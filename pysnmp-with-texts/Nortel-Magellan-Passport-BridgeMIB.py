#
# PySNMP MIB module Nortel-Magellan-Passport-BridgeMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-BridgeMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
InterfaceIndex, Integer32, Gauge32, MacAddress, RowStatus, Counter32, BridgeId, Unsigned32, DisplayString, StorageType = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "InterfaceIndex", "Integer32", "Gauge32", "MacAddress", "RowStatus", "Counter32", "BridgeId", "Unsigned32", "DisplayString", "StorageType")
HexString, Hex, AsciiStringIndex, AsciiString, DashedHexString, NonReplicated, Link = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "HexString", "Hex", "AsciiStringIndex", "AsciiString", "DashedHexString", "NonReplicated", "Link")
components, passportMIBs = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "components", "passportMIBs")
vrPpIndex, vrIndex, vr, vrPp = mibBuilder.importSymbols("Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex", "vrIndex", "vr", "vrPp")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Bits, Gauge32, iso, TimeTicks, ModuleIdentity, Counter64, Counter32, NotificationType, Unsigned32, IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Bits", "Gauge32", "iso", "TimeTicks", "ModuleIdentity", "Counter64", "Counter32", "NotificationType", "Unsigned32", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
bridgeMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25))
vrPpTbcl = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2))
vrPpTbclRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 1), )
if mibBuilder.loadTexts: vrPpTbclRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpTbcl components.')
vrPpTbclRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclRowStatusEntry.setDescription('A single entry in the table represents a single vrPpTbcl component.')
vrPpTbclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpTbcl components. These components can be added and deleted.')
vrPpTbclComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpTbclStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStorageType.setDescription('This variable represents the storage type value for the vrPpTbcl tables.')
vrPpTbclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpTbclIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclIndex.setDescription('This variable represents the index for the vrPpTbcl tables.')
vrPpTbclProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 10), )
if mibBuilder.loadTexts: vrPpTbclProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpTbclProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclProvEntry.setDescription('An entry in the vrPpTbclProvTable.')
vrPpTbclTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpTbclFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpTbclServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpTbclConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpTbclPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpTbclOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpTbclTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 11), )
if mibBuilder.loadTexts: vrPpTbclTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
vrPpTbclTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclTbProvEntry.setDescription('An entry in the vrPpTbclTbProvTable.')
vrPpTbclSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
vrPpTbclStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 12), )
if mibBuilder.loadTexts: vrPpTbclStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpTbclStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStpProvEntry.setDescription('An entry in the vrPpTbclStpProvTable.')
vrPpTbclAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpTbclPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpTbclStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpTbclPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpTbclPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpTbclPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpTbclDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 13), )
if mibBuilder.loadTexts: vrPpTbclDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpTbclDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDIProvEntry.setDescription('An entry in the vrPpTbclDIProvTable.')
vrPpTbclDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpTbclPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpTbclStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 14), )
if mibBuilder.loadTexts: vrPpTbclStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpTbclStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStateEntry.setDescription('An entry in the vrPpTbclStateTable.')
vrPpTbclAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpTbclOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpTbclUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpTbclOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 15), )
if mibBuilder.loadTexts: vrPpTbclOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpTbclOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclOperStatusEntry.setDescription('An entry in the vrPpTbclOperStatusTable.')
vrPpTbclSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpTbclOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16), )
if mibBuilder.loadTexts: vrPpTbclOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpTbclOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclOperEntry.setDescription('An entry in the vrPpTbclOperTable.')
vrPpTbclPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpTbclUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpTbclDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpTbclBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpTbclBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpTbclBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpTbclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpTbclDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpTbclMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpTbclTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17), )
if mibBuilder.loadTexts: vrPpTbclTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
vrPpTbclTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclTbOperEntry.setDescription('An entry in the vrPpTbclTbOperTable.')
vrPpTbclMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
vrPpTbclBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
vrPpTbclUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
vrPpTbclStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
vrPpTbclDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
vrPpTbclLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
vrPpTbclInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
vrPpTbclInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
vrPpTbclOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
vrPpTbclStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18), )
if mibBuilder.loadTexts: vrPpTbclStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpTbclStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStpOperEntry.setDescription('An entry in the vrPpTbclStpOperTable.')
vrPpTbclStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpTbclStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpTbclDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpTbclPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpTbclDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpTbclDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpTbclForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpTbclBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpTbclDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpTbclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 19), )
if mibBuilder.loadTexts: vrPpTbclStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpTbclStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"))
if mibBuilder.loadTexts: vrPpTbclStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclStatsEntry.setDescription('An entry in the vrPpTbclStatsTable.')
vrPpTbclBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpTbclTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpTbclTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpTbclInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpTbclOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpTbclNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2))
vrPpTbclNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 1), )
if mibBuilder.loadTexts: vrPpTbclNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpTbclNs components.')
vrPpTbclNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclNsIndex"))
if mibBuilder.loadTexts: vrPpTbclNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsRowStatusEntry.setDescription('A single entry in the table represents a single vrPpTbclNs component.')
vrPpTbclNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpTbclNs components. These components can be added and deleted.')
vrPpTbclNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpTbclNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbclNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsStorageType.setDescription('This variable represents the storage type value for the vrPpTbclNs tables.')
vrPpTbclNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpTbclNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsIndex.setDescription('This variable represents the index for the vrPpTbclNs tables.')
vrPpTbclNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 10), )
if mibBuilder.loadTexts: vrPpTbclNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
vrPpTbclNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbclNsIndex"))
if mibBuilder.loadTexts: vrPpTbclNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsProvEntry.setDescription('An entry in the vrPpTbclNsProvTable.')
vrPpTbclNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
vrPpTbclNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 2, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbclNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbclNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
vrPpFddiETB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3))
vrPpFddiETBRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 1), )
if mibBuilder.loadTexts: vrPpFddiETBRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpFddiETB components.')
vrPpFddiETBRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBRowStatusEntry.setDescription('A single entry in the table represents a single vrPpFddiETB component.')
vrPpFddiETBRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpFddiETB components. These components can be added and deleted.')
vrPpFddiETBComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpFddiETBStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStorageType.setDescription('This variable represents the storage type value for the vrPpFddiETB tables.')
vrPpFddiETBIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpFddiETBIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBIndex.setDescription('This variable represents the index for the vrPpFddiETB tables.')
vrPpFddiETBProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 10), )
if mibBuilder.loadTexts: vrPpFddiETBProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpFddiETBProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBProvEntry.setDescription('An entry in the vrPpFddiETBProvTable.')
vrPpFddiETBTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpFddiETBFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpFddiETBServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpFddiETBConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpFddiETBPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpFddiETBOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpFddiETBTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 11), )
if mibBuilder.loadTexts: vrPpFddiETBTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
vrPpFddiETBTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBTbProvEntry.setDescription('An entry in the vrPpFddiETBTbProvTable.')
vrPpFddiETBSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
vrPpFddiETBStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 12), )
if mibBuilder.loadTexts: vrPpFddiETBStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpFddiETBStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStpProvEntry.setDescription('An entry in the vrPpFddiETBStpProvTable.')
vrPpFddiETBAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpFddiETBPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpFddiETBStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpFddiETBPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpFddiETBPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpFddiETBPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpFddiETBDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 13), )
if mibBuilder.loadTexts: vrPpFddiETBDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpFddiETBDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDIProvEntry.setDescription('An entry in the vrPpFddiETBDIProvTable.')
vrPpFddiETBDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpFddiETBPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpFddiETBStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 14), )
if mibBuilder.loadTexts: vrPpFddiETBStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpFddiETBStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStateEntry.setDescription('An entry in the vrPpFddiETBStateTable.')
vrPpFddiETBAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpFddiETBOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpFddiETBUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpFddiETBOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 15), )
if mibBuilder.loadTexts: vrPpFddiETBOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpFddiETBOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBOperStatusEntry.setDescription('An entry in the vrPpFddiETBOperStatusTable.')
vrPpFddiETBSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpFddiETBOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16), )
if mibBuilder.loadTexts: vrPpFddiETBOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpFddiETBOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBOperEntry.setDescription('An entry in the vrPpFddiETBOperTable.')
vrPpFddiETBPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpFddiETBUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpFddiETBDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpFddiETBBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpFddiETBBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpFddiETBBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpFddiETBIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpFddiETBDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpFddiETBMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpFddiETBTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17), )
if mibBuilder.loadTexts: vrPpFddiETBTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
vrPpFddiETBTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBTbOperEntry.setDescription('An entry in the vrPpFddiETBTbOperTable.')
vrPpFddiETBMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
vrPpFddiETBBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
vrPpFddiETBDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
vrPpFddiETBInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18), )
if mibBuilder.loadTexts: vrPpFddiETBStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpFddiETBStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStpOperEntry.setDescription('An entry in the vrPpFddiETBStpOperTable.')
vrPpFddiETBStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpFddiETBStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpFddiETBDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpFddiETBPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpFddiETBDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpFddiETBDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpFddiETBForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpFddiETBBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpFddiETBStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 19), )
if mibBuilder.loadTexts: vrPpFddiETBStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpFddiETBStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"))
if mibBuilder.loadTexts: vrPpFddiETBStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBStatsEntry.setDescription('An entry in the vrPpFddiETBStatsTable.')
vrPpFddiETBBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpFddiETBTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpFddiETBInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpFddiETBNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2))
vrPpFddiETBNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 1), )
if mibBuilder.loadTexts: vrPpFddiETBNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpFddiETBNs components.')
vrPpFddiETBNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBNsIndex"))
if mibBuilder.loadTexts: vrPpFddiETBNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsRowStatusEntry.setDescription('A single entry in the table represents a single vrPpFddiETBNs component.')
vrPpFddiETBNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpFddiETBNs components. These components can be added and deleted.')
vrPpFddiETBNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpFddiETBNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpFddiETBNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsStorageType.setDescription('This variable represents the storage type value for the vrPpFddiETBNs tables.')
vrPpFddiETBNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpFddiETBNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsIndex.setDescription('This variable represents the index for the vrPpFddiETBNs tables.')
vrPpFddiETBNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 10), )
if mibBuilder.loadTexts: vrPpFddiETBNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
vrPpFddiETBNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpFddiETBNsIndex"))
if mibBuilder.loadTexts: vrPpFddiETBNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsProvEntry.setDescription('An entry in the vrPpFddiETBNsProvTable.')
vrPpFddiETBNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
vrPpFddiETBNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 3, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpFddiETBNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpFddiETBNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
vrPpTbp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4))
vrPpTbpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 1), )
if mibBuilder.loadTexts: vrPpTbpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpTbp components.')
vrPpTbpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpRowStatusEntry.setDescription('A single entry in the table represents a single vrPpTbp component.')
vrPpTbpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpTbp components. These components can be added and deleted.')
vrPpTbpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpTbpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStorageType.setDescription('This variable represents the storage type value for the vrPpTbp tables.')
vrPpTbpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpTbpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpIndex.setDescription('This variable represents the index for the vrPpTbp tables.')
vrPpTbpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 10), )
if mibBuilder.loadTexts: vrPpTbpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpTbpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpProvEntry.setDescription('An entry in the vrPpTbpProvTable.')
vrPpTbpTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpTbpFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpTbpServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpTbpConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpTbpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpTbpOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpTbpTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 11), )
if mibBuilder.loadTexts: vrPpTbpTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
vrPpTbpTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpTbProvEntry.setDescription('An entry in the vrPpTbpTbProvTable.')
vrPpTbpSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
vrPpTbpStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 12), )
if mibBuilder.loadTexts: vrPpTbpStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpTbpStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStpProvEntry.setDescription('An entry in the vrPpTbpStpProvTable.')
vrPpTbpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpTbpPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpTbpStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpTbpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpTbpPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpTbpPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpTbpDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 13), )
if mibBuilder.loadTexts: vrPpTbpDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpTbpDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDIProvEntry.setDescription('An entry in the vrPpTbpDIProvTable.')
vrPpTbpDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpTbpPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpTbpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 14), )
if mibBuilder.loadTexts: vrPpTbpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpTbpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStateEntry.setDescription('An entry in the vrPpTbpStateTable.')
vrPpTbpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpTbpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpTbpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpTbpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 15), )
if mibBuilder.loadTexts: vrPpTbpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpTbpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpOperStatusEntry.setDescription('An entry in the vrPpTbpOperStatusTable.')
vrPpTbpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpTbpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16), )
if mibBuilder.loadTexts: vrPpTbpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpTbpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpOperEntry.setDescription('An entry in the vrPpTbpOperTable.')
vrPpTbpPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpTbpUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpTbpDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpTbpBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpTbpBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpTbpBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpTbpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpTbpDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpTbpMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpTbpTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17), )
if mibBuilder.loadTexts: vrPpTbpTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
vrPpTbpTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpTbOperEntry.setDescription('An entry in the vrPpTbpTbOperTable.')
vrPpTbpMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
vrPpTbpBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
vrPpTbpUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
vrPpTbpStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
vrPpTbpDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
vrPpTbpLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
vrPpTbpInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
vrPpTbpInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
vrPpTbpOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
vrPpTbpStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18), )
if mibBuilder.loadTexts: vrPpTbpStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpTbpStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStpOperEntry.setDescription('An entry in the vrPpTbpStpOperTable.')
vrPpTbpStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpTbpStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpTbpDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpTbpPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpTbpDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpTbpDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpTbpForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpTbpBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpTbpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpTbpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 19), )
if mibBuilder.loadTexts: vrPpTbpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpTbpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"))
if mibBuilder.loadTexts: vrPpTbpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpStatsEntry.setDescription('An entry in the vrPpTbpStatsTable.')
vrPpTbpBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpTbpTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpTbpTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpTbpInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpTbpOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpTbpNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2))
vrPpTbpNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 1), )
if mibBuilder.loadTexts: vrPpTbpNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpTbpNs components.')
vrPpTbpNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpNsIndex"))
if mibBuilder.loadTexts: vrPpTbpNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsRowStatusEntry.setDescription('A single entry in the table represents a single vrPpTbpNs component.')
vrPpTbpNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpTbpNs components. These components can be added and deleted.')
vrPpTbpNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpTbpNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbpNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsStorageType.setDescription('This variable represents the storage type value for the vrPpTbpNs tables.')
vrPpTbpNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpTbpNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsIndex.setDescription('This variable represents the index for the vrPpTbpNs tables.')
vrPpTbpNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 10), )
if mibBuilder.loadTexts: vrPpTbpNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
vrPpTbpNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbpNsIndex"))
if mibBuilder.loadTexts: vrPpTbpNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsProvEntry.setDescription('An entry in the vrPpTbpNsProvTable.')
vrPpTbpNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
vrPpTbpNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 4, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbpNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbpNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
vrPpSrBp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8))
vrPpSrBpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 1), )
if mibBuilder.loadTexts: vrPpSrBpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpSrBp components.')
vrPpSrBpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpRowStatusEntry.setDescription('A single entry in the table represents a single vrPpSrBp component.')
vrPpSrBpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpSrBp components. These components can be added and deleted.')
vrPpSrBpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpSrBpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStorageType.setDescription('This variable represents the storage type value for the vrPpSrBp tables.')
vrPpSrBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpSrBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpIndex.setDescription('This variable represents the index for the vrPpSrBp tables.')
vrPpSrBpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 10), )
if mibBuilder.loadTexts: vrPpSrBpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpSrBpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpProvEntry.setDescription('An entry in the vrPpSrBpProvTable.')
vrPpSrBpTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpSrBpFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpSrBpServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpSrBpConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpSrBpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpSrBpOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpSrBpStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 12), )
if mibBuilder.loadTexts: vrPpSrBpStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpSrBpStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStpProvEntry.setDescription('An entry in the vrPpSrBpStpProvTable.')
vrPpSrBpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpSrBpPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpSrBpStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpSrBpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpSrBpPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpSrBpPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpSrBpDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 13), )
if mibBuilder.loadTexts: vrPpSrBpDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpSrBpDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDIProvEntry.setDescription('An entry in the vrPpSrBpDIProvTable.')
vrPpSrBpDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpSrBpPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpSrBpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 14), )
if mibBuilder.loadTexts: vrPpSrBpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpSrBpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStateEntry.setDescription('An entry in the vrPpSrBpStateTable.')
vrPpSrBpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpSrBpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpSrBpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpSrBpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 15), )
if mibBuilder.loadTexts: vrPpSrBpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpSrBpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpOperStatusEntry.setDescription('An entry in the vrPpSrBpOperStatusTable.')
vrPpSrBpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpSrBpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16), )
if mibBuilder.loadTexts: vrPpSrBpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpSrBpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpOperEntry.setDescription('An entry in the vrPpSrBpOperTable.')
vrPpSrBpPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpSrBpUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpSrBpDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpSrBpBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpSrBpBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpSrBpBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpSrBpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpSrBpDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpSrBpMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpSrBpStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18), )
if mibBuilder.loadTexts: vrPpSrBpStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpSrBpStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStpOperEntry.setDescription('An entry in the vrPpSrBpStpOperTable.')
vrPpSrBpStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpSrBpStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpSrBpDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpSrBpPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpSrBpDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpSrBpDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpSrBpForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpSrBpBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpSrBpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpSrBpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 19), )
if mibBuilder.loadTexts: vrPpSrBpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpSrBpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStatsEntry.setDescription('An entry in the vrPpSrBpStatsTable.')
vrPpSrBpBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpSrBpTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpSrBpTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpSrBpInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrBpOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrBpSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20), )
if mibBuilder.loadTexts: vrPpSrBpSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
vrPpSrBpSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSrProvEntry.setDescription('An entry in the vrPpSrBpSrProvTable.')
vrPpSrBpHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
vrPpSrBpExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
vrPpSrBpLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrBpInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrBpBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
vrPpSrBpLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
vrPpSrBpSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
vrPpSrBpAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
vrPpSrBpSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
vrPpSrBpSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21), )
if mibBuilder.loadTexts: vrPpSrBpSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
vrPpSrBpSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"))
if mibBuilder.loadTexts: vrPpSrBpSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSrStatsEntry.setDescription('An entry in the vrPpSrBpSrStatsTable.')
vrPpSrBpSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrBpApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrBpSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrBpNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2))
vrPpSrBpNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 1), )
if mibBuilder.loadTexts: vrPpSrBpNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpSrBpNs components.')
vrPpSrBpNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpNsIndex"))
if mibBuilder.loadTexts: vrPpSrBpNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsRowStatusEntry.setDescription('A single entry in the table represents a single vrPpSrBpNs component.')
vrPpSrBpNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpSrBpNs components. These components can be added and deleted.')
vrPpSrBpNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpSrBpNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrBpNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsStorageType.setDescription('This variable represents the storage type value for the vrPpSrBpNs tables.')
vrPpSrBpNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpSrBpNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsIndex.setDescription('This variable represents the index for the vrPpSrBpNs tables.')
vrPpSrBpNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 10), )
if mibBuilder.loadTexts: vrPpSrBpNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
vrPpSrBpNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrBpNsIndex"))
if mibBuilder.loadTexts: vrPpSrBpNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsProvEntry.setDescription('An entry in the vrPpSrBpNsProvTable.')
vrPpSrBpNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
vrPpSrBpNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 8, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrBpNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrBpNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
vrPpSrtBp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9))
vrPpSrtBpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 1), )
if mibBuilder.loadTexts: vrPpSrtBpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpSrtBp components.')
vrPpSrtBpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpRowStatusEntry.setDescription('A single entry in the table represents a single vrPpSrtBp component.')
vrPpSrtBpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpSrtBp components. These components can be added and deleted.')
vrPpSrtBpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpSrtBpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStorageType.setDescription('This variable represents the storage type value for the vrPpSrtBp tables.')
vrPpSrtBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpSrtBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpIndex.setDescription('This variable represents the index for the vrPpSrtBp tables.')
vrPpSrtBpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 10), )
if mibBuilder.loadTexts: vrPpSrtBpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpSrtBpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpProvEntry.setDescription('An entry in the vrPpSrtBpProvTable.')
vrPpSrtBpTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpSrtBpFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpSrtBpServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpSrtBpConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpSrtBpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpSrtBpOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpSrtBpTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 11), )
if mibBuilder.loadTexts: vrPpSrtBpTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
vrPpSrtBpTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpTbProvEntry.setDescription('An entry in the vrPpSrtBpTbProvTable.')
vrPpSrtBpSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
vrPpSrtBpStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 12), )
if mibBuilder.loadTexts: vrPpSrtBpStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpSrtBpStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStpProvEntry.setDescription('An entry in the vrPpSrtBpStpProvTable.')
vrPpSrtBpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpSrtBpPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpSrtBpStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpSrtBpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpSrtBpPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpSrtBpPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpSrtBpDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 13), )
if mibBuilder.loadTexts: vrPpSrtBpDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpSrtBpDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDIProvEntry.setDescription('An entry in the vrPpSrtBpDIProvTable.')
vrPpSrtBpDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpSrtBpPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpSrtBpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 14), )
if mibBuilder.loadTexts: vrPpSrtBpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpSrtBpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStateEntry.setDescription('An entry in the vrPpSrtBpStateTable.')
vrPpSrtBpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpSrtBpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpSrtBpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpSrtBpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 15), )
if mibBuilder.loadTexts: vrPpSrtBpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpSrtBpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpOperStatusEntry.setDescription('An entry in the vrPpSrtBpOperStatusTable.')
vrPpSrtBpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpSrtBpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16), )
if mibBuilder.loadTexts: vrPpSrtBpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpSrtBpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpOperEntry.setDescription('An entry in the vrPpSrtBpOperTable.')
vrPpSrtBpPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpSrtBpUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpSrtBpDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpSrtBpBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpSrtBpBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpSrtBpBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpSrtBpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpSrtBpDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpSrtBpMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpSrtBpTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17), )
if mibBuilder.loadTexts: vrPpSrtBpTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
vrPpSrtBpTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpTbOperEntry.setDescription('An entry in the vrPpSrtBpTbOperTable.')
vrPpSrtBpMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
vrPpSrtBpBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
vrPpSrtBpDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
vrPpSrtBpInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18), )
if mibBuilder.loadTexts: vrPpSrtBpStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpSrtBpStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStpOperEntry.setDescription('An entry in the vrPpSrtBpStpOperTable.')
vrPpSrtBpStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpSrtBpStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpSrtBpDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpSrtBpPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpSrtBpDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpSrtBpDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpSrtBpForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpSrtBpBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpSrtBpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 19), )
if mibBuilder.loadTexts: vrPpSrtBpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpSrtBpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStatsEntry.setDescription('An entry in the vrPpSrtBpStatsTable.')
vrPpSrtBpBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpSrtBpTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpSrtBpInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrtBpSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20), )
if mibBuilder.loadTexts: vrPpSrtBpSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
vrPpSrtBpSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSrProvEntry.setDescription('An entry in the vrPpSrtBpSrProvTable.')
vrPpSrtBpHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
vrPpSrtBpExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
vrPpSrtBpLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrtBpInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrtBpBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
vrPpSrtBpLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
vrPpSrtBpSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
vrPpSrtBpAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
vrPpSrtBpSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
vrPpSrtBpSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21), )
if mibBuilder.loadTexts: vrPpSrtBpSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
vrPpSrtBpSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"))
if mibBuilder.loadTexts: vrPpSrtBpSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSrStatsEntry.setDescription('An entry in the vrPpSrtBpSrStatsTable.')
vrPpSrtBpSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrtBpApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrtBpSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrtBpNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2))
vrPpSrtBpNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 1), )
if mibBuilder.loadTexts: vrPpSrtBpNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpSrtBpNs components.')
vrPpSrtBpNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpNsIndex"))
if mibBuilder.loadTexts: vrPpSrtBpNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsRowStatusEntry.setDescription('A single entry in the table represents a single vrPpSrtBpNs component.')
vrPpSrtBpNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpSrtBpNs components. These components can be added and deleted.')
vrPpSrtBpNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpSrtBpNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrtBpNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsStorageType.setDescription('This variable represents the storage type value for the vrPpSrtBpNs tables.')
vrPpSrtBpNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpSrtBpNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsIndex.setDescription('This variable represents the index for the vrPpSrtBpNs tables.')
vrPpSrtBpNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 10), )
if mibBuilder.loadTexts: vrPpSrtBpNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
vrPpSrtBpNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrtBpNsIndex"))
if mibBuilder.loadTexts: vrPpSrtBpNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsProvEntry.setDescription('An entry in the vrPpSrtBpNsProvTable.')
vrPpSrtBpNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
vrPpSrtBpNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 9, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrtBpNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrtBpNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
vrPpSrse = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10))
vrPpSrseRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 1), )
if mibBuilder.loadTexts: vrPpSrseRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpSrse components.')
vrPpSrseRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseRowStatusEntry.setDescription('A single entry in the table represents a single vrPpSrse component.')
vrPpSrseRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpSrse components. These components can be added and deleted.')
vrPpSrseComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpSrseStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStorageType.setDescription('This variable represents the storage type value for the vrPpSrse tables.')
vrPpSrseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpSrseIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseIndex.setDescription('This variable represents the index for the vrPpSrse tables.')
vrPpSrseProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 10), )
if mibBuilder.loadTexts: vrPpSrseProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpSrseProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseProvEntry.setDescription('An entry in the vrPpSrseProvTable.')
vrPpSrseTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpSrseFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpSrseServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpSrseConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpSrsePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsePortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpSrseOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpSrseStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 12), )
if mibBuilder.loadTexts: vrPpSrseStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpSrseStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStpProvEntry.setDescription('An entry in the vrPpSrseStpProvTable.')
vrPpSrseAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpSrsePortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsePortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsePortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpSrseStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpSrsePortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsePortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsePortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpSrsePathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsePathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsePathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpSrsePathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsePathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsePathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpSrseDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 13), )
if mibBuilder.loadTexts: vrPpSrseDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpSrseDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDIProvEntry.setDescription('An entry in the vrPpSrseDIProvTable.')
vrPpSrseDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpSrsePreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsePreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsePreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpSrseStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 14), )
if mibBuilder.loadTexts: vrPpSrseStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpSrseStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStateEntry.setDescription('An entry in the vrPpSrseStateTable.')
vrPpSrseAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpSrseOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpSrseUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpSrseOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 15), )
if mibBuilder.loadTexts: vrPpSrseOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpSrseOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseOperStatusEntry.setDescription('An entry in the vrPpSrseOperStatusTable.')
vrPpSrseSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpSrseOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16), )
if mibBuilder.loadTexts: vrPpSrseOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpSrseOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseOperEntry.setDescription('An entry in the vrPpSrseOperTable.')
vrPpSrsePortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsePortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsePortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpSrseUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpSrseDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpSrseBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpSrseBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpSrseBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpSrseIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpSrseDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpSrseMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpSrseStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18), )
if mibBuilder.loadTexts: vrPpSrseStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpSrseStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStpOperEntry.setDescription('An entry in the vrPpSrseStpOperTable.')
vrPpSrseStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpSrseStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpSrseDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpSrsePathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsePathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsePathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpSrseDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpSrseDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpSrseForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpSrseBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpSrseDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpSrseStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 19), )
if mibBuilder.loadTexts: vrPpSrseStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpSrseStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStatsEntry.setDescription('An entry in the vrPpSrseStatsTable.')
vrPpSrseBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpSrseTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpSrseTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpSrseInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrseOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrseSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20), )
if mibBuilder.loadTexts: vrPpSrseSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
vrPpSrseSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSrProvEntry.setDescription('An entry in the vrPpSrseSrProvTable.')
vrPpSrseHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
vrPpSrseExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
vrPpSrseLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrseInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrseBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
vrPpSrseLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
vrPpSrseSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
vrPpSrseAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
vrPpSrseSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrseSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
vrPpSrseSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21), )
if mibBuilder.loadTexts: vrPpSrseSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
vrPpSrseSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrseIndex"))
if mibBuilder.loadTexts: vrPpSrseSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSrStatsEntry.setDescription('An entry in the vrPpSrseSrStatsTable.')
vrPpSrseSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrseApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrseSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrseDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 10, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrseDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrseDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpTbse = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11))
vrPpTbseRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 1), )
if mibBuilder.loadTexts: vrPpTbseRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpTbse components.')
vrPpTbseRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseRowStatusEntry.setDescription('A single entry in the table represents a single vrPpTbse component.')
vrPpTbseRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpTbse components. These components can be added and deleted.')
vrPpTbseComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpTbseStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStorageType.setDescription('This variable represents the storage type value for the vrPpTbse tables.')
vrPpTbseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpTbseIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseIndex.setDescription('This variable represents the index for the vrPpTbse tables.')
vrPpTbseProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 10), )
if mibBuilder.loadTexts: vrPpTbseProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpTbseProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseProvEntry.setDescription('An entry in the vrPpTbseProvTable.')
vrPpTbseTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpTbseFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpTbseServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpTbseConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpTbsePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsePortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpTbseOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpTbseTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 11), )
if mibBuilder.loadTexts: vrPpTbseTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
vrPpTbseTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseTbProvEntry.setDescription('An entry in the vrPpTbseTbProvTable.')
vrPpTbseSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
vrPpTbseStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 12), )
if mibBuilder.loadTexts: vrPpTbseStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpTbseStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStpProvEntry.setDescription('An entry in the vrPpTbseStpProvTable.')
vrPpTbseAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpTbsePortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsePortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsePortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpTbseStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpTbsePortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsePortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsePortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpTbsePathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsePathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsePathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpTbsePathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsePathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsePathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpTbseDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 13), )
if mibBuilder.loadTexts: vrPpTbseDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpTbseDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDIProvEntry.setDescription('An entry in the vrPpTbseDIProvTable.')
vrPpTbseDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbseDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpTbsePreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsePreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsePreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpTbseStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 14), )
if mibBuilder.loadTexts: vrPpTbseStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpTbseStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStateEntry.setDescription('An entry in the vrPpTbseStateTable.')
vrPpTbseAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpTbseOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpTbseUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpTbseOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 15), )
if mibBuilder.loadTexts: vrPpTbseOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpTbseOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseOperStatusEntry.setDescription('An entry in the vrPpTbseOperStatusTable.')
vrPpTbseSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpTbseOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16), )
if mibBuilder.loadTexts: vrPpTbseOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpTbseOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseOperEntry.setDescription('An entry in the vrPpTbseOperTable.')
vrPpTbsePortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsePortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsePortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpTbseUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpTbseDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpTbseBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpTbseBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpTbseBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpTbseIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpTbseDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpTbseMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpTbseTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17), )
if mibBuilder.loadTexts: vrPpTbseTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
vrPpTbseTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseTbOperEntry.setDescription('An entry in the vrPpTbseTbOperTable.')
vrPpTbseMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
vrPpTbseBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
vrPpTbseUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
vrPpTbseStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
vrPpTbseDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
vrPpTbseLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
vrPpTbseInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
vrPpTbseInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
vrPpTbseOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
vrPpTbseStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18), )
if mibBuilder.loadTexts: vrPpTbseStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpTbseStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStpOperEntry.setDescription('An entry in the vrPpTbseStpOperTable.')
vrPpTbseStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpTbseStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpTbseDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpTbsePathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsePathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsePathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpTbseDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpTbseDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpTbseForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpTbseBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpTbseDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpTbseStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 19), )
if mibBuilder.loadTexts: vrPpTbseStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpTbseStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbseIndex"))
if mibBuilder.loadTexts: vrPpTbseStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseStatsEntry.setDescription('An entry in the vrPpTbseStatsTable.')
vrPpTbseBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpTbseTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpTbseTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpTbseInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpTbseOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 11, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbseOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbseOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrsg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12))
vrPpSrsgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 1), )
if mibBuilder.loadTexts: vrPpSrsgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpSrsg components.')
vrPpSrsgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgRowStatusEntry.setDescription('A single entry in the table represents a single vrPpSrsg component.')
vrPpSrsgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpSrsg components. These components can be added and deleted.')
vrPpSrsgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpSrsgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStorageType.setDescription('This variable represents the storage type value for the vrPpSrsg tables.')
vrPpSrsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpSrsgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgIndex.setDescription('This variable represents the index for the vrPpSrsg tables.')
vrPpSrsgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 10), )
if mibBuilder.loadTexts: vrPpSrsgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpSrsgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgProvEntry.setDescription('An entry in the vrPpSrsgProvTable.')
vrPpSrsgTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpSrsgFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpSrsgServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpSrsgConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpSrsgPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpSrsgOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpSrsgStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 12), )
if mibBuilder.loadTexts: vrPpSrsgStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpSrsgStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStpProvEntry.setDescription('An entry in the vrPpSrsgStpProvTable.')
vrPpSrsgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpSrsgPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpSrsgStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpSrsgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpSrsgPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpSrsgPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpSrsgDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 13), )
if mibBuilder.loadTexts: vrPpSrsgDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpSrsgDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDIProvEntry.setDescription('An entry in the vrPpSrsgDIProvTable.')
vrPpSrsgDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpSrsgPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpSrsgStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 14), )
if mibBuilder.loadTexts: vrPpSrsgStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpSrsgStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStateEntry.setDescription('An entry in the vrPpSrsgStateTable.')
vrPpSrsgAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpSrsgOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpSrsgUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpSrsgOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 15), )
if mibBuilder.loadTexts: vrPpSrsgOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpSrsgOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgOperStatusEntry.setDescription('An entry in the vrPpSrsgOperStatusTable.')
vrPpSrsgSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpSrsgOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16), )
if mibBuilder.loadTexts: vrPpSrsgOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpSrsgOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgOperEntry.setDescription('An entry in the vrPpSrsgOperTable.')
vrPpSrsgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpSrsgUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpSrsgDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpSrsgBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpSrsgBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpSrsgBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpSrsgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpSrsgDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpSrsgMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpSrsgStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18), )
if mibBuilder.loadTexts: vrPpSrsgStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpSrsgStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStpOperEntry.setDescription('An entry in the vrPpSrsgStpOperTable.')
vrPpSrsgStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpSrsgStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpSrsgDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpSrsgPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpSrsgDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpSrsgDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpSrsgForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpSrsgBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpSrsgDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpSrsgStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 19), )
if mibBuilder.loadTexts: vrPpSrsgStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpSrsgStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStatsEntry.setDescription('An entry in the vrPpSrsgStatsTable.')
vrPpSrsgBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpSrsgTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpSrsgTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpSrsgInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrsgOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrsgSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20), )
if mibBuilder.loadTexts: vrPpSrsgSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
vrPpSrsgSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSrProvEntry.setDescription('An entry in the vrPpSrsgSrProvTable.')
vrPpSrsgHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
vrPpSrsgExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
vrPpSrsgLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrsgInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrsgBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
vrPpSrsgLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
vrPpSrsgSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
vrPpSrsgAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
vrPpSrsgSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrsgSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
vrPpSrsgSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21), )
if mibBuilder.loadTexts: vrPpSrsgSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
vrPpSrsgSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrsgIndex"))
if mibBuilder.loadTexts: vrPpSrsgSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSrStatsEntry.setDescription('An entry in the vrPpSrsgSrStatsTable.')
vrPpSrsgSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrsgApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrsgSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrsgDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 12, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrsgDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrsgDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpTbsg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13))
vrPpTbsgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 1), )
if mibBuilder.loadTexts: vrPpTbsgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpTbsg components.')
vrPpTbsgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgRowStatusEntry.setDescription('A single entry in the table represents a single vrPpTbsg component.')
vrPpTbsgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpTbsg components. These components can be added and deleted.')
vrPpTbsgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpTbsgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStorageType.setDescription('This variable represents the storage type value for the vrPpTbsg tables.')
vrPpTbsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpTbsgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgIndex.setDescription('This variable represents the index for the vrPpTbsg tables.')
vrPpTbsgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 10), )
if mibBuilder.loadTexts: vrPpTbsgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpTbsgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgProvEntry.setDescription('An entry in the vrPpTbsgProvTable.')
vrPpTbsgTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpTbsgFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpTbsgServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpTbsgConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpTbsgPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpTbsgOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpTbsgTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 11), )
if mibBuilder.loadTexts: vrPpTbsgTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
vrPpTbsgTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgTbProvEntry.setDescription('An entry in the vrPpTbsgTbProvTable.')
vrPpTbsgSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
vrPpTbsgStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 12), )
if mibBuilder.loadTexts: vrPpTbsgStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpTbsgStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStpProvEntry.setDescription('An entry in the vrPpTbsgStpProvTable.')
vrPpTbsgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpTbsgPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpTbsgStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpTbsgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpTbsgPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpTbsgPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpTbsgDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 13), )
if mibBuilder.loadTexts: vrPpTbsgDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpTbsgDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDIProvEntry.setDescription('An entry in the vrPpTbsgDIProvTable.')
vrPpTbsgDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpTbsgPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpTbsgPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpTbsgStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 14), )
if mibBuilder.loadTexts: vrPpTbsgStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpTbsgStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStateEntry.setDescription('An entry in the vrPpTbsgStateTable.')
vrPpTbsgAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpTbsgOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpTbsgUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpTbsgOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 15), )
if mibBuilder.loadTexts: vrPpTbsgOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpTbsgOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgOperStatusEntry.setDescription('An entry in the vrPpTbsgOperStatusTable.')
vrPpTbsgSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpTbsgOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16), )
if mibBuilder.loadTexts: vrPpTbsgOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpTbsgOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgOperEntry.setDescription('An entry in the vrPpTbsgOperTable.')
vrPpTbsgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpTbsgUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpTbsgDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpTbsgBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpTbsgBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpTbsgBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpTbsgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpTbsgDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpTbsgMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpTbsgTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17), )
if mibBuilder.loadTexts: vrPpTbsgTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
vrPpTbsgTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgTbOperEntry.setDescription('An entry in the vrPpTbsgTbOperTable.')
vrPpTbsgMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
vrPpTbsgBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
vrPpTbsgUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
vrPpTbsgStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
vrPpTbsgDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
vrPpTbsgLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
vrPpTbsgInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
vrPpTbsgInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
vrPpTbsgOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
vrPpTbsgStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18), )
if mibBuilder.loadTexts: vrPpTbsgStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpTbsgStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStpOperEntry.setDescription('An entry in the vrPpTbsgStpOperTable.')
vrPpTbsgStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpTbsgStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpTbsgDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpTbsgPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpTbsgDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpTbsgDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpTbsgForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpTbsgBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpTbsgDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpTbsgStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 19), )
if mibBuilder.loadTexts: vrPpTbsgStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpTbsgStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpTbsgIndex"))
if mibBuilder.loadTexts: vrPpTbsgStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgStatsEntry.setDescription('An entry in the vrPpTbsgStatsTable.')
vrPpTbsgBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpTbsgTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpTbsgTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpTbsgInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpTbsgOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 13, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpTbsgOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpTbsgOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrcl = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14))
vrPpSrclRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 1), )
if mibBuilder.loadTexts: vrPpSrclRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpSrcl components.')
vrPpSrclRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclRowStatusEntry.setDescription('A single entry in the table represents a single vrPpSrcl component.')
vrPpSrclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpSrcl components. These components can be added and deleted.')
vrPpSrclComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpSrclStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStorageType.setDescription('This variable represents the storage type value for the vrPpSrcl tables.')
vrPpSrclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpSrclIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclIndex.setDescription('This variable represents the index for the vrPpSrcl tables.')
vrPpSrclProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 10), )
if mibBuilder.loadTexts: vrPpSrclProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
vrPpSrclProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclProvEntry.setDescription('An entry in the vrPpSrclProvTable.')
vrPpSrclTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
vrPpSrclFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
vrPpSrclServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
vrPpSrclConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
vrPpSrclPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
vrPpSrclOutboundFrameMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unaltered", 1), ("ethernetConv", 2))).clone('unaltered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclOutboundFrameMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclOutboundFrameMediaType.setDescription('This attribute specifies the media type the frame must be in before it is to be forwarded over the outbound supported WAN Bridge Protocol Port. The attribute only applies to outbound Bridge Protocol Port. For supported bridge ports, if the attribute value remains set to the default value of unaltered then there will be no frame conversion. When the value is set to the value ethernetConv then all frames being forwarded out the outbound WAN Port will be converted to ethernet before forwarding takes place. The only outbound WAN medias that currently support conversion are: FR (Frame Relay) and VNS. All other medias will fail the Bridge Port semantic check when attempts are made to alter this attribute. The following is an example of what the user may be able to do. Frames originating from a Token Ring are to be flooded out onto another Token Ring and a Frame Relay Port. The token ring Outbound port performs no translation, yet the FR Port has the outboundFrameMediaType attribute set to ethernetConv which results in the frame being translated into Ethernet format from Token Ring format before Frame Relay does its encapsulation and transmits over the FR port.')
vrPpSrclStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 12), )
if mibBuilder.loadTexts: vrPpSrclStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
vrPpSrclStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStpProvEntry.setDescription('An entry in the vrPpSrclStpProvTable.')
vrPpSrclAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
vrPpSrclPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
vrPpSrclStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
vrPpSrclPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
vrPpSrclPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
vrPpSrclPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
vrPpSrclDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 13), )
if mibBuilder.loadTexts: vrPpSrclDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
vrPpSrclDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDIProvEntry.setDescription('An entry in the vrPpSrclDIProvTable.')
vrPpSrclDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
vrPpSrclPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
vrPpSrclStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 14), )
if mibBuilder.loadTexts: vrPpSrclStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpSrclStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStateEntry.setDescription('An entry in the vrPpSrclStateTable.')
vrPpSrclAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpSrclOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpSrclUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpSrclOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 15), )
if mibBuilder.loadTexts: vrPpSrclOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpSrclOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclOperStatusEntry.setDescription('An entry in the vrPpSrclOperStatusTable.')
vrPpSrclSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpSrclOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16), )
if mibBuilder.loadTexts: vrPpSrclOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
vrPpSrclOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclOperEntry.setDescription('An entry in the vrPpSrclOperTable.')
vrPpSrclPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrPpSrclUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
vrPpSrclDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
vrPpSrclBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
vrPpSrclBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
vrPpSrclBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
vrPpSrclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
vrPpSrclDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
vrPpSrclMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
vrPpSrclStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18), )
if mibBuilder.loadTexts: vrPpSrclStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
vrPpSrclStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStpOperEntry.setDescription('An entry in the vrPpSrclStpOperTable.')
vrPpSrclStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
vrPpSrclStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
vrPpSrclDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
vrPpSrclPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
vrPpSrclDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
vrPpSrclDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
vrPpSrclForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
vrPpSrclBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
vrPpSrclDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
vrPpSrclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 19), )
if mibBuilder.loadTexts: vrPpSrclStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
vrPpSrclStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 19, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStatsEntry.setDescription('An entry in the vrPpSrclStatsTable.')
vrPpSrclBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
vrPpSrclTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
vrPpSrclTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
vrPpSrclInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrclOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
vrPpSrclSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20), )
if mibBuilder.loadTexts: vrPpSrclSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
vrPpSrclSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSrProvEntry.setDescription('An entry in the vrPpSrclSrProvTable.')
vrPpSrclHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
vrPpSrclExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
vrPpSrclLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrclInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
vrPpSrclBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
vrPpSrclLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
vrPpSrclSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
vrPpSrclAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
vrPpSrclSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
vrPpSrclSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21), )
if mibBuilder.loadTexts: vrPpSrclSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
vrPpSrclSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"))
if mibBuilder.loadTexts: vrPpSrclSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSrStatsEntry.setDescription('An entry in the vrPpSrclSrStatsTable.')
vrPpSrclSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrclApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
vrPpSrclSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
vrPpSrclNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2))
vrPpSrclNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 1), )
if mibBuilder.loadTexts: vrPpSrclNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpSrclNs components.')
vrPpSrclNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclNsIndex"))
if mibBuilder.loadTexts: vrPpSrclNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsRowStatusEntry.setDescription('A single entry in the table represents a single vrPpSrclNs component.')
vrPpSrclNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpSrclNs components. These components can be added and deleted.')
vrPpSrclNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpSrclNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpSrclNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsStorageType.setDescription('This variable represents the storage type value for the vrPpSrclNs tables.')
vrPpSrclNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpSrclNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsIndex.setDescription('This variable represents the index for the vrPpSrclNs tables.')
vrPpSrclNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 10), )
if mibBuilder.loadTexts: vrPpSrclNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
vrPpSrclNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrPpSrclNsIndex"))
if mibBuilder.loadTexts: vrPpSrclNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsProvEntry.setDescription('An entry in the vrPpSrclNsProvTable.')
vrPpSrclNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
vrPpSrclNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 14, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpSrclNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpSrclNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
vrBr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5))
vrBrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 1), )
if mibBuilder.loadTexts: vrBrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrRowStatusTable.setDescription('This entry controls the addition and deletion of vrBr components.')
vrBrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"))
if mibBuilder.loadTexts: vrBrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrRowStatusEntry.setDescription('A single entry in the table represents a single vrBr component.')
vrBrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBr components. These components can be added and deleted.')
vrBrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrStorageType.setDescription('This variable represents the storage type value for the vrBr tables.')
vrBrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrBrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrIndex.setDescription('This variable represents the index for the vrBr tables.')
vrBrAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 10), )
if mibBuilder.loadTexts: vrBrAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrBrAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"))
if mibBuilder.loadTexts: vrBrAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrAdminControlEntry.setDescription('An entry in the vrBrAdminControlTable.')
vrBrAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrAdminStatus.setDescription('This attribute defines the current administrative status for thiscomponent. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation. The application preserves all previously received provisioning data, all writable operational data and all counters. Please note that all learnt data are lost. The bridge application is not available for operation while in this state.')
vrBrStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 12), )
if mibBuilder.loadTexts: vrBrStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrBrStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"))
if mibBuilder.loadTexts: vrBrStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrStateEntry.setDescription('An entry in the vrBrStateTable.')
vrBrAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrBrOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrBrUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrBrOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 13), )
if mibBuilder.loadTexts: vrBrOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrBrOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"))
if mibBuilder.loadTexts: vrBrOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrOperStatusEntry.setDescription('An entry in the vrBrOperStatusTable.')
vrBrSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrBrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 14), )
if mibBuilder.loadTexts: vrBrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrOperTable.setDescription('This group houses all the operational attributes applicable to bridging, those components that are global in nature and are not port specific.')
vrBrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"))
if mibBuilder.loadTexts: vrBrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrOperEntry.setDescription('An entry in the vrBrOperTable.')
vrBrBridgeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 14, 1, 1), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrBridgeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrBridgeAddress.setDescription('This attribute represents the Mac address for the bridge. This address is used when this bridge must be referred to in a unique manner. It is used to form the bridge identifier, used by the spanning tree protocol, by concatenating it with the attribute bridgePriority under the component SpanningTreeProtocol.')
vrBrNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 14, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNumPorts.setDescription('This attribute is indicative of the number of ports this bridge controls. In other words, it is a count of the number of bridge ports provisioned.')
vrBrType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("transparentOnly", 2), ("sourceRouteOnly", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrType.setDescription('This attribute is indicative of the capability of this bridge unit in terms of types of bridging it can handle.')
vrBrPte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2))
vrBrPteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 1), )
if mibBuilder.loadTexts: vrBrPteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrBrPte components.')
vrBrPteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPteDomainNumIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPtePortNameIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPteModeIndex"))
if mibBuilder.loadTexts: vrBrPteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteRowStatusEntry.setDescription('A single entry in the table represents a single vrBrPte component.')
vrBrPteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrPte components. These components cannot be added nor deleted.')
vrBrPteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrPteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteStorageType.setDescription('This variable represents the storage type value for the vrBrPte tables.')
vrBrPteDomainNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: vrBrPteDomainNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteDomainNumIndex.setDescription('This variable represents an index for the vrBrPte tables.')
vrBrPtePortNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 1, 1, 11), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(0, 29)))
if mibBuilder.loadTexts: vrBrPtePortNameIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPtePortNameIndex.setDescription('This variable represents an index for the vrBrPte tables.')
vrBrPteModeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("tb", 2), ("sr", 3), ("srt", 4))))
if mibBuilder.loadTexts: vrBrPteModeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteModeIndex.setDescription('This variable represents an index for the vrBrPte tables.')
vrBrPteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 10), )
if mibBuilder.loadTexts: vrBrPteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the operational attributes belonging to the PortTableEntry component.')
vrBrPteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPteDomainNumIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPtePortNameIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPteModeIndex"))
if mibBuilder.loadTexts: vrBrPteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteOperEntry.setDescription('An entry in the vrBrPteOperTable.')
vrBrPteMacType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernet", 0), ("tokenRing", 1), ("fddiBridgePort", 2), ("tokenBus", 3), ("fddiEncapsulating", 4), ("vns", 5), ("frameRelay", 6), ("ppp", 7), ("smds", 8), ("vcp", 9), ("x25", 10), ("srEncapSr", 11), ("srEncapTb", 12), ("sourceGateSr", 13), ("sourceGateTb", 14), ("srtb", 15), ("tbsr", 16), ("clusterSr", 17), ("clusterTb", 18), ("unknown", 19), ("atmMpe", 20), ("snaDlr", 21), ("lecEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteMacType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteMacType.setDescription('This attribute is indicative of the Mac type of the bridge port is associated with.')
vrBrPteStpState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteStpState.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteStpState.setDescription('This attribute is indicative of the stp state of the bridge port.')
vrBrPteStpType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteStpType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteStpType.setDescription('This attribute specifies the type of the spanning tree protocol this bridge port is participating in.')
vrBrPteFilterPoints = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("inOut", 3), ("none", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteFilterPoints.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteFilterPoints.setDescription('This attribute in indicative of the points where filtering is active currently.')
vrBrPtePortPointsTo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("rootBridge", 2), ("designatedBridge", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPtePortPointsTo.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPtePortPointsTo.setDescription('This attribute in indicative of the fact if this bridge port leads to the root bridge of the spanning tree topology or if leads to the designated bridge of the lan segment the bridge port is attached to.')
vrBrPteSpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 11), )
if mibBuilder.loadTexts: vrBrPteSpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteSpOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all the attributes associated with the source route portion of the port table.')
vrBrPteSpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPteDomainNumIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPtePortNameIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrPteModeIndex"))
if mibBuilder.loadTexts: vrBrPteSpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteSpOperEntry.setDescription('An entry in the vrBrPteSpOperTable.')
vrBrPteLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4095), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteLanId.setDescription('This attribute identifies the lan identifier the bridge port is attached to. LAN ID is a part of the route descriptor used when source route bridging. Note that the value 0 is used by some applications for special test cases and the value 65535 signifies that no lanId is assigned to this port.')
vrBrPteInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4095), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteInternalLanId.setDescription('This attribute contains the internal or logical LAN to which a port is attached. All source bridge ports have an associated physical LAN segment and logical internal LAN segment. Note that the value 0 is used by some applications for special test cases and the value 65535 signifies that no internalLanId is assigned to this port.')
vrBrPteBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrPteBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrPteBridgeNum.setDescription('This attribute specifies the number assigned to the bridge associated with this LAN ID table entry. The bridge number is a part of the route descriptor of a source routed frame. Note that the value 0 is used by some applications for special test cases and the value 65535 signifies that no bridgeNum is assigned to this port.')
vrBrNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3))
vrBrNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 1), )
if mibBuilder.loadTexts: vrBrNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrBrNs components.')
vrBrNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrNsIndex"))
if mibBuilder.loadTexts: vrBrNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsRowStatusEntry.setDescription('A single entry in the table represents a single vrBrNs component.')
vrBrNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrNs components. These components can be added and deleted.')
vrBrNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsStorageType.setDescription('This variable represents the storage type value for the vrBrNs tables.')
vrBrNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrBrNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsIndex.setDescription('This variable represents the index for the vrBrNs tables.')
vrBrNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 10), )
if mibBuilder.loadTexts: vrBrNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsProvTable.setDescription('This group houses all the provisionable attributes applicable to the packet control facility. These attributes are global attributes and are not port specific.')
vrBrNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrNsIndex"))
if mibBuilder.loadTexts: vrBrNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsProvEntry.setDescription('An entry in the vrBrNsProvTable.')
vrBrNsFirstFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsFirstFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsFirstFilter.setDescription('This attribute specifies the name of the filter to be applied at the first filter point.')
vrBrNsLastFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsLastFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsLastFilter.setDescription('This attribute specifies the name of the filter that is to be applied at the last filter point.')
vrBrNsAte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2))
vrBrNsAteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 1), )
if mibBuilder.loadTexts: vrBrNsAteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteRowStatusTable.setDescription('This entry controls the addition and deletion of vrBrNsAte components.')
vrBrNsAteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrNsIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrNsAteEntryNumberIndex"))
if mibBuilder.loadTexts: vrBrNsAteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteRowStatusEntry.setDescription('A single entry in the table represents a single vrBrNsAte component.')
vrBrNsAteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsAteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrNsAte components. These components can be added and deleted.')
vrBrNsAteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrNsAteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrNsAteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrNsAteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteStorageType.setDescription('This variable represents the storage type value for the vrBrNsAte tables.')
vrBrNsAteEntryNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: vrBrNsAteEntryNumberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteEntryNumberIndex.setDescription('This variable represents the index for the vrBrNsAte tables.')
vrBrNsAteProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10), )
if mibBuilder.loadTexts: vrBrNsAteProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteProvTable.setDescription('This group houses all the attributes that together form an apply table entry. These fields of an apply table entry are used as match criteria, which when satisfied results in the application of the named filter to the frame.')
vrBrNsAteProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrNsIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrNsAteEntryNumberIndex"))
if mibBuilder.loadTexts: vrBrNsAteProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteProvEntry.setDescription('An entry in the vrBrNsAteProvTable.')
vrBrNsAteDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967293))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsAteDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteDomainNum.setDescription('This attribute specifies the domain number associated with a frame, that would qualify it partly, for a match in the apply table. The domain number provisioned will form a part of the match criteria only if it is not provisioned with a wild card value of 0. If the wild card character is specified, any domain number will satisfy the match criteria, in effect loosing domain number as a qualifier in the match criteria.')
vrBrNsAteFirstMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10, 1, 2), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsAteFirstMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteFirstMacAddress.setDescription('This attribute specifies the MAC address to be anded with the firstMACAddressMask, and the result compared with- a) The source MAC address in a frame when the attribute direction has a value of to, b) The destination MAC address in a frame when the attribute direction has a value of from, c) Source / Destination address in a frame when the attribute direction has a value of toFrom, as a part of finding a match in the bridge filter apply table.')
vrBrNsAteFirstMacAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10, 1, 3), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="ffffffffffff")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsAteFirstMacAddressMask.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteFirstMacAddressMask.setDescription('This attribute specifies the mask which is anded with the attribute firstMACAddress. The result is then compared with- a) The source MAC address in a frame when the attribute direction has a value of to, b) The destination MAC address in a frame when the attribute direction has a value of from, c) Source / Destination address in a frame when the attribute direction has a value of toFrom, as a part of finding a match in the bridge filter apply table.')
vrBrNsAteSecondMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10, 1, 4), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsAteSecondMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteSecondMacAddress.setDescription('This attribute specifies the MAC address to be anded with the secondMACAddressMask, and the result compared with- a) The destination MAC address in a frame when the attribute direction has a value of to, b) The source MAC address in a frame when the attribute direction has a value of from, c) Destination/Source address in a frame when the attribute direction has a value of toFrom, as a part of finding a match in the bridge filter apply table.')
vrBrNsAteSecondMacAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10, 1, 5), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="ffffffffffff")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsAteSecondMacAddressMask.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteSecondMacAddressMask.setDescription('This attribute specifies the mask which is anded with the attribute secondMACAddress. The result is then compared with- a) The destination MAC address in a frame when the attribute direction has a value of to, b) The source MAC address in a frame when the attribute direction has a value of from, c) Destination/Source address in a frame when the attribute direction has a value of toFrom, as a part of finding a match in the bridge filter apply table.')
vrBrNsAteDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("to", 0), ("from", 1), ("toFrom", 2))).clone('toFrom')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsAteDirection.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteDirection.setDescription('This attribute specifies the direction of frame flow. It is used to appropriately compare the result of logically anding MAC address, MACAddressMask pairs, with the source /destination MAC address fields in a frame, as a part of the match finding process. When this attribute has value of to, the firstMACAddress is logically anded with the firstMACAddressMask and the result compared with the source MAC address in a frame and the secondMACAddress logically anded with the secondMACAddressMask and compared with the destination MAC address. When this attribute has a value of from, the firstMACAddress is logically anded with the firstMACAddressMask and the result compared with the destinationMAC address in a frame and the secondMACAddress logically anded with the secondMACAddressMask and compared with the sourceMAC addressin the frame, as a part of finding a match in the bridge filter apply table entry.')
vrBrNsAteFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 3, 2, 10, 1, 7), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrNsAteFilterName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrNsAteFilterName.setDescription('This attribute specifies the name of the filter to be applied to the frame, if it satisfies the match criteria mentioned in the bridge filter apply table entry.')
vrBrTb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4))
vrBrTbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 1), )
if mibBuilder.loadTexts: vrBrTbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbRowStatusTable.setDescription('This entry controls the addition and deletion of vrBrTb components.')
vrBrTbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"))
if mibBuilder.loadTexts: vrBrTbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbRowStatusEntry.setDescription('A single entry in the table represents a single vrBrTb component.')
vrBrTbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrTb components. These components can be added and deleted.')
vrBrTbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrTbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStorageType.setDescription('This variable represents the storage type value for the vrBrTb tables.')
vrBrTbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrBrTbIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbIndex.setDescription('This variable represents the index for the vrBrTb tables.')
vrBrTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 10), )
if mibBuilder.loadTexts: vrBrTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbProvTable.setDescription('This group houses all the provisionable attributes applicable to a transparent bridge, those attributes that are global and are not port specific.')
vrBrTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"))
if mibBuilder.loadTexts: vrBrTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbProvEntry.setDescription('An entry in the vrBrTbProvTable.')
vrBrTbFwdTableNumEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbFwdTableNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFwdTableNumEntries.setDescription('This attribute specifies the number of entries that can exist in the transparent bridge forwarding table. This attribute provides a way to control the resources allocated to forwarding table. This attribute will prove to be very useful while attempting to fine tune the resource allocated to the various types of tables to suit the network configuration. Please understand that this attribute tbFwdTableNumEntries is influenced by the memory management scheme provided by the VirtualRouter and is by no means independent of the same. It is important to understand the network configuration in terms of number and types of bridge ports provisioned before attempting to fine tune this attribute.The following attributes can be used as feedback to fine tune this attribute: a) attribute totalForwardingTableEntries under the TransparentBridge component, b) attribute numFtEntriesFree under the TransparentBridge component, c) attribute numFtEntriesDenied under the TransparentBridge component')
vrBrTbAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbAgingTime.setDescription('This attribute specifies the time period used in seconds, to age out dynamically learned entries in the forwarding table. The aging time can change, triggered by a spanning tree topology change. The operational value of the aging time is reflected in the attribute agingTimeOper under the SpanningTreeProtocol component.')
vrBrTbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 11), )
if mibBuilder.loadTexts: vrBrTbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStatsTable.setDescription('This group houses all the statistical attributes for a transparent bridge, those attributes that are global in nature and are not port specific.')
vrBrTbStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"))
if mibBuilder.loadTexts: vrBrTbStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStatsEntry.setDescription('An entry in the vrBrTbStatsTable.')
vrBrTbLearnedEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbLearnedEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbLearnedEntryDiscards.setDescription('This attribute represents the number of entries that might have been learned but have been discarded due to lack of space to store them in the forwarding table. This counter is not supported currently by the bridging platform and will always return a value of 0 in response to any queries.')
vrBrTbTotalForwardingTableEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbTotalForwardingTableEntries.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbTotalForwardingTableEntries.setDescription('This attribute specifies the total number of TB forwarding table entries. This includes static forwarding table entries and dynamic forwarding table entries. This attribute is influenced by the attribute tbFwdTableNumEntries, which is a provisionable attribute. If the value is consistently approaching the value of the attribute tbFwdTableNumEntries, it is advisable to increase the value provisioned for tbFwdTableNumEntries. It indicates a potential shortage of forwarding table entries in the future. This attribute is inversely proportional in value to the attribute numFtEntriesFree. This counter wraps around its maximum value of 4294967295.')
vrBrTbNumFtEntriesFree = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 11, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNumFtEntriesFree.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNumFtEntriesFree.setDescription('This attribute is indicative of the number of TB forwarding table entries free. These entries could be used by static entries or by dynamic entries. This counter wraps around its maximum value of 4294967295. A consistently high value for this attribute indicates that there is a resource surplus here, in terms of the memory requirements of the forwarding table. This surplus could be utilized elsewhere if need be. The value of this attributes directly influenced by the value of the attribute tbFwdTableNumEntries.')
vrBrTbNumFtEntriesDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNumFtEntriesDenied.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNumFtEntriesDenied.setDescription('This attribute is indicative of the number of instances wherein TB table entry was unavailable. These entries could have been denied for static entries or for dynamic entries. This counter wraps around its maximum value of 4294967295. If this counter consistently shows a high value, it is indicative of a resource shortage in terms of memory required to support the increase in the number of forwarding table entries. To rectify this resource shortage, increase the number of forwarding table entries through the provisioned attribute tbFwdTableEntries under the Bridge component. This counter should ideally be as low as possible.')
vrBrTbStp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2))
vrBrTbStpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 1), )
if mibBuilder.loadTexts: vrBrTbStpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpRowStatusTable.setDescription('This entry controls the addition and deletion of vrBrTbStp components.')
vrBrTbStpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbStpIndex"))
if mibBuilder.loadTexts: vrBrTbStpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpRowStatusEntry.setDescription('A single entry in the table represents a single vrBrTbStp component.')
vrBrTbStpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbStpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrTbStp components. These components can be added and deleted.')
vrBrTbStpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrTbStpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpStorageType.setDescription('This variable represents the storage type value for the vrBrTbStp tables.')
vrBrTbStpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: vrBrTbStpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpIndex.setDescription('This variable represents the index for the vrBrTbStp tables.')
vrBrTbStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 10), )
if mibBuilder.loadTexts: vrBrTbStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpProvTable.setDescription('This group houses all the provisionable attributes that are applicable to the spanning tree protocol. These are global attributes and not port specific attributes. These attributes have a direct impact on the way this bridge participates in the spanning tree protocol.')
vrBrTbStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbStpIndex"))
if mibBuilder.loadTexts: vrBrTbStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpProvEntry.setDescription('An entry in the vrBrTbStpProvTable.')
vrBrTbStpStpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2))).clone('access')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbStpStpMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpStpMode.setDescription('This attribute determines if this stp instance is to act as the stp instance for the backbone or an stp instance for a non-backbone media configuration. There can exist only one Backbone stp instance per virtual router. If the attribute domainStpTbState is set to a value on and Backbone bridge ports have been provisioned, there should exist a Backbone stp instance. Please note that it is not permissible to assign the instance identifier of this stp instance as domain number of any access bridge port. In case of stp instances that are non-Backbone, the instance identifier is indicative of the domain number the stp is operational in.')
vrBrTbStpProtocolSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("both", 1), ("dec", 2), ("ieee8021d", 3))).clone('ieee8021d')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbStpProtocolSpec.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpProtocolSpec.setDescription('This attribute specifies the type of spanning tree protocols that are in operation in the bridge. This means that this bridge participates in the types spanning tree protocol indicated by this attribute.')
vrBrTbStpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbStpPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpPriority.setDescription('This attribute is used to construct the bridgeId. It forms the first two octets of the bridgeId and the remaining 6 octets are made up of the bridgeMACAddress. The priority also determines the root bridge of the spanning tree topology. Manipulating this attribute might lead to a change in the spanning tree topology.')
vrBrTbStpBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbStpBridgeMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpBridgeMaxAge.setDescription('The maximum age of spanning tree protocol information learned from the network on any bridge port before it is discarded. This value is used by this bridge and all the other bridges, when this bridge is the root bridge of the spanning tree topology. The following relationships are enforced as required by the IEEE 802.1d standards document. 2 *(bridgeForwardDelay -1.0seconds) >= bridgeMaxAge, bridgeMaxAge >= 2 * bridgeHelloTime + 1.0 seconds. DESCRIPTION')
vrBrTbStpBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbStpBridgeHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpBridgeHelloTime.setDescription('This attribute specifies the time interval between the transmission of configuration BPDUs on any bridge port when this bridge becomes the root bridge. This attribute value is also used by all the other bridges in the Spanning Tree while this bridge is the root. The following relationship is enforced as required by the IEEE 802.1d standards document. bridgeMaxAge >= 2 * bridgeHelloTime + 1.0 seconds.')
vrBrTbStpBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbStpBridgeForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpBridgeForwardDelay.setDescription('This attribute specifies how fast a bridge port changes its STP state while progressing towards the forwarding state. It is also used as agingTime to age dynamic entries in the forwarding table once a topology change is detected. This attribute is used by all the bridges participating in the spanning tree protocol, when this bridge is the root bridge. The following relationship is enforced as required by the IEEE 802.1d standards document. 2 *(bridgeForwardDelay -1.0sconds) >= bridgeMaxAge.')
vrBrTbStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11), )
if mibBuilder.loadTexts: vrBrTbStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpOperTable.setDescription('This group houses all the operational, spanning tree protocol attributes. These attributes are applicable in a global manner and are not specific to a bridge port.')
vrBrTbStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbStpIndex"))
if mibBuilder.loadTexts: vrBrTbStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpOperEntry.setDescription('An entry in the vrBrTbStpOperTable.')
vrBrTbStpBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 1), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpBridgeId.setDescription('This attribute specifies the identifier value of this bridge, which serves to uniquely represent this bridge in the spanning tree topology. Thus, a bridgeId is unique only in the spanning tree instance the bridge in participating in. If multiple domain spanning trees exist then the same bridgeId can be re-used across these spanning tree instances.')
vrBrTbStpRootPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpRootPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpRootPortName.setDescription("This attribute specifies the name of the bridge port that offers the lowest cost route to the root bridge of the spanning tree topology.The attribute rootPortName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport. If multiple instances of spanning tree are operational, then there will exist a rootPortName value for each instance of the spanning tree running, and is applicable to that instance alone.")
vrBrTbStpTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpTimeSinceTopologyChange.setDescription('This attribute specifies the time since a spanning tree topology change was detected by this bridge.')
vrBrTbStpTopologyChangeDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpTopologyChangeDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpTopologyChangeDetect.setDescription('This attribute specifies whether or not a topology change was detected. This flag is set when a bpdu with the topology detect flag set is received from the root bridge. If this bridge is the root bridge this flag is set on receipt of a topology change notification bpdu. It is reset after a fixed length of time.')
vrBrTbStpTopologyChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpTopologyChanges.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpTopologyChanges.setDescription('This attribute is indicative of the number of topology changes detected by this bridge since the last bridge reset. This counter wraps around its maximum value of 4294967295.')
vrBrTbStpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpDesignatedRoot.setDescription('This attribute specifies the identifier of the bridge that this bridge treats as the root of the spanning tree topology. The root of the spanning tree topology is chosen through exchange.')
vrBrTbStpRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpRootCost.setDescription('This attribute specifies the cost of the path to the root as seen by this bridge.')
vrBrTbStpMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpMaxAge.setDescription('This attribute specifies the maximum age of the spanning tree protocol info learnt from a port, before it is discarded.')
vrBrTbStpAgingTimeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpAgingTimeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpAgingTimeOper.setDescription('This attribute specifies the time period used in seconds, to age out dynamically learned entries in the forwarding table. The aging time is specific to a spanning tree protocol instance running. A value for the aging time of the current instance of the spanning tree protocol can be provisioned through the attribute agingTime under the InwBrTb component. The agingTimeOper attribute assumes the value of the bridgeForwardDelay while a topology change is in progress. This is done to facilitate quick aging out of the learned entries that might have become obsolete due to a spanning tree topology change.')
vrBrTbStpHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(200)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpHelloTime.setDescription('This attribute specifies the time interval between the transmission of the configuration BPDUs. This value is obtained from the root bridge of the spanning tree topology, through bridge protocol data units. This value should be the value assigned to the attribute bridgeHelloTime of the root bridge.')
vrBrTbStpHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 100)).clone(100)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpHoldTime.setDescription('This attribute specifies the interval of time which no more than two BPDUs should be sent.')
vrBrTbStpFwdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 2, 11, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbStpFwdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbStpFwdDelay.setDescription('This attribute specifies how much time a port spends in any state while progressing towards the forwarding state. It is also used to age out learned entries while a topology change is in progress.This value should be the value assigned to the attribute bridgefwdDelay of the root bridge.')
vrBrTbSte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3))
vrBrTbSteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 1), )
if mibBuilder.loadTexts: vrBrTbSteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteRowStatusTable.setDescription('This entry controls the addition and deletion of vrBrTbSte components.')
vrBrTbSteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbSteAddressIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbSteReceivePortIndex"))
if mibBuilder.loadTexts: vrBrTbSteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteRowStatusEntry.setDescription('A single entry in the table represents a single vrBrTbSte component.')
vrBrTbSteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbSteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrTbSte components. These components can be added and deleted.')
vrBrTbSteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbSteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrTbSteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbSteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteStorageType.setDescription('This variable represents the storage type value for the vrBrTbSte tables.')
vrBrTbSteAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: vrBrTbSteAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteAddressIndex.setDescription('This variable represents an index for the vrBrTbSte tables.')
vrBrTbSteReceivePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 1, 1, 11), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 29)))
if mibBuilder.loadTexts: vrBrTbSteReceivePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteReceivePortIndex.setDescription('This variable represents an index for the vrBrTbSte tables.')
vrBrTbSteProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 10), )
if mibBuilder.loadTexts: vrBrTbSteProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteProvTable.setDescription('This group houses all the fields of a static table entry. All these attributes can be provisioned by the user. Multiple such static table entries together form the static forwarding table.')
vrBrTbSteProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbSteAddressIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbSteReceivePortIndex"))
if mibBuilder.loadTexts: vrBrTbSteProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteProvEntry.setDescription('An entry in the vrBrTbSteProvTable.')
vrBrTbSteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("permanent", 3))).clone('permanent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbSteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteStatus.setDescription('This attribute specifies the longevity of an entry in the static table. Please note that currently only a value of permanent is supported.')
vrBrTbSteAtgtTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 271), )
if mibBuilder.loadTexts: vrBrTbSteAtgtTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteAtgtTable.setDescription("This port map specifies the out bridge ports a MAC frame with address in its destination MAC address field, originating from receivePort, can go out of. The allowedToGoTo attribute is a set of strings where in each string is of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding TB or SRT bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. Multiple strings can be specified on the same set command. Each string in the list is space separated. An '*' in place of the i indicates that regardless of the protocol port instance, all bridge ports with name BridgePortName should be included in the allowedToGoTo. In cases where there are multiple bridge ports provisioned under a protocol port, (e.g. pseudo bridge ports) each bridge port name must be specified in the form of strings, as indicated above. Please note that this attribute allowedToGoTo cannot contain any of the following bridge ports in part: SrBP, Srtb, Srsg, Tbsg, Srse, Srcl, FddiESr.")
vrBrTbSteAtgtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 271, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbSteAddressIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbSteReceivePortIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbSteAtgtValue"))
if mibBuilder.loadTexts: vrBrTbSteAtgtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteAtgtEntry.setDescription('An entry in the vrBrTbSteAtgtTable.')
vrBrTbSteAtgtValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 271, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrTbSteAtgtValue.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteAtgtValue.setDescription('This variable represents both the value and the index for the vrBrTbSteAtgtTable.')
vrBrTbSteAtgtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 3, 271, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vrBrTbSteAtgtRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbSteAtgtRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the vrBrTbSteAtgtTable.')
vrBrTbFte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4))
vrBrTbFteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 1), )
if mibBuilder.loadTexts: vrBrTbFteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrBrTbFte components.')
vrBrTbFteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbFteAddressIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbFteDomainNumIndex"))
if mibBuilder.loadTexts: vrBrTbFteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteRowStatusEntry.setDescription('A single entry in the table represents a single vrBrTbFte component.')
vrBrTbFteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbFteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrTbFte components. These components cannot be added nor deleted.')
vrBrTbFteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbFteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrTbFteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbFteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteStorageType.setDescription('This variable represents the storage type value for the vrBrTbFte tables.')
vrBrTbFteAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: vrBrTbFteAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteAddressIndex.setDescription('This variable represents an index for the vrBrTbFte tables.')
vrBrTbFteDomainNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: vrBrTbFteDomainNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteDomainNumIndex.setDescription('This variable represents an index for the vrBrTbFte tables.')
vrBrTbFteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 10), )
if mibBuilder.loadTexts: vrBrTbFteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the attributes that form the fields of a forwarding table entry. Multiple such forwarding table entries put together form the forwarding table. These attributes reflect the state of the transparent bridge forwarding table.')
vrBrTbFteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbFteAddressIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbFteDomainNumIndex"))
if mibBuilder.loadTexts: vrBrTbFteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteOperEntry.setDescription('An entry in the vrBrTbFteOperTable.')
vrBrTbFtePort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbFtePort.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFtePort.setDescription("This attribute is the port name through which the address was learnt. This implies that the frames that are destined for a station whose MAC address is the same as the address, will be forwarded through the bridge port indicated by the attribute port. The attribute port is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrBrTbFteAgeOfEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 10, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbFteAgeOfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteAgeOfEntry.setDescription('This attribute specifies the age of the forwarding table entry. This is used to purge entries that have not been used for a certain period of time. This feature is to ensure that only the recently used entries are kept in the forwarding table. The time period for aging entries can be provisioned through the attribute agingTime under the component TransparentBridge.')
vrBrTbFtePeerAddressInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 10, 1, 5), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbFtePeerAddressInfo.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFtePeerAddressInfo.setDescription('This attribute represents the learned peer address information. This address is used to essentially tunnel frames to a peer bridge unit across a network or a backbone. The tunneled frame is then appropriately processed by the peer bridge unit. Fddi encapsulated bridging using FddiETb bridge port and Source route encapsulated bridging using SrseBridgePort & TbseBridgePort are examples of instances where this attribute peerAddressInfo is used.')
vrBrTbFteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 4, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("learned", 3))).clone('learned')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbFteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbFteStatus.setDescription('This attribute represents the status of the forwarding table entry. A value of learned indicates that the entry was learned and cached from the network. Please note that a only a value of learned is currently supported.')
vrBrTbNcFte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5))
vrBrTbNcFteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 1), )
if mibBuilder.loadTexts: vrBrTbNcFteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrBrTbNcFte components.')
vrBrTbNcFteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbNcFteAddressIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbNcFteDomainNumIndex"))
if mibBuilder.loadTexts: vrBrTbNcFteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteRowStatusEntry.setDescription('A single entry in the table represents a single vrBrTbNcFte component.')
vrBrTbNcFteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNcFteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrTbNcFte components. These components cannot be added nor deleted.')
vrBrTbNcFteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNcFteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrTbNcFteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNcFteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteStorageType.setDescription('This variable represents the storage type value for the vrBrTbNcFte tables.')
vrBrTbNcFteAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: vrBrTbNcFteAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteAddressIndex.setDescription('This variable represents an index for the vrBrTbNcFte tables.')
vrBrTbNcFteDomainNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: vrBrTbNcFteDomainNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteDomainNumIndex.setDescription('This variable represents an index for the vrBrTbNcFte tables.')
vrBrTbNcFteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 10), )
if mibBuilder.loadTexts: vrBrTbNcFteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the attributes that form the fields of a forwarding table entry. Multiple such forwarding table entries put together form the forwarding table. These attributes reflect the state of the transparent bridge forwarding table.')
vrBrTbNcFteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbNcFteAddressIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrTbNcFteDomainNumIndex"))
if mibBuilder.loadTexts: vrBrTbNcFteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteOperEntry.setDescription('An entry in the vrBrTbNcFteOperTable.')
vrBrTbNcFtePort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNcFtePort.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFtePort.setDescription("This attribute is the port name through which the address was learnt. This implies that the frames that are destined for a station whose MAC address is the same as the address, will be forwarded through the bridge port indicated by the attribute port. The attribute port is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
vrBrTbNcFteAgeOfEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 10, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNcFteAgeOfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteAgeOfEntry.setDescription('This attribute specifies the age of the forwarding table entry. This is used to purge entries that have not been used for a certain period of time. This feature is to ensure that only the recently used entries are kept in the forwarding table. The time period for aging entries can be provisioned through the attribute agingTime under the component TransparentBridge.')
vrBrTbNcFtePeerAddressInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 10, 1, 5), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNcFtePeerAddressInfo.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFtePeerAddressInfo.setDescription('This attribute represents the learned peer address information. This address is used to essentially tunnel frames to a peer bridge unit across a network or a backbone. The tunneled frame is then appropriately processed by the peer bridge unit. Fddi encapsulated bridging using FddiETb bridge port and Source route encapsulated bridging using SrseBridgePort & TbseBridgePort are examples of instances where this attribute peerAddressInfo is used.')
vrBrTbNcFteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 4, 5, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("learned", 3))).clone('learned')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrTbNcFteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrTbNcFteStatus.setDescription('This attribute represents the status of the forwarding table entry. A value of learned indicates that the entry was learned and cached from the network. Please note that a only a value of learned is currently supported.')
vrBrSrb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5))
vrBrSrbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 1), )
if mibBuilder.loadTexts: vrBrSrbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbRowStatusTable.setDescription('This entry controls the addition and deletion of vrBrSrb components.')
vrBrSrbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbIndex"))
if mibBuilder.loadTexts: vrBrSrbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbRowStatusEntry.setDescription('A single entry in the table represents a single vrBrSrb component.')
vrBrSrbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrSrb components. These components can be added and deleted.')
vrBrSrbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrSrbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStorageType.setDescription('This variable represents the storage type value for the vrBrSrb tables.')
vrBrSrbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrBrSrbIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbIndex.setDescription('This variable represents the index for the vrBrSrb tables.')
vrBrSrbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 10), )
if mibBuilder.loadTexts: vrBrSrbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbProvTable.setDescription('This group contains all provisionable attributes associated with source route bridging. These attributes are global in nature as opposed to port specific.')
vrBrSrbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbIndex"))
if mibBuilder.loadTexts: vrBrSrbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbProvEntry.setDescription('An entry in the vrBrSrbProvTable.')
vrBrSrbLanIdTableNumEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(500, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbLanIdTableNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLanIdTableNumEntries.setDescription('This attribute specifies the maximum number of entries in the LAN ID table. This attribute provides a way to control the resources allocated to the LAN ID table. The lanIdTableNumEntries value depends upon the VirtualRouter attribute bridgingMaxHeapSpace and the number of source route bridge ports provisioned for this SourceRouteBridge. Consider the following attributes of the SourceRouteBridge component when adjusting this number: - totalLanIdTableEntries - numLanIdTEntriesFree - numLanIdTEntriesDenied')
vrBrSrbAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbAgingTime.setDescription('This attribute specifies the time period used in seconds, to age out dynamically learned entries in the forwarding table. The aging time can change, triggered by a spanning tree topology change. The operational value of the aging time is reflected in the attribute agingTimeOper under the SpanningTreeProtocol component.')
vrBrSrbBridgeLfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mode3", 1), ("mode6", 2))).clone('mode3')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbBridgeLfMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbBridgeLfMode.setDescription('This attribute indicates whether the bridge operates using the older 3-bit length negotiation field or the newer 6-bit length field in the routing information field. Only the 3-bit field is supported at this time.')
vrBrSrbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 11), )
if mibBuilder.loadTexts: vrBrSrbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStatsTable.setDescription('This group contains all statistical attributes associated with the SourceRouteBridge. These attributes are global in nature as opposed to port specific.')
vrBrSrbStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbIndex"))
if mibBuilder.loadTexts: vrBrSrbStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStatsEntry.setDescription('An entry in the vrBrSrbStatsTable.')
vrBrSrbTotalLanIdTableEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbTotalLanIdTableEntries.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbTotalLanIdTableEntries.setDescription('This attribute specifies the total number of LAN ID Table entries. The total includes both static and dynamic entries. The value is limited by the attribute lanIdTableNumEntries, a provisionable attribute. If the value is consistently approaching the value of lanIdTableNumEntries it is advisable to increase the value provisioned for lanIdTableNumEntries.')
vrBrSrbNumLanIdtEntriesFree = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbNumLanIdtEntriesFree.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbNumLanIdtEntriesFree.setDescription('This attribute specifies the number of LanIdTable entries that are available for use. A consistently high value indicates a resource surplus in terms of memory requirements for the bridge. This surplus could be utilized elsewhere if need be. The value of this attribute is directly influenced by the value of the lanIdTableNumEntries.')
vrBrSrbNumLanIdtEntriesDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbNumLanIdtEntriesDenied.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbNumLanIdtEntriesDenied.setDescription('This attribute indicates the number of instances where an entry was not placed in the LanIdTable due to the lack of free entries. A rapid increase indicates a shortage of free entries. To reduce the shortage increase the provisioned lanIdTableNumEntries value.')
vrBrSrbStp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2))
vrBrSrbStpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 1), )
if mibBuilder.loadTexts: vrBrSrbStpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpRowStatusTable.setDescription('This entry controls the addition and deletion of vrBrSrbStp components.')
vrBrSrbStpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbStpIndex"))
if mibBuilder.loadTexts: vrBrSrbStpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpRowStatusEntry.setDescription('A single entry in the table represents a single vrBrSrbStp component.')
vrBrSrbStpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbStpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrSrbStp components. These components can be added and deleted.')
vrBrSrbStpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrSrbStpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpStorageType.setDescription('This variable represents the storage type value for the vrBrSrbStp tables.')
vrBrSrbStpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: vrBrSrbStpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpIndex.setDescription('This variable represents the index for the vrBrSrbStp tables.')
vrBrSrbStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 10), )
if mibBuilder.loadTexts: vrBrSrbStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpProvTable.setDescription('This group houses all the provisionable attributes that are applicable to the spanning tree protocol. These are global attributes and not port specific attributes. These attributes have a direct impact on the way this bridge participates in the spanning tree protocol.')
vrBrSrbStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbStpIndex"))
if mibBuilder.loadTexts: vrBrSrbStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpProvEntry.setDescription('An entry in the vrBrSrbStpProvTable.')
vrBrSrbStpStpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2))).clone('access')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbStpStpMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpStpMode.setDescription('This attribute determines if this stp instance is to act as the stp instance for the backbone or an stp instance for a non-backbone media configuration. There can exist only one Backbone stp instance per virtual router. If the attribute domainStpTbState is set to a value on and Backbone bridge ports have been provisioned, there should exist a Backbone stp instance. Please note that it is not permissible to assign the instance identifier of this stp instance as domain number of any access bridge port. In case of stp instances that are non-Backbone, the instance identifier is indicative of the domain number the stp is operational in.')
vrBrSrbStpProtocolSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("both", 1), ("dec", 2), ("ieee8021d", 3))).clone('ieee8021d')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbStpProtocolSpec.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpProtocolSpec.setDescription('This attribute specifies the type of spanning tree protocols that are in operation in the bridge. This means that this bridge participates in the types spanning tree protocol indicated by this attribute.')
vrBrSrbStpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbStpPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpPriority.setDescription('This attribute is used to construct the bridgeId. It forms the first two octets of the bridgeId and the remaining 6 octets are made up of the bridgeMACAddress. The priority also determines the root bridge of the spanning tree topology. Manipulating this attribute might lead to a change in the spanning tree topology.')
vrBrSrbStpBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbStpBridgeMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpBridgeMaxAge.setDescription('The maximum age of spanning tree protocol information learned from the network on any bridge port before it is discarded. This value is used by this bridge and all the other bridges, when this bridge is the root bridge of the spanning tree topology. The following relationships are enforced as required by the IEEE 802.1d standards document. 2 *(bridgeForwardDelay -1.0seconds) >= bridgeMaxAge, bridgeMaxAge >= 2 * bridgeHelloTime + 1.0 seconds. DESCRIPTION')
vrBrSrbStpBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbStpBridgeHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpBridgeHelloTime.setDescription('This attribute specifies the time interval between the transmission of configuration BPDUs on any bridge port when this bridge becomes the root bridge. This attribute value is also used by all the other bridges in the Spanning Tree while this bridge is the root. The following relationship is enforced as required by the IEEE 802.1d standards document. bridgeMaxAge >= 2 * bridgeHelloTime + 1.0 seconds.')
vrBrSrbStpBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBrSrbStpBridgeForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpBridgeForwardDelay.setDescription('This attribute specifies how fast a bridge port changes its STP state while progressing towards the forwarding state. It is also used as agingTime to age dynamic entries in the forwarding table once a topology change is detected. This attribute is used by all the bridges participating in the spanning tree protocol, when this bridge is the root bridge. The following relationship is enforced as required by the IEEE 802.1d standards document. 2 *(bridgeForwardDelay -1.0sconds) >= bridgeMaxAge.')
vrBrSrbStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11), )
if mibBuilder.loadTexts: vrBrSrbStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpOperTable.setDescription('This group houses all the operational, spanning tree protocol attributes. These attributes are applicable in a global manner and are not specific to a bridge port.')
vrBrSrbStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbStpIndex"))
if mibBuilder.loadTexts: vrBrSrbStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpOperEntry.setDescription('An entry in the vrBrSrbStpOperTable.')
vrBrSrbStpBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 1), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpBridgeId.setDescription('This attribute specifies the identifier value of this bridge, which serves to uniquely represent this bridge in the spanning tree topology. Thus, a bridgeId is unique only in the spanning tree instance the bridge in participating in. If multiple domain spanning trees exist then the same bridgeId can be re-used across these spanning tree instances.')
vrBrSrbStpRootPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpRootPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpRootPortName.setDescription("This attribute specifies the name of the bridge port that offers the lowest cost route to the root bridge of the spanning tree topology.The attribute rootPortName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport. If multiple instances of spanning tree are operational, then there will exist a rootPortName value for each instance of the spanning tree running, and is applicable to that instance alone.")
vrBrSrbStpTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpTimeSinceTopologyChange.setDescription('This attribute specifies the time since a spanning tree topology change was detected by this bridge.')
vrBrSrbStpTopologyChangeDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpTopologyChangeDetect.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpTopologyChangeDetect.setDescription('This attribute specifies whether or not a topology change was detected. This flag is set when a bpdu with the topology detect flag set is received from the root bridge. If this bridge is the root bridge this flag is set on receipt of a topology change notification bpdu. It is reset after a fixed length of time.')
vrBrSrbStpTopologyChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpTopologyChanges.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpTopologyChanges.setDescription('This attribute is indicative of the number of topology changes detected by this bridge since the last bridge reset. This counter wraps around its maximum value of 4294967295.')
vrBrSrbStpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpDesignatedRoot.setDescription('This attribute specifies the identifier of the bridge that this bridge treats as the root of the spanning tree topology. The root of the spanning tree topology is chosen through exchange.')
vrBrSrbStpRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpRootCost.setDescription('This attribute specifies the cost of the path to the root as seen by this bridge.')
vrBrSrbStpMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpMaxAge.setDescription('This attribute specifies the maximum age of the spanning tree protocol info learnt from a port, before it is discarded.')
vrBrSrbStpAgingTimeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpAgingTimeOper.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpAgingTimeOper.setDescription('This attribute specifies the time period used in seconds, to age out dynamically learned entries in the forwarding table. The aging time is specific to a spanning tree protocol instance running. A value for the aging time of the current instance of the spanning tree protocol can be provisioned through the attribute agingTime under the InwBrTb component. The agingTimeOper attribute assumes the value of the bridgeForwardDelay while a topology change is in progress. This is done to facilitate quick aging out of the learned entries that might have become obsolete due to a spanning tree topology change.')
vrBrSrbStpHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(200)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpHelloTime.setDescription('This attribute specifies the time interval between the transmission of the configuration BPDUs. This value is obtained from the root bridge of the spanning tree topology, through bridge protocol data units. This value should be the value assigned to the attribute bridgeHelloTime of the root bridge.')
vrBrSrbStpHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 100)).clone(100)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpHoldTime.setDescription('This attribute specifies the interval of time which no more than two BPDUs should be sent.')
vrBrSrbStpFwdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 2, 11, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbStpFwdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbStpFwdDelay.setDescription('This attribute specifies how much time a port spends in any state while progressing towards the forwarding state. It is also used to age out learned entries while a topology change is in progress.This value should be the value assigned to the attribute bridgefwdDelay of the root bridge.')
vrBrSrbLte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3))
vrBrSrbLteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 1), )
if mibBuilder.loadTexts: vrBrSrbLteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrBrSrbLte components.')
vrBrSrbLteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbLteLanIdIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbLteDomainNumIndex"))
if mibBuilder.loadTexts: vrBrSrbLteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteRowStatusEntry.setDescription('A single entry in the table represents a single vrBrSrbLte component.')
vrBrSrbLteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbLteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrBrSrbLte components. These components cannot be added nor deleted.')
vrBrSrbLteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbLteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrBrSrbLteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbLteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteStorageType.setDescription('This variable represents the storage type value for the vrBrSrbLte tables.')
vrBrSrbLteLanIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4095), ValueRangeConstraint(65535, 65535), )))
if mibBuilder.loadTexts: vrBrSrbLteLanIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteLanIdIndex.setDescription('This variable represents an index for the vrBrSrbLte tables.')
vrBrSrbLteDomainNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: vrBrSrbLteDomainNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteDomainNumIndex.setDescription('This variable represents an index for the vrBrSrbLte tables.')
vrBrSrbLteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 10), )
if mibBuilder.loadTexts: vrBrSrbLteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all the fields of a LAN ID Table entry.')
vrBrSrbLteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbLteLanIdIndex"), (0, "Nortel-Magellan-Passport-BridgeMIB", "vrBrSrbLteDomainNumIndex"))
if mibBuilder.loadTexts: vrBrSrbLteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteOperEntry.setDescription('An entry in the vrBrSrbLteOperTable.')
vrBrSrbLtePortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbLtePortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLtePortName.setDescription("This attribute specifies the name of the bridge port the frame should be forwarded through to reach the desired Lan. In the case where the desired Lan is across a TB/SRT cloud, this entry would have the name of the SrSeBridgePort. The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort the bridge port is provisioned under. For example a SourceRouteBridgePort provisioned under ProtocolPort/MyPort would have a name SrBP-MyPort. Please note that the attribute portName cannot have a value of TBP, FddiETb, Tbse, Tbcl, Tbsr, Srsg, Tbsg. DESCRIPTION")
vrBrSrbLteAgeOfEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbLteAgeOfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteAgeOfEntry.setDescription('This attribute specifies the age of this entry in seconds.')
vrBrSrbLtePeerMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 10, 1, 3), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbLtePeerMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLtePeerMACAddress.setDescription('This attribute specifies the MAC address of a bridge unit found across an transparent bridge/source route transparent network whose LAN ID is referenced by the attribute lanId. The peerMACAddress for static entries will be all zeroes.')
vrBrSrbLteTypeOfEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 5, 5, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("static", 0), ("dynamic", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBrSrbLteTypeOfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBrSrbLteTypeOfEntry.setDescription('This attribute specifies the type of the LAN ID table entry. LAN ID table entries may be either static or dynamic. Dynamic entries imply that to reach the desired LAN source route frames need to be tunneled through a TB/SRT network, to another bridge unit which is attached to the LAN. These entries have a peerMACAddress associated with them and may be removed through the aging mechanism of the LAN ID table. Static entries on the other hand contain information about LANs that may be reached directly through bridge ports attached to the bridge. They are not aged and do not have a peerMACAddress associated with them.')
cB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103))
cBRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 1), )
if mibBuilder.loadTexts: cBRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: cBRowStatusTable.setDescription('This entry controls the addition and deletion of cB components.')
cBRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "cBIndex"))
if mibBuilder.loadTexts: cBRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cBRowStatusEntry.setDescription('A single entry in the table represents a single cB component.')
cBRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cBRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cBRowStatus.setDescription('This variable is used as the basis for SNMP naming of cB components. These components can be added and deleted.')
cBComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: cBComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
cBStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: cBStorageType.setDescription('This variable represents the storage type value for the cB tables.')
cBIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: cBIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cBIndex.setDescription('This variable represents the index for the cB tables.')
cBAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 10), )
if mibBuilder.loadTexts: cBAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: cBAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
cBAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "cBIndex"))
if mibBuilder.loadTexts: cBAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cBAdminControlEntry.setDescription('An entry in the cBAdminControlTable.')
cBSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cBSnmpAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: cBSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
cBIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 11), )
if mibBuilder.loadTexts: cBIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: cBIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
cBIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "cBIndex"))
if mibBuilder.loadTexts: cBIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cBIfEntryEntry.setDescription('An entry in the cBIfEntryTable.')
cBIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cBIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cBIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
cBIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 11, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cBIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
cBMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 12), )
if mibBuilder.loadTexts: cBMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: cBMpTable.setDescription('This group contains the base provisioning data for the media base component.')
cBMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "cBIndex"))
if mibBuilder.loadTexts: cBMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cBMpEntry.setDescription('An entry in the cBMpTable.')
cBLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 12, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cBLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: cBLinkToProtocolPort.setDescription('This attribute specifies the ProtocolPort to which this interface is linked to. The protocol port is the logical interface to the network. The protocol port component describes the logical characteristics of this interface.')
cBOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 13), )
if mibBuilder.loadTexts: cBOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: cBOperTable.setDescription('This group includes the operational attibutes which are specific to the ClusterBridge component.')
cBOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "cBIndex"))
if mibBuilder.loadTexts: cBOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cBOperEntry.setDescription('An entry in the cBOperTable.')
cBMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 13, 1, 1), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cBMacAddress.setDescription('The medium access controller (MAC) address is an address that is only recognized by one station on the attached bus. This address is automatically assigned by the system.')
cBStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 14), )
if mibBuilder.loadTexts: cBStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: cBStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
cBStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "cBIndex"))
if mibBuilder.loadTexts: cBStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cBStateEntry.setDescription('An entry in the cBStateTable.')
cBAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: cBAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
cBOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: cBOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
cBUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: cBUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
cBOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 15), )
if mibBuilder.loadTexts: cBOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: cBOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
cBOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "cBIndex"))
if mibBuilder.loadTexts: cBOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cBOperStatusEntry.setDescription('An entry in the cBOperStatusTable.')
cBSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 103, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cBSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
pB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104))
pBRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 1), )
if mibBuilder.loadTexts: pBRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: pBRowStatusTable.setDescription('This entry controls the addition and deletion of pB components.')
pBRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "pBIndex"))
if mibBuilder.loadTexts: pBRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pBRowStatusEntry.setDescription('A single entry in the table represents a single pB component.')
pBRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pBRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pBRowStatus.setDescription('This variable is used as the basis for SNMP naming of pB components. These components can be added and deleted.')
pBComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pBComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: pBComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
pBStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pBStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: pBStorageType.setDescription('This variable represents the storage type value for the pB tables.')
pBIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: pBIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pBIndex.setDescription('This variable represents the index for the pB tables.')
pBAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 10), )
if mibBuilder.loadTexts: pBAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: pBAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
pBAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "pBIndex"))
if mibBuilder.loadTexts: pBAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pBAdminControlEntry.setDescription('An entry in the pBAdminControlTable.')
pBSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pBSnmpAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: pBSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
pBIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 11), )
if mibBuilder.loadTexts: pBIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: pBIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
pBIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "pBIndex"))
if mibBuilder.loadTexts: pBIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pBIfEntryEntry.setDescription('An entry in the pBIfEntryTable.')
pBIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pBIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pBIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
pBIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 11, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pBIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pBIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
pBMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 12), )
if mibBuilder.loadTexts: pBMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: pBMpTable.setDescription('This group contains the base provisioning data for the media base component.')
pBMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "pBIndex"))
if mibBuilder.loadTexts: pBMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pBMpEntry.setDescription('An entry in the pBMpTable.')
pBLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 12, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pBLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: pBLinkToProtocolPort.setDescription('This attribute specifies the ProtocolPort to which this interface is linked to. The protocol port is the logical interface to the network. The protocol port component describes the logical characteristics of this interface.')
pBOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 13), )
if mibBuilder.loadTexts: pBOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: pBOperTable.setDescription('This group includes the operational attibutes which are specific to the PseudoBridge component.')
pBOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "pBIndex"))
if mibBuilder.loadTexts: pBOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pBOperEntry.setDescription('An entry in the pBOperTable.')
pBMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 13, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pBMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pBMacAddress.setDescription('The medium access controller (MAC) address is an address that is only recognized by one station on the attached bus. This address is automatically assigned by the system.')
pBStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 14), )
if mibBuilder.loadTexts: pBStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: pBStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
pBStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "pBIndex"))
if mibBuilder.loadTexts: pBStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pBStateEntry.setDescription('An entry in the pBStateTable.')
pBAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pBAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: pBAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
pBOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pBOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: pBOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
pBUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pBUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: pBUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
pBOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 15), )
if mibBuilder.loadTexts: pBOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: pBOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
pBOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-BridgeMIB", "pBIndex"))
if mibBuilder.loadTexts: pBOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pBOperStatusEntry.setDescription('An entry in the pBOperStatusTable.')
pBSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 104, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: pBSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pBSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
bridgeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25, 1))
bridgeGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25, 1, 5))
bridgeGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25, 1, 5, 2))
bridgeGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25, 1, 5, 2, 2))
bridgeCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25, 3))
bridgeCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25, 3, 5))
bridgeCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25, 3, 5, 2))
bridgeCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 25, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-BridgeMIB", vrPpSrtBpSteSpanMode=vrPpSrtBpSteSpanMode, vrPpTbpAdminStatus=vrPpTbpAdminStatus, vrPpSrseComponentName=vrPpSrseComponentName, pBLinkToProtocolPort=pBLinkToProtocolPort, vrPpSrtBpUnicastNoMatches=vrPpSrtBpUnicastNoMatches, vrPpSrseStateEntry=vrPpSrseStateEntry, vrPpSrBpSteRdLimit=vrPpSrBpSteRdLimit, vrPpSrsgSpecInFrames=vrPpSrsgSpecInFrames, vrPpSrclPathCost=vrPpSrclPathCost, vrBrSrbStpProtocolSpec=vrBrSrbStpProtocolSpec, vrPpTbseInDiscards=vrPpTbseInDiscards, vrBr=vrBr, vrPpTbpMaxInfo=vrPpTbpMaxInfo, vrBrNsLastFilter=vrBrNsLastFilter, vrPpFddiETBOperEntry=vrPpFddiETBOperEntry, vrPpTbpNsOutgoingFilter=vrPpTbpNsOutgoingFilter, vrPpSrseMtuExceededDiscards=vrPpSrseMtuExceededDiscards, vrBrPteStpState=vrBrPteStpState, vrPpSrclDesignatedPort=vrPpSrclDesignatedPort, vrPpSrtBpDynamicEntryDiscards=vrPpSrtBpDynamicEntryDiscards, vrPpSrsgConvertArpMacAddress=vrPpSrsgConvertArpMacAddress, vrPpTbseInFrames=vrPpTbseInFrames, vrPpTbseStpTypeOper=vrPpTbseStpTypeOper, vrPpTbseTranslateIpx=vrPpTbseTranslateIpx, vrBrAdminState=vrBrAdminState, vrBrPteOperEntry=vrBrPteOperEntry, pBOperTable=pBOperTable, vrPpTbsgInFilterDiscards=vrPpTbsgInFilterDiscards, vrPpTbpStpOperTable=vrPpTbpStpOperTable, vrPpSrclFragmentIp=vrPpSrclFragmentIp, vrPpSrclSnmpOperStatus=vrPpSrclSnmpOperStatus, vrPpTbsgDynamicEntryDiscards=vrPpTbsgDynamicEntryDiscards, pBIfAdminStatus=pBIfAdminStatus, vrPpFddiETBDomainNum=vrPpFddiETBDomainNum, vrPpSrsgDelayExceededDiscards=vrPpSrsgDelayExceededDiscards, vrPpTbpDesignatedPort=vrPpTbpDesignatedPort, vrPpSrseStpProvEntry=vrPpSrseStpProvEntry, vrBrSrbStatsTable=vrBrSrbStatsTable, vrPpSrseBridgeNum=vrPpSrseBridgeNum, vrPpTbsgBridgePortType=vrPpTbsgBridgePortType, vrPpTbclDomainNum=vrPpTbclDomainNum, vrBrTbStpProtocolSpec=vrBrTbStpProtocolSpec, vrPpSrsgBridgePortConfig=vrPpSrsgBridgePortConfig, vrBrTbStpBridgeHelloTime=vrBrTbStpBridgeHelloTime, cBMacAddress=cBMacAddress, vrPpSrseTranslateIpx=vrPpSrseTranslateIpx, vrPpTbclNsStorageType=vrPpTbclNsStorageType, vrPpSrseSteRdLimit=vrPpSrseSteRdLimit, vrBrTbNcFteStorageType=vrBrTbNcFteStorageType, vrPpSrclBridgePortType=vrPpSrclBridgePortType, vrPpTbpSnmpOperStatus=vrPpTbpSnmpOperStatus, vrPpSrseSrStatsTable=vrPpSrseSrStatsTable, vrPpTbseTbProvEntry=vrPpTbseTbProvEntry, pBIndex=pBIndex, vrBrNsStorageType=vrBrNsStorageType, vrPpSrBpLargestFrame=vrPpSrBpLargestFrame, vrPpSrcl=vrPpSrcl, vrPpTbclTbProvTable=vrPpTbclTbProvTable, vrBrOperStatusEntry=vrBrOperStatusEntry, pBComponentName=pBComponentName, vrPpTbsgOperStatusEntry=vrPpTbsgOperStatusEntry, vrPpFddiETBTbProvTable=vrPpFddiETBTbProvTable, vrPpFddiETBNsRowStatusEntry=vrPpFddiETBNsRowStatusEntry, vrPpTbpTbOperEntry=vrPpTbpTbOperEntry, vrPpSrseDIProvEntry=vrPpSrseDIProvEntry, vrPpSrtBpProvTable=vrPpSrtBpProvTable, vrPpTbseIndex=vrPpTbseIndex, vrPpTbsePortStateStpControl=vrPpTbsePortStateStpControl, vrBrOperStatusTable=vrBrOperStatusTable, vrBrSrbStpRowStatus=vrBrSrbStpRowStatus, vrPpSrBpOperStatusTable=vrPpSrBpOperStatusTable, bridgeGroupBE01=bridgeGroupBE01, vrPpSrtBpDupSegmentDiscards=vrPpSrtBpDupSegmentDiscards, vrBrNsAte=vrBrNsAte, vrBrSrbStorageType=vrBrSrbStorageType, cBRowStatusEntry=cBRowStatusEntry, vrBrTbStpPriority=vrBrTbStpPriority, vrPpSrsgSrProvTable=vrPpSrsgSrProvTable, vrBrTbFteRowStatus=vrBrTbFteRowStatus, vrPpSrseDynamicDiscards=vrPpSrseDynamicDiscards, vrPpSrtBpInDiscards=vrPpSrtBpInDiscards, vrPpTbseProvEntry=vrPpTbseProvEntry, vrBrTbSteStorageType=vrBrTbSteStorageType, vrPpSrBpTinygramFramesIn=vrPpSrBpTinygramFramesIn, vrPpTbsgDesignatedRoot=vrPpTbsgDesignatedRoot, vrBrTbStpRootCost=vrBrTbStpRootCost, vrPpTbsgFragmentIp=vrPpTbsgFragmentIp, vrBrTbProvTable=vrBrTbProvTable, vrPpTbpBridgePortConfig=vrPpTbpBridgePortConfig, vrBrTbStpOperTable=vrBrTbStpOperTable, pBIfEntryTable=pBIfEntryTable, vrPpSrtBpOutFilterDiscards=vrPpSrtBpOutFilterDiscards, vrPpTbclOperTable=vrPpTbclOperTable, vrPpFddiETBOutFilterDiscards=vrPpFddiETBOutFilterDiscards, vrPpSrsgDesignatedPort=vrPpSrsgDesignatedPort, vrBrTbNcFteAddressIndex=vrBrTbNcFteAddressIndex, vrBrPteLanId=vrBrPteLanId, vrBrPteInternalLanId=vrBrPteInternalLanId, vrPpSrsgDynamicDiscards=vrPpSrsgDynamicDiscards, vrBrTbSteRowStatus=vrBrTbSteRowStatus, vrPpTbseProvTable=vrPpTbseProvTable, vrBrTbNcFteComponentName=vrBrTbNcFteComponentName, vrPpSrBpDupSegmentDiscards=vrPpSrBpDupSegmentDiscards, vrBrSrbRowStatusTable=vrBrSrbRowStatusTable, vrPpSrseBadAbstractDiscards=vrPpSrseBadAbstractDiscards, vrBrPteModeIndex=vrBrPteModeIndex, vrBrSrbStpTopologyChangeDetect=vrBrSrbStpTopologyChangeDetect, vrPpFddiETBDelayExceededDiscards=vrPpFddiETBDelayExceededDiscards, vrPpSrBpSteSpanMode=vrPpSrBpSteSpanMode, vrPpSrclAdminState=vrPpSrclAdminState, vrPpSrsgOperTable=vrPpSrsgOperTable, pBIfIndex=pBIfIndex, vrBrSrbLtePortName=vrBrSrbLtePortName, vrPpSrBpRowStatus=vrPpSrBpRowStatus, vrPpSrseDupSegmentDiscards=vrPpSrseDupSegmentDiscards, vrBrSrbStp=vrBrSrbStp, vrPpSrBpLanId=vrPpSrBpLanId, vrPpTbseDIProvTable=vrPpTbseDIProvTable, vrPpSrclSteRdLimit=vrPpSrclSteRdLimit, vrPpFddiETBStaticEntryDiscards=vrPpFddiETBStaticEntryDiscards, vrPpSrclPortNum=vrPpSrclPortNum, vrPpFddiETBTranslateIpx=vrPpFddiETBTranslateIpx, vrPpSrBpIfIndex=vrPpSrBpIfIndex, vrBrRowStatusEntry=vrBrRowStatusEntry, vrPpTbclMtuExceededDiscards=vrPpTbclMtuExceededDiscards, vrPpSrsgLanIdMismatches=vrPpSrsgLanIdMismatches, vrPpSrclProvTable=vrPpSrclProvTable, vrPpTbclMaxInfo=vrPpTbclMaxInfo, vrPpSrsgRowStatusEntry=vrPpSrsgRowStatusEntry, vrPpSrseAdminStatus=vrPpSrseAdminStatus, vrPpTbsgRowStatus=vrPpTbsgRowStatus, vrPpTbsgUnicastNoMatches=vrPpTbsgUnicastNoMatches, vrPpSrclDupSegmentDiscards=vrPpSrclDupSegmentDiscards, vrPpFddiETBStatsTable=vrPpFddiETBStatsTable, vrPpTbseBridgePortConfig=vrPpTbseBridgePortConfig, vrBrSrbNumLanIdtEntriesFree=vrBrSrbNumLanIdtEntriesFree, vrPpTbpProvTable=vrPpTbpProvTable, vrPpTbseDomainNum=vrPpTbseDomainNum, vrPpSrclStorageType=vrPpSrclStorageType, cBComponentName=cBComponentName, vrPpTbsePortName=vrPpTbsePortName, vrPpSrsgExploreFrameTreatment=vrPpSrsgExploreFrameTreatment, pBMpEntry=pBMpEntry, vrPpTbsgBridgePortConfig=vrPpTbsgBridgePortConfig, vrPpSrtBpOutFrames=vrPpSrtBpOutFrames, vrPpSrsgStpPortState=vrPpSrsgStpPortState, vrPpSrclSteOutFrames=vrPpSrclSteOutFrames, vrPpSrseForwardTransitions=vrPpSrseForwardTransitions, vrPpSrseStatsTable=vrPpSrseStatsTable, vrPpTbseBadVerifyDiscards=vrPpTbseBadVerifyDiscards, vrPpFddiETBStpPortState=vrPpFddiETBStpPortState, vrPpSrsgSteSpanMode=vrPpSrsgSteSpanMode, vrPpSrclStpOperEntry=vrPpSrclStpOperEntry, vrPpTbpPreserveDomain=vrPpTbpPreserveDomain, vrBrPteSpOperEntry=vrBrPteSpOperEntry, vrBrSrbAgingTime=vrBrSrbAgingTime, vrPpTbclPortStateStpControl=vrPpTbclPortStateStpControl, vrPpTbsgPortStateStpControl=vrPpTbsgPortStateStpControl, vrPpSrBpDIProvTable=vrPpSrBpDIProvTable, vrBrSrbLteRowStatusTable=vrBrSrbLteRowStatusTable, vrPpFddiETBOperTable=vrPpFddiETBOperTable, pBIfEntryEntry=pBIfEntryEntry, vrPpSrBp=vrPpSrBp, vrPpSrBpDomainNum=vrPpSrBpDomainNum, vrPpSrseSpecInFrames=vrPpSrseSpecInFrames, vrPpFddiETBPortStateStpControl=vrPpFddiETBPortStateStpControl, vrPpSrsgDomainNum=vrPpSrsgDomainNum, pBMacAddress=pBMacAddress, vrPpSrtBpStpTypeOper=vrPpSrtBpStpTypeOper, vrBrSrbStpAgingTimeOper=vrBrSrbStpAgingTimeOper, vrPpFddiETBIndex=vrPpFddiETBIndex, vrPpSrsgStpOperTable=vrPpSrsgStpOperTable, vrPpTbclSnmpOperStatus=vrPpTbclSnmpOperStatus, vrPpTbpOutboundFrameMediaType=vrPpTbpOutboundFrameMediaType, vrPpSrsePortNum=vrPpSrsePortNum, vrBrNsRowStatusTable=vrBrNsRowStatusTable, vrPpTbseStorageType=vrPpTbseStorageType, vrPpSrclTinygramFramesOut=vrPpSrclTinygramFramesOut, vrPpSrBpStatsTable=vrPpSrBpStatsTable, vrPpTbclStpTypeProv=vrPpTbclStpTypeProv, vrPpSrclDownTime=vrPpSrclDownTime, cBLinkToProtocolPort=cBLinkToProtocolPort, pBRowStatus=pBRowStatus, vrBrTbStpTopologyChanges=vrBrTbStpTopologyChanges, vrBrTbSteProvTable=vrBrTbSteProvTable, vrBrSrbStpBridgeId=vrBrSrbStpBridgeId, vrPpTbseUpTime=vrPpTbseUpTime, vrBrSrbLanIdTableNumEntries=vrBrSrbLanIdTableNumEntries, vrPpSrtBpOperTable=vrPpSrtBpOperTable, vrPpSrBpInternalLanId=vrPpSrBpInternalLanId, vrPpSrsgOperationalState=vrPpSrsgOperationalState, vrPpSrsgSnmpOperStatus=vrPpSrsgSnmpOperStatus, vrPpTbpForwardTransitions=vrPpTbpForwardTransitions, vrBrNsAteRowStatus=vrBrNsAteRowStatus, vrPpSrtBpApeInFrames=vrPpSrtBpApeInFrames, vrBrSrbRowStatus=vrBrSrbRowStatus, vrBrTbRowStatusTable=vrBrTbRowStatusTable, vrBrTbFteDomainNumIndex=vrBrTbFteDomainNumIndex, vrPpSrsgSteOutFrames=vrPpSrsgSteOutFrames, vrPpSrtBpStpOperTable=vrPpSrtBpStpOperTable, vrPpTbseInFilterDiscards=vrPpTbseInFilterDiscards, vrPpSrtBpOperStatusEntry=vrPpSrtBpOperStatusEntry, vrPpFddiETBStorageType=vrPpFddiETBStorageType, vrPpSrseExploreFrameTreatment=vrPpSrseExploreFrameTreatment, vrPpSrclPathCostMethod=vrPpSrclPathCostMethod, vrPpTbseStaticEntryDiscards=vrPpTbseStaticEntryDiscards, vrPpSrclSegmentMismatchDiscards=vrPpSrclSegmentMismatchDiscards, vrPpTbclPathCost=vrPpTbclPathCost, vrPpSrsgBridgeNum=vrPpSrsgBridgeNum, bridgeGroupBE=bridgeGroupBE, vrPpTbclDIProvTable=vrPpTbclDIProvTable, vrPpSrclApeOutFrames=vrPpSrclApeOutFrames, vrBrTbRowStatusEntry=vrBrTbRowStatusEntry, vrPpSrtBpIfIndex=vrPpSrtBpIfIndex, vrBrSrbLteOperTable=vrBrSrbLteOperTable, vrPpFddiETBUpTime=vrPpFddiETBUpTime, vrPpTbsgInFrames=vrPpTbsgInFrames, vrBrTbFwdTableNumEntries=vrBrTbFwdTableNumEntries, vrPpSrclDIProvEntry=vrPpSrclDIProvEntry, vrPpSrtBpTinygramFramesIn=vrPpSrtBpTinygramFramesIn, vrPpTbclFragmentIp=vrPpTbclFragmentIp, vrPpFddiETBNsRowStatus=vrPpFddiETBNsRowStatus, vrPpTbsgStpOperEntry=vrPpTbsgStpOperEntry, vrPpSrBpStpPortState=vrPpSrBpStpPortState, vrPpTbseStateEntry=vrPpTbseStateEntry, vrPpSrclBridgingMode=vrPpSrclBridgingMode, vrPpTbsgDownTime=vrPpTbsgDownTime, vrPpTbsgDomainNum=vrPpTbsgDomainNum, vrBrTbSteAtgtValue=vrBrTbSteAtgtValue, vrPpSrtBpStpTypeProv=vrPpSrtBpStpTypeProv, vrPpTbclPathCostMethod=vrPpTbclPathCostMethod, vrPpSrseSnmpOperStatus=vrPpSrseSnmpOperStatus, vrPpSrtBpOperStatusTable=vrPpSrtBpOperStatusTable, vrPpSrsgStpTypeProv=vrPpSrsgStpTypeProv, vrPpFddiETBOutFrames=vrPpFddiETBOutFrames, vrPpTbclTbProvEntry=vrPpTbclTbProvEntry, vrPpSrBpProvEntry=vrPpSrBpProvEntry, vrPpSrseStpPortState=vrPpSrseStpPortState, vrPpSrsgPortName=vrPpSrsgPortName, cBRowStatus=cBRowStatus, vrPpFddiETBStatsEntry=vrPpFddiETBStatsEntry, vrPpSrsgProvEntry=vrPpSrsgProvEntry, vrPpTbpPortStateStpControl=vrPpTbpPortStateStpControl, vrBrSrbLteLanIdIndex=vrBrSrbLteLanIdIndex, vrPpTbsgStatsTable=vrPpTbsgStatsTable, vrPpFddiETBSecureOption=vrPpFddiETBSecureOption, vrPpTbclRowStatusEntry=vrPpTbclRowStatusEntry, vrPpFddiETBInDiscards=vrPpFddiETBInDiscards, vrPpTbsgStorageType=vrPpTbsgStorageType, vrPpSrseStpProvTable=vrPpSrseStpProvTable, vrPpTbseDesignatedBridge=vrPpTbseDesignatedBridge, vrPpSrclStaticDiscards=vrPpSrclStaticDiscards, vrPpTbclNsComponentName=vrPpTbclNsComponentName, vrPpSrclOperTable=vrPpSrclOperTable)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-BridgeMIB", vrPpSrBpSrStatsEntry=vrPpSrBpSrStatsEntry, vrPpSrseBridgingMode=vrPpSrseBridgingMode, vrPpSrsgOperStatusTable=vrPpSrsgOperStatusTable, vrPpTbclStaticEntryDiscards=vrPpTbclStaticEntryDiscards, vrPpTbsgTbOperTable=vrPpTbsgTbOperTable, vrBrSrbStpOperTable=vrBrSrbStpOperTable, vrPpTbsgIfIndex=vrPpTbsgIfIndex, vrPpTbpFragmentIp=vrPpTbpFragmentIp, vrPpSrsePortPriority=vrPpSrsePortPriority, vrPpTbpTbOperTable=vrPpTbpTbOperTable, vrPpSrsgDupSegmentDiscards=vrPpSrsgDupSegmentDiscards, vrPpSrBpNsRowStatusEntry=vrPpSrBpNsRowStatusEntry, vrPpSrsgDownTime=vrPpSrsgDownTime, vrPpSrsgBridgePortType=vrPpSrsgBridgePortType, vrPpTbsgIndex=vrPpTbsgIndex, vrBrNs=vrBrNs, vrPpTbclStpPortState=vrPpTbclStpPortState, vrPpFddiETBOutboundFrameMediaType=vrPpFddiETBOutboundFrameMediaType, vrBrTbStpTopologyChangeDetect=vrBrTbStpTopologyChangeDetect, vrBrTbFteStatus=vrBrTbFteStatus, vrPpSrclStatsEntry=vrPpSrclStatsEntry, vrPpSrsgTinygramFramesOut=vrPpSrsgTinygramFramesOut, vrBrTbNcFtePeerAddressInfo=vrBrTbNcFtePeerAddressInfo, vrPpSrseDesignatedRoot=vrPpSrseDesignatedRoot, vrPpFddiETBAdminStatus=vrPpFddiETBAdminStatus, pBStorageType=pBStorageType, vrPpTbclBadAbstractDiscards=vrPpTbclBadAbstractDiscards, vrPpFddiETBInFilterDiscards=vrPpFddiETBInFilterDiscards, vrPpTbclPortName=vrPpTbclPortName, vrPpSrBpDynamicDiscards=vrPpSrBpDynamicDiscards, vrPpSrclStpOperTable=vrPpSrclStpOperTable, vrPpSrBpForwardTransitions=vrPpSrBpForwardTransitions, vrBrNsAteProvTable=vrBrNsAteProvTable, vrBrSrbStpHoldTime=vrBrSrbStpHoldTime, vrPpSrseDesignatedCost=vrPpSrseDesignatedCost, vrPpTbpRowStatusEntry=vrPpTbpRowStatusEntry, vrBrPteBridgeNum=vrBrPteBridgeNum, bridgeCapabilitiesBE01A=bridgeCapabilitiesBE01A, vrBrTbSteAtgtRowStatus=vrBrTbSteAtgtRowStatus, vrPpTbclNsIndex=vrPpTbclNsIndex, vrPpSrtBpInFilterDiscards=vrPpSrtBpInFilterDiscards, vrPpSrclPortStateStpControl=vrPpSrclPortStateStpControl, vrBrNsAteComponentName=vrBrNsAteComponentName, vrPpTbseBlockingDiscards=vrPpTbseBlockingDiscards, pBOperationalState=pBOperationalState, vrBrTbStatsEntry=vrBrTbStatsEntry, vrBrTbStpTimeSinceTopologyChange=vrBrTbStpTimeSinceTopologyChange, vrPpSrsgPortPriority=vrPpSrsgPortPriority, pBRowStatusTable=pBRowStatusTable, vrPpTbseTinygramFramesOut=vrPpTbseTinygramFramesOut, vrPpSrsgOperStatusEntry=vrPpSrsgOperStatusEntry, vrPpTbpPortName=vrPpTbpPortName, vrPpTbpNsRowStatusTable=vrPpTbpNsRowStatusTable, vrPpSrBpOperEntry=vrPpSrBpOperEntry, vrPpSrsgDIProvTable=vrPpSrsgDIProvTable, vrPpFddiETBRowStatusEntry=vrPpFddiETBRowStatusEntry, vrPpTbseStpOperTable=vrPpTbseStpOperTable, vrPpTbsgTbOperEntry=vrPpTbsgTbOperEntry, vrBrBridgeAddress=vrBrBridgeAddress, vrBrTbStpHelloTime=vrBrTbStpHelloTime, vrPpSrseTinygramFramesIn=vrPpSrseTinygramFramesIn, vrBrSrbLteStorageType=vrBrSrbLteStorageType, vrPpSrsgRowStatusTable=vrPpSrsgRowStatusTable, vrPpFddiETBStpProvTable=vrPpFddiETBStpProvTable, vrPpSrclPathCostOper=vrPpSrclPathCostOper, vrPpTbpOutFrames=vrPpTbpOutFrames, vrBrTbNcFteOperTable=vrBrTbNcFteOperTable, vrPpTbsgUsageState=vrPpTbsgUsageState, vrPpTbclIndex=vrPpTbclIndex, vrPpTbsgPortPriority=vrPpTbsgPortPriority, vrPpTbseMtuExceededDiscards=vrPpTbseMtuExceededDiscards, vrPpTbpDomainNum=vrPpTbpDomainNum, vrPpTbseMaxInfo=vrPpTbseMaxInfo, vrPpSrclRowStatusTable=vrPpSrclRowStatusTable, vrPpTbpOperStatusEntry=vrPpTbpOperStatusEntry, vrPpFddiETBPortName=vrPpFddiETBPortName, vrBrTbNumFtEntriesFree=vrBrTbNumFtEntriesFree, vrBrSrbComponentName=vrBrSrbComponentName, vrPpTbseDynamicEntryDiscards=vrPpTbseDynamicEntryDiscards, vrPpSrtBpConvertArpMacAddress=vrPpSrtBpConvertArpMacAddress, vrPpSrBpStpProvEntry=vrPpSrBpStpProvEntry, vrPpTbpNsIncomingFilter=vrPpTbpNsIncomingFilter, vrPpSrseOperationalState=vrPpSrseOperationalState, vrPpTbpDIProvTable=vrPpTbpDIProvTable, vrPpSrseIndex=vrPpSrseIndex, vrPpSrseSteOutFrames=vrPpSrseSteOutFrames, vrBrNsAteFilterName=vrBrNsAteFilterName, vrPpTbclNsProvEntry=vrPpTbclNsProvEntry, vrPpTbclDynamicEntryDiscards=vrPpTbclDynamicEntryDiscards, vrBrSrbLteDomainNumIndex=vrBrSrbLteDomainNumIndex, vrPpTbsgTinygramFramesIn=vrPpTbsgTinygramFramesIn, vrBrTbStpProvTable=vrBrTbStpProvTable, vrPpSrclSrStatsEntry=vrPpSrclSrStatsEntry, vrPpSrtBpNsRowStatus=vrPpSrtBpNsRowStatus, vrPpFddiETBBridgePortConfig=vrPpFddiETBBridgePortConfig, vrPpFddiETBDynamicEntryDiscards=vrPpFddiETBDynamicEntryDiscards, vrPpSrsePathCostMethod=vrPpSrsePathCostMethod, vrBrSrbStpProvTable=vrBrSrbStpProvTable, vrBrSrbNumLanIdtEntriesDenied=vrBrSrbNumLanIdtEntriesDenied, vrPpFddiETBStateTable=vrPpFddiETBStateTable, vrPpTbpNsIndex=vrPpTbpNsIndex, vrPpTbpUsageState=vrPpTbpUsageState, vrPpSrseProvEntry=vrPpSrseProvEntry, vrPpSrseInternalLanId=vrPpSrseInternalLanId, vrPpSrclRowStatus=vrPpSrclRowStatus, vrPpSrclBlockingDiscards=vrPpSrclBlockingDiscards, vrPpSrclStpTypeOper=vrPpSrclStpTypeOper, vrPpSrseDelayExceededDiscards=vrPpSrseDelayExceededDiscards, vrPpTbclUnicastNoMatches=vrPpTbclUnicastNoMatches, bridgeCapabilitiesBE=bridgeCapabilitiesBE, vrBrSrbLteRowStatus=vrBrSrbLteRowStatus, vrPpTbseOperationalState=vrPpTbseOperationalState, vrPpSrBpApeInFrames=vrPpSrBpApeInFrames, vrBrNsRowStatus=vrBrNsRowStatus, vrPpSrtBpSrProvEntry=vrPpSrtBpSrProvEntry, vrPpSrtBpBridgeNum=vrPpSrtBpBridgeNum, vrPpFddiETBLearningDiscards=vrPpFddiETBLearningDiscards, vrPpTbsePortNum=vrPpTbsePortNum, vrPpTbclDesignatedCost=vrPpTbclDesignatedCost, vrPpSrtBpDesignatedPort=vrPpSrtBpDesignatedPort, vrPpTbsgSnmpOperStatus=vrPpTbsgSnmpOperStatus, vrPpTbclInDiscards=vrPpTbclInDiscards, vrPpSrBpDesignatedRoot=vrPpSrBpDesignatedRoot, vrPpTbseConvertArpMacAddress=vrPpTbseConvertArpMacAddress, vrPpTbseUsageState=vrPpTbseUsageState, vrBrSrbStpTopologyChanges=vrBrSrbStpTopologyChanges, vrPpSrtBpNsComponentName=vrPpSrtBpNsComponentName, vrPpSrsgBlockingDiscards=vrPpSrsgBlockingDiscards, vrPpSrBpPortNum=vrPpSrBpPortNum, vrBrSnmpOperStatus=vrBrSnmpOperStatus, vrPpTbclOutFilterDiscards=vrPpTbclOutFilterDiscards, vrPpTbpUpTime=vrPpTbpUpTime, vrBrTbSteRowStatusEntry=vrBrTbSteRowStatusEntry, vrPpTbclOperStatusEntry=vrPpTbclOperStatusEntry, vrPpSrsgApeOutFrames=vrPpSrsgApeOutFrames, vrPpSrBpSpecInFrames=vrPpSrBpSpecInFrames, vrPpTbseAdminStatus=vrPpTbseAdminStatus, vrBrTbSteProvEntry=vrBrTbSteProvEntry, vrPpSrsgPortNum=vrPpSrsgPortNum, vrBrTbStatsTable=vrBrTbStatsTable, vrBrTbStpRowStatusEntry=vrBrTbStpRowStatusEntry, vrBrRowStatusTable=vrBrRowStatusTable, vrPpTbpUnicastNoMatches=vrPpTbpUnicastNoMatches, vrBrNsAteProvEntry=vrBrNsAteProvEntry, vrBrNumPorts=vrBrNumPorts, vrBrSrbLteRowStatusEntry=vrBrSrbLteRowStatusEntry, vrBrTbIndex=vrBrTbIndex, vrPpTbsgComponentName=vrPpTbsgComponentName, vrBrOperEntry=vrBrOperEntry, vrPpTbpTranslateIpx=vrPpTbpTranslateIpx, vrPpTbpBridgePortType=vrPpTbpBridgePortType, vrPpTbsgDesignatedBridge=vrPpTbsgDesignatedBridge, vrPpSrclAdminStatus=vrPpSrclAdminStatus, vrBrAdminStatus=vrBrAdminStatus, vrBrTbFteAgeOfEntry=vrBrTbFteAgeOfEntry, pBMpTable=pBMpTable, vrPpFddiETBUsageState=vrPpFddiETBUsageState, pBStateEntry=pBStateEntry, vrBrTbStpOperEntry=vrBrTbStpOperEntry, vrBrSrbLteOperEntry=vrBrSrbLteOperEntry, vrPpTbseFragmentIp=vrPpTbseFragmentIp, vrBrTbStpRowStatus=vrBrTbStpRowStatus, vrPpSrBpNsIncomingFilter=vrPpSrBpNsIncomingFilter, vrPpSrsgUsageState=vrPpSrsgUsageState, vrBrSrbStpBridgeHelloTime=vrBrSrbStpBridgeHelloTime, vrPpSrtBpDIProvEntry=vrPpSrtBpDIProvEntry, vrPpTbsgStpTypeOper=vrPpTbsgStpTypeOper, vrPpSrse=vrPpSrse, vrPpTbseDesignatedCost=vrPpTbseDesignatedCost, vrPpSrclInFilterDiscards=vrPpSrclInFilterDiscards, vrPpSrsgStpProvEntry=vrPpSrsgStpProvEntry, cBUsageState=cBUsageState, vrPpSrsgForwardTransitions=vrPpSrsgForwardTransitions, vrBrNsAteSecondMacAddressMask=vrBrNsAteSecondMacAddressMask, vrBrTbStpDesignatedRoot=vrBrTbStpDesignatedRoot, vrBrSrbStpStorageType=vrBrSrbStpStorageType, vrPpSrBpMtuExceededDiscards=vrPpSrBpMtuExceededDiscards, vrPpTbsgBadAbstractDiscards=vrPpTbsgBadAbstractDiscards, cBOperationalState=cBOperationalState, vrPpSrclDesignatedRoot=vrPpSrclDesignatedRoot, vrPpTbpOperStatusTable=vrPpTbpOperStatusTable, vrPpSrseDomainNum=vrPpSrseDomainNum, vrPpSrBpNsComponentName=vrPpSrBpNsComponentName, vrBrSrbLteAgeOfEntry=vrBrSrbLteAgeOfEntry, vrPpSrsgPreserveDomain=vrPpSrsgPreserveDomain, vrPpTbpOutFilterDiscards=vrPpTbpOutFilterDiscards, vrPpSrtBpIndex=vrPpSrtBpIndex, vrPpSrclConvertArpMacAddress=vrPpSrclConvertArpMacAddress, vrBrNsFirstFilter=vrBrNsFirstFilter, cBStateEntry=cBStateEntry, vrBrTbSteAtgtTable=vrBrTbSteAtgtTable, vrPpTbpBlockingDiscards=vrPpTbpBlockingDiscards, vrPpTbclDesignatedRoot=vrPpTbclDesignatedRoot, vrPpTbpStpProvTable=vrPpTbpStpProvTable, vrPpTbpTbProvEntry=vrPpTbpTbProvEntry, vrPpSrtBpTinygramFramesOut=vrPpSrtBpTinygramFramesOut, vrPpTbsePathCostOper=vrPpTbsePathCostOper, vrPpTbsgProvEntry=vrPpTbsgProvEntry, vrPpSrclLargestFrame=vrPpSrclLargestFrame, vrPpTbsgTranslateIpx=vrPpTbsgTranslateIpx, vrPpSrBpSpecOutFrames=vrPpSrBpSpecOutFrames, vrPpSrBpNsStorageType=vrPpSrBpNsStorageType, vrPpSrBpSegmentMismatchDiscards=vrPpSrBpSegmentMismatchDiscards, cBIfEntryTable=cBIfEntryTable, vrPpTbclPathCostOper=vrPpTbclPathCostOper, vrPpSrtBpSnmpOperStatus=vrPpSrtBpSnmpOperStatus, vrPpTbpOperTable=vrPpTbpOperTable, vrPpSrBpExploreFrameTreatment=vrPpSrBpExploreFrameTreatment, vrPpSrBpBridgePortType=vrPpSrBpBridgePortType, vrPpSrBpBadAbstractDiscards=vrPpSrBpBadAbstractDiscards, vrBrTbStpComponentName=vrBrTbStpComponentName, vrBrSrbStpDesignatedRoot=vrBrSrbStpDesignatedRoot, vrPpTbclNsRowStatus=vrPpTbclNsRowStatus, cBOperStatusTable=cBOperStatusTable, vrPpSrclNs=vrPpSrclNs, cBRowStatusTable=cBRowStatusTable, vrBrTbFteRowStatusEntry=vrBrTbFteRowStatusEntry, vrPpTbclTinygramFramesOut=vrPpTbclTinygramFramesOut, vrPpFddiETBUnicastNoMatches=vrPpFddiETBUnicastNoMatches, vrPpSrsgApeInFrames=vrPpSrsgApeInFrames, vrBrSrbStpFwdDelay=vrBrSrbStpFwdDelay, vrPpSrtBpStpOperEntry=vrPpSrtBpStpOperEntry, vrPpSrBpLanIdMismatches=vrPpSrBpLanIdMismatches, vrPpFddiETBInFrames=vrPpFddiETBInFrames, pBOperEntry=pBOperEntry, vrPpSrsePreserveDomain=vrPpSrsePreserveDomain, vrBrStateEntry=vrBrStateEntry, vrBrTbFteOperEntry=vrBrTbFteOperEntry, vrPpTbclTinygramFramesIn=vrPpTbclTinygramFramesIn, vrPpFddiETBAdminState=vrPpFddiETBAdminState, vrPpTbseBadAbstractDiscards=vrPpTbseBadAbstractDiscards, vrPpSrtBpSteOutFrames=vrPpSrtBpSteOutFrames, vrBrStorageType=vrBrStorageType, vrBrSrb=vrBrSrb, vrPpTbseStpTypeProv=vrPpTbseStpTypeProv, vrPpTbpTbProvTable=vrPpTbpTbProvTable, vrBrTbFteStorageType=vrBrTbFteStorageType, vrPpFddiETBIfIndex=vrPpFddiETBIfIndex, vrPpTbseStpProvTable=vrPpTbseStpProvTable, vrPpFddiETBNsOutgoingFilter=vrPpFddiETBNsOutgoingFilter, vrPpSrtBpTbProvEntry=vrPpSrtBpTbProvEntry, vrPpSrtBpAdminStatus=vrPpSrtBpAdminStatus, vrPpSrtBpOperationalState=vrPpSrtBpOperationalState, vrPpTbpNs=vrPpTbpNs, vrPpSrsgTranslateIpx=vrPpSrsgTranslateIpx, vrPpTbsePathCost=vrPpTbsePathCost, vrPpSrsgSpecOutFrames=vrPpSrsgSpecOutFrames, vrPpTbclStpProvTable=vrPpTbclStpProvTable, vrPpTbpPortNum=vrPpTbpPortNum, vrPpSrseStorageType=vrPpSrseStorageType, vrBrTbFte=vrBrTbFte, vrPpFddiETBTbOperEntry=vrPpFddiETBTbOperEntry, vrPpTbclStpProvEntry=vrPpTbclStpProvEntry, cBMpTable=cBMpTable)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-BridgeMIB", vrBrTbStpMaxAge=vrBrTbStpMaxAge, vrPpSrtBpAdminState=vrPpSrtBpAdminState, vrPpTbclTbOperEntry=vrPpTbclTbOperEntry, vrPpFddiETBMaxInfo=vrPpFddiETBMaxInfo, vrPpSrBpApeOutFrames=vrPpSrBpApeOutFrames, vrPpFddiETBOperStatusTable=vrPpFddiETBOperStatusTable, vrBrPteComponentName=vrBrPteComponentName, vrPpTbpInFrames=vrPpTbpInFrames, vrPpFddiETBPathCost=vrPpFddiETBPathCost, vrBrTbFteComponentName=vrBrTbFteComponentName, bridgeGroupBE01A=bridgeGroupBE01A, vrPpSrseLanId=vrPpSrseLanId, vrPpSrseRowStatusTable=vrPpSrseRowStatusTable, vrPpTbpStorageType=vrPpTbpStorageType, vrPpSrsgStorageType=vrPpSrsgStorageType, vrPpTbpIndex=vrPpTbpIndex, vrPpTbpServiceClass=vrPpTbpServiceClass, vrPpTbpIfIndex=vrPpTbpIfIndex, vrPpSrtBpUpTime=vrPpSrtBpUpTime, vrPpTbseOperStatusTable=vrPpTbseOperStatusTable, vrPpTbpDesignatedBridge=vrPpTbpDesignatedBridge, vrPpSrseFragmentIp=vrPpSrseFragmentIp, vrPpSrclStatsTable=vrPpSrclStatsTable, vrBrNsProvEntry=vrBrNsProvEntry, vrPpSrtBpBridgingMode=vrPpSrtBpBridgingMode, vrPpSrseInFilterDiscards=vrPpSrseInFilterDiscards, vrPpSrsgInternalLanId=vrPpSrsgInternalLanId, cBIfIndex=cBIfIndex, vrBrTbComponentName=vrBrTbComponentName, vrPpTbsgTinygramFramesOut=vrPpTbsgTinygramFramesOut, vrPpTbseBridgePortType=vrPpTbseBridgePortType, vrPpTbpTinygramFramesIn=vrPpTbpTinygramFramesIn, vrPpSrBpOutFilterDiscards=vrPpSrBpOutFilterDiscards, vrPpSrclStpTypeProv=vrPpSrclStpTypeProv, vrPpFddiETBComponentName=vrPpFddiETBComponentName, vrPpTbclStatsTable=vrPpTbclStatsTable, vrPpTbclOperEntry=vrPpTbclOperEntry, vrPpFddiETBBadVerifyDiscards=vrPpFddiETBBadVerifyDiscards, vrPpSrtBp=vrPpSrtBp, vrPpTbseBridgingMode=vrPpTbseBridgingMode, vrPpSrclSrProvTable=vrPpSrclSrProvTable, vrPpTbclComponentName=vrPpTbclComponentName, vrPpSrBpPreserveDomain=vrPpSrBpPreserveDomain, vrPpTbsgPortNum=vrPpTbsgPortNum, vrPpSrseDIProvTable=vrPpSrseDIProvTable, vrPpSrclOperStatusEntry=vrPpSrclOperStatusEntry, vrPpTbpPathCostOper=vrPpTbpPathCostOper, vrPpTbpStateEntry=vrPpTbpStateEntry, vrPpSrtBpForwardTransitions=vrPpSrtBpForwardTransitions, vrPpTbsgStateEntry=vrPpTbsgStateEntry, vrPpTbclDesignatedBridge=vrPpTbclDesignatedBridge, vrBrSrbRowStatusEntry=vrBrSrbRowStatusEntry, vrPpSrtBpInternalLanId=vrPpSrtBpInternalLanId, vrPpFddiETBOperationalState=vrPpFddiETBOperationalState, vrPpFddiETBDownTime=vrPpFddiETBDownTime, vrPpFddiETBServiceClass=vrPpFddiETBServiceClass, vrPpSrBpNsIndex=vrPpSrBpNsIndex, vrBrPteSpOperTable=vrBrPteSpOperTable, vrPpSrsgPathCost=vrPpSrsgPathCost, vrPpTbsgStpTypeProv=vrPpTbsgStpTypeProv, vrPpSrclStpProvEntry=vrPpSrclStpProvEntry, vrPpSrtBpBadVerifyDiscards=vrPpSrtBpBadVerifyDiscards, vrPpSrseUsageState=vrPpSrseUsageState, vrBrNsAteRowStatusTable=vrBrNsAteRowStatusTable, vrBrSrbLteTypeOfEntry=vrBrSrbLteTypeOfEntry, vrBrPteStpType=vrBrPteStpType, vrPpTbclInFrames=vrPpTbclInFrames, vrPpSrclHopCountExceededDiscards=vrPpSrclHopCountExceededDiscards, vrBrTbLearnedEntryDiscards=vrBrTbLearnedEntryDiscards, vrPpSrBpBlockingDiscards=vrPpSrBpBlockingDiscards, vrPpFddiETBBridgePortType=vrPpFddiETBBridgePortType, vrPpSrBpNs=vrPpSrBpNs, vrPpSrclServiceClass=vrPpSrclServiceClass, vrPpSrclNsRowStatusTable=vrPpSrclNsRowStatusTable, vrPpSrBpStatsEntry=vrPpSrBpStatsEntry, vrPpTbclInFilterDiscards=vrPpTbclInFilterDiscards, vrPpSrBpStpTypeProv=vrPpSrBpStpTypeProv, vrPpSrsgSrProvEntry=vrPpSrsgSrProvEntry, vrPpSrclNsRowStatusEntry=vrPpSrclNsRowStatusEntry, vrBrPtePortNameIndex=vrBrPtePortNameIndex, vrBrTbSteReceivePortIndex=vrBrTbSteReceivePortIndex, vrPpTbsgRowStatusTable=vrPpTbsgRowStatusTable, vrBrSrbStpPriority=vrBrSrbStpPriority, vrPpTbpBadAbstractDiscards=vrPpTbpBadAbstractDiscards, vrPpFddiETBStpTypeProv=vrPpFddiETBStpTypeProv, pB=pB, vrPpSrtBpPreserveDomain=vrPpSrtBpPreserveDomain, vrPpSrseBridgePortConfig=vrPpSrseBridgePortConfig, vrPpTbsgStaticEntryDiscards=vrPpTbsgStaticEntryDiscards, vrPpTbseOperStatusEntry=vrPpTbseOperStatusEntry, vrBrNsAteDirection=vrBrNsAteDirection, vrBrTbStpIndex=vrBrTbStpIndex, vrPpSrBpServiceClass=vrPpSrBpServiceClass, vrPpSrtBpNsStorageType=vrPpSrtBpNsStorageType, vrPpSrsgTinygramFramesIn=vrPpSrsgTinygramFramesIn, vrPpTbclUsageState=vrPpTbclUsageState, cBIfAdminStatus=cBIfAdminStatus, vrPpSrtBpDesignatedRoot=vrPpSrtBpDesignatedRoot, vrPpSrBpStpProvTable=vrPpSrBpStpProvTable, vrPpFddiETBStpTypeOper=vrPpFddiETBStpTypeOper, vrPpSrsgIfIndex=vrPpSrsgIfIndex, vrPpSrseAdminState=vrPpSrseAdminState, vrPpSrBpNsRowStatusTable=vrPpSrBpNsRowStatusTable, vrPpSrsgStateEntry=vrPpSrsgStateEntry, vrPpTbclSecureOption=vrPpTbclSecureOption, vrPpSrtBpMaxInfo=vrPpSrtBpMaxInfo, vrPpSrtBpPathCostOper=vrPpSrtBpPathCostOper, vrPpSrtBpNsRowStatusTable=vrPpSrtBpNsRowStatusTable, vrPpTbpMtuExceededDiscards=vrPpTbpMtuExceededDiscards, vrPpTbseLearningDiscards=vrPpTbseLearningDiscards, vrPpTbclPortNum=vrPpTbclPortNum, vrPpSrsgDesignatedRoot=vrPpSrsgDesignatedRoot, vrPpTbpOperationalState=vrPpTbpOperationalState, vrPpTbclOperationalState=vrPpTbclOperationalState, vrPpSrtBpLanIdMismatches=vrPpSrtBpLanIdMismatches, cBOperEntry=cBOperEntry, vrPpTbseDownTime=vrPpTbseDownTime, vrPpTbseStpPortState=vrPpTbseStpPortState, vrBrTbNcFteAgeOfEntry=vrBrTbNcFteAgeOfEntry, vrBrNsAteFirstMacAddressMask=vrBrNsAteFirstMacAddressMask, cBOperTable=cBOperTable, vrPpSrclTinygramFramesIn=vrPpSrclTinygramFramesIn, vrPpTbpNsRowStatusEntry=vrPpTbpNsRowStatusEntry, vrPpTbclBadVerifyDiscards=vrPpTbclBadVerifyDiscards, vrPpFddiETBTinygramFramesOut=vrPpFddiETBTinygramFramesOut, vrPpSrtBpPathCost=vrPpSrtBpPathCost, vrPpSrsgAdminState=vrPpSrsgAdminState, vrPpSrclUsageState=vrPpSrclUsageState, vrPpTbsg=vrPpTbsg, vrPpTbclStateTable=vrPpTbclStateTable, vrPpSrseDupLanIdOrTreeErrors=vrPpSrseDupLanIdOrTreeErrors, vrPpTbsgStpPortState=vrPpTbsgStpPortState, vrBrSrbStatsEntry=vrBrSrbStatsEntry, vrPpFddiETBStpOperEntry=vrPpFddiETBStpOperEntry, vrPpSrtBpSrProvTable=vrPpSrtBpSrProvTable, cBOperStatusEntry=cBOperStatusEntry, vrPpSrsePortStateStpControl=vrPpSrsePortStateStpControl, vrPpTbclDesignatedPort=vrPpTbclDesignatedPort, vrPpFddiETBSnmpOperStatus=vrPpFddiETBSnmpOperStatus, vrBrSrbStpMaxAge=vrBrSrbStpMaxAge, vrPpSrseOperEntry=vrPpSrseOperEntry, vrPpTbclNsIncomingFilter=vrPpTbclNsIncomingFilter, vrPpSrsgBridgingMode=vrPpSrsgBridgingMode, vrPpSrseHopCount=vrPpSrseHopCount, cBSnmpAdminStatus=cBSnmpAdminStatus, vrPpTbclAdminState=vrPpTbclAdminState, vrPpTbclNsRowStatusTable=vrPpTbclNsRowStatusTable, vrPpSrclIndex=vrPpSrclIndex, vrBrTbRowStatus=vrBrTbRowStatus, vrPpTbpNsStorageType=vrPpTbpNsStorageType, vrPpSrsgStateTable=vrPpSrsgStateTable, vrBrTbNumFtEntriesDenied=vrBrTbNumFtEntriesDenied, vrBrTbFteRowStatusTable=vrBrTbFteRowStatusTable, vrPpFddiETBPreserveDomain=vrPpFddiETBPreserveDomain, vrPpSrsgDIProvEntry=vrPpSrsgDIProvEntry, vrPpSrBpSrProvTable=vrPpSrBpSrProvTable, vrPpSrsgStaticDiscards=vrPpSrsgStaticDiscards, vrBrTbNcFteDomainNumIndex=vrBrTbNcFteDomainNumIndex, pBRowStatusEntry=pBRowStatusEntry, vrPpSrtBpStatsTable=vrPpSrtBpStatsTable, vrPpSrseSpecOutFrames=vrPpSrseSpecOutFrames, vrPpSrclDIProvTable=vrPpSrclDIProvTable, vrBrRowStatus=vrBrRowStatus, vrPpSrclDelayExceededDiscards=vrPpSrclDelayExceededDiscards, vrPpTbseStpProvEntry=vrPpTbseStpProvEntry, vrPpSrtBpStatsEntry=vrPpSrtBpStatsEntry, vrPpSrsgPathCostOper=vrPpSrsgPathCostOper, vrPpSrseOutFilterDiscards=vrPpSrseOutFilterDiscards, vrPpTbclStpOperEntry=vrPpTbclStpOperEntry, vrPpFddiETBStpOperTable=vrPpFddiETBStpOperTable, vrPpTbsePortPriority=vrPpTbsePortPriority, vrBrTbAgingTime=vrBrTbAgingTime, vrPpSrtBpPortNum=vrPpSrtBpPortNum, vrPpSrseApeOutFrames=vrPpSrseApeOutFrames, vrPpSrBpSrProvEntry=vrPpSrBpSrProvEntry, vrBrComponentName=vrBrComponentName, vrPpSrtBpOperEntry=vrPpSrtBpOperEntry, vrPpSrtBpAreRdLimit=vrPpSrtBpAreRdLimit, vrPpSrseOperTable=vrPpSrseOperTable, vrBrPteDomainNumIndex=vrBrPteDomainNumIndex, vrPpSrBpSnmpOperStatus=vrPpSrBpSnmpOperStatus, vrPpSrsgInFilterDiscards=vrPpSrsgInFilterDiscards, vrPpSrclSrProvEntry=vrPpSrclSrProvEntry, vrPpSrsgOutboundFrameMediaType=vrPpSrsgOutboundFrameMediaType, vrPpSrsgStpOperEntry=vrPpSrsgStpOperEntry, vrBrTbStpStpMode=vrBrTbStpStpMode, vrPpSrclDesignatedBridge=vrPpSrclDesignatedBridge, vrPpTbclNsProvTable=vrPpTbclNsProvTable, vrBrTbFtePort=vrBrTbFtePort, vrPpSrseStpTypeProv=vrPpSrseStpTypeProv, vrPpSrseSrProvTable=vrPpSrseSrProvTable, bridgeCapabilities=bridgeCapabilities, vrPpSrclNsOutgoingFilter=vrPpSrclNsOutgoingFilter, vrBrTbStpStorageType=vrBrTbStpStorageType, vrPpFddiETBDIProvTable=vrPpFddiETBDIProvTable, vrPpTbpBadVerifyDiscards=vrPpTbpBadVerifyDiscards, vrPpTbsgSecureOption=vrPpTbsgSecureOption, vrPpTbsgPathCostMethod=vrPpTbsgPathCostMethod, vrPpTbpNsComponentName=vrPpTbpNsComponentName, vrPpSrtBpSrStatsEntry=vrPpSrtBpSrStatsEntry, vrPpTbseStatsEntry=vrPpTbseStatsEntry, vrPpTbclDelayExceededDiscards=vrPpTbclDelayExceededDiscards, vrPpTbsgDesignatedCost=vrPpTbsgDesignatedCost, vrPpSrclStpPortState=vrPpSrclStpPortState, vrPpSrBpStateEntry=vrPpSrBpStateEntry, vrPpSrclOutFilterDiscards=vrPpSrclOutFilterDiscards, pBAdminControlTable=pBAdminControlTable, vrPpSrtBpSteInFrames=vrPpSrtBpSteInFrames, vrPpSrtBpStaticEntryDiscards=vrPpSrtBpStaticEntryDiscards, vrPpTbseServiceClass=vrPpTbseServiceClass, vrBrTbStorageType=vrBrTbStorageType, vrPpSrsgDesignatedBridge=vrPpSrsgDesignatedBridge, vrPpSrBpDesignatedPort=vrPpSrBpDesignatedPort, vrBrTbSteAtgtEntry=vrBrTbSteAtgtEntry, vrPpFddiETBOperStatusEntry=vrPpFddiETBOperStatusEntry, vrPpSrBpComponentName=vrPpSrBpComponentName, vrPpSrseAreRdLimit=vrPpSrseAreRdLimit, vrPpTbpPathCostMethod=vrPpTbpPathCostMethod, vrBrType=vrBrType, vrPpTbsgLearningDiscards=vrPpTbsgLearningDiscards, vrPpSrtBpBlockingDiscards=vrPpSrtBpBlockingDiscards, vrBrTbTotalForwardingTableEntries=vrBrTbTotalForwardingTableEntries, vrPpTbpBridgingMode=vrPpTbpBridgingMode, vrPpSrtBpSpecOutFrames=vrPpSrtBpSpecOutFrames, vrPpSrsgFragmentIp=vrPpSrsgFragmentIp, vrPpSrclProvEntry=vrPpSrclProvEntry, vrPpSrtBpStateTable=vrPpSrtBpStateTable, vrPpTbsgTbProvEntry=vrPpTbsgTbProvEntry, vrPpSrsgLargestFrame=vrPpSrsgLargestFrame, pBAdminControlEntry=pBAdminControlEntry, vrPpSrtBpStaticDiscards=vrPpSrtBpStaticDiscards, vrBrTbFteOperTable=vrBrTbFteOperTable, vrPpSrclRowStatusEntry=vrPpSrclRowStatusEntry, vrBrSrbStpComponentName=vrBrSrbStpComponentName, vrPpFddiETBPathCostOper=vrPpFddiETBPathCostOper, vrPpSrtBpSecureOption=vrPpSrtBpSecureOption, vrPpSrtBpPortName=vrPpSrtBpPortName, vrPpSrBpPortPriority=vrPpSrBpPortPriority, vrPpTbsgBadVerifyDiscards=vrPpTbsgBadVerifyDiscards, vrPpSrclLanId=vrPpSrclLanId, vrPpTbp=vrPpTbp, vrPpTbsgPathCostOper=vrPpTbsgPathCostOper, vrPpTbseStateTable=vrPpTbseStateTable, pBOperStatusTable=pBOperStatusTable, vrPpTbclPortPriority=vrPpTbclPortPriority, vrPpTbpRowStatus=vrPpTbpRowStatus, vrPpSrseBridgePortType=vrPpSrseBridgePortType, vrPpFddiETBNsProvTable=vrPpFddiETBNsProvTable, vrBrPte=vrBrPte, vrPpTbclOutboundFrameMediaType=vrPpTbclOutboundFrameMediaType, vrPpTbpProvEntry=vrPpTbpProvEntry, vrPpSrsgSrStatsTable=vrPpSrsgSrStatsTable, vrBrSrbStpRootCost=vrBrSrbStpRootCost, vrPpSrBpPathCost=vrPpSrBpPathCost)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-BridgeMIB", vrPpTbsgStpProvEntry=vrPpTbsgStpProvEntry, vrPpSrBpIndex=vrPpSrBpIndex, vrPpTbsgMtuExceededDiscards=vrPpTbsgMtuExceededDiscards, vrPpTbseTbOperTable=vrPpTbseTbOperTable, vrBrTbStp=vrBrTbStp, vrBrTbSte=vrBrTbSte, vrPpFddiETBRowStatusTable=vrPpFddiETBRowStatusTable, vrPpSrBpProvTable=vrPpSrBpProvTable, vrPpTbclRowStatus=vrPpTbclRowStatus, vrPpTbpPortPriority=vrPpTbpPortPriority, vrPpTbclRowStatusTable=vrPpTbclRowStatusTable, vrPpSrBpDelayExceededDiscards=vrPpSrBpDelayExceededDiscards, vrPpSrtBpTbOperEntry=vrPpSrtBpTbOperEntry, vrPpSrclSteInFrames=vrPpSrclSteInFrames, vrBrSrbStpOperEntry=vrBrSrbStpOperEntry, vrPpTbclTranslateIpx=vrPpTbclTranslateIpx, vrPpSrseStatsEntry=vrPpSrseStatsEntry, vrPpTbseOutFilterDiscards=vrPpTbseOutFilterDiscards, vrPpTbseUnicastNoMatches=vrPpTbseUnicastNoMatches, vrPpTbseComponentName=vrPpTbseComponentName, vrBrPteFilterPoints=vrBrPteFilterPoints, vrPpSrseSrProvEntry=vrPpSrseSrProvEntry, vrPpTbsgOutboundFrameMediaType=vrPpTbsgOutboundFrameMediaType, vrPpSrBpBridgeNum=vrPpSrBpBridgeNum, vrPpSrseDesignatedBridge=vrPpSrseDesignatedBridge, vrPpTbpLearningDiscards=vrPpTbpLearningDiscards, vrBrTbNcFteOperEntry=vrBrTbNcFteOperEntry, vrPpFddiETBDesignatedRoot=vrPpFddiETBDesignatedRoot, pBAdminState=pBAdminState, vrBrTbSteAddressIndex=vrBrTbSteAddressIndex, vrPpSrtBpApeOutFrames=vrPpSrtBpApeOutFrames, vrPpSrseProvTable=vrPpSrseProvTable, vrPpTbseTinygramFramesIn=vrPpTbseTinygramFramesIn, vrPpSrsgSteRdLimit=vrPpSrsgSteRdLimit, vrPpSrclSrStatsTable=vrPpSrclSrStatsTable, vrPpTbsgOperTable=vrPpTbsgOperTable, vrPpTbsgAdminState=vrPpTbsgAdminState, vrBrSrbLteComponentName=vrBrSrbLteComponentName, vrPpSrsgDupLanIdOrTreeErrors=vrPpSrsgDupLanIdOrTreeErrors, vrPpSrBpDupLanIdOrTreeErrors=vrPpSrBpDupLanIdOrTreeErrors, vrPpTbseForwardTransitions=vrPpTbseForwardTransitions, vrPpSrtBpRowStatus=vrPpSrtBpRowStatus, vrPpSrclComponentName=vrPpSrclComponentName, vrPpSrclNsStorageType=vrPpSrclNsStorageType, vrPpSrBpOperationalState=vrPpSrBpOperationalState, vrPpSrclMtuExceededDiscards=vrPpSrclMtuExceededDiscards, vrBrTbStpRootPortName=vrBrTbStpRootPortName, vrPpSrBpOperTable=vrPpSrBpOperTable, vrPpSrtBpStateEntry=vrPpSrtBpStateEntry, vrPpSrseUpTime=vrPpSrseUpTime, vrPpTbpStaticEntryDiscards=vrPpTbpStaticEntryDiscards, vrPpSrclNsIndex=vrPpSrclNsIndex, vrBrTbStpProvEntry=vrBrTbStpProvEntry, vrBrOperTable=vrBrOperTable, vrPpTbpStateTable=vrPpTbpStateTable, vrPpTbclBlockingDiscards=vrPpTbclBlockingDiscards, vrPpSrBpNsOutgoingFilter=vrPpSrBpNsOutgoingFilter, vrBrSrbStpIndex=vrBrSrbStpIndex, vrPpSrtBpStpProvEntry=vrPpSrtBpStpProvEntry, vrPpSrBpDIProvEntry=vrPpSrBpDIProvEntry, vrPpTbseDesignatedRoot=vrPpTbseDesignatedRoot, vrPpSrtBpPortStateStpControl=vrPpSrtBpPortStateStpControl, vrPpSrBpStpOperTable=vrPpSrBpStpOperTable, bridgeCapabilitiesBE01=bridgeCapabilitiesBE01, vrPpTbpStpOperEntry=vrPpTbpStpOperEntry, vrPpSrseSegmentMismatchDiscards=vrPpSrseSegmentMismatchDiscards, vrPpSrtBpLargestFrame=vrPpSrtBpLargestFrame, vrPpSrseLanIdMismatches=vrPpSrseLanIdMismatches, vrPpSrBpDesignatedBridge=vrPpSrBpDesignatedBridge, bridgeGroup=bridgeGroup, cBAdminControlTable=cBAdminControlTable, cBStorageType=cBStorageType, vrPpSrclBadAbstractDiscards=vrPpSrclBadAbstractDiscards, vrPpFddiETBPathCostMethod=vrPpFddiETBPathCostMethod, vrPpSrtBpHopCount=vrPpSrtBpHopCount, vrPpSrsg=vrPpSrsg, cBAdminControlEntry=cBAdminControlEntry, vrPpFddiETBDIProvEntry=vrPpFddiETBDIProvEntry, vrBrPteMacType=vrBrPteMacType, vrPpSrclPreserveDomain=vrPpSrclPreserveDomain, vrPpTbsgRowStatusEntry=vrPpTbsgRowStatusEntry, vrBrSrbStpRowStatusTable=vrBrSrbStpRowStatusTable, vrPpTbclStatsEntry=vrPpTbclStatsEntry, vrPpSrsgPortStateStpControl=vrPpSrsgPortStateStpControl, vrBrTbNcFteRowStatusEntry=vrBrTbNcFteRowStatusEntry, vrPpSrtBpTbOperTable=vrPpSrtBpTbOperTable, vrPpTbseOutboundFrameMediaType=vrPpTbseOutboundFrameMediaType, vrPpTbclForwardTransitions=vrPpTbclForwardTransitions, vrPpSrseStpOperTable=vrPpSrseStpOperTable, vrPpTbsgOperEntry=vrPpTbsgOperEntry, vrPpFddiETBProvEntry=vrPpFddiETBProvEntry, vrBrTbFtePeerAddressInfo=vrBrTbFtePeerAddressInfo, vrBrSrbStpHelloTime=vrBrSrbStpHelloTime, vrPpSrtBpPathCostMethod=vrPpSrtBpPathCostMethod, vrPpTbpTinygramFramesOut=vrPpTbpTinygramFramesOut, vrPpFddiETBStpProvEntry=vrPpFddiETBStpProvEntry, vrPpTbseStatsTable=vrPpTbseStatsTable, vrPpSrclOutboundFrameMediaType=vrPpSrclOutboundFrameMediaType, vrBrAdminControlTable=vrBrAdminControlTable, vrPpSrseApeInFrames=vrPpSrseApeInFrames, vrBrUsageState=vrBrUsageState, vrPpTbclProvEntry=vrPpTbclProvEntry, vrBrTbProvEntry=vrBrTbProvEntry, vrPpTbclProvTable=vrPpTbclProvTable, vrPpSrclIfIndex=vrPpSrclIfIndex, pBUsageState=pBUsageState, vrPpTbclPreserveDomain=vrPpTbclPreserveDomain, vrPpTbclNsOutgoingFilter=vrPpTbclNsOutgoingFilter, vrPpSrsgOperEntry=vrPpSrsgOperEntry, vrPpFddiETBConvertArpMacAddress=vrPpFddiETBConvertArpMacAddress, vrPpTbsgDelayExceededDiscards=vrPpTbsgDelayExceededDiscards, vrBrNsAteDomainNum=vrBrNsAteDomainNum, vrPpSrtBpSegmentMismatchDiscards=vrPpSrtBpSegmentMismatchDiscards, vrPpSrseDownTime=vrPpSrseDownTime, vrPpSrclAreRdLimit=vrPpSrclAreRdLimit, vrPpSrclBridgeNum=vrPpSrclBridgeNum, vrBrIndex=vrBrIndex, vrBrPteStorageType=vrBrPteStorageType, vrPpSrsgSteInFrames=vrPpSrsgSteInFrames, vrBrNsProvTable=vrBrNsProvTable, cBSnmpOperStatus=cBSnmpOperStatus, vrPpTbsgUpTime=vrPpTbsgUpTime, vrPpFddiETBTbOperTable=vrPpFddiETBTbOperTable, vrPpTbclNs=vrPpTbclNs, cBIndex=cBIndex, vrPpSrBpRowStatusEntry=vrPpSrBpRowStatusEntry, vrPpSrBpNsRowStatus=vrPpSrBpNsRowStatus, vrPpSrtBpPortPriority=vrPpSrtBpPortPriority, vrPpTbsgDIProvEntry=vrPpTbsgDIProvEntry, vrPpSrseOperStatusTable=vrPpSrseOperStatusTable, vrPpSrBpPortName=vrPpSrBpPortName, vrPpFddiETBStateEntry=vrPpFddiETBStateEntry, vrPpFddiETBBadAbstractDiscards=vrPpFddiETBBadAbstractDiscards, vrPpTbpNsProvEntry=vrPpTbpNsProvEntry, vrPpFddiETBPortNum=vrPpFddiETBPortNum, vrPpTbclTbOperTable=vrPpTbclTbOperTable, vrPpTbseOperTable=vrPpTbseOperTable, vrPpTbclConvertArpMacAddress=vrPpTbclConvertArpMacAddress, vrBrTbStpBridgeForwardDelay=vrBrTbStpBridgeForwardDelay, vrPpSrtBpLearningDiscards=vrPpSrtBpLearningDiscards, vrBrSrbIndex=vrBrSrbIndex, vrPpSrsgStpProvTable=vrPpSrsgStpProvTable, vrPpSrclBridgePortConfig=vrPpSrclBridgePortConfig, vrPpTbsePreserveDomain=vrPpTbsePreserveDomain, vrPpSrsgRowStatus=vrPpSrsgRowStatus, vrPpTbclIfIndex=vrPpTbclIfIndex, vrBrTbStpBridgeMaxAge=vrBrTbStpBridgeMaxAge, vrPpSrtBpNsIndex=vrPpSrtBpNsIndex, vrPpSrsgComponentName=vrPpSrsgComponentName, vrPpSrtBpNsRowStatusEntry=vrPpSrtBpNsRowStatusEntry, vrPpSrtBpRowStatusEntry=vrPpSrtBpRowStatusEntry, vrPpTbseRowStatusEntry=vrPpTbseRowStatusEntry, vrPpTbclServiceClass=vrPpTbclServiceClass, vrPpTbpDynamicEntryDiscards=vrPpTbpDynamicEntryDiscards, vrPpTbpInFilterDiscards=vrPpTbpInFilterDiscards, vrPpSrclOperationalState=vrPpSrclOperationalState, vrPpSrtBpDesignatedCost=vrPpSrtBpDesignatedCost, vrPpTbseSecureOption=vrPpTbseSecureOption, vrPpSrBpStpTypeOper=vrPpSrBpStpTypeOper, vrPpTbseRowStatus=vrPpTbseRowStatus, vrPpSrBpConvertArpMacAddress=vrPpSrBpConvertArpMacAddress, vrPpTbsgStpOperTable=vrPpTbsgStpOperTable, vrPpSrtBpDelayExceededDiscards=vrPpSrtBpDelayExceededDiscards, vrBrSrbStpBridgeForwardDelay=vrBrSrbStpBridgeForwardDelay, vrPpSrsgProvTable=vrPpSrsgProvTable, vrPpTbclStpOperTable=vrPpTbclStpOperTable, vrPpSrclStpProvTable=vrPpSrclStpProvTable, vrPpSrsgDesignatedCost=vrPpSrsgDesignatedCost, vrPpTbpPathCost=vrPpTbpPathCost, vrPpSrseOperStatusEntry=vrPpSrseOperStatusEntry, vrPpSrseOutboundFrameMediaType=vrPpSrseOutboundFrameMediaType, vrPpSrBpNsProvTable=vrPpSrBpNsProvTable, vrPpFddiETB=vrPpFddiETB, vrPpTbpConvertArpMacAddress=vrPpTbpConvertArpMacAddress, vrPpSrsePortName=vrPpSrsePortName, vrPpSrtBpServiceClass=vrPpSrtBpServiceClass, vrPpSrsgBadAbstractDiscards=vrPpSrsgBadAbstractDiscards, vrBrSrbStpTimeSinceTopologyChange=vrBrSrbStpTimeSinceTopologyChange, vrPpTbclBridgePortType=vrPpTbclBridgePortType, vrPpTbsgConvertArpMacAddress=vrPpTbsgConvertArpMacAddress, vrPpTbclDownTime=vrPpTbclDownTime, vrPpTbpAdminState=vrPpTbpAdminState, vrBrTbStpHoldTime=vrBrTbStpHoldTime, vrPpSrtBpDIProvTable=vrPpSrtBpDIProvTable, vrPpSrBpStaticDiscards=vrPpSrBpStaticDiscards, vrPpFddiETBNs=vrPpFddiETBNs, vrPpSrtBpDomainNum=vrPpSrtBpDomainNum, vrPpTbsgPortName=vrPpTbsgPortName, pBStateTable=pBStateTable, vrPpTbpOperEntry=vrPpTbpOperEntry, vrPpSrBpInFilterDiscards=vrPpSrBpInFilterDiscards, vrBrTbNcFteRowStatus=vrBrTbNcFteRowStatus, vrBrSrbStpStpMode=vrBrSrbStpStpMode, cBIfEntryEntry=cBIfEntryEntry, vrPpSrseHopCountExceededDiscards=vrPpSrseHopCountExceededDiscards, vrPpSrtBpDynamicDiscards=vrPpSrtBpDynamicDiscards, vrPpTbseStpOperEntry=vrPpTbseStpOperEntry, vrPpTbpComponentName=vrPpTbpComponentName, vrPpSrclNsProvTable=vrPpSrclNsProvTable, vrPpFddiETBRowStatus=vrPpFddiETBRowStatus, vrPpSrtBpComponentName=vrPpSrtBpComponentName, vrPpSrseSteInFrames=vrPpSrseSteInFrames, vrPpSrseServiceClass=vrPpSrseServiceClass, vrPpSrclLanIdMismatches=vrPpSrclLanIdMismatches, vrPpSrBpSteOutFrames=vrPpSrBpSteOutFrames, vrBrTbStpFwdDelay=vrBrTbStpFwdDelay, vrPpTbseTbOperEntry=vrPpTbseTbOperEntry, vrBrTbNcFte=vrBrTbNcFte, vrPpSrsgUpTime=vrPpSrsgUpTime, vrPpSrclStateEntry=vrPpSrclStateEntry, vrPpSrclStateTable=vrPpSrclStateTable, vrPpTbclStateEntry=vrPpTbclStateEntry, vrPpSrBpDownTime=vrPpSrBpDownTime, vrPpTbclAdminStatus=vrPpTbclAdminStatus, vrPpSrtBpUsageState=vrPpSrtBpUsageState, vrPpSrtBpNsIncomingFilter=vrPpSrtBpNsIncomingFilter, vrPpSrseStpOperEntry=vrPpSrseStpOperEntry, vrPpSrseStaticDiscards=vrPpSrseStaticDiscards, vrPpSrtBpBadAbstractDiscards=vrPpSrtBpBadAbstractDiscards, vrPpTbsgStateTable=vrPpTbsgStateTable, vrPpSrtBpRowStatusTable=vrPpSrtBpRowStatusTable, vrPpSrseTinygramFramesOut=vrPpSrseTinygramFramesOut, vrPpTbseTbProvTable=vrPpTbseTbProvTable, vrPpTbseRowStatusTable=vrPpTbseRowStatusTable, vrPpTbpStpProvEntry=vrPpTbpStpProvEntry, vrPpTbsgDIProvTable=vrPpTbsgDIProvTable, vrPpTbsgServiceClass=vrPpTbsgServiceClass, vrPpSrseConvertArpMacAddress=vrPpSrseConvertArpMacAddress, vrPpSrBpRowStatusTable=vrPpSrBpRowStatusTable, vrBrNsAteSecondMacAddress=vrBrNsAteSecondMacAddress, vrPpTbclDIProvEntry=vrPpTbclDIProvEntry, cBMpEntry=cBMpEntry, vrPpSrtBpStorageType=vrPpSrtBpStorageType, vrPpSrtBpMtuExceededDiscards=vrPpSrtBpMtuExceededDiscards, vrPpSrBpAdminState=vrPpSrBpAdminState, vrPpSrBpOperStatusEntry=vrPpSrBpOperStatusEntry, vrPpSrtBpSteRdLimit=vrPpSrtBpSteRdLimit, vrPpSrtBpSpecInFrames=vrPpSrtBpSpecInFrames, vrBrStateTable=vrBrStateTable, vrPpSrclUpTime=vrPpSrclUpTime, vrPpTbpStpPortState=vrPpTbpStpPortState, vrPpSrBpDesignatedCost=vrPpSrBpDesignatedCost, vrPpSrseStateTable=vrPpSrseStateTable, vrPpFddiETBDesignatedPort=vrPpFddiETBDesignatedPort, vrPpTbseOutFrames=vrPpTbseOutFrames, vrBrSrbBridgeLfMode=vrBrSrbBridgeLfMode, vrPpSrtBpNsProvTable=vrPpSrtBpNsProvTable, vrBrPtePortPointsTo=vrBrPtePortPointsTo, vrBrTbStpRowStatusTable=vrBrTbStpRowStatusTable, vrPpTbclStpTypeOper=vrPpTbclStpTypeOper, vrPpTbsgOperationalState=vrPpTbsgOperationalState, vrPpTbsgDesignatedPort=vrPpTbsgDesignatedPort, vrPpTbpStatsEntry=vrPpTbpStatsEntry, vrPpSrseRowStatus=vrPpSrseRowStatus)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-BridgeMIB", vrBrTb=vrBrTb, vrPpSrBpBridgePortConfig=vrPpSrBpBridgePortConfig, vrPpSrtBpStpPortState=vrPpSrtBpStpPortState, vrPpSrtBpNsOutgoingFilter=vrPpSrtBpNsOutgoingFilter, vrPpTbpDIProvEntry=vrPpTbpDIProvEntry, vrPpTbpStpTypeOper=vrPpTbpStpTypeOper, vrPpTbsgForwardTransitions=vrPpTbsgForwardTransitions, vrPpSrclHopCount=vrPpSrclHopCount, vrBrNsAteStorageType=vrBrNsAteStorageType, vrPpSrsgHopCountExceededDiscards=vrPpSrsgHopCountExceededDiscards, vrPpFddiETBNsIncomingFilter=vrPpFddiETBNsIncomingFilter, vrPpTbseSnmpOperStatus=vrPpTbseSnmpOperStatus, vrPpTbpDownTime=vrPpTbpDownTime, vrPpSrsgStpTypeOper=vrPpSrsgStpTypeOper, vrBrPteOperTable=vrBrPteOperTable, vrBrTbNcFteStatus=vrBrTbNcFteStatus, vrBrSrbLte=vrBrSrbLte, vrPpTbclBridgingMode=vrPpTbclBridgingMode, vrPpSrtBpSrStatsTable=vrPpSrtBpSrStatsTable, vrPpTbseDelayExceededDiscards=vrPpTbseDelayExceededDiscards, vrPpSrtBpBridgePortType=vrPpSrtBpBridgePortType, vrPpSrBpBridgingMode=vrPpSrBpBridgingMode, vrPpSrclDesignatedCost=vrPpSrclDesignatedCost, vrPpSrBpStorageType=vrPpSrBpStorageType, vrPpSrsgMtuExceededDiscards=vrPpSrsgMtuExceededDiscards, vrPpSrsgSegmentMismatchDiscards=vrPpSrsgSegmentMismatchDiscards, vrPpSrsgSrStatsEntry=vrPpSrsgSrStatsEntry, vrPpSrsgAdminStatus=vrPpSrsgAdminStatus, vrPpTbsgStpProvTable=vrPpTbsgStpProvTable, pBSnmpOperStatus=pBSnmpOperStatus, vrPpSrsgOutFilterDiscards=vrPpSrsgOutFilterDiscards, vrBrTbFteAddressIndex=vrBrTbFteAddressIndex, vrPpSrBpOutboundFrameMediaType=vrPpSrBpOutboundFrameMediaType, vrPpSrseStpTypeOper=vrPpSrseStpTypeOper, vrPpSrsgServiceClass=vrPpSrsgServiceClass, vrPpTbsgMaxInfo=vrPpTbsgMaxInfo, vrPpFddiETBMtuExceededDiscards=vrPpFddiETBMtuExceededDiscards, vrPpSrsgIndex=vrPpSrsgIndex, vrPpTbsgPathCost=vrPpTbsgPathCost, vrPpSrclSpecInFrames=vrPpSrclSpecInFrames, vrBrSrbProvTable=vrBrSrbProvTable, vrPpSrsgAreRdLimit=vrPpSrsgAreRdLimit, vrPpSrclDomainNum=vrPpSrclDomainNum, vrPpSrclNsProvEntry=vrPpSrclNsProvEntry, vrPpSrBpSteInFrames=vrPpSrBpSteInFrames, vrBrSrbLtePeerMACAddress=vrBrSrbLtePeerMACAddress, vrBrAdminControlEntry=vrBrAdminControlEntry, vrPpSrBpUsageState=vrPpSrBpUsageState, vrPpTbclOperStatusTable=vrPpTbclOperStatusTable, vrBrTbSteComponentName=vrBrTbSteComponentName, vrPpFddiETBBridgingMode=vrPpFddiETBBridgingMode, vrPpSrclSteSpanMode=vrPpSrclSteSpanMode, vrPpFddiETBNsProvEntry=vrPpFddiETBNsProvEntry, vrPpTbseDIProvEntry=vrPpTbseDIProvEntry, vrBrNsAteEntryNumberIndex=vrBrNsAteEntryNumberIndex, vrPpFddiETBNsComponentName=vrPpFddiETBNsComponentName, vrPpTbpStpTypeProv=vrPpTbpStpTypeProv, vrPpSrclOperEntry=vrPpSrclOperEntry, vrBrTbNcFtePort=vrBrTbNcFtePort, vrPpTbseIfIndex=vrPpTbseIfIndex, vrPpFddiETBDesignatedCost=vrPpFddiETBDesignatedCost, pBOperStatusEntry=pBOperStatusEntry, vrPpSrclApeInFrames=vrPpSrclApeInFrames, vrBrTbSteStatus=vrBrTbSteStatus, vrPpSrtBpLanId=vrPpSrtBpLanId, vrPpSrsgStatsEntry=vrPpSrsgStatsEntry, vrPpTbse=vrPpTbse, vrBrSrbStpRowStatusEntry=vrBrSrbStpRowStatusEntry, vrPpTbcl=vrPpTbcl, vrPpSrBpPortStateStpControl=vrPpSrBpPortStateStpControl, vrPpSrtBpFragmentIp=vrPpSrtBpFragmentIp, vrPpSrclNsIncomingFilter=vrPpSrclNsIncomingFilter, vrPpSrBpAreRdLimit=vrPpSrBpAreRdLimit, vrPpTbclStorageType=vrPpTbclStorageType, vrBrTbSteRowStatusTable=vrBrTbSteRowStatusTable, vrPpSrBpPathCostOper=vrPpSrBpPathCostOper, vrBrTbStpBridgeId=vrBrTbStpBridgeId, vrPpSrtBpStpProvTable=vrPpSrtBpStpProvTable, vrPpSrclPortPriority=vrPpSrclPortPriority, vrPpSrBpPathCostMethod=vrPpSrBpPathCostMethod, vrPpSrtBpHopCountExceededDiscards=vrPpSrtBpHopCountExceededDiscards, pBSnmpAdminStatus=pBSnmpAdminStatus, cBStateTable=cBStateTable, vrPpSrclPortName=vrPpSrclPortName, vrBrSrbStpProvEntry=vrBrSrbStpProvEntry, vrPpFddiETBFragmentIp=vrPpFddiETBFragmentIp, vrPpFddiETBNsIndex=vrPpFddiETBNsIndex, vrPpSrtBpDupLanIdOrTreeErrors=vrPpSrtBpDupLanIdOrTreeErrors, vrPpTbsgAdminStatus=vrPpTbsgAdminStatus, vrPpSrclTranslateIpx=vrPpSrclTranslateIpx, vrPpFddiETBNsStorageType=vrPpFddiETBNsStorageType, vrPpSrBpStateTable=vrPpSrBpStateTable, vrPpSrseLargestFrame=vrPpSrseLargestFrame, vrPpSrclDupLanIdOrTreeErrors=vrPpSrclDupLanIdOrTreeErrors, vrPpTbsePathCostMethod=vrPpTbsePathCostMethod, vrPpTbsgStatsEntry=vrPpTbsgStatsEntry, vrPpSrtBpOutboundFrameMediaType=vrPpSrtBpOutboundFrameMediaType, vrPpTbclBridgePortConfig=vrPpTbclBridgePortConfig, vrPpSrclOperStatusTable=vrPpSrclOperStatusTable, vrPpSrsgHopCount=vrPpSrsgHopCount, vrPpTbpNsRowStatus=vrPpTbpNsRowStatus, vrBrTbStpAgingTimeOper=vrBrTbStpAgingTimeOper, vrBrTbNcFteRowStatusTable=vrBrTbNcFteRowStatusTable, vrPpTbpStatsTable=vrPpTbpStatsTable, vrPpTbclOutFrames=vrPpTbclOutFrames, vrPpSrtBpInFrames=vrPpSrtBpInFrames, vrPpSrseSrStatsEntry=vrPpSrseSrStatsEntry, vrPpTbsgBridgingMode=vrPpTbsgBridgingMode, vrBrSrbStpRootPortName=vrBrSrbStpRootPortName, bridgeMIB=bridgeMIB, vrPpSrBpUpTime=vrPpSrBpUpTime, vrBrNsAteRowStatusEntry=vrBrNsAteRowStatusEntry, vrPpTbsgInDiscards=vrPpTbsgInDiscards, vrPpTbclUpTime=vrPpTbclUpTime, vrPpSrtBpNs=vrPpSrtBpNs, vrBrNsRowStatusEntry=vrBrNsRowStatusEntry, vrPpFddiETBBlockingDiscards=vrPpFddiETBBlockingDiscards, vrPpTbsgOperStatusTable=vrPpTbsgOperStatusTable, vrPpSrclForwardTransitions=vrPpSrclForwardTransitions, vrPpSrBpHopCountExceededDiscards=vrPpSrBpHopCountExceededDiscards, vrPpSrtBpExploreFrameTreatment=vrPpSrtBpExploreFrameTreatment, vrPpTbpNsProvTable=vrPpTbpNsProvTable, vrPpSrclNsRowStatus=vrPpSrclNsRowStatus, vrBrOperationalState=vrBrOperationalState, vrPpTbseDesignatedPort=vrPpTbseDesignatedPort, vrPpTbseAdminState=vrPpTbseAdminState, vrBrSrbProvEntry=vrBrSrbProvEntry, vrPpSrtBpDesignatedBridge=vrPpSrtBpDesignatedBridge, vrPpFddiETBProvTable=vrPpFddiETBProvTable, vrPpTbsgOutFrames=vrPpTbsgOutFrames, vrPpSrseSteSpanMode=vrPpSrseSteSpanMode, vrPpFddiETBDesignatedBridge=vrPpFddiETBDesignatedBridge, vrPpTbseOperEntry=vrPpTbseOperEntry, vrPpTbsgTbProvTable=vrPpTbsgTbProvTable, vrPpTbpDelayExceededDiscards=vrPpTbpDelayExceededDiscards, vrPpSrseBlockingDiscards=vrPpSrseBlockingDiscards, vrPpSrtBpNsProvEntry=vrPpSrtBpNsProvEntry, vrPpTbsgProvTable=vrPpTbsgProvTable, vrPpSrBpTranslateIpx=vrPpSrBpTranslateIpx, vrBrPteRowStatus=vrBrPteRowStatus, vrPpSrseRowStatusEntry=vrPpSrseRowStatusEntry, vrBrNsAteFirstMacAddress=vrBrNsAteFirstMacAddress, cBAdminState=cBAdminState, vrPpFddiETBTbProvEntry=vrPpFddiETBTbProvEntry, vrPpSrsgPathCostMethod=vrPpSrsgPathCostMethod, vrPpSrtBpBridgePortConfig=vrPpSrtBpBridgePortConfig, vrPpFddiETBNsRowStatusTable=vrPpFddiETBNsRowStatusTable, cB=cB, vrPpSrclNsComponentName=vrPpSrclNsComponentName, vrPpSrclSpecOutFrames=vrPpSrclSpecOutFrames, vrPpTbsgBlockingDiscards=vrPpTbsgBlockingDiscards, vrPpFddiETBPortPriority=vrPpFddiETBPortPriority, vrPpSrsgLanId=vrPpSrsgLanId, vrPpTbsgPreserveDomain=vrPpTbsgPreserveDomain, vrPpTbclNsRowStatusEntry=vrPpTbclNsRowStatusEntry, vrPpFddiETBTinygramFramesIn=vrPpFddiETBTinygramFramesIn, vrPpSrclInternalLanId=vrPpSrclInternalLanId, vrPpSrBpTinygramFramesOut=vrPpSrBpTinygramFramesOut, vrPpSrsgStatsTable=vrPpSrsgStatsTable, vrBrNsIndex=vrBrNsIndex, vrPpTbpSecureOption=vrPpTbpSecureOption, vrPpFddiETBForwardTransitions=vrPpFddiETBForwardTransitions, vrPpTbpInDiscards=vrPpTbpInDiscards, vrPpSrseDesignatedPort=vrPpSrseDesignatedPort, vrPpSrBpHopCount=vrPpSrBpHopCount, vrBrPteRowStatusTable=vrBrPteRowStatusTable, vrPpTbsgOutFilterDiscards=vrPpTbsgOutFilterDiscards, vrPpTbpDesignatedCost=vrPpTbpDesignatedCost, vrBrPteRowStatusEntry=vrBrPteRowStatusEntry, vrBrSrbStpBridgeMaxAge=vrBrSrbStpBridgeMaxAge, vrBrNsComponentName=vrBrNsComponentName, vrPpTbpDesignatedRoot=vrPpTbpDesignatedRoot, vrPpTbpRowStatusTable=vrPpTbpRowStatusTable, vrPpTbclLearningDiscards=vrPpTbclLearningDiscards, vrPpSrtBpProvEntry=vrPpSrtBpProvEntry, vrPpSrBpFragmentIp=vrPpSrBpFragmentIp, vrPpSrBpNsProvEntry=vrPpSrBpNsProvEntry, vrPpSrtBpTbProvTable=vrPpSrtBpTbProvTable, vrPpSrtBpTranslateIpx=vrPpSrtBpTranslateIpx, vrPpSrseIfIndex=vrPpSrseIfIndex, vrPpSrBpStpOperEntry=vrPpSrBpStpOperEntry, vrPpSrBpSrStatsTable=vrPpSrBpSrStatsTable, vrPpSrclDynamicDiscards=vrPpSrclDynamicDiscards, vrPpSrsePathCostOper=vrPpSrsePathCostOper, vrPpSrBpAdminStatus=vrPpSrBpAdminStatus, vrBrSrbTotalLanIdTableEntries=vrBrSrbTotalLanIdTableEntries, vrPpSrclExploreFrameTreatment=vrPpSrclExploreFrameTreatment, vrPpSrsePathCost=vrPpSrsePathCost, vrPpSrtBpDownTime=vrPpSrtBpDownTime)

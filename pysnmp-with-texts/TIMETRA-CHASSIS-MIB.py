#
# PySNMP MIB module TIMETRA-CHASSIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TIMETRA-CHASSIS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:16:54 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Integer32, Unsigned32, Counter64, TimeTicks, ObjectIdentity, MibIdentifier, ModuleIdentity, IpAddress, NotificationType, Bits, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Unsigned32", "Counter64", "TimeTicks", "ObjectIdentity", "MibIdentifier", "ModuleIdentity", "IpAddress", "NotificationType", "Bits", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Counter32")
DisplayString, DateAndTime, TruthValue, RowPointer, TextualConvention, RowStatus, MacAddress, TimeStamp, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "DateAndTime", "TruthValue", "RowPointer", "TextualConvention", "RowStatus", "MacAddress", "TimeStamp", "TimeInterval")
tmnxSRConfs, timetraSRMIBModules, tmnxSRObjs, tmnxSRNotifyPrefix = mibBuilder.importSymbols("TIMETRA-GLOBAL-MIB", "tmnxSRConfs", "timetraSRMIBModules", "tmnxSRObjs", "tmnxSRNotifyPrefix")
TmnxEnabledDisabled, THsmdaWeightOverride, TmnxIngPolicerStatMode, TmnxIngPolicerStatModeOverride, THPolCIRRateOverride, TmnxAdminState, TmnxOperState, TmnxIpSecIsaOperFlags, THPolPIRRateOverride, TPlcrBurstSizeBytesOverride, TmnxActionType, TItemDescription, THsmdaPIRMRateOverride, TPerPacketOffsetOvr, TmnxPortID, TNamedItem, TIngPolicerId, TNamedItemOrEmpty = mibBuilder.importSymbols("TIMETRA-TC-MIB", "TmnxEnabledDisabled", "THsmdaWeightOverride", "TmnxIngPolicerStatMode", "TmnxIngPolicerStatModeOverride", "THPolCIRRateOverride", "TmnxAdminState", "TmnxOperState", "TmnxIpSecIsaOperFlags", "THPolPIRRateOverride", "TPlcrBurstSizeBytesOverride", "TmnxActionType", "TItemDescription", "THsmdaPIRMRateOverride", "TPerPacketOffsetOvr", "TmnxPortID", "TNamedItem", "TIngPolicerId", "TNamedItemOrEmpty")
tmnxChassisMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 2))
tmnxChassisMIBModule.setRevisions(('1911-02-01 00:00', '1909-02-28 00:00', '1908-07-01 00:00', '1908-01-01 00:00', '1907-01-01 00:00', '1906-03-16 00:00', '1905-08-31 00:00', '1905-01-24 00:00', '1904-01-15 00:00', '1903-08-15 00:00', '1903-01-20 00:00', '1900-08-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: tmnxChassisMIBModule.setRevisionsDescriptions(('Rev 9.0 01 Feb 2011 00:00 9.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 7.0 28 Feb 2009 00:00 7.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 6.1 01 Jul 2008 00:00 6.1 release of the TIMETRA-CHASSIS-MIB.', 'Rev 6.0 01 Jan 2008 00:00 6.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 5.0 01 Jan 2007 00:00 5.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 4.0 16 Mar 2006 00:00 4.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 3.0 31 Aug 2005 00:00 3.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 2.1 24 Jan 2005 00:00 2.1 release of the TIMETRA-CHASSIS-MIB.', 'Rev 2.0 15 Jan 2004 00:00 2.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 1.2 15 Aug 2003 00:00 1.2 release of the TIMETRA-CHASSIS-MIB.', 'Rev 1.0 20 Jan 2003 00:00 Release 1.0 of the TIMETRA-HW-MIB.', 'Rev 0.1 14 Aug 2000 00:00 Initial version of the TIMETRA-HW-MIB.',))
if mibBuilder.loadTexts: tmnxChassisMIBModule.setLastUpdated('201102010000Z')
if mibBuilder.loadTexts: tmnxChassisMIBModule.setOrganization('Alcatel-Lucent')
if mibBuilder.loadTexts: tmnxChassisMIBModule.setContactInfo('Alcatel-Lucent SROS Support Web: http://support.alcatel-lucent.com ')
if mibBuilder.loadTexts: tmnxChassisMIBModule.setDescription("This document is the SNMP MIB module to manage and provision the hardware components of the Alcatel-Lucent 7x50 device. Copyright 2003-2014 Alcatel-Lucent. All rights reserved. Reproduction of this document is authorized on the condition that the foregoing copyright notice is included. This SNMP MIB module (Specification) embodies Alcatel-Lucent's proprietary intellectual property. Alcatel-Lucent retains all title and ownership in the Specification, including any revisions. Alcatel-Lucent grants all interested parties a non-exclusive license to use and distribute an unmodified copy of this Specification in connection with management of Alcatel-Lucent products, and without fee, provided this copyright notice and license appear on all copies. This Specification is supplied 'as is', and Alcatel-Lucent makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification.")
tmnxHwObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2))
tmnxChassisObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1))
tmnxSlotObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 2))
tmnxCardObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3))
tmnxChassisNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6))
tmnxChassisAdminObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8))
tmnxHwNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2))
tmnxChassisNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1))
tmnxChassisNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0))
tmnxHwConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2))
tmnxChassisConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1))
class TmnxAlarmState(TextualConvention, Integer32):
    description = 'The TmnxAlarmState is an enumerated integer whose value indicates the current alarm state of a physical or logical component in the Alcatel-Lucent SROS series system.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unknown", 0), ("alarmActive", 1), ("alarmCleared", 2))

class TmnxChassisIndex(TextualConvention, Integer32):
    description = 'The TmnxChassisIndex is a unique index that identifies a chassis within an Alcatel-Lucent SROS system. Note that initial releases will support only one chassis in a system.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 32)

class TmnxChassisIndexOrZero(TextualConvention, Integer32):
    description = 'The TmnxChassisIndexOrZero can be either a nonzero TmnxChassisIndex, or the value zero.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 32)

class TmnxHwIndex(TextualConvention, Integer32):
    description = 'The TmnxHwIndex is a unique integer index that identifies an Alcatel-Lucent SROS series manufactured hardware component, such as an IOM, CPM, Fabric or MDA card.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class TmnxHwIndexOrZero(TextualConvention, Integer32):
    description = 'The TmnxHwIndexOrZero is a unique integer index that identifies an Alcatel-Lucent SROS series manufactured hardware component, such as an IOM, CPM, Fabric or MDA card. Also TmnxHwIndexOrZero can be zero.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class TmnxHwClass(TextualConvention, Integer32):
    description = 'TmnxHwClass is an enumerated integer that identifies the general hardware type of a component in the tmnxHwTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 30))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("chassis", 3), ("container", 4), ("powerSupply", 5), ("fan", 6), ("sensor", 7), ("ioModule", 8), ("cpmModule", 9), ("fabricModule", 10), ("mdaModule", 11), ("flashDiskModule", 12), ("port", 13), ("mcm", 14), ("ccm", 15), ("alarmInputModule", 16), ("vwmShelfModule", 30))

class TmnxCardType(TextualConvention, Unsigned32):
    description = 'The TmnxCardType data type is an integer that specifies an Alcatel-Lucent SROS series card type. A TmnxCardType value is valid when there is a corresponding row in the tmnxCardTypeTable.'
    status = 'current'

class TmnxCardSuppType(TextualConvention, Bits):
    description = 'The TmnxCardSuppType is a bit-mask specifying the valid card types supported for a specific card slot. When multiple bits are set, it can be used to identify a set or list of card types used in the tmnxCardTable and tmnxCpmCardTable to indicate supported cards within a specific chassis slot. Some example card types might be: sfm-400g -- 400g CPM/SF module sfm-200g -- 200g CPM/SF module iom-20g -- 2 x 10-Gig MDA IOM Card'
    status = 'current'
    namedValues = NamedValues(("invalid-card-type", 0), ("unassigned", 1), ("supp-card-type-2", 2), ("supp-card-type-3", 3), ("supp-card-type-4", 4), ("supp-card-type-5", 5), ("supp-card-type-6", 6), ("supp-card-type-7", 7), ("supp-card-type-8", 8), ("supp-card-type-9", 9), ("supp-card-type-10", 10), ("supp-card-type-11", 11), ("supp-card-type-12", 12), ("supp-card-type-13", 13), ("supp-card-type-14", 14), ("supp-card-type-15", 15), ("supp-card-type-16", 16), ("supp-card-type-17", 17), ("supp-card-type-18", 18), ("supp-card-type-19", 19), ("supp-card-type-20", 20), ("supp-card-type-21", 21), ("supp-card-type-22", 22), ("supp-card-type-23", 23), ("supp-card-type-24", 24), ("supp-card-type-25", 25), ("supp-card-type-26", 26), ("supp-card-type-27", 27), ("supp-card-type-28", 28), ("supp-card-type-29", 29), ("supp-card-type-30", 30), ("supp-card-type-31", 31), ("supp-card-type-32", 32), ("supp-card-type-33", 33), ("supp-card-type-34", 34), ("supp-card-type-35", 35), ("supp-card-type-36", 36), ("supp-card-type-37", 37), ("supp-card-type-38", 38), ("supp-card-type-39", 39), ("supp-card-type-40", 40), ("supp-card-type-41", 41), ("supp-card-type-42", 42), ("supp-card-type-43", 43), ("supp-card-type-44", 44), ("supp-card-type-45", 45), ("supp-card-type-46", 46), ("supp-card-type-47", 47), ("supp-card-type-48", 48), ("supp-card-type-49", 49), ("supp-card-type-50", 50), ("supp-card-type-51", 51), ("supp-card-type-52", 52), ("supp-card-type-53", 53), ("supp-card-type-54", 54), ("supp-card-type-55", 55), ("supp-card-type-56", 56), ("supp-card-type-57", 57), ("supp-card-type-58", 58), ("supp-card-type-59", 59), ("supp-card-type-60", 60), ("supp-card-type-61", 61), ("supp-card-type-62", 62), ("supp-card-type-63", 63))

class TmnxFabricType(TextualConvention, Unsigned32):
    description = 'The TmnxFabricType data type is an integer that specifies an Alcatel-Lucent SROS series fabric card type. A TmnxFabricType value is valid when there is a corresponding row in the tmnxFabricTypeTable.'
    status = 'current'

class TmnxFabricSuppType(TextualConvention, Bits):
    description = 'The TmnxFabricSuppType is a bit-mask specifying the valid fabric card types supported for a specific card slot. When multiple bits are set, it can be used to identify a set or list of card types used in the tmnxFabricTable to indicate supported fabric cards within a specific chassis slot. Some example card types might be: integrated -- the CPM/SF Module consists of an integrated fabric card.'
    status = 'current'
    namedValues = NamedValues(("invalidCardType", 0), ("unassigned", 1), ("suppCardType2", 2), ("suppCardType3", 3), ("suppCardType4", 4), ("suppCardType5", 5), ("suppCardType6", 6), ("suppCardType7", 7), ("suppCardType8", 8), ("suppCardType9", 9), ("suppCardType10", 10), ("suppCardType11", 11), ("suppCardType12", 12), ("suppCardType13", 13), ("suppCardType14", 14), ("suppCardType15", 15), ("suppCardType16", 16), ("suppCardType17", 17), ("suppCardType18", 18), ("suppCardType19", 19), ("suppCardType20", 20), ("suppCardType21", 21), ("suppCardType22", 22), ("suppCardType23", 23), ("suppCardType24", 24), ("suppCardType25", 25), ("suppCardType26", 26), ("suppCardType27", 27), ("suppCardType28", 28), ("suppCardType29", 29), ("suppCardType30", 30), ("suppCardType31", 31), ("suppCardType32", 32), ("suppCardType33", 33), ("suppCardType34", 34), ("suppCardType35", 35), ("suppCardType36", 36), ("suppCardType37", 37), ("suppCardType38", 38), ("suppCardType39", 39), ("suppCardType40", 40), ("suppCardType41", 41), ("suppCardType42", 42), ("suppCardType43", 43), ("suppCardType44", 44), ("suppCardType45", 45), ("suppCardType46", 46), ("suppCardType47", 47), ("suppCardType48", 48), ("suppCardType49", 49), ("suppCardType50", 50), ("suppCardType51", 51), ("suppCardType52", 52), ("suppCardType53", 53), ("suppCardType54", 54), ("suppCardType55", 55), ("suppCardType56", 56), ("suppCardType57", 57), ("suppCardType58", 58), ("suppCardType59", 59), ("suppCardType60", 60), ("suppCardType61", 61), ("suppCardType62", 62), ("suppCardType63", 63))

class TmnxCardRebootType(TextualConvention, Integer32):
    description = "The TmnxCardRebootType is an enumerated integer that describes the values used to support reboot operation style commands. GETs and GETNEXTs on a variable of this type always returns 'not-applicable (2)'."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("cardReset", 1), ("notApplicable", 2), ("cardPowerCycle", 3))

class TmnxChassisType(TextualConvention, Unsigned32):
    description = 'The TmnxChassisType data type is an integer that specifies the index value for the entry in the tmnxChassisTypeTable used to identify a specific type of chassis backplane manufactured by Alcatel-Lucent.'
    status = 'current'

class TmnxDeviceState(TextualConvention, Integer32):
    description = 'The TmnxDeviceState data type is an enumerated integer that describes the values used to identify states of chassis components such as fans and power supplies.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("deviceStateUnknown", 1), ("deviceNotEquipped", 2), ("deviceStateOk", 3), ("deviceStateFailed", 4), ("deviceStateOutOfService", 5))

class TmnxLEDState(TextualConvention, Integer32):
    description = 'The TmnxLEDState data type is an enumerated integer that describes the values used to identify state LEDs on Alcatel-Lucent SROS series cards.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("ledOff", 1), ("ledRed", 2), ("ledAmber", 3), ("ledYellow", 4), ("ledGreen", 5), ("ledAmberBlink", 6), ("ledYellowBlink", 7), ("ledGreenBlink", 8))

class TmnxMdaType(TextualConvention, Unsigned32):
    description = 'The TmnxMdaType data type is an integer that used to identify the kind of Media Dependent Adapter (MDA) installed on a card. The value of TmnxMdaType corresponds to the bit number indicated by TmnxMDASuppType. A TmnxMdaType value specifies the index value for the entry in the tmnxMdaTypeTable used to identify a specific type of MDA manufactured by Alcatel-Lucent.'
    status = 'current'

class TmnxMDASuppType(TextualConvention, Bits):
    description = 'The TmnxMDASuppType data type is a SNMP BIT that is used to identify the kind of Media Dependent Adapter (MDA) supported on a card. When multiple bits are set, it can be used to identify a set or list of supported MDAs within a specific card slot. The MDA types are defined in the tmnxMdaTypeTable.'
    status = 'current'
    namedValues = NamedValues(("invalid-MDA-type", 0), ("unassigned", 1), ("supp-MDA-type-2", 2), ("supp-MDA-type-3", 3), ("supp-MDA-type-4", 4), ("supp-MDA-type-5", 5), ("supp-MDA-type-6", 6), ("supp-MDA-type-7", 7), ("supp-MDA-type-8", 8), ("supp-MDA-type-9", 9), ("supp-MDA-type-10", 10), ("supp-MDA-type-11", 11), ("supp-MDA-type-12", 12), ("supp-MDA-type-13", 13), ("supp-MDA-type-14", 14), ("supp-MDA-type-15", 15), ("supp-MDA-type-16", 16), ("supp-MDA-type-17", 17), ("supp-MDA-type-18", 18), ("supp-MDA-type-19", 19), ("supp-MDA-type-20", 20), ("supp-MDA-type-21", 21), ("supp-MDA-type-22", 22), ("supp-MDA-type-23", 23), ("supp-MDA-type-24", 24), ("supp-MDA-type-25", 25), ("supp-MDA-type-26", 26), ("supp-MDA-type-27", 27), ("supp-MDA-type-28", 28), ("supp-MDA-type-29", 29), ("supp-MDA-type-30", 30), ("supp-MDA-type-31", 31), ("supp-MDA-type-32", 32), ("supp-MDA-type-33", 33), ("supp-MDA-type-34", 34), ("supp-MDA-type-35", 35), ("supp-MDA-type-36", 36), ("supp-MDA-type-37", 37), ("supp-MDA-type-38", 38), ("supp-MDA-type-39", 39), ("supp-MDA-type-40", 40), ("supp-MDA-type-41", 41), ("supp-MDA-type-42", 42), ("supp-MDA-type-43", 43), ("supp-MDA-type-44", 44), ("supp-MDA-type-45", 45), ("supp-MDA-type-46", 46), ("supp-MDA-type-47", 47), ("supp-MDA-type-48", 48), ("supp-MDA-type-49", 49), ("supp-MDA-type-50", 50), ("supp-MDA-type-51", 51), ("supp-MDA-type-52", 52), ("supp-MDA-type-53", 53), ("supp-MDA-type-54", 54), ("supp-MDA-type-55", 55), ("supp-MDA-type-56", 56), ("supp-MDA-type-57", 57), ("supp-MDA-type-58", 58), ("supp-MDA-type-59", 59), ("supp-MDA-type-60", 60), ("supp-MDA-type-61", 61), ("supp-MDA-type-62", 62), ("supp-MDA-type-63", 63), ("supp-MDA-type-64", 64), ("supp-MDA-type-65", 65), ("supp-MDA-type-66", 66), ("supp-MDA-type-67", 67), ("supp-MDA-type-68", 68), ("supp-MDA-type-69", 69), ("supp-MDA-type-70", 70), ("supp-MDA-type-71", 71), ("supp-MDA-type-72", 72), ("supp-MDA-type-73", 73), ("supp-MDA-type-74", 74), ("supp-MDA-type-75", 75), ("supp-MDA-type-76", 76), ("supp-MDA-type-77", 77), ("supp-MDA-type-78", 78), ("supp-MDA-type-79", 79), ("supp-MDA-type-80", 80), ("supp-MDA-type-81", 81), ("supp-MDA-type-82", 82), ("supp-MDA-type-83", 83), ("supp-MDA-type-84", 84), ("supp-MDA-type-85", 85), ("supp-MDA-type-86", 86), ("supp-MDA-type-87", 87), ("supp-MDA-type-88", 88), ("supp-MDA-type-89", 89), ("supp-MDA-type-90", 90), ("supp-MDA-type-91", 91), ("supp-MDA-type-92", 92), ("supp-MDA-type-93", 93), ("supp-MDA-type-94", 94), ("supp-MDA-type-95", 95), ("supp-MDA-type-96", 96), ("supp-MDA-type-97", 97), ("supp-MDA-type-98", 98), ("supp-MDA-type-99", 99), ("supp-MDA-type-100", 100), ("supp-MDA-type-101", 101), ("supp-MDA-type-102", 102), ("supp-MDA-type-103", 103), ("supp-MDA-type-104", 104), ("supp-MDA-type-105", 105), ("supp-MDA-type-106", 106), ("supp-MDA-type-107", 107), ("supp-MDA-type-108", 108), ("supp-MDA-type-109", 109), ("supp-MDA-type-110", 110), ("supp-MDA-type-111", 111))

class TmnxMDAChanType(TextualConvention, Integer32):
    description = 'The TmnxMDAChanType data type indicates the type of channel that can be created on an MDA.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))
    namedValues = NamedValues(("unknown", 0), ("sonetSts768", 1), ("sonetSts192", 2), ("sonetSts48", 3), ("sonetSts12", 4), ("sonetSts3", 5), ("sonetSts1", 6), ("sdhTug3", 7), ("sonetVtg", 8), ("sonetVt15", 9), ("sonetVt2", 10), ("sonetVt3", 11), ("sonetVt6", 12), ("pdhTu3", 13), ("pdhDs3", 14), ("pdhE3", 15), ("pdhDs1", 16), ("pdhE1", 17), ("pdhDs0Grp", 18))

class TmnxMdaAtmMode(TextualConvention, Integer32):
    description = 'TmnxMdaAtmMode is an enumerated integer whose value specifies the maximum number of Virtual Circuits for an ATM-capable Media Dependent Adapter (MDA).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("notApplicable", 0), ("max8kVc", 1), ("max16kVc", 2))

class TmnxCcmType(TextualConvention, Unsigned32):
    description = 'The TmnxCcmType data type is bit-mask field that describes the values used to identify the kind of Chassis Control module (CCM) installed on the chassis. A TmnxCcmType bit value specifies the index value for the entry in the tmnxCcmTypeTable used to identify a specific type of CCM manufactured by Alcatel-Lucent. When multiple bits are set, it can be used to identify a set or list of CCM types used in the tmnxCcmTable to indicate supported CCMs within a specific chassis slot. Some example CCM types are: unknown -- unknown/uninstalled ccm-v1 -- Chassis Control Module version 1 '
    status = 'current'

class TmnxMcmType(TextualConvention, Unsigned32):
    description = 'The TmnxMcmType data type is bit-mask field that describes the values used to identify the kind of MDA Carrier module (MCM) installed on the chassis. A TmnxMcmType bit value specifies the index value for the entry in the tmnxMcmTypeTable used to identify a specific type of MCM manufactured by Alcatel-Lucent. When multiple bits are set, it can be used to identify a set or list of MCM types used in the tmnxMcmTable to indicate supported MCMs within a specific card slot.'
    status = 'current'

class TmnxSlotNum(TextualConvention, Integer32):
    description = 'The TmnxSlotNum data type is an integer that specifies a slot in an Alcatel-Lucent SROS series chassis.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 128)

class TmnxSlotNumOrZero(TextualConvention, Integer32):
    description = 'The TmnxSlotNumOrZero data type is an integer that specifies a slot in an Alcatel-Lucent SROS series chassis or zero.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 128)

class TmnxPortAdminStatus(TextualConvention, Integer32):
    description = 'The desired administrative status of this port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("noop", 1), ("inService", 2), ("outOfService", 3), ("diagnose", 4))

class TmnxChassisMode(TextualConvention, Integer32):
    description = "The TmnxChassisMode data type is an enumerated integer that specifies the values used to identify which set of scaling numbers and features are effective for an Alcatel-Lucent SROS series chassis. 'modeA' corresponds to the scaling and feature set on the existing iom-20g. 'modeB' corresponds to the scaling and features that come with iom-20g-b. 'modeC' corresponds to the scaling and features that come with iom2-20g. 'modeD' corresponds to the scaling and features that come with iom3-xp/imm modules."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("modeA", 1), ("modeB", 2), ("modeC", 3), ("modeD", 4))

class TmnxSETSRefSource(TextualConvention, Integer32):
    description = 'The TmnxSETSRefSource data type is an enumerated integer that describes the values used to identify the Synchronous Equipment Timing Subsystem (SETS) timing reference source.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("otherCPM", 0), ("reference1", 1), ("reference2", 2), ("bits1", 3), ("bits2", 4), ("ptp", 5), ("noReference", 6))

class TmnxSETSRefQualified(TextualConvention, Integer32):
    description = "The TmnxSETSRefQualified data type is an enumerated integer that describes the values used to identify whether the reference is 'qualified' or 'not-qualified' for use by SETS."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("qualified", 1), ("not-qualified", 2))

class TmnxSETSRefAlarm(TextualConvention, Bits):
    description = "The TmnxSETSRefAlarm data type is a bitmap that describes the values used to identify the alarms on the SETS timing reference source if the source is 'not-qualified'. 'los' - loss of signal 'oof' - out of frequency range 'oopir' - out of pull in range."
    status = 'current'
    namedValues = NamedValues(("los", 0), ("oof", 1), ("oopir", 2))

class TmnxBITSIfType(TextualConvention, Integer32):
    description = 'The TmnxBITSIfType data type is an enumerated integer that describes the values used to identify the interface and framing types of a BITS (Building Integrated Timing Supply) interface.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("none", 0), ("t1-esf", 1), ("t1-sf", 2), ("e1-pcm30crc", 3), ("e1-pcm31crc", 4))

class TmnxSSMQualityLevel(TextualConvention, Integer32):
    description = 'The TmnxSSMQualityLevel is an enumerated integer that describes the values used to identify the SSM Quality level of received SSM messages.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))
    namedValues = NamedValues(("unknown", 0), ("prs", 1), ("stu", 2), ("st2", 3), ("tnc", 4), ("st3e", 5), ("st3", 6), ("smc", 7), ("st4", 8), ("dus", 9), ("prc", 10), ("ssua", 11), ("ssub", 12), ("sec", 13), ("dnu", 14), ("inv", 15), ("pno", 16), ("eec1", 17), ("eec2", 18), ("failed", 19))

class TmnxRefInState(TextualConvention, Integer32):
    reference = "IEEE Std 1588-2008 'IEEE Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems'"
    description = "The TmnxRefInState is an enumerated integer that describes the values used to identify the state of system timing reference. A value of 'ptpAdminDisabled (17)' means that the PTP timing reference is not in use because 'tmnxPtpClockAdminState' is 'outOfService (3)'. This value only applies to the PTP timing reference. A value of 'ptpOperDown (18)' means that the PTP timing reference is not in use because 'tmnxPtpClockOperState' is 'outOfService (3)'. This value only applies to the PTP timing reference. A value of 'ptpNoParentClock (19)' means that the PTP timing reference is not in use because the local PTP clock has not selected a remote master clock to be the parent clock. This value only applies to the PTP timing reference."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))
    namedValues = NamedValues(("disabled", 0), ("unqualified", 1), ("standby", 2), ("up", 3), ("previousFailure", 4), ("lowQuality", 5), ("lof", 6), ("ais", 7), ("ghost", 8), ("validating", 9), ("reserved-10", 10), ("reserved-11", 11), ("reserved-12", 12), ("fer", 13), ("reserved-14", 14), ("reserved-15", 15), ("reserved-16", 16), ("ptpAdminDisabled", 17), ("ptpOperDown", 18), ("ptpNoParentClock", 19))

class TmnxBITSOutSource(TextualConvention, Integer32):
    reference = 'ITU-T G.8264/Y.1364 Distribution of timing through packet networks, Section A.7.'
    description = "The TmnxBITSOutSource is an enumerated integer that describes the values used to identity the source of the BITS (Building Integrated Timing Supply) output. When TmnxBITSOutSource is 'lineRef (1)', the BITS output timing is selected from either the first or second line reference input's timing, without any filtering. When TmnxBITSOutSource is 'internalClock (2)', the BITS output timing is driven from the system timing."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("lineRef", 1), ("internalClock", 2))

class TmnxCcagId(TextualConvention, Integer32):
    description = "TmnxCcagId is an integer specifying the cross connect aggregation group. The value '0' is used when a ccag is not defined and is not a valid value when TmnxCcagId is used as an index."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8), )
class TmnxCcagRate(TextualConvention, Integer32):
    description = "TmnxCcagRate is an integer specifying the rate for a CCAG member in Kbps. The range of TmnxCcagRate is from 0 Kbps to 100Gbps. The value '-1' is used for maximum rate available."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100000000), )
class TmnxCcagRateOption(TextualConvention, Integer32):
    description = 'TmnxCcagRateOption specifies how the defined rate is applied to active Cross Connect Adaptors (CCAs). aggregate (1) - the defined rate is equally divided among the CCAs in the CCAG member list based on the number of active CCAs. cca (2) - the defined rate is applied to all CCAs in the CCAG member list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("aggregate", 1), ("cca", 2))

class TmnxChassisPemType(TextualConvention, Integer32):
    description = 'TmnxChassisPemType specifies what Power Entry Module (PEM) type is installed in the Chassis. not-applicable (0) - Chassis does not support an installed PEM. unknown (1) - Unknown kind of PEM installed./ pem (2) - First generation of the PEM module. pem-3 (3) - Second generation of the PEM module capable of supporting the IOM3/IMM modules. peq (4) - Power Equalizer.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("not-applicable", 0), ("unknown", 1), ("pem", 2), ("pem-3", 3), ("peq", 4))

class TmnxCardSlotBitMap(TextualConvention, Bits):
    description = "TmnxCardSlotBitMap specifies a bitmap of card slots. A bit value set to '1' indicates the slot is used by the object."
    status = 'current'
    namedValues = NamedValues(("slot1", 0), ("slot2", 1), ("slot3", 2), ("slot4", 3), ("slot5", 4), ("slot6", 5), ("slot7", 6), ("slot8", 7), ("slot9", 8), ("slot10", 9), ("slot11", 10), ("slot12", 11), ("slot13", 12), ("slot14", 13), ("slot15", 14), ("slot16", 15))

class TmnxTunnelGroupId(TextualConvention, Unsigned32):
    description = 'TmnxTunnelGroupId is an integer specifying the ISA tunnel-group.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 16)

class TmnxTunnelGroupIdOrZero(TextualConvention, Unsigned32):
    description = 'TmnxTunnelGroupIdOrZero is an integer specifying the ISA tunnel-group A value of zero is used when the tunnel-group is not defined.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16), )
tmnxChassisTotalNumber = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisTotalNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTotalNumber.setDescription('The number of chassis installed in this system. For the first release of the Alcatel-Lucent 7x50 series product, there is only 1 chassis per system. A multi-chassis system model is supported to allow for future product expansion.')
tmnxChassisLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisLastChange.setDescription('The value of sysUpTime when the tmnxChassisTable was last changed.')
tmnxChassisTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3), )
if mibBuilder.loadTexts: tmnxChassisTable.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTable.setDescription('The chassis table has an entry for each chassis in the system.')
tmnxChassisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"))
if mibBuilder.loadTexts: tmnxChassisEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisEntry.setDescription('Each row entry represents a chassis in the system. The agent creates the row for the first chassis in the system, with tmnxChassisIndex = 1, which is auto-discovered by the active CPM card. Additional chassis entries can be created and deleted via SNMP SET operations. Creation requires a SET request containing at least tmnxChassisAdminMode and tmnxChassisRowStatus. Note that the first Alcatel-Lucent 7x50 series product release does not support multiple chassis, therefore there will not be more than one row entry in this table; attempts to create additional rows in this table will be denied.')
tmnxChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 1), TmnxChassisIndex())
if mibBuilder.loadTexts: tmnxChassisIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisIndex.setDescription('The unique value which identifies this chassis in the system. The first release of the product only supports a single chassis in the system.')
tmnxChassisRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisRowStatus.setDescription('The row status. The creation or deletion of a chassis entry causes creation or deletion of corresponding entries in the tmnxCardTable with the same tmnxChassisIndex value. Note, the agent will disallow chassis deletion if its entries in the card table have not first been put into the proper state for removal. The row entry for tmnxChassisIndex equal 1 cannot be deleted.')
tmnxChassisName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 3), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisName.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisName.setDescription("The administrative name assigned this chassis. Setting tmnxChassisName to the empty string, ''H, resets tmnxChassisName to the TiMOS default value.")
tmnxChassisType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 4), TmnxChassisType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisType.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisType.setDescription('The type of chassis used in this Alcatel-Lucent 7x50 system. The value of tmnxChassisType is the tmnxChassisTypeIndex for the entry in the tmnxChassisTypeTable that represents the Alcatel-Lucent SROS series chassis model for this system. Chassis types are distinguished by their backplane type.')
tmnxChassisLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 5), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisLocation.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisLocation.setDescription('A user supplied string that indicates the on site location of this chassis. This could used for a Common Language Location Identifier, CLLI, code string if desired. A CLLI code is an 11-character standardized geographic identifier that uniquely identifies the geographic location of places and certain functional categories of equipment unique to the telecommunications industry. All valid CLLI codes are created, updated and maintained in the Central Location Online Entry System (CLONES) database.')
tmnxChassisCoordinates = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 6), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisCoordinates.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisCoordinates.setDescription("A user supplied string that indicates the Global Positioning System (GPS) coordinates for the location of this chassis. N 45 58 23, W 34 56 12 N37 37' 00 latitude, W122 22' 00 longitude N36*39.246' W121*40.121' Two-dimensional GPS positioning offers latitude and longitude information as a four dimensional vector: <Direction, hours, minutes, seconds> where Direction is one of the four basic values: N, S, W, E; hours ranges from 0 to 180 (for latitude) and 0 to 90 for longitude, and, finally, minutes and seconds range from 0 to 60. Thus <W, 122, 56, 89> is an example of longitude and <N, 85, 66, 43> is an example of latitude. Four bytes of addressing space (one byte for each of the four dimensions) are necessary to store latitude and four bytes are also sufficient to store longitude. Thus eight bytes total are necessary to address the whole surface of earth with precision down to 0.1 mile! Notice that if we desired precision down to 0.001 mile (1.8 meters) then we would need just five bytes for each component, or ten bytes together for the full address (as military versions provide).")
tmnxChassisNumSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumSlots.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumSlots.setDescription('The number of slots in this chassis that are available for plug-in cards. This includes both fabric and IOM cards')
tmnxChassisNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumPorts.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumPorts.setDescription('The total number of ports currently installed in this chassis. This count does not include the Ethernet ports on the CPM cards that are used for management access.')
tmnxChassisNumPwrSupplies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumPwrSupplies.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumPwrSupplies.setDescription('The total number of power supplies installed in this chassis.')
tmnxChassisNumFanTrays = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumFanTrays.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumFanTrays.setDescription('The total number of fan trays installed in this chassis.')
tmnxChassisNumFans = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumFans.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumFans.setDescription('The total number of fans installed in this chassis.')
tmnxChassisCriticalLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 12), TmnxLEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisCriticalLEDState.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisCriticalLEDState.setDescription('The current state of the Critical LED in this chassis.')
tmnxChassisMajorLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 13), TmnxLEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisMajorLEDState.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisMajorLEDState.setDescription('The current state of the Major LED in this chassis.')
tmnxChassisMinorLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 14), TmnxLEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisMinorLEDState.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisMinorLEDState.setDescription('The current state of the Minor LED in this chassis.')
tmnxChassisBaseMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 15), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisBaseMacAddress.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisBaseMacAddress.setDescription('The base chassis ethernet MAC address. Special purpose MAC addresses used by the system software are constructed as offsets from this base address.')
tmnxChassisCLLICode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 16), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisCLLICode.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisCLLICode.setDescription('A Common Language Location Identifier (CLLI) code is an 11-character standardized geographic identifier that uniquely identifies the geographic location of places and certain functional categories of equipment unique to the telecommunications industry. If the set on this object specifies a non-null string, the string will automatically be truncated or padded(with spaces) to 11 characters.')
tmnxChassisReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 17), TmnxActionType().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisReboot.setDescription("Setting this tmnxChassisReboot to 'doAction' causes a soft-reboot of the entire chassis including all the CPM and IOM cards. Note that the reboot action is likely to occur before the SNMP SET response can be transmitted.")
tmnxChassisUpgrade = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 18), TmnxActionType().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisUpgrade.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUpgrade.setDescription("Setting this tmnxChassisUpgrade to 'doAction' causes an upgrade of all firmware and a reboot of the entire chassis including all the CPM and IOM cards. CAUTION: This upgrade and reboot may take several minutes to complete. The chassis MUST NOT be reset or powered down, nor cards inserted or removed, during this process. Any of these prohibited actions may cause the cards to be rendered inoperable. tmnxChassisUpgrade and tmnxChassisReboot must be set together in the same SNMP SET request PDU or else the SET request will fail with an inconsistentValue error. Note that the reboot action is likely to occur before the SNMP SET response can be transmitted.")
tmnxChassisAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 19), TmnxChassisMode().clone('modeA')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisAdminMode.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminMode.setDescription("The value of tmnxChassisAdminMode specifies the scaling and feature set for all of the IOM cards in the chassis. Setting tmnxChassisAdminMode to a particular mode corresponds to the scaling and feature sets supported on that IOM card type. The following table describes the maximum mode capable per IOM (ie. 'modeC' scaling and feature sets cannot be supported on either the iom-20g or the iom-20g-b): IOM MODE (maximum) ---------------- -------------- iom-20g modeA iom-20g-b modeB iom2-20g modeC iom3-xp/imm modeD An attempt to change the value of tmnxChassisAdminMode from a lesser mode to a greater mode (ie. Upgrading from 'modeA' to 'modeB') without also setting tmnxChassisModeForce to a value of 'doAction' in the same SNMP SET request, will fail with an inconsistentValue error if there are any IOM cards in the chassis with a tmnxCardAssignedType value that does not support the new mode. Changing the value of tmnxChassisAdminMode from a greater mode to a lesser mode (ie. Downgrading from 'modeC' to 'modeA') will not take effect until after saving the configuration and rebooting the system.")
tmnxChassisOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 20), TmnxChassisMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisOperMode.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisOperMode.setDescription("The value of tmnxChassisOperMode indicates the operational scaling and feature set for all IOM cards in the chassis. Changing the value of tmnxChassisAdminMode from a greater mode to a lesser mode (downgrade) will result in tmnxChassisAdminMode indicating the new mode while tmnxChassisOperMode indicates previous mode until the configuration is saved and the system rebooted, at which point, the actual downgrade will take effect and both tmnxChassisAdminMode and tmnxChassisOperMode will indicate the new mode. Upgrading from a lesser mode to a greater mode (ie. From 'modeA' to 'modeB') will take effect immediately and the tmnxChassisOperMode will indicate the same mode as that of tmnxChassisAdminMode.")
tmnxChassisModeForce = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 21), TmnxActionType().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisModeForce.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisModeForce.setDescription("Setting tmnxChassisModeForce to a value of 'doAction' in the same SNMP SET request where tmnxChassisAdminMode is set to a greater mode than the current mode (ie. New mode 'modeB', while current is 'modeA') allows the chassis to be upgraded to to the new mode even if there are IOM cards in the chassis with a tmnxCardAssignedType value that does not support the new mode. An attempt to set tmnxChassisModeForce to 'doAction' without also setting tmnxChassisAdminMode, in the same SNMP SET request will fail with an inconsistentValue error.")
tmnxChassisUpdateWaitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 600)).clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisUpdateWaitTime.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisUpdateWaitTime.setDescription('The value of tmnxChassisUpdateWaitTime specifies the time to wait before rebooting IOM cards running older software versions following a software upgrade or downgrade activity switchover. This object was obsoleted in release 5.0.')
tmnxChassisUpdateTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 23), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisUpdateTimeLeft.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUpdateTimeLeft.setDescription('Following a software upgrade or downgrade activity switchover, the value of tmnxChassisUpdateTimeLeft indicates the time remaining before IOM cards or MDAs running older software versions will be rebooted.')
tmnxChassisOverTempState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stateOk", 1), ("stateOverTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisOverTempState.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisOverTempState.setDescription('The current Over Temperature state of this chassis. stateOk Indicates chassis is below the temperature threshold. stateOverTemp Indicates chassis is above the temperature threshold. ')
tmnxChassisMixedModeIomAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 25), TmnxEnabledDisabled().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisMixedModeIomAdminMode.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisMixedModeIomAdminMode.setDescription("The value of tmnxChassisMixedModeIomAdminMode specifies if the chassis should allow functionally to run with a mixture of forwarding hardware. When 'enabled(1)' on a 7450 chassis it allows SR functionality to be configured. SR functionality is a superset of ESS functionality. Once tmnxChassisMixedModeIomAdminMode is enabled, additional IOMs can be converted to SR functionality by setting the tmnxCardCapability field of the corresponding tmnxCardEntry. When 'enabled(1)' on a 7750 chassis it allows allows IPv6 functionality without requiring chassis mode C or better. tmnxChassisMixedModeIomAdminMode is only applicable when tmnxChassisType indicates the chassis type is 7450 ESS-6, 7450 ESS-6v, 7450 ESS-7, 7450 ESS-12, 7750 SR-7 or 7750 SR-12.")
tmnxChassisMixedModeIomUpgrList = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 26), Bits().clone(namedValues=NamedValues(("iomSlot1", 0), ("iomSlot2", 1), ("iomSlot3", 2), ("iomSlot4", 3), ("iomSlot5", 4), ("iomSlot6", 5), ("iomSlot7", 6), ("iomSlot8", 7), ("iomSlot9", 8), ("iomSlot10", 9)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisMixedModeIomUpgrList.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisMixedModeIomUpgrList.setDescription("The value of tmnxChassisMixedModeIomUpgrList specifies the list of IOM slots which are to operate with SR functionality on the 7450 chassis. tmnxChassisMixedModeIomUpgrList is only applicable when tmnxChassisType indicates the chassis type is 7450 ESS-7 or 7450 ESS-12, and should only be set when enabling mixed-mode. tmnxChassisMixedModeIomUpgrList is a bitmap, with a bit for each IOM slot on the chassis. If the bit for a particular IOM slot is '1', the SR functionality will be enabled on the IOM when enabling mixed-mode. If the bit is set to '0', the IOM will continue to operate with ESS functionality. To set a particular bit to '1': 1. The IOM slot must have a configured type of iom3-xp, or any type of IMM. 2. The installed IOM/IMM must be a 7750 IOM/IMM. The platform type for an IOM/IMM can be read using tmnxHwEquippedPlatform. 3. tmnxChassisMixedModeIomAdminMode must be set to 'enabled (1)' in the same Set request packet.")
tmnxChassisRedForcedSingleSfm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 27), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisRedForcedSingleSfm.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisRedForcedSingleSfm.setDescription("Setting this variable to 'true' forces the IGP single-SFM-overload state to 'overload' in the router instances where the value of the object TIMETRA-VRTR-MIB::vRtrSingleSfmOverloadAdminState is equal to 'inService'.")
tmnxChassisFanTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4), )
if mibBuilder.loadTexts: tmnxChassisFanTable.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanTable.setDescription('This table contains information about fan trays.')
tmnxChassisFanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxChassisFanIndex"))
if mibBuilder.loadTexts: tmnxChassisFanEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanEntry.setDescription('Contains information regarding a fan tray.')
tmnxChassisFanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: tmnxChassisFanIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanIndex.setDescription('The unique value which identifies a specific fan tray in the chassis.')
tmnxChassisFanOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1, 2), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisFanOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanOperStatus.setDescription('Current status of the Fan tray.')
tmnxChassisFanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("unknown", 1), ("halfSpeed", 2), ("fullSpeed", 3), ("lowSpeed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisFanSpeed.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanSpeed.setDescription("The value of tmnxChassisFanSpeed indicates if the fans in this fan tray are running at 'lowSpeed', 'halfSpeed' or 'fullSpeed'.")
tmnxChassisFanRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("fan1", 1), ("hfFan2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisFanRevision.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanRevision.setDescription('The value of tmnxChassisFanRevision indicates the fan tray revision. fan1 - represents the original fan tray. hfFan2 - represents the high-flow fan tray; second revision.')
tmnxChassisPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5), )
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTable.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTable.setDescription('This table contains information about power supply trays, also known as PEMs (Power Entry Modules).')
tmnxChassisPowerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyId"))
if mibBuilder.loadTexts: tmnxChassisPowerSupplyEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyEntry.setDescription('Contains information regarding a power supply tray.')
tmnxChassisPowerSupplyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: tmnxChassisPowerSupplyId.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyId.setDescription('The unique identifier index for a power supply tray in the chassis.')
tmnxChassisPowerSupplyACStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 2), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyACStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyACStatus.setDescription("If the value of tmnxChassisPowerSupplyACStatus is 'deviceStateOk', the input AC voltage is within range. If the value is 'deviceStateFailed', an AC voltage out of range condition has been detected. A value of 'deviceNotEquipped' indicates that the AC power supply is not present.")
tmnxChassisPowerSupplyDCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 3), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyDCStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyDCStatus.setDescription("If the value of tmnxChassisPowerSupplyDCStatus is 'deviceStateOk', the input DC voltage is within range. If the value is 'deviceStateFailed', an DC voltage out of range condition has been detected. A value of 'deviceNotEquipped' indicates that the DC power supply is not present.")
tmnxChassisPowerSupplyTempStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 4), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTempStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTempStatus.setDescription("If the value of tmnxChassisPowerSupplyTempStatus is 'deviceStateOk', the current temperature is within acceptable range. If the value is 'deviceStateFailed', a temperature too high condition has been detected.")
tmnxChassisPowerSupplyTempThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 5), Integer32()).setUnits('degrees celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTempThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTempThreshold.setDescription("The temperature threshold for this power supply tray in degrees celsius. When the temperature raises above tmnxChassisPowerSupplyTempThreshold, a 'temperature too high' event will be generated.")
tmnxChassisPowerSupply1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 6), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupply1Status.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupply1Status.setDescription("The overall status of an equipped power supply. For AC multiple power supplies, this represents the overall status of the first power supply in the tray (or shelf). For any other type, this represents the overall status of the power supply. If tmnxChassisPowerSupply1Status is 'deviceStateOk', then all monitored statuses are 'deviceStateOk'. A value of 'deviceStateFailed' represents a condition where at least one monitored status is in a failed state.")
tmnxChassisPowerSupply2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 7), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupply2Status.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupply2Status.setDescription("The overall status of an equipped power supply. For AC multiple power supplies, this represents the overall status of the second power supply in the tray (or shelf). For any other type, this field is unused and set to 'deviceNotEquipped'. If tmnxChassisPowerSupply2Status is 'deviceStateOk', then all monitored statuses are 'deviceStateOk'. A value of 'deviceStateFailed' represents a condition where at least one monitored status is in a failed state.")
tmnxChassisPowerSupplyAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("dc", 1), ("acSingle", 2), ("acMultiple", 3), ("default", 4))).clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyAssignedType.setDescription("tmnxChassisPowerSupplyAssignedType configures the type of power supply for a platform. Based on the value assigned to this object, various power supply monitoring signals will be interpreted. For example, if a platform is provisioned to use DC power supplies, then the signal that indicates an AC power supply is missing can be ignored. The configuration of this object away from 'default (4)' is required for proper generation of traps and LED management.")
tmnxChassisPowerSupplyInputStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 9), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyInputStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyInputStatus.setDescription("If the value of tmnxChassisPowerSupplyInputStatus is 'deviceStateOk', the input voltage of the power supply is within range. If the value is 'deviceStateFailed', an input voltage out of range condition has been detected. A value of 'deviceNotEquipped' indicates that the power supply is not present.")
tmnxChassisPowerSupplyOutputStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 10), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyOutputStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyOutputStatus.setDescription("If the value of tmnxChassisPowerSupplyOutputStatus is 'deviceStateOk', the output voltage of the power supply is within range. If the value is 'deviceStateFailed', an output voltage out of range condition has been detected. A value of 'deviceNotEquipped' indicates that the power supply is not present.")
tmnxChassisPowerSupplyPemType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 11), TmnxChassisPemType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyPemType.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyPemType.setDescription('The tmnxChassisPowerSupplyPemType indicates the Power Entry Module type installed in the PEM slot.')
tmnxChassisTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6), )
if mibBuilder.loadTexts: tmnxChassisTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeTable.setDescription('The chassis type table has an entry for each Alcatel-Lucent SROS series chassis model.')
tmnxChassisTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisTypeIndex"))
if mibBuilder.loadTexts: tmnxChassisTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeEntry.setDescription('Each row entry represents an Alcatel-Lucent SROS series Chassis model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxChassisTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1, 1), TmnxChassisType())
if mibBuilder.loadTexts: tmnxChassisTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeIndex.setDescription('The unique index value which identifies this type of Alcatel-Lucent SROS series chassis model.')
tmnxChassisTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeName.setDescription('The administrative name that identifies this type of Alcatel-Lucent SROS series chassis model. This name string may be used in CLI commands to specify a particular chassis model type.')
tmnxChassisTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeDescription.setDescription('A detailed description of this Alcatel-Lucent SROS series chassis model.')
tmnxChassisTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeStatus.setDescription("When tmnxChassisTypeStatus has a value of 'true' it indicates that this chassis model is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxHwLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxHwLastChange.setDescription('The value of sysUpTime when the tmnxHwTable was last changed.')
tmnxHwTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8), )
if mibBuilder.loadTexts: tmnxHwTable.setStatus('current')
if mibBuilder.loadTexts: tmnxHwTable.setDescription("The tmnxHwTable has an entry for each managed hardware component in the Alcatel-Lucent SROS series system's chassis. Examples of these hardware component types are IOM, Fabric, and CPM cards, MCM and CCM, and MDA modules. Similar information for physical ports is in the tmnxPortObjs.")
tmnxHwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxHwIndex"))
if mibBuilder.loadTexts: tmnxHwEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxHwEntry.setDescription('Each row entry represents an Alcatel-Lucent SROS series manufactured hardware component. Entries cannot be created and deleted via SNMP SET operations. When an entry is created in one of the card tables, IOM, CPM, Fabric or MDA, a tmnxHwEntry is created for the common hardware management information for that card in that chassis. When the card is removed from the chassis, its corresponding tmnxHwEntry is deleted. The tmnxHwIndex is bitmapped: | 32 25 | 24 17 | 16 9 | 8 1 | +-------------+-------------+-------------+-------------+ | TmnxHwClass | 00000000 | Slot | number | +-------------+-------------+-------------+-------------+ The Slot field is only used for components on cards in slots. It is zero for all others. The number field starts from 1 and indicates which component. E.g. Power supply 1 or 2.')
tmnxHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 1), TmnxHwIndex())
if mibBuilder.loadTexts: tmnxHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxHwIndex.setDescription('The value of tmnxHwIndex is a unique index that identifies common management information for Alcatel-Lucent SROS series manufactured hardware components within the specified chassis.')
tmnxHwID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwID.setStatus('current')
if mibBuilder.loadTexts: tmnxHwID.setDescription("The value of tmnxHwID is an object identifier that points to the table and row entry with additional management information specific to this hardware component's class.")
tmnxHwMfgString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 253))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwMfgString.setStatus('current')
if mibBuilder.loadTexts: tmnxHwMfgString.setDescription('The tmnxHwMfgString contains unspecified Alcatel-Lucent SROS series manufacturing information and includes the Alcatel-Lucent vendor information.')
tmnxHwMfgBoardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwMfgBoardNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxHwMfgBoardNumber.setDescription('The tmnxHwMfgBoardNumber contains the part number information.')
tmnxHwSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSerialNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxHwSerialNumber.setDescription('The unique Alcatel-Lucent SROS series serial number of the hardware component.')
tmnxHwManufactureDate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwManufactureDate.setStatus('current')
if mibBuilder.loadTexts: tmnxHwManufactureDate.setDescription("The manufacturing date of the hardware component in 'mmddyyyy' ascii format.")
tmnxHwClass = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 7), TmnxHwClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwClass.setStatus('current')
if mibBuilder.loadTexts: tmnxHwClass.setDescription("The value of tmnxHwClass indicates the general hardware type of this component. If no appropriate enumeration exists for this hardware component then the value 'other (1)' is used. If the agent cannot identify this hardware component then the value 'unknown (2)' is used.")
tmnxHwName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 8), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwName.setStatus('current')
if mibBuilder.loadTexts: tmnxHwName.setDescription("The value of tmnxHwName is the name of the component as assigned by the system software itself and is suitable for use in CLI commands. This may be a text name such as 'console' or a port ID such as '2/2'. If there is no predefined name then a zero length string is returned. Note that the value of tmnxHwName for two component entries will be the same if the CLI does not distinguish between them, e.g. the chassis slot-1 and the card in slot-1.")
tmnxHwAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 9), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxHwAlias.setStatus('current')
if mibBuilder.loadTexts: tmnxHwAlias.setDescription("The value of tmnxHwAlias is the administrative name assigned to this hardware component by the CLI user or network manager. It is saved across re-initializations and reboots of the system. The object tmnxHwAlias is not supported on rows where the tmnxHwClass is set to 'flashDiskModule (12)'. Attempts to set the tmnxHwAlias object on rows where it is not supported will result in an inconsistentValue error.")
tmnxHwAssetID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 10), SnmpAdminString().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxHwAssetID.setStatus('current')
if mibBuilder.loadTexts: tmnxHwAssetID.setDescription("The value of tmnxHwAssetID is an administratively assigned asset tracking identifier for this hardware component. It is saved across re-initializations and reboots of the system. If no asset tracking information is associated with this hardware component, a zero-length string is returned to an SNMP get request. The object tmnxHwAssetID is not supported on rows where the tmnxHwClass is set to 'flashDiskModule (12)'. Attempts to set the tmnxHwAssetID object on rows where it is not supported will result in an inconsistentValue error. Some hardware components do not have asset tracking identifiers. Components for which tmnxHwIsFRU has a value of 'false' do not need their own unique asset tracking identifier. In this case, the agent denies write access to this object and returns a zero-length string to an SNMP get request.")
tmnxHwCLEI = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwCLEI.setReference('Bellcore (Telcordia Technologies) GR-485.')
if mibBuilder.loadTexts: tmnxHwCLEI.setStatus('current')
if mibBuilder.loadTexts: tmnxHwCLEI.setDescription("The Common Language Equipment Identifier, CLEI, code is a unique 10-character identifier, that is fixed by the manufacturer. It consists of ten alphanumeric characters. The first seven characters present a concise summary of an equipment entity's circuit or transport capabilities, e.g., functional, electrical, bandwidth, etc. CLEI codes for plug-in or portable equipment with the same first seven characters (CLEI-7) are considered bidirectionally interchangeable and group under a G level record. Most licensees plug-in inventories and records are controlled at the group level. The eighth character denotes the reference source used for coding the item, and the last two characters denote manufacturing vintage or version, and other complemental information. A ten-character CLEI code that is developed for a specific piece of equipment is unique within the CLEI code universe and is used in A level records; the code is not assigned to any other equipment piece. Equipment is coded to a first or major application. When the same equipment is usable in another application or system, it is not recorded nor are additional codes developed for that purpose.")
tmnxHwIsFRU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwIsFRU.setStatus('current')
if mibBuilder.loadTexts: tmnxHwIsFRU.setDescription("The value of tmnxHwIsFRU indicates whether or not this hardware component is a Field Replaceable Unit (FRU) or not. Those components that are permanently contained within a FRU have a value of 'false'.")
tmnxHwContainedIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwContainedIn.setStatus('current')
if mibBuilder.loadTexts: tmnxHwContainedIn.setDescription('The value of tmnxHwContainedIn is the tmnxHwIndex value for the row entry of the hardware component that contains this component. A value of zero indicates that this component is not contained in any other component.')
tmnxHwParentRelPos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwParentRelPos.setStatus('current')
if mibBuilder.loadTexts: tmnxHwParentRelPos.setDescription("The value of tmnxHwParentRelPos indicates the relative position of this hardware component among all its 'sibling' components. A sibling component shares the same instance values for tmnxHwContainedIn and tmnxHwClass objects. If the associated value of tmnxHwContainedIn is zero, then the value -1 is returned.")
tmnxHwAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noop", 1), ("inService", 2), ("outOfService", 3), ("diagnose", 4), ("operateSwitch", 5))).clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxHwAdminState.setStatus('current')
if mibBuilder.loadTexts: tmnxHwAdminState.setDescription("The desired administrative status of this hardware component. Write access will be denied for those components that do not have administrative status. An attempt to set tmnxHwAdminState to 'operateSwitch (5)' will fail if the hardware component is not part of a redundant pair. Some examples of redundant hardware are the CPM cards and fabric cards.")
tmnxHwOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("unknown", 1), ("inService", 2), ("outOfService", 3), ("diagnosing", 4), ("failed", 5), ("booting", 6), ("empty", 7), ("provisioned", 8), ("unprovisioned", 9), ("upgrade", 10), ("downgrade", 11), ("inServiceUpgrade", 12), ("inServiceDowngrade", 13), ("resetPending", 14), ("softReset", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwOperState.setStatus('current')
if mibBuilder.loadTexts: tmnxHwOperState.setDescription("The actual operational status of this hardware component. unknown (1) Status cannot be determined inService (2) Online - If tmnxHwClass has a value of 'ioModule (8)' or 'cpmModule (9), the card is present, booted, configured, and running. outOfService (3) Ready - The hardware component is OK but is down because tmnxHwAdminState has a value of 'outOfService (3)'. diagnosing (4) Not implemented. failed (5) This hardware component has failed. The value of tmnxHwFailureReason indicates the type of failure. If tmnxHwClass has a value of 'ioModule(8)' or 'cpmModule(9)', there is a card in the slot but it has failed. booting (6) A card is in the transitional startup state. empty (7) There is no card in the slot and it has not been pre-configured. provisioned (8) There is no card in the slot but it has been pre-configured. unprovisioned (9) There is a card in the slot but it is not configured. upgrade (10) Card software version is compatible with and newer than that running on the current active CPM. downgrade (11) Card software version is compatible with and older than that running on the current active CPM. inServiceUpgrade (12) Card is inService and the card software version is compatible with and newer than that running on the current active CPM. This state applies only to a standby CPM card. This enumeration is no longer supported as of release 5.0. inServiceDowngrade (13) Card is inService and the card software is compatible with and older than that running on the current active CPM. This state applies only to a standby CPM card. This enumeration is no longer supported as of release 5.0. resetPending (14) Card is awaiting reset following an upgrade or downgrade activity switch. The card software version is upgrade or downgrade compatible but will be reset in order to update it to match the active CPM software. The value of tmnxChassisUpdateWaitTime indicates the how long the system will wait following an upgrade or downgrade activity switch before it resets IOM cards. This state applies only to IOM cards. This enumeration is no longer supported as of release 5.0. softReset (15) Card is performing a soft reset. The data path is active, but control path transitional changes are suspended until the card leaves this state. ")
tmnxHwTempSensor = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwTempSensor.setStatus('current')
if mibBuilder.loadTexts: tmnxHwTempSensor.setDescription('The value of tmnxHwTempSensor indicates whether or not this hardware component contains a temperature sensor.')
tmnxHwTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 18), Integer32()).setUnits('degrees celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwTemperature.setStatus('current')
if mibBuilder.loadTexts: tmnxHwTemperature.setDescription("The current temperature reading in degrees celsius from this hardware component's temperature sensor. If this component does not contain a temperature sensor, then the value -1 is returned.")
tmnxHwTempThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 19), Integer32()).setUnits('degrees celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwTempThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxHwTempThreshold.setDescription("The temperature threshold for this hardware component in degrees celsius. When the value of tmnxHwTemperature raises above tmnxHwTempThreshold, a 'temperature too high' event will be generated.")
tmnxHwBootCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwBootCodeVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxHwBootCodeVersion.setDescription('The version number of boot eprom on the card in this slot. If no specific software program is associated with this hardware component then this object will contain a zero length string.')
tmnxHwSoftwareCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSoftwareCodeVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxHwSoftwareCodeVersion.setDescription('The software product release version number for the software image currently running on this IOM or CPM card. If no specific software program is associated with this hardware component then this object will contain a zero length string.')
tmnxHwSwLastBoot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 22), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSwLastBoot.setStatus('current')
if mibBuilder.loadTexts: tmnxHwSwLastBoot.setDescription('The date and time the software running on this IOM or CPM card was last rebooted. If this row entry represents a standby CPM card, the date and time indicated is when the standby completed its initial synchronization process and became ready to take over in case the active card fails or a manual switchover command is issued.')
tmnxHwSwState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 0), ("hwFailure", 1), ("swFailure", 2), ("hwInitting", 3), ("swDownloading", 4), ("swInitting", 5), ("swInitted", 6), ("swRunning", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSwState.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHwSwState.setDescription('The state of the software running on this IOM or CPM card. The tmnxHwSwState object is obsolete. The Alcatel-Lucent 7x50 platform cannot distinguish software status separate from the hardware status. Instead of using this object, additional operational states have been added to tmnxHwOperState. If no specific software program is associated with this hardware component then this object will contain a zero.')
tmnxHwAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 24), TmnxAlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwAlarmState.setStatus('current')
if mibBuilder.loadTexts: tmnxHwAlarmState.setDescription('The value of tmnxHwAlarmState indicates the current alarm state for this hardware component.')
tmnxHwLastAlarmEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 25), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwLastAlarmEvent.setStatus('current')
if mibBuilder.loadTexts: tmnxHwLastAlarmEvent.setDescription("The value of tmnxHwLastAlarmEvent indicates the object name and instance value that points to the row entry in the ALARM-MIB containing the most recent alarm associated with this hardware component. If tmnxHwAlarmState has a value of 'alarmCleared(2)', the most recent alarm event will be in the cleared alarm table. If it has a value of 'alarmActive(1)', the most recent alarm event will be in the active alarm table. If the value of tmnxHwLastAlarmEvent is '0.0', either no hardware component alarm events have occurred since the system was last booted, or the last hardware component alarm event has aged out and its entry is no longer available in the ALARM-MIB tables.")
tmnxHwClearAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 26), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxHwClearAlarms.setStatus('current')
if mibBuilder.loadTexts: tmnxHwClearAlarms.setDescription('Setting this action variable causes all the active alarms associated with this hardware component to be moved from the ALARM-MIB nlmActiveAlarmTable to the nlmClearedAlarmTable. This action button is primarily meant for use as a code development aid. This object may be removed from the TIMETRA-CHASSIS-MIB before product release.')
tmnxHwSwImageSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("primary", 1), ("secondary", 2), ("tertiary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSwImageSource.setStatus('current')
if mibBuilder.loadTexts: tmnxHwSwImageSource.setDescription('The value of tmnxHwSwImageSource indicates the location in the Boot Options File (BOF) where the software image file was found when the system last rebooted.')
tmnxHwMfgDeviations = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 28), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwMfgDeviations.setStatus('current')
if mibBuilder.loadTexts: tmnxHwMfgDeviations.setDescription('tmnxHwMfgDeviations contains a record of changes done by the manufacturing to the hardware or software and which is outside the normal revision control process.')
tmnxHwBaseMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 29), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwBaseMacAddress.setStatus('current')
if mibBuilder.loadTexts: tmnxHwBaseMacAddress.setDescription("tmnxHwBaseMacAddress contains the base MAC address of the hardware component. It is applicable only if tmnxHwClass is of type 'chassis', 'ioModule', 'cpmModule' or 'mdaModule'.")
tmnxHwFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 30), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwFailureReason.setStatus('current')
if mibBuilder.loadTexts: tmnxHwFailureReason.setDescription("tmnxHwFailureReason indicates the reason why a hardware component 'failed' as indicated in tmnxHwOperState.")
tmnxHwEquippedPlatform = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("pfUnknown", 0), ("pf7750", 1), ("pf7450", 2), ("pf7710", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwEquippedPlatform.setStatus('current')
if mibBuilder.loadTexts: tmnxHwEquippedPlatform.setDescription("The value of tmnxHwEquippedPlatform indicates the platform type of the installed hardware component, as read from the component's EEPROM. For example, 'pf7750' is returned for an installed 7750 iom3-xp. pfUnknown is returned if the component's EEPROM is unreadable, or in the case of an empty slot.")
tmnxHwMfgAssemblyNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 32), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwMfgAssemblyNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxHwMfgAssemblyNumber.setDescription('The value of tmnxHwMfgAssemblyNumber may contain an assembly number which indicates manufacturing differences for a given part number.')
tmnxHwFirmwareCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 33), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwFirmwareCodeVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxHwFirmwareCodeVersion.setDescription('The software product release version number associated with the firmware version currently programmed on this card. If no specific software release is associated with this hardware component then this object will contain a zero length string.')
tmnxHwContainsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 9), )
if mibBuilder.loadTexts: tmnxHwContainsTable.setStatus('current')
if mibBuilder.loadTexts: tmnxHwContainsTable.setDescription('The tmnxHwContainsTable shows the container/containee relationship between entries in the tmnxHwTable. The hardware component containment tree can be constructed from information in the tmnxHwTable, but this table provides the information in a more convenient format for the manager system to use.')
tmnxHwContainsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 9, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxHwIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxHwContainedIndex"))
if mibBuilder.loadTexts: tmnxHwContainsEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxHwContainsEntry.setDescription('Each row entry represents a single container/containee relationship. Entries cannot be created and deleted via SNMP SET operations.')
tmnxHwContainedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 9, 1, 1), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwContainedIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxHwContainedIndex.setDescription('The value of tmnxHwIndex for the contained hardware component.')
tmnxCcmTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10), )
if mibBuilder.loadTexts: tmnxCcmTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTable.setDescription('This table contains information about CCM.')
tmnxCcmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCcmIndex"))
if mibBuilder.loadTexts: tmnxCcmEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmEntry.setDescription('Contains information regarding a CCM.')
tmnxCcmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: tmnxCcmIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmIndex.setDescription('The unique value which identifies a specific CCM instance in the chassis.')
tmnxCcmOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1, 2), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmOperStatus.setDescription('Current status of the CCM.')
tmnxCcmHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1, 3), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmHwIndex.setDescription('The value of tmnxCcmHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this CCM.')
tmnxCcmEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1, 4), TmnxCcmType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmEquippedType.setDescription('A bit-mask that identifies the CCM type that is physically inserted into this chassis. There will not be more than one bit set at a time in tmnxCcmEquippedType.')
tmnxCcmTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11), )
if mibBuilder.loadTexts: tmnxCcmTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeTable.setDescription('The card type table has an entry for each Alcatel-Lucent 7710 series Chassis Control Module (CCM) model.')
tmnxCcmTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxCcmTypeIndex"))
if mibBuilder.loadTexts: tmnxCcmTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeEntry.setDescription('Each row entry represents an Alcatel-Lucent 7710 series CCM model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxCcmTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1, 1), TmnxCcmType())
if mibBuilder.loadTexts: tmnxCcmTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeIndex.setDescription('The unique index value which identifies this type of Alcatel-Lucent 7710 series CCM model.')
tmnxCcmTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeName.setDescription('The administrative name that identifies this type of Alcatel-Lucent 7710 series CCM model. This name string may be used in CLI commands to specify a particular card model type.')
tmnxCcmTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeDescription.setDescription('A detailed description of this Alcatel-Lucent 7710 series CCM model.')
tmnxCcmTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeStatus.setDescription("When tmnxCcmTypeStatus has a value of 'true' it indicates that this CCM is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxFanTrayComponentTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 12), )
if mibBuilder.loadTexts: tmnxFanTrayComponentTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFanTrayComponentTable.setDescription('The Fan Tray Component table has an entry for every sub-component of a Fan Tray that has monitored states. Not all fan trays have monitored sub-components, in this case, this table will be empty for the given fan-tray.')
tmnxFanTrayComponentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 12, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxChassisFanIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFanTrayCompIndex"))
if mibBuilder.loadTexts: tmnxFanTrayComponentEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFanTrayComponentEntry.setDescription('Each row entry represents a fan tray component. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxFanTrayCompIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 12, 1, 1), Unsigned32())
if mibBuilder.loadTexts: tmnxFanTrayCompIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxFanTrayCompIndex.setDescription('The tmnxFanTrayCompIndex specifies an individual fan tray component.')
tmnxFanTrayCompSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 12, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFanTrayCompSpeed.setStatus('current')
if mibBuilder.loadTexts: tmnxFanTrayCompSpeed.setDescription('The tmnxFanTrayCompSpeed indicates the current speed of the fan tray component.')
tmnxHwResourceTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13), )
if mibBuilder.loadTexts: tmnxHwResourceTable.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceTable.setDescription("The tmnxHwResourceTable has an entry for each managed hardware component in the Alcatel-Lucent SROS series system's chassis that supports resource monitoring. Hardware components that do not support resource monitoring will not show up in this table. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.")
tmnxHwResourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxHwIndex"))
if mibBuilder.loadTexts: tmnxHwResourceEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceEntry.setDescription('Each tmnxHwResourceEntry row consists of the current resource levels for a particular managed hardware component.')
tmnxHwResourceCurrentVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceCurrentVoltage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceCurrentVoltage.setDescription('The value of tmnxHwResourceCurrentVoltage indicates the current voltage use of the managed hardware component in 1/10000 of a Volt(V).')
tmnxHwResourcePeakVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourcePeakVoltage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourcePeakVoltage.setDescription('The value of tmnxHwResourcePeakVoltage indicates the peak voltage use of the managed hardware component in 1/10000 of a Volt(V) last recorded at the time indicated by tmnxHwResourcePeakVoltageTime.')
tmnxHwResourcePeakVoltageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourcePeakVoltageTime.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourcePeakVoltageTime.setDescription('The value of tmnxHwResourcePeakVoltageTime indicates the time, since system initialization, that tmnxHwResourcePeakVoltage was last updated.')
tmnxHwResourceMinVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceMinVoltage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceMinVoltage.setDescription('The value of tmnxHwResourceMinVoltage indicates the lowest voltage use of the managed hardware component in 1/10000 of a Volt(V) last recorded at the time indicated by tmnxHwResourceMinVoltageTime.')
tmnxHwResourceMinVoltageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceMinVoltageTime.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceMinVoltageTime.setDescription('The value of tmnxHwResourceMinVoltageTime indicates the time, since system initialization, that tmnxHwResourceMinVoltage was last updated.')
tmnxHwResourceCurrentWattage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceCurrentWattage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceCurrentWattage.setDescription('The value of tmnxHwResourceCurrentWattage indicates the current power use of the managed hardware component in 1/10th of a micro-Watt (uW).')
tmnxHwResourcePeakWattage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourcePeakWattage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourcePeakWattage.setDescription('The value of tmnxHwResourcePeakWattage indicates the peak power use of the managed hardware component in 1/10th of a micro-Watt (uW) last recorded at the time indicated by tmnxHwResourcePeakWattageTime.')
tmnxHwResourcePeakWattageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourcePeakWattageTime.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourcePeakWattageTime.setDescription('The value of tmnxHwResourcePeakWattageTime indicates the time, since system initialization, that tmnxHwResourcePeakWattage was last updated.')
tmnxHwResourceMinWattage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceMinWattage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceMinWattage.setDescription('The value of tmnxHwResourceMinWattage indicates the lowest power use of the managed hardware component in 1/10th of a micro-Watt (uW) last recorded at the time indicated by tmnxHwResourceMinWattageTime.')
tmnxHwResourceMinWattageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceMinWattageTime.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceMinWattageTime.setDescription('The value of tmnxHwResourceMinWattageTime indicates the time, since system initialization, that tmnxHwResourceMinWattage was last updated.')
tmnxHwResourceCurrentAmperage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceCurrentAmperage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceCurrentAmperage.setDescription('The value of tmnxHwResourceCurrentAmperage indicates the current drawn by the managed hardware component in micro-Amperes (uA).')
tmnxHwResourcePeakAmperage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourcePeakAmperage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourcePeakAmperage.setDescription('The value of tmnxHwResourcePeakAmperage indicates the peak current drawn by the managed hardware component in micro-Amperes (uA) last recorded at the time indicated by tmnxHwResourcePeakAmperageTime.')
tmnxHwResourcePeakAmperageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 13), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourcePeakAmperageTime.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourcePeakAmperageTime.setDescription('The value of tmnxHwResourcePeakAmperageTime indicates the time, since system initialization, that tmnxHwResourcePeakAmperage was last updated.')
tmnxHwResourceMinAmperage = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceMinAmperage.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceMinAmperage.setDescription('The value of tmnxHwResourceMinAmperage indicates the lowest current drawn by the managed hardware component in micro-Amperes (uA) last recorded at the time indicated by tmnxHwResourceMinAmperageTime.')
tmnxHwResourceMinAmperageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 13, 1, 15), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwResourceMinAmperageTime.setStatus('current')
if mibBuilder.loadTexts: tmnxHwResourceMinAmperageTime.setDescription('The value of tmnxHwResourceMinAmperageTime indicates the time, since system initialization, that tmnxHwResourceMinAmperage was last updated.')
tmnxCardLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxCardLastChange.setDescription('The value of sysUpTime when the tmnxCardTable was last changed.')
tmnxCardTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2), )
if mibBuilder.loadTexts: tmnxCardTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTable.setDescription('The tmnxCardTable has an entry for each IOM card slot in each chassis in the TMNX system.')
tmnxCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"))
if mibBuilder.loadTexts: tmnxCardEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCardEntry.setDescription('Each row entry represents an IOM card slot in a chassis in the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxChassisEntry is created, a tmnxCardEntry is created for each IOM card slot in that chassis. Before a tmnxChassisEntry can be deleted, each tmnxCardEntry for that chassis must be in the proper state for removal.')
tmnxCardSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 1), TmnxSlotNum())
if mibBuilder.loadTexts: tmnxCardSlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSlotNum.setDescription('The unique value which identifies this IOM slot within a chassis in the system.')
tmnxCardSupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 2), TmnxCardSuppType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardSupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSupportedTypes.setDescription('A bit-mask that specifies what card types can be physically supported in this IOM slot in this chassis.')
tmnxCardAllowedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 3), TmnxCardType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardAllowedTypes.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxCardAllowedTypes.setDescription('A bit-mask that specifies what IOM card types the administrator has designated be allowed to be inserted into this slot. If the slot has not-been pre-provisioned and a card that does not match one of the allowed types is inserted into this slot, a mis-match alarm will be raised. If a specific value has not yet been SET by the manager, tmnxCardAllowedTypes will return the same value to a GET request as tmnxCardSupportedTypes. The object was made obsolete in the 3.0 release.')
tmnxCardAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 4), TmnxCardType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCardAssignedType.setDescription('The tmnxCardAssignedType specifies the administratively assigned (pre-provisioned) IOM card type defined in the tmnxCardTypeTable that should occupy this slot in this chassis. If tmnxCardAssignedType has a value of 1 (unassigned), this slot has not yet been pre-provisioned.')
tmnxCardEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 5), TmnxCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCardEquippedType.setDescription('The tmnxCardEquippedType indicates the IOM card type that is physically inserted into this slot in this chassis. If the slot has been pre-provisioned, tmnxCardAssignedType is not equal to 1 (unassigned), and the value of tmnxCardEquippedType is not the same as tmnxCardAssignedType, a mis-match alarm will be raised. A value of 0 indicates the IOM card type is not recognized by the software.')
tmnxCardHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 6), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCardHwIndex.setDescription('The value of tmnxCardHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this IOM card.')
tmnxCardClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 10), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardClockSource.setStatus('current')
if mibBuilder.loadTexts: tmnxCardClockSource.setDescription('The clock source used by the IOM card in this slot.')
tmnxCardNumMdaSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardNumMdaSlots.setStatus('current')
if mibBuilder.loadTexts: tmnxCardNumMdaSlots.setDescription('The number of Media Dependent Adapter (MDA) slots available on this IOM card.')
tmnxCardNumMdas = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardNumMdas.setStatus('current')
if mibBuilder.loadTexts: tmnxCardNumMdas.setDescription('The number of Media Dependent Adapters installed on this IOM card.')
tmnxCardReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 13), TmnxCardRebootType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxCardReboot.setDescription("Setting this variable to 'cardReboot' causes the IOM card to execute a soft-reboot. Setting this variable to 'cardPowerCycle' causes the IOM to turn off and turn on power to the card initiating a hard-reboot.")
tmnxCardMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 14), Unsigned32()).setUnits('Mega-bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardMemorySize.setStatus('current')
if mibBuilder.loadTexts: tmnxCardMemorySize.setDescription('The value of tmnxCardMemorySize indicates the amount of memory, in mega-bytes, populated on this IOM card.')
tmnxCardNamedPoolAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 15), TmnxAdminState().clone('outOfService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardNamedPoolAdminMode.setStatus('current')
if mibBuilder.loadTexts: tmnxCardNamedPoolAdminMode.setDescription("The value of tmnxCardNamedPoolAdminMode indicates whether or not an IOM is provisioned for the configuration of named pools. If the value of tmnxCardNamedPoolAdminMode is 'inService(2)', the system will change the way default pools are created and allow for the creation of MDA and port level named buffer pools. If the value of tmnxCardNamedPoolAdminMode is 'outOfService(3)', the system will not create per port pools, instead a default network and access pool is created for ingress and egress and is shared by queues on all ports. This object is used in conjunction with tmnxCardNamedPoolOperMode.")
tmnxCardNamedPoolOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 16), TmnxAdminState().clone('outOfService')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardNamedPoolOperMode.setStatus('current')
if mibBuilder.loadTexts: tmnxCardNamedPoolOperMode.setDescription("The value of tmnxCardNamedPoolOperMode indicates whether or not an IOM provisioned with tmnxCardNamedPoolAdminMode to a value of 'inService(2)' will activly use named pools or not. A value of 'outOfService(3) means that the named pool configurations will not be downloaded to the IOM until after a reset of the IOM is performed. A value of 'inService(2)' means that the named pool configurations are programmed by the IOM. On systems using a separate CPM and IOM combination the value of tmnxCardNamedPoolOperMode and tmnxCardNamedPoolAdminMode will always be in sync due to a mandatory reboot of the IOM. On systems using a combined image (CFM) these values will be out-of-sync until the chassis is rebooted.")
tmnxCardSoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 17), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardSoftReset.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSoftReset.setDescription("The value of tmnxCardSoftReset, when set to 'doAction(1)', causes the IOM card to re-initialize the applications and protocols running on the card with limited traffic impact.")
tmnxCardLastBootupReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("hardReboot", 0), ("softReset", 1), ("powerCycle", 2), ("clearCard", 3), ("activitySwitch", 4), ("configChange", 5), ("runtimeFail", 6), ("bootFail", 7), ("unexpected", 8), ("issuTimeout", 9), ("reinserted", 10), ("issuHardReboot", 11), ("ccmFail", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardLastBootupReason.setStatus('current')
if mibBuilder.loadTexts: tmnxCardLastBootupReason.setDescription('The value of tmnxCardLastBootupReason indicates the type of the last reboot/reset of the IOM card. Not all reasons exist in all software versions. hardReboot - new/different card inserted for first time softReset - user initiated soft reset powerCycle - user initiated power cycle clearCard - user initiated clear card activitySwitch - card rebooted during activity switch configChange - configuration change forced a reboot runtimeFail - card failed while running and was rebooted bootFail - card failed during boot and was rebooted unexpected - card unexpectedly rebooted issuTimeout - ISSU timeout timer expired reinserted - card was removed and reinserted issuHardReboot - card rebooted during ISSU upgrade (soft reset ineligible) ccmFail - Chassis Control Module (CCM) failed. ')
tmnxCardCmplx1IngrFcsOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1IngrFcsOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1IngrFcsOccur.setDescription('The value of tmnxCardCmplx1IngrFcsOccur indicates the number of times the first complex experienced an occurrence of a FCS error in the ingress direction since startup, last clear, or IOM reboot.')
tmnxCardCmplx1IngrFcsOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1IngrFcsOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1IngrFcsOccurTime.setDescription('The value of tmnxCardCmplx1IngrFcsOccurTime indicates the last time tmnxCardCmplx1IngrFcsOccur incremented.')
tmnxCardCmplx1EgrFcsOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1EgrFcsOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1EgrFcsOccur.setDescription('The value of tmnxCardCmplx1EgrFcsOccur indicates the number of times the first complex experienced an occurrence of a FCS error in the egress direction since startup, last clear, or IOM reboot.')
tmnxCardCmplx1EgrFcsOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 22), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1EgrFcsOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1EgrFcsOccurTime.setDescription('The value of tmnxCardCmplx1EgrFcsOccurTime indicates the last time tmnxCardCmplx1EgrFcsOccur incremented.')
tmnxCardCmplx2IngrFcsOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2IngrFcsOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2IngrFcsOccur.setDescription('The value of tmnxCardCmplx2IngrFcsOccur indicates the number of times the second complex experienced an occurrence of a FCS error in the ingress direction since startup, last clear, or IOM reboot.')
tmnxCardCmplx2IngrFcsOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 24), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2IngrFcsOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2IngrFcsOccurTime.setDescription('The value of tmnxCardCmplx2IngrFcsOccurTime indicates the last time tmnxCardCmplx2IngrFcsOccur incremented.')
tmnxCardCmplx2EgrFcsOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2EgrFcsOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2EgrFcsOccur.setDescription('The value of tmnxCardCmplx2EgrFcsOccur indicates the number of times the second complex experienced an occurrence of a FCS error in the egress direction since startup, last clear, or IOM reboot.')
tmnxCardCmplx2EgrFcsOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 26), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2EgrFcsOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2EgrFcsOccurTime.setDescription('The value of tmnxCardCmplx2EgrFcsOccurTime indicates the last time tmnxCardCmplx2EgrFcsOccur incremented.')
tmnxCardCmplx1MemParityOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1MemParityOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1MemParityOccur.setDescription('The value of tmnxCardCmplx1MemParityOccur indicates the number of times the first complex experienced an occurrence of a memory parity error since startup, last clear, or IOM reboot.')
tmnxCardCmplx1MemParityOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 28), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1MemParityOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1MemParityOccurTime.setDescription('The value of tmnxCardCmplx1MemParityOccurTime indicates the last time tmnxCardCmplx1MemParityOccur incremented.')
tmnxCardCmplx2MemParityOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2MemParityOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2MemParityOccur.setDescription('The value of tmnxCardCmplx2MemParityOccur indicates the number of times the second complex experienced an occurrence of a memory parity error since startup, last clear, or IOM reboot.')
tmnxCardCmplx2MemParityOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 30), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2MemParityOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2MemParityOccurTime.setDescription('The value of tmnxCardCmplx2MemParityOccurTime indicates the last time tmnxCardCmplx2MemParityOccur incremented.')
tmnxCardCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 31), Bits().clone(namedValues=NamedValues(("sr", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardCapability.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCapability.setDescription("The value of tmnxCardCapability indicates special capabilities that are set on this card. tmnxCardCapability is a bitmap whith the following values: 'sr': Enable SR capabilities on this card. ")
tmnxCardCmplx1CAMErrorOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1CAMErrorOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1CAMErrorOccur.setDescription('The value of tmnxCardCmplx1CAMErrorOccur indicates the number of times the first complex experienced an occurrence of a CAM error since startup, last clear, or IOM reboot.')
tmnxCardCmplx1CAMErrorOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 33), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1CAMErrorOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1CAMErrorOccurTime.setDescription('The value of tmnxCardCmplx1CAMErrorOccurTime indicates the last time tmnxCardCmplx1CAMErrorOccur incremented.')
tmnxCardCmplx2CAMErrorOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2CAMErrorOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2CAMErrorOccur.setDescription('The value of tmnxCardCmplx2CAMErrorOccur indicates the number of times the second complex experienced an occurrence of a CAM error since startup, last clear, or IOM reboot.')
tmnxCardCmplx2CAMErrorOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 35), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2CAMErrorOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2CAMErrorOccurTime.setDescription('The value of tmnxCardCmplx2CAMErrorOccurTime indicates the last time tmnxCardCmplx2CAMErrorOccur incremented.')
tmnxCardFailOnError = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 36), Bits().clone(namedValues=NamedValues(("memoryEventGroupA", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardFailOnError.setStatus('current')
if mibBuilder.loadTexts: tmnxCardFailOnError.setDescription('The value of tmnxCardFailOnError specifies the set of events that, if triggered, will cause the card to fail. The suppression or generation of the NOTIFICATION-TYPE event is independent of the card failing. The following set of events are configurable: memoryEventGroupA (0) - tmnxEqCardPChipMemoryEvent, tmnxEqCardPChipCamEvent, tmnxEqCardPChipError. tmnxEqCardPChipError will only cause a card failure if all MDAs(s) on the complex are Ethernet or ISAs.')
tmnxCardCmplx1EgrFcsSrcSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 37), TmnxCardSlotBitMap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx1EgrFcsSrcSlots.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx1EgrFcsSrcSlots.setDescription('The value of tmnxCardCmplx1EgrFcsSrcSlots indicates the source slots reported from the last time tmnxCardCmplx1EgrFcsOccur incremented.')
tmnxCardCmplx2EgrFcsSrcSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 38), TmnxCardSlotBitMap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardCmplx2EgrFcsSrcSlots.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCmplx2EgrFcsSrcSlots.setDescription('The value of tmnxCardCmplx2EgrFcsSrcSlots indicates the source slots reported from the last time tmnxCardCmplx2EgrFcsOccur incremented.')
tmnxCardHardResetUnsupMdas = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 39), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardHardResetUnsupMdas.setStatus('current')
if mibBuilder.loadTexts: tmnxCardHardResetUnsupMdas.setDescription("The value of tmnxCardHardResetUnsupMdas specifies whether to do hard reset of the soft reset incapable MDAs as part setting 'doAction' to tmnxCardSoftReset object.")
tmnxCpmCardLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardLastChange.setDescription('The value of sysUpTime when the tmnxCpmCardTable was last changed.')
tmnxCpmCardTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4), )
if mibBuilder.loadTexts: tmnxCpmCardTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardTable.setDescription('The tmnxCpmCardTable has an entry for each CPM card or module in each chassis in the TMNX system.')
tmnxCpmCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCpmCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCpmCardNum"))
if mibBuilder.loadTexts: tmnxCpmCardEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardEntry.setDescription('Each row entry represents a CPM card or module in a chassis in the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxChassisEntry is created, a tmnxCpmCardEntry is created for each CPM card or module in that chassis. Before a tmnxChassisEntry can be deleted, each tmnxCpmCardEntry for that chassis must be in the proper state for removal.')
tmnxCpmCardSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 1), TmnxSlotNum())
if mibBuilder.loadTexts: tmnxCpmCardSlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardSlotNum.setDescription('The unique value which identifies this slot within a chassis in the system. Depending upon the value of tmnxChassisType, this may represent a fabric slot or a regular card slot. If this CPM module resides on a fabric card, tmnxCpmCardSlotNum has the value the corresponding tmnxFabricSlotNum. If this is a CPM module on a fabric card, tmnxCpmCardSlotNum is the fabric slot number in the chassis where this CPM module is located. Else if this is a CPM card, tmnxCpmCardSlotNum is a regular card slot number.')
tmnxCpmCardNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 2), Unsigned32())
if mibBuilder.loadTexts: tmnxCpmCardNum.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardNum.setDescription('The unique value which identifies this CPM module within a specific card slot within a chassis in the system.')
tmnxCpmCardSupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 3), TmnxCardSuppType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardSupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardSupportedTypes.setDescription('A bit-mask that specifies what CPM card types can be physically supported in this slot in this chassis.')
tmnxCpmCardAllowedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 4), TmnxCardType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardAllowedTypes.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxCpmCardAllowedTypes.setDescription('A bit-mask that specifies what CPM card types the administrator has designated be allowed to be inserted into this slot. If the slot has not-been pre-provisioned and a card that does not match one of the allowed types is inserted into this slot, a mis-match alarm will be raised. If a specific value has not yet been SET by the manager, tmnxCpmCardAllowedTypes will return the same value to a GET request as tmnxCpmCardSupportedTypes. The object was made obsolete in the 3.0 release.')
tmnxCpmCardAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 5), TmnxCardType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardAssignedType.setDescription('The tmnxCpmCardAssignedType specifies the administratively assigned (pre-provisioned) CPM card type defined in tmnxCardTypeTable that should occupy this slot in this chassis. If tmnxCpmCardAssignedType has a value of 1 (unassigned), this slot has not yet been pre-provisioned.')
tmnxCpmCardEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 6), TmnxCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardEquippedType.setDescription('The tmnxCpmCardEquippedType indicates the CPM card type that is physically inserted into this slot in this chassis. If the slot has been pre-provisioned, tmnxCpmCardAssignedType is not equal to 1 (unassigned), and the value of tmnxCpmCardEquippedType is not the same as tmnxCpmCardAssignedType, a mis-match alarm will be raised.')
tmnxCpmCardHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 7), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardHwIndex.setDescription('The value of tmnxCpmCardHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this CPM card or module.')
tmnxCpmCardBootOptionVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 8), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardBootOptionVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardBootOptionVersion.setDescription('The version number of boot option file (BOF) read by the CPM card in this slot.')
tmnxCpmCardBootOptionLastModified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardBootOptionLastModified.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardBootOptionLastModified.setDescription('The date and time the boot options file (BOF) for this card was last modified. If tmnxCpmCardBootOptionLastModified is more recent than tmnxHwSwLastBoot, the boot options file has been edited since the software was booted and different software images or configuration will likely be used when this card is next rebooted.')
tmnxCpmCardConfigBootedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 10), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigBootedVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigBootedVersion.setDescription('The version of the configuration file read when this CPM card was last rebooted.')
tmnxCpmCardIndexBootedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 11), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardIndexBootedVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardIndexBootedVersion.setDescription('The version of the index file read when this CPM card was last rebooted.')
tmnxCpmCardConfigLastModified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 12), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigLastModified.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigLastModified.setDescription('The date and time the running configuration was last modified. If tmnxCpmCardConfigLastModified is more recent than tmnxHwSwLastBoot, the current configuration may be different than that in the configuration file read upon system initialization.')
tmnxCpmCardConfigLastSaved = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 13), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigLastSaved.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigLastSaved.setDescription('The date and time the current configuration was last saved. If tmnxCpmCardConfigLastSaved is more recent the value of tmnxHwSwLastBoot, the initial configuration is likely to be different the next time the system is rebooted.')
tmnxCpmCardRedundant = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("singleton", 1), ("redundantActive", 2), ("redundantStandby", 3), ("redundantSplit", 4), ("redundantDisabled", 5), ("redundantSyncing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardRedundant.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardRedundant.setDescription("This variable indicates if the CPM card is standalone or part of a pair of redundant cards. If 'redundantDisabled', tmnxHwOperState indicates the specific reason why this redundant CPM card is not available. Note that the 'redudantSplit' option is not implemented.")
tmnxCpmCardClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 15), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardClockSource.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardClockSource.setDescription('The clock source used by the CPM card in this slot.')
tmnxCpmCardNumCpus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardNumCpus.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardNumCpus.setDescription('The value of tmnxCpmCardNumCpus indicates the number of CPU chips populated on this CPM module.')
tmnxCpmCardCpuType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("mips", 2), ("pentium-pc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardCpuType.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardCpuType.setDescription('The value of tmnxCpmCardCpuType indicates the type of CPU chips populated on this CPM module.')
tmnxCpmCardMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 18), Unsigned32()).setUnits('Mega-bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardMemorySize.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardMemorySize.setDescription('The value of tmnxCpmCardMemorySize indicates the amount of memory, in mega-bytes, populated on this CPM module.')
tmnxCpmCardSwitchToRedundantCard = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 19), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardSwitchToRedundantCard.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardSwitchToRedundantCard.setDescription('Setting this variable to doAction causes the switchover to the redundant CPM card.')
tmnxCpmCardReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 20), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardReboot.setDescription("Setting this variable to 'doAction' causes the CPM card to execute a soft-reboot.")
tmnxCpmCardRereadBootOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 21), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardRereadBootOptions.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardRereadBootOptions.setDescription("Setting this variable to 'doAction' causes the Boot Options File (BOF) to be reread and applied.")
tmnxCpmCardConfigFileLastBooted = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 22), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastBooted.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastBooted.setDescription('tmnxCpmCardConfigFileLastBooted indicates the location and name of the configuration file from which the system last rebooted.')
tmnxCpmCardConfigFileLastSaved = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 23), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastSaved.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastSaved.setDescription('tmnxCpmCardConfigFileLastSaved indicates the location and name of the file to which the configuration was last saved.')
tmnxCpmCardConfigFileLastBootedHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastBootedHeader.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastBootedHeader.setDescription('tmnxCpmCardConfigFileLastBootedHeader contains the header of the configuration file from which the system last rebooted.')
tmnxCpmCardIndexFileLastBootedHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardIndexFileLastBootedHeader.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardIndexFileLastBootedHeader.setDescription('tmnxCpmCardIndexFileLastBootedHeader contains the header of the index file from which the system last rebooted.')
tmnxCpmCardBootOptionSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 26), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardBootOptionSource.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardBootOptionSource.setDescription("tmnxCpmCardBootOptionSource indicates the compact flash slot where the Boot Options File (BOF) file was found when the system last rebooted. For example, if the BOF file was found on compact flash slot 1, the value of this variable will be 'cf1:'")
tmnxCpmCardConfigSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("primary", 1), ("secondary", 2), ("tertiary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigSource.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigSource.setDescription('The value of tmnxCpmCardConfigSource indicates the location in the Boot Options File(BOF) where the configuration file was found when the system last rebooted.')
tmnxCpmCardBootOptionLastSaved = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 28), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardBootOptionLastSaved.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardBootOptionLastSaved.setDescription('The date and time the boot options file (BOF) was last saved. If tmnxCpmCardBootOptionLastSaved is more recent than the value of tmnxHwSwLastBoot, the boot options file has been edited since the software was booted and different software images or configuration will likely be used when this card is next rebooted.')
tmnxCpmCardMasterSlaveRefState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primaryRef", 1), ("secondaryRef", 2), ("notInitialized", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardMasterSlaveRefState.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardMasterSlaveRefState.setDescription('The current Master/Slave clocking reference designation. primaryRef Indicates this card is designated as the primary clocking reference in a redundant system. secondaryRef Indicates this card is designated as the secondary clocking reference in a redundant system. notInitialized Indicates the clock is not initialized. ')
tmnxCpmCardConfigUserLastModified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 31), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigUserLastModified.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigUserLastModified.setDescription("The value of tmnxCpmCardConfigUserLastModified indicates the last user who modified the configuration. If the configuration was last modified by an SNMPv1 or SNMPv2 set operation, the value of this object will indicate the SNMP community string and view name separated by the '/' character. If the configuration was last modified by an SNMPv3 set operation, the value of this object will be the SNMPv3 user and view name separated by the '/' character. If the configuration has not been saved since the last boot, the object will have the value of an empty string.")
tmnxCpmCardCmplxCAMErrOccur = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardCmplxCAMErrOccur.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardCmplxCAMErrOccur.setDescription('The value of tmnxCpmCardCmplxCAMErrOccur indicates the number of times the complex experienced an occurrence of a CAM error since startup, or card reboot.')
tmnxCpmCardCmplxCAMErrOccurTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 33), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardCmplxCAMErrOccurTime.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardCmplxCAMErrOccurTime.setDescription('The value of tmnxCpmCardCmplxCAMErrOccurTime indicates the last time tmnxCpmCardCmplxCAMErrOccur incremented.')
tmnxCpmCardOscillatorType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("tcxo", 2), ("ocxo", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardOscillatorType.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardOscillatorType.setDescription('The value of tmnxCpmCardOscillatorType indicates the type of oscillator present on the card. An Oven-Controlled Crystal Oscillator (OCXO) is required for the card to support IEEE 1588 clock recovery. A Temperature-Compensated Crystal Oscillator (TCXO) is not sufficient. The type of oscillator also affects the holdover performance of the system.')
tmnxFabricLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricLastChange.setDescription('The value of sysUpTime when the tmnxFabricTable was last changed.')
tmnxFabricTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6), )
if mibBuilder.loadTexts: tmnxFabricTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricTable.setDescription('The tmnxFabricTable has an entry for each fabric card slot in each chassis in the TMNX system.')
tmnxFabricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFabricSlotNum"))
if mibBuilder.loadTexts: tmnxFabricEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricEntry.setDescription('Each row entry represents a fabric card slot in a chassis in the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxChassisEntry is created, a tmnxFabricEntry is created for each fabric card slot in that chassis. Before a tmnxChassisEntry can be deleted, each tmnxFabricEntry for that chassis must be in the proper state for removal.')
tmnxFabricSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: tmnxFabricSlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricSlotNum.setDescription('The unique value which identifies this fabric slot within a chassis in the system. The CPM cards and IOM cards cannot be physically inserted into the switch fabric card slots. In some models, the CPM is not a separate card, but rather a module on a Fabric card.')
tmnxFabricAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 2), TmnxFabricType().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFabricAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricAssignedType.setDescription('The administratively assigned switch fabric card type that should occupy this fabric slot in this chassis.')
tmnxFabricEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 3), TmnxFabricType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricEquippedType.setDescription('The switch fabric card type that is physically inserted into this slot in this chassis.')
tmnxFabricHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 4), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricHwIndex.setDescription('The value of tmnxHwIndex is the index into the tmnxHwTable to locate the row entry that represents the hardware component information for this fabric card.')
tmnxFabricSupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 5), TmnxFabricSuppType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricSupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricSupportedTypes.setDescription('A bit-mask that specifies what fabric card types can be configured in this slot in this chassis.')
tmnxFabricReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 6), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFabricReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricReboot.setDescription("Setting this variable to 'doAction' causes the fabric to execute a soft-reboot.")
tmnxCpmFlashTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7), )
if mibBuilder.loadTexts: tmnxCpmFlashTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashTable.setDescription('This table contains information about Flash devices on a CPM card.')
tmnxCpmFlashEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCpmFlashId"))
if mibBuilder.loadTexts: tmnxCpmFlashEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashEntry.setDescription("Contains information regarding a CPM card's flash unit.")
tmnxCpmFlashId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: tmnxCpmFlashId.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashId.setDescription('The unique identifier index for a flash device on a CPM card.')
tmnxCpmFlashOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 2), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashOperStatus.setDescription('Current status of this flash unit on this CPM card.')
tmnxCpmFlashSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashSerialNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashSerialNumber.setDescription('The serial number for this flash unit on this CPM card.')
tmnxCpmFlashFirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 4), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashFirmwareRevision.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashFirmwareRevision.setDescription('The firmware revision number for this flash unit on this CPM card.')
tmnxCpmFlashModelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 5), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashModelNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashModelNumber.setDescription('The model number for this flash unit on this CPM card.')
tmnxCpmFlashCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 6), Unsigned32()).setUnits('sectors').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashCapacity.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashCapacity.setDescription('The value of tmnxCpmFlashCapacity indicates the maximum size of this flash unit in 512-byte sectors.')
tmnxCpmFlashUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 7), Unsigned32()).setUnits('sectors').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashUsed.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashUsed.setDescription("The value of tmnxCpmFlashUsed indicates the amount used, in 512-byte sectors, of this flash unit's total capacity.")
tmnxCpmFlashHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 8), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashHwIndex.setDescription('The value of tmnxHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this flash unit.')
tmnxMDATable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8), )
if mibBuilder.loadTexts: tmnxMDATable.setStatus('current')
if mibBuilder.loadTexts: tmnxMDATable.setDescription('The tmnxMDATable has an entry for each MDA slot in each IOM card in this chassis in the TMNX system.')
tmnxMDAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxMDASlotNum"))
if mibBuilder.loadTexts: tmnxMDAEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEntry.setDescription('Each row entry represents a MDA slot in an IOM card in a chassis in the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxCardEntry has tmnxCardAssignedType or tmnxCardEquippedType equal to an IOM card type that supports MDA slots, a tmnxMDAEntry is created by the agent for each MDA slot on that IOM card. Before a tmnxCardEntry can be deleted, each tmnxMDAEntry for that card must be in the proper state for removal.')
tmnxMDASlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16)))
if mibBuilder.loadTexts: tmnxMDASlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxMDASlotNum.setDescription('The unique value which identifies this MDA slot within a specific IOM card in the system. Rows with a tmnxMDASlotNum value of zero (0) represent the special case of an IOM card without MDA slots but that instead has its ports directly on the IOM card itself. In that case, there should be only that one row entry in the tmnxMDATable for that IOM card.')
tmnxMDASupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 2), TmnxMDASuppType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDASupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxMDASupportedTypes.setDescription('A bit-mask that specifies what MDA card types can be configured in this slot in this chassis.')
tmnxMDAAllowedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 3), TmnxMdaType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAAllowedTypes.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMDAAllowedTypes.setDescription('An integer that specified what MDA card types the administrator has designated be allowed to be inserted into this slot. If the slot has not-been pre-provisioned and a MDA card that does not match one of the allowed types is inserted into this slot, a mis-match alarm will be raised. The object was made obsolete in the 3.0 release.')
tmnxMDAAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 4), TmnxMdaType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAAssignedType.setDescription("An integer that indicates the administratively assigned (pre-provisioned) MDA card type that should occupy this slot in this chassis. If tmnxMDAAssignedType has a value of 'unassigned', this slot has not yet been pre-provisioned.")
tmnxMDAEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 5), TmnxMdaType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEquippedType.setDescription("An integer that indicates the MDA card type that is physically inserted into this slot in this chassis. If the slot has been pre-provisioned, tmnxMDAAssignedType is not equal 'unassigned', and the value of tmnxMDAEquippedType is not the same as tmnxMDAAssignedType, a mis-match alarm will be raised. A value of 0 indicates the equipped MDA is not supported by this software release.")
tmnxMDAHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 6), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHwIndex.setDescription('The value of tmnxHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this MDA card.')
tmnxMDAMaxPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMaxPorts.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMaxPorts.setDescription('The maximum number of ports that can be equipped on this MDA card.')
tmnxMDAEquippedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAEquippedPorts.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEquippedPorts.setDescription('The value of tmnxMDAEquippedPorts indicates the number of ports equipped on this MDA card.')
tmnxMDATxTimingSelected = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("cpm-card-A", 1), ("cpm-card-B", 2), ("local", 3), ("holdover", 4), ("not-applicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDATxTimingSelected.setStatus('current')
if mibBuilder.loadTexts: tmnxMDATxTimingSelected.setDescription("The transmit timing method which is presently selected and being used by this MDA. tmnxMDATxTimingSelected will be set to 'not-applicable' if this MDA does not use the transmit timing subsystem.")
tmnxMDASyncIfTimingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("qualified", 1), ("not-qualified", 2), ("not-applicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDASyncIfTimingStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxMDASyncIfTimingStatus.setDescription("Indicates the status of the synchronous equipment timing subsystem. If the tmnxSyncIfTimingRef1Qualified and tmnxSyncIfTimingRef2Qualified are both set to 'not-qualified, then tmnxMDASyncIfTimingStatus is set to 'not-qualified'. If any of the timing references is in use, then tmnxMDASyncIfTimingStatus is set to 'qualified'. tmnxMDASyncIfTimingStatus will be set to 'not-applicable' if this MDA does not use the transmit timing subsystem.")
tmnxMDANetworkIngQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 12), TNamedItem().clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDANetworkIngQueues.setStatus('current')
if mibBuilder.loadTexts: tmnxMDANetworkIngQueues.setDescription('Specifies the network queue policy being used for this object to define the queueing structure for this object.')
tmnxMDACapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 13), Bits().clone(namedValues=NamedValues(("isEthernet", 0), ("isSonet", 1), ("isTDM", 2), ("supportsPPP", 3), ("supportsFR", 4), ("supportsATM", 5), ("supportscHDLC", 6), ("isCMA", 7), ("supportsCEM", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDACapabilities.setStatus('current')
if mibBuilder.loadTexts: tmnxMDACapabilities.setDescription('tmnxMDACapabilities indicates the capabilities of this MDA. It identifies the type of MDA and the protocols that can run on it.')
tmnxMDAMinChannelization = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 14), TmnxMDAChanType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMinChannelization.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMinChannelization.setDescription('tmnxMDAMinChannelization indicates the minimum size of the channel that can exist on this MDA.')
tmnxMDAMaxChannelization = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 15), TmnxMDAChanType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMaxChannelization.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMaxChannelization.setDescription('tmnxMDAMaxChannelization indicates the maximum size of the channel that can exist on this MDA.')
tmnxMDAMaxChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMaxChannels.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMaxChannels.setDescription('tmnxMDAMaxChannels is applicable for SONET and TDM MDAs only. It indicates the total number of leaf SONET paths, TDM channels and bundles on the MDA that may be configured to pass traffic.')
tmnxMDAChannelsInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAChannelsInUse.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAChannelsInUse.setDescription('tmnxMDAChannelsInUse is applicable for SONET and TDM MDAs only. It indicates the total number of leaf SONET paths, TDM channels and bundles on the MDA which are in use. A leaf SONET path or TDM channel which is currently capable of passing traffic is considered to be in use. Also, a SONET path or TDM channel which is channelized and has no subchannels capable of passing traffic is considered to be in use. A SONET path or TDM channel which is channelized and has one or more subchannels capable of passing traffic is not considered to be in use, although the subchannels themselves are considered to be in use. A bundle is considered to be a channel in use as are each of its members since they are TDM channels capable of passing traffic.')
tmnxMDACcagId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 18), TmnxCcagId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDACcagId.setStatus('current')
if mibBuilder.loadTexts: tmnxMDACcagId.setDescription("When tmnxMDAAssignedType has a value of 'cca' , the value of tmnxMDACcagId specifies the Cross Connect Aggregation Group (CCAG) entry this MDA is provisioned on. If this entry does not represent a 'cca' MDA or is not associated with a CCAG, tmnxMDACcagId has a value of zero. ")
tmnxMDAReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 19), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAReboot.setDescription("Setting this variable to 'doAction' causes the MDA to execute a soft-reboot.")
tmnxMDAHiBwMcastSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 20), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAHiBwMcastSource.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHiBwMcastSource.setDescription("The value of tmnxMDAHiBwMcastSource specifies if this MDA should attempt to allocate separate fabric planes to allocate high bandwidth multicast traffic taps. tmnxMDAHiBwMcastGroup must be set in the same SNMP request PDU with tmnxMDAHiBwMcastSource or an 'inconsistentValue' error will be returned.")
tmnxMDAHiBwMcastAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 21), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAHiBwMcastAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHiBwMcastAlarm.setDescription('The value of tmnxMDAHiBwMcastAlarm specifies if a tmnxChassisHiBwMcastAlarm alarm is raised if there are more than one high bandwidth multicast traffic taps sharing a plane.')
tmnxMDAHiBwMcastTapCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAHiBwMcastTapCount.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHiBwMcastTapCount.setDescription('The value of tmnxMDAHiBwMcastTapCount indicates the number of high bandwidth multicast traffic taps on this MDA.')
tmnxMDAHiBwMcastGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAHiBwMcastGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHiBwMcastGroup.setDescription("The value of tmnxMDAHiBwMcastGroup specifies the group of high bandwidth multicast traffic taps to which this tap belongs. A value of '0' specifies that this tap is not a member of any High Bandwidth Multicast group. On an IOM of type 'iom-10g', the value of tmnxMDAHiBwMcastGroup should be the same as the value of tmnxMDAHiBwMcastGroup set on the other MDA residing on the IOM if the tmnxMDAHiBwMcastSource is set to 'true'. Attempt to set to different values will result in an 'inconsistentValue' error. tmnxMDAHiBwMcastGroup must be set in the same SNMP request PDU with tmnxMDAHiBwMcastSource or an 'inconsistentValue' error will be returned.")
tmnxMDAClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("adaptive", 1), ("differential", 2))).clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAClockMode.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAClockMode.setDescription("The value of tmnxMDAClockMode specifies the clock mode of the MDA. notApplicable - The MDA does not support any clock modes or domains. adaptive - The MDA is in 'adaptive' clock mode. This allows adaptive clock domains to be created. differential - The MDA is in 'differential clock mode. This allows differential clock domains to be created. The value of tmnxMDAClockMode can be changed when there are no ports created on the MDA. If there are ports created, a shutdown of the MDA is required in order to change the value.")
tmnxMDADiffTimestampFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 25), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(19440, 19440), ValueRangeConstraint(77760, 77760), ValueRangeConstraint(103680, 103680), ))).setUnits('kilohertz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDADiffTimestampFreq.setStatus('current')
if mibBuilder.loadTexts: tmnxMDADiffTimestampFreq.setDescription("The value of tmnxMDADiffTimestampFreq specifies the differential timestamp frequency of the differential clock on the MDA. The value must be a multiple of 8 KHz. This value can only be changed if the value of tmnxMDAClockMode is 'differential (2)' and there are no ports created on the MDA. If there are ports created, a shutdown of the MDA is required in order to change the value. If the value of tmnxMDAClockMode is 'differential (2) then the default is 103,680 KHz. If the value of tmnxMDAClockMode is not 'differential (2)' then this value is 0 KHz and cannot be changed.")
tmnxMDAIngHsmdaSchedPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 26), TNamedItemOrEmpty()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAIngHsmdaSchedPolicy.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMDAIngHsmdaSchedPolicy.setDescription("The value of tmnxMDAIngHsmdaSchedPolicy specifies the name of High Scale MDA (HSMDA) scheduler policy to use on the ingress of the MDA. An 'inconsistentValue' error is returned if this object is set to a value which does not have a corresponding entry in TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyTable. When the value of tmnxMDAAssignedType specifies a non-HSMDA MDA Type, an 'inconsistentValue' error is returned if this object is set to any non-empty string. This object is obsoleted in 10.0 Release.")
tmnxMDAMcPathMgmtBwPlcyName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 27), TNamedItem().clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtBwPlcyName.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtBwPlcyName.setDescription('The value of tmnxMDAMcPathMgmtBwPlcyName specifies the multicast policy name configured on the MDA.')
tmnxMDAMcPathMgmtPriPathLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 28), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2000), ))).setUnits('mega-bits-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtPriPathLimit.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtPriPathLimit.setDescription('The value of tmnxMDAMcPathMgmtPriPathLimit specifies the primary path limit for the MDA.')
tmnxMDAMcPathMgmtSecPathLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 29), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2000), ))).setUnits('mega-bits-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtSecPathLimit.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtSecPathLimit.setDescription('The value of tmnxMDAMcPathMgmtSecPathLimit specifies the secondary path limit for the MDA.')
tmnxMDAMcPathMgmtAncPathLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 5000), ))).setUnits('mega-bits-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAncPathLimit.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAncPathLimit.setDescription('The value of tmnxMDAMcPathMgmtAncPathLimit specifies the ancillary path limit for the MDA.')
tmnxMDAMcPathMgmtAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 31), TmnxAdminState().clone('outOfService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAdminState.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAdminState.setDescription('The value of tmnxMDAMcPathMgmtAdminState specifies administrative state of this multicast path on the MDA.')
tmnxMDAIngNamedPoolPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 32), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAIngNamedPoolPolicy.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAIngNamedPoolPolicy.setDescription('The value of tmnxMDAIngNamedPoolPolicy specifies a named pool policy associated with an MDA ingress context. The policy governs the way named pools are created at the MDA level.')
tmnxMDAEgrNamedPoolPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 33), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAEgrNamedPoolPolicy.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEgrNamedPoolPolicy.setDescription('The value of tmnxMDAEgrNamedPoolPolicy specifies a named pool policy associated with an MDA egress context. The policy governs the way named pools are created at the MDA level.')
tmnxMDAIngHsmdaPoolPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 34), TNamedItemOrEmpty()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAIngHsmdaPoolPolicy.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMDAIngHsmdaPoolPolicy.setDescription("The value of tmnxMDAIngHsmdaPoolPolicy specifies the name of High Scale MDA (HSMDA) pool policy to use on the ingress of the MDA. An 'inconsistentValue' error is returned if this object is set to a value which does not have a corresponding entry in TIMETRA-QOS-MIB::tHsmdaPoolPolicyTable. When the value of tmnxMDAAssignedType specifies a non-HSMDA MDA Type, an 'inconsistentValue' error is returned if this object is set to any non-empty string. This object is obsoleted in 10.0 Release.")
tmnxMDAEgrHsmdaPoolPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 35), TNamedItemOrEmpty()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAEgrHsmdaPoolPolicy.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEgrHsmdaPoolPolicy.setDescription("The value of tmnxMDAEgrHsmdaPoolPolicy specifies the name of High Scale MDA (HSMDA) pool policy to use on the egress of the MDA. An 'inconsistentValue' error is returned if this object is set to a value which does not have a corresponding entry in TIMETRA-QOS-MIB::tHsmdaPoolPolicyTable. When the value of tmnxMDAAssignedType specifies a non-HSMDA MDA Type, an 'inconsistentValue' error is returned if this object is set to any non-empty string.")
tmnxMDAMcPathMgmtPriInUseBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 36), Gauge32()).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtPriInUseBw.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtPriInUseBw.setDescription('The value of tmnxMDAMcPathMgmtPriInUseBw indicates the in use ingress multicast bandwidth for the primary forwarding path.')
tmnxMDAMcPathMgmtSecInUseBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 37), Gauge32()).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtSecInUseBw.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtSecInUseBw.setDescription('The value of tmnxMDAMcPathMgmtSecInUseBw indicates the in use ingress multicast bandwidth for the secondary forwarding path.')
tmnxMDAMcPathMgmtAncInUseBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 38), Gauge32()).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAncInUseBw.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAncInUseBw.setDescription('The value of tmnxMDAMcPathMgmtAncInUseBw indicates the in use ingress multicast bandwidth for the ancillary forwarding path.')
tmnxMDAMcPathMgmtBlkHoleInUseBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 39), Gauge32()).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtBlkHoleInUseBw.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtBlkHoleInUseBw.setDescription('The value of tmnxMDAMcPathMgmtBlkHoleInUseBw indicates the bandwidth of the ingress multicast traffic that is being black holed on the MDA.')
tmnxMDASynchronousEthernet = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("not-applicable", 0), ("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDASynchronousEthernet.setStatus('current')
if mibBuilder.loadTexts: tmnxMDASynchronousEthernet.setDescription("The value of tmnxMDASynchronousEthernet specifies whether or not the MDA maintains synchronous Ethernet (syncE) communication on all of its ports. not-applicable - The MDA does not support synchronous Ethernet. enabled - The MDA is in synchronous mode. disabled - The MDA is in asynchronous mode (default). On MDAs that do not support synchronous ethernet the only supported value is 'not-applicable (0)'. If tmnxMDASynchronousEthernet is 'enabled (1)' then any port on the MDA can be used as a source port in the tmnxSyncIfTimingTable.")
tmnxMDAXplErrorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 41), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAXplErrorTime.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAXplErrorTime.setDescription('The value of tmnxMDAXplErrorTime indicates the last time when the tmnxEqMdaXplError notification occurred.')
tmnxMDAXplFailedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 42), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAXplFailedCount.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAXplFailedCount.setDescription('The value of tmnxMDAXplFailedCount indicates the number of XPL failures on the MDA since startup.')
tmnxMDAAtmMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 43), TmnxMdaAtmMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAAtmMode.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAAtmMode.setDescription("The value of tmnxMDAAtmMode specifies the maximum number of Virtual Circuits for the MDA. On MDA's that do not support ATM, 'notApplicable' is the only allowed value and this is also the default value. On MDA's that support ATM, the default value is 'max8kVc'.")
tmnxMDAEgrHsmdaThrshLoBrstMult = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 65536), )).clone(-1)).setUnits('bytes per megabit of rate').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAEgrHsmdaThrshLoBrstMult.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEgrHsmdaThrshLoBrstMult.setDescription("The value of tmnxMDAEgrHsmdaThrshLoBrstMult specifies the bytes per megabit/second of rate multiplier for the aggregate rate of the queues pertaining to the low burst threshold in the queue group. When set to the default value '-1', the system will adopt the lowest usable threshold as a default setting per rate.")
tmnxMDAEgrHsmdaThrshHiBrstInc = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 65536), )).clone(-1)).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAEgrHsmdaThrshHiBrstInc.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEgrHsmdaThrshHiBrstInc.setDescription("The value of tmnxMDAEgrHsmdaThrshHiBrstInc specifies the incremental number of bytes above the low burst limit to be used as the high burst threshold for the aggregate rate of the queues pertaining to the high burst threshold in the queue group. When set to the default value '-1', the system will default to a value of '4000' bytes.")
tmnxMDAIsaTunnelGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 46), TmnxTunnelGroupIdOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAIsaTunnelGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAIsaTunnelGroup.setDescription('The value of tmnxMDAIsaTunnelGroup specifies the tunnel-group identifiter associated with this MDA.')
tmnxMDAIsaTunnelGroupInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 47), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAIsaTunnelGroupInUse.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAIsaTunnelGroupInUse.setDescription('The value of tmnxMDAIsaTunnelGroupInUse indicates if this MDA is active in the Integrated Service Adaptor tunnel group indicated by tmnxMDAIsaTunnelGroup.')
tmnxCardTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9), )
if mibBuilder.loadTexts: tmnxCardTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeTable.setDescription('The card type table has an entry for each Alcatel-Lucent SROS series card model.')
tmnxCardTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxCardTypeIndex"))
if mibBuilder.loadTexts: tmnxCardTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeEntry.setDescription('Each row entry represents an Alcatel-Lucent SROS series Card model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxCardTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1, 1), TmnxCardType())
if mibBuilder.loadTexts: tmnxCardTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeIndex.setDescription('The unique index value which identifies this type of Alcatel-Lucent SROS series card model.')
tmnxCardTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeName.setDescription('The administrative name that identifies this type of Alcatel-Lucent SROS series card model. This name string may be used in CLI commands to specify a particular card model type.')
tmnxCardTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeDescription.setDescription('A detailed description of this Alcatel-Lucent SROS series card model.')
tmnxCardTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeStatus.setDescription("When tmnxCardTypeStatus has a value of 'true' it indicates that this card model is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxMdaTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10), )
if mibBuilder.loadTexts: tmnxMdaTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeTable.setDescription('The MDA type table has an entry for each Alcatel-Lucent SROS series MDA card model.')
tmnxMdaTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxMdaTypeIndex"))
if mibBuilder.loadTexts: tmnxMdaTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeEntry.setDescription('Each row entry represents an Alcatel-Lucent SROS series MDA card model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxMdaTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1, 1), TmnxMdaType())
if mibBuilder.loadTexts: tmnxMdaTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeIndex.setDescription('The unique index value which identifies this type of Alcatel-Lucent SROS series MDA card model.')
tmnxMdaTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMdaTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeName.setDescription('The administrative name that identifies this type of Alcatel-Lucent SROS series MDA card model. This name string may be used in CLI commands to specify a particular MDA card model type.')
tmnxMdaTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMdaTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeDescription.setDescription('A detailed description of this Alcatel-Lucent SROS series MDA card model.')
tmnxMdaTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMdaTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeStatus.setDescription("When tmnxMdaTypeStatus has a value of 'true' it indicates that this MDA card model is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxSyncIfTimingTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11), )
if mibBuilder.loadTexts: tmnxSyncIfTimingTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingTable.setDescription('The synchronous interface timing table has an entry for each cpm card in the system.')
tmnxSyncIfTimingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1), )
tmnxCpmCardEntry.registerAugmentions(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingEntry"))
tmnxSyncIfTimingEntry.setIndexNames(*tmnxCpmCardEntry.getIndexNames())
if mibBuilder.loadTexts: tmnxSyncIfTimingEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingEntry.setDescription('A row represents the configuration of synchronous equipment timing subsystem (SETS) of the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxCpmCardEntry is created, a tmnxSyncIfTimingEntry is created. SNMP set operations with tmnxCpmCardSlotNum of the secondary CPM will be denied. If the value of the reference source port is a valid Port ID then the reference is a port. If the value of the source hardware is a valid non-zero HWIndex then the source is the hardware specified by the HWIndex.')
tmnxSyncIfTimingRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRevert.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRevert.setDescription("The value of tmnxSyncIfTimingRevert indicates whether the reference source will revert to a higher priority source that has been re-validated or newly validated. The synchronous interface timing subsystem is by default non-revertive ('false').")
tmnxSyncIfTimingRefOrder1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 2), TmnxSETSRefSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder1.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder1.setDescription("The value of tmnxSyncIfTimingRefOrder1 indicates the most preferred timing reference source. Four different timing input references may be specified in the reference order ('bits', 'reference1', 'reference2', and 'ptp'). The synchronous equipment timing subsystem chooses a reference based on priority.")
tmnxSyncIfTimingRefOrder2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 3), TmnxSETSRefSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder2.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder2.setDescription('The value of tmnxSyncIfTimingRefOrder2 indicates the second most preferred timing reference for the synchronous equipment timing subsystem.')
tmnxSyncIfTimingRef1SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 4), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1SrcPort.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1SrcPort.setDescription("The value of tmnxSyncIfTimingRef1SrcPort indicates the source port of the first timing reference. A value of '1e000000'H indicates that there is no source port for this reference.")
tmnxSyncIfTimingRef1AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 5), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1AdminStatus.setDescription('The value of tmnxSyncIfTimingRef1AdminStatus indicates the administrative status of the first timing reference.')
tmnxSyncIfTimingRef1InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1InUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1InUse.setDescription('The value of tmnxSyncIfTimingRef1InUse indicates whether the first timing reference is presently being used by the synchronous timing subsystem. If it is in use, tmnxSyncIfTimingFreqOffset indicates the frequency offset for this reference.')
tmnxSyncIfTimingRef1Qualified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 7), TmnxSETSRefQualified()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1Qualified.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1Qualified.setDescription("The value of tmnxSyncIfTimingRef1Qualified indicates whether the first timing reference is qualified for use by the synchronous timing subsystem. If tmnxSyncIfTimingRef1Qualified is set to 'not-qualified', then the object tmnxSyncIfTimingRef1Alarm gives the reason for disqualification.")
tmnxSyncIfTimingRef1Alarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 8), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1Alarm.setDescription("The value of tmnxSyncIfTimingRef1Alarm indicates the alarms on the first reference. If any of the bits is set to '1', then the first reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingRef1Qualified is set to 'not-qualified'. los - loss of signal oof - out of frequency range oopir - out of pull in range ")
tmnxSyncIfTimingRef2SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 9), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2SrcPort.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2SrcPort.setDescription("The value of tmnxSyncIfTimingRef2SrcPort indicates the source port of the second timing reference. A value of '1e000000'H indicates that there is no source port for this reference.")
tmnxSyncIfTimingRef2AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 10), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2AdminStatus.setDescription('The value of tmnxSyncIfTimingRef2AdminStatus indicates the administrative status of the second timing reference.')
tmnxSyncIfTimingRef2InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2InUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2InUse.setDescription('The value of tmnxSyncIfTimingRef2InUse indicates whether the second timing reference is presently being used by the synchronous timing subsystem.')
tmnxSyncIfTimingRef2Qualified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 12), TmnxSETSRefQualified()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2Qualified.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2Qualified.setDescription("The value of tmnxSyncIfTimingRef2Qualified indicates whether the second timing reference is qualified for use by the synchronous timing subsystem. If tmnxSyncIfTimingRef2Qualified is 'not-qualified' then the object tmnxSyncIfTimingRef2Alarm gives the reason for disqualification.")
tmnxSyncIfTimingRef2Alarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 13), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2Alarm.setDescription("The value of tmnxSyncIfTimingRef2Alarm indicates the alarms on the second reference. If any of the bits is set to '1', then the second reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingRef2Qualified is set to 'not-qualified'. los - loss of signal oof - out of frequency range oopir - out of pull in range ")
tmnxSyncIfTimingFreqOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 14), Integer32()).setUnits('parts-per-million').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingFreqOffset.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingFreqOffset.setDescription('The value of tmnxSyncIfTimingFreqOffset indicates the frequency offset of the current selected timing reference in parts per million (ppm).')
tmnxSyncIfTimingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("not-present", 1), ("master-freerun", 2), ("master-holdover", 3), ("master-locked", 4), ("slave", 5), ("acquiring", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingStatus.setDescription('The value of tmnxSyncIfTimingStatus indicates the present status of the synchronous timing equipment subsystem (SETS).')
tmnxSyncIfTimingRefOrder3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 16), TmnxSETSRefSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder3.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder3.setDescription('The value of tmnxSyncIfTimingRefOrder3 is the third most preferred timing reference for the synchronous equipment timing subsystem.')
tmnxSyncIfTimingBITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 17), TmnxBITSIfType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSIfType.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSIfType.setDescription('The value of tmnxSyncIfTimingBITSIfType indicates the interface type of the BITS (Building Integrated Timing Supply) timing reference. It also indicates the framing type of the interface.')
tmnxSyncIfTimingBITSAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 18), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSAdminStatus.setDescription('The value of tmnxSyncIfTimingBITSAdminStatus indicates administrative status of the BITS (Building Integrated Timing Supply) input timing reference.')
tmnxSyncIfTimingBITSInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSInUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSInUse.setDescription('The value of tmnxSyncIfTimingBITSInUse indicates whether the BITS timing reference is presently being used by the synchronous timing subsystem. If it is in use, tmnxSyncIfTimingFreqOffset indicates the frequency offset for this reference.')
tmnxSyncIfTimingBITSQualified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 20), TmnxSETSRefQualified()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSQualified.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSQualified.setDescription("The value of tmnxSyncIfTimingBITSQualified indicates whether the BITS timing reference is qualified for use by the synchronous timing subsystem. If tmnxSyncIfTimingBITSQualified is 'not-qualified', then the object tmnxSyncIfTimingBITSAlarm gives the reason for disqualification.")
tmnxSyncIfTimingBITSAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 21), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSAlarm.setDescription("The value of tmnxSyncIfTimingBITSAlarm indicates the alarms on the BITS reference. If any of the bits is set to '1', then the BITS reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingBITSQualified is set to 'not-qualified'.")
tmnxSyncIfTimingRef1SrcHw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 22), TmnxHwIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1SrcHw.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1SrcHw.setDescription('The value of tmnxSyncIfTimingRef1SrcHw indicates the source HW index of the first timing reference if source is not a port.')
tmnxSyncIfTimingRef1BITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 23), TmnxBITSIfType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1BITSIfType.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1BITSIfType.setDescription('The value of tmnxSyncIfTimingRef1BITSIfType indicates the interface type of the first timing reference if the source is BITS. It also indicates the framing type of the interface.')
tmnxSyncIfTimingRef2SrcHw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 24), TmnxHwIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2SrcHw.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2SrcHw.setDescription('The value of tmnxSyncIfTimingRef2SrcHw indicates the source HW index of the second timing reference if source is not a port.')
tmnxSyncIfTimingRef2BITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 25), TmnxBITSIfType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2BITSIfType.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2BITSIfType.setDescription('The value of tmnxSyncIfTimingRef2BITSIfType indicates the interface type of the second timing reference if the source is BITS. It also indicates the framing type of the interface.')
tmnxSyncIfTimingBITSOutAdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 26), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSOutAdmStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSOutAdmStatus.setDescription('The value of tmnxSyncIfTimingBITSOutAdmStatus indicates administrative status of the BITS (Building Integrated Timing Supply) output timing reference.')
tmnxSyncIfTimingBITSOutLineLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lengthNotApplicable", 0), ("length0To110", 1), ("length110To220", 2), ("length220To330", 3), ("length330To440", 4), ("length440To550", 5), ("length550To660", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSOutLineLen.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSOutLineLen.setDescription("tmnxSyncIfTimingBITSOutLineLen indicates the length of the line (in feet) for the BITS (Building Integrated Timing Supply) output. The following values are valid: lengthNotApplicable (0) - When BITS output is not supported length0To110 (1) - For line length from 0 to 110 feet length110To220 (2) - For line length from 110 to 220 feet length220To330 (3) - For line length from 230 to 330 feet length330To440 (4) - For line length from 330 to 440 feet length440To550 (5) - For line length from 440 to 550 feet length550To660 (6) - For line length from 550 to 660 feet The default is 'lengthNotApplicable' on CPM cards which do not support line length. Otherwise, the default is 'length0To110'.")
tmnxSyncIfTimingRef1CfgQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 28), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1CfgQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1CfgQltyLevel.setDescription("The value of tmnxSyncIfTimingRef1CfgQltyLevel indicates the configured Quality Level of Reference 1. A value of 'unknown (0)' indicates Reference 1 is not forced to a specific quality level.")
tmnxSyncIfTimingRef1RxQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 29), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1RxQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1RxQltyLevel.setDescription('The value of tmnxSyncIfTimingRef1RxQltyLevel indicates the received SSM Quality Level of Reference 1.')
tmnxSyncIfTimingRef2CfgQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 30), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2CfgQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2CfgQltyLevel.setDescription("The value of tmnxSyncIfTimingRef2CfgQltyLevel indicates the configured Quality Level of Reference 2. A value of 'unknown (0)' indicates Reference 2 is not forced to a specific quality level.")
tmnxSyncIfTimingRef2RxQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 31), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2RxQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2RxQltyLevel.setDescription('The value of tmnxSyncIfTimingRef2RxQltyLevel indicates the received SSM Quality Level of Reference 2.')
tmnxSyncIfTimingBITSCfgQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 32), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSCfgQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSCfgQltyLevel.setDescription("The value of tmnxSyncIfTimingBITSCfgQltyLevel indicates the configured Quality Level of the BITS interface. A value of 'unknown (0)' indicates the BITS interface is not forced to a specific quality level.")
tmnxSyncIfTimingBITSRxQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 33), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSRxQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSRxQltyLevel.setDescription('The value of tmnxSyncIfTimingBITSRxQltyLevel indicates the received SSM Quality Level of the BITS interface.')
tmnxSyncIfTimingBITS2InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 34), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2InUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2InUse.setDescription('The value of tmnxSyncIfTimingBITS2InUse indicates whether the BITS2 timing reference is presently being used by the synchronous timing subsystem. If it is in use, tmnxSyncIfTimingFreqOffset indicates the frequency offset for this reference.')
tmnxSyncIfTimingBITS2Qualified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 35), TmnxSETSRefQualified()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2Qualified.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2Qualified.setDescription("The value of tmnxSyncIfTimingBITS2Qualified indicates whether the BITS2 timing reference is qualified for use by the synchronous timing subsystem. If tmnxSyncIfTimingBITS2Qualified is 'not-qualified', then the object tmnxSyncIfTimingBITS2Alarm gives the reason for disqualification.")
tmnxSyncIfTimingBITS2Alarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 36), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2Alarm.setDescription("The value of tmnxSyncIfTimingBITS2Alarm indicates the alarms on the BITS2 reference. If any of the bits is set to '1', then the BITS2 reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingBITSQualified is set to 'not-qualified'.")
tmnxSyncIfTimingBITS2RxQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 37), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2RxQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2RxQltyLevel.setDescription('The value of tmnxSyncIfTimingBITS2RxQltyLevel indicates the received SSM Rx Quality Level of the BITS2 interface.')
tmnxSyncIfTimingRef1State = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 38), TmnxRefInState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1State.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1State.setDescription('The value of tmnxSyncIfTimingRef1State indicates the operational state of the Reference 1 Timing.')
tmnxSyncIfTimingRef2State = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 39), TmnxRefInState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2State.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2State.setDescription('The value of tmnxSyncIfTimingRef2State indicates the operational state of the Reference 2 Timing.')
tmnxSyncIfTimingBITSState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 40), TmnxRefInState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSState.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSState.setDescription('The value of tmnxSyncIfTimingBITSState indicates the operational state of the BITS Timing Interface.')
tmnxSyncIfTimingBITS2State = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 41), TmnxRefInState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2State.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2State.setDescription('The value of tmnxSyncIfTimingBITS2State indicates the operational state of the BITS2 Timing Interface.')
tmnxSyncIfTimingRef1NationalUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 42), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 8)).clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1NationalUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1NationalUse.setDescription('The value of tmnxSyncIfTimingRef1NationalUse indicates the national use bit to carry SSM Messages. This applies only to E1 BITS interfaces.')
tmnxSyncIfTimingRef2NationalUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 43), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 8)).clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2NationalUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2NationalUse.setDescription('The value of tmnxSyncIfTimingRef2NationalUse indicates the national use bit to carry SSM Messages. This applies only to E1 BITS interfaces.')
tmnxSyncIfTimingBITSNationalUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 44), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 8)).clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSNationalUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSNationalUse.setDescription('The value of tmnxSyncIfTimingBITSNationalUse indicates the national use bit to carry SSM Messages. This applies only to E1 BITS interfaces.')
tmnxSyncIfTimingQLSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 45), TmnxEnabledDisabled()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingQLSelection.setReference('ITU-T Recommendation G.781, June 1999, Section 5.12')
if mibBuilder.loadTexts: tmnxSyncIfTimingQLSelection.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingQLSelection.setDescription('The value of tmnxSyncIfTimingQLSelection indicates whether or not the timing reference selection process uses the quality level of each timing reference when making the decision on which reference should provide system timing.')
tmnxSyncIfTimingOtherCPMInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 46), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingOtherCPMInUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingOtherCPMInUse.setDescription('The value of tmnxSyncIfTimingOtherCPMInUse indicates whether the timing reference from the other CPM is presently being used by the synchronous timing subsystem on the this CPM.')
tmnxSyncIfTimingOtherCPMQual = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 47), TmnxSETSRefQualified().clone('not-qualified')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingOtherCPMQual.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingOtherCPMQual.setDescription("The value of tmnxSyncIfTimingOtherCPMQual indicates whether the timing reference from the other CPM is qualified for use by the synchronous timing subsystem on the local CPM. If tmnxSyncIfTimingOtherCPMQual is 'not-qualified', then the object tmnxSyncIfTimingOtherCPMAlarm gives the reason for disqualification.")
tmnxSyncIfTimingOtherCPMAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 48), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingOtherCPMAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingOtherCPMAlarm.setDescription("The value of tmnxSyncIfTimingOtherCPMAlarm indicates the alarms on the timing reference from the other CPM. If any of the bits is set to '1', then the reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingOtherCPMQual is set to 'not-qualified'.")
tmnxSyncIfTimingOtherCPMState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 49), TmnxRefInState().clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingOtherCPMState.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingOtherCPMState.setDescription('The value of tmnxSyncIfTimingOtherCPMState indicates the operational state of the timing reference from the other CPM on the local CPM.')
tmnxSyncIfTimingBITSOutRefSel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 50), TmnxSETSRefSource().clone('noReference')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSOutRefSel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSOutRefSel.setDescription('The value of tmnxSyncIfTimingBITSOutRefSel indicates the reference source for BITS output.')
tmnxSyncIfTimingBITSTxQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 51), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSTxQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSTxQltyLevel.setDescription('The value of tmnxSyncIfTimingBITSTxQltyLevel indicates the transmitted SSM Tx Quality Level of the BITS interface.')
tmnxSyncIfTimingBITS2AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 52), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2AdminStatus.setDescription('The value of tmnxSyncIfTimingBITS2AdminStatus indicates administrative status of the BITS2 (Building Integrated Timing Supply) input timing reference.')
tmnxSyncIfTimingSystemQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 53), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingSystemQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingSystemQltyLevel.setDescription('The value of tmnxSyncIfTimingSystemQltyLevel indicates the quality level of the system timing reference. This is normally the quality level of the selected timing reference. If no timing reference has been selected, it indicates the freerun/holdover quality of the system.')
tmnxSyncIfTimingRefOrder4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 54), TmnxSETSRefSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder4.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder4.setDescription('The value of tmnxSyncIfTimingRefOrder4 is the fourth most preferred timing reference for the synchronous equipment timing subsystem.')
tmnxSyncIfTimingPTPAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 55), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPAdminStatus.setDescription('The value of tmnxSyncIfTimingPTPAdminStatus indicates the administrative status of the Precision Timing Protocol (PTP) timing reference.')
tmnxSyncIfTimingPTPInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 56), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPInUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPInUse.setDescription('The value of tmnxSyncIfTimingPTPInUse indicates whether the Precision Timing Protocol (PTP) timing reference is presently being used by the synchronous timing subsystem. If it is in use, tmnxSyncIfTimingFreqOffset indicates the frequency offset for this reference.')
tmnxSyncIfTimingPTPQualified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 57), TmnxSETSRefQualified()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPQualified.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPQualified.setDescription("The value of tmnxSyncIfTimingPTPQualified indicates whether the Precision Timing Protocol (PTP) timing reference is qualified for use by the synchronous timing subsystem. If tmnxSyncIfTimingPTPQualified is set to 'not-qualified', then the object tmnxSyncIfTimingPTPAlarm gives the reason for the disqualification.")
tmnxSyncIfTimingPTPAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 58), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPAlarm.setDescription("The value of tmnxSyncIfTimingPTPAlarm indicates the alarms on the Precision Timing Protocol (PTP) reference. If any of the bits is set to '1', then the PTP reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingPTPQualified is set to 'not-qualified'. los - loss of signal oof - out of frequency range oopir - out of pull in range ")
tmnxSyncIfTimingPTPCfgQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 59), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPCfgQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPCfgQltyLevel.setDescription("The value of tmnxSyncIfTimingPTPCfgQltyLevel indicates the configured Quality Level of Precision Timing Protocol (PTP). A value of 'unknown (0)' indicates PTP is not forced to a specific quality level.")
tmnxSyncIfTimingPTPRxQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 60), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPRxQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPRxQltyLevel.setDescription('The value of tmnxSyncIfTimingPTPRxQltyLevel indicates the received SSM RX Quality Level of the Precision Timing Protocol (PTP).')
tmnxSyncIfTimingPTPState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 61), TmnxRefInState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPState.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingPTPState.setDescription('The value of tmnxSyncIfTimingPTPState indicates the operational state of the Precision Timing Protocol (PTP) Timing.')
tmnxSyncIfTimingBITSOutSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 62), TmnxBITSOutSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSOutSource.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSOutSource.setDescription('The value of tmnxSyncIfTimingBITSOutSource indicates the source of the BITS (Building Integrated Timing Supply) output.')
tmnxSyncIfTimingRefOrder5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 70), TmnxSETSRefSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder5.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder5.setDescription('The value of tmnxSyncIfTimingRefOrder5 is the fifth most preferred timing reference for the synchronous equipment timing subsystem.')
tmnxSyncIfTimingBITS2InAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 71), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2InAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2InAdminStatus.setDescription('The value of tmnxSyncIfTimingBITS2InAdminStatus indicates administrative status of the BITS (Building Integrated Timing Supply) input timing reference.')
tmnxSyncIfTimingBITS2OutAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 72), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2OutAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2OutAdminStatus.setDescription('The value of tmnxSyncIfTimingBITS2OutAdminStatus indicates administrative status of the BITS (Building Integrated Timing Supply) input timing reference.')
tmnxSyncIfTimingBITS2TxQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 73), TmnxSSMQualityLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2TxQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITS2TxQltyLevel.setDescription('The value of tmnxSyncIfTimingBITS2TxQltyLevel indicates the received SSM Rx Quality Level of the BITS2 interface.')
tmnxChassisAdminCtrlObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1))
tmnxChassisAdminValueObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2))
tSyncIfTimingAdmTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1), )
if mibBuilder.loadTexts: tSyncIfTimingAdmTable.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmTable.setDescription('Values for the synchronous interface timing for the chassis.')
tSyncIfTimingAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCpmCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCpmCardNum"))
if mibBuilder.loadTexts: tSyncIfTimingAdmEntry.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmEntry.setDescription('Information about the synchronous interface timing. Entries are created by user. Entries are deleted by user. Note that the first Alcatel-Lucent SROS series product release does not support configuration of synchronous timing equipment on the secondary CPM. All SNMP operations with tmnxCpmCardSlotNum of the secondary CPM will be denied. The 7x50 systems supports 3 timing references (reference1, reference2 and bits). The 7710 system only supports 2 timing references (reference1 and reference2). On 7710 system, references can be a source port or a BITS input on a CES CMA. If the value of the reference source port is a valid Port ID then the reference is a source port. If the value of the source hardware is a valid HWIndex of a CES CMA then the source is a BITS on the CES CMA.')
tSyncIfTimingAdmRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRevert.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRevert.setDescription("The value of tSyncIfTimingAdmRevert specifies whether the reference source will revert to a higher priority source that has been re-validated or newly validated. The synchronous interface timing subsystem is by default non-revertive ('false').")
tSyncIfTimingAdmRefOrder1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 2), TmnxSETSRefSource().clone('bits1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder1.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder1.setDescription("The value of tSyncIfTimingAdmRefOrder1 specifies the most preferred timing reference source. The synchronous equipment timing subsystem chooses a timing reference based on priority. The user can configure the priority order of the following timing reference inputs ('bits', 'reference1', 'reference2', and 'ptp'). If the platform does not support that timing reference input, it cannot be configured in the reference priority order. For example, the 'bits' timing reference cannot be configured on a 7750 SR-c12 system. Other values of TmnxSETSRefSource (e.g. 'bits2') cannot be configured in the reference order.")
tSyncIfTimingAdmRefOrder2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 3), TmnxSETSRefSource().clone('reference1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder2.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder2.setDescription('The value of tSyncIfTimingAdmRefOrder2 specifies the second most preferred timing reference for the synchronous equipment timing subsystem.')
tSyncIfTimingAdmRef1SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 4), TmnxPortID().clone(503316480)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1SrcPort.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1SrcPort.setDescription('The value of tSyncIfTimingAdmRef1SrcPort specifies the source port of the first timing reference. This can only be set to a valid TmnxPortID if the value of tSyncIfTimingAdmRef1SrcHw is 0.')
tSyncIfTimingAdmRef1AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 5), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1AdminStatus.setDescription('The value of tSyncIfTimingAdmRef1AdminStatus specifies the desired administrative status of the first timing reference.')
tSyncIfTimingAdmRef2SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 6), TmnxPortID().clone(503316480)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2SrcPort.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2SrcPort.setDescription('The value of tSyncIfTimingAdmRef2SrcPort specifies the source port of the second timing reference. This can only be set to a valid TmnxPortID if the value of tSyncIfTimingAdmRef2SrcHw is 0.')
tSyncIfTimingAdmRef2AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 7), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2AdminStatus.setDescription('The value of tSyncIfTimingAdmRef2AdminStatus specifies the desired administrative status of the second timing reference.')
tSyncIfTimingAdmChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmChanged.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmChanged.setDescription('The value of tSyncIfTimingAdmChanged is a bitmask that indicates which objects have been set, but not committed. bit values used here are: 0x0001: tSyncIfTimingAdmRevert 0x0002: tSyncIfTimingAdmRefOrder1 0x0004: tSyncIfTimingAdmRefOrder2 0x0008: tSyncIfTimingAdmRef1SrcPort 0x0010: tSyncIfTimingAdmRef1AdminStatus 0x0020: tSyncIfTimingAdmRef2SrcPort 0x0040: tSyncIfTimingAdmRef2AdminStatus 0x0080: tSyncIfTimingAdmRefOrder3 0x0100: tSyncIfTimingAdmBITSIfType 0x0200: tSyncIfTimingAdmBITSAdminStatus 0x0400: tSyncIfTimingAdmRef1SrcHw 0x0800: tSyncIfTimingAdmRef1BITSIfType 0x1000: tSyncIfTimingAdmRef2SrcHw 0x2000: tSyncIfTimingAdmRef2BITSIfType The agent sets these bits when an object in the row is set. This object is cleared to zero by setting tmnxChassisAdminControlApply to initialize(2) or commit(3). ')
tSyncIfTimingAdmRefOrder3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 9), TmnxSETSRefSource().clone('reference2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder3.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder3.setDescription('The value of tSyncIfTimingAdmRefOrder3 indicates the third most preferred timing reference for the synchronous equipment timing subsystem.')
tSyncIfTimingAdmBITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 10), TmnxBITSIfType().clone('t1-esf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSIfType.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSIfType.setDescription('The value of tSyncIfTimingAdmBITSIfType specifies the interface type of the BITS (Building Integrated Timing Supply) timing reference.')
tSyncIfTimingAdmBITSAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 11), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSAdminStatus.setDescription('The value of tSyncIfTimingAdmBITSAdminStatus specifies the desired administrative status of the BITS (Building Integrated Timing Supply) input timing reference.')
tSyncIfTimingAdmRef1SrcHw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 12), TmnxHwIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1SrcHw.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1SrcHw.setDescription("The value of tSyncIfTimingAdmRef1SrcHw specifies the source HW Index of the first timing reference if the source is not a port. This can only be set to a valid HW Index if the value of tSyncIfTimingAdmRef1SrcPort is '1e000000'H. Setting the value of tSyncIfTimingAdmRef1SrcHw from non-zero to zero will cause the value of tSyncIfTimingAdmRef1BITSIfType to be reset to its default value of 't1-esf'.")
tSyncIfTimingAdmRef1BITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 13), TmnxBITSIfType().clone('t1-esf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1BITSIfType.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1BITSIfType.setDescription('The value of tSyncIfTimingAdmRef1BITSIfType specifies the interface type of the first timing reference if the source is BITS. This can only be changed if the value of tSyncIfTimingAdmRef1SrcHw is not 0.')
tSyncIfTimingAdmRef2SrcHw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 14), TmnxHwIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2SrcHw.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2SrcHw.setDescription("The value of tSyncIfTimingAdmRef2SrcHw specifies the source HW Index of the second timing reference if the source is not a port. This can only be set to a valid HW Index if the value of tSyncIfTimingAdmRef2SrcPort is '1e000000'H. Setting the value of tSyncIfTimingAdmRef2SrcHw from non-zero to zero will cause the value of tSyncIfTimingAdmRef2BITSIfType to be reset to its default value of 't1-esf'.")
tSyncIfTimingAdmRef2BITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 15), TmnxBITSIfType().clone('t1-esf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2BITSIfType.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2BITSIfType.setDescription('The value of tSyncIfTimingAdmRef2BITSIfType specifies the interface type of the second timing reference if the source is BITS. This can only be changed if the value of tSyncIfTimingAdmRef2SrcHw is not 0.')
tSyncIfTimingAdmBITSOutAdmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 16), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSOutAdmStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSOutAdmStatus.setDescription('The value of tSyncIfTimingAdmBITSOutAdmStatus specifies administrative status of the BITS (Building Integrated Timing Supply) output timing reference.')
tSyncIfTimingAdmBITSOutLineLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lengthNotApplicable", 0), ("length0To110", 1), ("length110To220", 2), ("length220To330", 3), ("length330To440", 4), ("length440To550", 5), ("length550To660", 6))).clone('lengthNotApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSOutLineLen.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSOutLineLen.setDescription("tSyncIfTimingAdmBITSOutLineLen specifies the length of the line (in feet) for the BITS (Building Integrated Timing Supply) output. The following values are valid: lengthNotApplicable (0) - When BITS output is not supported length0To110 (1) - For line length from 0 to 110 feet length110To220 (2) - For line length from 110 to 220 feet length220To330 (3) - For line length from 230 to 330 feet length330To440 (4) - For line length from 330 to 440 feet length440To550 (5) - For line length from 440 to 550 feet length550To660 (6) - For line length from 550 to 660 feet The default is 'lengthNotApplicable' on CPM cards which do not support line length. Otherwise, the default is 'length0To110'.")
tSyncIfTimingAdmRef1CfgQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 18), TmnxSSMQualityLevel().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1CfgQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1CfgQltyLevel.setDescription("The value of tSyncIfTimingAdmRef1CfgQltyLevel specifies the configured Quality Level of Reference 1. A value of 'unknown (0)' indicates Reference 1 is not forced to a specific quality level.")
tSyncIfTimingAdmRef2CfgQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 19), TmnxSSMQualityLevel().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2CfgQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2CfgQltyLevel.setDescription("The value of tSyncIfTimingAdmRef2CfgQltyLevel specifies the configured Quality Level of Reference 2. A value of 'unknown (0)' indicates Reference 2 is not forced to a specific quality level.")
tSyncIfTimingAdmBITSCfgQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 20), TmnxSSMQualityLevel().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSCfgQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSCfgQltyLevel.setDescription("The value of tSyncIfTimingAdmBITSCfgQltyLevel specifies the configured Quality Level of the BITS interface. A value of 'unknown (0)' indicates the BITS interface is not forced to a specific quality level.")
tSyncIfTimingAdmRef1NationalUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 8)).clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1NationalUse.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1NationalUse.setDescription('The value of tSyncIfTimingAdmRef1NationalUse specifies the national use bit to carry SSM Messages. This applies only to E1 BITS interfaces.')
tSyncIfTimingAdmRef2NationalUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 8)).clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2NationalUse.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2NationalUse.setDescription('The value of tSyncIfTimingAdmRef2NationalUse specifies the national use bit to carry SSM Messages. This applies only to E1 BITS interfaces.')
tSyncIfTimingAdmBITSNationalUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 8)).clone(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSNationalUse.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSNationalUse.setDescription('The value of tSyncIfTimingAdmBITSNationalUse specifies the national use bit to carry SSM Messages. This applies only to E1 BITS interfaces.')
tSyncIfTimingAdmQLSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 24), TmnxEnabledDisabled().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmQLSelection.setReference('ITU-T Recommendation G.781, June 1999, Section 5.12')
if mibBuilder.loadTexts: tSyncIfTimingAdmQLSelection.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmQLSelection.setDescription('The value of tSyncIfTimingAdmQLSelection specifies whether or not the timing reference selection process uses the quality level of each timing reference when making the decision on which reference should provide system timing.')
tSyncIfTimingAdmRefOrder4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 25), TmnxSETSRefSource().clone('ptp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder4.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder4.setDescription('The value of tSyncIfTimingAdmRefOrder4 specifies the fourth most preferred timing reference for the synchronous equipment timing subsystem.')
tSyncIfTimingAdmPTPAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 26), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmPTPAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmPTPAdminStatus.setDescription('The value of tSyncIfTimingAdmPTPAdminStatus specifies the desired administrative status of the Precision Timing Protocol (PTP) timing reference.')
tSyncIfTimingAdmPTPCfgQltyLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 27), TmnxSSMQualityLevel().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmPTPCfgQltyLevel.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmPTPCfgQltyLevel.setDescription("The value of tSyncIfTimingAdmPTPCfgQltyLevel specifies the configured Quality Level of the Precision Timing Protocol (PTP). A value of 'unknown (0)' specifies PTP is not forced to a specific quality level.")
tSyncIfTimingAdmBITSOutSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 28), TmnxBITSOutSource().clone('internalClock')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSOutSource.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSOutSource.setDescription('The value of tSyncIfTimingAdmBITSOutSource specifies the source of the BITS (Building Integrated Timing Supply) output.')
tSyncIfTimingAdmRefOrder5 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 50), TmnxSETSRefSource().clone('bits2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder5.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder5.setDescription('The value of tSyncIfTimingAdmRefOrder5 specifies the fifth most preferred timing reference for the synchronous equipment timing subsystem.')
tSyncIfTimingAdmBITS2InAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 51), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITS2InAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITS2InAdminStatus.setDescription('The value of tSyncIfTimingAdmBITS2InAdminStatus specifies administrative status of the BITS2 (Building Integrated Timing Supply) output timing reference.')
tSyncIfTimingAdmBITS2OutAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 52), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITS2OutAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITS2OutAdminStatus.setDescription('The value of tSyncIfTimingAdmBITS2OutAdminStatus specifies administrative status of the BITS2 (Building Integrated Timing Supply) output timing reference.')
tmnxChassisAdminOwner = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1, 1), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxChassisAdminOwner.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminOwner.setDescription('Who has last initialized the chassis administrative table, who is making all the changes, and who is expected to either commit or re-initialize (ABORT-TRANSACTION). tmnxChassisAdminOwner is advisory only. Before beginning a transaction, read tmnxChassisAdminOwner. if it is empty then proceed with the configuration. Set tmnxChassisAdminOwner after setting tmnxChassisAdminControlApply so that other users will be advised to not make changes to the Admin tables. Agent sets tmnxChassisAdminOwner to empty string after tmnxChassisAdminControlApply is set - either by user initializing or committing, or by agent timing out the uncommitted transactions (tmnxChassisAdminLastSetTimer). ')
tmnxChassisAdminControlApply = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("initialize", 2), ("commit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxChassisAdminControlApply.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminControlApply.setDescription('This object controls the use of tmnxChassisAdminTable. when set to initialize(2), the objects in tmnxChassisAdminTable are set to the current Operational values, from the tmnxChassisTable. Any uncommitted changes are lost, so setting this value corresponds to both BEGIN-TRANSACTION and ABORT-TRANSACTION. when set to commit(3) (END-TRANSACTION), all of the objects from tmnxChassisAdminTable are copied to the corresponding tmnxChassisTable table objects. ')
tmnxChassisAdminLastSetTimer = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1, 3), TimeInterval()).setUnits('centiseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisAdminLastSetTimer.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminLastSetTimer.setDescription('The time remaining until the agent re-initializes the administrative tables. If tmnxChassisAdminControlApply is not set to commit(3) within tmnxChassisAdminLastSetTimeout centiseconds, the agent will set it to initialize(2) and all uncommitted changes will be lost. This way, uncommitted changes from failed (uncompleted) change sets will eventually be removed, and another transaction can safely begin. this object is reset to tmnxChassisAdminLastSetTimeout after SNMP SET operation to any of the tmnxChassisAdminValue tables. ')
tmnxChassisAdminLastSetTimeout = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1, 4), TimeInterval().clone(180000)).setUnits('centiseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxChassisAdminLastSetTimeout.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminLastSetTimeout.setDescription('Timeout for tmnxChassisAdminLastSetTimer. The value zero is not allowed. ')
tmnxCcagTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12), )
if mibBuilder.loadTexts: tmnxCcagTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagTable.setDescription('The tmnxCcagTable has an entry for each Cross Connect Aggregation Group,CCAG, configured on this system.')
tmnxCcagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxCcagId"))
if mibBuilder.loadTexts: tmnxCcagEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagEntry.setDescription('Each row entry represents a particular CCAG. Entries are created/deleted by the user. There is no StorageType object, entries have a presumed StorageType of nonVolatile.')
tmnxCcagId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 1), TmnxCcagId())
if mibBuilder.loadTexts: tmnxCcagId.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagId.setDescription('The value of tmnxCcagId is used to index into the tmnxCcagTable. It uniquely identifies a CCAG entry as configured on this system.')
tmnxCcagRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagRowStatus.setDescription('The value of tmnxCcagRowStatus specifies the row status. It allows entries to be created and deleted in the tmnxCcagTable. tmnxCcagRowStatus does not support createAndWait. The status can only be active or notInService.')
tmnxCcagLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagLastChanged.setDescription('The value of tmnxCcagLastChanged indicates the time this row was last changed.')
tmnxCcagDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 4), DisplayString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagDescription.setDescription('The value of tmnxCcagDescription specifies a user provided description string of this CCAG entry.')
tmnxCcagAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 5), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagAdminStatus.setDescription('The value of tmnxCcagAdminStatus specifies the desired state of this CCAG.')
tmnxCcagOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 6), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagOperStatus.setDescription('The value of tmnxCcagOperStatus indicates the operational state of this CCAG.')
tmnxCcagCcaRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 7), TmnxCcagRate().clone(-1)).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagCcaRate.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagCcaRate.setDescription('The value of tmnxCcagCcaRate specifies the maximum forwarding rate for each CCA member within the CCAG.')
tmnxCcagAccessAdaptQos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("link", 1), ("distribute", 2))).clone('distribute')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagAccessAdaptQos.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagAccessAdaptQos.setDescription('The value of tmnxCcagAccessAdaptQos specifies how the CCAG SAP queue and virtual scheduler buffering and rate parameters are adapted over multiple active CCAs. link (1) - The CCAG will create the SAP queues and virtual schedulers on each CCA with the actual parameters specified in the tmnxCcagPathCcTable. distribute (2) - Each CCA will receive a portion of the parameters specified in the tmnxCcagPathCcTable.')
tmnxCcagPathTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13), )
if mibBuilder.loadTexts: tmnxCcagPathTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathTable.setDescription('The tmnxCcagPathTable has an entry for each Cross Connect Aggregation Group, CCAG, path configured on this system.')
tmnxCcagPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxCcagId"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCcagPathId"))
if mibBuilder.loadTexts: tmnxCcagPathEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathEntry.setDescription('Each row entry represents a particular CCAG Path. Entries are created/deleted by the user. There is no StorageType object, entries have a presumed StorageType of nonVolatile.')
tmnxCcagPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alpha", 1), ("beta", 2))))
if mibBuilder.loadTexts: tmnxCcagPathId.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathId.setDescription('The value of tmnxCcagPathId is used as the secondary index into the tmnxCcagPathTable. Along with tmnxCcagId, it uniquely identifies a specific path, alpha or beta, on a CCAG.')
tmnxCcagPathLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagPathLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathLastChanged.setDescription('The value of tmnxCcagPathLastChanged indicates the time this row was last changed.')
tmnxCcagPathRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 3), TmnxCcagRate().clone(-1)).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathRate.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathRate.setDescription('The value of tmnxCcagPathRate specifies the bandwidth rate limitation for this path on each member cross connect adaptor, CCA, in the CCAG.')
tmnxCcagPathRateOption = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 4), TmnxCcagRateOption().clone('aggregate')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathRateOption.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathRateOption.setDescription('The value of tmnxCcagPathRateOption specifies whether the rate in tmnxCcagPathRate is defined as an aggregate path rate for all CCAs in the CCAG or as a per CCA path rate.')
tmnxCcagPathWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(50)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathWeight.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathWeight.setDescription('The value of tmnxCcagPathWeight specifies the scheduling percentage for this path. It is applied to all CCAs in the CCAG membership list for this path.')
tmnxCcagPathCcTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14), )
if mibBuilder.loadTexts: tmnxCcagPathCcTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcTable.setDescription('The tmnxCcagPathCcTable has an entry for each type of Cross Connection on a Cross Connect Aggregation Group Path configured on this system.')
tmnxCcagPathCcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxCcagId"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCcagPathId"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcType"))
if mibBuilder.loadTexts: tmnxCcagPathCcEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcEntry.setDescription('Each row entry represents a particular CCAG Path Cross Connect. Entries are created/deleted by the user. There is no StorageType object, entries have a presumed StorageType of nonVolatile.')
tmnxCcagPathCcType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sapsap", 1), ("sapnet", 2), ("netsap", 3))))
if mibBuilder.loadTexts: tmnxCcagPathCcType.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcType.setDescription('The value of tmnxCcagPathCcType is used as a third index into the tmnxCcagPathCcTable. Along with tmnxCcagId and tmnxCcagPathId, it uniquely identifies a cross connection type on a specific path in a particular CCAG. The types are: sapsap (1): the cross connection is between two saps, where both services are access. sapnet (2): the cross connection is between a sap and a network service. netsap (3): the cross connection is between a network and a sap service.')
tmnxCcagPathCcLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagPathCcLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcLastChanged.setDescription('The value of tmnxCcagPathCcLastChanged indicates the time this row was last changed.')
tmnxCcagPathCcEgrPoolResvCbs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcEgrPoolResvCbs.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcEgrPoolResvCbs.setDescription("The value of tmnxCcagPathCcEgrPoolResvCbs specifies the percentage of pool size reserved for the committed burst size, CBS. The value '-1' implies that the reserved CBS should be computed as the sum of the CBS requested by the entities using this pool if the application point is 'network'. For 'access' application points the value '-1' means a default of 30%.")
tmnxCcagPathCcEgrPoolSlpPlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 4), TNamedItem().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcEgrPoolSlpPlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcEgrPoolSlpPlcy.setDescription('The value of tmnxCcagPathCcEgrPoolSlpPlcy specifies the slope policy being used for the egress pool. The Slope policies define the nature of the RED Slopes for the high and the low priority traffic.')
tmnxCcagPathCcIngPoolResvCbs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcIngPoolResvCbs.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcIngPoolResvCbs.setDescription("The value of tmnxCcagPathCcIngPoolResvCbs specifies the percentage of pool size reserved for the committed burst size, CBS. The value '-1' implies that the reserved CBS should be computed as the sum of the CBS requested by the entities using this pool if the application point is 'network'. For 'access' application points the value '-1' means a default of 30%. tmnxCcagPathCcIngPoolResvCbs does not apply to tmnxCcagPathCcType 'netsap'.")
tmnxCcagPathCcIngPoolSlpPlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 6), TNamedItem().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcIngPoolSlpPlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcIngPoolSlpPlcy.setDescription("The value of tmnxCcagPathCcIngPoolSlpPlcy specifies the slope policy being used for the ingress pool. The Slope policies define the nature of the RED Slopes for the high and the low priority traffic. tmnxCcagPathCcIngPoolSlpPlcy does not apply to tmnxCcagPathCcType 'netsap'.")
tmnxCcagPathCcAcctPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcAcctPolicyId.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcAcctPolicyId.setDescription("The value of tmnxCcagPathCcAcctPolicyId specifies the accounting policy which must be defined prior to associating it with the port. A non-zero value indicates the tmnxLogApPolicyId index identifying the policy entry in the tmnxLogApTable from the TIMETRA-LOG-MIB which is associated with this port. A zero value indicates that there is no accounting policy associated with this port. It is only meaningful when the tmnxCcagPathCcType is 'netsap'.")
tmnxCcagPathCcCollectStats = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcCollectStats.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcCollectStats.setDescription("The value of tmnxCcagPathCcCollectStats specifies whether the collection of accounting and statistical data for the network port is enabled/disabled, 'true'/'false'. When applying accounting policies the data by default will be collected in the appropriate records and written to the designated billing file. When the value is set to false, the statistics are still accumulated by the IOM cards, however, the CPU will not obtain the results and write them to the billing file. If the value of tmnxCcagPathCcType is not 'netsap', the value of this object is meaningless and an attempt to set it will result in an inconsistentValue error.")
tmnxCcagPathCcQueuePlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 9), TNamedItem().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcQueuePlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcQueuePlcy.setDescription("The value of tmnxCcagPathCcQueuePlcy specifies the network egress queue policy. If the value of tmnxCcagPathCcType is not 'netsap', the value of this object is meaningless and an attempt to set it will result in an inconsistentValue error.")
tmnxCcagPathCcMac = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 10), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcMac.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcMac.setDescription('The value of tmnxCcagPathCcMac specifies the MAC address of the virtual LAG that maps to tmnxCcagPathId and tmnxCcagPathCcType. The default value of this object is derived from the chassis MAC address pool.')
tmnxCcagPathCcMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 11), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcMtu.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcMtu.setDescription("The value of tmnxCcagPathCcMtu specifies the MTU of the path indexed by tmnxCcagId, tmnxCcagPathId, and tmnxCcagPathCcType. When the value is '0', the real MTU is calculated internally.")
tmnxCcagPathCcUserAssignedMac = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 12), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagPathCcUserAssignedMac.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcUserAssignedMac.setDescription("The value of tmnxCcagPathCcUserAssignedMac indicates whether the value of tmnxCcagPathCcMac has been explicitly assigned or inherited from tmnxCcagPathCcHwMac, 'true' and 'false', respectively.")
tmnxCcagPathCcHwMac = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 13), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagPathCcHwMac.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcHwMac.setDescription("The value of tmnxCcagPathCcHwMac is the system assigned MAC address of the virtual LAG that maps to tmnxCcagPathId and tmnxCcagPathCcType. When tmnxCcagPathCcUserAssignedMac is 'false', tmnxCcagPathCcMac inherits its value from this object.")
tmnxMcmTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15), )
if mibBuilder.loadTexts: tmnxMcmTable.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTable.setDescription('The tmnxMcmTable has an entry for each Mda Carrier module (MCM) on the 7710 system.')
tmnxMcmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxMcmSlotNum"))
if mibBuilder.loadTexts: tmnxMcmEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmEntry.setDescription('Each row entry represents a MCM in a chassis in the 7710 system. Entries in the table cannot be created and deleted via SNMP SET operations. When a tmnxChassisEntry is created, a tmnxMcmEntry is created in the chassis. Before a tmnxChassisEntry can be deleted, each tmnxMcmEntry for the chassis must be in the proper state for removal.')
tmnxMcmSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16)))
if mibBuilder.loadTexts: tmnxMcmSlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmSlotNum.setDescription('The unique value which identifies this MDA slot within a specific IOM card in the system. Since the MCM occupies two MDA slots in the chassis this value can only be an odd number.')
tmnxMcmSupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 2), TmnxMcmType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmSupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmSupportedTypes.setDescription('A bit-mask that specifies what MCM types can be physically supported in this chassis.')
tmnxMcmAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 3), TmnxMcmType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMcmAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmAssignedType.setDescription("A bit-mask that identifies the administratively assigned (pre-provisioned) MCM type that should occupy this chassis. If tmnxMcmAssignedType has a value of 'unassigned', this slot has not yet been pre-provisioned. There must not be more than one bit set at a time in tmnxMcmAssignedType.")
tmnxMcmEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 4), TmnxMcmType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmEquippedType.setDescription("A bit-mask that identifies the MCM type that is physically inserted into this chassis. If the chassis has been pre-provisioned, tmnxMcmAssignedType is not equal 'unassigned', and the value of tmnxMcmEquippedType is not the same as tmnxMcmAssignedType, a mis-match alarm will be raised. If the chassis has not been pre-provisioned, and the value of tmnxMcmEquippedType is not one of the supported types as specified by tmnxMcmSupportedTypes, a mis-match alarm will be raised. There will not be more than one bit set at a time in tmnxMcmEquippedType.")
tmnxMcmHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 5), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmHwIndex.setDescription('The value of tmnxMcmHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this MCM.')
tmnxMcmTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16), )
if mibBuilder.loadTexts: tmnxMcmTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeTable.setDescription('The card type table has an entry for each Alcatel-Lucent 7710 series Mda Carrier Module (MCM) model.')
tmnxMcmTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxMcmTypeIndex"))
if mibBuilder.loadTexts: tmnxMcmTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeEntry.setDescription('Each row entry represents an Alcatel-Lucent 7710 series MCM model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxMcmTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1, 1), TmnxMcmType())
if mibBuilder.loadTexts: tmnxMcmTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeIndex.setDescription('The unique index value which identifies this type of Alcatel-Lucent 7710 series MCM model.')
tmnxMcmTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeName.setDescription('The administrative name that identifies this type of Alcatel-Lucent 7710 series MCM model. This name string may be used in CLI commands to specify a particular card model type.')
tmnxMcmTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeDescription.setDescription('A detailed description of this Alcatel-Lucent 7710 series MCM model.')
tmnxMcmTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeStatus.setDescription("When tmnxMcmTypeStatus has a value of 'true' it indicates that this MCM is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxIPsecIsaGrpTableLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 17), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTableLastChanged.setDescription('The value of tmnxIPsecIsaGrpTableLastChanged indicates the sysUpTime at the time of the last modification to tmnxIPsecIsaGrpTable by adding, deleting an entry or change to a writable object in the table. If no changes were made to the table since the last re-initialization of the local network management subsystem, then this object contains a zero value.')
tmnxIPsecIsaGrpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18), )
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTable.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTable.setDescription('Table to store entries for Groups of IPSec Integrated Service Adaptors. The table tmnxIPsecIsaGrpTable used to create and remove IPsec ISA groups. An IPsec ISA group is used to represent multiple hardware adaptors as a single entity. This allows for warm redundancy to be run between two IPsec ISAs.')
tmnxIPsecIsaGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpId"))
if mibBuilder.loadTexts: tmnxIPsecIsaGrpEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpEntry.setDescription('Information about a single IPsec group entry.')
tmnxIPsecIsaGrpId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 1), TmnxTunnelGroupId())
if mibBuilder.loadTexts: tmnxIPsecIsaGrpId.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpId.setDescription('The value of tmnxIPsecIsaGrpId specifies the id of a TmnxIPsecIsaGrpEntry and is the primary index for the table.')
tmnxIPsecIsaGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpRowStatus.setDescription('The tmnxIPsecIsaGrpRowStatus object is used to create and delete rows in the tmnxIPsecIsaGrpTable.')
tmnxIPsecIsaGrpLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpLastChanged.setDescription('The value of tmnxIPsecIsaGrpLastChanged indicates the sysUpTime at the time of the last modification of this entry. If no changes were made to the entry since the last re-initialization of the local network management subsystem, then this object contains a zero value.')
tmnxIPsecIsaGrpDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 4), TItemDescription()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpDescription.setDescription('The value of tmnxIPsecIsaGrpDescription specifies the user-provided description for each tmnxIPsecIsaGrpEntry in the table tmnxIPsecIsaGrpTable.')
tmnxIPsecIsaGrpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 5), TmnxAdminState().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpAdminState.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpAdminState.setDescription('The value of tmnxIPsecIsaGrpAdminState specifies the administrative state of the tmnxIPsecIsaGrpEntry.')
tmnxIPsecIsaGrpOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 6), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpOperState.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpOperState.setDescription('The value of tmnxIPsecIsaGrpOperState indicates the operational status of tmnxIPsecIsaGrpEntry.')
tmnxIPsecIsaGrpIsaChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 7), TmnxChassisIndex().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpIsaChassis.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpIsaChassis.setDescription('The value of tmnxIPsecIsaGrpIsaChassis indicates the chassis on which the tmnxIPsecIsaGrpPrimaryIsa and tmnxIPsecIsaGrpBackupIsa are present.')
tmnxIPsecIsaGrpPrimaryIsa = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 8), TmnxHwIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpPrimaryIsa.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpPrimaryIsa.setDescription('The value of tmnxIPsecIsaGrpPrimaryIsa specifies the primary IPsec ISA to be used for this module group.')
tmnxIPsecIsaGrpBackupIsa = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 9), TmnxHwIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpBackupIsa.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpBackupIsa.setDescription('The value of tmnxIPsecIsaGrpBackupIsa specifies the backup IPsec ISA to be used for this module group.')
tmnxIPsecIsaGrpActiveIsa = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 10), TmnxHwIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpActiveIsa.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpActiveIsa.setDescription('The value of tmnxIPsecIsaGrpActiveIsa indicates the active ISA that is being used for this module group.')
tmnxIPsecIsaGrpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTunnels.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTunnels.setDescription('The value of tmnxIPsecIsaGrpTunnels indicates the number of IPSec tunnels being used for this module group.')
tmnxIPsecIsaGrpMaxTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpMaxTunnels.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpMaxTunnels.setDescription('The value of tmnxIPsecIsaGrpMaxTunnels indicates the maximum number of IPSec tunnels available for this module group.')
tmnxIPsecIsaGrpTunnelReassembly = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setUnits('milli-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTunnelReassembly.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTunnelReassembly.setDescription("The value of tmnxIPsecIsaGrpTunnelReassembly specifies the maximum number of seconds to wait to receive all fragments of a particular IPSec or GRE packet for reassembly. The tmnxGreTunnelReassembly value set to zero indicates that reassembly is disabled. An 'inconsistentValue' error is retuned if the value is not a multiple of 100 milli-seconds.")
tmnxIPsecIsaGrpOperFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 14), TmnxIpSecIsaOperFlags()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpOperFlags.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpOperFlags.setDescription('The value of tmnxIPsecIsaGrpOperFlags indicates the operational flags to determine the status of tmnxIPsecIsaGrpEntry.')
tmnxIPsecIsaGrpMultiActive = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpMultiActive.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpMultiActive.setDescription('The value of tmnxIPsecIsaGrpMultiActive specifies whether this tunnel group will load-balance IPsec traffic on multiple MDAs.')
tmnxIPsecIsaGrpActiveMda = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpActiveMda.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpActiveMda.setDescription('The value of tmnxIPsecIsaGrpActiveMda specifies the number of active MDA to be used by this tunnel-group to load-balance IPsec traffic.')
tmnxIPsecIsaGrpIpTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpIpTunnels.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpIpTunnels.setDescription('The value of tmnxIPsecIsaGrpIpTunnels indicates the number of IP tunnels being used for this module group.')
tmnxIPsecIsaGrpIpMaxTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 18, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxIPsecIsaGrpIpMaxTunnels.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpIpMaxTunnels.setDescription('The value of tmnxIPsecIsaGrpIpMaxTunnels indicates the maximum number of IP tunnels available for this module group.')
tmnxHsmdaMdaSchOvrTblLastChangd = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 19), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrTblLastChangd.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrTblLastChangd.setDescription('The value of tmnxHsmdaMdaSchOvrTblLastChangd indicates the sysUpTime at the time of the last modification of tmnxHsmdaMdaSchOvrTable. If no changes were made to the table since the last re-initialization of the local network management subsystem, then this object contains a zero value. This object is obsoleted in 10.0 Release.')
tmnxHsmdaMdaSchOvrTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20), )
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrTable.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrTable.setDescription('The tmnxHsmdaMdaSchOvrTable has an entry for each MDA-level HSMDA scheduler override configured on this system. This table is obsoleted in 10.0 Release.')
tmnxHsmdaMdaSchOvrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxMDASlotNum"))
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrEntry.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrEntry.setDescription('Each row represents a particular MDA-level HSMDA scheduler override. Entries are created and deleted by the user.')
tmnxHsmdaMdaSchOvrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrRowStatus.setDescription("The value of tmnxHsmdaMdaSchOvrRowStatus is used for the creation and deletion of MDA-level HSMDA scheduler overrides. When the tmnxMDAAssignedType of the tmnxMDAEntry indexed by the same indices of this table is a non-HSMDA MDA Type, creation will fail and return a 'noCreation' error.")
tmnxHsmdaMdaSchOvrLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrLastChanged.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrLastChanged.setDescription('The value of tmnxHsmdaMdaSchOvrLastChanged indicates the sysUpTime at the time of the last modification of this entry. If no changes were made to the entry since the last re-initialization of the local network management subsystem, then this object contains a zero value.')
tmnxHsmdaMdaSchOvrMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 3), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrMaxRate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrMaxRate.setDescription('The value of tmnxHsmdaMdaSchOvrMaxRate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyMaxRate.')
tmnxHsmdaMdaSchOvrGrp1Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 4), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrGrp1Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrGrp1Rate.setDescription('The value of tmnxHsmdaMdaSchOvrGrp1Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for group 1 for this HSMDA scheduler. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyGrp1Rate.')
tmnxHsmdaMdaSchOvrGrp2Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 5), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrGrp2Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrGrp2Rate.setDescription('The value of tmnxHsmdaMdaSchOvrGrp2Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for group 2 for this HSMDA scheduler. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyGrp2Rate.')
tmnxHsmdaMdaSchOvrClass1Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 6), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass1Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass1Rate.setDescription('The value of tmnxHsmdaMdaSchOvrClass1Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler policy level. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl1Rate.')
tmnxHsmdaMdaSchOvrClass1WtInGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 7), THsmdaWeightOverride().clone(-2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass1WtInGrp.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass1WtInGrp.setDescription('The value of tmnxHsmdaMdaSchOvrClass1WtInGrp specifies the weight the HSMDA scheduler policy should apply to this policy level within the group it belongs to. The value of tmnxHsmdaMdaSchOvrClass1WtInGrp will only be used if this policy level has been assigned to a group by setting tHsmdaSchedulerPlcyLvl1GrpId to a non-zero value. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl1WgtInGrp.')
tmnxHsmdaMdaSchOvrClass2Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 8), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass2Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass2Rate.setDescription('The value of tmnxHsmdaMdaSchOvrClass2Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler policy level. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl2Rate.')
tmnxHsmdaMdaSchOvrClass2WtInGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 9), THsmdaWeightOverride().clone(-2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass2WtInGrp.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass2WtInGrp.setDescription('The value of tmnxHsmdaMdaSchOvrClass2WtInGrp specifies the weight the HSMDA scheduler policy should apply to this policy level within the group it belongs to. The value of tmnxHsmdaMdaSchOvrClass2WtInGrp will only be used if this policy level has been assigned to a group by setting tHsmdaSchedulerPlcyLvl2GrpId to a non-zero value. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl2WgtInGrp.')
tmnxHsmdaMdaSchOvrClass3Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 10), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass3Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass3Rate.setDescription('The value of tmnxHsmdaMdaSchOvrClass3Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler policy level. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl3Rate.')
tmnxHsmdaMdaSchOvrClass3WtInGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 11), THsmdaWeightOverride().clone(-2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass3WtInGrp.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass3WtInGrp.setDescription('The value of tmnxHsmdaMdaSchOvrClass3WtInGrp specifies the weight the HSMDA scheduler policy should apply to this policy level within the group it belongs to. The value of tmnxHsmdaMdaSchOvrClass3WtInGrp will only be used if this policy level has been assigned to a group by setting tHsmdaSchedulerPlcyLvl3GrpId to a non-zero value. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl3WgtInGrp.')
tmnxHsmdaMdaSchOvrClass4Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 12), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass4Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass4Rate.setDescription('The value of tmnxHsmdaMdaSchOvrClass4Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler policy level. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl4Rate.')
tmnxHsmdaMdaSchOvrClass4WtInGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 13), THsmdaWeightOverride().clone(-2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass4WtInGrp.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass4WtInGrp.setDescription('The value of tmnxHsmdaMdaSchOvrClass4WtInGrp specifies the weight the HSMDA scheduler policy should apply to this policy level within the group it belongs to. The value of tmnxHsmdaMdaSchOvrClass4WtInGrp will only be used if this policy level has been assigned to a group by setting tHsmdaSchedulerPlcyLvl4GrpId to a non-zero value. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl4WgtInGrp.')
tmnxHsmdaMdaSchOvrClass5Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 14), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass5Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass5Rate.setDescription('The value of tmnxHsmdaMdaSchOvrClass5Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler policy level. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl5Rate.')
tmnxHsmdaMdaSchOvrClass5WtInGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 15), THsmdaWeightOverride().clone(-2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass5WtInGrp.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass5WtInGrp.setDescription('The value of tmnxHsmdaMdaSchOvrClass5WtInGrp specifies the weight the HSMDA scheduler policy should apply to this policy level within the group it belongs to. The value of tmnxHsmdaMdaSchOvrClass5WtInGrp will only be used if this policy level has been assigned to a group by setting tHsmdaSchedulerPlcyLvl5GrpId to a non-zero value. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl5WgtInGrp.')
tmnxHsmdaMdaSchOvrClass6Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 16), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass6Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass6Rate.setDescription('The value of tmnxHsmdaMdaSchOvrClass6Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler policy level. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl6Rate.')
tmnxHsmdaMdaSchOvrClass6WtInGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 17), THsmdaWeightOverride().clone(-2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass6WtInGrp.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass6WtInGrp.setDescription('The value of tmnxHsmdaMdaSchOvrClass6WtInGrp specifies the weight the HSMDA scheduler policy should apply to this policy level within the group it belongs to. The value of tmnxHsmdaMdaSchOvrClass6WtInGrp will only be used if this policy level has been assigned to a group by setting tHsmdaSchedulerPlcyLvl6GrpId to a non-zero value. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl6WgtInGrp.')
tmnxHsmdaMdaSchOvrClass7Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 18), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass7Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass7Rate.setDescription('The value of tmnxHsmdaMdaSchOvrClass7Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler policy level. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl7Rate.')
tmnxHsmdaMdaSchOvrClass7WtInGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 19), THsmdaWeightOverride().clone(-2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass7WtInGrp.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass7WtInGrp.setDescription('The value of tmnxHsmdaMdaSchOvrClass7WtInGrp specifies the weight the HSMDA scheduler policy should apply to this policy level within the group it belongs to. The value of tmnxHsmdaMdaSchOvrClass7WtInGrp will only be used if this policy level has been assigned to a group by setting tHsmdaSchedulerPlcyLvl7GrpId to a non-zero value. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl7WgtInGrp.')
tmnxHsmdaMdaSchOvrClass8Rate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 20), THsmdaPIRMRateOverride().clone(-2)).setUnits('Mbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass8Rate.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass8Rate.setDescription('The value of tmnxHsmdaMdaSchOvrClass8Rate specifies the explicit maximum frame based bandwidth limit, in megabits per second, for this HSMDA scheduler policy level. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl8Rate.')
tmnxHsmdaMdaSchOvrClass8WtInGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 20, 1, 21), THsmdaWeightOverride().clone(-2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass8WtInGrp.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHsmdaMdaSchOvrClass8WtInGrp.setDescription('The value of tmnxHsmdaMdaSchOvrClass8WtInGrp specifies the weight the HSMDA scheduler policy should apply to this policy level within the group it belongs to. The value of tmnxHsmdaMdaSchOvrClass8WtInGrp will only be used if this policy level has been assigned to a group by setting tHsmdaSchedulerPlcyLvl8GrpId to a non-zero value. A value of -2 indicates no override. This object overrides TIMETRA-QOS-MIB::tHsmdaSchedulerPlcyLvl8WgtInGrp.')
tmnxFPTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21), )
if mibBuilder.loadTexts: tmnxFPTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFPTable.setDescription('The tmnxFPTable has an entry for each Forwarding Plane configuration. An entry is created in this table whenever an entry for card is created in tmnxCardTable. This entry is relevant only for IOM3/IMM.')
tmnxFPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNum"))
if mibBuilder.loadTexts: tmnxFPEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFPEntry.setDescription('Each row entry represents a Forwarding Plane (FP) configuration.')
tmnxFPNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 1), Unsigned32())
if mibBuilder.loadTexts: tmnxFPNum.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNum.setDescription('The value of tmnxFPNum identifies the Forwarding Plane.')
tmnxFPMcPathMgmtBwPlcyName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 2), TNamedItem().clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPMcPathMgmtBwPlcyName.setStatus('current')
if mibBuilder.loadTexts: tmnxFPMcPathMgmtBwPlcyName.setDescription('The value of tmnxFPMcPathMgmtBwPlcyName specifies the multicast policy name configured for the FP. tmnxFPMcPathMgmtBwPlcyName can be set only if the policy exists in TIMETRA-MCAST-PATH-MGMT-MIB::tmnxMcPathBwPlcyTable.')
tmnxFPMcPathMgmtAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 3), TmnxAdminState().clone('outOfService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPMcPathMgmtAdminState.setStatus('current')
if mibBuilder.loadTexts: tmnxFPMcPathMgmtAdminState.setDescription('The value of tmnxFPMcPathMgmtAdminState specifies administrative state of the multicast path for the FP.')
tmnxFPLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxFPLastChanged.setDescription('The value of tmnxFPLastChanged indicates the timestamp of last change to this row in tmnxFPTable.')
tmnxFPHiBwMcastSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPHiBwMcastSource.setStatus('current')
if mibBuilder.loadTexts: tmnxFPHiBwMcastSource.setDescription("The value of tmnxFPHiBwMcastSource specifies if this FP should attempt to allocate separate fabric planes to allocate high bandwidth multicast traffic taps. tmnxFPHiBwMcastGroup must be set in the same SNMP request PDU with tmnxFPHiBwMcastSource or an 'inconsistentValue' error will be returned.")
tmnxFPHiBwMcastAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPHiBwMcastAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxFPHiBwMcastAlarm.setDescription('The value of tmnxFPHiBwMcastAlarm specifies if a tmnxChassisHiBwMcastAlarm alarm is raised if there are more than one high bandwidth multicast traffic taps sharing a plane.')
tmnxFPHiBwMcastTapCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPHiBwMcastTapCount.setStatus('current')
if mibBuilder.loadTexts: tmnxFPHiBwMcastTapCount.setDescription('The value of tmnxFPHiBwMcastTapCount indicates the number of high bandwidth multicast traffic taps on this FP.')
tmnxFPHiBwMcastGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPHiBwMcastGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxFPHiBwMcastGroup.setDescription("The value of tmnxFPHiBwMcastGroup specifies the group of high bandwidth multicast traffic taps to which this tap belongs. A value of '0' specifies that this tap is not a member of any High Bandwidth Multicast group. tmnxMDAHiBwMcastGroup must be set in the same SNMP request PDU with tmnxMDAHiBwMcastSource or an 'inconsistentValue' error will be returned.")
tmnxFPWredBufAllocMin = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999)).clone(2500)).setUnits('Hundredths of a percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPWredBufAllocMin.setStatus('current')
if mibBuilder.loadTexts: tmnxFPWredBufAllocMin.setDescription('The value of tmnxFPWredBufAllocMin specifies the minimum WRED (Weighted Random Early Detection) queue aggregate buffer allocation which will be set aside for WRED queue buffer pools.')
tmnxFPWredBufAllocMax = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(2500)).setUnits('Hundredths of a percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPWredBufAllocMax.setStatus('current')
if mibBuilder.loadTexts: tmnxFPWredBufAllocMax.setDescription('The value of tmnxFPWredBufAllocMax specifies the maximum WRED queue aggregate buffer allocation which will be set aside for WRED queue buffer pools.')
tmnxFPWredResvCbsMin = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999)).clone(2500)).setUnits('Hundredths of a percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPWredResvCbsMin.setStatus('current')
if mibBuilder.loadTexts: tmnxFPWredResvCbsMin.setDescription('The value of tmnxFPWredResvCbsMin specifies the minimum buffers within the WRED pool that will be set aside for WRED queues operating within their configured CBS (Committed Buffer Size) thresholds.')
tmnxFPWredResvCbsMax = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(2500)).setUnits('Hundredths of a percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPWredResvCbsMax.setStatus('current')
if mibBuilder.loadTexts: tmnxFPWredResvCbsMax.setDescription('The value of tmnxFPWredResvCbsMax specifies the maximum buffers within the WRED pool that will be set aside for WRED queues operating within their configured CBS (Committed Buffer Size) thresholds.')
tmnxFPWredSlopePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 13), TNamedItemOrEmpty().clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPWredSlopePolicy.setStatus('current')
if mibBuilder.loadTexts: tmnxFPWredSlopePolicy.setDescription('The value of tmnxFPWredSlopePolicy specifies the name of slope policy being used within WRED pool.')
tmnxFPWredAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 14), TmnxAdminState().clone('outOfService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPWredAdminState.setStatus('current')
if mibBuilder.loadTexts: tmnxFPWredAdminState.setDescription('The value of tmnxFPWredAdminState specifies administrative state of the egress WRED queue support on the card.')
tmnxFPHiBwMcastDefaultPathsOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 21, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFPHiBwMcastDefaultPathsOnly.setStatus('current')
if mibBuilder.loadTexts: tmnxFPHiBwMcastDefaultPathsOnly.setDescription("The value of tmnxFPHiBwMcastDefaultPathsOnly specifies whether only the default paths are to be High Bandwidth Multicast (HBM) (typically paths 0 and 15) and the remaining paths are non-HBM 'true (1)', or all paths are configured HBM on the forwarding path 'false (2)'. This object is only meaningful if tmnxFPHiBwMcastSource is set to the value 'true (1)'.")
tmnxFPAccIngQGrpTableLastChgd = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 22), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpTableLastChgd.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpTableLastChgd.setDescription('The value of tmnxFPAccIngQGrpTableLastChgd indicates the timestamp of last change to the tmnxFPAccIngQGrpTable.')
tmnxFPAccIngQGrpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23), )
if mibBuilder.loadTexts: tmnxFPAccIngQGrpTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpTable.setDescription('The value of tmnxFPAccIngQGrpTable defines access Ingress Queue Group Table for providing, via SNMP, the capability of defining the forwarding-plane specific queue groups from the queue-groups existing in the TIMETRA-QOS-MIB::tQosIngQGroupTable.')
tmnxFPAccIngQGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpName"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpInstanceId"))
if mibBuilder.loadTexts: tmnxFPAccIngQGrpEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpEntry.setDescription('The value of tmnxFPAccIngQGrpEntry defines an entry in the tmnxFPAccIngQGrpTable. Entries are created/deleted in this table by SNMP sets to tmnxFPAccIngQGrpRowStatus.')
tmnxFPAccIngQGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1, 1), TNamedItem())
if mibBuilder.loadTexts: tmnxFPAccIngQGrpName.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpName.setDescription('The value of tmnxFPAccIngQGrpName defines the forwarding-plane Ingress Queue Group name. It, along with tmnxFPAccIngQGrpInstanceId uniquely identifies a forwarding-plane ingress queue group in the managed system.')
tmnxFPAccIngQGrpInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: tmnxFPAccIngQGrpInstanceId.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpInstanceId.setDescription('The value of tmnxFPAccIngQGrpInstanceId defines the unique instance of the forwarding-plane ingress Queue Group. It, along with tmnxFPAccIngQGrpName, uniquely identifies a forwarding-plane ingress queue group in the managed system.')
tmnxFPAccIngQGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpRowStatus.setReference("See definition of RowStatus in RFC 2579, 'Textual Conventions for SMIv2.'")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpRowStatus.setDescription('The value of tmnxFPAccIngQGrpRowStatus allows entries to be created and deleted in the tmnxFPAccIngQGrpTable. The creation of an entry in this table will succeed only if the queue-group being created exists in TIMETRA-QOS-MIB::tQosIngQGroupTable.')
tmnxFPAccIngQGrpLastChgd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpLastChgd.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpLastChgd.setDescription('The value of tmnxFPAccIngQGrpLastChgd indicates the value of sysUpTime when the queue entry was last modified.')
tmnxFPAccIngQGrpAcctgPolId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpAcctgPolId.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpAcctgPolId.setDescription('The value of tmnxFPAccIngQGrpAcctgPolId specifies the accounting-policy to be used with this forwarding-plane ingress queue-group. A non-zero value indicates the tmnxLogApPolicyId index identifying the policy entry in the tmnxLogApTable from the TIMETRA-LOG-MIB which is associated with this queue-group. The value zero indicates that the agent should use the default accounting policy, if one exists.')
tmnxFPAccIngQGrpCollectStats = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpCollectStats.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpCollectStats.setDescription('The value of tmnxFPAccIngQGrpCollectStats specifies whether statistics should be collected on this forwarding-plane ingress queue-group.')
tmnxFPAccIngQGrpDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1, 7), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpDescr.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpDescr.setDescription('The value of tmnxFPAccIngQGrpDescr specifies the description for this forwarding-plane queue-group.')
tmnxFPAccIngQGrpPolicerPol = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 23, 1, 8), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPolicerPol.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPolicerPol.setDescription('The value of tmnxFPAccIngQGrpPolicerPol specifies the name of the policer control policy to be used with this forwarding-plane ingress queue-group.')
tmnxFPNetIngQGrpTableLastChgd = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 24), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpTableLastChgd.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpTableLastChgd.setDescription('The value of tmnxFPNetIngQGrpTableLastChgd indicates the timestamp of last change to the tmnxFPNetIngQGrpTable.')
tmnxFPNetIngQGrpTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25), )
if mibBuilder.loadTexts: tmnxFPNetIngQGrpTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpTable.setDescription('The value of tmnxFPNetIngQGrpTable defines access Ingress Queue Group Table for providing, via SNMP, the capability of defining the forwarding-plane specific queue groups from the queue-groups existing in the TIMETRA-QOS-MIB::tQosIngQGroupTable.')
tmnxFPNetIngQGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpName"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpInstanceId"))
if mibBuilder.loadTexts: tmnxFPNetIngQGrpEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpEntry.setDescription('The value of tmnxFPNetIngQGrpEntry defines an entry in the tmnxFPNetIngQGrpTable. Entries are created/deleted in this table by SNMP sets to tmnxFPNetIngQGrpRowStatus.')
tmnxFPNetIngQGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1, 1), TNamedItem())
if mibBuilder.loadTexts: tmnxFPNetIngQGrpName.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpName.setDescription('The value of tmnxFPNetIngQGrpName defines the forwarding-plane Ingress Queue Group name. It, along with tmnxFPNetIngQGrpInstanceId uniquely identifies a forwarding-plane ingress queue group in the managed system.')
tmnxFPNetIngQGrpInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: tmnxFPNetIngQGrpInstanceId.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpInstanceId.setDescription('The value of tmnxFPNetIngQGrpInstanceId defines the unique instance of the forwarding-plane ingress Queue Group. It, along with tmnxFPNetIngQGrpName, uniquely identifies a forwarding-plane ingress queue group in the managed system.')
tmnxFPNetIngQGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpRowStatus.setReference("See definition of RowStatus in RFC 2579, 'Textual Conventions for SMIv2.'")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpRowStatus.setDescription('The value of tmnxFPNetIngQGrpRowStatus allows entries to be created and deleted in the tmnxFPNetIngQGrpTable. The creation of an entry in this table will succeed only if the queue-group being created exists in TIMETRA-QOS-MIB::tQosIngQGroupTable.')
tmnxFPNetIngQGrpLastChgd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpLastChgd.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpLastChgd.setDescription('The value of tmnxFPNetIngQGrpLastChgd indicates the value of sysUpTime when the queue entry was last modified.')
tmnxFPNetIngQGrpAcctgPolId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpAcctgPolId.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpAcctgPolId.setDescription('The value of tmnxFPNetIngQGrpAcctgPolId specifies the accounting-policy to be used with this forwarding-plane ingress queue-group. A non-zero value indicates the tmnxLogApPolicyId index identifying the policy entry in the tmnxLogApTable from the TIMETRA-LOG-MIB which is associated with this queue-group. The value zero indicates that the agent should use the default accounting policy, if one exists.')
tmnxFPNetIngQGrpCollectStats = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpCollectStats.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpCollectStats.setDescription('The value of tmnxFPNetIngQGrpCollectStats specifies whether statistics should be collected on this forwarding-plane ingress queue-group.')
tmnxFPNetIngQGrpDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1, 7), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpDescr.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpDescr.setDescription('The value of tmnxFPNetIngQGrpDescr specifies the description for this forwarding-plane queue-group.')
tmnxFPNetIngQGrpPolicerPol = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 25, 1, 8), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPolicerPol.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPolicerPol.setDescription('The value of tmnxFPNetIngQGrpPolicerPol specifies the name of the policer control policy to be used with this forwarding-plane ingress queue-group.')
tmnxFPNetIngQGrpPStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27), )
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPStatTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPStatTable.setDescription('The value of tmnxFPNetIngQGrpTable contains forwarding-plane ingress QoS queue group policer statistics on network side.')
tmnxFPNetIngQGrpPStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpName"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpInstanceId"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpPStatPolicerId"))
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPStatEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPStatEntry.setDescription('The value of tmnxFPNetIngQGrpPStatEntry defines an entry in the tmnxFPNetIngQGrpPStatTable. It represents statistics about a specific QoS ingress queue group policer.')
tmnxFPNetIngQGrpPStatPolicerId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 1), TIngPolicerId())
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPStatPolicerId.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPStatPolicerId.setDescription('The value of tmnxFPNetIngQGrpPStatPolicerId specifies the index of the ingress QoS policer of this fowarding-plane queue group on network.')
tmnxFPNetIngQGrpPStatMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 2), TmnxIngPolicerStatMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPStatMode.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQGrpPStatMode.setDescription('The value of tmnxFPNetIngQGrpPStatMode indicates the stat mode used by this policer.')
tmnxFPNetIngQgPStOffHPrioPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioPkts.setDescription('The value of tmnxFPNetIngQgPStOffHPrioPkts indicates the number of high priority packets, as determined by the ingress queue group policer, offered by the Pchip to the Qchip.')
tmnxFPNetIngQgPStOffHPrioPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioPktsL.setDescription('The value of tmnxFPNetIngQgPStOffHPrioPktsL indicates the lower 32 bits of tmnxFPNetIngQgPStOffHPrioPkts.')
tmnxFPNetIngQgPStOffHPrioPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioPktsH.setDescription('The value of tmnxFPNetIngQgPStOffHPrioPktsH indicates the upper 32 bits of tmnxFPNetIngQgPStOffHPrioPkts.')
tmnxFPNetIngQgPStDrpHPrioPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioPkts.setDescription('The value of tmnxFPNetIngQgPStDrpHPrioPkts indicates the number of high priority packets, as determined by the ingress queue group policer, dropped by the Pchip due to: MBS exceeded, buffer pool limit exceeded, etc.')
tmnxFPNetIngQgPStDrpHPrioPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioPktsL.setDescription('The value of tmnxFPNetIngQgPStDrpHPrioPktsL indicates the lower 32 bits of tmnxFPNetIngQgPStDrpHPrioPkts.')
tmnxFPNetIngQgPStDrpHPrioPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioPktsH.setDescription('The value of tmnxFPNetIngQgPStDrpHPrioPktsH indicates the upper 32 bits of tmnxFPNetIngQgPStDrpHPrioPkts.')
tmnxFPNetIngQgPStOffLPrioPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioPkts.setDescription('The value of tmnxFPNetIngQgPStOffLPrioPkts indicates the number of low priority packets, as determined by the ingress queue group policer, offered by the Pchip to the Qchip.')
tmnxFPNetIngQgPStOffLPrioPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioPktsL.setDescription('The value of tmnxFPNetIngQgPStOffLPrioPktsL indicates the lower 32 bits of tmnxFPNetIngQgPStOffLPrioPkts.')
tmnxFPNetIngQgPStOffLPrioPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioPktsH.setDescription('The value of tmnxFPNetIngQgPStOffLPrioPktsH indicates the upper 32 bits of tmnxFPNetIngQgPStOffLPrioPkts.')
tmnxFPNetIngQgPStDrpLPrioPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioPkts.setDescription('The value of tmnxFPNetIngQgPStDrpLPrioPkts indicates the number of low priority packets, as determined by the ingress queue group policer, dropped by the Pchip due to: MBS exceeded, buffer pool limit exceeded, etc.')
tmnxFPNetIngQgPStDrpLPrioPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioPktsL.setDescription('The value of tmnxFPNetIngQgPStDrpLPrioPktsL indicates the lower 32 bits of tmnxFPNetIngQgPStDrpLPrioPkts.')
tmnxFPNetIngQgPStDrpLPrioPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioPktsH.setDescription('The value of tmnxFPNetIngQgPStDrpLPrioPktsH indicates the upper 32 bits of tmnxFPNetIngQgPStDrpLPrioPkts.')
tmnxFPNetIngQgPStOffHPrioOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioOcts.setDescription('The value of tmnxFPNetIngQgPStOffHPrioOcts indicates the number of high priority octets, as determined by the ingress queue group policer, offered by the Pchip to the Qchip.')
tmnxFPNetIngQgPStOffHPrioOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioOctsL.setDescription('The value of tmnxFPNetIngQgPStOffHPrioOctsL indicates the lower 32 bits of tmnxFPNetIngQgPStOffHPrioOcts.')
tmnxFPNetIngQgPStOffHPrioOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffHPrioOctsH.setDescription('The value of tmnxFPNetIngQgPStOffHPrioOctsH indicates the upper 32 bits of tmnxFPNetIngQgPStOffHPrioOcts.')
tmnxFPNetIngQgPStDrpHPrioOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioOcts.setDescription('The value of tmnxFPNetIngQgPStDrpHPrioOcts indicates the number of high priority octets, as determined by the ingress queue group policer, dropped by the Pchip due to: MBS exceeded, buffer pool limit exceeded, etc.')
tmnxFPNetIngQgPStDrpHPrioOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioOctsL.setDescription('The value of tmnxFPNetIngQgPStDrpHPrioOctsL indicates the lower 32 bits of tmnxFPNetIngQgPStDrpHPrioOcts.')
tmnxFPNetIngQgPStDrpHPrioOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpHPrioOctsH.setDescription('The value of tmnxFPNetIngQgPStDrpHPrioOctsH indicates the upper 32 bits of tmnxFPNetIngQgPStDrpHPrioOcts.')
tmnxFPNetIngQgPStOffLPrioOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioOcts.setDescription('The value of tmnxFPNetIngQgPStOffLPrioOcts indicates the number of low priority octets, as determined by the ingress queue group policer, offered by the Pchip to the Pchip.')
tmnxFPNetIngQgPStOffLPrioOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioOctsL.setDescription('The value of tmnxFPNetIngQgPStOffLPrioOctsL indicates the lower 32 bits of tmnxFPNetIngQgPStOffLPrioOcts.')
tmnxFPNetIngQgPStOffLPrioOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStOffLPrioOctsH.setDescription('The value of tmnxFPNetIngQgPStOffLPrioOctsH indicates the upper 32 bits of tmnxFPNetIngQgPStOffLPrioOcts.')
tmnxFPNetIngQgPStDrpLPrioOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioOcts.setDescription('The value of tmnxFPNetIngQgPStDrpLPrioOcts indicates the number of low priority octets, as determined by the ingress queue group policer, dropped by the Pchip due to: MBS exceeded, buffer pool limit exceeded, etc.')
tmnxFPNetIngQgPStDrpLPrioOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioOctsL.setDescription('The value of tmnxFPNetIngQgPStDrpLPrioOctsL indicates the lower 32 bits of tmnxFPNetIngQgPStDrpLPrioOcts.')
tmnxFPNetIngQgPStDrpLPrioOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStDrpLPrioOctsH.setDescription('The value of tmnxFPNetIngQgPStDrpLPrioOctsH indicates the upper 32 bits of tmnxFPNetIngQgPStDrpLPrioOcts.')
tmnxFPNetIngQgPStFwdInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfPkts.setDescription('The value of tmnxFPNetIngQgPStFwdInProfPkts indicates the number of in-profile packets (rate below CIR) forwarded by the ingress Pchip.')
tmnxFPNetIngQgPStFwdInProfPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfPktsL.setDescription('The value of tmnxFPNetIngQgPStFwdInProfPktsL indicates the lower 32 bits of tmnxFPNetIngQgPStFwdInProfPkts.')
tmnxFPNetIngQgPStFwdInProfPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfPktsH.setDescription('The value of tmnxFPNetIngQgPStFwdInProfPktsH indicates the upper 32 bits of tmnxFPNetIngQgPStFwdInProfPkts.')
tmnxFPNetIngQgPStFwdOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfPkts.setDescription('The value of tmnxFPNetIngQgPStFwdOutProfPkts indicates the number of out-of-profile packets (rate above CIR) forwarded by the ingress Pchip.')
tmnxFPNetIngQgPStFwdOutProfPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfPktsL.setDescription('The value of tmnxFPNetIngQgPStFwdOutProfPktsL indicates the lower 32 bits of tmnxFPNetIngQgPStFwdOutProfPkts.')
tmnxFPNetIngQgPStFwdOutProfPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfPktsH.setDescription('The value of tmnxFPNetIngQgPStFwdOutProfPktsH indicates the upper 32 bits of tmnxFPNetIngQgPStFwdOutProfPkts.')
tmnxFPNetIngQgPStFwdInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfOcts.setDescription('The value of tmnxFPNetIngQgPStFwdInProfOcts indicates the number of in-profile octets (rate below CIR) forwarded by the ingress Pchip.')
tmnxFPNetIngQgPStFwdInProfOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfOctsL.setDescription('The value of tmnxFPNetIngQgPStFwdInProfOctsL indicates the lower 32 bits of tmnxFPNetIngQgPStFwdInProfOcts.')
tmnxFPNetIngQgPStFwdInProfOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdInProfOctsH.setDescription('The value of tmnxFPNetIngQgPStFwdInProfOctsH indicates the upper 32 bits of tmnxFPNetIngQgPStFwdInProfOcts.')
tmnxFPNetIngQgPStFwdOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 36), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfOcts.setDescription('The value of tmnxFPNetIngQgPStFwdOutProfOcts indicates the number of out-of-profile octets (rate above CIR) forwarded by the ingress Pchip.')
tmnxFPNetIngQgPStFwdOutProfOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfOctsL.setDescription('The value of tmnxFPNetIngQgPStFwdOutProfOctsL indicates the lower 32 bits of tmnxFPNetIngQgPStFwdOutProfOcts.')
tmnxFPNetIngQgPStFwdOutProfOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStFwdOutProfOctsH.setDescription('The value of tmnxFPNetIngQgPStFwdOutProfOctsH indicates the upper 32 bits of tmnxFPNetIngQgPStFwdOutProfOcts.')
tmnxFPNetIngQgPStUncolPktsOff = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 39), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolPktsOff.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolPktsOff.setDescription('The value of tmnxFPNetIngQgPStUncolPktsOff indicates the number of uncolored packets offered to the ingress Pchip.')
tmnxFPNetIngQgPStUncolPktsOffL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolPktsOffL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolPktsOffL.setDescription('The value of tmnxFPNetIngQgPStUncolPktsOffL indicates the lower 32 bits of tmnxFPNetIngQgPStUncolPktsOff.')
tmnxFPNetIngQgPStUncolPktsOffH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolPktsOffH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolPktsOffH.setDescription('The value of tmnxFPNetIngQgPStUncolPktsOffH indicates the upper 32 bits of tmnxFPNetIngQgPStUncolPktsOff.')
tmnxFPNetIngQgPStUncolOctsOff = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 42), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolOctsOff.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolOctsOff.setDescription('The value of tmnxFPNetIngQgPStUncolOctsOff indicates the number of uncolored octets offered to the ingress Pchip.')
tmnxFPNetIngQgPStUncolOctsOffL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolOctsOffL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolOctsOffL.setDescription('The value of tmnxFPNetIngQgPStUncolOctsOffL indicates the lower 32 bits of tmnxFPNetIngQgPStUncolOctsOff.')
tmnxFPNetIngQgPStUncolOctsOffH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 27, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolOctsOffH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPNetIngQgPStUncolOctsOffH.setDescription('The value of tmnxFPNetIngQgPStUncolOctsOffH indicates the higher 32 bits of the value of tmnxFPNetIngQgPStUncolOctsOff.')
tmnxFPAccIngQGrpPStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28), )
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPStatTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPStatTable.setDescription('The value of tmnxFPAccIngQGrpTable contains forwarding-plane ingress QoS queue group policer statistics on access side.')
tmnxFPAccIngQGrpPStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpName"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpInstanceId"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpPStatPolicerId"))
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPStatEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPStatEntry.setDescription('The value of tmnxFPAccIngQGrpPStatEntry defines an entry in the tmnxFPAccIngQGrpPStatTable. It represents statistics about a specific QoS ingress queue group policer.')
tmnxFPAccIngQGrpPStatPolicerId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 1), TIngPolicerId())
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPStatPolicerId.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPStatPolicerId.setDescription('The value of tmnxFPAccIngQGrpPStatPolicerId specifies the index of the ingress QoS policer of this forwarding-plane queue group on access.')
tmnxFPAccIngQGrpPStatMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 2), TmnxIngPolicerStatMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPStatMode.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQGrpPStatMode.setDescription('The value of tmnxFPAccIngQGrpPStatMode indicates the stat mode used by this policer.')
tmnxFPAccIngQgPStOffHPrioPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioPkts.setDescription('The value of tmnxFPAccIngQgPStOffHPrioPkts indicates the number of high priority packets, as determined by the ingress queue group policer, offered by the Pchip to the Qchip.')
tmnxFPAccIngQgPStOffHPrioPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioPktsL.setDescription('The value of tmnxFPAccIngQgPStOffHPrioPktsL indicates the lower 32 bits of tmnxFPAccIngQgPStOffHPrioPkts.')
tmnxFPAccIngQgPStOffHPrioPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioPktsH.setDescription('The value of tmnxFPAccIngQgPStOffHPrioPktsH indicates the upper 32 bits of tmnxFPAccIngQgPStOffHPrioPkts.')
tmnxFPAccIngQgPStDrpHPrioPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioPkts.setDescription('The value of tmnxFPAccIngQgPStDrpHPrioPkts indicates the number of high priority packets, as determined by the ingress queue group policer, dropped by the Pchip due to: MBS exceeded, buffer pool limit exceeded, etc.')
tmnxFPAccIngQgPStDrpHPrioPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioPktsL.setDescription('The value of tmnxFPAccIngQgPStDrpHPrioPktsL indicates the lower 32 bits of tmnxFPAccIngQgPStDrpHPrioPkts.')
tmnxFPAccIngQgPStDrpHPrioPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioPktsH.setDescription('The value of tmnxFPAccIngQgPStDrpHPrioPktsH indicates the upper 32 bits of tmnxFPAccIngQgPStDrpHPrioPkts.')
tmnxFPAccIngQgPStOffLPrioPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioPkts.setDescription('The value of tmnxFPAccIngQgPStOffLPrioPkts indicates the number of low priority packets, as determined by the ingress queue group policer, offered by the Pchip to the Qchip.')
tmnxFPAccIngQgPStOffLPrioPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioPktsL.setDescription('The value of tmnxFPAccIngQgPStOffLPrioPktsL indicates the lower 32 bits of tmnxFPAccIngQgPStOffLPrioPkts.')
tmnxFPAccIngQgPStOffLPrioPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioPktsH.setDescription('The value of tmnxFPAccIngQgPStOffLPrioPktsH indicates the upper 32 bits of tmnxFPAccIngQgPStOffLPrioPkts.')
tmnxFPAccIngQgPStDrpLPrioPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioPkts.setDescription('The value of tmnxFPAccIngQgPStDrpLPrioPkts indicates the number of low priority packets, as determined by the ingress queue group policer, dropped by the Pchip due to: MBS exceeded, buffer pool limit exceeded, etc.')
tmnxFPAccIngQgPStDrpLPrioPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioPktsL.setDescription('The value of tmnxFPAccIngQgPStDrpLPrioPktsL indicates the lower 32 bits of tmnxFPAccIngQgPStDrpLPrioPkts.')
tmnxFPAccIngQgPStDrpLPrioPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioPktsH.setDescription('The value of tmnxFPAccIngQgPStDrpLPrioPktsH indicates the upper 32 bits of tmnxFPAccIngQgPStDrpLPrioPkts.')
tmnxFPAccIngQgPStOffHPrioOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioOcts.setDescription('The value of tmnxFPAccIngQgPStOffHPrioOcts indicates the number of high priority octets, as determined by the ingress queue group policer, offered by the Pchip to the Qchip.')
tmnxFPAccIngQgPStOffHPrioOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioOctsL.setDescription('The value of tmnxFPAccIngQgPStOffHPrioOctsL indicates the lower 32 bits of tmnxFPAccIngQgPStOffHPrioOcts.')
tmnxFPAccIngQgPStOffHPrioOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffHPrioOctsH.setDescription('The value of tmnxFPAccIngQgPStOffHPrioOctsH indicates the upper 32 bits of tmnxFPAccIngQgPStOffHPrioOcts.')
tmnxFPAccIngQgPStDrpHPrioOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioOcts.setDescription('The value of tmnxFPAccIngQgPStDrpHPrioOcts indicates the number of high priority octets, as determined by the ingress queue group policer, dropped by the Pchip due to: MBS exceeded, buffer pool limit exceeded, etc.')
tmnxFPAccIngQgPStDrpHPrioOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioOctsL.setDescription('The value of tmnxFPAccIngQgPStDrpHPrioOctsL indicates the lower 32 bits of tmnxFPAccIngQgPStDrpHPrioOcts.')
tmnxFPAccIngQgPStDrpHPrioOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpHPrioOctsH.setDescription('The value of tmnxFPAccIngQgPStDrpHPrioOctsH indicates the upper 32 bits of tmnxFPAccIngQgPStDrpHPrioOcts.')
tmnxFPAccIngQgPStOffLPrioOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioOcts.setDescription('The value of tmnxFPAccIngQgPStOffLPrioOcts indicates the number of low priority octets, as determined by the ingress queue group policer, offered by the Pchip to the Pchip.')
tmnxFPAccIngQgPStOffLPrioOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioOctsL.setDescription('The value of tmnxFPAccIngQgPStOffLPrioOctsL indicates the lower 32 bits of tmnxFPAccIngQgPStOffLPrioOcts.')
tmnxFPAccIngQgPStOffLPrioOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStOffLPrioOctsH.setDescription('The value of tmnxFPAccIngQgPStOffLPrioOctsH indicates the upper 32 bits of tmnxFPAccIngQgPStOffLPrioOcts.')
tmnxFPAccIngQgPStDrpLPrioOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioOcts.setDescription('The value of tmnxFPAccIngQgPStDrpLPrioOcts indicates the number of low priority octets, as determined by the ingress queue group policer, dropped by the Pchip due to: MBS exceeded, buffer pool limit exceeded, etc.')
tmnxFPAccIngQgPStDrpLPrioOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioOctsL.setDescription('The value of tmnxFPAccIngQgPStDrpLPrioOctsL indicates the lower 32 bits of tmnxFPAccIngQgPStDrpLPrioOcts.')
tmnxFPAccIngQgPStDrpLPrioOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStDrpLPrioOctsH.setDescription('The value of tmnxFPAccIngQgPStDrpLPrioOctsH indicates the upper 32 bits of tmnxFPAccIngQgPStDrpLPrioOcts.')
tmnxFPAccIngQgPStFwdInProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfPkts.setDescription('The value of tmnxFPAccIngQgPStFwdInProfPkts indicates the number of in-profile packets (rate below CIR) forwarded by the ingress Pchip.')
tmnxFPAccIngQgPStFwdInProfPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfPktsL.setDescription('The value of tmnxFPAccIngQgPStFwdInProfPktsL indicates the lower 32 bits of tmnxFPAccIngQgPStFwdInProfPkts.')
tmnxFPAccIngQgPStFwdInProfPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfPktsH.setDescription('The value of tmnxFPAccIngQgPStFwdInProfPktsH indicates the upper 32 bits of tmnxFPAccIngQgPStFwdInProfPkts.')
tmnxFPAccIngQgPStFwdOutProfPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfPkts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfPkts.setDescription('The value of tmnxFPAccIngQgPStFwdOutProfPkts indicates the number of out-of-profile packets (rate above CIR) forwarded by the ingress Pchip.')
tmnxFPAccIngQgPStFwdOutProfPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfPktsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfPktsL.setDescription('The value of tmnxFPAccIngQgPStFwdOutProfPktsL indicates the lower 32 bits of tmnxFPAccIngQgPStFwdOutProfPkts.')
tmnxFPAccIngQgPStFwdOutProfPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfPktsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfPktsH.setDescription('The value of tmnxFPAccIngQgPStFwdOutProfPktsH indicates the upper 32 bits of tmnxFPAccIngQgPStFwdOutProfPkts.')
tmnxFPAccIngQgPStFwdInProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfOcts.setDescription('The value of tmnxFPAccIngQgPStFwdInProfOcts indicates the number of in-profile octets (rate below CIR) forwarded by the ingress Pchip.')
tmnxFPAccIngQgPStFwdInProfOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfOctsL.setDescription('The value of tmnxFPAccIngQgPStFwdInProfOctsL indicates the lower 32 bits of tmnxFPAccIngQgPStFwdInProfOcts.')
tmnxFPAccIngQgPStFwdInProfOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdInProfOctsH.setDescription('The value of tmnxFPAccIngQgPStFwdInProfOctsH indicates the upper 32 bits of tmnxFPAccIngQgPStFwdInProfOcts.')
tmnxFPAccIngQgPStFwdOutProfOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 36), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfOcts.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfOcts.setDescription('The value of tmnxFPAccIngQgPStFwdOutProfOcts indicates the number of out-of-profile octets (rate above CIR) forwarded by the ingress Pchip.')
tmnxFPAccIngQgPStFwdOutProfOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfOctsL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfOctsL.setDescription('The value of tmnxFPAccIngQgPStFwdOutProfOctsL indicates the lower 32 bits of tmnxFPAccIngQgPStFwdOutProfOcts.')
tmnxFPAccIngQgPStFwdOutProfOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfOctsH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStFwdOutProfOctsH.setDescription('The value of tmnxFPAccIngQgPStFwdOutProfOctsH indicates the upper 32 bits of tmnxFPAccIngQgPStFwdOutProfOcts.')
tmnxFPAccIngQgPStUncolPktsOff = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 39), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolPktsOff.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolPktsOff.setDescription('The value of tmnxFPAccIngQgPStUncolPktsOff indicates the number of uncolored packets offered to the ingress Pchip.')
tmnxFPAccIngQgPStUncolPktsOffL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolPktsOffL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolPktsOffL.setDescription('The value of tmnxFPAccIngQgPStUncolPktsOffL indicates the lower 32 bits of tmnxFPAccIngQgPStUncolPktsOff.')
tmnxFPAccIngQgPStUncolPktsOffH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolPktsOffH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolPktsOffH.setDescription('The value of tmnxFPAccIngQgPStUncolPktsOffH indicates the upper 32 bits of tmnxFPAccIngQgPStUncolPktsOff.')
tmnxFPAccIngQgPStUncolOctsOff = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 42), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolOctsOff.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolOctsOff.setDescription('The value of tmnxFPAccIngQgPStUncolOctsOff indicates the number of uncolored octets offered to the ingress Pchip.')
tmnxFPAccIngQgPStUncolOctsOffL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolOctsOffL.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolOctsOffL.setDescription('The value of tmnxFPAccIngQgPStUncolOctsOffL indicates the lower 32 bits of tmnxFPAccIngQgPStUncolOctsOff.')
tmnxFPAccIngQgPStUncolOctsOffH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 28, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolOctsOffH.setStatus('current')
if mibBuilder.loadTexts: tmnxFPAccIngQgPStUncolOctsOffH.setDescription('The value of tmnxFPAccIngQgPStUncolOctsOffH indicates the higher 32 bits of the value of tmnxFPAccIngQgPStUncolOctsOff.')
tFPAccIngQGrpPlcrOvrTblLstChgd = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 29), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrTblLstChgd.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrTblLstChgd.setDescription('The value of tFPAccIngQGrpPlcrOvrTblLstChgd indicates the timestamp of last change to the tFPAccIngQGrpPlcrOvrTable.')
tFPAccIngQGrpPlcrOvrTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30), )
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrTable.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrTable.setDescription('The value of tFPAccIngQGrpPlcrOvrTable contains forwarding-plane QoS ingress queue group policer overrides on access side.')
tFPAccIngQGrpPlcrOvrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpName"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpInstanceId"), (0, "TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrPolicerId"))
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrEntry.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrEntry.setDescription('The value of tmnxFPAccIngQGrpPStatEntry defines an entry in the tFPAccIngQGrpPlcrOvrTable. It represents policer overrides about a specific forwarding-plane QoS ingress queue group policer.')
tFPAccIngQGrpPlcrOvrPolicerId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 1), TIngPolicerId())
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrPolicerId.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrPolicerId.setDescription('The value of tFPAccIngQGrpPlcrOvrPolicerId specifies the index of the ingress QoS policer of this forwarding-plane queue group on access.')
tFPAccIngQGrpPlcrOvrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrRowStatus.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrRowStatus.setDescription('The value of tFPAccIngQGrpPlcrOvrRowStatus specifies the Row Status of the entry. This tFPAccIngQGrpPlcrOvrRowStatus object allows creation/deletion of rows in this table.')
tFPAccIngQGrpPlcrOvrLastChgd = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrLastChgd.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrLastChgd.setDescription('The value of tFPAccIngQGrpPlcrOvrLastChgd indicates the timestamp of last change to this row in tFPAccIngQGrpPlcrOvrTable.')
tFPAccIngQGrpPlcrOvrAdminPIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 4), THPolPIRRateOverride().clone(-2)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrAdminPIR.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrAdminPIR.setDescription('The value of tFPAccIngQGrpPlcrOvrAdminPIR specifies the administrative PIR specified by the user.')
tFPAccIngQGrpPlcrOvrAdminCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 5), THPolCIRRateOverride().clone(-2)).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrAdminCIR.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrAdminCIR.setDescription('The value of tFPAccIngQGrpPlcrOvrAdminCIR specifies the administrative CIR specified by the user.')
tFPAccIngQGrpPlcrOvrStatMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 6), TmnxIngPolicerStatModeOverride().clone('noOverride')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrStatMode.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrStatMode.setDescription('The value of tFPAccIngQGrpPlcrOvrStatMode specifies the mode of statistics collected by the policer on this forwarding-plane QoS ingress queue group.')
tFPAccIngQGrpPlcrOvrMBS = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 7), TPlcrBurstSizeBytesOverride().clone(-2)).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrMBS.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrMBS.setDescription('The value of tFPAccIngQGrpPlcrOvrMBS specifies the maximum amount of buffer space (in bytes) allowed for the queue by the policer on this forwarding-plane QoS ingress queue group.')
tFPAccIngQGrpPlcrOvrCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 8), TPlcrBurstSizeBytesOverride().clone(-2)).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrCBS.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrCBS.setDescription('The value of tFPAccIngQGrpPlcrOvrCBS specifies the amount of reserved buffer space (in bytes) set by the policer on this forwarding-plane QoS ingress queue group.')
tFPAccIngQGrpPlcrOvrPktOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 30, 1, 9), TPerPacketOffsetOvr().clone(-128)).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrPktOffset.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpPlcrOvrPktOffset.setDescription('The value of tFPAccIngQGrpPlcrOvrPktOffset specifies the packet byte offset for addition of policing information by the policer on this forwarding-plane QoS ingress queue group.')
tFPAccIngQGrpArbitStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31), )
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatTable.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatTable.setDescription('The value of tFPAccIngQGrpArbitStatTable contains forwarding-plane ingress QoS queue group policer statistics on access side.')
tFPAccIngQGrpArbitStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpName"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpInstanceId"), (0, "TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpArbitStatName"))
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatEntry.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatEntry.setDescription('The value of tFPAccIngQGrpArbitStatEntry defines an entry in the tFPAccIngQGrpArbitStatTable. It represents statistics about a specific QoS ingress queue group policer.')
tFPAccIngQGrpArbitStatName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31, 1, 1), TNamedItem())
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatName.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatName.setDescription('The value of tFPAccIngQGrpArbitStatName specifies the name of the ingress QoS arbiter of this forwarding-plane queue group on access.')
tFPAccIngQGrpArbitStatFwdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdPkts.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdPkts.setDescription('The value of tFPAccIngQGrpArbitStatFwdPkts indicates the number of fowrwarded packets by the ingress queue group arbiter Pchip.')
tFPAccIngQGrpArbitStatFwdPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdPktsL.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdPktsL.setDescription('The value of tFPAccIngQGrpArbitStatFwdPktsL indicates the lower 32 bits of tFPAccIngQGrpArbitStatFwdPkts.')
tFPAccIngQGrpArbitStatFwdPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdPktsH.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdPktsH.setDescription('The value of tFPAccIngQGrpArbitStatFwdPktsH indicates the upper 32 bits of tFPAccIngQGrpArbitStatFwdPkts.')
tFPAccIngQGrpArbitStatFwdOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdOcts.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdOcts.setDescription('The value of tFPAccIngQGrpArbitStatFwdOcts indicates the number of fowrwarded octets by the ingress queue group arbiter Pchip.')
tFPAccIngQGrpArbitStatFwdOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdOctsL.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdOctsL.setDescription('The value of tFPAccIngQGrpArbitStatFwdOctsL indicates the lower 32 bits of tFPAccIngQGrpArbitStatFwdOcts.')
tFPAccIngQGrpArbitStatFwdOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 31, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdOctsH.setStatus('current')
if mibBuilder.loadTexts: tFPAccIngQGrpArbitStatFwdOctsH.setDescription('The value of tFPAccIngQGrpArbitStatFwdOctsH indicates the upper 32 bits of tFPAccIngQGrpArbitStatFwdOcts.')
tFPNetIngQGrpArbitStatTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32), )
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatTable.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatTable.setDescription('The value of tFPNetIngQGrpArbitStatTable contains forwarding-plane ingress QoS queue group arbiter statistics on network side.')
tFPNetIngQGrpArbitStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNum"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpName"), (0, "TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpInstanceId"), (0, "TIMETRA-CHASSIS-MIB", "tFPNetIngQGrpArbitStatName"))
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatEntry.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatEntry.setDescription('The value of tFPNetIngQGrpArbitStatEntry defines an entry in the tFPNetIngQGrpArbitStatTable. It represents statistics about a specific QoS ingress queue group arbiter.')
tFPNetIngQGrpArbitStatName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32, 1, 1), TNamedItem())
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatName.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatName.setDescription('The value of tFPNetIngQGrpArbitStatName specifies the name of the ingress QoS arbiter of this forwarding-plane queue group on network.')
tFPNetIngQGrpArbitStatFwdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdPkts.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdPkts.setDescription('The value of tFPNetIngQGrpArbitStatFwdPkts indicates the number of fowrwarded packets by the ingress queue group arbiter Pchip.')
tFPNetIngQGrpArbitStatFwdPktsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdPktsL.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdPktsL.setDescription('The value of tFPNetIngQGrpArbitStatFwdPktsL indicates the lower 32 bits of tFPNetIngQGrpArbitStatFwdPkts.')
tFPNetIngQGrpArbitStatFwdPktsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdPktsH.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdPktsH.setDescription('The value of tFPNetIngQGrpArbitStatFwdPktsH indicates the upper 32 bits of tFPNetIngQGrpArbitStatFwdPkts.')
tFPNetIngQGrpArbitStatFwdOcts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdOcts.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdOcts.setDescription('The value of tFPNetIngQGrpArbitStatFwdOcts indicates the number of fowrwarded octets by the ingress queue group arbiter Pchip.')
tFPNetIngQGrpArbitStatFwdOctsL = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdOctsL.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdOctsL.setDescription('The value of tFPNetIngQGrpArbitStatFwdOctsL indicates the lower 32 bits of tFPNetIngQGrpArbitStatFwdOcts.')
tFPNetIngQGrpArbitStatFwdOctsH = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 32, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdOctsH.setStatus('current')
if mibBuilder.loadTexts: tFPNetIngQGrpArbitStatFwdOctsH.setDescription('The value of tFPNetIngQGrpArbitStatFwdOctsH indicates the upper 32 bits of tFPNetIngQGrpArbitStatFwdOcts.')
tmnxVirtualSchedulerAdjTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 33), )
if mibBuilder.loadTexts: tmnxVirtualSchedulerAdjTable.setStatus('current')
if mibBuilder.loadTexts: tmnxVirtualSchedulerAdjTable.setDescription('The tmnxVirtualSchedulerAdjTable has an entry to fine tune Quality of Service (QoS) parameters.')
tmnxVirtualSchedulerAdjEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 33, 1), )
tmnxCardEntry.registerAugmentions(("TIMETRA-CHASSIS-MIB", "tmnxVirtualSchedulerAdjEntry"))
tmnxVirtualSchedulerAdjEntry.setIndexNames(*tmnxCardEntry.getIndexNames())
if mibBuilder.loadTexts: tmnxVirtualSchedulerAdjEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxVirtualSchedulerAdjEntry.setDescription('The tmnxVirtualSchedulerAdjEntry allows fine tune Quality of Service (QoS) parameters on the corresponding card. The row exists only if the associated card instance identified by tmnxCardSlotNum exists in the tmnxCardTable.')
tmnxCardRateCalcFastQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 33, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000)).clone(10000)).setUnits('thousandths of a percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardRateCalcFastQueue.setStatus('current')
if mibBuilder.loadTexts: tmnxCardRateCalcFastQueue.setDescription("The value of tmnxCardRateCalcFastQueue specifies the percentage by which fine tuning of Quality of Service (QoS) parameter 'Fast-Queue' is modified.")
tmnxCardRateCalcSlowQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 33, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000)).clone(10000)).setUnits('thousandths of a percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardRateCalcSlowQueue.setStatus('current')
if mibBuilder.loadTexts: tmnxCardRateCalcSlowQueue.setDescription("The value of tmnxCardRateCalcSlowQueue specifies the percentage by which fine tuning of Quality of Service (QoS) parameter 'Slow-Queue' is modified.")
tmnxCardSchedRun = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 33, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000)).clone(10000)).setUnits('thousandths of a percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardSchedRun.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSchedRun.setDescription('The value of tmnxCardSchedRun specifies the percentage by which the minimum amount of time required between the iterations of bandwidth distribution by an Quality of Service (QoS) virtual scheduler is modified.')
tmnxCardTaskScheduling = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 33, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100000)).clone(10000)).setUnits('thousandths of a percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardTaskScheduling.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTaskScheduling.setDescription('The value of tmnxCardTaskScheduling specifies the percentage change in virtual scheduling task wake up interval.')
tmnxCardSlowQueueThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 33, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000)).clone(1000)).setUnits('kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardSlowQueueThresh.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSlowQueueThresh.setDescription("The value of tmnxCardSlowQueueThresh specifies the rate at which queues are placed in the 'slow-queue' category.")
tmnxFabricTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 26), )
if mibBuilder.loadTexts: tmnxFabricTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricTypeTable.setDescription('The fabric type table has an entry for each Alcatel-Lucent SROS series Fabric card type.')
tmnxFabricTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 26, 1), ).setIndexNames((0, "TIMETRA-CHASSIS-MIB", "tmnxFabricTypeIndex"))
if mibBuilder.loadTexts: tmnxFabricTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricTypeEntry.setDescription('Each row entry represents an Alcatel-Lucent SROS series Fabric card. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxFabricTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 26, 1, 1), TmnxFabricType())
if mibBuilder.loadTexts: tmnxFabricTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricTypeIndex.setDescription('The unique index value which identifies this type of Alcatel-Lucent SROS series Fabric card type.')
tmnxFabricTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 26, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricTypeName.setDescription('The administrative name that identifies this type of Alcatel-Lucent SROS series Fabric card. This name string may be used in CLI commands to specify a particular fabric card type.')
tmnxFabricTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 26, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricTypeDescription.setDescription('A detailed description of this Alcatel-Lucent SROS series Fabric card.')
tmnxFabricTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 26, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricTypeStatus.setDescription("When tmnxFabricTypeStatus has a value of 'true' it indicates that this Fabric is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxEqNotificationRow = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 1), RowPointer()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxEqNotificationRow.setStatus('current')
if mibBuilder.loadTexts: tmnxEqNotificationRow.setDescription('used by tmnx chassis Notifications, the OID indicates the table and entry.')
tmnxEqTypeNotificationRow = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 2), RowPointer()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxEqTypeNotificationRow.setStatus('current')
if mibBuilder.loadTexts: tmnxEqTypeNotificationRow.setDescription('used by tmnx chassis notifications, the OID indicates the table and entry with the equipment model type information.')
tmnxChassisNotifyChassisId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 3), TmnxChassisIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyChassisId.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyChassisId.setDescription('Used by tmnx chassis and port Notifications, indicates the chassis associated with the alarm.')
tmnxChassisNotifyHwIndex = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 4), TmnxHwIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyHwIndex.setDescription('Used by tmnx chassis and port Notifications, indicates the entry in the tmnxHwTable for the hardware component associated with an alarm.')
tmnxRedSecondaryCPMStatus = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("online", 1), ("offline", 2), ("fail", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxRedSecondaryCPMStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxRedSecondaryCPMStatus.setDescription('Used by the tmnxRedSecondaryCPMStatusChange Notification, indicates the status of the secondary CPM.')
tmnxChassisNotifyOID = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 6), ObjectIdentifier()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyOID.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyOID.setDescription('Used by the tmnxChassisNotificationClear trap, the OID identifies the trap which is getting cleared.')
tmnxSyncIfTimingNotifyAlarm = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notUsed", 0), ("los", 1), ("oof", 2), ("oopir", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxSyncIfTimingNotifyAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingNotifyAlarm.setDescription('Used by tmnx Synchronous interface timing notifications, the value of tmnxSyncIfTimingNotifyAlarm indicates the reason a timing reference alarm has been raised.')
tmnxChassisNotifyMismatchedVer = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 8), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyMismatchedVer.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyMismatchedVer.setDescription('Used by tmnxPeSoftwareVersionMismatch, the value of tmnxChassisNotifyMismatchedVer indicates the software version of the mismatched CPM/IOM card.')
tmnxChassisNotifySoftwareLocation = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 9), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifySoftwareLocation.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifySoftwareLocation.setDescription('Used by tmnxPeSoftwareLoadFailed, the value of tmnxChassisNotifySoftwareLocation contains the location of the software.')
tmnxChassisNotifyCardFailureReason = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 10), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyCardFailureReason.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyCardFailureReason.setDescription('Used by tmnxEqCardFailure, the value of tmnxChassisNotifyCardFailureReason contains the reason for card failure.')
tmnxChassisNotifyCardName = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyCardName.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyCardName.setDescription('Used by tmnxEqCardInserted and tmnxEqCardRemoved, the value of tmnxChassisNotifyCardName specifies the name of the affected card.')
tmnxChassisNotifyCardSyncFile = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 12), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyCardSyncFile.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyCardSyncFile.setDescription('Used by tmnxCpmCardSyncFileNotPresent, the value of tmnxChassisNotifyCardSyncFile specifies the name of the affected file.')
tmnxCardComplexNumber = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 13), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxCardComplexNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxCardComplexNumber.setDescription('Used by tmnxEqCardPChipError, the value of tmnxCardComplexNumber specifies the number of the affected Complex.')
tmnxCardFwdDirection = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxCardFwdDirection.setStatus('current')
if mibBuilder.loadTexts: tmnxCardFwdDirection.setDescription('Used by tmnxEqCardPChipError, the value of tmnxCardFwdDirection specifies the direction of the affected Complex.')
tmnxCardSoftResetState = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("initiated", 1), ("aborted", 2), ("complete", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxCardSoftResetState.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSoftResetState.setDescription('Used by tmnxEqCardSoftResetAlarm, the value of tmnxCardSoftResetState specifies the reset state of the IOM card.')
tmnxMdaNotifyType = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 16), TmnxMdaType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxMdaNotifyType.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaNotifyType.setDescription("Used by equipment alarms where the type of MDA isn't supported with the current configuration.")
tmnxCardSrcSlotBitmap = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 17), TmnxCardSlotBitMap()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxCardSrcSlotBitmap.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSrcSlotBitmap.setDescription('Used by tmnxEqCardPChipError, the value of tmnxCardSrcSlotBitmap specifies the source slots of the affected Complex.')
tmnxHwConfigChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 1)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxHwConfigChange.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHwConfigChange.setDescription('A tmnxHwConfigChange notification is generated when the value of tmnxHwLastChange is updated. It can be used by the NMS to trigger maintenance polls of the hardware configuration information. Only one tmnxHwConfigChange notification event will be generated in a 5 second throttling time period. A notification event is the transmission of a single trap to a list of notification destinations configured in the SNMP-TARGET-MIB. If additional hardware configuration change occurs within the throttling period, the notification events for these changes are suppressed until the throttling period expires. At the end of the throttling period, one notification event is generated if any addition configuration changes occurred within the just completed throttling period and another throttling period is started. The NMS should periodically check the value of tmnxHwConfigChange to detect any missed tmnxHwConfigChange traps. This notification was made obsolete in the 2.1 release. The tmnxHwConfigChange notification has been replaced with the generic change notifications from the TIMETRA-SYSTEM-MIB: tmnxConfigModify, tmnxConfigCreate, tmnxConfigDelete, tmnxStateChange.')
tmnxEnvTempTooHigh = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 2)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxHwTemperature"), ("TIMETRA-CHASSIS-MIB", "tmnxHwTempThreshold"))
if mibBuilder.loadTexts: tmnxEnvTempTooHigh.setStatus('current')
if mibBuilder.loadTexts: tmnxEnvTempTooHigh.setDescription('Generated when the temperature sensor reading on an equipment object is greater than its configured threshold.')
tmnxEqPowerSupplyFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 3)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyACStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyDCStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempThreshold"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply1Status"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply2Status"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyInputStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyOutputStatus"))
if mibBuilder.loadTexts: tmnxEqPowerSupplyFailure.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPowerSupplyFailure.setDescription("Generated when one of the chassis's power supplies fails.")
tmnxEqPowerSupplyInserted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 4)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqPowerSupplyInserted.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPowerSupplyInserted.setDescription("Generated when one of the chassis's power supplies is inserted.")
tmnxEqPowerSupplyRemoved = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 5)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqPowerSupplyRemoved.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPowerSupplyRemoved.setDescription("Generated when one of the chassis's power supplies is removed.")
tmnxEqFanFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 6)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisFanOperStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisFanSpeed"))
if mibBuilder.loadTexts: tmnxEqFanFailure.setStatus('current')
if mibBuilder.loadTexts: tmnxEqFanFailure.setDescription('Generated when one of the fans in a fan tray has failed.')
tmnxEqCardFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 7)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxHwOperState"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardFailureReason"))
if mibBuilder.loadTexts: tmnxEqCardFailure.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardFailure.setDescription('Generated when one of the cards in a chassis has failed. The card type may be IOM, Fabric, MDA, MCM, CCM, CPM module, compact flash module, etc. tmnxChassisNotifyCardFailureReason contains the reason for card failure.')
tmnxEqCardInserted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 8)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardName"))
if mibBuilder.loadTexts: tmnxEqCardInserted.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardInserted.setDescription('Generated when a card is inserted into the chassis. The card type may be IOM, Fabric, MDA, MCM, CCM CPM module, compact flash module, etc.')
tmnxEqCardRemoved = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 9)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardName"))
if mibBuilder.loadTexts: tmnxEqCardRemoved.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardRemoved.setDescription('Generated when a card is removed from the chassis. The card type may be IOM, Fabric, MDA, MCM, CCM, CPM module, compact flash module, etc.')
tmnxEqWrongCard = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 10)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqWrongCard.setStatus('current')
if mibBuilder.loadTexts: tmnxEqWrongCard.setDescription('Generated when the wrong type of card is inserted into a slot of the chassis. Even though a card may be physically supported by the slot, it may have been administratively configured to allow only certain card types in a particular slot location. The card type may be IOM, Fabric, MDA, MCM, CPM module, etc.')
tmnxEqCpuFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 11)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqCpuFailure.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqCpuFailure.setDescription('Generated when a failure is detected for a CPU on an IOM card or CPM module. This notification was made obsolete in the 2.1 release. A cpu failure on a CPM card is detected by the hardware bootup and is indicated by the boot diagnostic display. If there is no working redundant CPM card, the system does not come up. A failure of an IOM card or standby redundant CPM card causes the tmnxEqCardFailure notification to be sent.')
tmnxEqMemoryFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 12)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqMemoryFailure.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqMemoryFailure.setDescription("Generated when a memory module failure is detected for an IOM card or CPM module. This notification was made obsolete in the 2.1 release. A failure of the memory device is detected by the hardware bootup and is indicated by the boot diagnostic display. If there is no working redundant CPM card, the system does not come up. A failure of the memory device during run-time causes the system to fail and the 'admin tech-support' information to be saved. A failure of an IOM card or standby redundant CPM card causes the tmnxEqCardFailure notification to be sent.")
tmnxEqBackdoorBusFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 13)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyChassisId"))
if mibBuilder.loadTexts: tmnxEqBackdoorBusFailure.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqBackdoorBusFailure.setDescription('Generated when the backdoor bus has failed. This notification was made obsolete in the 2.1 release.')
tmnxPeSoftwareError = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 14)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeSoftwareError.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeSoftwareError.setDescription("Generated when a software error has been detected. This notification was made obsolete in the 2.1 release. Many of the other notifications more specifically indicate detection of some type of software error. The 'admin tech-support' information helps developers diagnose a failure of the software in the field.")
tmnxPeSoftwareAbnormalHalt = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 15)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeSoftwareAbnormalHalt.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeSoftwareAbnormalHalt.setDescription("Generated when the software has abnormally terminated. This notification was made obsolete in the 2.1 release. Many of the other notifications more specifically indicate detection of some type of software error. The 'admin tech-support' information helps developers diagnose a failure of the software in the field.")
tmnxPeSoftwareVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 16)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeSoftwareVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: tmnxPeSoftwareVersionMismatch.setDescription('Generated when there is a mismatch between software versions of the active CPM and standby CPM or the CPM and IOM. tmnxChassisNotifyHwIndex identifies the mismatched CPM/IOM card and tmnxChassisNotifyMismatchedVer will contain the version of the mismatched card. The tmnxHwSoftwareCodeVersion object will contain the expected version.')
tmnxPeOutOfMemory = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 17)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeOutOfMemory.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeOutOfMemory.setDescription('Generated when there is an out of memory error detected. This notification was made obsolete in the 2.1 release. The tmnxPeOutOfMemory notification has been replaced with the module specific notification from the TIMETRA-SYSTEM-MIB: tmnxModuleMallocFailed.')
tmnxPeConfigurationError = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 18)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeConfigurationError.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeConfigurationError.setDescription("Generated when a configuration error has been detected. This notification was made obsolete in the 2.1 release. Many other notifications more specifically indicate detection of a configuration error. In most cases the SNMP SET request that tries to make an invalid configuration results in an error response. In some cases the configuration parameters are valid and the SNMP SET request succeeds but the system cannot successfully apply the new parameters. The affected object may then put into an operational 'down' state. A state change notification such as tmnxStateChange or a more specific notification is sent to alert about the problem. For example, an attempt to create an event log with a file-type destination when the specified cflash media is full or not present results in TIMETRA-LOG-MIB notifications tmnxLogSpaceContention, tmnxLogAdminLocFailed, or tmnxLogBackupLocFailed.")
tmnxPeStorageProblem = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 19)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeStorageProblem.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeStorageProblem.setDescription("Generated when there is a storage capacity problem. This notification was made obsolete in the 2.1 release. The only 'storage' devices on the SR7750 are the cflash drives. Cflash write errors cause a tmnxEqFlashDataLoss notification to be sent. The tmnxEqFlashDiskFull notification is sent when the driver detects that the cflash device is full.")
tmnxPeCpuCyclesExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 20)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeCpuCyclesExceeded.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeCpuCyclesExceeded.setDescription('Generated when the CPU cycle usage limit has been exceeded. This notification was made obsolete in the 2.1 release. It does not apply. The SR7750 software architecture does not restrict CPU cycles used by a specific code module.')
tmnxRedPrimaryCPMFail = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 21)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxRedPrimaryCPMFail.setStatus('current')
if mibBuilder.loadTexts: tmnxRedPrimaryCPMFail.setDescription('Generated when the primary CPM fails.')
tmnxRedSecondaryCPMStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 22)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxRedSecondaryCPMStatus"))
if mibBuilder.loadTexts: tmnxRedSecondaryCPMStatusChange.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxRedSecondaryCPMStatusChange.setDescription('Generated when there is a change in the secondary CPM status. This notification was made obsolete in the 2.1 release. There is no way to administratively enable or disable CPM cards so there is no need for a status change event for administrative state changes. Operational changes detected about the standby CPM card are indicated by more specific notifications such as tmnxEqCardFailure, tmnxEqCardRemoved, tmnxEqCardInserted TIMETRA-SYSTEM-MIB::ssiRedStandbyReady, TIMETRA-SYSTEM-MIB::ssiRedStandbySyncLost, and TIMETRA-SYSTEM-MIB::ssiRedStandbySyncLost.')
tmnxRedRestoreSuccess = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 23)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxRedRestoreSuccess.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxRedRestoreSuccess.setDescription('Generated when the secondary CPM successfully restores the config and state. This notification was made obsolete in the 2.1 release. It does not apply. This event was originally created for an early redundancy mechanism that was never released.')
tmnxRedRestoreFail = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 24)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxRedRestoreFail.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxRedRestoreFail.setDescription('Generated when the secondary CPM fails to restore the config and state. This notification was made obsolete in the 2.1 release. It does not apply. This event was originally created for an early redundancy mechanism that was never released.')
tmnxChassisNotificationClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 25)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyOID"))
if mibBuilder.loadTexts: tmnxChassisNotificationClear.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotificationClear.setDescription('A trap indicating the clear of a chassis notification identified by tmnxChassisNotifyOID.')
tmnxEqSyncIfTimingHoldover = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 26)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingHoldover.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingHoldover.setDescription('Generated when the synchronous equipment timing subsystem transitions into a holdover state. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingHoldoverClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 27)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingHoldoverClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingHoldoverClear.setDescription('Generated when the synchronous equipment timing subsystem transitions out of the holdover state. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingRef1Alarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 28)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1Alarm.setDescription('Generated when an alarm condition on the first timing reference is detected. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingRef1AlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 29)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1AlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1AlarmClear.setDescription('Generated when an alarm condition on the first timing reference is cleared. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingRef2Alarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 30)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2Alarm.setDescription('Generated when an alarm condition on the second timing reference is detected. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingRef2AlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 31)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2AlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2AlarmClear.setDescription('Generated when an alarm condition on the second timing reference is cleared. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqFlashDataLoss = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 32)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxHwOperState"))
if mibBuilder.loadTexts: tmnxEqFlashDataLoss.setStatus('current')
if mibBuilder.loadTexts: tmnxEqFlashDataLoss.setDescription('tmnxEqFlashDataLoss is generated when there was an error while data was getting written on to the compact flash. This notification indicates a probable data loss.')
tmnxEqFlashDiskFull = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 33)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxHwOperState"))
if mibBuilder.loadTexts: tmnxEqFlashDiskFull.setStatus('current')
if mibBuilder.loadTexts: tmnxEqFlashDiskFull.setDescription('tmnxEqFlashDiskFull is generated when there is no space left on the compact flash. No more data can be written to it.')
tmnxPeSoftwareLoadFailed = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 34)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifySoftwareLocation"))
if mibBuilder.loadTexts: tmnxPeSoftwareLoadFailed.setStatus('current')
if mibBuilder.loadTexts: tmnxPeSoftwareLoadFailed.setDescription('Generated when the CPM fails to load the software from a specified location. tmnxChassisNotifyHwIndex identifies the card for which the software load failed and tmnxChassisNotifySoftwareLocation contains the location from where the software load was attempted.')
tmnxPeBootloaderVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 35)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeBootloaderVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: tmnxPeBootloaderVersionMismatch.setDescription('Generated when there is a mismatch between the CPM and boot loader versions. tmnxChassisNotifyHwIndex identifies the CPM card. tmnxChassisNotifyMismatchedVer contains the mismatched version of bootloader and tmnxHwSoftwareCodeVersion contains the expected version of the bootloader.')
tmnxPeBootromVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 36)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeBootromVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: tmnxPeBootromVersionMismatch.setDescription('Generated when there is a mismatch between the boot rom versions. tmnxChassisNotifyHwIndex identifies the IOM card. tmnxChassisNotifyMismatchedVer contains the mismatched version of bootrom and tmnxHwSoftwareCodeVersion contains the expected version of the bootrom.')
tmnxPeFPGAVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 37)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeFPGAVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: tmnxPeFPGAVersionMismatch.setDescription('Generated when there is a mismatch between the FPGA versions. tmnxChassisNotifyHwIndex identifies the IOM card. tmnxChassisNotifyMismatchedVer contains the mismatched version of FPGA and tmnxHwSoftwareCodeVersion contains the expected version of the FPGA.')
tmnxEqSyncIfTimingBITSAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 38)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSAlarm.setDescription('Generated when an alarm condition on the BITS timing reference is detected. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingBITSAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 39)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSAlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSAlarmClear.setDescription('Generated when an alarm condition on the BITS timing reference is cleared. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqCardFirmwareUpgraded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 40)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqCardFirmwareUpgraded.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardFirmwareUpgraded.setDescription('Generated when a card is hot-inserted into the chassis and its firmware is automatically upgraded. The card type may be IOM or CPM module.')
tmnxChassisUpgradeInProgress = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 41)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxChassisUpgradeInProgress.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUpgradeInProgress.setDescription('The tmnxChassisUpgradeInProgress notification is generated only after a CPM switchover occurs and the new active CPM is running new software, while the IOMs are still running old software. This is the start of the upgrade process. The tmnxChassisUpgradeInProgress notification will continue to be generated every 30 minutes while at least one IOM is still running older software.')
tmnxChassisUpgradeComplete = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 42)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxChassisUpgradeComplete.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUpgradeComplete.setDescription('The tmnxChassisUpgradeComplete notification is generated to indicate that all the IOMs are running matching software version in reference to the active CPM software version changed as part of the upgrade process.')
tmnxChassisHiBwMcastAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 43)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxChassisHiBwMcastAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisHiBwMcastAlarm.setDescription('The tmnxChassisHiBwMcastAlarm notification is generated when a plane is shared by more than one high bandwidth multicast tap.')
tmnxEqMdaCfgNotCompatible = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 44)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaNotifyType"))
if mibBuilder.loadTexts: tmnxEqMdaCfgNotCompatible.setStatus('current')
if mibBuilder.loadTexts: tmnxEqMdaCfgNotCompatible.setDescription("Generated when a supported MDA is inserted into a slot of an IOM, the MDA is compatible with the currently provisioned MDA, but the current configuration on the MDA's ports is not compatible with the inserted MDA. [EFFECT] Though services can still be created, if the tmnxMdaNotifyType is the same as the tmnxMDAEquippedType then the MDA will fail to operate as configured and will be in a failed state. [RECOVERY] Change the configuration to reflect the capabilities of the MDA port, or switch out/re-provision the MDA for one that is compatible.")
tmnxCpmCardSyncFileNotPresent = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 45)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardSyncFile"))
if mibBuilder.loadTexts: tmnxCpmCardSyncFileNotPresent.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardSyncFileNotPresent.setDescription('The tmnxCpmCardSyncFileNotPresent notification is generated when the redundancy file synchronization failed to locate an optional file.')
tmnxEqMdaXplError = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 46)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAXplFailedCount"))
if mibBuilder.loadTexts: tmnxEqMdaXplError.setStatus('current')
if mibBuilder.loadTexts: tmnxEqMdaXplError.setDescription('The tmnxEqMdaXplError notification is generated when an MDA exhibits persistent XPL Errors.')
tmnxEqCardPChipError = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 47)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxCardComplexNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxCardFwdDirection"), ("TIMETRA-CHASSIS-MIB", "tmnxCardSrcSlotBitmap"))
if mibBuilder.loadTexts: tmnxEqCardPChipError.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardPChipError.setDescription('The tmnxEqCardPChipError notification is generated when persistent FCS errors are detected by the P chip in either the ingress or egress datapath/complex. The value tmnxCardSrcSlotBitmap is only used for the egress datapath/complex direction.')
tmnxEqCardSoftResetAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 48)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxCardSoftResetState"))
if mibBuilder.loadTexts: tmnxEqCardSoftResetAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardSoftResetAlarm.setDescription("The tmnxEqCardSoftResetAlarm notification is generated when an IOM card enters and exits the 'soft-reset' state.")
tmnxEqMdaSyncENotCompatible = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 49)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaNotifyType"))
if mibBuilder.loadTexts: tmnxEqMdaSyncENotCompatible.setStatus('current')
if mibBuilder.loadTexts: tmnxEqMdaSyncENotCompatible.setDescription('The tmnxEqMdaSyncENotCompatible notification is generated when an MDA card is inserted into a slot of an IOM. The MDA is compatible with the currently provisioned MDA, but the currently configured synchronous ethernet, tmnxMDASynchronousEthernet, is not compatible with the inserted MDA. [EFFECT] Though services can still be created, if the tmnxMdaNotifyType is the same as the tmnxMDAEquippedType then the MDA will fail to operate as configured and will be in a failed state. [RECOVERY] Change the configuration to reflect the capabilities of the MDA port, or switch out/re-provision the MDA for one that is compatible.')
tmnxIPsecIsaGrpActiveIsaChgd = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 50)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpPrimaryIsa"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpBackupIsa"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpActiveIsa"))
if mibBuilder.loadTexts: tmnxIPsecIsaGrpActiveIsaChgd.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpActiveIsaChgd.setDescription('The tmnxIPsecIsaGrpActiveIsaChgd notification is generated when a change in the active ISA (Integrated Service Adaptor) occurs in a IPsec ISA module group.')
tmnxEqCardPChipMemoryEvent = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 51)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxCardComplexNumber"))
if mibBuilder.loadTexts: tmnxEqCardPChipMemoryEvent.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardPChipMemoryEvent.setDescription('The tmnxEqCardPChipMemoryEvent notification is generated when a P-chip experiences an occurrence of a memory parity error.')
tmnxIPsecIsaGrpUnableToSwitch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 52)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpActiveIsa"))
if mibBuilder.loadTexts: tmnxIPsecIsaGrpUnableToSwitch.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpUnableToSwitch.setDescription("The tmnxIPsecIsaGrpUnableToSwitch notification is generated when an IPsec ISA (Integrated Service Adaptor) module group is unable to switch due to lack of resources. In such an event the ISA group is left without an active MDA and the tmnxIPsecIsaGrpOperState is set to 'outOfService'. Recovery is possible by releasing resources, and setting the tmnxIPsecIsaGrpAdminState object to 'outOfService' followed by a reset to 'inService' to bring up the ISA group.")
tmnxIPsecIsaGrpTnlLowWMark = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 53)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTunnels"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpMaxTunnels"))
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTnlLowWMark.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTnlLowWMark.setDescription('The tmnxIPsecIsaGrpTnlLowWMark notification is generated when number of tunnels for an IPsec ISA (Integrated Service Adaptor) module has dropped to the low watermark which is 90% of the tmnxIPsecIsaGrpMaxTunnels.')
tmnxIPsecIsaGrpTnlHighWMark = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 54)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTunnels"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpMaxTunnels"))
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTnlHighWMark.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTnlHighWMark.setDescription('The tmnxIPsecIsaGrpTnlHighWMark notification is generated when number of tunnels for an IPsec ISA (Integrated Service Adaptor) module has reached to the high watermark which is 95% of the tmnxIPsecIsaGrpMaxTunnels.')
tmnxIPsecIsaGrpTnlMax = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 55)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTunnels"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpMaxTunnels"))
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTnlMax.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpTnlMax.setDescription('The tmnxIPsecIsaGrpTnlMax notification is generated when number of tunnels for an IPsec ISA (Integrated Service Adaptor) module has reached the maximum of the tmnxIPsecIsaGrpMaxTunnels.')
tmnxEqSyncIfTimingRef1Quality = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 56)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1RxQltyLevel"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1Quality.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1Quality.setDescription('Generated when there is a change of the received quality level on timing reference 1.')
tmnxEqSyncIfTimingRef2Quality = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 57)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2RxQltyLevel"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2Quality.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2Quality.setDescription('Generated when there is a change of the received quality level on timing reference 2.')
tmnxEqSyncIfTimingBITSQuality = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 58)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSRxQltyLevel"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSQuality.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSQuality.setDescription('Generated when there is a change of the received quality level on the bits interface.')
tmnxEqSyncIfTimingBITS2Quality = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 59)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2RxQltyLevel"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITS2Quality.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITS2Quality.setDescription('Generated when there is a change of the received quality level on the second bits interface.')
tmnxEqSyncIfTimingRefSwitch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 60)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1InUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2InUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSInUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2InUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPInUse"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRefSwitch.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRefSwitch.setDescription('Generated when there is a change of which timing reference is providing timing for the system.')
tmnxEqSyncIfTimingBITS2Alarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 61)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITS2Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITS2Alarm.setDescription('Generated when an alarm condition on the BITS 2 timing reference is detected. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingBITS2AlarmClr = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 62)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITS2AlarmClr.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITS2AlarmClr.setDescription('Generated when an alarm condition on the BITS 2 timing reference is cleared. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingBITSOutRefChg = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 63)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSOutRefSel"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSOutRefChg.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSOutRefChg.setDescription('Generated when the BITS Out timing reference selection changes.')
tmnxEqCardPChipCamEvent = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 64)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxCardComplexNumber"))
if mibBuilder.loadTexts: tmnxEqCardPChipCamEvent.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardPChipCamEvent.setDescription('The tmnxEqCardPChipCamEvent notification is generated when either an IOM or a CPM experiences a persistent occurrence of a PChip CAM error. On a CPM card, the tmnxCardComplexNumber will be fixed to the value zero (0).')
tmnxEqSyncIfTimingSystemQuality = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 65)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingSystemQltyLevel"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingSystemQuality.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingSystemQuality.setDescription("The tmnxEqSyncIfTimingSystemQuality notification is generated when there is a change in the system timing quality level. This notification is a point-in-time state change event. [CAUSE] This notification may be triggered for the following reasons: 1) There has been a switch in the timing reference in use by the network element, either because the previously active timing reference was disqualified, or to ensure that the network element is using the timing reference with the best timing quality. 2) There has been a change in the active timing reference's quality and the change does not result in a timing reference switch. 3) The network element has transitioned into or out of the holdover state. [EFFECT] The system quality level is used to determine the SSM code transmitted on synchronous interfaces. This may affect the SSM code transmitted on some or all interfaces, which may affect the distribution of timing throughout the network. [RECOVERY] If the customer is expecting the system to be locked to a reference of a particular quality and the system quality has decreased, the customer will need to determine the root cause (for example, loss of communication with a satellite) and resolve the issue.")
tmnxEqHwEnhancedCapability = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 66)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqHwEnhancedCapability.setStatus('current')
if mibBuilder.loadTexts: tmnxEqHwEnhancedCapability.setDescription("The tmnxEqHwEnhancedCapability notification is generated when the hardware, specified by the supplied objects, consists of enhanced capabilities as compared to the active hardware. [EFFECT] The system behaves normally under this situation, however, switching to the newer hardware will put the system in an incompatible state with the currently active hardware. That is, once this device takes activity, the lesser capable hardware will fail to communicate with it. In this mode, the system is deemed to be in a 'one-way upgrade' scenario. [RECOVERY] Two modes of recovery exist for this notification. 1. Remove the enhanced hardware, and supply a more compatible device (status quo) with the active hardware, or 2. Switch to the enhanced device, and replace the older hardware with a similarly enhanced device (upgrade).")
tmnxEqSyncIfTimingPTPQuality = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 67)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPRxQltyLevel"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingPTPQuality.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingPTPQuality.setDescription('Generated when there is a change of the received quality level on the Precision Timing Protocol (PTP).')
tmnxEqSyncIfTimingPTPAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 68)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingPTPAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingPTPAlarm.setDescription('Generated when an alarm condition on the Precision Timing Protocol (PTP) timing reference is detected. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingPTPAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 69)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingPTPAlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingPTPAlarmClear.setDescription('Generated when an alarm condition on the Precision Timing Protocol (PTP) timing reference is cleared. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxPeFirmwareVersionWarning = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 70)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxHwFirmwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeFirmwareVersionWarning.setStatus('current')
if mibBuilder.loadTexts: tmnxPeFirmwareVersionWarning.setDescription('Generated when a card is running compatible yet older firmware than the firmware associated with the current software release. tmnxChassisNotifyHwIndex identifies the card. The tmnxHwFirmwareCodeVersion object will contain the programmed the firmware version.')
tmnxMDAIsaTunnelGroupChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 71)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAIsaTunnelGroupInUse"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAIsaTunnelGroup"))
if mibBuilder.loadTexts: tmnxMDAIsaTunnelGroupChange.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAIsaTunnelGroupChange.setDescription('[CAUSE] The tmnxMDAIsaTunnelGroupChange notification is generated when IPsec ISA (Integrated Service Adaptor) tunnel-group in-use for the MDA changes value. [EFFECT] There is no operational impact due to this event. [RECOVERY] None required.')
tmnxChassisCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1))
tmnxChassisGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2))
tmnxChassisV4v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 4)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV4v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV4v0Compliance = tmnxChassisV4v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisV4v0Compliance.setDescription('The compliance statement for management of chassis features in the TIMETRA-CHASSIS-MIB.')
tmnxChassisV5v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 6)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV4v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV5v0Compliance = tmnxChassisV5v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisV5v0Compliance.setDescription('The compliance statement for management of chassis features in the TIMETRA-CHASSIS-MIB.')
tmnxChassis7750V6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 7)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHsmdaV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7750V6v0Compliance = tmnxChassis7750V6v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassis7750V6v0Compliance.setDescription('The compliance statement for management of chassis features on the 7750 in the TIMETRA-CHASSIS-MIB.')
tmnxChassis7450V6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 8)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHsmdaV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7450V6v0Compliance = tmnxChassis7450V6v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassis7450V6v0Compliance.setDescription('The compliance statement for management of chassis features on the 7450 in the TIMETRA-CHASSIS-MIB.')
tmnxChassis7750V6v1Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 9)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHsmdaV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7750V6v1Compliance = tmnxChassis7750V6v1Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassis7750V6v1Compliance.setDescription('The compliance statement for management of chassis features on the 7750 in the TIMETRA-CHASSIS-MIB.')
tmnxChassis7450V6v1Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 10)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHsmdaV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7450V6v1Compliance = tmnxChassis7450V6v1Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassis7450V6v1Compliance.setDescription('The compliance statement for management of chassis features on the 7450 in the TIMETRA-CHASSIS-MIB.')
tmnxChassis7750V7v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 11)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHsmdaV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUserModV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecNotifV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7750V7v0Compliance = tmnxChassis7750V7v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassis7750V7v0Compliance.setDescription('The compliance statement for management of chassis features on the 7750 in the TIMETRA-CHASSIS-MIB.')
tmnxChassis7450V7v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 12)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHsmdaV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUserModV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7450V7v0Compliance = tmnxChassis7450V7v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassis7450V7v0Compliance.setDescription('The compliance statement for management of chassis features on the 7450 in the TIMETRA-CHASSIS-MIB.')
tmnxChassis7x50V8v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 13)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710SETSRefSrcHwV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHsmdaV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUserModV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecNotifV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisMixedModeIomV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7x50V8v0Compliance = tmnxChassis7x50V8v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassis7x50V8v0Compliance.setDescription('The compliance statement for management of chassis features on the 7x50 in the TIMETRA-CHASSIS-MIB.')
tmnxChassisV9v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 14)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710SETSRefSrcHwV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxAtmGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHsmdaV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisMixedModeIomV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUserModV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecNotifV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV9v0Compliance = tmnxChassisV9v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisV9v0Compliance.setDescription('The compliance statement for management of chassis features on SROS series systems in the TIMETRA-CHASSIS-MIB.')
tmnxChassisV10v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 15)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710SETSRefSrcHwV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxAtmGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisMixedModeIomV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUserModV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV10v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecNotifV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingV9v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV10v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIpsecV10v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPQGrpGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxFPQGrpV10v0R4Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyV10v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaV10v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaHsmdaPoolV10v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV10v0Compliance = tmnxChassisV10v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV10v0Compliance.setDescription('The compliance statement for management of chassis features on SROS series systems in the TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710 = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5))
tmnxChassisComp7710V3v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 1)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V3v0 = tmnxChassisComp7710V3v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisComp7710V3v0.setDescription('The compliance statement for management of chassis features for the 7710 in the TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710V5v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 2)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV4v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V5v0 = tmnxChassisComp7710V5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisComp7710V5v0.setDescription('The compliance statement for management of chassis features for the 7710 in the TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710V6v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 3)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710SETSRefSrcHwV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V6v0 = tmnxChassisComp7710V6v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisComp7710V6v0.setDescription('The compliance statement for management of chassis features for the 7710 in the TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710V6v1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 4)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710SETSRefSrcHwV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V6v1 = tmnxChassisComp7710V6v1.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisComp7710V6v1.setDescription('The compliance statement for management of chassis features for the 7710 in the TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710V7v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 5)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710SETSRefSrcHwV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUserModV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecNotifV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V7v0 = tmnxChassisComp7710V7v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisComp7710V7v0.setDescription('The compliance statement for management of chassis features for the 7710 in the TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710V8v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 6)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnx7710SETSRefSrcHwV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaXplV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUserModV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV5v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardPchipV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCamErrorV6v1Group"), ("TIMETRA-CHASSIS-MIB", "tmnxCardV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecNotifV7v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncV6v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifV8v0Group"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHwV6v1Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V8v0 = tmnxChassisComp7710V8v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisComp7710V8v0.setDescription('The compliance statement for management of chassis features for the 7710 in the TIMETRA-CHASSIS-MIB. This MODULE-COMPLIANCE has been replaced by tmnxChassisV9v0Compliance.')
tmnxChassisNotifyObjsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 4)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEqNotificationRow"), ("TIMETRA-CHASSIS-MIB", "tmnxEqTypeNotificationRow"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyChassisId"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxRedSecondaryCPMStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyOID"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifySoftwareLocation"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardFailureReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObjsGroup = tmnxChassisNotifyObjsGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObjsGroup.setDescription('The group of objects supporting chassis hardware notifications on Alcatel-Lucent SROS series systems.')
tmnxChassisNotifyObsoleteGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 7)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxHwConfigChange"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCpuFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMemoryFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqBackdoorBusFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareError"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareAbnormalHalt"), ("TIMETRA-CHASSIS-MIB", "tmnxPeOutOfMemory"), ("TIMETRA-CHASSIS-MIB", "tmnxPeConfigurationError"), ("TIMETRA-CHASSIS-MIB", "tmnxPeStorageProblem"), ("TIMETRA-CHASSIS-MIB", "tmnxPeCpuCyclesExceeded"), ("TIMETRA-CHASSIS-MIB", "tmnxRedSecondaryCPMStatusChange"), ("TIMETRA-CHASSIS-MIB", "tmnxRedRestoreSuccess"), ("TIMETRA-CHASSIS-MIB", "tmnxRedRestoreFail"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObsoleteGroup = tmnxChassisNotifyObsoleteGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObsoleteGroup.setDescription('The group of notifications supporting the management of chassis hardware made obsolete for revision 2.1 on Alcatel-Lucent SROS series systems.')
tmnxChassisV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 9)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisTotalNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisLastChange"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisName"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisType"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisLocation"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisCoordinates"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumSlots"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumPorts"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumPwrSupplies"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumFanTrays"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumFans"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisCriticalLEDState"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisMajorLEDState"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisMinorLEDState"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisBaseMacAddress"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisCLLICode"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisReboot"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgrade"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisAdminMode"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisOperMode"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisModeForce"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpdateWaitTime"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpdateTimeLeft"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisFanOperStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisFanSpeed"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyACStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyDCStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempThreshold"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply1Status"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply2Status"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxHwLastChange"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwMfgString"), ("TIMETRA-CHASSIS-MIB", "tmnxHwMfgBoardNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSerialNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxHwManufactureDate"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxHwName"), ("TIMETRA-CHASSIS-MIB", "tmnxHwAlias"), ("TIMETRA-CHASSIS-MIB", "tmnxHwAssetID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwCLEI"), ("TIMETRA-CHASSIS-MIB", "tmnxHwIsFRU"), ("TIMETRA-CHASSIS-MIB", "tmnxHwContainedIn"), ("TIMETRA-CHASSIS-MIB", "tmnxHwParentRelPos"), ("TIMETRA-CHASSIS-MIB", "tmnxHwAdminState"), ("TIMETRA-CHASSIS-MIB", "tmnxHwOperState"), ("TIMETRA-CHASSIS-MIB", "tmnxHwTempSensor"), ("TIMETRA-CHASSIS-MIB", "tmnxHwTemperature"), ("TIMETRA-CHASSIS-MIB", "tmnxHwTempThreshold"), ("TIMETRA-CHASSIS-MIB", "tmnxHwBootCodeVersion"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSwLastBoot"), ("TIMETRA-CHASSIS-MIB", "tmnxHwAlarmState"), ("TIMETRA-CHASSIS-MIB", "tmnxHwLastAlarmEvent"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClearAlarms"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSwImageSource"), ("TIMETRA-CHASSIS-MIB", "tmnxHwMfgDeviations"), ("TIMETRA-CHASSIS-MIB", "tmnxHwBaseMacAddress"), ("TIMETRA-CHASSIS-MIB", "tmnxHwFailureReason"), ("TIMETRA-CHASSIS-MIB", "tmnxHwContainedIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV3v0Group = tmnxChassisV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisV3v0Group.setDescription('The group of objects supporting management of chassis hardware capabilities on release 3.0 of Alcatel-Lucent SROS series systems.')
tmnxMDAV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 10)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDASupportedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedType"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxPorts"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedPorts"), ("TIMETRA-CHASSIS-MIB", "tmnxMDATxTimingSelected"), ("TIMETRA-CHASSIS-MIB", "tmnxMDASyncIfTimingStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxMDANetworkIngQueues"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACapabilities"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMinChannelization"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannelization"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannels"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAChannelsInUse"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagId"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagAdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagOperStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagCcaRate"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagAccessAdaptQos"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathRate"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathRateOption"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathWeight"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolResvCbs"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolSlpPlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolResvCbs"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolSlpPlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcAcctPolicyId"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcCollectStats"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcQueuePlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMac"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMtu"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcHwMac"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcUserAssignedMac"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDAV3v0Group = tmnxMDAV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMDAV3v0Group.setDescription('The group of objects supporting management of MDAs on Alcatel-Lucent SROS series systems.')
tmnxChassisObsoleteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 11)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxHwSwState"), ("TIMETRA-CHASSIS-MIB", "tmnxCardAllowedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardAllowedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAAllowedTypes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisObsoleteGroup = tmnxChassisObsoleteGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisObsoleteGroup.setDescription('The group of objects supporting the allowed types of CPM cards, IOM cards and MDA made obsolete for revision 3.0 on Alcatel-Lucent SROS series systems.')
tmnxCardV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 12)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardLastChange"), ("TIMETRA-CHASSIS-MIB", "tmnxCardTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxCardTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxCardTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCardSupportedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxCardAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxCardEquippedType"), ("TIMETRA-CHASSIS-MIB", "tmnxCardHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxCardClockSource"), ("TIMETRA-CHASSIS-MIB", "tmnxCardNumMdaSlots"), ("TIMETRA-CHASSIS-MIB", "tmnxCardNumMdas"), ("TIMETRA-CHASSIS-MIB", "tmnxCardReboot"), ("TIMETRA-CHASSIS-MIB", "tmnxCardMemorySize"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardLastChange"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardSupportedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardEquippedType"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardBootOptionVersion"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardBootOptionLastModified"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigBootedVersion"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardIndexBootedVersion"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigLastModified"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigLastSaved"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardRedundant"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardClockSource"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardNumCpus"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardCpuType"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardMemorySize"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardSwitchToRedundantCard"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardReboot"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardRereadBootOptions"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigFileLastBooted"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigFileLastSaved"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigFileLastBootedHeader"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardIndexFileLastBootedHeader"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardBootOptionSource"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigSource"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardBootOptionLastSaved"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricLastChange"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricEquippedType"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmFlashOperStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmFlashSerialNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmFlashFirmwareRevision"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmFlashModelNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmFlashCapacity"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmFlashUsed"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmFlashHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRevert"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRefOrder1"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRefOrder2"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1SrcPort"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1AdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1InUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1Qualified"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2SrcPort"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2AdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2InUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2Qualified"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingFreqOffset"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRefOrder3"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSIfType"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSAdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSInUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSQualified"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSAlarm"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRevert"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRefOrder1"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRefOrder2"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1SrcPort"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1AdminStatus"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2SrcPort"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2AdminStatus"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmChanged"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRefOrder3"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSIfType"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSAdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisAdminOwner"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisAdminControlApply"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisAdminLastSetTimer"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisAdminLastSetTimeout"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2InAdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2OutAdminStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardV3v0Group = tmnxCardV3v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxCardV3v0Group.setDescription('The group of objects supporting management of hardware cards on Alcatel-Lucent SROS series systems.')
tmnxMDAV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 13)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDASupportedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedType"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxPorts"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedPorts"), ("TIMETRA-CHASSIS-MIB", "tmnxMDATxTimingSelected"), ("TIMETRA-CHASSIS-MIB", "tmnxMDASyncIfTimingStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxMDANetworkIngQueues"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACapabilities"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMinChannelization"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannelization"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannels"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAChannelsInUse"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACcagId"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAReboot"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagAdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagOperStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagCcaRate"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagAccessAdaptQos"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathRate"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathRateOption"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathWeight"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolResvCbs"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolSlpPlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolResvCbs"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolSlpPlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcAcctPolicyId"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcCollectStats"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcQueuePlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMac"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMtu"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcHwMac"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcUserAssignedMac"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastSource"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastTapCount"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastGroup"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDAV4v0Group = tmnxMDAV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMDAV4v0Group.setDescription('The group of objects supporting management of MDAs for release 4.0 on Alcatel-Lucent SROS series systems.')
tmnxChassisNotificationV4v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 14)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEnvTempTooHigh"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFanFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqWrongCard"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxRedPrimaryCPMFail"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldover"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldoverClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDataLoss"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDiskFull"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareLoadFailed"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootloaderVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootromVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeFPGAVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFirmwareUpgraded"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeInProgress"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeComplete"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHiBwMcastAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaCfgNotCompatible"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV4v0Group = tmnxChassisNotificationV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisNotificationV4v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 4.0 on Alcatel-Lucent SROS series systems.')
tmnx7710HwV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 15)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisOverTempState"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardMasterSlaveRefState"), ("TIMETRA-CHASSIS-MIB", "tmnxCcmOperStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcmHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxCcmEquippedType"), ("TIMETRA-CHASSIS-MIB", "tmnxCcmTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxCcmTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxCcmTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxMcmSupportedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxMcmAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxMcmEquippedType"), ("TIMETRA-CHASSIS-MIB", "tmnxMcmHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxMcmTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxMcmTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxMcmTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyInputStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyOutputStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAReboot"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnx7710HwV3v0Group = tmnx7710HwV3v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnx7710HwV3v0Group.setDescription('The group of objects supporting management of hardware specific to the Alcatel-Lucent 7710 SR series systems.')
tmnxChassisV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 16)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisTotalNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisLastChange"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisName"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisType"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisLocation"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisCoordinates"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumSlots"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumPorts"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumPwrSupplies"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumFanTrays"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNumFans"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisCriticalLEDState"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisMajorLEDState"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisMinorLEDState"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisBaseMacAddress"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisCLLICode"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisReboot"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgrade"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisAdminMode"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisOperMode"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisModeForce"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpdateTimeLeft"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisFanOperStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisFanSpeed"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyACStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyDCStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempThreshold"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply1Status"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply2Status"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxHwLastChange"), ("TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwMfgString"), ("TIMETRA-CHASSIS-MIB", "tmnxHwMfgBoardNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSerialNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxHwManufactureDate"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("TIMETRA-CHASSIS-MIB", "tmnxHwName"), ("TIMETRA-CHASSIS-MIB", "tmnxHwAlias"), ("TIMETRA-CHASSIS-MIB", "tmnxHwAssetID"), ("TIMETRA-CHASSIS-MIB", "tmnxHwCLEI"), ("TIMETRA-CHASSIS-MIB", "tmnxHwIsFRU"), ("TIMETRA-CHASSIS-MIB", "tmnxHwContainedIn"), ("TIMETRA-CHASSIS-MIB", "tmnxHwParentRelPos"), ("TIMETRA-CHASSIS-MIB", "tmnxHwAdminState"), ("TIMETRA-CHASSIS-MIB", "tmnxHwOperState"), ("TIMETRA-CHASSIS-MIB", "tmnxHwTempSensor"), ("TIMETRA-CHASSIS-MIB", "tmnxHwTemperature"), ("TIMETRA-CHASSIS-MIB", "tmnxHwTempThreshold"), ("TIMETRA-CHASSIS-MIB", "tmnxHwBootCodeVersion"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSwLastBoot"), ("TIMETRA-CHASSIS-MIB", "tmnxHwAlarmState"), ("TIMETRA-CHASSIS-MIB", "tmnxHwLastAlarmEvent"), ("TIMETRA-CHASSIS-MIB", "tmnxHwClearAlarms"), ("TIMETRA-CHASSIS-MIB", "tmnxHwSwImageSource"), ("TIMETRA-CHASSIS-MIB", "tmnxHwMfgDeviations"), ("TIMETRA-CHASSIS-MIB", "tmnxHwBaseMacAddress"), ("TIMETRA-CHASSIS-MIB", "tmnxHwFailureReason"), ("TIMETRA-CHASSIS-MIB", "tmnxHwContainedIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV5v0Group = tmnxChassisV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV5v0Group.setDescription('The group of objects supporting management of chassis hardware capabilities on release 5.0 of Alcatel-Lucent SROS series systems.')
tmnxChassisV5v0ObsoleteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 17)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisUpdateWaitTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV5v0ObsoleteGroup = tmnxChassisV5v0ObsoleteGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV5v0ObsoleteGroup.setDescription('The group of onbsolete objects for managing the chassis hardware capabilities on release 5.0 of Alcatel-Lucent SROS series systems.')
tmnx77x0CESMDAV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 18)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAClockMode"), ("TIMETRA-CHASSIS-MIB", "tmnxMDADiffTimestampFreq"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAIngNamedPoolPolicy"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEgrNamedPoolPolicy"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnx77x0CESMDAV6v0Group = tmnx77x0CESMDAV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnx77x0CESMDAV6v0Group.setDescription('The group of objects supporting management of CES MDAs for release 6.0 on Alcatel-Lucent 77x0 SR series systems.')
tmnxIPsecIsaGrpV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 19)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTableLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpAdminState"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpOperState"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpIsaChassis"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpPrimaryIsa"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpBackupIsa"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpActiveIsa"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxIPsecIsaGrpV6v0Group = tmnxIPsecIsaGrpV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecIsaGrpV6v0Group.setDescription('The group of objects supporting management of IPsec MDAs for release 6.0 on Alcatel-Lucent 7750 and 7710 SR series systems.')
tmnxChassisNotificationV3v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 20)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEnvTempTooHigh"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFanFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqWrongCard"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxRedPrimaryCPMFail"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldover"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldoverClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDataLoss"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDiskFull"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareLoadFailed"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootloaderVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootromVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeFPGAVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFirmwareUpgraded"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaCfgNotCompatible"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV3v0Group = tmnxChassisNotificationV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisNotificationV3v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 3.0 on Alcatel-Lucent SROS series systems.')
tmnxChassisNotificationV6v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 21)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEnvTempTooHigh"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFanFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqWrongCard"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxRedPrimaryCPMFail"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldover"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldoverClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDataLoss"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDiskFull"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareLoadFailed"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootloaderVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootromVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeFPGAVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFirmwareUpgraded"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeInProgress"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeComplete"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHiBwMcastAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaCfgNotCompatible"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardSyncFileNotPresent"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaXplError"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipError"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipMemoryEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV6v0Group = tmnxChassisNotificationV6v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisNotificationV6v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 6.0 on Alcatel-Lucent SROS series systems.')
tmnx7710SETSRefSrcHwV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 22)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1SrcHw"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1BITSIfType"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2SrcHw"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2BITSIfType"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1SrcHw"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1BITSIfType"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2SrcHw"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2BITSIfType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnx7710SETSRefSrcHwV6v0Group = tmnx7710SETSRefSrcHwV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnx7710SETSRefSrcHwV6v0Group.setDescription("The group of objects supporting management of 'Synchronous Equipment Timing' (SETS) when the references are of type 'Building Integrated Timing Supply' (BITS) for release 6.0 on Alcatel-Lucent 7710 SR series systems.")
tmnxChassisHsmdaV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 23)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAIngHsmdaSchedPolicy"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrTblLastChangd"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrMaxRate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrGrp1Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrGrp2Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass1Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass1WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass2Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass2WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass3Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass3WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass4Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass4WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass5Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass5WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass6Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass6WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass7Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass7WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass8Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass8WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAIngHsmdaPoolPolicy"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEgrHsmdaPoolPolicy"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisHsmdaV6v0Group = tmnxChassisHsmdaV6v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisHsmdaV6v0Group.setDescription("The group of objects supporting management of the 'Queueing MDA' (HSMDA) for release 6.0 on Alcatel-Lucent SROS series systems.")
tmnxMDAMcPathMgmtV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 24)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtBwPlcyName"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtPriPathLimit"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtSecPathLimit"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtAncPathLimit"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtAdminState"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtPriInUseBw"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtSecInUseBw"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtAncInUseBw"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtBlkHoleInUseBw"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDAMcPathMgmtV6v0Group = tmnxMDAMcPathMgmtV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtV6v0Group.setDescription('The group of objects supporting management of Multicast Path Management feature for release 6.0 on Alcatel-Lucent SROS series systems.')
tmnxCardV6v0NamedPoolPlcyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 25)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardNamedPoolAdminMode"), ("TIMETRA-CHASSIS-MIB", "tmnxCardNamedPoolOperMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardV6v0NamedPoolPlcyGroup = tmnxCardV6v0NamedPoolPlcyGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxCardV6v0NamedPoolPlcyGroup.setDescription('The group of objects supporting named buffer pools for release 6.0 on Alcatel-Lucent SROS series systems.')
tmnxChassisNotifyObjsV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 26)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardName"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardSyncFile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObjsV6v0Group = tmnxChassisNotifyObjsV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObjsV6v0Group.setDescription('The group of objects added in 6.0 release to support chassis hardware notifications on Alcatel-Lucent SROS series systems.')
tmnxChassisV6v1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 27)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyPemType"), ("TIMETRA-CHASSIS-MIB", "tmnxCardSoftReset"), ("TIMETRA-CHASSIS-MIB", "tmnxCardLastBootupReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV6v1Group = tmnxChassisV6v1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV6v1Group.setDescription('The group of objects added in 6.1 release on Alcatel-Lucent 7xx0 SR series systems.')
tmnxFPMcPathMgmtV6v1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 28)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtBwPlcyName"), ("TIMETRA-CHASSIS-MIB", "tmnxFPMcPathMgmtAdminState"), ("TIMETRA-CHASSIS-MIB", "tmnxFPLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxFPHiBwMcastSource"), ("TIMETRA-CHASSIS-MIB", "tmnxFPHiBwMcastAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxFPHiBwMcastTapCount"), ("TIMETRA-CHASSIS-MIB", "tmnxFPHiBwMcastGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxFPHiBwMcastDefaultPathsOnly"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxFPMcPathMgmtV6v1Group = tmnxFPMcPathMgmtV6v1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxFPMcPathMgmtV6v1Group.setDescription('The group of objects supporting management of Multicast Path Management feature for release 6.1 on Alcatel-Lucent SROS series systems.')
tmnxMDAV6v1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 29)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDASupportedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAAssignedType"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedType"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHwIndex"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxPorts"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedPorts"), ("TIMETRA-CHASSIS-MIB", "tmnxMDATxTimingSelected"), ("TIMETRA-CHASSIS-MIB", "tmnxMDASyncIfTimingStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxMDANetworkIngQueues"), ("TIMETRA-CHASSIS-MIB", "tmnxMDACapabilities"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMinChannelization"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannelization"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannels"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAChannelsInUse"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxMdaTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAReboot"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastSource"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastTapCount"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxMDASynchronousEthernet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDAV6v1Group = tmnxMDAV6v1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAV6v1Group.setDescription('The group of objects supporting management of MDAs for release 6.1 on Alcatel-Lucent SROS series systems.')
tmnxMDACcagV6v1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 30)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDACcagId"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagAdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagOperStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagCcaRate"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagAccessAdaptQos"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathRate"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathRateOption"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathWeight"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolResvCbs"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolSlpPlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolResvCbs"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolSlpPlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcAcctPolicyId"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcCollectStats"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcQueuePlcy"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMac"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMtu"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcHwMac"), ("TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcUserAssignedMac"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDACcagV6v1Group = tmnxMDACcagV6v1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMDACcagV6v1Group.setDescription('The group of objects supporting management of MDA CCAG for release 6.1 on Alcatel-Lucent SROS series systems.')
tmnxMdaXplV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 31)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAXplErrorTime"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAXplFailedCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMdaXplV5v0Group = tmnxMdaXplV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaXplV5v0Group.setDescription('The group of objects added in 5.0 release to support MDA XPL error indications on Alcatel-Lucent SROS series systems.')
tmnxChassisNotifyObjsV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 32)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardComplexNumber"), ("TIMETRA-CHASSIS-MIB", "tmnxCardFwdDirection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObjsV5v0Group = tmnxChassisNotifyObjsV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObjsV5v0Group.setDescription('The group of objects added in 5.0 release to support chassis hardware notifications on Alcatel-Lucent SROS series systems.')
tmnxChassisNotificationV5v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 33)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEqMdaXplError"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipError"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipMemoryEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV5v0Group = tmnxChassisNotificationV5v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisNotificationV5v0Group.setDescription('The group of notifications added in 5.0 release to support the hardware notifications on Alcatel-Lucent SROS series systems.')
tmnxChassisNotificationV6v1Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 34)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEnvTempTooHigh"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFanFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqWrongCard"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxRedPrimaryCPMFail"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldover"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldoverClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDataLoss"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDiskFull"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareLoadFailed"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootloaderVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootromVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeFPGAVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFirmwareUpgraded"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeInProgress"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeComplete"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHiBwMcastAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaCfgNotCompatible"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardSyncFileNotPresent"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaXplError"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipError"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardSoftResetAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipMemoryEvent"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipCamEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV6v1Group = tmnxChassisNotificationV6v1Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisNotificationV6v1Group.setDescription('The group of notifications supporting the management of chassis hardware for release 6.0 on Alcatel-Lucent SROS series systems.')
tmnxChassisNotifyObjsV6v1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 35)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardSoftResetState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObjsV6v1Group = tmnxChassisNotifyObjsV6v1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObjsV6v1Group.setDescription('The group of objects added in 6.1 release to support chassis hardware notifications on Alcatel-Lucent SROS series systems.')
tmnxChassisNotificationV7v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 36)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEnvTempTooHigh"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFanFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFailure"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardInserted"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardRemoved"), ("TIMETRA-CHASSIS-MIB", "tmnxEqWrongCard"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxRedPrimaryCPMFail"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldover"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldoverClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2AlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDataLoss"), ("TIMETRA-CHASSIS-MIB", "tmnxEqFlashDiskFull"), ("TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareLoadFailed"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootloaderVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeBootromVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxPeFPGAVersionMismatch"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarmClear"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardFirmwareUpgraded"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeInProgress"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeComplete"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisHiBwMcastAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaCfgNotCompatible"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardSyncFileNotPresent"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaXplError"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipError"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardSoftResetAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqMdaSyncENotCompatible"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpActiveIsaChgd"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipMemoryEvent"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpUnableToSwitch"), ("TIMETRA-CHASSIS-MIB", "tmnxEqCardPChipCamEvent"), ("TIMETRA-CHASSIS-MIB", "tmnxEqHwEnhancedCapability"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV7v0Group = tmnxChassisNotificationV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotificationV7v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 7.0 on Alcatel-Lucent SROS series systems.')
tmnxChassisUserModV7v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 37)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigUserLastModified"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisUserModV7v0Group = tmnxChassisUserModV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUserModV7v0Group.setDescription('The group of objects added in 7.0 release on Alcatel-Lucent 7xx0 SR series systems to track user modifications.')
tmnxCardPchipV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 38)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1IngrFcsOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1IngrFcsOccurTime"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1EgrFcsOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1EgrFcsOccurTime"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2IngrFcsOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2IngrFcsOccurTime"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2EgrFcsOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2EgrFcsOccurTime"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1MemParityOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1MemParityOccurTime"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2MemParityOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2MemParityOccurTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardPchipV5v0Group = tmnxCardPchipV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxCardPchipV5v0Group.setDescription('The group of objects added in 5.0 release to support IOM Card Pchip error indications on Alcatel-Lucent SROS series systems.')
tmnxFPWredV7v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 39)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxFPWredBufAllocMin"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredBufAllocMax"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredResvCbsMin"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredResvCbsMax"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredSlopePolicy"), ("TIMETRA-CHASSIS-MIB", "tmnxFPWredAdminState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxFPWredV7v0Group = tmnxFPWredV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxFPWredV7v0Group.setDescription('The group of objects supporting management of WRED Queue Management feature for release 7.0 on Alcatel-Lucent SROS series systems.')
tmnxChassisV7v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 40)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisFanRevision"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV7v0Group = tmnxChassisV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV7v0Group.setDescription('The group of objects added in 7.0 release on Alcatel-Lucent 7x50 SR series systems to track Fan Tray revisions.')
tmnxIPsecV7v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 41)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTunnels"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpMaxTunnels"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxIPsecV7v0Group = tmnxIPsecV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecV7v0Group.setDescription('The group of objects added in 7.0 release on Alcatel-Lucent 7x50 SR series systems related to IPsec feature.')
tmnxIPsecNotifV7v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 42)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTnlLowWMark"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTnlHighWMark"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTnlMax"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxIPsecNotifV7v0Group = tmnxIPsecNotifV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxIPsecNotifV7v0Group.setDescription('The group of objects added in 7.0 release to support IPsec notifications on Alcatel-Lucent SROS series systems.')
tmnxSyncV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 43)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1State"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2State"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSyncV6v0Group = tmnxSyncV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncV6v0Group.setDescription('The group of objects added in 6.0 release on Alcatel 7xx0 SR series systems related to system timing.')
tmnxSyncIfTimingV8v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 44)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSOutAdmStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSOutLineLen"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1CfgQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1RxQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2CfgQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2RxQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSCfgQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSRxQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2InUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2Qualified"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2RxQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2State"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1NationalUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2NationalUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSNationalUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingQLSelection"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingOtherCPMInUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingOtherCPMQual"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingOtherCPMAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingOtherCPMState"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSOutRefSel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSTxQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITS2AdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingSystemQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSOutAdmStatus"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSOutLineLen"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1CfgQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2CfgQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSCfgQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1NationalUse"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2NationalUse"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSNationalUse"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmQLSelection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSyncIfTimingV8v0Group = tmnxSyncIfTimingV8v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingV8v0Group.setDescription('The group of objects added in 8.0 release to support new Sync-if-timing features on Alcatel SROS series systems.')
tmnxSyncIfTimingNotifV8v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 45)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Quality"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Quality"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSQuality"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITS2Quality"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRefSwitch"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITS2Alarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITS2AlarmClr"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSOutRefChg"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingSystemQuality"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSyncIfTimingNotifV8v0Group = tmnxSyncIfTimingNotifV8v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingNotifV8v0Group.setDescription('The group of objects added in 8.0 release to support Sync-If-Timing notifications on Alcatel-Lucent SROS series systems.')
tmnxChassisV8v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 46)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxHwEquippedPlatform"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisRedForcedSingleSfm"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCapability"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV8v0Group = tmnxChassisV8v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV8v0Group.setDescription('The group of objects added in 8.0 release on Alcatel-Lucent SR series systems.')
tmnxChassisMixedModeIomV8v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 47)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxChassisMixedModeIomAdminMode"), ("TIMETRA-CHASSIS-MIB", "tmnxChassisMixedModeIomUpgrList"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisMixedModeIomV8v0Group = tmnxChassisMixedModeIomV8v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisMixedModeIomV8v0Group.setDescription('The group of objects added in 8.0 release on Alcatel-Lucent SR series systems to support the Mixed Mode IOM feature.')
tmnxCardCamErrorV6v1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 48)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1CAMErrorOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1CAMErrorOccurTime"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2CAMErrorOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2CAMErrorOccurTime"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardCmplxCAMErrOccur"), ("TIMETRA-CHASSIS-MIB", "tmnxCpmCardCmplxCAMErrOccurTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardCamErrorV6v1Group = tmnxCardCamErrorV6v1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxCardCamErrorV6v1Group.setDescription('The group of objects added in 6.1 release on Alcatel 7xx0 SR series systems related to Card CAM Failures.')
tmnxChassisV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 49)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardLastBootupReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV6v0Group = tmnxChassisV6v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisV6v0Group.setDescription('The group of objects added in 6.0 release on Alcatel 7xx0 SR series systems.')
tmnxCardV7v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 50)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardFailOnError"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardV7v0Group = tmnxCardV7v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxCardV7v0Group.setDescription('The group of objects added in 7.0 release on Alcatel 7xx0 SR series systems for card management.')
tmnxAtmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 51)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAAtmMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxAtmGroup = tmnxAtmGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxAtmGroup.setDescription('The group of objects on Alcatel 7xx0 SR series systems for ATM management.')
tmnxChassisHwV6v1Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 52)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxHwMfgAssemblyNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisHwV6v1Group = tmnxChassisHwV6v1Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisHwV6v1Group.setDescription('The group of hardware related objects added in release 6.1 on Alcatel 7xx0 SR series systems.')
tmnxChassisHwV9v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 53)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCpmCardOscillatorType"), ("TIMETRA-CHASSIS-MIB", "tmnxHwFirmwareCodeVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisHwV9v0Group = tmnxChassisHwV9v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisHwV9v0Group.setDescription('The group of hardware related objects added in release 9.0 on Alcatel SROS series systems.')
tmnxSyncIfTimingV9v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 54)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRefOrder4"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPAdminStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPInUse"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPQualified"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPCfgQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPRxQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingPTPState"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSOutSource"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRefOrder4"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmPTPAdminStatus"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmPTPCfgQltyLevel"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSOutSource"), ("TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRefOrder5"), ("TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRefOrder5"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSyncIfTimingV9v0Group = tmnxSyncIfTimingV9v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingV9v0Group.setDescription('The group of objects added in 9.0 release to support new Sync-if-timing features on Alcatel SROS series systems.')
tmnxSyncIfTimingNotifyV9v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 55)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingPTPQuality"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingPTPAlarm"), ("TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingPTPAlarmClear"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxSyncIfTimingNotifyV9v0Group = tmnxSyncIfTimingNotifyV9v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingNotifyV9v0Group.setDescription('The group of notifications added in 9.0 release to support new Sync-if-timing features on Alcatel SROS series systems.')
tmnxChassisNotifyObjsV9v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 56)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMdaNotifyType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObjsV9v0Group = tmnxChassisNotifyObjsV9v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObjsV9v0Group.setDescription('The group of notification objects extending chassis features for revision 9.0 on Alcatel SROS series systems.')
tmnxMDAV9v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 57)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAEgrHsmdaThrshLoBrstMult"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAEgrHsmdaThrshHiBrstInc"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDAV9v0Group = tmnxMDAV9v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAV9v0Group.setDescription('The group of objects added in 9.0 release to support new HSMDA threshold limits on Alcatel SROS series systems.')
tmnxCardPchipV8v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 58)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx1EgrFcsSrcSlots"), ("TIMETRA-CHASSIS-MIB", "tmnxCardCmplx2EgrFcsSrcSlots"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardPchipV8v0Group = tmnxCardPchipV8v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxCardPchipV8v0Group.setDescription('The group of objects added in 8.0 release to enhance IOM Card Pchip error indications on Alcatel-Lucent SROS series systems.')
tmnxChassisNotifyObjsV8v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 59)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardSrcSlotBitmap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObjsV8v0Group = tmnxChassisNotifyObjsV8v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObjsV8v0Group.setDescription('The group of objects added in 8.0 release to support chassis hardware notifications on Alcatel-Lucent SROS series systems.')
tmnxFPQGrpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 60)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpAcctgPolId"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpCollectStats"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpDescr"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpLastChgd"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpPolicerPol"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpTableLastChgd"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpAcctgPolId"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpCollectStats"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpDescr"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpLastChgd"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpPolicerPol"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpTableLastChgd"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQGrpPStatMode"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffHPrioPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffHPrioPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffHPrioPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpHPrioPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpHPrioPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpHPrioPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffLPrioPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffLPrioPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffLPrioPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpLPrioPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpLPrioPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpLPrioPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffHPrioOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffHPrioOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffHPrioOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpHPrioOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpHPrioOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpHPrioOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffLPrioOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffLPrioOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStOffLPrioOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpLPrioOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpLPrioOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStDrpLPrioOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdInProfPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdInProfPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdInProfPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdOutProfPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdOutProfPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdOutProfPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdInProfOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdInProfOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdInProfOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdOutProfOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdOutProfOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStFwdOutProfOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStUncolPktsOff"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStUncolPktsOffL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStUncolPktsOffH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStUncolOctsOff"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStUncolOctsOffL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPNetIngQgPStUncolOctsOffH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQGrpPStatMode"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffHPrioPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffHPrioPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffHPrioPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpHPrioPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpHPrioPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpHPrioPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffLPrioPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffLPrioPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffLPrioPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpLPrioPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpLPrioPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpLPrioPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffHPrioOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffHPrioOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffHPrioOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpHPrioOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpHPrioOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpHPrioOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffLPrioOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffLPrioOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStOffLPrioOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpLPrioOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpLPrioOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStDrpLPrioOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdInProfPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdInProfPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdInProfPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdOutProfPkts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdOutProfPktsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdOutProfPktsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdInProfOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdInProfOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdInProfOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdOutProfOcts"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdOutProfOctsL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStFwdOutProfOctsH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStUncolPktsOff"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStUncolPktsOffL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStUncolPktsOffH"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStUncolOctsOff"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStUncolOctsOffL"), ("TIMETRA-CHASSIS-MIB", "tmnxFPAccIngQgPStUncolOctsOffH"), ("TIMETRA-CHASSIS-MIB", "tFPNetIngQGrpArbitStatFwdPkts"), ("TIMETRA-CHASSIS-MIB", "tFPNetIngQGrpArbitStatFwdPktsL"), ("TIMETRA-CHASSIS-MIB", "tFPNetIngQGrpArbitStatFwdPktsH"), ("TIMETRA-CHASSIS-MIB", "tFPNetIngQGrpArbitStatFwdOcts"), ("TIMETRA-CHASSIS-MIB", "tFPNetIngQGrpArbitStatFwdOctsL"), ("TIMETRA-CHASSIS-MIB", "tFPNetIngQGrpArbitStatFwdOctsH"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpArbitStatFwdPkts"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpArbitStatFwdPktsL"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpArbitStatFwdPktsH"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpArbitStatFwdOcts"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpArbitStatFwdOctsL"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpArbitStatFwdOctsH"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxFPQGrpGroup = tmnxFPQGrpGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxFPQGrpGroup.setDescription('The group of objects added in 10.0 release to support fowarding-plane queue-group objects on Alcatel-Lucent SROS series systems.')
tmnxCardV10v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 61)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxCardHardResetUnsupMdas"), ("TIMETRA-CHASSIS-MIB", "tmnxCardRateCalcFastQueue"), ("TIMETRA-CHASSIS-MIB", "tmnxCardRateCalcSlowQueue"), ("TIMETRA-CHASSIS-MIB", "tmnxCardSchedRun"), ("TIMETRA-CHASSIS-MIB", "tmnxCardTaskScheduling"), ("TIMETRA-CHASSIS-MIB", "tmnxCardSlowQueueThresh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardV10v0Group = tmnxCardV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxCardV10v0Group.setDescription('The group of objects added in 10.0 release to enhance IOM Card features on Alcatel-Lucent SROS series systems.')
tmnxIpsecV10v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 62)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpTunnelReassembly"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpOperFlags"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpIpTunnels"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpIpMaxTunnels"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxIpsecV10v0Group = tmnxIpsecV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxIpsecV10v0Group.setDescription('The group of objects added in 10.0 release to ipsec features on Alcatel-Lucent SROS series systems.')
tmnxChassisV10v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 63)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxFanTrayCompSpeed"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricSupportedTypes"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricReboot"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricTypeName"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricTypeDescription"), ("TIMETRA-CHASSIS-MIB", "tmnxFabricTypeStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceCurrentVoltage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourcePeakVoltage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourcePeakVoltageTime"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceMinVoltage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceMinVoltageTime"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceCurrentWattage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourcePeakWattage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourcePeakWattageTime"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceMinWattage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceMinWattageTime"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceCurrentAmperage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourcePeakAmperage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourcePeakAmperageTime"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceMinAmperage"), ("TIMETRA-CHASSIS-MIB", "tmnxHwResourceMinAmperageTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV10v0Group = tmnxChassisV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV10v0Group.setDescription('The group of objects added in 10.0 release to enhance hardware functionality on Alcatel-Lucent SROS series systems.')
tmnxChassisNotificationV9v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 64)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxPeFirmwareVersionWarning"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV9v0Group = tmnxChassisNotificationV9v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotificationV9v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 9.0 on Alcatel-Lucent SROS series systems.')
tmnxFPQGrpV10v0R4Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 65)).setObjects(("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrTblLstChgd"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrRowStatus"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrLastChgd"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrAdminPIR"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrAdminCIR"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrStatMode"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrMBS"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrCBS"), ("TIMETRA-CHASSIS-MIB", "tFPAccIngQGrpPlcrOvrPktOffset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxFPQGrpV10v0R4Group = tmnxFPQGrpV10v0R4Group.setStatus('current')
if mibBuilder.loadTexts: tmnxFPQGrpV10v0R4Group.setDescription('The group of objects added in 10.0 release to support fowarding-plane queue-group policer override objects on Alcatel-Lucent SROS series systems.')
tmnxMdaV10v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 66)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAIsaTunnelGroup"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpMultiActive"), ("TIMETRA-CHASSIS-MIB", "tmnxIPsecIsaGrpActiveMda"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAIsaTunnelGroupInUse"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMdaV10v0Group = tmnxMdaV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaV10v0Group.setDescription('The group of objects added in 10.0 release to enhance IOM MDA features on Alcatel-Lucent SROS series systems.')
tmnxMdaObsoletedV10v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 67)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAIngHsmdaSchedPolicy"), ("TIMETRA-CHASSIS-MIB", "tmnxMDAIngHsmdaPoolPolicy"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrTblLastChangd"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrRowStatus"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrLastChanged"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrMaxRate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrGrp1Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrGrp2Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass1Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass1WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass2Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass2WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass3Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass3WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass4Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass4WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass5Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass5WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass6Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass6WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass7Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass7WtInGrp"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass8Rate"), ("TIMETRA-CHASSIS-MIB", "tmnxHsmdaMdaSchOvrClass8WtInGrp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMdaObsoletedV10v0Group = tmnxMdaObsoletedV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaObsoletedV10v0Group.setDescription('The group of objects obsoleted in 10.0 release to enhance IOM MDA features on Alcatel-Lucent SROS series systems.')
tmnxChassisNotifyV10v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 69)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAIsaTunnelGroupChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyV10v0Group = tmnxChassisNotifyV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyV10v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 10.0 on Alcatel-Lucent SROS series systems.')
tmnxMdaHsmdaPoolV10v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 70)).setObjects(("TIMETRA-CHASSIS-MIB", "tmnxMDAEgrHsmdaPoolPolicy"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMdaHsmdaPoolV10v0Group = tmnxMdaHsmdaPoolV10v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaHsmdaPoolV10v0Group.setDescription('The group of objects added in 10.0 release to enhance IOM MDA features related to HSMDA on Alcatel-Lucent SROS series systems.')
mibBuilder.exportSymbols("TIMETRA-CHASSIS-MIB", tmnxHwConfigChange=tmnxHwConfigChange, tmnxChassisTable=tmnxChassisTable, tmnxCardCmplx2IngrFcsOccurTime=tmnxCardCmplx2IngrFcsOccurTime, tmnxCardTypeDescription=tmnxCardTypeDescription, tmnxFPNetIngQgPStFwdInProfPktsL=tmnxFPNetIngQgPStFwdInProfPktsL, tmnxCcmEntry=tmnxCcmEntry, tmnxFPNetIngQgPStUncolOctsOff=tmnxFPNetIngQgPStUncolOctsOff, tmnxFPAccIngQgPStDrpLPrioOctsH=tmnxFPAccIngQgPStDrpLPrioOctsH, tSyncIfTimingAdmRefOrder1=tSyncIfTimingAdmRefOrder1, tSyncIfTimingAdmRevert=tSyncIfTimingAdmRevert, tmnxHwConformance=tmnxHwConformance, tmnxFPNum=tmnxFPNum, tmnxFPAccIngQgPStFwdInProfOctsL=tmnxFPAccIngQgPStFwdInProfOctsL, tmnxChassisModeForce=tmnxChassisModeForce, tmnxSyncIfTimingStatus=tmnxSyncIfTimingStatus, tmnxChassisNotifyHwIndex=tmnxChassisNotifyHwIndex, tmnxEqCardInserted=tmnxEqCardInserted, tmnxCardHwIndex=tmnxCardHwIndex, tmnxFPNetIngQgPStFwdInProfOctsL=tmnxFPNetIngQgPStFwdInProfOctsL, tmnxFPAccIngQgPStDrpLPrioPktsH=tmnxFPAccIngQgPStDrpLPrioPktsH, tmnxFPAccIngQgPStDrpHPrioPktsH=tmnxFPAccIngQgPStDrpHPrioPktsH, tmnxCardRateCalcFastQueue=tmnxCardRateCalcFastQueue, tmnxChassisV8v0Group=tmnxChassisV8v0Group, tmnxChassisCriticalLEDState=tmnxChassisCriticalLEDState, tmnxSyncIfTimingBITSOutLineLen=tmnxSyncIfTimingBITSOutLineLen, tFPNetIngQGrpArbitStatFwdPktsH=tFPNetIngQGrpArbitStatFwdPktsH, tmnxFabricReboot=tmnxFabricReboot, tmnxPeOutOfMemory=tmnxPeOutOfMemory, tmnxRedRestoreFail=tmnxRedRestoreFail, tmnxCardCamErrorV6v1Group=tmnxCardCamErrorV6v1Group, tmnxHwResourceEntry=tmnxHwResourceEntry, tmnxChassisTypeName=tmnxChassisTypeName, tmnxChassisNotificationV9v0Group=tmnxChassisNotificationV9v0Group, tFPNetIngQGrpArbitStatName=tFPNetIngQGrpArbitStatName, tmnxFPWredResvCbsMax=tmnxFPWredResvCbsMax, tmnxIPsecIsaGrpTable=tmnxIPsecIsaGrpTable, tmnxFPAccIngQgPStFwdOutProfPktsH=tmnxFPAccIngQgPStFwdOutProfPktsH, tmnxFPAccIngQgPStUncolOctsOffL=tmnxFPAccIngQgPStUncolOctsOffL, tmnxMdaXplV5v0Group=tmnxMdaXplV5v0Group, tmnxCpmCardCpuType=tmnxCpmCardCpuType, tmnxPeFPGAVersionMismatch=tmnxPeFPGAVersionMismatch, tmnxPeBootloaderVersionMismatch=tmnxPeBootloaderVersionMismatch, tmnxMcmTypeName=tmnxMcmTypeName, tSyncIfTimingAdmRef2CfgQltyLevel=tSyncIfTimingAdmRef2CfgQltyLevel, tmnxMDAMaxChannels=tmnxMDAMaxChannels, tmnxChassisTypeEntry=tmnxChassisTypeEntry, tmnxMDAMaxChannelization=tmnxMDAMaxChannelization, tmnxHwCLEI=tmnxHwCLEI, TmnxCcmType=TmnxCcmType, tmnxHwAlarmState=tmnxHwAlarmState, tmnxFabricTable=tmnxFabricTable, tmnxFPAccIngQGrpTable=tmnxFPAccIngQGrpTable, tmnxChassisComp7710=tmnxChassisComp7710, tmnxIpsecV10v0Group=tmnxIpsecV10v0Group, tmnxChassisPowerSupplyAssignedType=tmnxChassisPowerSupplyAssignedType, tmnxFPAccIngQgPStOffHPrioPkts=tmnxFPAccIngQgPStOffHPrioPkts, tFPNetIngQGrpArbitStatFwdPkts=tFPNetIngQGrpArbitStatFwdPkts, tmnxChassisNumSlots=tmnxChassisNumSlots, tmnxMDAMcPathMgmtBwPlcyName=tmnxMDAMcPathMgmtBwPlcyName, tmnxPeFirmwareVersionWarning=tmnxPeFirmwareVersionWarning, tmnxSyncIfTimingRef1CfgQltyLevel=tmnxSyncIfTimingRef1CfgQltyLevel, tmnxSyncIfTimingRef1AdminStatus=tmnxSyncIfTimingRef1AdminStatus, tmnxCpmFlashSerialNumber=tmnxCpmFlashSerialNumber, tFPNetIngQGrpArbitStatFwdOctsH=tFPNetIngQGrpArbitStatFwdOctsH, tFPNetIngQGrpArbitStatTable=tFPNetIngQGrpArbitStatTable, tmnxFabricLastChange=tmnxFabricLastChange, tmnxCcagPathCcLastChanged=tmnxCcagPathCcLastChanged, tmnxChassis7750V7v0Compliance=tmnxChassis7750V7v0Compliance, tSyncIfTimingAdmPTPAdminStatus=tSyncIfTimingAdmPTPAdminStatus, tmnxChassis7x50V8v0Compliance=tmnxChassis7x50V8v0Compliance, tmnxIPsecIsaGrpOperState=tmnxIPsecIsaGrpOperState, tmnxChassisNotificationV4v0Group=tmnxChassisNotificationV4v0Group, tmnxChassisPowerSupplyOutputStatus=tmnxChassisPowerSupplyOutputStatus, tmnxFPWredV7v0Group=tmnxFPWredV7v0Group, tmnxHwResourceMinAmperageTime=tmnxHwResourceMinAmperageTime, tmnxFanTrayComponentEntry=tmnxFanTrayComponentEntry, tFPAccIngQGrpPlcrOvrAdminPIR=tFPAccIngQGrpPlcrOvrAdminPIR, tmnxFPNetIngQgPStOffLPrioPktsL=tmnxFPNetIngQgPStOffLPrioPktsL, tmnxSyncIfTimingOtherCPMState=tmnxSyncIfTimingOtherCPMState, tmnxCardAssignedType=tmnxCardAssignedType, tmnxCardCmplx1MemParityOccur=tmnxCardCmplx1MemParityOccur, tmnxChassisRedForcedSingleSfm=tmnxChassisRedForcedSingleSfm, tmnxFPWredSlopePolicy=tmnxFPWredSlopePolicy, tmnxRedRestoreSuccess=tmnxRedRestoreSuccess, tmnxMDAAllowedTypes=tmnxMDAAllowedTypes, TmnxCardSuppType=TmnxCardSuppType, tmnxSyncIfTimingRef1SrcHw=tmnxSyncIfTimingRef1SrcHw, tmnxCardCmplx2EgrFcsOccurTime=tmnxCardCmplx2EgrFcsOccurTime, tmnxHwContainsTable=tmnxHwContainsTable, tmnxCardHardResetUnsupMdas=tmnxCardHardResetUnsupMdas, tmnxCpmCardClockSource=tmnxCpmCardClockSource, tmnxCardNumMdaSlots=tmnxCardNumMdaSlots, tmnxChassisNotifyObjsV6v0Group=tmnxChassisNotifyObjsV6v0Group, tmnxSyncIfTimingRefOrder4=tmnxSyncIfTimingRefOrder4, tmnxChassisNotifyV10v0Group=tmnxChassisNotifyV10v0Group, tmnxCpmCardEntry=tmnxCpmCardEntry, TmnxHwIndexOrZero=TmnxHwIndexOrZero, tmnxMdaTypeTable=tmnxMdaTypeTable, tmnxSyncIfTimingBITSRxQltyLevel=tmnxSyncIfTimingBITSRxQltyLevel, tSyncIfTimingAdmRefOrder2=tSyncIfTimingAdmRefOrder2, tmnxSyncIfTimingRevert=tmnxSyncIfTimingRevert, tmnxHsmdaMdaSchOvrGrp2Rate=tmnxHsmdaMdaSchOvrGrp2Rate, tmnxCcagPathCcTable=tmnxCcagPathCcTable, tmnxFPNetIngQgPStDrpHPrioPkts=tmnxFPNetIngQgPStDrpHPrioPkts, tmnxFPNetIngQgPStUncolPktsOffH=tmnxFPNetIngQgPStUncolPktsOffH, tmnxSyncV6v0Group=tmnxSyncV6v0Group, tmnxRedSecondaryCPMStatusChange=tmnxRedSecondaryCPMStatusChange, tmnxSyncIfTimingRef2NationalUse=tmnxSyncIfTimingRef2NationalUse, tmnxSyncIfTimingBITSAlarm=tmnxSyncIfTimingBITSAlarm, TmnxFabricType=TmnxFabricType, tmnxCardClockSource=tmnxCardClockSource, tmnxSyncIfTimingBITSCfgQltyLevel=tmnxSyncIfTimingBITSCfgQltyLevel, TmnxCardSlotBitMap=TmnxCardSlotBitMap, tmnxCcagPathCcMtu=tmnxCcagPathCcMtu, tmnxPeBootromVersionMismatch=tmnxPeBootromVersionMismatch, tmnxCpmCardConfigLastModified=tmnxCpmCardConfigLastModified, tmnxFPAccIngQgPStFwdOutProfOctsH=tmnxFPAccIngQgPStFwdOutProfOctsH, tmnxChassisBaseMacAddress=tmnxChassisBaseMacAddress, tmnxCpmCardBootOptionSource=tmnxCpmCardBootOptionSource, tmnxChassisLastChange=tmnxChassisLastChange, tmnxCpmCardRedundant=tmnxCpmCardRedundant, tmnxFPAccIngQGrpPStatEntry=tmnxFPAccIngQGrpPStatEntry, tmnxEqMdaCfgNotCompatible=tmnxEqMdaCfgNotCompatible, tmnxSyncIfTimingOtherCPMQual=tmnxSyncIfTimingOtherCPMQual, tmnxPeSoftwareLoadFailed=tmnxPeSoftwareLoadFailed, tmnxFPNetIngQgPStDrpHPrioOctsL=tmnxFPNetIngQgPStDrpHPrioOctsL, tmnxMDAIngNamedPoolPolicy=tmnxMDAIngNamedPoolPolicy, tmnxIPsecV7v0Group=tmnxIPsecV7v0Group, tFPAccIngQGrpPlcrOvrMBS=tFPAccIngQGrpPlcrOvrMBS, tmnxEqFlashDiskFull=tmnxEqFlashDiskFull, tmnxFabricHwIndex=tmnxFabricHwIndex, tmnxMDAEgrHsmdaThrshHiBrstInc=tmnxMDAEgrHsmdaThrshHiBrstInc, tmnxEqSyncIfTimingRef2Alarm=tmnxEqSyncIfTimingRef2Alarm, tmnxFPNetIngQgPStOffLPrioPkts=tmnxFPNetIngQgPStOffLPrioPkts, tmnxFPAccIngQgPStDrpHPrioOctsH=tmnxFPAccIngQgPStDrpHPrioOctsH, tmnxMcmAssignedType=tmnxMcmAssignedType, tmnxMdaHsmdaPoolV10v0Group=tmnxMdaHsmdaPoolV10v0Group, tmnxMdaTypeStatus=tmnxMdaTypeStatus, tmnxSyncIfTimingBITS2OutAdminStatus=tmnxSyncIfTimingBITS2OutAdminStatus, tmnxFPNetIngQgPStDrpHPrioOcts=tmnxFPNetIngQgPStDrpHPrioOcts, tmnxHwSerialNumber=tmnxHwSerialNumber, tmnxCardPchipV5v0Group=tmnxCardPchipV5v0Group, tmnxHwResourceCurrentWattage=tmnxHwResourceCurrentWattage, tmnxCpmCardHwIndex=tmnxCpmCardHwIndex, tFPAccIngQGrpArbitStatFwdOcts=tFPAccIngQGrpArbitStatFwdOcts, tmnxFPAccIngQgPStUncolPktsOffH=tmnxFPAccIngQgPStUncolPktsOffH, tmnxChassisUpgrade=tmnxChassisUpgrade, tmnxHsmdaMdaSchOvrGrp1Rate=tmnxHsmdaMdaSchOvrGrp1Rate, tmnxIPsecIsaGrpActiveIsa=tmnxIPsecIsaGrpActiveIsa, tmnxFPNetIngQgPStUncolPktsOff=tmnxFPNetIngQgPStUncolPktsOff, tFPAccIngQGrpArbitStatName=tFPAccIngQGrpArbitStatName, tmnxFanTrayCompIndex=tmnxFanTrayCompIndex, tmnxEqCardFirmwareUpgraded=tmnxEqCardFirmwareUpgraded, tmnxFPNetIngQGrpPolicerPol=tmnxFPNetIngQGrpPolicerPol, tmnxMDAEquippedPorts=tmnxMDAEquippedPorts, tmnxHwTable=tmnxHwTable, tmnxFanTrayCompSpeed=tmnxFanTrayCompSpeed, TmnxPortAdminStatus=TmnxPortAdminStatus, TmnxChassisType=TmnxChassisType, tmnxMDAMcPathMgmtBlkHoleInUseBw=tmnxMDAMcPathMgmtBlkHoleInUseBw, tmnxHsmdaMdaSchOvrClass8Rate=tmnxHsmdaMdaSchOvrClass8Rate, tmnxChassisOperMode=tmnxChassisOperMode, tmnxFPHiBwMcastAlarm=tmnxFPHiBwMcastAlarm, tmnxChassisPowerSupplyDCStatus=tmnxChassisPowerSupplyDCStatus, tmnxFPLastChanged=tmnxFPLastChanged, tmnxMDAAssignedType=tmnxMDAAssignedType, tmnxCcmHwIndex=tmnxCcmHwIndex, tmnxChassisConformance=tmnxChassisConformance, tSyncIfTimingAdmRefOrder3=tSyncIfTimingAdmRefOrder3, tmnxHsmdaMdaSchOvrClass5WtInGrp=tmnxHsmdaMdaSchOvrClass5WtInGrp, tmnxCcagPathCcIngPoolResvCbs=tmnxCcagPathCcIngPoolResvCbs, tmnxChassisMajorLEDState=tmnxChassisMajorLEDState, tmnxFPHiBwMcastTapCount=tmnxFPHiBwMcastTapCount, tmnxHsmdaMdaSchOvrClass6Rate=tmnxHsmdaMdaSchOvrClass6Rate, tmnxCpmCardConfigLastSaved=tmnxCpmCardConfigLastSaved, tmnxChassisComp7710V5v0=tmnxChassisComp7710V5v0, tmnxCardV6v0NamedPoolPlcyGroup=tmnxCardV6v0NamedPoolPlcyGroup, tmnxMdaTypeDescription=tmnxMdaTypeDescription, tmnxFPAccIngQgPStOffHPrioOctsH=tmnxFPAccIngQgPStOffHPrioOctsH, tmnxRedPrimaryCPMFail=tmnxRedPrimaryCPMFail, tmnxSyncIfTimingSystemQltyLevel=tmnxSyncIfTimingSystemQltyLevel, tmnxSyncIfTimingBITSIfType=tmnxSyncIfTimingBITSIfType, tmnxHwManufactureDate=tmnxHwManufactureDate, tSyncIfTimingAdmEntry=tSyncIfTimingAdmEntry, tmnxEqCardSoftResetAlarm=tmnxEqCardSoftResetAlarm, tmnxMDAEquippedType=tmnxMDAEquippedType, tmnxChassisV6v1Group=tmnxChassisV6v1Group, tmnxSyncIfTimingOtherCPMInUse=tmnxSyncIfTimingOtherCPMInUse, tSyncIfTimingAdmChanged=tSyncIfTimingAdmChanged, tSyncIfTimingAdmRef1CfgQltyLevel=tSyncIfTimingAdmRef1CfgQltyLevel, TmnxChassisMode=TmnxChassisMode, tmnxFPAccIngQgPStDrpHPrioOcts=tmnxFPAccIngQgPStDrpHPrioOcts, tFPAccIngQGrpPlcrOvrLastChgd=tFPAccIngQGrpPlcrOvrLastChgd, tmnxEqFlashDataLoss=tmnxEqFlashDataLoss, tmnxFPAccIngQgPStOffLPrioPkts=tmnxFPAccIngQgPStOffLPrioPkts, tmnxSyncIfTimingBITS2Alarm=tmnxSyncIfTimingBITS2Alarm, tmnxChassisNotifyObjsV8v0Group=tmnxChassisNotifyObjsV8v0Group, tmnxFPNetIngQgPStDrpHPrioPktsH=tmnxFPNetIngQgPStDrpHPrioPktsH, tmnxChassisRowStatus=tmnxChassisRowStatus, tmnxFabricEquippedType=tmnxFabricEquippedType, tmnxFPAccIngQgPStOffHPrioPktsH=tmnxFPAccIngQgPStOffHPrioPktsH, tmnxChassisPowerSupplyId=tmnxChassisPowerSupplyId, tmnxCpmCardCmplxCAMErrOccur=tmnxCpmCardCmplxCAMErrOccur, tmnxChassisFanSpeed=tmnxChassisFanSpeed, tSyncIfTimingAdmRef2SrcHw=tSyncIfTimingAdmRef2SrcHw, tmnxEqSyncIfTimingRef2AlarmClear=tmnxEqSyncIfTimingRef2AlarmClear, tmnxMDAMcPathMgmtPriInUseBw=tmnxMDAMcPathMgmtPriInUseBw, tmnxCardMemorySize=tmnxCardMemorySize, tmnxCpmCardRereadBootOptions=tmnxCpmCardRereadBootOptions, tmnxCpmCardAllowedTypes=tmnxCpmCardAllowedTypes, tmnxSyncIfTimingEntry=tmnxSyncIfTimingEntry, tmnxFPNetIngQgPStFwdOutProfPkts=tmnxFPNetIngQgPStFwdOutProfPkts, tmnxCpmCardConfigFileLastSaved=tmnxCpmCardConfigFileLastSaved, tFPAccIngQGrpArbitStatEntry=tFPAccIngQGrpArbitStatEntry, tmnxChassis7450V7v0Compliance=tmnxChassis7450V7v0Compliance, tmnxChassisPowerSupplyPemType=tmnxChassisPowerSupplyPemType, tmnxCardNamedPoolOperMode=tmnxCardNamedPoolOperMode, tmnxCardSlotNum=tmnxCardSlotNum, tmnx7710HwV3v0Group=tmnx7710HwV3v0Group, tmnxChassisHwV6v1Group=tmnxChassisHwV6v1Group, tmnxCpmCardOscillatorType=tmnxCpmCardOscillatorType, tmnxSyncIfTimingRef1NationalUse=tmnxSyncIfTimingRef1NationalUse, tmnxSyncIfTimingRef1State=tmnxSyncIfTimingRef1State, tmnxSyncIfTimingNotifyV9v0Group=tmnxSyncIfTimingNotifyV9v0Group, tmnxSyncIfTimingRef2Qualified=tmnxSyncIfTimingRef2Qualified, tmnxHwLastChange=tmnxHwLastChange, tmnxMDAEgrHsmdaPoolPolicy=tmnxMDAEgrHsmdaPoolPolicy, tmnxFPAccIngQgPStDrpLPrioOctsL=tmnxFPAccIngQgPStDrpLPrioOctsL, tmnxSyncIfTimingBITSAdminStatus=tmnxSyncIfTimingBITSAdminStatus, tmnxSyncIfTimingRefOrder1=tmnxSyncIfTimingRefOrder1, tmnxMdaTypeIndex=tmnxMdaTypeIndex, tmnxFPAccIngQGrpPStatTable=tmnxFPAccIngQGrpPStatTable, tmnxChassis7450V6v0Compliance=tmnxChassis7450V6v0Compliance, tmnxChassisObjs=tmnxChassisObjs, tmnxCpmCardBootOptionLastModified=tmnxCpmCardBootOptionLastModified, tmnxEqSyncIfTimingSystemQuality=tmnxEqSyncIfTimingSystemQuality, tmnxCpmCardConfigBootedVersion=tmnxCpmCardConfigBootedVersion, tmnxMDACapabilities=tmnxMDACapabilities, tFPNetIngQGrpArbitStatEntry=tFPNetIngQGrpArbitStatEntry, tmnxHsmdaMdaSchOvrEntry=tmnxHsmdaMdaSchOvrEntry, tmnxChassisReboot=tmnxChassisReboot, tmnxSyncIfTimingRef2AdminStatus=tmnxSyncIfTimingRef2AdminStatus, tSyncIfTimingAdmBITS2InAdminStatus=tSyncIfTimingAdmBITS2InAdminStatus, tmnxFanTrayComponentTable=tmnxFanTrayComponentTable, tmnxFPNetIngQGrpDescr=tmnxFPNetIngQGrpDescr, tmnxCardCmplx2CAMErrorOccurTime=tmnxCardCmplx2CAMErrorOccurTime, tmnxSyncIfTimingV8v0Group=tmnxSyncIfTimingV8v0Group, tmnxSyncIfTimingPTPInUse=tmnxSyncIfTimingPTPInUse, tmnxFPNetIngQGrpTableLastChgd=tmnxFPNetIngQGrpTableLastChgd, tmnxFPAccIngQGrpPStatPolicerId=tmnxFPAccIngQGrpPStatPolicerId, tmnxChassisNumFans=tmnxChassisNumFans, tmnxFPAccIngQGrpAcctgPolId=tmnxFPAccIngQGrpAcctgPolId, tmnxCardFwdDirection=tmnxCardFwdDirection, tmnxCcagPathCcHwMac=tmnxCcagPathCcHwMac)
mibBuilder.exportSymbols("TIMETRA-CHASSIS-MIB", tmnxSyncIfTimingRef1Alarm=tmnxSyncIfTimingRef1Alarm, tmnxHwFailureReason=tmnxHwFailureReason, tmnxPeConfigurationError=tmnxPeConfigurationError, tmnxMDAHiBwMcastAlarm=tmnxMDAHiBwMcastAlarm, tmnxMDAEgrNamedPoolPolicy=tmnxMDAEgrNamedPoolPolicy, TmnxBITSIfType=TmnxBITSIfType, tmnxChassisAdminValueObjs=tmnxChassisAdminValueObjs, tmnxCcagPathCcCollectStats=tmnxCcagPathCcCollectStats, tmnxCardV10v0Group=tmnxCardV10v0Group, TmnxChassisPemType=TmnxChassisPemType, tmnxChassisNotifyObjsV6v1Group=tmnxChassisNotifyObjsV6v1Group, tmnxSyncIfTimingBITS2AdminStatus=tmnxSyncIfTimingBITS2AdminStatus, TmnxMDASuppType=TmnxMDASuppType, tmnxChassisNumPwrSupplies=tmnxChassisNumPwrSupplies, tmnxChassisFanTable=tmnxChassisFanTable, tmnxFPNetIngQgPStFwdOutProfPktsL=tmnxFPNetIngQgPStFwdOutProfPktsL, tmnxPeSoftwareAbnormalHalt=tmnxPeSoftwareAbnormalHalt, tmnxChassisNotificationClear=tmnxChassisNotificationClear, tmnxChassisFanIndex=tmnxChassisFanIndex, tmnxFPAccIngQGrpPStatMode=tmnxFPAccIngQGrpPStatMode, tmnxIPsecIsaGrpTunnelReassembly=tmnxIPsecIsaGrpTunnelReassembly, tmnxHsmdaMdaSchOvrClass6WtInGrp=tmnxHsmdaMdaSchOvrClass6WtInGrp, tSyncIfTimingAdmRef1SrcPort=tSyncIfTimingAdmRef1SrcPort, tmnxFPNetIngQgPStDrpHPrioPktsL=tmnxFPNetIngQgPStDrpHPrioPktsL, tmnxChassisCLLICode=tmnxChassisCLLICode, tmnxCcagPathCcIngPoolSlpPlcy=tmnxCcagPathCcIngPoolSlpPlcy, tmnxIPsecNotifV7v0Group=tmnxIPsecNotifV7v0Group, tmnxFPAccIngQgPStDrpLPrioPktsL=tmnxFPAccIngQgPStDrpLPrioPktsL, tFPAccIngQGrpArbitStatFwdOctsH=tFPAccIngQGrpArbitStatFwdOctsH, tmnxEqSyncIfTimingPTPAlarmClear=tmnxEqSyncIfTimingPTPAlarmClear, tmnxFPAccIngQgPStOffHPrioPktsL=tmnxFPAccIngQgPStOffHPrioPktsL, tmnxCcagPathRateOption=tmnxCcagPathRateOption, tmnxMDAMcPathMgmtPriPathLimit=tmnxMDAMcPathMgmtPriPathLimit, tmnxEqSyncIfTimingHoldoverClear=tmnxEqSyncIfTimingHoldoverClear, tFPAccIngQGrpArbitStatFwdOctsL=tFPAccIngQGrpArbitStatFwdOctsL, tmnxCardNumMdas=tmnxCardNumMdas, tmnxIPsecIsaGrpTableLastChanged=tmnxIPsecIsaGrpTableLastChanged, tmnxMcmSupportedTypes=tmnxMcmSupportedTypes, tmnxSyncIfTimingRef2InUse=tmnxSyncIfTimingRef2InUse, TmnxLEDState=TmnxLEDState, tmnxChassisPowerSupplyInputStatus=tmnxChassisPowerSupplyInputStatus, tmnxCardCmplx1IngrFcsOccur=tmnxCardCmplx1IngrFcsOccur, tmnxCpmCardCmplxCAMErrOccurTime=tmnxCpmCardCmplxCAMErrOccurTime, tmnxCpmFlashTable=tmnxCpmFlashTable, tmnxSyncIfTimingRefOrder2=tmnxSyncIfTimingRefOrder2, tmnxSyncIfTimingRef2SrcPort=tmnxSyncIfTimingRef2SrcPort, TmnxCcagRate=TmnxCcagRate, tmnxChassisNumFanTrays=tmnxChassisNumFanTrays, tmnxCcagPathEntry=tmnxCcagPathEntry, tmnxHwFirmwareCodeVersion=tmnxHwFirmwareCodeVersion, tmnxSyncIfTimingRef1Qualified=tmnxSyncIfTimingRef1Qualified, tFPAccIngQGrpPlcrOvrPolicerId=tFPAccIngQGrpPlcrOvrPolicerId, tmnxIPsecIsaGrpV6v0Group=tmnxIPsecIsaGrpV6v0Group, tmnxFPNetIngQgPStDrpLPrioPktsL=tmnxFPNetIngQgPStDrpLPrioPktsL, tmnxChassisNotificationV7v0Group=tmnxChassisNotificationV7v0Group, tmnxChassisEntry=tmnxChassisEntry, tmnxCpmCardConfigFileLastBootedHeader=tmnxCpmCardConfigFileLastBootedHeader, tmnxFPNetIngQgPStFwdInProfPkts=tmnxFPNetIngQgPStFwdInProfPkts, tmnxHwIndex=tmnxHwIndex, tmnxFPAccIngQgPStOffHPrioOcts=tmnxFPAccIngQgPStOffHPrioOcts, tmnxCardSoftReset=tmnxCardSoftReset, tmnxChassisAdminObjects=tmnxChassisAdminObjects, tmnxFPMcPathMgmtAdminState=tmnxFPMcPathMgmtAdminState, tmnxCardLastBootupReason=tmnxCardLastBootupReason, tmnxFPAccIngQgPStDrpLPrioOcts=tmnxFPAccIngQgPStDrpLPrioOcts, tmnxChassisV10v0Compliance=tmnxChassisV10v0Compliance, tSyncIfTimingAdmPTPCfgQltyLevel=tSyncIfTimingAdmPTPCfgQltyLevel, tmnxFPAccIngQgPStDrpHPrioOctsL=tmnxFPAccIngQgPStDrpHPrioOctsL, tSyncIfTimingAdmRef1BITSIfType=tSyncIfTimingAdmRef1BITSIfType, tmnxChassisNotifyCardName=tmnxChassisNotifyCardName, tmnxCpmCardSyncFileNotPresent=tmnxCpmCardSyncFileNotPresent, tmnxMDATable=tmnxMDATable, tmnxSyncIfTimingBITSInUse=tmnxSyncIfTimingBITSInUse, tmnxCcmTypeIndex=tmnxCcmTypeIndex, tmnxMdaTypeName=tmnxMdaTypeName, tmnxChassisV5v0Compliance=tmnxChassisV5v0Compliance, tmnxChassisType=tmnxChassisType, tmnxCardSchedRun=tmnxCardSchedRun, tmnxHwTemperature=tmnxHwTemperature, tmnxHsmdaMdaSchOvrClass8WtInGrp=tmnxHsmdaMdaSchOvrClass8WtInGrp, tmnxEqPowerSupplyInserted=tmnxEqPowerSupplyInserted, TmnxSETSRefQualified=TmnxSETSRefQualified, tmnxCcagPathLastChanged=tmnxCcagPathLastChanged, tFPNetIngQGrpArbitStatFwdOctsL=tFPNetIngQGrpArbitStatFwdOctsL, tmnxCcagPathCcQueuePlcy=tmnxCcagPathCcQueuePlcy, tmnxCpmCardNumCpus=tmnxCpmCardNumCpus, tmnxHwMfgString=tmnxHwMfgString, tmnxHwTempSensor=tmnxHwTempSensor, tmnxFabricSlotNum=tmnxFabricSlotNum, tmnxMDAHiBwMcastTapCount=tmnxMDAHiBwMcastTapCount, tmnxChassisGroups=tmnxChassisGroups, tmnxMDAMcPathMgmtV6v0Group=tmnxMDAMcPathMgmtV6v0Group, tmnxChassisV7v0Group=tmnxChassisV7v0Group, tmnxFPNetIngQGrpEntry=tmnxFPNetIngQGrpEntry, tmnxCpmFlashEntry=tmnxCpmFlashEntry, tmnxCpmFlashHwIndex=tmnxCpmFlashHwIndex, TmnxChassisIndex=TmnxChassisIndex, tmnxChassisV10v0Group=tmnxChassisV10v0Group, tmnxFPAccIngQgPStFwdOutProfOctsL=tmnxFPAccIngQgPStFwdOutProfOctsL, tFPAccIngQGrpPlcrOvrAdminCIR=tFPAccIngQGrpPlcrOvrAdminCIR, tmnxCcagPathWeight=tmnxCcagPathWeight, tmnxHwNotification=tmnxHwNotification, tmnxEqFanFailure=tmnxEqFanFailure, tmnxChassisV5v0Group=tmnxChassisV5v0Group, tmnxFPNetIngQgPStDrpLPrioOctsL=tmnxFPNetIngQgPStDrpLPrioOctsL, tmnxMdaObsoletedV10v0Group=tmnxMdaObsoletedV10v0Group, tmnxHsmdaMdaSchOvrClass1Rate=tmnxHsmdaMdaSchOvrClass1Rate, tFPAccIngQGrpArbitStatFwdPkts=tFPAccIngQGrpArbitStatFwdPkts, tmnxFPNetIngQgPStOffHPrioOctsH=tmnxFPNetIngQgPStOffHPrioOctsH, tmnxChassisNotificationV3v0Group=tmnxChassisNotificationV3v0Group, tmnxChassisHsmdaV6v0Group=tmnxChassisHsmdaV6v0Group, tmnxFPAccIngQgPStFwdInProfOcts=tmnxFPAccIngQgPStFwdInProfOcts, tmnxFPNetIngQgPStFwdOutProfOcts=tmnxFPNetIngQgPStFwdOutProfOcts, tmnxFPNetIngQgPStDrpLPrioOcts=tmnxFPNetIngQgPStDrpLPrioOcts, tmnxCardCmplx2CAMErrorOccur=tmnxCardCmplx2CAMErrorOccur, tmnxMDAEntry=tmnxMDAEntry, tSyncIfTimingAdmRef1NationalUse=tSyncIfTimingAdmRef1NationalUse, tmnxFPNetIngQgPStOffHPrioPkts=tmnxFPNetIngQgPStOffHPrioPkts, tmnxCardTypeIndex=tmnxCardTypeIndex, tmnxMDAClockMode=tmnxMDAClockMode, tmnxChassisAdminControlApply=tmnxChassisAdminControlApply, tmnxCardCmplx2IngrFcsOccur=tmnxCardCmplx2IngrFcsOccur, tmnxMDAMcPathMgmtAncPathLimit=tmnxMDAMcPathMgmtAncPathLimit, tmnxChassisMinorLEDState=tmnxChassisMinorLEDState, tmnxCardCmplx1EgrFcsSrcSlots=tmnxCardCmplx1EgrFcsSrcSlots, tSyncIfTimingAdmQLSelection=tSyncIfTimingAdmQLSelection, tmnxCpmCardBootOptionVersion=tmnxCpmCardBootOptionVersion, tmnxCpmCardReboot=tmnxCpmCardReboot, TmnxCardType=TmnxCardType, tmnxCardAllowedTypes=tmnxCardAllowedTypes, tmnxCardCmplx1CAMErrorOccurTime=tmnxCardCmplx1CAMErrorOccurTime, tmnxCcagAdminStatus=tmnxCcagAdminStatus, tmnxFPNetIngQGrpPStatMode=tmnxFPNetIngQGrpPStatMode, tmnxCcagPathRate=tmnxCcagPathRate, tmnxEqSyncIfTimingHoldover=tmnxEqSyncIfTimingHoldover, tmnxEqMdaXplError=tmnxEqMdaXplError, tmnxEqSyncIfTimingBITS2Quality=tmnxEqSyncIfTimingBITS2Quality, tmnxFabricTypeEntry=tmnxFabricTypeEntry, tmnxChassisV5v0ObsoleteGroup=tmnxChassisV5v0ObsoleteGroup, tmnxChassisV4v0Compliance=tmnxChassisV4v0Compliance, tSyncIfTimingAdmBITSOutSource=tSyncIfTimingAdmBITSOutSource, tmnxHwEquippedPlatform=tmnxHwEquippedPlatform, tmnxFPNetIngQgPStFwdInProfOctsH=tmnxFPNetIngQgPStFwdInProfOctsH, tmnxSyncIfTimingRef2CfgQltyLevel=tmnxSyncIfTimingRef2CfgQltyLevel, tmnxMDAV6v1Group=tmnxMDAV6v1Group, tmnxMDAReboot=tmnxMDAReboot, tmnxEqCardFailure=tmnxEqCardFailure, tmnxMDASlotNum=tmnxMDASlotNum, tmnxFPNetIngQgPStOffHPrioOctsL=tmnxFPNetIngQgPStOffHPrioOctsL, tmnxEqSyncIfTimingBITSOutRefChg=tmnxEqSyncIfTimingBITSOutRefChg, tmnxSyncIfTimingBITSNationalUse=tmnxSyncIfTimingBITSNationalUse, tmnxFPNetIngQgPStOffLPrioOcts=tmnxFPNetIngQgPStOffLPrioOcts, TmnxSlotNum=TmnxSlotNum, TmnxHwIndex=TmnxHwIndex, tmnxEqHwEnhancedCapability=tmnxEqHwEnhancedCapability, tmnxCardSlowQueueThresh=tmnxCardSlowQueueThresh, tmnxChassisNotifyPrefix=tmnxChassisNotifyPrefix, tmnxChassisNotifyCardSyncFile=tmnxChassisNotifyCardSyncFile, tmnxSyncIfTimingRefOrder5=tmnxSyncIfTimingRefOrder5, tmnxFPHiBwMcastGroup=tmnxFPHiBwMcastGroup, tmnxMDASynchronousEthernet=tmnxMDASynchronousEthernet, tmnxRedSecondaryCPMStatus=tmnxRedSecondaryCPMStatus, tmnxCardTypeName=tmnxCardTypeName, tmnxFabricEntry=tmnxFabricEntry, tmnxFPAccIngQgPStFwdOutProfPkts=tmnxFPAccIngQgPStFwdOutProfPkts, tmnxHwBootCodeVersion=tmnxHwBootCodeVersion, tmnxCcagTable=tmnxCcagTable, tmnxCardReboot=tmnxCardReboot, tmnxCardCmplx1IngrFcsOccurTime=tmnxCardCmplx1IngrFcsOccurTime, tmnxChassisTotalNumber=tmnxChassisTotalNumber, tSyncIfTimingAdmRef2AdminStatus=tSyncIfTimingAdmRef2AdminStatus, tmnxHwID=tmnxHwID, tmnxSyncIfTimingQLSelection=tmnxSyncIfTimingQLSelection, tmnxChassisMixedModeIomUpgrList=tmnxChassisMixedModeIomUpgrList, tmnxSlotObjs=tmnxSlotObjs, tmnxCardSrcSlotBitmap=tmnxCardSrcSlotBitmap, tmnxMDASupportedTypes=tmnxMDASupportedTypes, tmnxCardTable=tmnxCardTable, tmnxChassisNotificationObjects=tmnxChassisNotificationObjects, tmnxFPNetIngQgPStUncolOctsOffH=tmnxFPNetIngQgPStUncolOctsOffH, tmnxChassisNotifyChassisId=tmnxChassisNotifyChassisId, tmnxIPsecIsaGrpTnlLowWMark=tmnxIPsecIsaGrpTnlLowWMark, TmnxFabricSuppType=TmnxFabricSuppType, tmnxCcmTypeTable=tmnxCcmTypeTable, tmnxFPAccIngQgPStFwdInProfPktsL=tmnxFPAccIngQgPStFwdInProfPktsL, tmnxFPMcPathMgmtV6v1Group=tmnxFPMcPathMgmtV6v1Group, tmnxCcmTypeDescription=tmnxCcmTypeDescription, tmnxHsmdaMdaSchOvrTable=tmnxHsmdaMdaSchOvrTable, tmnxChassisFanRevision=tmnxChassisFanRevision, tmnxHwSwImageSource=tmnxHwSwImageSource, tmnxCcagPathCcMac=tmnxCcagPathCcMac, tmnxFPAccIngQGrpInstanceId=tmnxFPAccIngQGrpInstanceId, tmnxChassisNotificationV6v1Group=tmnxChassisNotificationV6v1Group, tmnxHwResourcePeakAmperageTime=tmnxHwResourcePeakAmperageTime, tmnxCpmFlashOperStatus=tmnxCpmFlashOperStatus, tmnxChassisComp7710V6v1=tmnxChassisComp7710V6v1, tmnxIPsecIsaGrpEntry=tmnxIPsecIsaGrpEntry, tmnxFPAccIngQGrpTableLastChgd=tmnxFPAccIngQGrpTableLastChgd, tmnxCpmCardLastChange=tmnxCpmCardLastChange, tmnxIPsecIsaGrpIpTunnels=tmnxIPsecIsaGrpIpTunnels, tmnxFPNetIngQgPStFwdOutProfOctsL=tmnxFPNetIngQgPStFwdOutProfOctsL, tmnxEqTypeNotificationRow=tmnxEqTypeNotificationRow, tmnxCardSoftResetState=tmnxCardSoftResetState, tmnxEnvTempTooHigh=tmnxEnvTempTooHigh, tmnxFPQGrpV10v0R4Group=tmnxFPQGrpV10v0R4Group, tmnxChassisAdminMode=tmnxChassisAdminMode, tmnxMDAMcPathMgmtAncInUseBw=tmnxMDAMcPathMgmtAncInUseBw, tmnxFPAccIngQGrpEntry=tmnxFPAccIngQGrpEntry, tmnxFPAccIngQGrpRowStatus=tmnxFPAccIngQGrpRowStatus, tmnxEqCpuFailure=tmnxEqCpuFailure, tmnxMDAHiBwMcastGroup=tmnxMDAHiBwMcastGroup, tmnxMDATxTimingSelected=tmnxMDATxTimingSelected, tmnxFPAccIngQGrpLastChgd=tmnxFPAccIngQGrpLastChgd, tmnxMDASyncIfTimingStatus=tmnxMDASyncIfTimingStatus, tmnxFPNetIngQgPStDrpLPrioOctsH=tmnxFPNetIngQgPStDrpLPrioOctsH, tmnxHwAdminState=tmnxHwAdminState, TmnxCcagId=TmnxCcagId, tmnxEqNotificationRow=tmnxEqNotificationRow, tmnxChassisAdminCtrlObjs=tmnxChassisAdminCtrlObjs, tmnxPeStorageProblem=tmnxPeStorageProblem, tmnxMDAV3v0Group=tmnxMDAV3v0Group, tmnxMDAHiBwMcastSource=tmnxMDAHiBwMcastSource, tmnx77x0CESMDAV6v0Group=tmnx77x0CESMDAV6v0Group, tmnxChassisNotification=tmnxChassisNotification, tmnxFPHiBwMcastDefaultPathsOnly=tmnxFPHiBwMcastDefaultPathsOnly, tmnxFPAccIngQgPStFwdOutProfPktsL=tmnxFPAccIngQgPStFwdOutProfPktsL, tmnxHwContainedIn=tmnxHwContainedIn, tmnxHwResourcePeakAmperage=tmnxHwResourcePeakAmperage, tmnxFPNetIngQgPStFwdInProfPktsH=tmnxFPNetIngQgPStFwdInProfPktsH, tmnxVirtualSchedulerAdjTable=tmnxVirtualSchedulerAdjTable, tmnxIPsecIsaGrpMultiActive=tmnxIPsecIsaGrpMultiActive, tmnxSyncIfTimingRef2BITSIfType=tmnxSyncIfTimingRef2BITSIfType, tmnxSyncIfTimingNotifyAlarm=tmnxSyncIfTimingNotifyAlarm, tmnxPeSoftwareVersionMismatch=tmnxPeSoftwareVersionMismatch, tmnxChassisPowerSupplyTable=tmnxChassisPowerSupplyTable, tmnxHwMfgAssemblyNumber=tmnxHwMfgAssemblyNumber, tmnxHwContainedIndex=tmnxHwContainedIndex, tmnxVirtualSchedulerAdjEntry=tmnxVirtualSchedulerAdjEntry, tmnxMDACcagId=tmnxMDACcagId, tmnxSyncIfTimingRef1BITSIfType=tmnxSyncIfTimingRef1BITSIfType, tmnxFPAccIngQgPStOffLPrioPktsL=tmnxFPAccIngQgPStOffLPrioPktsL, tmnxCardCmplx2EgrFcsSrcSlots=tmnxCardCmplx2EgrFcsSrcSlots, tFPAccIngQGrpPlcrOvrRowStatus=tFPAccIngQGrpPlcrOvrRowStatus, tmnxIPsecIsaGrpMaxTunnels=tmnxIPsecIsaGrpMaxTunnels, tmnxSyncIfTimingBITS2State=tmnxSyncIfTimingBITS2State, tmnxCcagDescription=tmnxCcagDescription, tmnxCardV3v0Group=tmnxCardV3v0Group, tmnxFabricTypeDescription=tmnxFabricTypeDescription, tmnxEqSyncIfTimingRef1Alarm=tmnxEqSyncIfTimingRef1Alarm, tmnxChassisPowerSupplyTempThreshold=tmnxChassisPowerSupplyTempThreshold, tmnxHwSoftwareCodeVersion=tmnxHwSoftwareCodeVersion, tmnxHwSwState=tmnxHwSwState, tmnxChassisIndex=tmnxChassisIndex, tmnxHsmdaMdaSchOvrTblLastChangd=tmnxHsmdaMdaSchOvrTblLastChangd)
mibBuilder.exportSymbols("TIMETRA-CHASSIS-MIB", tmnxSyncIfTimingBITSOutSource=tmnxSyncIfTimingBITSOutSource, tmnxFPAccIngQgPStOffLPrioOcts=tmnxFPAccIngQgPStOffLPrioOcts, tmnxChassisTypeDescription=tmnxChassisTypeDescription, tmnxIPsecIsaGrpPrimaryIsa=tmnxIPsecIsaGrpPrimaryIsa, tmnxFPNetIngQgPStDrpHPrioOctsH=tmnxFPNetIngQgPStDrpHPrioOctsH, tmnxChassisName=tmnxChassisName, tmnxMDAIsaTunnelGroupChange=tmnxMDAIsaTunnelGroupChange, tmnxChassis7750V6v1Compliance=tmnxChassis7750V6v1Compliance, tmnxChassisPowerSupplyTempStatus=tmnxChassisPowerSupplyTempStatus, tmnxHwClass=tmnxHwClass, tmnxEqCardPChipMemoryEvent=tmnxEqCardPChipMemoryEvent, tmnxChassisUserModV7v0Group=tmnxChassisUserModV7v0Group, tmnxSyncIfTimingNotifV8v0Group=tmnxSyncIfTimingNotifV8v0Group, tSyncIfTimingAdmRefOrder4=tSyncIfTimingAdmRefOrder4, tmnxMcmTypeTable=tmnxMcmTypeTable, tmnxFPAccIngQGrpDescr=tmnxFPAccIngQGrpDescr, tmnxFPNetIngQGrpPStatEntry=tmnxFPNetIngQGrpPStatEntry, tmnxCpmCardAssignedType=tmnxCpmCardAssignedType, tmnxChassisV6v0Group=tmnxChassisV6v0Group, tmnxEqSyncIfTimingRef1Quality=tmnxEqSyncIfTimingRef1Quality, tmnxChassisComp7710V3v0=tmnxChassisComp7710V3v0, tmnxIPsecIsaGrpDescription=tmnxIPsecIsaGrpDescription, tmnxMDAIsaTunnelGroupInUse=tmnxMDAIsaTunnelGroupInUse, tmnxChassisNotifyObjsV5v0Group=tmnxChassisNotifyObjsV5v0Group, tmnxHwLastAlarmEvent=tmnxHwLastAlarmEvent, tmnxCardCmplx2MemParityOccurTime=tmnxCardCmplx2MemParityOccurTime, tmnxCpmCardTable=tmnxCpmCardTable, tmnxCcagPathCcUserAssignedMac=tmnxCcagPathCcUserAssignedMac, tmnxFPNetIngQgPStOffHPrioPktsH=tmnxFPNetIngQgPStOffHPrioPktsH, tmnxChassisMixedModeIomV8v0Group=tmnxChassisMixedModeIomV8v0Group, tmnxEqCardRemoved=tmnxEqCardRemoved, tmnxFPNetIngQgPStOffLPrioOctsL=tmnxFPNetIngQgPStOffLPrioOctsL, tmnxChassisPowerSupplyEntry=tmnxChassisPowerSupplyEntry, tmnxCpmFlashFirmwareRevision=tmnxCpmFlashFirmwareRevision, tmnxSyncIfTimingBITSQualified=tmnxSyncIfTimingBITSQualified, tmnxSyncIfTimingRef1SrcPort=tmnxSyncIfTimingRef1SrcPort, tmnxFPAccIngQgPStOffLPrioOctsL=tmnxFPAccIngQgPStOffLPrioOctsL, tmnxMDAIngHsmdaSchedPolicy=tmnxMDAIngHsmdaSchedPolicy, tmnxCpmCardConfigFileLastBooted=tmnxCpmCardConfigFileLastBooted, tmnxHsmdaMdaSchOvrMaxRate=tmnxHsmdaMdaSchOvrMaxRate, tmnxHsmdaMdaSchOvrClass5Rate=tmnxHsmdaMdaSchOvrClass5Rate, tmnxHwResourcePeakVoltage=tmnxHwResourcePeakVoltage, tFPAccIngQGrpPlcrOvrPktOffset=tFPAccIngQGrpPlcrOvrPktOffset, tmnxChassisV9v0Compliance=tmnxChassisV9v0Compliance, tmnxEqSyncIfTimingBITS2Alarm=tmnxEqSyncIfTimingBITS2Alarm, tmnxChassisNotifyObjsV9v0Group=tmnxChassisNotifyObjsV9v0Group, tmnxMDAV9v0Group=tmnxMDAV9v0Group, tmnxIPsecIsaGrpActiveIsaChgd=tmnxIPsecIsaGrpActiveIsaChgd, tmnxFPTable=tmnxFPTable, tmnxHwResourceMinVoltageTime=tmnxHwResourceMinVoltageTime, tmnxCcagPathCcEgrPoolSlpPlcy=tmnxCcagPathCcEgrPoolSlpPlcy, tmnxMcmTypeIndex=tmnxMcmTypeIndex, tmnxCpmCardConfigUserLastModified=tmnxCpmCardConfigUserLastModified, tmnxMcmTypeEntry=tmnxMcmTypeEntry, tmnxCcagOperStatus=tmnxCcagOperStatus, tmnxChassisNotifyObsoleteGroup=tmnxChassisNotifyObsoleteGroup, tSyncIfTimingAdmRefOrder5=tSyncIfTimingAdmRefOrder5, tmnxMDACcagV6v1Group=tmnxMDACcagV6v1Group, tmnxHwMfgBoardNumber=tmnxHwMfgBoardNumber, tmnxSyncIfTimingBITS2InUse=tmnxSyncIfTimingBITS2InUse, tmnxCardObjs=tmnxCardObjs, TmnxSETSRefAlarm=TmnxSETSRefAlarm, tmnxCcagEntry=tmnxCcagEntry, tmnxFPNetIngQgPStOffHPrioOcts=tmnxFPNetIngQgPStOffHPrioOcts, tmnxEqSyncIfTimingBITS2AlarmClr=tmnxEqSyncIfTimingBITS2AlarmClr, tmnxSyncIfTimingRef2State=tmnxSyncIfTimingRef2State, tmnxCcmTypeEntry=tmnxCcmTypeEntry, tmnxFPAccIngQgPStDrpHPrioPktsL=tmnxFPAccIngQgPStDrpHPrioPktsL, tmnxFPQGrpGroup=tmnxFPQGrpGroup, tmnxChassisCompliances=tmnxChassisCompliances, tmnxCpmCardEquippedType=tmnxCpmCardEquippedType, tmnxMDAAtmMode=tmnxMDAAtmMode, tmnxIPsecIsaGrpLastChanged=tmnxIPsecIsaGrpLastChanged, tmnxFPNetIngQgPStOffLPrioPktsH=tmnxFPNetIngQgPStOffLPrioPktsH, tmnxChassisNumPorts=tmnxChassisNumPorts, tmnxSyncIfTimingBITSState=tmnxSyncIfTimingBITSState, tmnxFPNetIngQGrpLastChgd=tmnxFPNetIngQGrpLastChgd, tmnxHsmdaMdaSchOvrClass4WtInGrp=tmnxHsmdaMdaSchOvrClass4WtInGrp, tmnxHsmdaMdaSchOvrClass7WtInGrp=tmnxHsmdaMdaSchOvrClass7WtInGrp, tmnxCpmFlashId=tmnxCpmFlashId, tmnxCpmFlashUsed=tmnxCpmFlashUsed, tmnxFPAccIngQgPStDrpHPrioPkts=tmnxFPAccIngQgPStDrpHPrioPkts, tmnxHwResourceMinWattage=tmnxHwResourceMinWattage, tmnxFPAccIngQGrpCollectStats=tmnxFPAccIngQGrpCollectStats, tmnxChassisComp7710V7v0=tmnxChassisComp7710V7v0, tmnxIPsecIsaGrpIsaChassis=tmnxIPsecIsaGrpIsaChassis, tmnxHwResourceCurrentVoltage=tmnxHwResourceCurrentVoltage, tFPAccIngQGrpPlcrOvrEntry=tFPAccIngQGrpPlcrOvrEntry, tmnxHwResourcePeakVoltageTime=tmnxHwResourcePeakVoltageTime, tmnxMDAIsaTunnelGroup=tmnxMDAIsaTunnelGroup, tmnxEqBackdoorBusFailure=tmnxEqBackdoorBusFailure, tmnxFPAccIngQgPStUncolOctsOff=tmnxFPAccIngQgPStUncolOctsOff, tmnxChassisPowerSupplyACStatus=tmnxChassisPowerSupplyACStatus, tmnxCcagPathTable=tmnxCcagPathTable, tmnxMDAChannelsInUse=tmnxMDAChannelsInUse, tmnxFPNetIngQgPStUncolOctsOffL=tmnxFPNetIngQgPStUncolOctsOffL, tmnxMcmTypeDescription=tmnxMcmTypeDescription, TmnxSSMQualityLevel=TmnxSSMQualityLevel, tmnxCcagPathCcAcctPolicyId=tmnxCcagPathCcAcctPolicyId, tmnxFPWredBufAllocMax=tmnxFPWredBufAllocMax, tmnx7710SETSRefSrcHwV6v0Group=tmnx7710SETSRefSrcHwV6v0Group, tmnxChassisFanEntry=tmnxChassisFanEntry, tmnxCpmFlashModelNumber=tmnxCpmFlashModelNumber, tmnxSyncIfTimingBITS2Qualified=tmnxSyncIfTimingBITS2Qualified, tmnxFPNetIngQGrpPStatTable=tmnxFPNetIngQGrpPStatTable, tFPAccIngQGrpArbitStatFwdPktsH=tFPAccIngQGrpArbitStatFwdPktsH, tmnxCpmCardSlotNum=tmnxCpmCardSlotNum, tmnxSyncIfTimingBITSOutAdmStatus=tmnxSyncIfTimingBITSOutAdmStatus, tmnxFPWredResvCbsMin=tmnxFPWredResvCbsMin, tmnxChassisNotifyMismatchedVer=tmnxChassisNotifyMismatchedVer, tmnxChassisTypeTable=tmnxChassisTypeTable, tmnxCardTypeStatus=tmnxCardTypeStatus, tmnxSyncIfTimingTable=tmnxSyncIfTimingTable, tmnxFPNetIngQGrpCollectStats=tmnxFPNetIngQGrpCollectStats, tmnxFPAccIngQgPStFwdOutProfOcts=tmnxFPAccIngQgPStFwdOutProfOcts, tmnxCcagPathId=tmnxCcagPathId, tmnxEqPowerSupplyFailure=tmnxEqPowerSupplyFailure, tmnxCardSupportedTypes=tmnxCardSupportedTypes, tmnxSyncIfTimingOtherCPMAlarm=tmnxSyncIfTimingOtherCPMAlarm, tSyncIfTimingAdmBITSNationalUse=tSyncIfTimingAdmBITSNationalUse, tSyncIfTimingAdmRef1AdminStatus=tSyncIfTimingAdmRef1AdminStatus, tmnxFPAccIngQgPStFwdInProfOctsH=tmnxFPAccIngQgPStFwdInProfOctsH, tmnxFPNetIngQgPStOffHPrioPktsL=tmnxFPNetIngQgPStOffHPrioPktsL, tmnxChassisV3v0Group=tmnxChassisV3v0Group, tmnxFPAccIngQgPStDrpLPrioPkts=tmnxFPAccIngQgPStDrpLPrioPkts, TmnxTunnelGroupIdOrZero=TmnxTunnelGroupIdOrZero, tmnxMDADiffTimestampFreq=tmnxMDADiffTimestampFreq, tmnxCardEntry=tmnxCardEntry, tmnxChassis7750V6v0Compliance=tmnxChassis7750V6v0Compliance, tmnxSyncIfTimingPTPAlarm=tmnxSyncIfTimingPTPAlarm, tmnxEqSyncIfTimingPTPQuality=tmnxEqSyncIfTimingPTPQuality, tmnxCcagPathCcType=tmnxCcagPathCcType, TmnxSlotNumOrZero=TmnxSlotNumOrZero, tmnxSyncIfTimingBITSTxQltyLevel=tmnxSyncIfTimingBITSTxQltyLevel, tmnxEqSyncIfTimingRef2Quality=tmnxEqSyncIfTimingRef2Quality, tmnxHwResourceMinAmperage=tmnxHwResourceMinAmperage, tmnxAtmGroup=tmnxAtmGroup, tmnxHwOperState=tmnxHwOperState, tmnxCardCmplx1CAMErrorOccur=tmnxCardCmplx1CAMErrorOccur, tmnxFabricTypeIndex=tmnxFabricTypeIndex, tmnxFPHiBwMcastSource=tmnxFPHiBwMcastSource, TmnxRefInState=TmnxRefInState, tmnxChassis7450V6v1Compliance=tmnxChassis7450V6v1Compliance, tmnxSyncIfTimingPTPQualified=tmnxSyncIfTimingPTPQualified, tmnxCcagCcaRate=tmnxCcagCcaRate, TmnxMdaType=TmnxMdaType, tmnxHwAlias=tmnxHwAlias, tmnxHwEntry=tmnxHwEntry, tmnxCardTaskScheduling=tmnxCardTaskScheduling, tmnxCpmCardSwitchToRedundantCard=tmnxCpmCardSwitchToRedundantCard, tmnxCcmEquippedType=tmnxCcmEquippedType, tmnxHwSwLastBoot=tmnxHwSwLastBoot, tSyncIfTimingAdmRef2SrcPort=tSyncIfTimingAdmRef2SrcPort, tmnxFPAccIngQgPStOffHPrioOctsL=tmnxFPAccIngQgPStOffHPrioOctsL, tmnxCardRateCalcSlowQueue=tmnxCardRateCalcSlowQueue, tmnxHwResourcePeakWattageTime=tmnxHwResourcePeakWattageTime, tmnxFPNetIngQgPStUncolPktsOffL=tmnxFPNetIngQgPStUncolPktsOffL, tmnxIPsecIsaGrpUnableToSwitch=tmnxIPsecIsaGrpUnableToSwitch, tSyncIfTimingAdmBITSIfType=tSyncIfTimingAdmBITSIfType, tmnxCardTypeEntry=tmnxCardTypeEntry, tmnxMDAHwIndex=tmnxMDAHwIndex, tmnxCardTypeTable=tmnxCardTypeTable, tmnxChassisOverTempState=tmnxChassisOverTempState, tmnxCpmCardSupportedTypes=tmnxCpmCardSupportedTypes, tSyncIfTimingAdmBITSOutLineLen=tSyncIfTimingAdmBITSOutLineLen, tmnxFabricTypeStatus=tmnxFabricTypeStatus, tmnxSyncIfTimingBITS2InAdminStatus=tmnxSyncIfTimingBITS2InAdminStatus, tmnxMcmTable=tmnxMcmTable, tmnxFPNetIngQGrpPStatPolicerId=tmnxFPNetIngQGrpPStatPolicerId, tmnxHwIsFRU=tmnxHwIsFRU, tmnxMDAV4v0Group=tmnxMDAV4v0Group, tmnxCcmTypeName=tmnxCcmTypeName, tmnxCcmIndex=tmnxCcmIndex, tmnxFPEntry=tmnxFPEntry, tmnxChassisCoordinates=tmnxChassisCoordinates, tmnxCpmCardIndexBootedVersion=tmnxCpmCardIndexBootedVersion, tFPAccIngQGrpPlcrOvrTable=tFPAccIngQGrpPlcrOvrTable, tmnxEqWrongCard=tmnxEqWrongCard, tmnxMDAMcPathMgmtSecInUseBw=tmnxMDAMcPathMgmtSecInUseBw, tmnxMDAXplFailedCount=tmnxMDAXplFailedCount, TmnxAlarmState=TmnxAlarmState, tmnxFPAccIngQgPStUncolPktsOff=tmnxFPAccIngQgPStUncolPktsOff, tmnxHwMfgDeviations=tmnxHwMfgDeviations, tmnxIPsecIsaGrpId=tmnxIPsecIsaGrpId, tmnxFabricTypeName=tmnxFabricTypeName, tmnxHwTempThreshold=tmnxHwTempThreshold, tmnxHwObjs=tmnxHwObjs, tmnxIPsecIsaGrpTnlMax=tmnxIPsecIsaGrpTnlMax, tmnxChassisUpgradeComplete=tmnxChassisUpgradeComplete, tmnxSyncIfTimingV9v0Group=tmnxSyncIfTimingV9v0Group, tmnxFPAccIngQgPStFwdInProfPkts=tmnxFPAccIngQgPStFwdInProfPkts, tmnxChassisNotifyCardFailureReason=tmnxChassisNotifyCardFailureReason, tFPAccIngQGrpPlcrOvrCBS=tFPAccIngQGrpPlcrOvrCBS, tmnxCardCmplx1EgrFcsOccurTime=tmnxCardCmplx1EgrFcsOccurTime, tmnxMDANetworkIngQueues=tmnxMDANetworkIngQueues, tmnxFPAccIngQgPStOffLPrioOctsH=tmnxFPAccIngQgPStOffLPrioOctsH, tmnxCardCmplx1EgrFcsOccur=tmnxCardCmplx1EgrFcsOccur, tmnxFPNetIngQGrpRowStatus=tmnxFPNetIngQGrpRowStatus, tmnxPeSoftwareError=tmnxPeSoftwareError, tmnxEqSyncIfTimingBITSQuality=tmnxEqSyncIfTimingBITSQuality, tmnxCardNamedPoolAdminMode=tmnxCardNamedPoolAdminMode, tmnxChassisNotifySoftwareLocation=tmnxChassisNotifySoftwareLocation, tmnxIPsecIsaGrpBackupIsa=tmnxIPsecIsaGrpBackupIsa, tmnxFPAccIngQgPStUncolPktsOffL=tmnxFPAccIngQgPStUncolPktsOffL, tmnxCardCmplx1MemParityOccurTime=tmnxCardCmplx1MemParityOccurTime, tmnxFPNetIngQGrpAcctgPolId=tmnxFPNetIngQGrpAcctgPolId, tSyncIfTimingAdmBITSAdminStatus=tSyncIfTimingAdmBITSAdminStatus, TmnxMcmType=TmnxMcmType, tmnxHwAssetID=tmnxHwAssetID, tmnxCcagPathCcEgrPoolResvCbs=tmnxCcagPathCcEgrPoolResvCbs, tmnxHsmdaMdaSchOvrLastChanged=tmnxHsmdaMdaSchOvrLastChanged, tmnxHsmdaMdaSchOvrClass1WtInGrp=tmnxHsmdaMdaSchOvrClass1WtInGrp, tmnxIPsecIsaGrpIpMaxTunnels=tmnxIPsecIsaGrpIpMaxTunnels, tmnxFPNetIngQgPStDrpLPrioPkts=tmnxFPNetIngQgPStDrpLPrioPkts, tmnxCardFailOnError=tmnxCardFailOnError, tmnxIPsecIsaGrpRowStatus=tmnxIPsecIsaGrpRowStatus, tmnxSyncIfTimingRef2RxQltyLevel=tmnxSyncIfTimingRef2RxQltyLevel, tmnxHsmdaMdaSchOvrClass2Rate=tmnxHsmdaMdaSchOvrClass2Rate, tmnxMcmSlotNum=tmnxMcmSlotNum, tmnxChassisUpdateWaitTime=tmnxChassisUpdateWaitTime, PYSNMP_MODULE_ID=tmnxChassisMIBModule, tmnxHwResourceMinWattageTime=tmnxHwResourceMinWattageTime, tmnxCpmCardBootOptionLastSaved=tmnxCpmCardBootOptionLastSaved, tmnxIPsecIsaGrpActiveMda=tmnxIPsecIsaGrpActiveMda, tFPAccIngQGrpPlcrOvrStatMode=tFPAccIngQGrpPlcrOvrStatMode, tmnxFPNetIngQGrpInstanceId=tmnxFPNetIngQGrpInstanceId, tmnxEqSyncIfTimingBITSAlarm=tmnxEqSyncIfTimingBITSAlarm, tmnxFabricAssignedType=tmnxFabricAssignedType, tFPAccIngQGrpPlcrOvrTblLstChgd=tFPAccIngQGrpPlcrOvrTblLstChgd, tmnxCcagAccessAdaptQos=tmnxCcagAccessAdaptQos, tmnxCpmCardMemorySize=tmnxCpmCardMemorySize, tmnxMcmTypeStatus=tmnxMcmTypeStatus, TmnxSETSRefSource=TmnxSETSRefSource, tmnxIPsecIsaGrpOperFlags=tmnxIPsecIsaGrpOperFlags, tmnxChassisHiBwMcastAlarm=tmnxChassisHiBwMcastAlarm, tmnxChassisNotifyObjsGroup=tmnxChassisNotifyObjsGroup, tmnxFPNetIngQgPStFwdOutProfPktsH=tmnxFPNetIngQgPStFwdOutProfPktsH, tmnxIPsecIsaGrpAdminState=tmnxIPsecIsaGrpAdminState, tmnxCardLastChange=tmnxCardLastChange, tmnxCpmCardNum=tmnxCpmCardNum, tmnxHsmdaMdaSchOvrClass4Rate=tmnxHsmdaMdaSchOvrClass4Rate, tmnxChassisComp7710V6v0=tmnxChassisComp7710V6v0, tmnxHsmdaMdaSchOvrClass3WtInGrp=tmnxHsmdaMdaSchOvrClass3WtInGrp, tmnxPeCpuCyclesExceeded=tmnxPeCpuCyclesExceeded, TmnxDeviceState=TmnxDeviceState, tmnxChassisUpgradeInProgress=tmnxChassisUpgradeInProgress, TmnxTunnelGroupId=TmnxTunnelGroupId, tmnxCcmOperStatus=tmnxCcmOperStatus, tmnxChassisLocation=tmnxChassisLocation, tmnxCcagRowStatus=tmnxCcagRowStatus, tmnxMdaTypeEntry=tmnxMdaTypeEntry, tmnxHsmdaMdaSchOvrClass3Rate=tmnxHsmdaMdaSchOvrClass3Rate, tmnxMDAMcPathMgmtSecPathLimit=tmnxMDAMcPathMgmtSecPathLimit, tmnxSyncIfTimingBITSOutRefSel=tmnxSyncIfTimingBITSOutRefSel)
mibBuilder.exportSymbols("TIMETRA-CHASSIS-MIB", tmnxFPNetIngQGrpName=tmnxFPNetIngQGrpName, tmnxCardPchipV8v0Group=tmnxCardPchipV8v0Group, tmnxEqSyncIfTimingRefSwitch=tmnxEqSyncIfTimingRefSwitch, TmnxCcagRateOption=TmnxCcagRateOption, tmnxMDAEgrHsmdaThrshLoBrstMult=tmnxMDAEgrHsmdaThrshLoBrstMult, tmnxFPWredAdminState=tmnxFPWredAdminState, tmnxCcagId=tmnxCcagId, tmnxCcmTable=tmnxCcmTable, tmnxHwContainsEntry=tmnxHwContainsEntry, tmnxChassisFanOperStatus=tmnxChassisFanOperStatus, tFPNetIngQGrpArbitStatFwdOcts=tFPNetIngQGrpArbitStatFwdOcts, tmnxMcmEntry=tmnxMcmEntry, tmnxMcmHwIndex=tmnxMcmHwIndex, tmnxChassisNotifyOID=tmnxChassisNotifyOID, tmnxCpmCardConfigSource=tmnxCpmCardConfigSource, tmnxFPMcPathMgmtBwPlcyName=tmnxFPMcPathMgmtBwPlcyName, tmnxSyncIfTimingRef2SrcHw=tmnxSyncIfTimingRef2SrcHw, tmnxMDAMaxPorts=tmnxMDAMaxPorts, tmnxFabricSupportedTypes=tmnxFabricSupportedTypes, tmnxSyncIfTimingPTPState=tmnxSyncIfTimingPTPState, tmnxHwResourcePeakWattage=tmnxHwResourcePeakWattage, tmnxFPNetIngQgPStDrpLPrioPktsH=tmnxFPNetIngQgPStDrpLPrioPktsH, tSyncIfTimingAdmBITS2OutAdminStatus=tSyncIfTimingAdmBITS2OutAdminStatus, tFPAccIngQGrpArbitStatTable=tFPAccIngQGrpArbitStatTable, tmnxChassisNotificationV6v0Group=tmnxChassisNotificationV6v0Group, tmnxMdaV10v0Group=tmnxMdaV10v0Group, tmnxFPWredBufAllocMin=tmnxFPWredBufAllocMin, tmnxHwName=tmnxHwName, tmnxCardCmplx2EgrFcsOccur=tmnxCardCmplx2EgrFcsOccur, tmnxHwResourceCurrentAmperage=tmnxHwResourceCurrentAmperage, tmnxCcmTypeStatus=tmnxCcmTypeStatus, tmnxEqCardPChipError=tmnxEqCardPChipError, tmnxEqCardPChipCamEvent=tmnxEqCardPChipCamEvent, tmnxChassisTypeStatus=tmnxChassisTypeStatus, tmnxIPsecIsaGrpTunnels=tmnxIPsecIsaGrpTunnels, tmnxChassisNotificationV5v0Group=tmnxChassisNotificationV5v0Group, tmnxFabricTypeTable=tmnxFabricTypeTable, tSyncIfTimingAdmBITSOutAdmStatus=tSyncIfTimingAdmBITSOutAdmStatus, tmnxChassisAdminLastSetTimer=tmnxChassisAdminLastSetTimer, tmnxCardCapability=tmnxCardCapability, tmnxMDAMcPathMgmtAdminState=tmnxMDAMcPathMgmtAdminState, tmnxSyncIfTimingRef1InUse=tmnxSyncIfTimingRef1InUse, tmnxSyncIfTimingBITS2TxQltyLevel=tmnxSyncIfTimingBITS2TxQltyLevel, tmnxFPAccIngQgPStFwdInProfPktsH=tmnxFPAccIngQgPStFwdInProfPktsH, tmnxHsmdaMdaSchOvrClass7Rate=tmnxHsmdaMdaSchOvrClass7Rate, tmnxCcagLastChanged=tmnxCcagLastChanged, tmnxEqPowerSupplyRemoved=tmnxEqPowerSupplyRemoved, tmnxEqSyncIfTimingBITSAlarmClear=tmnxEqSyncIfTimingBITSAlarmClear, tmnxFPAccIngQGrpPolicerPol=tmnxFPAccIngQGrpPolicerPol, tmnxCardV7v0Group=tmnxCardV7v0Group, TmnxMDAChanType=TmnxMDAChanType, tmnxChassisObsoleteGroup=tmnxChassisObsoleteGroup, tmnxEqSyncIfTimingRef1AlarmClear=tmnxEqSyncIfTimingRef1AlarmClear, tmnxHwClearAlarms=tmnxHwClearAlarms, tSyncIfTimingAdmTable=tSyncIfTimingAdmTable, tmnxSyncIfTimingPTPCfgQltyLevel=tmnxSyncIfTimingPTPCfgQltyLevel, tmnxFPNetIngQgPStFwdInProfOcts=tmnxFPNetIngQgPStFwdInProfOcts, TmnxHwClass=TmnxHwClass, tmnxCardEquippedType=tmnxCardEquippedType, tmnxFPAccIngQGrpName=tmnxFPAccIngQGrpName, tmnxChassisTypeIndex=tmnxChassisTypeIndex, tmnxMdaNotifyType=tmnxMdaNotifyType, TmnxMdaAtmMode=TmnxMdaAtmMode, tmnxMDAIngHsmdaPoolPolicy=tmnxMDAIngHsmdaPoolPolicy, tmnxMDAXplErrorTime=tmnxMDAXplErrorTime, tSyncIfTimingAdmRef2BITSIfType=tSyncIfTimingAdmRef2BITSIfType, tmnxCpmCardIndexFileLastBootedHeader=tmnxCpmCardIndexFileLastBootedHeader, tmnxChassisAdminOwner=tmnxChassisAdminOwner, tmnxSyncIfTimingRefOrder3=tmnxSyncIfTimingRefOrder3, TmnxBITSOutSource=TmnxBITSOutSource, tSyncIfTimingAdmBITSCfgQltyLevel=tSyncIfTimingAdmBITSCfgQltyLevel, tmnxChassisPowerSupply1Status=tmnxChassisPowerSupply1Status, tmnxCpmCardMasterSlaveRefState=tmnxCpmCardMasterSlaveRefState, tmnxIPsecIsaGrpTnlHighWMark=tmnxIPsecIsaGrpTnlHighWMark, tmnxFPNetIngQgPStFwdOutProfOctsH=tmnxFPNetIngQgPStFwdOutProfOctsH, TmnxChassisIndexOrZero=TmnxChassisIndexOrZero, tmnxMDAMinChannelization=tmnxMDAMinChannelization, tmnxChassisMixedModeIomAdminMode=tmnxChassisMixedModeIomAdminMode, tmnxFPNetIngQGrpTable=tmnxFPNetIngQGrpTable, TmnxCardRebootType=TmnxCardRebootType, tFPNetIngQGrpArbitStatFwdPktsL=tFPNetIngQGrpArbitStatFwdPktsL, tmnxHwBaseMacAddress=tmnxHwBaseMacAddress, tmnxChassisPowerSupply2Status=tmnxChassisPowerSupply2Status, tmnxCpmFlashCapacity=tmnxCpmFlashCapacity, tmnxEqSyncIfTimingPTPAlarm=tmnxEqSyncIfTimingPTPAlarm, tmnxChassisAdminLastSetTimeout=tmnxChassisAdminLastSetTimeout, tmnxCardComplexNumber=tmnxCardComplexNumber, tmnxHwParentRelPos=tmnxHwParentRelPos, tmnxHsmdaMdaSchOvrClass2WtInGrp=tmnxHsmdaMdaSchOvrClass2WtInGrp, tmnxEqMemoryFailure=tmnxEqMemoryFailure, tFPAccIngQGrpArbitStatFwdPktsL=tFPAccIngQGrpArbitStatFwdPktsL, tmnxEqMdaSyncENotCompatible=tmnxEqMdaSyncENotCompatible, tmnxCardCmplx2MemParityOccur=tmnxCardCmplx2MemParityOccur, tmnxChassisUpdateTimeLeft=tmnxChassisUpdateTimeLeft, tmnxHwResourceMinVoltage=tmnxHwResourceMinVoltage, tmnxChassisMIBModule=tmnxChassisMIBModule, tmnxSyncIfTimingPTPAdminStatus=tmnxSyncIfTimingPTPAdminStatus, tmnxCcagPathCcEntry=tmnxCcagPathCcEntry, tmnxSyncIfTimingPTPRxQltyLevel=tmnxSyncIfTimingPTPRxQltyLevel, tmnxFPAccIngQgPStOffLPrioPktsH=tmnxFPAccIngQgPStOffLPrioPktsH, tmnxChassisHwV9v0Group=tmnxChassisHwV9v0Group, tmnxFPAccIngQgPStUncolOctsOffH=tmnxFPAccIngQgPStUncolOctsOffH, tmnxFPNetIngQgPStOffLPrioOctsH=tmnxFPNetIngQgPStOffLPrioOctsH, tmnxSyncIfTimingFreqOffset=tmnxSyncIfTimingFreqOffset, tmnxHsmdaMdaSchOvrRowStatus=tmnxHsmdaMdaSchOvrRowStatus, tSyncIfTimingAdmRef2NationalUse=tSyncIfTimingAdmRef2NationalUse, tSyncIfTimingAdmRef1SrcHw=tSyncIfTimingAdmRef1SrcHw, tmnxSyncIfTimingRef2Alarm=tmnxSyncIfTimingRef2Alarm, tmnxSyncIfTimingRef1RxQltyLevel=tmnxSyncIfTimingRef1RxQltyLevel, tmnxMcmEquippedType=tmnxMcmEquippedType, tmnxChassisComp7710V8v0=tmnxChassisComp7710V8v0, tmnxSyncIfTimingBITS2RxQltyLevel=tmnxSyncIfTimingBITS2RxQltyLevel, tmnxHwResourceTable=tmnxHwResourceTable)

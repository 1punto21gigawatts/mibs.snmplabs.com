#
# PySNMP MIB module ASYNC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ASYNC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:29:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
scanet, = mibBuilder.importSymbols("SCANET-MIB", "scanet")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, ModuleIdentity, Counter32, NotificationType, ObjectIdentity, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Unsigned32, Integer32, IpAddress, MibIdentifier, iso, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ModuleIdentity", "Counter32", "NotificationType", "ObjectIdentity", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Unsigned32", "Integer32", "IpAddress", "MibIdentifier", "iso", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
pysmi_async = MibIdentifier((1, 3, 6, 1, 4, 1, 208, 45)).setLabel("async")
asyncConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 208, 45, 1))
asyncMon = MibIdentifier((1, 3, 6, 1, 4, 1, 208, 45, 2))
asyncPcmcia = MibIdentifier((1, 3, 6, 1, 4, 1, 208, 45, 3))
asyncConfigTable = MibTable((1, 3, 6, 1, 4, 1, 208, 45, 1, 1), )
if mibBuilder.loadTexts: asyncConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigTable.setDescription('A list of configuration entries. Each entry contains the configuration of a PCMCIA interface when this is used with an asynchronous modem.')
asyncConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 208, 45, 1, 1, 1), ).setIndexNames((0, "ASYNC-MIB", "asyncConfigIndex"))
if mibBuilder.loadTexts: asyncConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigEntry.setDescription('Every configuration option available for the PC-Card modem driver.')
asyncConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigIndex.setDescription('The ifIndex for the modem interface.')
asyncConfigDialMode = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tone", 1), ("pulse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asyncConfigDialMode.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigDialMode.setDescription('The dialing mode. Note that the pulse mode may not be compatible with all countries unless advanced country information is setup with the init strings.')
asyncConfigAutoInit = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asyncConfigAutoInit.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigAutoInit.setDescription('When auto-init is enabled the modem brand is detected and a predefined init string suited to the modem is used. When auto-init is disabled the user editable init string is used.')
asyncConfigDialString = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asyncConfigDialString.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigDialString.setDescription('The phone number to dial, with special characters to control the dialing, like pauses and waits for new dial tones. The special characters may vary amongst the modem brands.')
asyncConfigInitString1 = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asyncConfigInitString1.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigInitString1.setDescription('The first half of the user-editable init string. The two init strings are combined before use.')
asyncConfigInitString2 = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asyncConfigInitString2.setStatus('mandatory')
if mibBuilder.loadTexts: asyncConfigInitString2.setDescription('The second half of the user-editable init string.')
asyncMonTable = MibTable((1, 3, 6, 1, 4, 1, 208, 45, 2, 1), )
if mibBuilder.loadTexts: asyncMonTable.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonTable.setDescription('A list of monitor entries. Each entry contains the monitorable data of a PCMCIA interface when this is used with an asynchronous modem.')
asyncMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1), ).setIndexNames((0, "ASYNC-MIB", "asyncMonIndex"))
if mibBuilder.loadTexts: asyncMonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonEntry.setDescription('Every value that can be monitored for the PCMCIA interface.')
asyncMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonIndex.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonIndex.setDescription('The ifIndex for the modem interface.')
asyncMonMode = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("noConfiguration", 1), ("noValidModem", 2), ("initializingModem", 3), ("resettingModem", 4), ("waitingForResetAck", 5), ("hangingUp", 6), ("waitingForHangupAck", 7), ("standBy", 8), ("acceptingCall", 9), ("connected", 10), ("reserved", 11), ("dialing", 12), ("waitingForAnswer", 13), ("other", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonMode.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonMode.setDescription('The current internal state of the modem driver.')
asyncMonTransmitFailedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonTransmitFailedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonTransmitFailedErrors.setDescription('The number of aborted packet transmits due to a disconnect while packets were queued for transmission.')
asyncMonTransmitCongestions = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonTransmitCongestions.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonTransmitCongestions.setDescription('The number of packet transmissions that failed due to lack of resources.')
asyncMonReceiveLostEndMarkers = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveLostEndMarkers.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveLostEndMarkers.setDescription('The number of packets discarded because the packet end signature was missing.')
asyncMonReceiveOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveOverflows.setDescription('The number of packets discarded due to lack of free receive buffers.')
asyncMonReceiveStuffingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveStuffingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveStuffingErrors.setDescription("In data transmissions via an asynchrounous modem, certain characters are reserved for use with the modem, e.g. to indicate the start and end of data packets. If these reserved characters occur in the data stream, an 'Escape character' followed by a 'Substitute character' are used to represent it. This is known as stuffing. This parameter shows the number of packets discarded due to illegal combinations of the Escape character with Substitute characters.")
asyncMonReceiveCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveCRCErrors.setDescription('The number of packets discarded due to errors in the packet detected using the packet checksum.')
asyncMonReceiveShortPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveShortPackets.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveShortPackets.setDescription('The number of packets discarded because the packets were shorter than the minimum legal packet length.')
asyncMonReceiveLongPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveLongPackets.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveLongPackets.setDescription('The number of packets discarded because the packets were larger than the maximum legal packet length.')
asyncMonReceiveUartOverrunErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveUartOverrunErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveUartOverrunErrors.setDescription('The number of packets discarded because the incoming data exceeded the receive buffer size in the UART.')
asyncMonReceiveUartParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveUartParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveUartParityErrors.setDescription('The number of packets discarded because of errors in the packet detected using the parity bit.')
asyncMonReceiveUartFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveUartFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveUartFramingErrors.setDescription('The number of packets discarded because of errors during receiving the bit stream.')
asyncMonReceiveUartBreakErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonReceiveUartBreakErrors.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonReceiveUartBreakErrors.setDescription('The number of packets discarded because of a temporary loss of the received data flow.')
asyncMonCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncMonCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: asyncMonCallDirection.setDescription('Direction of the current call.')
asyncPcmciaTable = MibTable((1, 3, 6, 1, 4, 1, 208, 45, 3, 1), )
if mibBuilder.loadTexts: asyncPcmciaTable.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPcmciaTable.setDescription('A list of PC-Card (PCMCIA) information entries. Each entry contains the information available from the modems PCMCIA-interface.')
asyncPcmciaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 208, 45, 3, 1, 1), ).setIndexNames((0, "ASYNC-MIB", "asyncPcmciaIndex"))
if mibBuilder.loadTexts: asyncPcmciaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPcmciaEntry.setDescription('')
asyncPcmciaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPcmciaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPcmciaIndex.setDescription('The ifIndex for the modem interface.')
asyncPcmciaManufacturerName = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(100, 100)).setFixedLength(100)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPcmciaManufacturerName.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPcmciaManufacturerName.setDescription('The company name of the modem manufacturer.')
asyncPcmciaProductName = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(100, 100)).setFixedLength(100)).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPcmciaProductName.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPcmciaProductName.setDescription('The brand name of the modem.')
asyncPcmciaProductVersionMajor = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPcmciaProductVersionMajor.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPcmciaProductVersionMajor.setDescription('The modem hardware major version number.')
asyncPcmciaProductVersionMinor = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPcmciaProductVersionMinor.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPcmciaProductVersionMinor.setDescription('The modem hardware minor version number.')
asyncPcmciaPcmciaSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 208, 45, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asyncPcmciaPcmciaSupported.setStatus('mandatory')
if mibBuilder.loadTexts: asyncPcmciaPcmciaSupported.setDescription('This value is yes when the modem can be used with the router.')
mibBuilder.exportSymbols("ASYNC-MIB", asyncMonTransmitFailedErrors=asyncMonTransmitFailedErrors, asyncMonReceiveStuffingErrors=asyncMonReceiveStuffingErrors, asyncPcmciaProductVersionMajor=asyncPcmciaProductVersionMajor, asyncMonReceiveUartFramingErrors=asyncMonReceiveUartFramingErrors, asyncMonReceiveUartParityErrors=asyncMonReceiveUartParityErrors, asyncPcmciaIndex=asyncPcmciaIndex, asyncPcmciaPcmciaSupported=asyncPcmciaPcmciaSupported, asyncPcmciaEntry=asyncPcmciaEntry, asyncMon=asyncMon, pysmi_async=pysmi_async, asyncConfig=asyncConfig, asyncMonEntry=asyncMonEntry, asyncMonReceiveOverflows=asyncMonReceiveOverflows, asyncMonReceiveUartBreakErrors=asyncMonReceiveUartBreakErrors, asyncMonReceiveCRCErrors=asyncMonReceiveCRCErrors, asyncPcmcia=asyncPcmcia, asyncConfigInitString2=asyncConfigInitString2, asyncPcmciaProductName=asyncPcmciaProductName, asyncConfigDialString=asyncConfigDialString, asyncMonReceiveLostEndMarkers=asyncMonReceiveLostEndMarkers, asyncConfigDialMode=asyncConfigDialMode, asyncPcmciaManufacturerName=asyncPcmciaManufacturerName, asyncMonTransmitCongestions=asyncMonTransmitCongestions, asyncMonReceiveUartOverrunErrors=asyncMonReceiveUartOverrunErrors, asyncConfigIndex=asyncConfigIndex, asyncMonReceiveShortPackets=asyncMonReceiveShortPackets, asyncMonTable=asyncMonTable, asyncConfigInitString1=asyncConfigInitString1, asyncPcmciaTable=asyncPcmciaTable, asyncConfigAutoInit=asyncConfigAutoInit, asyncMonReceiveLongPackets=asyncMonReceiveLongPackets, asyncConfigTable=asyncConfigTable, asyncConfigEntry=asyncConfigEntry, asyncMonMode=asyncMonMode, asyncMonIndex=asyncMonIndex, asyncMonCallDirection=asyncMonCallDirection, asyncPcmciaProductVersionMinor=asyncPcmciaProductVersionMinor)

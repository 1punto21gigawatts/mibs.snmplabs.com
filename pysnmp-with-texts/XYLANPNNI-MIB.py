#
# PySNMP MIB module XYLANPNNI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XYLANPNNI-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:45:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, ObjectIdentity, Gauge32, Integer32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, MibIdentifier, Unsigned32, NotificationType, Counter64, TimeTicks, Bits, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "ObjectIdentity", "Gauge32", "Integer32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "MibIdentifier", "Unsigned32", "NotificationType", "Counter64", "TimeTicks", "Bits", "Counter32")
TextualConvention, TimeStamp, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TimeStamp", "TruthValue", "DisplayString")
xylanPnni, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanPnni")
xylanPnniMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2))
if mibBuilder.loadTexts: xylanPnniMIB.setLastUpdated('9810190000Z')
if mibBuilder.loadTexts: xylanPnniMIB.setOrganization('Xylan')
if mibBuilder.loadTexts: xylanPnniMIB.setContactInfo('Alcatel Internetworking, Inc. 26801 W. Agoura Road Calabasas, CA 91301 USA Phone: +1 818-878-3500')
if mibBuilder.loadTexts: xylanPnniMIB.setDescription("This MIB specifies additional Xylan functionality to the ATM Forum's PNNI MIB.")
xylanPnniMIBExtens = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1))
xylanPnniMIBObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1))
class XPnniNodeId(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(22, 22)
    fixedLength = 22

class XPnniNodeLevel(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 104)

class XPnniAtmAddr(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class XPnniPortId(Unsigned32):
    pass

class XPnniFiltCallType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("both-ptop-pmp", 0), ("ptop", 1), ("pmp", 2))

class XPnniFiltServiceCategory(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("none-specified", 0), ("cbr", 1), ("rtVbr", 2), ("abr", 3))

class XPnniFiltMetricConstraint(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("none-specified", 0), ("pcr", 1), ("min-cr", 2), ("scr", 3), ("max-burst", 4))

class XPnniFiltExceptionCriteria(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("none-specified", 0), ("all-addrs-pass-except", 1), ("no-addrs-pass-except", 2))

class XPnniFilterPrefixLength(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 152)

class XPnniAddrPrefix(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(19, 19)
    fixedLength = 19

xPnniAssociativeNameTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 1), )
if mibBuilder.loadTexts: xPnniAssociativeNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAssociativeNameTable.setDescription('The xPnniAssociativeNameTable contains attributes that bind node names to PNNI Node IDs. There is a single row in this table for each PNNI node in the network. Default names are node1, node2, ... until the administrator specifically configures a different name.')
xPnniNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 1, 1), ).setIndexNames((0, "XYLANPNNI-MIB", "xPnniNodeIndex"))
if mibBuilder.loadTexts: xPnniNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniNameEntry.setDescription('An entry in the table, containing information about a PNNI node in this network.')
xPnniNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniNodeIndex.setDescription('The index into the associative name table. This index also corresponds to entries in the nodal map table.')
xPnniNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 1, 1, 2), XPnniNodeId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniNodeId.setDescription('The value of the 22-byte node ID which a switching system uses to represent itself in the peer-group.')
xPnniNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniNodeName.setDescription('The ASCII text string which represents this node. The default node name has the value NODE_n where n is 1..65535.')
xPnniAddressFilterTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2), )
if mibBuilder.loadTexts: xPnniAddressFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAddressFilterTable.setDescription('The xPnniAddressFilterTable contains attributes that allow an administrator to configure address filters for security. Address filters are specified by the following: the LGN to which the filter applies; their direction (in, out or both); their addresses (src, dest or both specified as an nsap prefix from 2 to 152 bits); their call type (PTOP, PMP, or both); their service class (CBR, ABR or RtVBR); their metric constraints (CBR - metric is PCR threshold, ABR - the metric is Min CR, and RtVBR - the metric threshold is either PCR, SCR, or Max Burst); their metric threshold; their trap threshold; any exceptions (all/no addresses pass except...) and the corresponding exception prefix (from 2-152 bits); and start/stop Time Of Day values: There is a single row in this table for each PNNI filter in this switching system.')
xPnniAddressFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1), ).setIndexNames((0, "XYLANPNNI-MIB", "xPnniFiltIndex"))
if mibBuilder.loadTexts: xPnniAddressFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAddressFilterEntry.setDescription('An entry in the table, containing information about a filter in this switching system.')
xPnniFiltIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltIndex.setDescription('The index into the PNNI Filter Table.')
xPnniFiltNodeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 2), XPnniNodeLevel().clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltNodeLevel.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltNodeLevel.setDescription('The level of the node within this switching system. Note that filters may be defined for any level. If a node at a specific level is disabled, then corresponding filters become inactive until the node is re-enabled.')
xPnniFiltSrcPrefLen = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 3), XPnniFilterPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltSrcPrefLen.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltSrcPrefLen.setDescription('The length (in bits) of the source prefix.')
xPnniFiltSrcPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 4), XPnniAddrPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltSrcPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltSrcPrefix.setDescription('The source prefix to be filtered.')
xPnniFiltDestPrefLen = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 5), XPnniFilterPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltDestPrefLen.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltDestPrefLen.setDescription('The length (in bits) of the destination prefix.')
xPnniFiltDestPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 6), XPnniAddrPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltDestPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltDestPrefix.setDescription('The destination prefix to be filtered.')
xPnniFiltCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 7), XPnniFiltCallType().clone('both-ptop-pmp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltCallType.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltCallType.setDescription('The call type indicates if the filter is to be applied to point to point calls, point to multi-point calls (add parties), or to both.')
xPnniFiltCallSrvCls = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 8), XPnniFiltServiceCategory().clone('none-specified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltCallSrvCls.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltCallSrvCls.setDescription('The service class (if any) which this filter is active for. If the service class is CBR, then the xPnniFiltCallMtrcConstrnt field below must be set to PCR. If the service class is ABR, then the xPnniFiltCallMtrcConstrnt field below must be set to Min-CR. If the service class is RtVbr, then the xPnniFiltCallMtrcConstrnt field below must be set to either PCR, SCR or Max-burst. Any of the three previous values for xPnniFiltCallSrvCls (CBR, ABR and RtVbr) should result in a non-zero xPnniFiltCallMtrcThresh below. Finally, if the service class is set to none-specified, then the fields xPnniFiltCallMtrcConstrnt and xPnniFiltCallMtrcThresh are ignored.')
xPnniFiltCallMtrcConstrnt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 9), XPnniFiltMetricConstraint().clone('none-specified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltCallMtrcConstrnt.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltCallMtrcConstrnt.setDescription('A metric constraint that is used with xPnniFiltCallSrvCls.')
xPnniFiltCallMtrcThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltCallMtrcThresh.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltCallMtrcThresh.setDescription('A metric threshold value that is used with xPnniFiltCallSrvCls. The value 0 is only valid if the xPnniFiltCallSrvCls is none-specified.')
xPnniFiltTrapThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltTrapThresh.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltTrapThresh.setDescription('A threshold which when this number of filter hits are encountered, will cause a trap to be sent to all trap-clients. The value of 0 causes traps to be inhibited.')
xPnniFiltSrcExceptionCriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 12), XPnniFiltExceptionCriteria().clone('none-specified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltSrcExceptionCriteria.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltSrcExceptionCriteria.setDescription('The criteria used to cause exceptions to the source address filters. If the value is none-specified, then the fields: xPnniFiltSrcExceptionLen and xPnniFiltSrcException are ignored. If this value is all-addrs-pass-except or no-addrs-pass-except, then the xPnniFiltSrcExceptionLen and xPnniFiltSrcException attributes contain the source prefix len and prefix which are to be exception handled. This value cannot be set to all-addrs-pass-except or no-addrs-pass-except if the xPnniFiltSrcPrefLen (above) is set to 0.')
xPnniFiltSrcExceptionLen = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 13), XPnniFilterPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltSrcExceptionLen.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltSrcExceptionLen.setDescription('The length (in bits) of the exception address prefix attribute: xPnniFiltSrcException.')
xPnniFiltSrcException = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 14), XPnniAddrPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltSrcException.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltSrcException.setDescription('The ATM Address Prefix of the source address exception.')
xPnniFiltDestExceptionCriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 15), XPnniFiltExceptionCriteria().clone('none-specified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltDestExceptionCriteria.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltDestExceptionCriteria.setDescription('The criteria used to cause exceptions to the destination address filters. If the value is none-specified, then the fields: xPnniFiltDestExceptionLen and xPnniFiltDestException are ignored. If this value is all-addrs-pass-except or no-addrs-pass-except, then the xPnniFiltDestExceptionLen and xPnniFiltDestException attributes contain the destination prefix len and prefix which are to be exception handled. This value cannot be set to all-addrs-pass-except or no-addrs-pass-except if the xPnniFiltDestPrefLen (above) is set to 0.')
xPnniFiltDestExceptionLen = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 16), XPnniFilterPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltDestExceptionLen.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltDestExceptionLen.setDescription('The length (in bits) of the exception address prefix attribute: xPnniFiltDestException.')
xPnniFiltDestException = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 17), XPnniAddrPrefix()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltDestException.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltDestException.setDescription('The ATM Address Prefix of the destination address exception.')
xPnniFiltDeniedHitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 18), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltDeniedHitCount.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltDeniedHitCount.setDescription('A counter specifying how many times this filter was activated. Writing a 0 value to this field will cause this counter to be reset for this filter.')
xPnniFiltExceptionHitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 19), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltExceptionHitCount.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltExceptionHitCount.setDescription('A counter specifying how many times this filter was activated but an exception was permitted. Writing a 0 value to this field will cause this counter to be reset for this filter.')
xPnniFiltTODStartHr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltTODStartHr.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltTODStartHr.setDescription('The hour of the day (using a 24 hour clock) when the filter is to be activated.')
xPnniFiltTODStartMin = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltTODStartMin.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltTODStartMin.setDescription('The minute of the hour when the filter is to be activated.')
xPnniFiltTODStartSec = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltTODStartSec.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltTODStartSec.setDescription('The second of the minute when the filter is to be activated.')
xPnniFiltTODStopHr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltTODStopHr.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltTODStopHr.setDescription('The hour of the day (using a 24 hour clock) when the filter is to be de-activated.')
xPnniFiltTODStopMin = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltTODStopMin.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltTODStopMin.setDescription('The minute of the hour when the filter is to be de-activated.')
xPnniFiltTODStopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 2, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniFiltTODStopSec.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniFiltTODStopSec.setDescription('The second of the minute when the filter is to be de-activated.')
xPnniIAdjMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3))
xPnniIAdjGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1))
xPnniNumIAdj = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniNumIAdj.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniNumIAdj.setDescription('The number of adjacencies registered via ILMI in PNNIs lowest nodes adjacency table in this switching system.')
xPnniIAdjTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2), )
if mibBuilder.loadTexts: xPnniIAdjTable.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjTable.setDescription('The xPnniIAdjTable stores records of adjacencies which ILMI has registered with the lowest level PNNI node in this network. There is a single row in this table for each adjacency which ILMI has registered.')
xPnniIAdjEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1), ).setIndexNames((0, "XYLANPNNI-MIB", "xPnniIAdjIndex"))
if mibBuilder.loadTexts: xPnniIAdjEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjEntry.setDescription('An entry in the table, containing information about a PNNI logical node in this switching system.')
xPnniIAdjIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: xPnniIAdjIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjIndex.setDescription('A value assigned to an ILMI client registered via ILMI in this switching system that uniquely identifies it in the PNNI ILMI adjacency table.')
xPnniIAdjAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 2), XPnniAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniIAdjAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjAtmAddress.setDescription("This adjacency's ATM End System Address.")
xPnniIAdjSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniIAdjSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjSlot.setDescription('The slot in which this adjacency is physically connected to this switching system.')
xPnniIAdjPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniIAdjPort.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjPort.setDescription('The port in the slot which this adjacency is physically connected to this switching system.')
xPnniIAdjInst = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniIAdjInst.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjInst.setDescription('The instance identifier on the slot port pair which this adjacency is physically connected to this switching system. In the event that this is not a tunnel, this value will be zero.')
xPnniIAdjCsmPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniIAdjCsmPPort.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjCsmPPort.setDescription('The unique port id which PNNI has bound to this physical slot, port, and instance tuple.')
xPnniIAdjAdvertised = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniIAdjAdvertised.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjAdvertised.setDescription('Indicates if this ILMI client is advertised by this switching system. Note that if this value is False, the summary address may be used by remote nodes to still reach this ILMI client if xPnniIAdjSummarized is set to True (below).')
xPnniIAdjSummarized = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniIAdjSummarized.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjSummarized.setDescription("Indicates if this ILMI client is summarized by this switching system. Note that if this value is True, other nodes in the peer group will route to this node's advertised port of 1. Calls terminating at end-systems attached to this node will then be vectored out the xPnniIAdjCsmPPort.")
xPnniIAdjLearned = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 3, 1, 2, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniIAdjLearned.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniIAdjLearned.setDescription('This field contains a timestamp of when ILMI registered this adjacency with PNNI.')
xPnniTestMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4))
xPnniRtstMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1))
xPnniRtstTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1), )
if mibBuilder.loadTexts: xPnniRtstTable.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstTable.setDescription('The xPnniRtstTable is a single-row table which returns the results of a route test requested by a remote mgmt station. The route test parameters are specified in the INDEX.')
xPnniRtstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1), ).setIndexNames((0, "XYLANPNNI-MIB", "xPnniNodeIndex"), (0, "XYLANPNNI-MIB", "xPnniRtstClass"), (0, "XYLANPNNI-MIB", "xPnniRtstType"), (0, "XYLANPNNI-MIB", "xPnniRtstDest"))
if mibBuilder.loadTexts: xPnniRtstEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstEntry.setDescription('An entry in the route test table, containing information about a route lookup request.')
xPnniRtstClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ubr", 1), ("cbr", 2), ("vbrRt", 3), ("vbrNrt", 4), ("abr", 5))))
if mibBuilder.loadTexts: xPnniRtstClass.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstClass.setDescription('The class the route request is to use.')
xPnniRtstType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ptpt", 1), ("pmp", 2))))
if mibBuilder.loadTexts: xPnniRtstType.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstType.setDescription('This index specifies the type of call which may be either point to point or point to multi-point.')
xPnniRtstDest = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20))
if mibBuilder.loadTexts: xPnniRtstDest.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstDest.setDescription('The destination address. This may be specified by the user as an address prefix, but the SNMP manager must pad this out to 20 octets.')
xPnniRtstError = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("success", 0), ("noRouteToDest", 1), ("dtlExhaustion", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstError.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstError.setDescription('Indicates if an error has occurred and if so, the nature of the error. If this is set to success, then no error occurred and the rest of the row contains useful information.')
xPnniRtstFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dtlAdded", 1), ("direct", 2), ("myself", 3), ("directEreach", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstFlags.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstFlags.setDescription("If error is set to success, this flag indicates the nature of the route lookup confirmation. If this flag is set to dtlAdded, then the route request resulted in a DTL being allocated for this request. In this case, the xPnniRtstOutboundPort, xPnniRtstHopCount, xPnniRtstDTL, and xPnniRtstCurPointer contain useful information. (Also, after this information is conveyed back to the manager, the DTL entry is freed.) If this flag is set to direct, then the route request is informing the caller to proceed out a directly attached port. In this case, the xPnniRtstOutboundPort is valid and is either 1 (to indicate a match on this node's summary address) or is a reference to the PNNI advertised outbound port. If this flag is set to myself, then the route request is informing the caller that the test call to the node in this switching system (identified by xPnniNodeIndex) returned a successful match of myself as the destination. In this case, the xPnniRtstOutboundPort is valid and is set to 0 (which indicates a match on this node's own address). If this flag is set to directEreach, then the route request is informing the caller that the test call to the destination resulted in a direct indication. In this case, the xPnniRtstOutboundPort is valid and is set to the static route's PNNI advertised port ID. If the user also specified a VPI and E.164 address, then the xPnniRtstVPI and xPnniRtstE164 fields will also be present.")
xPnniRtstOutboundPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 6), XPnniPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstOutboundPort.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstOutboundPort.setDescription("If error is set to success, this indicates the outbound port of the route lookup confirmation. If this is set to 0, then this indicates the call was placed to this switching system's xPnniNodeIndex. If this is set to 1, then this indicates the call was placed to a reachability which matched this node's summary address. In this event, the IAdj table would be consulted to determine the actual port (if any) where the destination resided. If set to any other value, it indicates the PNNI advertised port of the static route which caused this port to be returned.")
xPnniRtstVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstVPI.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstVPI.setDescription('If error is set to success, and xPnniRtstFlags is set to directEreach, then this indicates the vpi (if set by the user) used to route the call.')
xPnniRtstE164 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstE164.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstE164.setDescription('If error is set to success, and xPnniRtstFlags is set to directEreach, then this indicates the E.164 address (if set by the user) used to route the call.')
xPnniRtstE164len = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstE164len.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstE164len.setDescription('If error is set to success, and xPnniRtstFlags is set to directEreach, then this indicates the number of significant octets used in the above E.164 address.')
xPnniRtstHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstHopCount.setDescription('If error is set to success, and xPnniRtstFlags is set to dtlAdded, then this indicates the number of hops in the xPnniRtstDTL.')
xPnniRtstDTL = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(52, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstDTL.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstDTL.setDescription("If error is set to success, and xPnniRtstFlags is set to dtlAdded, then this indicates the DTL generated by the route lookup function in the switching system. Note that this is a complete DTL meaning that the DTL IE header is also present. It has enough room for 50 entries (50 hops). Each entry has a 22-octet node-ID followed by a 4-octet PnniPortId. Entries therefore are 26 octets each and each entry is contiguous with its predecessor and successor. This DTL will not appear in the DTL table since it's freed after generating the reply to the management station.")
xPnniRtstCurPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniRtstCurPointer.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniRtstCurPointer.setDescription('If error is set to success, and xPnniRtstFlags is set to dtlAdded, then this indicates the offset (in bytes) into xPnniRtstDTL of the curPtr.')
xPnniTrcMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2))
xPnniTrcBufSiz = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniTrcBufSiz.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcBufSiz.setDescription('A value indicating the size of the trace capture buffer.')
xPnniTrcBufTrigger = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loop", 1), ("haltOnFull", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniTrcBufTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcBufTrigger.setDescription('A value indicating action on buffer capacity reached.')
xPnniTrcBufControl = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("start", 1), ("freeze", 2), ("stopAndFreeBuf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniTrcBufControl.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcBufControl.setDescription('A value indicating a control action on trace.')
xPnniTrcNodeIndex = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniTrcNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcNodeIndex.setDescription('This variable indicates the node index within this switching system to be traced.')
xPnniTrcTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5), )
if mibBuilder.loadTexts: xPnniTrcTable.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcTable.setDescription('The xPnniITrcTable stores records of captured frames from both the AAL-SAP as well as signalled RCCs. There is a single row in this table for each adjacency which ILMI has registered.')
xPnniTrcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1), ).setIndexNames((0, "XYLANPNNI-MIB", "xPnniTrcFrameIndex"), (0, "XYLANPNNI-MIB", "xPnniTrcFrameFrag"))
if mibBuilder.loadTexts: xPnniTrcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcEntry.setDescription('An entry in the analyzer table, containing information about a PNNI received by a node in this switching system.')
xPnniTrcFrameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcFrameIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcFrameIndex.setDescription('An index selecting a particular frame.')
xPnniTrcFrameFrag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcFrameFrag.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcFrameFrag.setDescription('A fragment within a captured frame.')
xPnniTrcDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcDirection.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcDirection.setDescription('Indicates whether the frame was transmitted or received.')
xPnniTrcSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcSlot.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcSlot.setDescription('Indicates the physical slot where the frame was transmitted or received.')
xPnniTrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcPort.setDescription('Indicates the physical port where the frame was transmitted or received.')
xPnniTrcCsmPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcCsmPPort.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcCsmPPort.setDescription('Indicates the advertised PNNI port ID where the frame was transmitted or received. This is used primarily for signaled RCCs.')
xPnniTrcFrType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("hello", 1), ("ptsp", 2), ("ptseAck", 3), ("dbSumm", 4), ("ptseReq", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcFrType.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcFrType.setDescription('Indicates the type of frame as specified in the ATM-Forum PNNI V1.0 Specification, Section 5.14.4, Table 5-21.')
xPnniTrcFrLen = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcFrLen.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcFrLen.setDescription('Indicates the overall frame length.')
xPnniTrcLearned = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcLearned.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcLearned.setDescription('Indicates the timestamp of when the frame was either transmitted or received.')
xPnniTrcFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 4, 2, 5, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1000, 1000)).setFixedLength(1000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrcFrame.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrcFrame.setDescription('Contains the raw frame contents.')
xPnniAliasTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 5), )
if mibBuilder.loadTexts: xPnniAliasTable.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAliasTable.setDescription('This table stores address (prefix) bindings for Display purposes.')
xPnniAliasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 5, 1), ).setIndexNames((0, "XYLANPNNI-MIB", "xPnniAliasIndex"))
if mibBuilder.loadTexts: xPnniAliasEntry.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAliasEntry.setDescription('An entry in the alias table containing information about a binding between PNNI address, nodeId or address prefix and a text string. When referring to a nodeId, this is called a domain name.')
xPnniAliasIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 5, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniAliasIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAliasIndex.setDescription('An index selecting a particular name-binding.')
xPnniAliasName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 5, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniAliasName.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAliasName.setDescription('The name to be bound to the prefix.')
xPnniAliasPrefLen = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniAliasPrefLen.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAliasPrefLen.setDescription('An length (in bits) of the prefix binding. A Prefix length of 176 bits (22 Octets) implies a node ID. A length of 160 bits implies an ATM Address.')
xPnniAliasPrefixBinding = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xPnniAliasPrefixBinding.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniAliasPrefixBinding.setDescription('The prefix binding.')
xPnniTrapMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6))
xPnniTrapPnPortId = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrapPnPortId.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrapPnPortId.setDescription('On a trap condition, this identifies the port-related variable.')
xPnniTrapRouteAddrAddress = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6, 2), XPnniAddrPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrapRouteAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrapRouteAddrAddress.setDescription('On a trap condition, this identifies the address prefix-related variable.')
xPnniTrapRouteAddrPrefixLength = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6, 3), XPnniFilterPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrapRouteAddrPrefixLength.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrapRouteAddrPrefixLength.setDescription('On a trap condition, this identifies the address prefix length related variable.')
xPnniTrapFiltIndex = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrapFiltIndex.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrapFiltIndex.setDescription('On a trap condition, this identifies the filter index variable.')
xPnniTrapNeighborId = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6, 5), XPnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrapNeighborId.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrapNeighborId.setDescription('On a Neighbor trap condition, this identifies the neighbor node Id-related variable.')
xPnniTrapNodeId = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6, 6), XPnniNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrapNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrapNodeId.setDescription('On a trap condition, this identifies the local node ID variable which specifies the level and LGN or lowest level node.')
xPnniTrapNodeDownReason = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("localUiAdmin", 1), ("remoteTelnet", 2), ("mgmt", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrapNodeDownReason.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrapNodeDownReason.setDescription("On a trap condition, this identifies the reason a node has gone down. A value of LocalUiAdmin specifies that a user on the MPM's Console or Modem Port has caused the action via a UI Shell:phalt command. A value of RemoteTelnet indicates that a user logged in remotely has caused the action via a UI Shell:phalt command. A value of Mgmt indicates that a remote SNMP management entity Has caused the action via a (re)configuration of the PNNI Node Table.")
xPnniTrapNodeDownRemoteIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 2, 1, 1, 6, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xPnniTrapNodeDownRemoteIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: xPnniTrapNodeDownRemoteIPAddr.setDescription('If the above variable: xPnniTrapNodeDownReason indicates a value of either RemoteTelnet or then this variable indicates the remote IP Address of the entity causing the action.')
mibBuilder.exportSymbols("XYLANPNNI-MIB", xPnniFiltTODStartHr=xPnniFiltTODStartHr, xPnniNameEntry=xPnniNameEntry, xPnniRtstType=xPnniRtstType, xPnniFiltTODStartMin=xPnniFiltTODStartMin, xPnniRtstDest=xPnniRtstDest, xPnniFiltTODStopSec=xPnniFiltTODStopSec, xPnniFiltTODStopMin=xPnniFiltTODStopMin, xPnniTrcLearned=xPnniTrcLearned, xPnniRtstEntry=xPnniRtstEntry, xPnniTrapNodeDownReason=xPnniTrapNodeDownReason, xPnniTrcSlot=xPnniTrcSlot, xPnniAliasIndex=xPnniAliasIndex, XPnniNodeId=XPnniNodeId, xPnniFiltDestPrefix=xPnniFiltDestPrefix, xPnniFiltCallMtrcThresh=xPnniFiltCallMtrcThresh, xPnniIAdjInst=xPnniIAdjInst, xPnniIAdjIndex=xPnniIAdjIndex, xPnniIAdjSlot=xPnniIAdjSlot, xPnniTrapRouteAddrAddress=xPnniTrapRouteAddrAddress, XPnniAtmAddr=XPnniAtmAddr, xPnniFiltSrcPrefLen=xPnniFiltSrcPrefLen, xPnniIAdjLearned=xPnniIAdjLearned, xPnniTrcNodeIndex=xPnniTrcNodeIndex, XPnniNodeLevel=XPnniNodeLevel, XPnniFiltServiceCategory=XPnniFiltServiceCategory, xPnniRtstDTL=xPnniRtstDTL, xPnniFiltTODStopHr=xPnniFiltTODStopHr, xPnniFiltCallSrvCls=xPnniFiltCallSrvCls, xPnniRtstE164len=xPnniRtstE164len, xPnniTrcTable=xPnniTrcTable, xPnniTrcCsmPPort=xPnniTrcCsmPPort, xPnniFiltDestExceptionCriteria=xPnniFiltDestExceptionCriteria, xPnniRtstHopCount=xPnniRtstHopCount, xPnniNodeId=xPnniNodeId, xPnniTrapPnPortId=xPnniTrapPnPortId, xPnniTrcFrLen=xPnniTrcFrLen, xPnniAliasEntry=xPnniAliasEntry, xPnniAliasName=xPnniAliasName, xPnniFiltTODStartSec=xPnniFiltTODStartSec, xPnniFiltSrcException=xPnniFiltSrcException, xPnniAddressFilterTable=xPnniAddressFilterTable, xPnniIAdjEntry=xPnniIAdjEntry, xPnniTrcFrType=xPnniTrcFrType, xPnniFiltNodeLevel=xPnniFiltNodeLevel, xPnniTrcBufTrigger=xPnniTrcBufTrigger, PYSNMP_MODULE_ID=xylanPnniMIB, xPnniRtstTable=xPnniRtstTable, xPnniTrcFrameFrag=xPnniTrcFrameFrag, xPnniIAdjSummarized=xPnniIAdjSummarized, xPnniIAdjCsmPPort=xPnniIAdjCsmPPort, xPnniFiltSrcExceptionCriteria=xPnniFiltSrcExceptionCriteria, XPnniFiltMetricConstraint=XPnniFiltMetricConstraint, xPnniIAdjPort=xPnniIAdjPort, xPnniFiltDeniedHitCount=xPnniFiltDeniedHitCount, XPnniPortId=XPnniPortId, xPnniTrapNodeId=xPnniTrapNodeId, xPnniNumIAdj=xPnniNumIAdj, xPnniFiltCallType=xPnniFiltCallType, xPnniFiltDestExceptionLen=xPnniFiltDestExceptionLen, xPnniRtstMIBGroup=xPnniRtstMIBGroup, xPnniAssociativeNameTable=xPnniAssociativeNameTable, xPnniNodeIndex=xPnniNodeIndex, xPnniTrapNodeDownRemoteIPAddr=xPnniTrapNodeDownRemoteIPAddr, xPnniFiltTrapThresh=xPnniFiltTrapThresh, XPnniFiltCallType=XPnniFiltCallType, xPnniFiltDestException=xPnniFiltDestException, xPnniTestMIBObjects=xPnniTestMIBObjects, xPnniTrapNeighborId=xPnniTrapNeighborId, xPnniAddressFilterEntry=xPnniAddressFilterEntry, xPnniTrcBufSiz=xPnniTrcBufSiz, xylanPnniMIB=xylanPnniMIB, XPnniAddrPrefix=XPnniAddrPrefix, xylanPnniMIBObjs=xylanPnniMIBObjs, xPnniTrcFrameIndex=xPnniTrcFrameIndex, xPnniAliasPrefixBinding=xPnniAliasPrefixBinding, xPnniRtstFlags=xPnniRtstFlags, xPnniFiltExceptionHitCount=xPnniFiltExceptionHitCount, xPnniTrapFiltIndex=xPnniTrapFiltIndex, xPnniFiltSrcExceptionLen=xPnniFiltSrcExceptionLen, xPnniIAdjAtmAddress=xPnniIAdjAtmAddress, xPnniIAdjGroup=xPnniIAdjGroup, xPnniRtstOutboundPort=xPnniRtstOutboundPort, xPnniRtstCurPointer=xPnniRtstCurPointer, xPnniIAdjTable=xPnniIAdjTable, xPnniIAdjMIBObjects=xPnniIAdjMIBObjects, xPnniTrcMIBGroup=xPnniTrcMIBGroup, xPnniRtstError=xPnniRtstError, xPnniFiltSrcPrefix=xPnniFiltSrcPrefix, xPnniRtstClass=xPnniRtstClass, XPnniFiltExceptionCriteria=XPnniFiltExceptionCriteria, xPnniAliasTable=xPnniAliasTable, xPnniTrapRouteAddrPrefixLength=xPnniTrapRouteAddrPrefixLength, xylanPnniMIBExtens=xylanPnniMIBExtens, xPnniFiltCallMtrcConstrnt=xPnniFiltCallMtrcConstrnt, xPnniTrcFrame=xPnniTrcFrame, xPnniTrcPort=xPnniTrcPort, xPnniAliasPrefLen=xPnniAliasPrefLen, xPnniFiltDestPrefLen=xPnniFiltDestPrefLen, xPnniRtstVPI=xPnniRtstVPI, xPnniTrcEntry=xPnniTrcEntry, xPnniTrapMIBObjects=xPnniTrapMIBObjects, xPnniTrcBufControl=xPnniTrcBufControl, xPnniNodeName=xPnniNodeName, xPnniFiltIndex=xPnniFiltIndex, xPnniRtstE164=xPnniRtstE164, xPnniIAdjAdvertised=xPnniIAdjAdvertised, xPnniTrcDirection=xPnniTrcDirection, XPnniFilterPrefixLength=XPnniFilterPrefixLength)

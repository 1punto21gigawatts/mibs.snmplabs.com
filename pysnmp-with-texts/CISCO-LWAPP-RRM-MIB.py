#
# PySNMP MIB module CISCO-LWAPP-RRM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-LWAPP-RRM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:06:22 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion")
cLApName, = mibBuilder.importSymbols("CISCO-LWAPP-AP-MIB", "cLApName")
cldcClientMacAddress, cldcApMacAddress, cldcIfType = mibBuilder.importSymbols("CISCO-LWAPP-DOT11-CLIENT-MIB", "cldcClientMacAddress", "cldcApMacAddress", "cldcIfType")
CLApIfType, = mibBuilder.importSymbols("CISCO-LWAPP-TC-MIB", "CLApIfType")
cLWlanChdEnable, = mibBuilder.importSymbols("CISCO-LWAPP-WLAN-MIB", "cLWlanChdEnable")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
TimeTicks, MibIdentifier, NotificationType, ObjectIdentity, Unsigned32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Counter32, IpAddress, Gauge32, Bits, ModuleIdentity, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibIdentifier", "NotificationType", "ObjectIdentity", "Unsigned32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Counter32", "IpAddress", "Gauge32", "Bits", "ModuleIdentity", "Counter64")
TimeStamp, DisplayString, MacAddress, TruthValue, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "MacAddress", "TruthValue", "TextualConvention", "RowStatus")
ciscoLwappRrmMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 615))
ciscoLwappRrmMIB.setRevisions(('2011-03-08 00:00', '2007-11-13 00:00', '2007-02-21 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoLwappRrmMIB.setRevisionsDescriptions(('Added following parameters to the table, clrRrmParametersTable. clrRrmParametersDcaChannelWidth, clrRrmParametersMaxTxPower, clrRrmParametersMinTxPower. Deprecated the following object: clrRrmParametersPicoCellMode, clrRrmTupleEntry. Added following scalar variables: clrRrmDcaDot11aOutdoorAPDca, clrRrmRfGroupingPriority. Following two tables have been added for RRM RF Grouping. clrRrmDot11BandGrpTable clrRrmDot11BandGrpMemberTable Following notification related objects have been added: clrRrmApTransmitPowerLevel clrRrmTimeStamp clrRrmClientType clrRrmRssiHistogramLength clrRrmRssiHistogramMaxIndex clrRrmRssiHistogramValues clrRrmNeighborApCount clrRrmNeighborApMacAddress clrRrmNeighborApRssi clrRrmNeighborApIfType clrRrmSysMacAddress clrRrmSysIpAddress Following notifications have been defined: ciscoLwappDot11ClientCoverageHolePreAlarm ciscoLwappRrmRfGroupLeaderChange ciscoLwappRrmRfGroupMemberAdded ciscoLwappRrmRfGroupMemberRemoved.', 'The following objects have been added: 1. clrRrmParametersChdEnable 2. clrRrmParametersVoicePktCountThreshold 3. clrRrmParametersVoicePktPercentThreshold 4. clrRrmParametersVoiceRssiThreshold 5. clrRrmParametersDataPktCountThreshold 6. clrRrmParametersDataPktPercentThreshold 7. clrRrmParametersDataRssiThreshold.', 'Initial version of this MIB module. ',))
if mibBuilder.loadTexts: ciscoLwappRrmMIB.setLastUpdated('201103290000Z')
if mibBuilder.loadTexts: ciscoLwappRrmMIB.setOrganization('Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoLwappRrmMIB.setContactInfo(' Cisco Systems, Customer Service Postal: 170 West Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS Email: cs-wnbu-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoLwappRrmMIB.setDescription("This MIB is intended to be implemented on all those devices operating as Central controllers, that terminate the Light Weight Access Point Protocol tunnel from Cisco Light-weight LWAPP Access Points. Information provided by this MIB is used to study the RRM on the WLAN. The relationship between CC and the LWAPP APs can be depicted as follows: +......+ +......+ +......+ + + + + + + + CC + + CC + + CC + + + + + + + +......+ +......+ +......+ .. . . .. . . . . . . . . . . . . . . . . . . +......+ +......+ +......+ +......+ + + + + + + + + + AP + + AP + + AP + + AP + + + + + + + + + +......+ +......+ +......+ +......+ . . . . . . . . . . . . . . . . . . . +......+ +......+ +......+ +......+ + + + + + + + + + MN + + MN + + MN + + MN + + + + + + + + + +......+ +......+ +......+ +......+ The LWAPP tunnel exists between the controller and the APs. The MNs communicate with the APs through the protocol defined by the 802.11 standard. LWAPP APs, upon bootup, discover and join one of the controllers and the controller pushes the configuration, that includes the WLAN parameters, to the LWAPP APs. The APs then encapsulate all the 802.11 frames from wireless clients inside LWAPP frames and forward the LWAPP frames to the controller. GLOSSARY Access Point ( AP ) An entity that contains an 802.11 medium access control ( MAC ) and physical layer ( PHY ) interface and provides access to the distribution services via the wireless medium for associated clients. LWAPP APs encapsulate all the 802.11 frames in LWAPP frames and sends them to the controller to which it is logically connected. Light Weight Access Point Protocol ( LWAPP ) This is a generic protocol that defines the communication between the Access Points and the Central Controller. Central Controller ( CC ) The central entity that terminates the LWAPP protocol tunnel from the LWAPP APs. Throughout this MIB, this entity is also referred to as 'controller'. Mobile Node ( MN ) A roaming 802.11 wireless device in a wireless network associated with an access point. Mobile Node and client are used interchangeably. Radio Resource Management ( RRM ) RRM is the system level control of co-channel interference and other radio transmission characteristics in wireless communication systems. Received Signal Strength Indicator ( RSSI ) A measure of the strength of the signal as observed by the entity that received it, expressed in 'dbm'. Coverage Hole Detection ( CHD ) If clients on an Access Point are detected at low RSSI levels, it is considered a coverage hole by the Access Points. This indicates the existence of an area where clients are continually getting poor signal coverage, without having a viable location to roam to. Dynamic Channel Assignment (DCA) Dynamic channel assignment (DCA) is used by the controller to minimize adjacent channel interference between access points. Dynamic Frequency Selection (DFS) Dynamic frequency selection (DFS) is used by the controller to detect radar signals and avoid interfering with them. RRM RF Grouping Radio Resource Management (RRM) allows the Cisco WLAN controllers to continuously analyze the existing RF environments, and automatically adjust the AP power and channel configurations in order to help alleviate overlapping channel interference, signal coverage problems, and so forth. An RF group is a cluster of Cisco wireless controllers that coordinates its RRM calculations on a per 802.11-network basis. An RF group exists for each 802.11 network type. Clustering controllers into RF groups enables the RRM algorithms to scale beyond a single controller. +....+ Auto-leader +....+ Auto-member + + <-------------> + C2 + + + (802.11a network) +....+ + C1 + + + + + Static-member +....+ Static-leader + + <-------------> + C3 + +....+ (802.11b network) +....+ With the help of above diagram, different aspects of RRM RF Grouping can be explained. Grouping can be configured for 3 modes. 1) Automatic 2) Static 3) Off If the mode is 'Automatic', the controllers automatically form groups and elect leaders to perform better dynamic parameter optimization. If the mode is 'Static', user can select one controller as the group leader and configure the group members manually. If the mode is 'Off', no dynamic grouping occurs. Each controller optimizes only its own APs' parameters. In the above diagram, controller C1 forms a RF group with controller C2 in 802.11a network. And with controller C3, it forms a different group in 802.11b network. For the 802.11a network, the gorup mode is selected as 'Automatic'. So between C1 and C2 controllers, one would be selected as group leader and the other controller as member automatically by the algorithm. In the above case C1 is the group leader and C2 is the group member. Now for 802.11b network, group mode is selected as 'Static'. Also the user has manually configured C3 as the leader in this group and C1 was added to this group as member. REFERENCE [1] Wireless LAN Medium Access Control ( MAC ) and Physical Layer ( PHY ) Specifications [2] Draft-obara-capwap-lwapp-00.txt, IETF Light Weight Access Point Protocol ")
ciscoLwappRrmMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 0))
ciscoLwappRrmMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 1))
ciscoLwappRrmMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 2))
clrRrmConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1))
class ClrRrmTupleTuningRange(TextualConvention, Integer32):
    description = 'This textual convention defines the RRM tuning parameter range on a 802.11 client.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-127, 127)

clrRrmParametersTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1), )
if mibBuilder.loadTexts: clrRrmParametersTable.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersTable.setDescription('This table represents the RRM parameters for a 802.11 interface type. Entries are automatically created on the controller for each 802.11 interface type.')
clrRrmParametersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-LWAPP-RRM-MIB", "clrRrmParametersType"))
if mibBuilder.loadTexts: clrRrmParametersEntry.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersEntry.setDescription('An entry in this table corresponds to a particular 802.11 interface type.')
clrRrmParametersType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 1), CLApIfType())
if mibBuilder.loadTexts: clrRrmParametersType.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersType.setDescription('This object uniquely represents the 802.11 interface type for this entry.')
clrRrmParametersPicoCellMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("picoCellv1", 2), ("picoCellv2", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersPicoCellMode.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmParametersPicoCellMode.setDescription("This object specifies the 802.11 pico-cell mode. disable - pico-cell mode is disabled. picoCellv1 - legacy pico-cell mode is in use. picoCellv2 - in this mode the APs to use the tuple information from the clrRrmTupleTable. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmParametersChdEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersChdEnable.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersChdEnable.setDescription("This object represents the state of CHD (Coverage Hole Detection) on the controller. A value of 'true' indicates that the detection is enabled. A value of 'false' indicates that the detection is disabled.")
clrRrmParametersVoicePktCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(10)).setUnits('packets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersVoicePktCountThreshold.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersVoicePktCountThreshold.setDescription('This object represents the minimum threshold on the Voice packet count required to trigger the CHD algorithm on the controller.')
clrRrmParametersVoicePktPercentThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(20)).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersVoicePktPercentThreshold.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersVoicePktPercentThreshold.setDescription('This object represents the threshold on the percent of Voice packets dropped, that is required to trigger the CHD algorithm on the controller.')
clrRrmParametersVoiceRssiThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-90, -60)).clone(-80)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersVoiceRssiThreshold.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersVoiceRssiThreshold.setDescription('This object represents the RSSI threshold value for Voice packets, that is required to trigger the CHD algorithm on the controller.')
clrRrmParametersDataPktCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(10)).setUnits('packets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersDataPktCountThreshold.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersDataPktCountThreshold.setDescription('This object represents the minimum threshold on the Data packet count required to trigger the CHD algorithm on the controller.')
clrRrmParametersDataPktPercentThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(20)).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersDataPktPercentThreshold.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersDataPktPercentThreshold.setDescription('This object represents the threshold on the percent of Data packets dropped, that is required to trigger the CHD algorithm on the controller.')
clrRrmParametersDataRssiThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-90, -60)).clone(-74)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersDataRssiThreshold.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersDataRssiThreshold.setDescription('This object represents the RSSI threshold value for Data packets, that is required to trigger the CHD algorithm on the controller.')
clrRrmParametersDcaChannelWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("min", 1), ("medium", 2), ("max", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersDcaChannelWidth.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersDcaChannelWidth.setDescription('This object specifies how the system performs DCA channel width selection min - Min channel width(20Mhz) the radio supports medium - Medium channel width(40Mhz) supported by this radio. max - Max channel width(80Mhz) supported by this radio.')
clrRrmParametersMaxTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-126, 126)).clone(30)).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersMaxTxPower.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersMaxTxPower.setDescription("This defines the upper limit of transmit power in dBm. For a 802.11a network, the system will only accept this configuration if the bsnGlobalDot11aDynamicTransmitPowerControl is set to 'automatic' or 'runOnce'. For a 802.11b network, the system will only accept this configuration if the bsnGlobalDot11bDynamicTransmitPowerControl is set to 'automatic' or 'runOnce'. The value of this attribute has to be greater than equal to value of clrRrmParametersMinTxPower.")
clrRrmParametersMinTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-126, 126)).clone(-10)).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersMinTxPower.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersMinTxPower.setDescription("This defines the lower limit of transmit power in dBm. For an 802.11a network, the system will only accept this configuration if the bsnGlobalDot11aDynamicTransmitPowerControl is set to 'automatic' or 'runOnce'. For an 802.11b network, the system will only accept this configuration if the bsnGlobalDot11bDynamicTransmitPowerControl is set to 'automatic' or 'runOnce'. The value of this attribute has to be less than equal to value of clrRrmParametersMaxTxPower.")
clrRrmParametersTpcVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("versionOne", 1), ("versionTwo", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersTpcVersion.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersTpcVersion.setDescription('This object represents the TPC(Transmission Power Control) version. If version 1 is selected, TPC would be in coverage optimal mode. If version 2 is selected, TPC would be in interference optimal mode.')
clrRrmParametersMaxClients = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersMaxClients.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersMaxClients.setDescription('This object represents the maximum allowed clients per radio.')
clrRrmParametersRssiCheckEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersRssiCheckEnable.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersRssiCheckEnable.setDescription("This object represents the state of RSSI low check on the controller. A value of 'true' indicates that the check is enabled. A value of 'false' indicates that the check is disabled.")
clrRrmParametersRssiThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-90, -60)).clone(-80)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersRssiThreshold.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersRssiThreshold.setDescription('This object represents the RSSI threshold value for RSSI low check.')
clrRrmParametersOptRoamEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 17), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersOptRoamEnable.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersOptRoamEnable.setDescription("This object represents the state of Optimized Roaming feature on the controller. A value of 'true' indicates that the feature is enabled. A value of 'false' indicates that the feature is disabled")
clrRrmParametersOptRoamDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 54))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersOptRoamDataRate.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersOptRoamDataRate.setDescription('This object represents the data rate threshold value for Optimized Roaming. A valid data rate in mbps must be entered.')
clrRrmParametersOptRoamInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 90)).clone(90)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmParametersOptRoamInterval.setStatus('current')
if mibBuilder.loadTexts: clrRrmParametersOptRoamInterval.setDescription('This object represents the reporting interval value for Optimized Roaming.')
clrRrmTupleTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2), )
if mibBuilder.loadTexts: clrRrmTupleTable.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleTable.setDescription("A list of tuple tuning parameters that are advertised to all APs registered under this 802.11 interface type. This information is pushed down to to 802.11 clients by the APs to operate under high density. Entries in this table are automatically created by the controller with default values. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-LWAPP-RRM-MIB", "clrRrmParametersType"))
if mibBuilder.loadTexts: clrRrmTupleEntry.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleEntry.setDescription("Each entry represents the tuning parameters for an interface type. These entries are applicable only when object clrRrmParametersPicoCellMode is is set to 'picoCellv2'. Pico cell is no more supported so deprecating this attribute. It will be obsolete post 7.0 release. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleRxSenseThresholdMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 1), ClrRrmTupleTuningRange().clone(-127)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleRxSenseThresholdMin.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleRxSenseThresholdMin.setDescription("This object represents the minimum value configured for receiver's sensitivity threshold. This value must be less than the value configured for clrRrmTupleRxSenseThresholdMax object. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleRxSenseThresholdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 2), ClrRrmTupleTuningRange().clone(127)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleRxSenseThresholdMax.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleRxSenseThresholdMax.setDescription("This object represents the maximum value configured for receiver's sensitivity threshold. This value must be greater than the value configured for clrRrmTupleRxSenseThresholdMin object. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleRxSenseThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 3), ClrRrmTupleTuningRange().clone(-80)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleRxSenseThreshold.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleRxSenseThreshold.setDescription("This object represents the current value for receiver's sensitivity threshold. This value is sent to the APs that join the controller. The APs in turn propogate this value to the 802.11 clients. The client will either use this value or will tune receiver's sensitivity settings between the range of values configured by clrRrmTupleRxSenseThresholdMin and clrRrmTupleRxSenseThresholdMax objects. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleCcaSenseThresholdMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 4), ClrRrmTupleTuningRange().clone(-127)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleCcaSenseThresholdMin.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleCcaSenseThresholdMin.setDescription("This object represents the minimum value configured for clear channel (CCA) sensitivity threshold. This value must be less than the value configured for clrRrmTupleCcaSenseThresholdMax object. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleCcaSenseThresholdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 5), ClrRrmTupleTuningRange().clone(127)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleCcaSenseThresholdMax.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleCcaSenseThresholdMax.setDescription("This object represents the maximum value configured for clear channel (CCA) sensitivity threshold. This value must be greater than the value configured for clrRrmTupleCcaSenseThresholdMin object. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleCcaSenseThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 6), ClrRrmTupleTuningRange().clone(-60)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleCcaSenseThreshold.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleCcaSenseThreshold.setDescription("This object represents the current value for clear channel (CCA) sensitivity. This value is sent to the APs that join the controller. The APs in turn propogate this value to the 802.11 clients. The client will either use this value or may tune CCA sensitivity settings between the range of values configured by clrRrmTupleCcaSenseThresholdMin and clrRrmTupleCcaSenseThresholdMax objects. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleTransmitPowerLevelMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 7), ClrRrmTupleTuningRange().clone(-127)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleTransmitPowerLevelMin.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleTransmitPowerLevelMin.setDescription("This object represents the minimum value configured for transmit power level. This value must be less than the value configured for clrRrmTupleTransmitPowerLevelMax object. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleTransmitPowerLevelMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 8), ClrRrmTupleTuningRange().clone(127)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleTransmitPowerLevelMax.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleTransmitPowerLevelMax.setDescription("This object represents the maximum value configured for transmit power level. This value must be greater than the value for clrRrmTupleTransmitPowerLevelMin object. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleTransmitPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 9), ClrRrmTupleTuningRange().clone(10)).setUnits('dbm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleTransmitPowerLevel.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleTransmitPowerLevel.setDescription("This object represents the current value for transmit power level. This value is sent to the APs that join the controller. The APs in turn propogate this value to the 802.11 clients. The client will either use this value or may tune the transmit power settings between the range of values configured by clrRrmTupleTransmitPowerLevelMin and clrRrmTupleTransmitPowerLevelMax objects. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmTupleSetDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 2, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmTupleSetDefault.setStatus('deprecated')
if mibBuilder.loadTexts: clrRrmTupleSetDefault.setDescription("This object restores the other objects in this table to default value. Setting this value to 'true' wil restore defaults as indicated by the DEFVAL clause. This object can only be set to 'true' and all other values are rejected. This object will always return 'false' for get operations. Object is deprecated since controller doesn't support Pico cell configuration anymore.")
clrRrmChannelTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 4), )
if mibBuilder.loadTexts: clrRrmChannelTable.setStatus('current')
if mibBuilder.loadTexts: clrRrmChannelTable.setDescription("This table represents the channel information for an AP's 802.11 interface. Based on the country that an AP operates in, it gets assigned to a regulatory domain. For a given regulatory domain a fixed number of channels are assigned automatically to an AP for a given interface. This table represents this information. Entries are automatically created on the controller as APs associate. Entries are removed when the APs disassociate.")
clrRrmChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-LWAPP-RRM-MIB", "clrRrmParametersType"), (0, "CISCO-LWAPP-RRM-MIB", "clrRrmChannelNum"))
if mibBuilder.loadTexts: clrRrmChannelEntry.setStatus('current')
if mibBuilder.loadTexts: clrRrmChannelEntry.setDescription('Each entry in this table provides the channel information for an 802.11 interface in an AP.')
clrRrmChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: clrRrmChannelNum.setStatus('current')
if mibBuilder.loadTexts: clrRrmChannelNum.setDescription('The channel nubmer for this entry. This value represents the unique channel number on this 802.11 interface for this regulatory domain.')
clrRrmChannelDcaState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 4, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmChannelDcaState.setStatus('current')
if mibBuilder.loadTexts: clrRrmChannelDcaState.setDescription("This object indicates whether this channel is part of the dynamic channel allocation (DCA) list. A value of 'true' indicates that the DCA for this channel is enabled. A value of 'false' indicates that the DCA for this channel is disabled.")
clrRrmDot11BandGrpTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5), )
if mibBuilder.loadTexts: clrRrmDot11BandGrpTable.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpTable.setDescription('This table contains the information about the RRM grouping corresponding to the dot11 band of the APs that have joined the controller. This table has a one-to-one dependent relationship on the clrRrmParametersTable.')
clrRrmDot11BandGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1), ).setIndexNames((0, "CISCO-LWAPP-RRM-MIB", "clrRrmParametersType"))
if mibBuilder.loadTexts: clrRrmDot11BandGrpEntry.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpEntry.setDescription('An entry in this table represents the RRM RF grouping on a dot11 band of an AP that has joined the controller. For each dot11 band an entry will be created.')
clrRrmDot11BandGrpLeaderIpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmDot11BandGrpLeaderIpAddressType.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpLeaderIpAddressType.setDescription("This object indicates the group leader's address type for the dot11 group containing this controller. The only one address type supported is ipv4(1).")
clrRrmDot11BandGrpLeaderIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1, 2), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmDot11BandGrpLeaderIpAddress.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpLeaderIpAddress.setDescription(" This object indicates the configured group leader's address for the dot11 group containing this controller.")
clrRrmDot11BandGrpLeaderName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmDot11BandGrpLeaderName.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpLeaderName.setDescription('This object denotes the name of the current group leader.')
clrRrmDot11BandGrpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic", 1), ("off", 2), ("leader", 3))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmDot11BandGrpMode.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpMode.setDescription("This object indicates the mode for the RRM algorithm for the band. 'automatic' - the controller form groups and elect leaders to perform better dynamic parameter optimization. 'leader' - the user can manually configure the group. 'off' - no dynamic grouping occurs. Each controller optimizes only its own APs' parameters.")
clrRrmDot11BandGrpRole = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("auto-leader", 2), ("auto-member", 3), ("static-leader", 4), ("static-member", 5))).clone('auto-leader')).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmDot11BandGrpRole.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpRole.setDescription("This object indicates the group role with respect to RRM RF grouping. The controller can be either group member or group leader while being in automatic or static grouping, for a particular band. If grouping is off , the value of the group role would be 'none'. 'none' - RRM RF Grouping is off 'auto-leader' - leader of automatic RRM RF Group 'auto-member' - member in automatic RRM RF Group 'static-leader' - leader of static RRM RF Group 'static-member' - member in static RRM RF Group.")
clrRrmDot11BandGrpRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmDot11BandGrpRestart.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpRestart.setDescription(" This object denotes if the grouping algorithm needs a restart. If a value of 'true' is set, the RRM grouping algorithm is restarted for the dot11 band. This will always return 'false' when retrieved")
clrRrmDot11BandGrpLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmDot11BandGrpLastUpdateTime.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpLastUpdateTime.setDescription(" This object indicates the last time the dot11 grouping was updated on this controller. This is valid only if the controller is not a static member in the group. If it is a static member (i.e the value of the variable ,'clrRrmDot11BandGrpMode' is 'static-member(4)'), a value of '0' would be returned always.")
clrRrmDot11BandGrpInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 5, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmDot11BandGrpInterval.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpInterval.setDescription('This object indicates the period used by the grouping algorithm. The grouping algorithm runs when the group contents changes and automatic grouping is enabled. The system administrator can start grouping on demand.')
clrRrmDot11BandGrpMemberTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 6), )
if mibBuilder.loadTexts: clrRrmDot11BandGrpMemberTable.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpMemberTable.setDescription('This table contains the information about the RRM grouping members corresponding to the dot11 band of the APs that have joined the controller. The entries are members of the group represented by clrRrmDot11BandGrpTable.')
clrRrmDot11BandGrpMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 6, 1), ).setIndexNames((0, "CISCO-LWAPP-RRM-MIB", "clrRrmParametersType"), (0, "CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandMemberIpAddressType"), (0, "CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandMemberIpAddress"))
if mibBuilder.loadTexts: clrRrmDot11BandGrpMemberEntry.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandGrpMemberEntry.setDescription('An entry describes the grouping members on a dot11 band of an AP that has joined the controller. An entry will be created/deleted when members are added/deleted to/from the gorup.')
clrRrmDot11BandMemberIpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 6, 1, 1), InetAddressType())
if mibBuilder.loadTexts: clrRrmDot11BandMemberIpAddressType.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandMemberIpAddressType.setDescription('This object indicates the address type of the dot11 group member for the dot11 grouping containing this controller.')
clrRrmDot11BandMemberIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 6, 1, 2), InetAddress())
if mibBuilder.loadTexts: clrRrmDot11BandMemberIpAddress.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandMemberIpAddress.setDescription('This object specifies the address of the dot11 group member for the dot11 grouping containing this controller.')
clrRrmDot11BandMemberName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 6, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clrRrmDot11BandMemberName.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandMemberName.setDescription('This object represents the name of the dot11 group member for the dot11 grouping containing this controller.')
clrRrmDot11BandMemberIsJoined = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 6, 1, 4), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmDot11BandMemberIsJoined.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandMemberIsJoined.setDescription("This object indicates whether the member has joined this RRM RF Group yet.If not the value would be 'false'. Else it would be true.This field is significant only if the current group is a static RRM RF Group. In all other cases a value of 'true' would be shown. true - member has joined the group successfully false - member has not joined the group yet.")
clrRrmDot11BandMemberJoinFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("joinedSuccessfully", 1), ("invalidIp", 2), ("groupSizeExceeded", 3), ("invalidGroupOrder", 4), ("nonMatchingGroupID", 5), ("unexpectedError", 6), ("weakSignalStrength", 7), ("joinPending", 8), ("notAManager", 9), ("groupingDelayed", 10), ("groupingDisabled", 11), ("invalidProtocolVersion", 12), ("countryCodeMismatch", 13), ("invalidHierarchy", 14), ("alreadyAStaticLeader", 15), ("memberOfAnotherGroup", 16), ("unconfiguredAsStaticMember", 17), ("cntlrNameAndIpMismatch", 18), ("unexpectedMemoryError", 19), ("rfDomainMismatch", 20), ("splitForInvalidStateRequest", 21), ("transitioningToStaticFromAuto", 22), ("splitDueToUserAction", 23))).clone('joinedSuccessfully')).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmDot11BandMemberJoinFailureReason.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandMemberJoinFailureReason.setDescription("This object indicates the reason the member could not join the RRM RF Group. This field is relevant only if the corresponding instance for 'clrRrmDot11BandMemberIsJoined' is 'false'. joinedSuccessfully - member has joined the group successfully invalidIp - invalid ip groupSizeExceeded - group size is exceeded invalidGroupOrder - group order is invalid nonMatchingGroupID - group id doesn't match unexpectedError - unexpected error has occurred weakSignalStrength - signal strength is weak joinPending - group join is pending notAManager - not a manager groupingDelayed - grouping is delayed groupingDisabled - grouping is disabled invalidProtocolVersion - protocol version is invalid countryCodeMismatch - country code doesn't match invalidHierarchy - invalid grouping hierarchy alreadyAStaticLeader - already a static leader memberOfAnotherGroup - member of another group unconfiguredAsStaticMember - unconfigured static member cntlrNameAndIpMismatch - controller name and ip doesn't match unexpectedMemoryError - an unexpected memory error has happened rfDomainMismatch - RF domain doesn't match. splitForInvalidStateRequest - split for invalid state request transitioningToStaticFromAuto - transitioning to static from auto splitDueToUserAction - split due to user action.")
clrRrmDot11BandMemberRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 6, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: clrRrmDot11BandMemberRowStatus.setStatus('current')
if mibBuilder.loadTexts: clrRrmDot11BandMemberRowStatus.setDescription('This object specifies the status of the row.')
clrRrmDcaConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 7))
clrRrmDcaDot11aOutdoorAPDca = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 7, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmDcaDot11aOutdoorAPDca.setStatus('current')
if mibBuilder.loadTexts: clrRrmDcaDot11aOutdoorAPDca.setDescription("This object specifies whether check for non-DFS channel should be done on DCA channel list or not. Generally at least one non-DFS channel should be present in DCA channel list. But there are locations like EU(European Union) where there is no non-DFS channel available for outdoor deployment. Customers deploying outdoor APs in EU or regions with similar regulations should set this variable to 'true'. When set to 'true' Controller will not perform check for non-DFS channels in DCA list.")
clrRrmRfGroupingPriority = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clrRrmRfGroupingPriority.setStatus('current')
if mibBuilder.loadTexts: clrRrmRfGroupingPriority.setDescription('This object indicates the priority assigned to controller with respect to RRM RF Grouping. When groups are formed, the priorities of the member controllers would be checked. Priority of the member controller should be less than or equal to priority of the leader controller.')
clrRrmPakRssiConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 10))
clrRrmPakRssiEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 10, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmPakRssiEnable.setStatus('current')
if mibBuilder.loadTexts: clrRrmPakRssiEnable.setDescription("This object represents the state of Packet RSSI location feature. A value of 'true' indicates that PRL is enabled. A value of 'false' indicates that PRL is disabled.")
clrRrmPakRssiThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 10, 2), Integer32().clone(-100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmPakRssiThreshold.setStatus('current')
if mibBuilder.loadTexts: clrRrmPakRssiThreshold.setDescription('This object represents the threshold value for Packet RSSI location feature. Valid range is -100 dbm to -50 dbm.')
clrRrmPakRssiThresholdTrigger = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 10, 3), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmPakRssiThresholdTrigger.setStatus('current')
if mibBuilder.loadTexts: clrRrmPakRssiThresholdTrigger.setDescription('This object represents the trigger threshold value for Packet RSSI location feature. Valid range is 1 dbm to 100 dbm.')
clrRrmPakRssiNtpIpAddressType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 10, 4), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmPakRssiNtpIpAddressType.setStatus('current')
if mibBuilder.loadTexts: clrRrmPakRssiNtpIpAddressType.setDescription('This object represents the NTP server IP address type for Packet RSSI location feature.')
clrRrmPakRssiNtp = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 1, 10, 5), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clrRrmPakRssiNtp.setStatus('current')
if mibBuilder.loadTexts: clrRrmPakRssiNtp.setDescription('This object represents the NTP server IP for Packet RSSI location feature.')
clrRrmNotificationVariable = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2))
clrRrmApTransmitPowerLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-200, 200))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmApTransmitPowerLevel.setStatus('current')
if mibBuilder.loadTexts: clrRrmApTransmitPowerLevel.setDescription('This indicates represents the transmit power level for the AP.')
clrRrmTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 2), TimeStamp()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmTimeStamp.setStatus('current')
if mibBuilder.loadTexts: clrRrmTimeStamp.setDescription('This object indicates the time when coverage pre alarm was first reported to controller by an access point. After receiving this alert, controller will try to mitigate the coverage hole by increasing the transmit power of that access point. After doing above step for stipulated time, if coverage hole cannot be corrected by controller, a final notification would be generated from controller , informing the administrator about the existence of a coverage hole.')
clrRrmClientType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("data", 1), ("voice", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmClientType.setStatus('current')
if mibBuilder.loadTexts: clrRrmClientType.setDescription('This object indicates the client type for which this notification was sent. data(1) - coverage hole has been detected for a data client(client which is meant for data services). voice(2) - coverage hole has been detected for a voice client(client which is meant for voice services).')
clrRrmRssiHistogramLength = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 4), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmRssiHistogramLength.setStatus('current')
if mibBuilder.loadTexts: clrRrmRssiHistogramLength.setDescription('This object represents the number of values on the histogram. At present it is 31 entries.')
clrRrmRssiHistogramMaxIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 5), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmRssiHistogramMaxIndex.setStatus('current')
if mibBuilder.loadTexts: clrRrmRssiHistogramMaxIndex.setDescription('This object represents the maximum value on the histogram.')
clrRrmRssiHistogramMinIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 6), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmRssiHistogramMinIndex.setStatus('current')
if mibBuilder.loadTexts: clrRrmRssiHistogramMinIndex.setDescription('This object represents the minimum value on the histogram.')
clrRrmRssiHistogramValues = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 7), SnmpAdminString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmRssiHistogramValues.setStatus('current')
if mibBuilder.loadTexts: clrRrmRssiHistogramValues.setDescription('This object returns a comma seperated string of histogram values. The number of values sent out is represented by the clrRrmRssiHistogramLength.')
clrRrmNeighborApCount = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 8), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmNeighborApCount.setStatus('current')
if mibBuilder.loadTexts: clrRrmNeighborApCount.setDescription("This object represents the number of 'clrRrmNeighborApMac, clrRrmNeighborApRssi' appended to this notification. This count is 5 and includes the AP itself.")
clrRrmNeighborApMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 9), SnmpAdminString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmNeighborApMacAddress.setStatus('current')
if mibBuilder.loadTexts: clrRrmNeighborApMacAddress.setDescription('This object represents the neighbor MAC address for this client. This is a comma sperated values for clrRrmNeighborApCount values.')
clrRrmNeighborApRssi = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 10), SnmpAdminString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmNeighborApRssi.setStatus('current')
if mibBuilder.loadTexts: clrRrmNeighborApRssi.setDescription('This object represents the neighbor RSSI values for this client. This is a comma sperated values for clrRrmNeighborApCount values.')
clrRrmNeighborApIfType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 11), SnmpAdminString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmNeighborApIfType.setStatus('current')
if mibBuilder.loadTexts: clrRrmNeighborApIfType.setDescription('This object represents the neighbor AP radio type for this client. This is a comma sperated values for clrRrmNeighborApCount values.')
clrRrmSysMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 12), MacAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmSysMacAddress.setStatus('current')
if mibBuilder.loadTexts: clrRrmSysMacAddress.setDescription('This object represents the MAC Address of the controller.')
clrRrmSysIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 615, 1, 2, 13), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: clrRrmSysIpAddress.setStatus('current')
if mibBuilder.loadTexts: clrRrmSysIpAddress.setDescription('This object represents the IPv4 and IPv6 address of the controller.')
ciscoLwappDot11ClientCoverageHolePreAlarm = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 615, 0, 1)).setObjects(("CISCO-LWAPP-DOT11-CLIENT-MIB", "cldcClientMacAddress"), ("CISCO-LWAPP-DOT11-CLIENT-MIB", "cldcApMacAddress"), ("CISCO-LWAPP-DOT11-CLIENT-MIB", "cldcIfType"), ("CISCO-LWAPP-AP-MIB", "cLApName"), ("CISCO-LWAPP-RRM-MIB", "clrRrmApTransmitPowerLevel"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTimeStamp"), ("CISCO-LWAPP-RRM-MIB", "clrRrmClientType"), ("CISCO-LWAPP-RRM-MIB", "clrRrmRssiHistogramLength"), ("CISCO-LWAPP-RRM-MIB", "clrRrmRssiHistogramMaxIndex"), ("CISCO-LWAPP-RRM-MIB", "clrRrmRssiHistogramMinIndex"), ("CISCO-LWAPP-RRM-MIB", "clrRrmRssiHistogramValues"), ("CISCO-LWAPP-RRM-MIB", "clrRrmNeighborApCount"), ("CISCO-LWAPP-RRM-MIB", "clrRrmNeighborApMacAddress"), ("CISCO-LWAPP-RRM-MIB", "clrRrmNeighborApRssi"), ("CISCO-LWAPP-RRM-MIB", "clrRrmNeighborApIfType"), ("CISCO-LWAPP-WLAN-MIB", "cLWlanChdEnable"))
if mibBuilder.loadTexts: ciscoLwappDot11ClientCoverageHolePreAlarm.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappDot11ClientCoverageHolePreAlarm.setDescription("This notification is generated when the AP receives at least 'packet count' packets, represented by clrRrmParametersVoicePktCount for voice or clrRrmParametersDataPktCount for data, from a client in any given 5 second interval and 'packet percent' of the packets, represented by clrRrmParametersVoicePktCount for voice and clrRrmParametersDataPktCount for data, from the client are below the 'RSSI threshold' represented by clrRrmParametersVoiceRssiThreshold for voice and clrRrmParametersDataRssiThreshold for data.")
ciscoLwappRrmRfGroupLeaderChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 615, 0, 2)).setObjects(("CISCO-LWAPP-DOT11-CLIENT-MIB", "cldcIfType"), ("CISCO-LWAPP-RRM-MIB", "clrRrmSysMacAddress"), ("CISCO-LWAPP-RRM-MIB", "clrRrmSysIpAddress"))
if mibBuilder.loadTexts: ciscoLwappRrmRfGroupLeaderChange.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmRfGroupLeaderChange.setDescription('This notification would be generated, from the controller that is elected as the new leader, when RF Grouping is done. It has MAC address and details of the new Group Leader.')
ciscoLwappRrmRfGroupMemberAdded = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 615, 0, 3)).setObjects(("CISCO-LWAPP-DOT11-CLIENT-MIB", "cldcIfType"), ("CISCO-LWAPP-RRM-MIB", "clrRrmSysMacAddress"), ("CISCO-LWAPP-RRM-MIB", "clrRrmSysIpAddress"))
if mibBuilder.loadTexts: ciscoLwappRrmRfGroupMemberAdded.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmRfGroupMemberAdded.setDescription('This notification is generated from the group leader when a new member is added to the RF group. This notification has MAC address and details of new group member.')
ciscoLwappRrmRfGroupMemberRemoved = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 615, 0, 4)).setObjects(("CISCO-LWAPP-DOT11-CLIENT-MIB", "cldcIfType"), ("CISCO-LWAPP-RRM-MIB", "clrRrmSysMacAddress"), ("CISCO-LWAPP-RRM-MIB", "clrRrmSysIpAddress"))
if mibBuilder.loadTexts: ciscoLwappRrmRfGroupMemberRemoved.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmRfGroupMemberRemoved.setDescription('The notification is generated from the group leader, when a member is removed from the RF group. This notification has MAC address and details of removed group member.')
ciscoLwappRrmMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 1))
ciscoLwappRrmMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 2))
ciscoLwappRrmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 1, 1)).setObjects(("CISCO-LWAPP-RRM-MIB", "ciscoLwappRrmConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmMIBCompliance = ciscoLwappRrmMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRrmMIBCompliance.setDescription('The compliance statement for the SNMP entities that implement the ciscoLwappRrmMIB module.')
ciscoLwappRrmMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 1, 2)).setObjects(("CISCO-LWAPP-RRM-MIB", "ciscoLwappRrmConfigGroup"), ("CISCO-LWAPP-RRM-MIB", "ciscoLwappRrmConfigGroupSup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmMIBComplianceRev1 = ciscoLwappRrmMIBComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRrmMIBComplianceRev1.setDescription('The compliance statement for the SNMP entities that implement the ciscoLwappRrmMIB module.')
ciscoLwappRrmMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 1, 3)).setObjects(("CISCO-LWAPP-RRM-MIB", "ciscoLwappRrmConfigGroupSup2"), ("CISCO-LWAPP-RRM-MIB", "ciscoLwappRrmConfigGroupSup1"), ("CISCO-LWAPP-RRM-MIB", "ciscoLwappRrmConfigGroupSup3"), ("CISCO-LWAPP-RRM-MIB", "ciscoLwappRrmConfigGroupSup4"), ("CISCO-LWAPP-RRM-MIB", "ciscoLwappRrmGrpStatusGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmMIBComplianceRev2 = ciscoLwappRrmMIBComplianceRev2.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmMIBComplianceRev2.setDescription('The compliance statement for the SNMP entities that implement the ciscoLwappRrmMIB module.')
ciscoLwappRrmConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 2, 1)).setObjects(("CISCO-LWAPP-RRM-MIB", "clrRrmParametersPicoCellMode"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleRxSenseThresholdMin"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleRxSenseThresholdMax"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleRxSenseThreshold"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleCcaSenseThresholdMin"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleCcaSenseThresholdMax"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleCcaSenseThreshold"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleTransmitPowerLevelMin"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleTransmitPowerLevelMax"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleTransmitPowerLevel"), ("CISCO-LWAPP-RRM-MIB", "clrRrmTupleSetDefault"), ("CISCO-LWAPP-RRM-MIB", "clrRrmChannelDcaState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmConfigGroup = ciscoLwappRrmConfigGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoLwappRrmConfigGroup.setDescription('This collection of objects represent the RRM configuration on the controller.')
ciscoLwappRrmConfigGroupSup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 2, 2)).setObjects(("CISCO-LWAPP-RRM-MIB", "clrRrmParametersChdEnable"), ("CISCO-LWAPP-RRM-MIB", "clrRrmParametersVoicePktCountThreshold"), ("CISCO-LWAPP-RRM-MIB", "clrRrmParametersVoicePktPercentThreshold"), ("CISCO-LWAPP-RRM-MIB", "clrRrmParametersVoiceRssiThreshold"), ("CISCO-LWAPP-RRM-MIB", "clrRrmParametersDataPktCountThreshold"), ("CISCO-LWAPP-RRM-MIB", "clrRrmParametersDataPktPercentThreshold"), ("CISCO-LWAPP-RRM-MIB", "clrRrmParametersDataRssiThreshold"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmConfigGroupSup1 = ciscoLwappRrmConfigGroupSup1.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmConfigGroupSup1.setDescription('This collection of objects represents the RRM configuration for Voice and Data packets on the controller.')
ciscoLwappRrmConfigGroupSup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 2, 3)).setObjects(("CISCO-LWAPP-RRM-MIB", "clrRrmChannelDcaState"), ("CISCO-LWAPP-RRM-MIB", "clrRrmParametersDcaChannelWidth"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDcaDot11aOutdoorAPDca"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmConfigGroupSup2 = ciscoLwappRrmConfigGroupSup2.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmConfigGroupSup2.setDescription('This collection of objects represent the RRM configuration on the controller.')
ciscoLwappRrmConfigGroupSup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 2, 4)).setObjects(("CISCO-LWAPP-RRM-MIB", "clrRrmParametersMaxTxPower"), ("CISCO-LWAPP-RRM-MIB", "clrRrmParametersMinTxPower"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmConfigGroupSup3 = ciscoLwappRrmConfigGroupSup3.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmConfigGroupSup3.setDescription('This collection of objects represent the Transmission Power Control(TPC) configuration on the controller, when the same is enabled on the controller.')
ciscoLwappRrmConfigGroupSup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 2, 5)).setObjects(("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandGrpMode"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandGrpRestart"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandMemberName"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandMemberRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmConfigGroupSup4 = ciscoLwappRrmConfigGroupSup4.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmConfigGroupSup4.setDescription('This collection of objects represent the RRM RF Grouping configuration on the controller, when the same is enabled on the controller.')
ciscoLwappRrmGrpStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 615, 2, 2, 6)).setObjects(("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandGrpLeaderIpAddressType"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandGrpLeaderIpAddress"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandGrpLeaderName"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandGrpRole"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandGrpLastUpdateTime"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandGrpInterval"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandMemberIsJoined"), ("CISCO-LWAPP-RRM-MIB", "clrRrmDot11BandMemberJoinFailureReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoLwappRrmGrpStatusGroup = ciscoLwappRrmGrpStatusGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoLwappRrmGrpStatusGroup.setDescription('This collection of objects represent the status of RRM RF Groping on the controller, when the same is enabled on the controller.')
mibBuilder.exportSymbols("CISCO-LWAPP-RRM-MIB", clrRrmTimeStamp=clrRrmTimeStamp, clrRrmTupleTransmitPowerLevel=clrRrmTupleTransmitPowerLevel, clrRrmParametersOptRoamInterval=clrRrmParametersOptRoamInterval, ClrRrmTupleTuningRange=ClrRrmTupleTuningRange, clrRrmParametersVoicePktPercentThreshold=clrRrmParametersVoicePktPercentThreshold, ciscoLwappRrmConfigGroupSup4=ciscoLwappRrmConfigGroupSup4, clrRrmDot11BandMemberName=clrRrmDot11BandMemberName, clrRrmDot11BandMemberIsJoined=clrRrmDot11BandMemberIsJoined, ciscoLwappRrmConfigGroupSup3=ciscoLwappRrmConfigGroupSup3, clrRrmNeighborApMacAddress=clrRrmNeighborApMacAddress, clrRrmRssiHistogramMaxIndex=clrRrmRssiHistogramMaxIndex, clrRrmNeighborApRssi=clrRrmNeighborApRssi, ciscoLwappDot11ClientCoverageHolePreAlarm=ciscoLwappDot11ClientCoverageHolePreAlarm, clrRrmDot11BandGrpInterval=clrRrmDot11BandGrpInterval, clrRrmRssiHistogramValues=clrRrmRssiHistogramValues, clrRrmChannelTable=clrRrmChannelTable, clrRrmTupleRxSenseThresholdMax=clrRrmTupleRxSenseThresholdMax, clrRrmDot11BandMemberRowStatus=clrRrmDot11BandMemberRowStatus, clrRrmParametersTable=clrRrmParametersTable, clrRrmPakRssiEnable=clrRrmPakRssiEnable, clrRrmDot11BandGrpMemberEntry=clrRrmDot11BandGrpMemberEntry, clrRrmPakRssiThresholdTrigger=clrRrmPakRssiThresholdTrigger, ciscoLwappRrmRfGroupMemberRemoved=ciscoLwappRrmRfGroupMemberRemoved, clrRrmDot11BandGrpRole=clrRrmDot11BandGrpRole, ciscoLwappRrmMIBCompliances=ciscoLwappRrmMIBCompliances, clrRrmTupleCcaSenseThresholdMin=clrRrmTupleCcaSenseThresholdMin, clrRrmDot11BandGrpEntry=clrRrmDot11BandGrpEntry, clrRrmDot11BandGrpLeaderIpAddressType=clrRrmDot11BandGrpLeaderIpAddressType, PYSNMP_MODULE_ID=ciscoLwappRrmMIB, clrRrmRssiHistogramLength=clrRrmRssiHistogramLength, clrRrmParametersRssiThreshold=clrRrmParametersRssiThreshold, clrRrmTupleCcaSenseThresholdMax=clrRrmTupleCcaSenseThresholdMax, ciscoLwappRrmMIBGroups=ciscoLwappRrmMIBGroups, clrRrmParametersChdEnable=clrRrmParametersChdEnable, clrRrmParametersMaxClients=clrRrmParametersMaxClients, clrRrmDot11BandGrpMode=clrRrmDot11BandGrpMode, clrRrmChannelDcaState=clrRrmChannelDcaState, ciscoLwappRrmMIBCompliance=ciscoLwappRrmMIBCompliance, clrRrmPakRssiNtp=clrRrmPakRssiNtp, clrRrmNeighborApIfType=clrRrmNeighborApIfType, ciscoLwappRrmMIBComplianceRev2=ciscoLwappRrmMIBComplianceRev2, clrRrmDot11BandGrpLeaderIpAddress=clrRrmDot11BandGrpLeaderIpAddress, clrRrmTupleTransmitPowerLevelMax=clrRrmTupleTransmitPowerLevelMax, clrRrmParametersType=clrRrmParametersType, clrRrmDot11BandMemberIpAddress=clrRrmDot11BandMemberIpAddress, clrRrmDcaConfig=clrRrmDcaConfig, clrRrmParametersVoiceRssiThreshold=clrRrmParametersVoiceRssiThreshold, clrRrmDot11BandGrpTable=clrRrmDot11BandGrpTable, clrRrmPakRssiConfig=clrRrmPakRssiConfig, clrRrmTupleTransmitPowerLevelMin=clrRrmTupleTransmitPowerLevelMin, clrRrmParametersDcaChannelWidth=clrRrmParametersDcaChannelWidth, clrRrmParametersDataRssiThreshold=clrRrmParametersDataRssiThreshold, clrRrmParametersVoicePktCountThreshold=clrRrmParametersVoicePktCountThreshold, ciscoLwappRrmConfigGroupSup2=ciscoLwappRrmConfigGroupSup2, ciscoLwappRrmMIB=ciscoLwappRrmMIB, clrRrmDot11BandMemberJoinFailureReason=clrRrmDot11BandMemberJoinFailureReason, clrRrmDot11BandGrpLastUpdateTime=clrRrmDot11BandGrpLastUpdateTime, ciscoLwappRrmMIBObjects=ciscoLwappRrmMIBObjects, clrRrmPakRssiNtpIpAddressType=clrRrmPakRssiNtpIpAddressType, clrRrmPakRssiThreshold=clrRrmPakRssiThreshold, clrRrmTupleSetDefault=clrRrmTupleSetDefault, clrRrmDot11BandGrpMemberTable=clrRrmDot11BandGrpMemberTable, ciscoLwappRrmMIBComplianceRev1=ciscoLwappRrmMIBComplianceRev1, clrRrmChannelNum=clrRrmChannelNum, clrRrmParametersOptRoamEnable=clrRrmParametersOptRoamEnable, clrRrmTupleEntry=clrRrmTupleEntry, clrRrmDcaDot11aOutdoorAPDca=clrRrmDcaDot11aOutdoorAPDca, clrRrmRfGroupingPriority=clrRrmRfGroupingPriority, clrRrmApTransmitPowerLevel=clrRrmApTransmitPowerLevel, ciscoLwappRrmConfigGroup=ciscoLwappRrmConfigGroup, ciscoLwappRrmMIBConform=ciscoLwappRrmMIBConform, ciscoLwappRrmRfGroupLeaderChange=ciscoLwappRrmRfGroupLeaderChange, clrRrmRssiHistogramMinIndex=clrRrmRssiHistogramMinIndex, clrRrmSysIpAddress=clrRrmSysIpAddress, ciscoLwappRrmRfGroupMemberAdded=ciscoLwappRrmRfGroupMemberAdded, clrRrmParametersRssiCheckEnable=clrRrmParametersRssiCheckEnable, clrRrmParametersMaxTxPower=clrRrmParametersMaxTxPower, clrRrmParametersPicoCellMode=clrRrmParametersPicoCellMode, clrRrmParametersTpcVersion=clrRrmParametersTpcVersion, clrRrmTupleTable=clrRrmTupleTable, clrRrmParametersDataPktCountThreshold=clrRrmParametersDataPktCountThreshold, clrRrmChannelEntry=clrRrmChannelEntry, clrRrmClientType=clrRrmClientType, ciscoLwappRrmGrpStatusGroup=ciscoLwappRrmGrpStatusGroup, clrRrmTupleRxSenseThreshold=clrRrmTupleRxSenseThreshold, clrRrmSysMacAddress=clrRrmSysMacAddress, clrRrmConfig=clrRrmConfig, clrRrmNotificationVariable=clrRrmNotificationVariable, clrRrmParametersEntry=clrRrmParametersEntry, clrRrmParametersDataPktPercentThreshold=clrRrmParametersDataPktPercentThreshold, clrRrmDot11BandMemberIpAddressType=clrRrmDot11BandMemberIpAddressType, clrRrmNeighborApCount=clrRrmNeighborApCount, clrRrmTupleCcaSenseThreshold=clrRrmTupleCcaSenseThreshold, clrRrmParametersOptRoamDataRate=clrRrmParametersOptRoamDataRate, clrRrmParametersMinTxPower=clrRrmParametersMinTxPower, clrRrmDot11BandGrpRestart=clrRrmDot11BandGrpRestart, clrRrmTupleRxSenseThresholdMin=clrRrmTupleRxSenseThresholdMin, ciscoLwappRrmMIBNotifs=ciscoLwappRrmMIBNotifs, ciscoLwappRrmConfigGroupSup1=ciscoLwappRrmConfigGroupSup1, clrRrmDot11BandGrpLeaderName=clrRrmDot11BandGrpLeaderName)

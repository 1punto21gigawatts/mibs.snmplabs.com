#
# PySNMP MIB module SHIVA-IP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SHIVA-IP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:03:10 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
tIP, = mibBuilder.importSymbols("SHIVA-MIB", "tIP")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Gauge32, MibIdentifier, IpAddress, Counter32, Bits, Counter64, NotificationType, ObjectIdentity, TimeTicks, Integer32, iso, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Gauge32", "MibIdentifier", "IpAddress", "Counter32", "Bits", "Counter64", "NotificationType", "ObjectIdentity", "TimeTicks", "Integer32", "iso", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
tARPClearCache = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tARPClearCache.setStatus('mandatory')
if mibBuilder.loadTexts: tARPClearCache.setDescription('Writing this variable clears the ARP Cache.')
tIPClearRedirects = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tIPClearRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: tIPClearRedirects.setDescription('Writing this variable removes all ICMP from the IP routing table.')
tUDPChecksums = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tUDPChecksums.setStatus('mandatory')
if mibBuilder.loadTexts: tUDPChecksums.setDescription('Indicates whether checksums will be calculated and verified for locally generated and received UDP packets.')
tIPBroadCastFill = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ones", 1), ("zeroes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tIPBroadCastFill.setStatus('mandatory')
if mibBuilder.loadTexts: tIPBroadCastFill.setDescription('Indicates whether locally calculated broadcast address will be one-fill or zero-fill.')
tTimeServerTable = MibTable((1, 3, 6, 1, 4, 1, 166, 4, 3, 5), )
if mibBuilder.loadTexts: tTimeServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: tTimeServerTable.setDescription('Table of RFC858 UDP Time servers.')
pysmiFakeCol1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 5, 1) + (1000, ), Integer32())
tTimeServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 166, 4, 3, 5, 1), ).setIndexNames((0, "SHIVA-IP-MIB", "pysmiFakeCol1000"))
if mibBuilder.loadTexts: tTimeServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tTimeServerEntry.setDescription('An entry in the Time Server table')
tTimeServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 5, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tTimeServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tTimeServerAddress.setDescription('The Address of the time server.')
tNameServerTable = MibTable((1, 3, 6, 1, 4, 1, 166, 4, 3, 6), )
if mibBuilder.loadTexts: tNameServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: tNameServerTable.setDescription('Table of Domain Name Servers.')
pysmiFakeCol1001 = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 6, 1) + (1001, ), Integer32())
tNameServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 166, 4, 3, 6, 1), ).setIndexNames((0, "SHIVA-IP-MIB", "pysmiFakeCol1001"))
if mibBuilder.loadTexts: tNameServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tNameServerEntry.setDescription('An entry in the Name Server table')
tNameServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 6, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tNameServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tNameServerAddress.setDescription('The Address of the name server.')
tBootServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tBootServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tBootServerAddress.setDescription('The Address of the server from which the system last retrieved an image and configuration.')
tSerialIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 166, 4, 3, 8), )
if mibBuilder.loadTexts: tSerialIpAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: tSerialIpAddressTable.setDescription('Table of Serial IP addresses and default addresses indexed by serial line number.')
tSerialIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 166, 4, 3, 8, 1), ).setIndexNames((0, "SHIVA-IP-MIB", "tSerialIpAddressIndex"))
if mibBuilder.loadTexts: tSerialIpAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tSerialIpAddressEntry.setDescription('An entry in the Serial IP Address table')
tSerialIpAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tSerialIpAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: tSerialIpAddressIndex.setDescription('A serial line number.')
tSerialIpAddressLocalDefaultAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 8, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tSerialIpAddressLocalDefaultAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tSerialIpAddressLocalDefaultAddress.setDescription('The default local IP address for this serial line.')
tSerialIpAddressRemoteDefaultAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 8, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tSerialIpAddressRemoteDefaultAddress.setStatus('deprecated')
if mibBuilder.loadTexts: tSerialIpAddressRemoteDefaultAddress.setDescription('The default remote IP address for this serial line. Deprecated, always 0.')
tSerialIpAddressLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 8, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tSerialIpAddressLocalAddress.setStatus('deprecated')
if mibBuilder.loadTexts: tSerialIpAddressLocalAddress.setDescription('The local IP address in use on this serial line. Deprecated, always 0.')
tSerialIpAddressRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 166, 4, 3, 8, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tSerialIpAddressRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tSerialIpAddressRemoteAddress.setDescription('The remote IP address in use on this serial line.')
tAcceptAnyClientAddr = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tAcceptAnyClientAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tAcceptAnyClientAddr.setDescription('Indicates whether IP addresses proposed by the client will be accepted without checking against configured (per-port, per-user, etc) addresses.')
tNumIpRoutes = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tNumIpRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: tNumIpRoutes.setDescription("Number of routes in the entity's IP routing table.")
tUseConfiguredUserAddr = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tUseConfiguredUserAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tUseConfiguredUserAddr.setDescription('Indicates whether IP addresses configured for users will be a determinant in IP address assignment policy for dialin clients. The four possible sources of IP addresses are as follows: 1) client-proposed address, 2) user record address, 3) address pool, and 4) address from Dynamic Host Configuration Protocol (DHCP) server. These sources are checked in order, but a source is only checked if it is enabled as a determinant.')
tUseConfiguredPortAddr = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tUseConfiguredPortAddr.setStatus('deprecated')
if mibBuilder.loadTexts: tUseConfiguredPortAddr.setDescription('Indicates whether IP addresses configured for ports will be a determinant in IP address assignment policy for dialin clients. The four possible sources of IP addresses are as follows: 1) client-proposed address, 2) user record address, 3) address pool, and 4) address from Dynamic Host Configuration Protocol (DHCP) server. These sources are checked in order, but a source is only checked if it is enabled as a determinant. Deprecated, always returns disabled(2)')
tUseDHCPAddr = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tUseDHCPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tUseDHCPAddr.setDescription('Indicates whether IP addresses will be obtained for dialin clients via the Dynamic Host Configuration Protocol. The four possible sources of IP addresses are as follows: 1) client-proposed address, 2) user record address, 3) address pool, and 4) address from Dynamic Host Configuration Protocol (DHCP) server. These sources are checked in order, but a source is only checked if it is enabled as a determinant.')
tHomeIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tHomeIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tHomeIPAddr.setDescription('The IP Address of the home (main) IP interface. It is implict that there is one main IP address which the device prefers to use as its source address for internally generated IP traffic which is not in response to received IP packets. Technically this address is already available via the ipAddrTable, but since this table is indexed by IP address a GetNext is needed in order to access the table to determine an IP address, and this is not always practical.')
tUsePoolAddr = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 3, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tUsePoolAddr.setStatus('mandatory')
if mibBuilder.loadTexts: tUsePoolAddr.setDescription('Indicates whether IP addresses from the IP address pool will be a determinant in IP address assignment policy for dialin clients. The four possible sources of IP addresses are as follows: 1) client-proposed address, 2) user record address, 3) address pool, and 4) address from Dynamic Host Configuration Protocol (DHCP) server. These sources are checked in order, but a source is only checked if it is enabled as a determinant.')
mibBuilder.exportSymbols("SHIVA-IP-MIB", tARPClearCache=tARPClearCache, tBootServerAddress=tBootServerAddress, tUseConfiguredPortAddr=tUseConfiguredPortAddr, tNameServerEntry=tNameServerEntry, tTimeServerEntry=tTimeServerEntry, tIPBroadCastFill=tIPBroadCastFill, tHomeIPAddr=tHomeIPAddr, tTimeServerAddress=tTimeServerAddress, tSerialIpAddressLocalDefaultAddress=tSerialIpAddressLocalDefaultAddress, tSerialIpAddressRemoteDefaultAddress=tSerialIpAddressRemoteDefaultAddress, tTimeServerTable=tTimeServerTable, tSerialIpAddressEntry=tSerialIpAddressEntry, tSerialIpAddressRemoteAddress=tSerialIpAddressRemoteAddress, tUseConfiguredUserAddr=tUseConfiguredUserAddr, pysmiFakeCol1000=pysmiFakeCol1000, tUsePoolAddr=tUsePoolAddr, tSerialIpAddressIndex=tSerialIpAddressIndex, tUDPChecksums=tUDPChecksums, tUseDHCPAddr=tUseDHCPAddr, tSerialIpAddressTable=tSerialIpAddressTable, tNameServerAddress=tNameServerAddress, tSerialIpAddressLocalAddress=tSerialIpAddressLocalAddress, tAcceptAnyClientAddr=tAcceptAnyClientAddr, pysmiFakeCol1001=pysmiFakeCol1001, tNumIpRoutes=tNumIpRoutes, tNameServerTable=tNameServerTable, tIPClearRedirects=tIPClearRedirects)

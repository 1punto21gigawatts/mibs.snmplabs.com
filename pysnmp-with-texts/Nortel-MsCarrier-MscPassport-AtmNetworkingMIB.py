#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-AtmNetworkingMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-AtmNetworkingMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
mscAtmIfVptVcc, mscAtmIfVpc, mscAtmIfVpcIndex, mscAtmIfIndex, mscAtmIfVptVccIndex, mscAtmIfVcc, mscAtmIfVptIndex, mscAtmIfVccIndex = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVcc", "mscAtmIfVpc", "mscAtmIfVpcIndex", "mscAtmIfIndex", "mscAtmIfVptVccIndex", "mscAtmIfVcc", "mscAtmIfVptIndex", "mscAtmIfVccIndex")
Unsigned32, StorageType, DisplayString, RowStatus, Counter32, RowPointer, Integer32, Gauge32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Unsigned32", "StorageType", "DisplayString", "RowStatus", "Counter32", "RowPointer", "Integer32", "Gauge32")
HexString, AsciiString, NonReplicated, AsciiStringIndex, IntegerSequence, FixedPoint1 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "HexString", "AsciiString", "NonReplicated", "AsciiStringIndex", "IntegerSequence", "FixedPoint1")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, Unsigned32, NotificationType, IpAddress, Gauge32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Counter32, Counter64, TimeTicks, ModuleIdentity, Integer32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Unsigned32", "NotificationType", "IpAddress", "Gauge32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Counter32", "Counter64", "TimeTicks", "ModuleIdentity", "Integer32", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
atmNetworkingMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42))
mscARtg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95))
mscARtgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 1), )
if mibBuilder.loadTexts: mscARtgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgRowStatusTable.setDescription('This entry controls the addition and deletion of mscARtg components.')
mscARtgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"))
if mibBuilder.loadTexts: mscARtgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgRowStatusEntry.setDescription('A single entry in the table represents a single mscARtg component.')
mscARtgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtg components. These components can be added and deleted.')
mscARtgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgStorageType.setDescription('This variable represents the storage type value for the mscARtg tables.')
mscARtgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscARtgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgIndex.setDescription('This variable represents the index for the mscARtg tables.')
mscARtgStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 10), )
if mibBuilder.loadTexts: mscARtgStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgStatsTable.setDescription('This group contains the statistical operational attributes of an ARtg component.')
mscARtgStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"))
if mibBuilder.loadTexts: mscARtgStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgStatsEntry.setDescription('An entry in the mscARtgStatsTable.')
mscARtgRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgRoutingAttempts.setDescription('This attribute counts the total number of calls routed. The counter wraps when it exceeds the maximum value.')
mscARtgFailedRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgFailedRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgFailedRoutingAttempts.setDescription('This attribute counts the total number of calls which were not successfully routed.The counter wraps when it exceeds the maximum value.')
mscARtgDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2))
mscARtgDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 1), )
if mibBuilder.loadTexts: mscARtgDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscARtgDna components.')
mscARtgDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgDnaIndex"))
if mibBuilder.loadTexts: mscARtgDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgDna component.')
mscARtgDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgDna components. These components cannot be added nor deleted.')
mscARtgDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaStorageType.setDescription('This variable represents the storage type value for the mscARtgDna tables.')
mscARtgDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 40)))
if mibBuilder.loadTexts: mscARtgDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaIndex.setDescription('This variable represents the index for the mscARtgDna tables.')
mscARtgDnaDestInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2))
mscARtgDnaDestInfoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 1), )
if mibBuilder.loadTexts: mscARtgDnaDestInfoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscARtgDnaDestInfo components.')
mscARtgDnaDestInfoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgDnaDestInfoIndex"))
if mibBuilder.loadTexts: mscARtgDnaDestInfoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgDnaDestInfo component.')
mscARtgDnaDestInfoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaDestInfoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgDnaDestInfo components. These components cannot be added nor deleted.')
mscARtgDnaDestInfoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaDestInfoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgDnaDestInfoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaDestInfoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoStorageType.setDescription('This variable represents the storage type value for the mscARtgDnaDestInfo tables.')
mscARtgDnaDestInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)))
if mibBuilder.loadTexts: mscARtgDnaDestInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoIndex.setDescription('This variable represents the index for the mscARtgDnaDestInfo tables.')
mscARtgDnaDestInfoOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 10), )
if mibBuilder.loadTexts: mscARtgDnaDestInfoOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes for the DestInfo component.')
mscARtgDnaDestInfoOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgDnaDestInfoIndex"))
if mibBuilder.loadTexts: mscARtgDnaDestInfoOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoOperEntry.setDescription('An entry in the mscARtgDnaDestInfoOperTable.')
mscARtgDnaDestInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("primary", 0), ("alternate", 1), ("registered", 2), ("default", 3), ("ebr", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaDestInfoType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoType.setDescription('This attribute indicates the type of the address at the destination interface. Provisioned addresses are assigned a type of primary or alternate; ATM routing will try primary routes and then the alternate routes if none of the primary routes succeed. The type registered is used for dynamic addresses registered through ILMI. The type default is used for Soft PVC addresses. The type ebr indicates addresses used by Edge Based Rerouting.')
mscARtgDnaDestInfoScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaDestInfoScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoScope.setDescription('This attribute indicates the highest level (meaning the lowest level number) in the hierarchy that the address will be advertised to. A value of -1 indicates that the scope is not applicable since this node has not been configured as a PNNI node.')
mscARtgDnaDestInfoStdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 10, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaDestInfoStdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoStdComponentName.setDescription('This attribute represents a component name of the interface through which the address can be reached.')
mscARtgDnaDestInfoReachability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 2, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgDnaDestInfoReachability.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgDnaDestInfoReachability.setDescription('This attribute indicates whether the address is internal or exterior.')
mscARtgPnni = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3))
mscARtgPnniRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 1), )
if mibBuilder.loadTexts: mscARtgPnniRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRowStatusTable.setDescription('This entry controls the addition and deletion of mscARtgPnni components.')
mscARtgPnniRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"))
if mibBuilder.loadTexts: mscARtgPnniRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnni component.')
mscARtgPnniRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnni components. These components can be added and deleted.')
mscARtgPnniComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniStorageType.setDescription('This variable represents the storage type value for the mscARtgPnni tables.')
mscARtgPnniIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscARtgPnniIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniIndex.setDescription('This variable represents the index for the mscARtgPnni tables.')
mscARtgPnniProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 10), )
if mibBuilder.loadTexts: mscARtgPnniProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniProvTable.setDescription('This group contains the generic provisionable attributes of a Pnni component.')
mscARtgPnniProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"))
if mibBuilder.loadTexts: mscARtgPnniProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniProvEntry.setDescription('An entry in the mscARtgPnniProvTable.')
mscARtgPnniNodeAddressPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniNodeAddressPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniNodeAddressPrefix.setDescription("This attribute specifies the ATM address of this node. It allows the default node address to be overridden. If this attribute is set to the null string, then the default node address prefix is assumed, and computed as follows: the value provisioned for the ModuleData component's nodePrefix attribute, followed by a unique MAC address (6 octets).")
mscARtgPnniDefaultScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 104))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniDefaultScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniDefaultScope.setDescription('This attribute specifies the default PNNI scope for ATM addresses associated with this node. The PNNI scope determines the level to which the address will be advertised within the PNNI routing domain. A provisioned Addr component may override the default scope in a PnniInfo subcomponent. A value of 0 means that all addresses which do not have provisioned scopes will be advertised globally within the PNNI routing domain. The value specified must be numerically smaller than or equal to that of the lowest level at which this node is configured in the PNNI hierarchy.')
mscARtgPnniDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)).clone(hexValue="31")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniDomain.setDescription('This attribute specifies the routing domain name. This attribute should be set identically for all nodes in the same routing domain.')
mscARtgPnniRestrictTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRestrictTransit.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRestrictTransit.setDescription('This attribute specifies if the node should restrict tandeming of SVCs. If this attribute is set to true, then other lowest level nodes in the PNNI hierarchy will avoid traversing this node during route computation.')
mscARtgPnniMaxAlternateRoutesOnCrankback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 20)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniMaxAlternateRoutesOnCrankback.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniMaxAlternateRoutesOnCrankback.setDescription('This attribute specifies the number of alternate routing attempts before a call requiring crank back is rejected.')
mscARtgPnniPglParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 11), )
if mibBuilder.loadTexts: mscARtgPnniPglParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPglParmsTable.setDescription('This group contains the provisionable attributes for the peer group leader election timer parameters of a Pnni component.')
mscARtgPnniPglParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"))
if mibBuilder.loadTexts: mscARtgPnniPglParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPglParmsEntry.setDescription('An entry in the mscARtgPnniPglParmsTable.')
mscARtgPnniPglInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniPglInitTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPglInitTime.setDescription('This attribute specifies how long this node will delay advertising its choice of preferred peer group leader after having initialized operation and reached the full peer state with at least one neighbor in the peer group.')
mscARtgPnniOverrideDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniOverrideDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniOverrideDelay.setDescription('This attribute specifies how long a node will wait for itself to be declared the preferred peer group leader by unanimous agreement among its peers.')
mscARtgPnniReElectionInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniReElectionInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniReElectionInterval.setDescription('This attribute specifies how long this node will wait after losing connectivity to the current peer group leader before re-starting the process of electing a new peer group leader.')
mscARtgPnniHlParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 12), )
if mibBuilder.loadTexts: mscARtgPnniHlParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniHlParmsTable.setDescription('This group contains the default provisionable Hello protocol parameters.')
mscARtgPnniHlParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"))
if mibBuilder.loadTexts: mscARtgPnniHlParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniHlParmsEntry.setDescription('An entry in the mscARtgPnniHlParmsTable.')
mscARtgPnniHelloHoldDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 12, 1, 1), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(1, 655350)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniHelloHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniHelloHoldDown.setDescription('This attribute is used to limit the rate at which this node sends out Hello packets. Specifically, it specifies the default minimum amount of time between successive Hellos used by routing control channels on this node.')
mscARtgPnniHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniHelloInterval.setDescription('This attribute specifies the default duration of the Hello Timer in seconds for routing control channels on this node. Every helloInterval seconds, this node will send out a Hello packet to the neighbor node, subject to the helloHoldDown timer having expired at least once since the last Hello packet was sent.')
mscARtgPnniHelloInactivityFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniHelloInactivityFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniHelloInactivityFactor.setDescription('This attribute specifies the default number of Hello intervals allowed to pass without receiving a Hello from the neighbor node, before an attempt is made to re-stage, for routing control channels on this node. The hello inactivity timer is enabled in the oneWayInside, twoWayInside, oneWayOutside, twoWayOutside and commonOutside (see the helloState attribute on the Rcc component for a description of these states). Note that the value for the Hello interval used in the calculation is the one specified in the Hello packet from the neighbor node.')
mscARtgPnniPtseParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 13), )
if mibBuilder.loadTexts: mscARtgPnniPtseParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPtseParmsTable.setDescription('This group contains the provisionable attributes for the PTSE timer values of a Pnni component.')
mscARtgPnniPtseParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"))
if mibBuilder.loadTexts: mscARtgPnniPtseParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPtseParmsEntry.setDescription('An entry in the mscARtgPnniPtseParmsTable.')
mscARtgPnniPtseHoldDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 13, 1, 1), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(1, 655350)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniPtseHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPtseHoldDown.setDescription('This attribute is used to limit the rate at which this node sends out PTSE packets. Specifically, it specifies the minimum amount of time in seconds that this node must wait between sending successive PTSE packets.')
mscARtgPnniPtseRefreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 65535)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniPtseRefreshInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPtseRefreshInterval.setDescription('This attribute specifies the duration of the PTSE Timer. Every ptseRefreshInterval seconds, this node will send out a self- originated PTSE packet to the neighbor node, subject to the ptseHoldDown timer having expired at least once since the last PTSE packet was sent.')
mscARtgPnniPtseLifetimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(101, 1000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniPtseLifetimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPtseLifetimeFactor.setDescription('This attribute specifies the lifetime multiplier. The result of multiplying the ptseRefreshInterval by this value is used as the initial lifetime that this node places into PTSEs.')
mscARtgPnniRequestRxmtInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRequestRxmtInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRequestRxmtInterval.setDescription('This attribute specifies the period between retransmissions of unacknowledged Database Summary packets, PTSE Request packets and PTSPs.')
mscARtgPnniPeerDelayedAckInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 13, 1, 5), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(1, 655350)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniPeerDelayedAckInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPeerDelayedAckInterval.setDescription('This attribute specifies the minimum amount of time between transmissions of delayed PTSE acknowledgment packets.')
mscARtgPnniThreshParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 14), )
if mibBuilder.loadTexts: mscARtgPnniThreshParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniThreshParmsTable.setDescription('This group contains the provisionable attributes for the change thresholds of a ARtg Pnni component.')
mscARtgPnniThreshParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"))
if mibBuilder.loadTexts: mscARtgPnniThreshParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniThreshParmsEntry.setDescription('An entry in the mscARtgPnniThreshParmsTable.')
mscARtgPnniAvcrMt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniAvcrMt.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniAvcrMt.setDescription('This attribute when multiplied by the Maximum Cell Rate specifies the minimum threshold used in the algorithms that determine significant change for average cell rate parameters.')
mscARtgPnniAvcrPm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 14, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniAvcrPm.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniAvcrPm.setDescription('This attribute when multiplied by the current Available Cell Rate specifies the threshold used in the algorithms that determine significant change for AvCR parameters. If the resulting threshold is lower than minimum threshold, minimum threshold will be used. Increasing the value of the attribute increases the range of insignificance and reduces the amount of PTSP flooding due to changes in resource availability.')
mscARtgPnniOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 15), )
if mibBuilder.loadTexts: mscARtgPnniOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniOperTable.setDescription('This group contains the generic operational attributes of an ARtg Pnni component.')
mscARtgPnniOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"))
if mibBuilder.loadTexts: mscARtgPnniOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniOperEntry.setDescription('An entry in the mscARtgPnniOperTable.')
mscARtgPnniTopologyMemoryExhaustion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopologyMemoryExhaustion.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopologyMemoryExhaustion.setDescription('This attribute indicates if the topology database is overloaded. A node goes into a database overload state when it fails to store the complete topology database due to insufficient memory in the node. A node in this state performs resynchronization periodically by restarting all its Neighbor Peer Finite State Machines. The node will stay in this state until it synchronizes with all of its neighbors without any overload problems. When this attribute is set an alarm will be issued.')
mscARtgPnniStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 16), )
if mibBuilder.loadTexts: mscARtgPnniStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniStatsTable.setDescription('This group contains the statistical operational attributes of a ARtg Pnni component.')
mscARtgPnniStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"))
if mibBuilder.loadTexts: mscARtgPnniStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniStatsEntry.setDescription('An entry in the mscARtgPnniStatsTable.')
mscARtgPnniSuccessfulRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniSuccessfulRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniSuccessfulRoutingAttempts.setDescription('This attribute counts successful PNNI routing attempts. The counter wraps when it exceeds the maximum value.')
mscARtgPnniFailedRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniFailedRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniFailedRoutingAttempts.setDescription('This attribute counts failed PNNI routing attempts. The counter wraps when it exceeds the maximum value.')
mscARtgPnniAlternateRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniAlternateRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniAlternateRoutingAttempts.setDescription('This attribute counts successful PNNI alternate routing attempts. The counter wraps when it exceeds the maximum value.')
mscARtgPnniOptMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 386), )
if mibBuilder.loadTexts: mscARtgPnniOptMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniOptMetricTable.setDescription('This attribute is a vector that specifies the optimization metric for each ATM service category. The optimization metric is used during Generic Connection Admission Control (GCAC) route computation. Setting the value to cdv for a particular service category will cause GCAC to optimize for cell delay variation on call setups requiring that service category. Setting the value to maxCtd for a particular service category will cause GCAC to optimize for maximum cell transfer delay on call setups requiring that service category. Setting the value to aw for a particular service category will cause GCAC to optimize for administrative weight on call setups requiring that service category.')
mscARtgPnniOptMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 386, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniOptMetricIndex"))
if mibBuilder.loadTexts: mscARtgPnniOptMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniOptMetricEntry.setDescription('An entry in the mscARtgPnniOptMetricTable.')
mscARtgPnniOptMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 386, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cbr", 1), ("rtVbr", 2), ("nrtVbr", 3), ("ubr", 4))))
if mibBuilder.loadTexts: mscARtgPnniOptMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniOptMetricIndex.setDescription('This variable represents the mscARtgPnniOptMetricTable specific index for the mscARtgPnniOptMetricTable.')
mscARtgPnniOptMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 386, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("maxCtd", 1), ("aw", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniOptMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniOptMetricValue.setDescription('This variable represents an individual value for the mscARtgPnniOptMetricTable.')
mscARtgPnniRf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2))
mscARtgPnniRfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 1), )
if mibBuilder.loadTexts: mscARtgPnniRfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfRowStatusTable.setDescription('This entry controls the addition and deletion of mscARtgPnniRf components.')
mscARtgPnniRfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfIndex"))
if mibBuilder.loadTexts: mscARtgPnniRfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniRf component.')
mscARtgPnniRfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniRfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniRf components. These components cannot be added nor deleted.')
mscARtgPnniRfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniRfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniRfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniRfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniRf tables.')
mscARtgPnniRfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscARtgPnniRfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfIndex.setDescription('This variable represents the index for the mscARtgPnniRf tables.')
mscARtgPnniRfCriteriaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10), )
if mibBuilder.loadTexts: mscARtgPnniRfCriteriaTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfCriteriaTable.setDescription('This group contains the attributes specifying the routing criteria for the route computation.')
mscARtgPnniRfCriteriaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfIndex"))
if mibBuilder.loadTexts: mscARtgPnniRfCriteriaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfCriteriaEntry.setDescription('An entry in the mscARtgPnniRfCriteriaTable.')
mscARtgPnniRfDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfDestinationAddress.setDescription('This attribute specifies the destination NSAP address to be used for the computation. If this attribute specifies an invalid address then no routes will be found.')
mscARtgPnniRfMaxRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfMaxRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfMaxRoutes.setDescription('This attribute specifies a ceiling on the number of routes to be computed.')
mscARtgPnniRfTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscARtgPnniRfRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
mscARtgPnniRfAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC IE parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by CellTransfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. VBR real time service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. VBR non-real time service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscARtgPnniRfFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. Class 1 supports a QOS that will meet Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that will meet Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that will meet Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that will meet Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscARtgPnniRfBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. Class 1 supports a QOS that will meet Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that will meet Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that will meet Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that will meet Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscARtgPnniRfBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfBearerClassBbc.setDescription('This attribute specifies the bearer capability. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol.')
mscARtgPnniRfTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability : TrafficType, Timing> 0 : NoIndication, NoIndication 1 : NoIndication, yes 2 : NoIndication, no 5 : CBR, yes 8 : VBR, NoIndication 9 : VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; this is also the case for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscARtgPnniRfClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC IE. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscARtgPnniRfBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor IE. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. DESCRIPTION')
mscARtgPnniRfOptimizationMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("maxCtd", 1), ("aw", 2))).clone('aw')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfOptimizationMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfOptimizationMetric.setDescription('This attribute specifies the optimization metric to be used in the route computation; one of cell delay variation (cdv), maximum cell transfer delay (maxCtd), or administrative weight (aw).')
mscARtgPnniRfRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 388), )
if mibBuilder.loadTexts: mscARtgPnniRfRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute will be taken from the txTrafficDescParm.')
mscARtgPnniRfRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 388, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfRxTdpIndex"))
if mibBuilder.loadTexts: mscARtgPnniRfRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfRxTdpEntry.setDescription('An entry in the mscARtgPnniRfRxTdpTable.')
mscARtgPnniRfRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 388, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscARtgPnniRfRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfRxTdpIndex.setDescription('This variable represents the mscARtgPnniRfRxTdpTable specific index for the mscARtgPnniRfRxTdpTable.')
mscARtgPnniRfRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 388, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfRxTdpValue.setDescription('This variable represents an individual value for the mscARtgPnniRfRxTdpTable.')
mscARtgPnniRfTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 389), )
if mibBuilder.loadTexts: mscARtgPnniRfTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic will be shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic will be shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic will be shaped at the next rate above the PCR.')
mscARtgPnniRfTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 389, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfTxTdpIndex"))
if mibBuilder.loadTexts: mscARtgPnniRfTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfTxTdpEntry.setDescription('An entry in the mscARtgPnniRfTxTdpTable.')
mscARtgPnniRfTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 389, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscARtgPnniRfTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfTxTdpIndex.setDescription('This variable represents the mscARtgPnniRfTxTdpTable specific index for the mscARtgPnniRfTxTdpTable.')
mscARtgPnniRfTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 389, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfTxTdpValue.setDescription('This variable represents an individual value for the mscARtgPnniRfTxTdpTable.')
mscARtgPnniRfFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 390), )
if mibBuilder.loadTexts: mscARtgPnniRfFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscARtgPnniRfFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 390, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfFqpIndex"))
if mibBuilder.loadTexts: mscARtgPnniRfFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfFqpEntry.setDescription('An entry in the mscARtgPnniRfFqpTable.')
mscARtgPnniRfFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 390, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscARtgPnniRfFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfFqpIndex.setDescription('This variable represents the mscARtgPnniRfFqpTable specific index for the mscARtgPnniRfFqpTable.')
mscARtgPnniRfFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 390, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfFqpValue.setDescription('This variable represents an individual value for the mscARtgPnniRfFqpTable.')
mscARtgPnniRfBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 393), )
if mibBuilder.loadTexts: mscARtgPnniRfBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfBqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscARtgPnniRfBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 393, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniRfBqpIndex"))
if mibBuilder.loadTexts: mscARtgPnniRfBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfBqpEntry.setDescription('An entry in the mscARtgPnniRfBqpTable.')
mscARtgPnniRfBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 393, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscARtgPnniRfBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfBqpIndex.setDescription('This variable represents the mscARtgPnniRfBqpTable specific index for the mscARtgPnniRfBqpTable.')
mscARtgPnniRfBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 2, 393, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniRfBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniRfBqpValue.setDescription('This variable represents an individual value for the mscARtgPnniRfBqpTable.')
mscARtgPnniCfgNode = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3))
mscARtgPnniCfgNodeRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 1), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeRowStatusTable.setDescription('This entry controls the addition and deletion of mscARtgPnniCfgNode components.')
mscARtgPnniCfgNodeRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniCfgNode component.')
mscARtgPnniCfgNodeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniCfgNode components. These components can be added and deleted.')
mscARtgPnniCfgNodeComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniCfgNodeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniCfgNode tables.')
mscARtgPnniCfgNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 104)))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeIndex.setDescription('This variable represents the index for the mscARtgPnniCfgNode tables.')
mscARtgPnniCfgNodeProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 10), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeProvTable.setDescription('This group contains the provisionable attributes of a ConfiguredNode component.')
mscARtgPnniCfgNodeProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeProvEntry.setDescription('An entry in the mscARtgPnniCfgNodeProvTable.')
mscARtgPnniCfgNodeNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 10, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNodeId.setDescription('This attribute specifies the node id of the configured node. If this attribute is set to null, then the node id is computed as follows: If this is the lowest configured node, then the node id is computed as the level (one octet), followed by the integer value 160 (one octet), followed by the node address (20 octets). If this is not the lowest configured node, then the node id is computed as the level (one octet), followed by the 14 octet peer group id of the child peer group which the LGN represents, followed by the ESI specified in the node address (6 octets), followed by the integer value 0 (one octet).')
mscARtgPnniCfgNodePeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniCfgNodePeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodePeerGroupId.setDescription("This attribute allows the peer group id of the Logical Group Node (LGN) to be set. The peer group id is specified by 28 hex digits where the first octet represents the level of the node and the remaining 13 octets form the End System Address. If this attribute is set to the null string then the peer group id is computed as follows: The peer group id for a lowest level node is computed to be the node's level (one octet), followed by the first <level> bits of the node's address, followed by zero or more padding 0 bits. The peer group id for an LGN is computed to be the LGN's level (one octet), followed by the first <level> bits of the id of the peer group which this LGN represents.")
mscARtgPnniCfgNodeOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeOperTable.setDescription('This group contains the generic operational attributes of a ConfiguredNode component.')
mscARtgPnniCfgNodeOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeOperEntry.setDescription('An entry in the mscARtgPnniCfgNodeOperTable.')
mscARtgPnniCfgNodeNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNodeAddress.setDescription('This attribute indicates the address of the node at this level. At the lowest level, the nodeAddress is determined by the value of the nodeAddressPrefix attribute for the ARtg Pnni component followed by the level of this CfgNode. For LGNs, the nodeAddress is the same as the nodeAddress of the node at the lowest level, with the selector field set to the level of the peer group containing the LGN.')
mscARtgPnniCfgNodeOpNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeOpNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeOpNodeId.setDescription('This attribute indicates the node id of the node at this level. The default node id is computed as follows: If this is the lowest level node, then the default node id is computed as the level (one octet), followed by the integer value 160 (one octet), followed by the node address (20 octets). If this is not the lowest level node, then the default node id is computed as the level (one octet), followed by the 14 octet peer group id of the child peer group which the LGN represents, followed by the ESI specified in the node address (6 octets), followed by the integer value 0 (one octet).')
mscARtgPnniCfgNodeOpPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeOpPeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeOpPeerGroupId.setDescription('This attribute indicates the peer group id of the node at this level. The value is determined by the provisioned peerGroupId attribute.')
mscARtgPnniCfgNodeNumNeighbors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNumNeighbors.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNumNeighbors.setDescription('This attribute indicates the number of PNNI nodes which are neighbors of this node at this level.')
mscARtgPnniCfgNodeNumRccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNumRccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNumRccs.setDescription("This attribute indicates the number of Routing Control Channels to this node's neighbors at this level.")
mscARtgPnniCfgNodeCurrentLeadershipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 205))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeCurrentLeadershipPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeCurrentLeadershipPriority.setDescription('This attribute indicates the leadership priority of the node that this node believes should be the peer group leader at this point in time.')
mscARtgPnniCfgNodePglElectionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("starting", 0), ("awaiting", 1), ("awaitingFull", 2), ("initialDelay", 3), ("calculating", 4), ("operNotPgl", 5), ("operPgl", 6), ("awaitUnanimity", 7), ("hungElection", 8), ("awaitReElection", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodePglElectionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodePglElectionState.setDescription('This attribute indicates the current state of the peer group leader election process. The following are the possible values for this attribute: starting: the initial state of the state machine. awaiting: the node has started the Hello Finite State Machine on at least one link, and no peer has been found yet. awaitingFull: no database synchronization process has been completed yet but at least one neighboring peer has been found. initialDelay: Database synchronization has been completed with at least one neighboring peer. The node must wait pglInitTime second before it can select and advertise its preferred Peer Group Leader (PGL). calculating: the node is in the process of calculating what its new choice for preferred PGL will be. operNotPgl: a non PGL node is in the process of determining which node has the highest priority to be PGL by examining PTSEs sent by other nodes. operPgl: a PGL node is in the process of determining if another node has a higher priority than itself by examining PTSEs sent by other nodes. awaitUnanimity: the node has chosen itself as PGL. If the node has been elected unanimously, it generates a Unanimity event. It waits for unanimity or expiration of the overrideDelay timer before declaring itself peer group leader. hungElection: the node has chosen itself as PGL with less than 2/3 of the other nodes advertising it as their preferred PGL. In this case either this node should change its choice of preferred PGL, or the other nodes are going to accept it as PGL. awaitReElection: the node has lost connectivity to the current PGL. The connectivity must be reestablished before the reElectionInterval timer fires, otherwise the election is redone.')
mscARtgPnniCfgNodeSAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2))
mscARtgPnniCfgNodeSAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 1), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mscARtgPnniCfgNodeSAddr components.')
mscARtgPnniCfgNodeSAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrPrefixLengthIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrReachabilityIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniCfgNodeSAddr component.')
mscARtgPnniCfgNodeSAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniCfgNodeSAddr components. These components can be added and deleted.')
mscARtgPnniCfgNodeSAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniCfgNodeSAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniCfgNodeSAddr tables.')
mscARtgPnniCfgNodeSAddrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 1, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(19, 19)).setFixedLength(19))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrAddressIndex.setDescription('This variable represents an index for the mscARtgPnniCfgNodeSAddr tables.')
mscARtgPnniCfgNodeSAddrPrefixLengthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 152)))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrPrefixLengthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrPrefixLengthIndex.setDescription('This variable represents an index for the mscARtgPnniCfgNodeSAddr tables.')
mscARtgPnniCfgNodeSAddrReachabilityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1))))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrReachabilityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrReachabilityIndex.setDescription('This variable represents an index for the mscARtgPnniCfgNodeSAddr tables.')
mscARtgPnniCfgNodeSAddrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 10), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrProvTable.setDescription('This group contains the provisionable attributes of a SummaryAddress component. A summary address is an abbreviation of a set of addresses, represented by an address prefix that all of the summarized addresses have in common. A suppressed summary address is used to suppress the advertisement of addresses which match this prefix, regardless of scope.')
mscARtgPnniCfgNodeSAddrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrPrefixLengthIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrReachabilityIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrProvEntry.setDescription('An entry in the mscARtgPnniCfgNodeSAddrProvTable.')
mscARtgPnniCfgNodeSAddrSuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrSuppress.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrSuppress.setDescription('This attribute specifies whether or not the address should be suppressed. If this attribute is set to true, then all addresses matching that prefix will not be advertised above this level.')
mscARtgPnniCfgNodeSAddrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 11), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrOperTable.setDescription('This group contains the operational attributes of a SummaryAddress component.')
mscARtgPnniCfgNodeSAddrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrPrefixLengthIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeSAddrReachabilityIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrOperEntry.setDescription('An entry in the mscARtgPnniCfgNodeSAddrOperTable.')
mscARtgPnniCfgNodeSAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("advertising", 0), ("suppressing", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrState.setDescription('This attribute indicates the state of the address: one of advertising, suppressing or inactive. inactive: the summary address has been configured but is not suppressing or summarizing any ATM addresses. suppressing: the summary address has suppressed at least one ATM address on the node. advertising: the summary address is summarizing at least one ATM address on the node.')
mscARtgPnniCfgNodeSAddrScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeSAddrScope.setDescription('This attribute indicates the scope of the summary address. The scope corresponds to the scope of the underlying summarized address with the highest advertised scope. A value of -1 means the scope is unknown.')
mscARtgPnniCfgNodeNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3))
mscARtgPnniCfgNodeNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 1), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscARtgPnniCfgNodeNbr components.')
mscARtgPnniCfgNodeNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeNbrIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniCfgNodeNbr component.')
mscARtgPnniCfgNodeNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniCfgNodeNbr components. These components cannot be added nor deleted.')
mscARtgPnniCfgNodeNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniCfgNodeNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniCfgNodeNbr tables.')
mscARtgPnniCfgNodeNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 1, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrIndex.setDescription('This variable represents the index for the mscARtgPnniCfgNodeNbr tables.')
mscARtgPnniCfgNodeNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 10), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of a Neighbor component.')
mscARtgPnniCfgNodeNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeNbrIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrOperEntry.setDescription('An entry in the mscARtgPnniCfgNodeNbrOperTable.')
mscARtgPnniCfgNodeNbrPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("npDown", 0), ("negotiating", 1), ("exchanging", 2), ("loading", 3), ("full", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPeerState.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPeerState.setDescription('This attribute indicates the state of the routing database exchange with the peer node. npDown: there are no active links (i.e. in the twoWayInside Hello state) to the neighboring peer. negotiating: the first step in creating an adjacency between the two neighboring peers; this step determines which node is the master, and what the initial DS sequence number will be. exchanging: the node describes its topology database by sending Database Summary packets to the neighboring peer. loading: a full sequence of Database Summary packets has been exchanged with the neighboring peer, and the required PTSEs are requested and at least one has not yet been received. full: All PTSEs known to be available have been received from the neighboring peer. At this point the all ports leading to the neighbor node will be flooded in PTSEs within the peer group.')
mscARtgPnniCfgNodeNbrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the statistical operational attributes of a Neighbor component.')
mscARtgPnniCfgNodeNbrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeNbrIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrStatsEntry.setDescription('An entry in the mscARtgPnniCfgNodeNbrStatsTable.')
mscARtgPnniCfgNodeNbrPtspRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtspRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtspRx.setDescription('This attribute counts the PNNI Topology State Packets received from the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrPtspTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtspTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtspTx.setDescription('This attribute counts the total number of PTSPs send to the neighbor node.The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrPtseRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseRx.setDescription('This attribute counts the total number of PTSEs received from the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrPtseTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseTx.setDescription('This attribute counts the total number of PTSEs sent to the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrPtseReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseReqRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseReqRx.setDescription('This attribute counts the total number of PTSE requests received from the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrPtseReqTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseReqTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseReqTx.setDescription('This attribute counts the total number of PTSE requests sent to the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrPtseAcksRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseAcksRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseAcksRx.setDescription('This attribute counts the total number of PTSE acknowledgments received from the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrPtseAcksTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseAcksTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrPtseAcksTx.setDescription('This attribute counts the total number of PTSE acknowledgments sent to the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrDbSummariesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrDbSummariesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrDbSummariesRx.setDescription('This attribute counts the number of database summary packets received from the neighbor. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrDbSummariesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrDbSummariesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrDbSummariesTx.setDescription('This attribute counts the number of database summary packets transmitted to the neighbor. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrBadPtspRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadPtspRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadPtspRx.setDescription('This attribute counts the total number of invalid PTSP packets received from the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrBadPtseRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadPtseRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadPtseRx.setDescription('This attribute counts the total number of invalid PTSE packets received to the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrBadPtseReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadPtseReqRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadPtseReqRx.setDescription('This attribute counts the total number of invalid PTSE requests received from the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrBadPtseAckRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadPtseAckRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadPtseAckRx.setDescription('This attribute counts the total number of invalid PTSE acknowledgments received from the neighbor node. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrBadDbSummariesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 11, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadDbSummariesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrBadDbSummariesRx.setDescription('This attribute counts the total number of invalid database summary packets received from the neighbor. The counter wraps when it exceeds the maximum value.')
mscARtgPnniCfgNodeNbrRccListTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 385), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRccListTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRccListTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the component names of all Routing Control Channels to the neighbor PNNI node.')
mscARtgPnniCfgNodeNbrRccListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 385, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeNbrIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeNbrRccListValue"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRccListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRccListEntry.setDescription('An entry in the mscARtgPnniCfgNodeNbrRccListTable.')
mscARtgPnniCfgNodeNbrRccListValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 3, 385, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRccListValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeNbrRccListValue.setDescription('This variable represents both the value and the index for the mscARtgPnniCfgNodeNbrRccListTable.')
mscARtgPnniCfgNodeDefSAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4))
mscARtgPnniCfgNodeDefSAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 1), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mscARtgPnniCfgNodeDefSAddr components.')
mscARtgPnniCfgNodeDefSAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeDefSAddrIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniCfgNodeDefSAddr component.')
mscARtgPnniCfgNodeDefSAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniCfgNodeDefSAddr components. These components cannot be added nor deleted.')
mscARtgPnniCfgNodeDefSAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniCfgNodeDefSAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniCfgNodeDefSAddr tables.')
mscARtgPnniCfgNodeDefSAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrIndex.setDescription('This variable represents the index for the mscARtgPnniCfgNodeDefSAddr tables.')
mscARtgPnniCfgNodeDefSAddrDefAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 10), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrDefAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrDefAddrTable.setDescription('This group contains the operational attributes of a DefSummaryAddress component.')
mscARtgPnniCfgNodeDefSAddrDefAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeDefSAddrIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrDefAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrDefAddrEntry.setDescription('An entry in the mscARtgPnniCfgNodeDefSAddrDefAddrTable.')
mscARtgPnniCfgNodeDefSAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrAddress.setDescription('This attribute indicates the default summary address of the node at this level.')
mscARtgPnniCfgNodeDefSAddrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 11), )
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrOperTable.setDescription('This group contains the operational attributes of a SummaryAddress component.')
mscARtgPnniCfgNodeDefSAddrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniCfgNodeDefSAddrIndex"))
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrOperEntry.setDescription('An entry in the mscARtgPnniCfgNodeDefSAddrOperTable.')
mscARtgPnniCfgNodeDefSAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("advertising", 0), ("suppressing", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrState.setDescription('This attribute indicates the state of the address: one of advertising, suppressing or inactive. inactive: the summary address has been configured but is not suppressing or summarizing any ATM addresses. suppressing: the summary address has suppressed at least one ATM address on the node. advertising: the summary address is summarizing at least one ATM address on the node.')
mscARtgPnniCfgNodeDefSAddrScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 3, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniCfgNodeDefSAddrScope.setDescription('This attribute indicates the scope of the summary address. The scope corresponds to the scope of the underlying summarized address with the highest advertised scope. A value of -1 means the scope is unknown.')
mscARtgPnniTop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4))
mscARtgPnniTopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 1), )
if mibBuilder.loadTexts: mscARtgPnniTopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscARtgPnniTop components.')
mscARtgPnniTopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopIndex"))
if mibBuilder.loadTexts: mscARtgPnniTopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniTop component.')
mscARtgPnniTopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniTop components. These components cannot be added nor deleted.')
mscARtgPnniTopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniTopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniTop tables.')
mscARtgPnniTopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 104)))
if mibBuilder.loadTexts: mscARtgPnniTopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopIndex.setDescription('This variable represents the index for the mscARtgPnniTop tables.')
mscARtgPnniTopOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 10), )
if mibBuilder.loadTexts: mscARtgPnniTopOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of a Topology component.')
mscARtgPnniTopOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopIndex"))
if mibBuilder.loadTexts: mscARtgPnniTopOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopOperEntry.setDescription('An entry in the mscARtgPnniTopOperTable.')
mscARtgPnniTopPtsesInDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 10, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopPtsesInDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopPtsesInDatabase.setDescription("This attribute indicates the number of PTSEs in storage in this node's topology database for this level.")
mscARtgPnniTopPglNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 10, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopPglNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopPglNodeId.setDescription('This attribute indicates the node id of the peer group leader. If this attribute is empty, it indicates the Peer Group Level node id is unknown.')
mscARtgPnniTopActiveParentNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopActiveParentNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopActiveParentNodeId.setDescription('This attribute indicates the node identifier being used by the LGN representing this peer group at the next higher level peer group.')
mscARtgPnniTopPreferredPglNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopPreferredPglNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopPreferredPglNodeId.setDescription('This attribute represents the node in database with the highest Peer Group Level (PGL) priority. If this attribute is empty, it indicates the preferred PGL node id is unknown.')
mscARtgPnniTopNode = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2))
mscARtgPnniTopNodeRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 1), )
if mibBuilder.loadTexts: mscARtgPnniTopNodeRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscARtgPnniTopNode components.')
mscARtgPnniTopNodeRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeIndex"))
if mibBuilder.loadTexts: mscARtgPnniTopNodeRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniTopNode component.')
mscARtgPnniTopNodeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniTopNode components. These components cannot be added nor deleted.')
mscARtgPnniTopNodeComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniTopNodeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniTopNode tables.')
mscARtgPnniTopNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 1, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22))
if mibBuilder.loadTexts: mscARtgPnniTopNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeIndex.setDescription('This variable represents the index for the mscARtgPnniTopNode tables.')
mscARtgPnniTopNodeAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2))
mscARtgPnniTopNodeAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 1), )
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscARtgPnniTopNodeAddr components.')
mscARtgPnniTopNodeAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeAddrPrefixLengthIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeAddrReachabilityIndex"))
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniTopNodeAddr component.')
mscARtgPnniTopNodeAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniTopNodeAddr components. These components cannot be added nor deleted.')
mscARtgPnniTopNodeAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniTopNodeAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniTopNodeAddr tables.')
mscARtgPnniTopNodeAddrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 1, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(19, 19)).setFixedLength(19))
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrAddressIndex.setDescription('This variable represents an index for the mscARtgPnniTopNodeAddr tables.')
mscARtgPnniTopNodeAddrPrefixLengthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 152)))
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrPrefixLengthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrPrefixLengthIndex.setDescription('This variable represents an index for the mscARtgPnniTopNodeAddr tables.')
mscARtgPnniTopNodeAddrReachabilityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1))))
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrReachabilityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrReachabilityIndex.setDescription('This variable represents an index for the mscARtgPnniTopNodeAddr tables.')
mscARtgPnniTopNodeAddrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 10), )
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute group contains the operational attributes for the Address component.')
mscARtgPnniTopNodeAddrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeAddrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeAddrPrefixLengthIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeAddrReachabilityIndex"))
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrOperEntry.setDescription('An entry in the mscARtgPnniTopNodeAddrOperTable.')
mscARtgPnniTopNodeAddrScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrScope.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeAddrScope.setDescription('This attribute specifies the scope of the ATM address, which is the highest level to which this address will be advertised in the PNNI hierarchy.')
mscARtgPnniTopNodeLink = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3))
mscARtgPnniTopNodeLinkRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 1), )
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscARtgPnniTopNodeLink components.')
mscARtgPnniTopNodeLinkRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeLinkIndex"))
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniTopNodeLink component.')
mscARtgPnniTopNodeLinkRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniTopNodeLink components. These components cannot be added nor deleted.')
mscARtgPnniTopNodeLinkComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniTopNodeLinkStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniTopNodeLink tables.')
mscARtgPnniTopNodeLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435455)))
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkIndex.setDescription('This variable represents the index for the mscARtgPnniTopNodeLink tables.')
mscARtgPnniTopNodeLinkOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 10), )
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of a Link component.')
mscARtgPnniTopNodeLinkOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniTopNodeLinkIndex"))
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkOperEntry.setDescription('An entry in the mscARtgPnniTopNodeLinkOperTable.')
mscARtgPnniTopNodeLinkRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRemoteNodeId.setDescription('This attribute indicates the id of the node at the far end of this link.')
mscARtgPnniTopNodeLinkRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 4, 2, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRemotePortId.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniTopNodeLinkRemotePortId.setDescription("This attribute indicates the node's port id at the far end of this link.")
mscARtgPnniPort = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5))
mscARtgPnniPortRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 1), )
if mibBuilder.loadTexts: mscARtgPnniPortRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscARtgPnniPort components.')
mscARtgPnniPortRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniPortIndex"))
if mibBuilder.loadTexts: mscARtgPnniPortRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortRowStatusEntry.setDescription('A single entry in the table represents a single mscARtgPnniPort component.')
mscARtgPnniPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscARtgPnniPort components. These components cannot be added nor deleted.')
mscARtgPnniPortComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniPortComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscARtgPnniPortStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniPortStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortStorageType.setDescription('This variable represents the storage type value for the mscARtgPnniPort tables.')
mscARtgPnniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435455)))
if mibBuilder.loadTexts: mscARtgPnniPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortIndex.setDescription('This variable represents the index for the mscARtgPnniPort tables.')
mscARtgPnniPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 10), )
if mibBuilder.loadTexts: mscARtgPnniPortOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of a Port component.')
mscARtgPnniPortOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscARtgPnniPortIndex"))
if mibBuilder.loadTexts: mscARtgPnniPortOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortOperEntry.setDescription('An entry in the mscARtgPnniPortOperTable.')
mscARtgPnniPortStdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 95, 3, 5, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscARtgPnniPortStdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscARtgPnniPortStdComponentName.setDescription('This attribute indicates the component name of the port.')
mscAtmCR = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113))
mscAtmCRRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 1), )
if mibBuilder.loadTexts: mscAtmCRRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmCR components.')
mscAtmCRRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmCRIndex"))
if mibBuilder.loadTexts: mscAtmCRRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmCR component.')
mscAtmCRRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmCRRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmCR components. These components can be added and deleted.')
mscAtmCRComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmCRComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmCRStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmCRStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRStorageType.setDescription('This variable represents the storage type value for the mscAtmCR tables.')
mscAtmCRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmCRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRIndex.setDescription('This variable represents the index for the mscAtmCR tables.')
mscAtmCRProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 10), )
if mibBuilder.loadTexts: mscAtmCRProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRProvTable.setDescription('This group represents the provisioned attributes for the AtmCallRouter component.')
mscAtmCRProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmCRIndex"))
if mibBuilder.loadTexts: mscAtmCRProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRProvEntry.setDescription('An entry in the mscAtmCRProvTable.')
mscAtmCRNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(26, 26)).setFixedLength(26)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmCRNodeAddress.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmCRNodeAddress.setDescription('This attribute specifies the NSAP address prefix used for ILMI purposes.')
mscAtmCRStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 11), )
if mibBuilder.loadTexts: mscAtmCRStatsTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmCRStatsTable.setDescription('This group represents the operational attributes for the AtmCallRouter component.')
mscAtmCRStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmCRIndex"))
if mibBuilder.loadTexts: mscAtmCRStatsEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmCRStatsEntry.setDescription('An entry in the mscAtmCRStatsTable.')
mscAtmCRCallsRouted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmCRCallsRouted.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmCRCallsRouted.setDescription('This attribute counts the total number of calls routed.')
mscAtmCRCallsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmCRCallsFailed.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmCRCallsFailed.setDescription('This attribute specifies the number of calls that failed to route.')
mscAtmCRDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2))
mscAtmCRDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 1), )
if mibBuilder.loadTexts: mscAtmCRDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRDnaRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscAtmCRDna components.')
mscAtmCRDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmCRIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmCRDnaIndex"))
if mibBuilder.loadTexts: mscAtmCRDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmCRDna component.')
mscAtmCRDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmCRDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmCRDna components. These components cannot be added nor deleted.')
mscAtmCRDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmCRDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmCRDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmCRDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRDnaStorageType.setDescription('This variable represents the storage type value for the mscAtmCRDna tables.')
mscAtmCRDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 40)))
if mibBuilder.loadTexts: mscAtmCRDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmCRDnaIndex.setDescription('This variable represents the index for the mscAtmCRDna tables.')
mscAtmCRDnaDestinationNameTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 289), )
if mibBuilder.loadTexts: mscAtmCRDnaDestinationNameTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmCRDnaDestinationNameTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates which components have this address provisioned or dynamically registered via ILMI.')
mscAtmCRDnaDestinationNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 289, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmCRIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmCRDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmCRDnaDestinationNameValue"))
if mibBuilder.loadTexts: mscAtmCRDnaDestinationNameEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmCRDnaDestinationNameEntry.setDescription('An entry in the mscAtmCRDnaDestinationNameTable.')
mscAtmCRDnaDestinationNameValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 113, 2, 289, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmCRDnaDestinationNameValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmCRDnaDestinationNameValue.setDescription('This variable represents both the value and the index for the mscAtmCRDnaDestinationNameTable.')
mscAtmIfVpcSrc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6))
mscAtmIfVpcSrcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcSrcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcSrc components.')
mscAtmIfVpcSrcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcSrcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcSrc component.')
mscAtmIfVpcSrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcSrcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcSrc components. These components can be added and deleted.')
mscAtmIfVpcSrcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcSrcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcSrcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcSrcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcSrc tables.')
mscAtmIfVpcSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcIndex.setDescription('This variable represents the index for the mscAtmIfVpcSrc tables.')
mscAtmIfVpcSrcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 10), )
if mibBuilder.loadTexts: mscAtmIfVpcSrcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcProvTable.setDescription('This attribute group contains the provisionable attributes of the AtmIf/n Vpc/vpi SrcPvp component.')
mscAtmIfVpcSrcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcSrcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcProvEntry.setDescription('An entry in the mscAtmIfVpcSrcProvTable.')
mscAtmIfVpcSrcCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcSrcCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcCallingAddress.setDescription('This attribute specifies the calling address of the soft PVP. If it is a null string, then the calling address is the address of the current interface (that is, where the soft PVC originates).')
mscAtmIfVpcSrcCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 10, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcSrcCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcCalledAddress.setDescription('This attribute specifies the called (remote) address of the soft PVP.')
mscAtmIfVpcSrcCalledVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcSrcCalledVpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcCalledVpi.setDescription('This attribute specifies the called VPI of the soft PVP.')
mscAtmIfVpcSrcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 11), )
if mibBuilder.loadTexts: mscAtmIfVpcSrcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcOperTable.setDescription('This attribute group contains the operational attributes associated with the SrcPvp or SrcPvc component.')
mscAtmIfVpcSrcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcSrcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcOperEntry.setDescription('An entry in the mscAtmIfVpcSrcOperTable.')
mscAtmIfVpcSrcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcSrcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcState.setDescription('This attribute indicates the state of the soft PVP or soft PVC.')
mscAtmIfVpcSrcRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcSrcRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcRetryCount.setDescription('This attribute indicates the number of failed attempts to set up the soft PVP or soft PVC since the last time the connection failed.')
mscAtmIfVpcSrcLastFailureCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcSrcLastFailureCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcLastFailureCauseCode.setDescription('This attribute contains the cause code in the last transmitted signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages. The default value for this attribute is set to 0.')
mscAtmIfVpcSrcLastFailureDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 6, 11, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcSrcLastFailureDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSrcLastFailureDiagCode.setDescription('This attribute contains the diagnostic code in the last transmitted signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to NULL.')
mscAtmIfVpcRp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7))
mscAtmIfVpcRpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcRpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcRp components.')
mscAtmIfVpcRpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcRpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcRpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcRp component.')
mscAtmIfVpcRpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcRp components. These components cannot be added nor deleted.')
mscAtmIfVpcRpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcRpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcRp tables.')
mscAtmIfVpcRpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcRpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpIndex.setDescription('This variable represents the index for the mscAtmIfVpcRp tables.')
mscAtmIfVpcRpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 10), )
if mibBuilder.loadTexts: mscAtmIfVpcRpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpOperTable.setDescription('This attribute group contains the operational attributes for the AtmRelayPoint component.')
mscAtmIfVpcRpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcRpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcRpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpOperEntry.setDescription('An entry in the mscAtmIfVpcRpOperTable.')
mscAtmIfVpcRpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRpNextHop.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRpNextHop.setDescription('This attribute indicates the component name of the Rp component with which this Rp component is associated.')
mscAtmIfVpcRpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 430), )
if mibBuilder.loadTexts: mscAtmIfVpcRpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpNextHopsTable.setDescription('This attribute indicates the component name(s) of the Rp component(s) with which this Rp component is associated. This attribute can have more than one component name only when the Vcc distributionType is pointToMultipoint and the callDirection is fromLink.')
mscAtmIfVpcRpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 430, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcRpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcRpNextHopsValue"))
if mibBuilder.loadTexts: mscAtmIfVpcRpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpNextHopsEntry.setDescription('An entry in the mscAtmIfVpcRpNextHopsTable.')
mscAtmIfVpcRpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 7, 430, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRpNextHopsValue.setDescription('This variable represents both the value and the index for the mscAtmIfVpcRpNextHopsTable.')
mscAtmIfVpcDst = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8))
mscAtmIfVpcDstRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcDstRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcDst components.')
mscAtmIfVpcDstRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcDstIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcDstRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcDst component.')
mscAtmIfVpcDstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcDstRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcDst components. These components cannot be added nor deleted.')
mscAtmIfVpcDstComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcDstComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcDstStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcDstStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcDst tables.')
mscAtmIfVpcDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstIndex.setDescription('This variable represents the index for the mscAtmIfVpcDst tables.')
mscAtmIfVpcDstOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 10), )
if mibBuilder.loadTexts: mscAtmIfVpcDstOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstOperTable.setDescription('This attribute group contains the operational attributes for the AtmIf/n Vpc/vpi DstPvp component.')
mscAtmIfVpcDstOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVpcDstIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcDstOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstOperEntry.setDescription('An entry in the mscAtmIfVpcDstOperTable.')
mscAtmIfVpcDstCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcDstCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstCalledAddress.setDescription('This attribute indicates the called address of the soft PVP.')
mscAtmIfVpcDstCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcDstCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstCallingAddress.setDescription('This attribute indicates the calling (remote) address of the soft PVP. If the address in not known, then the value of this address is Unknown.')
mscAtmIfVpcDstCallingVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 8, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcDstCallingVpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDstCallingVpi.setDescription('This attribute represents the calling (remote) VPI of the soft PVP. If the VPI value is not known, the attribute value is set to Unknown.')
mscAtmIfVccSrc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8))
mscAtmIfVccSrcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 1), )
if mibBuilder.loadTexts: mscAtmIfVccSrcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccSrc components.')
mscAtmIfVccSrcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVccSrcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccSrc component.')
mscAtmIfVccSrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccSrcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccSrc components. These components can be added and deleted.')
mscAtmIfVccSrcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccSrcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccSrcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccSrcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccSrc tables.')
mscAtmIfVccSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcIndex.setDescription('This variable represents the index for the mscAtmIfVccSrc tables.')
mscAtmIfVccSrcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 10), )
if mibBuilder.loadTexts: mscAtmIfVccSrcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcProvTable.setDescription('This attribute group contains the provisionable attributes of the SourcePvc component.')
mscAtmIfVccSrcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVccSrcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcProvEntry.setDescription('An entry in the mscAtmIfVccSrcProvTable.')
mscAtmIfVccSrcRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccSrcRemoteAddress.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccSrcRemoteAddress.setDescription('This attribute represents the remote address of the soft PVC.')
mscAtmIfVccSrcRemoteVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 10, 1, 2), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccSrcRemoteVpiVci.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccSrcRemoteVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC.')
mscAtmIfVccSrcCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccSrcCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcCallingAddress.setDescription('This attribute represents the calling address of the soft PVC. If it is a null string, then the calling address is the address of the current interface (that is, where the soft PVC originates).')
mscAtmIfVccSrcCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccSrcCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcCalledAddress.setDescription('This attribute represents the called (remote) address of the soft PVC.')
mscAtmIfVccSrcCalledVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 10, 1, 5), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccSrcCalledVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcCalledVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC.')
mscAtmIfVccSrcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 11), )
if mibBuilder.loadTexts: mscAtmIfVccSrcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcOperTable.setDescription('This attribute group contains the operational attributes associated with the SrcPvp or SrcPvc component.')
mscAtmIfVccSrcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVccSrcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcOperEntry.setDescription('An entry in the mscAtmIfVccSrcOperTable.')
mscAtmIfVccSrcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccSrcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcState.setDescription('This attribute indicates the state of the soft PVP or soft PVC.')
mscAtmIfVccSrcRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccSrcRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcRetryCount.setDescription('This attribute indicates the number of failed attempts to set up the soft PVP or soft PVC since the last time the connection failed.')
mscAtmIfVccSrcLastFailureCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccSrcLastFailureCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcLastFailureCauseCode.setDescription('This attribute contains the cause code in the last transmitted signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages. The default value for this attribute is set to 0.')
mscAtmIfVccSrcLastFailureDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 8, 11, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccSrcLastFailureDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSrcLastFailureDiagCode.setDescription('This attribute contains the diagnostic code in the last transmitted signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to NULL.')
mscAtmIfVccEp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9))
mscAtmIfVccEpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 1), )
if mibBuilder.loadTexts: mscAtmIfVccEpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccEp components.')
mscAtmIfVccEpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccEpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccEpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccEp component.')
mscAtmIfVccEpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccEpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccEp components. These components cannot be added nor deleted.')
mscAtmIfVccEpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccEpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccEpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccEpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccEp tables.')
mscAtmIfVccEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpIndex.setDescription('This variable represents the index for the mscAtmIfVccEp tables.')
mscAtmIfVccEpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 10), )
if mibBuilder.loadTexts: mscAtmIfVccEpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpOperTable.setDescription('This attribute group contains the operational attributes for the AtmEndPoint component.')
mscAtmIfVccEpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccEpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccEpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpOperEntry.setDescription('An entry in the mscAtmIfVccEpOperTable.')
mscAtmIfVccEpApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 9, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccEpApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEpApplicationName.setDescription('This attribute indicates the component name associated with the application associated with the switched VCC.')
mscAtmIfVccRp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10))
mscAtmIfVccRpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 1), )
if mibBuilder.loadTexts: mscAtmIfVccRpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccRp components.')
mscAtmIfVccRpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccRpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccRpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccRp component.')
mscAtmIfVccRpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccRp components. These components cannot be added nor deleted.')
mscAtmIfVccRpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccRpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccRp tables.')
mscAtmIfVccRpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccRpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpIndex.setDescription('This variable represents the index for the mscAtmIfVccRp tables.')
mscAtmIfVccRpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 10), )
if mibBuilder.loadTexts: mscAtmIfVccRpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpOperTable.setDescription('This attribute group contains the operational attributes for the AtmRelayPoint component.')
mscAtmIfVccRpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccRpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccRpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpOperEntry.setDescription('An entry in the mscAtmIfVccRpOperTable.')
mscAtmIfVccRpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRpNextHop.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRpNextHop.setDescription('This attribute indicates the component name of the Rp component with which this Rp component is associated.')
mscAtmIfVccRpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 430), )
if mibBuilder.loadTexts: mscAtmIfVccRpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpNextHopsTable.setDescription('This attribute indicates the component name(s) of the Rp component(s) with which this Rp component is associated. This attribute can have more than one component name only when the Vcc distributionType is pointToMultipoint and the callDirection is fromLink.')
mscAtmIfVccRpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 430, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccRpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccRpNextHopsValue"))
if mibBuilder.loadTexts: mscAtmIfVccRpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpNextHopsEntry.setDescription('An entry in the mscAtmIfVccRpNextHopsTable.')
mscAtmIfVccRpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 10, 430, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRpNextHopsValue.setDescription('This variable represents both the value and the index for the mscAtmIfVccRpNextHopsTable.')
mscAtmIfVccDst = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11))
mscAtmIfVccDstRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 1), )
if mibBuilder.loadTexts: mscAtmIfVccDstRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccDst components.')
mscAtmIfVccDstRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccDstIndex"))
if mibBuilder.loadTexts: mscAtmIfVccDstRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccDst component.')
mscAtmIfVccDstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccDstRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccDst components. These components cannot be added nor deleted.')
mscAtmIfVccDstComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccDstComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccDstStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccDstStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccDst tables.')
mscAtmIfVccDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstIndex.setDescription('This variable represents the index for the mscAtmIfVccDst tables.')
mscAtmIfVccDstOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 10), )
if mibBuilder.loadTexts: mscAtmIfVccDstOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstOperTable.setDescription('This attribute group contains the operational attributes for the DestinationPvc component.')
mscAtmIfVccDstOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVccDstIndex"))
if mibBuilder.loadTexts: mscAtmIfVccDstOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstOperEntry.setDescription('An entry in the mscAtmIfVccDstOperTable.')
mscAtmIfVccDstCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccDstCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstCalledAddress.setDescription('This attribute represents the called address of the soft PVC.')
mscAtmIfVccDstCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 10, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccDstCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstCallingAddress.setDescription('This attribute represents the remote address of the soft PVC. If the address in not known, then the value of this address is Unknown.')
mscAtmIfVccDstCallingVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 11, 10, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccDstCallingVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDstCallingVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC. If the VPI and VCI values are not known, this attribute is set to Unknown.')
mscAtmIfVptVccSrc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8))
mscAtmIfVptVccSrcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccSrc components.')
mscAtmIfVptVccSrcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccSrc component.')
mscAtmIfVptVccSrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccSrc components. These components can be added and deleted.')
mscAtmIfVptVccSrcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccSrcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccSrc tables.')
mscAtmIfVptVccSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcIndex.setDescription('This variable represents the index for the mscAtmIfVptVccSrc tables.')
mscAtmIfVptVccSrcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 10), )
if mibBuilder.loadTexts: mscAtmIfVptVccSrcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcProvTable.setDescription('This attribute group contains the provisionable attributes of the SourcePvc component.')
mscAtmIfVptVccSrcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccSrcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcProvEntry.setDescription('An entry in the mscAtmIfVptVccSrcProvTable.')
mscAtmIfVptVccSrcRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRemoteAddress.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRemoteAddress.setDescription('This attribute represents the remote address of the soft PVC.')
mscAtmIfVptVccSrcRemoteVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 10, 1, 2), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRemoteVpiVci.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRemoteVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC.')
mscAtmIfVptVccSrcCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcCallingAddress.setDescription('This attribute represents the calling address of the soft PVC. If it is a null string, then the calling address is the address of the current interface (that is, where the soft PVC originates).')
mscAtmIfVptVccSrcCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcCalledAddress.setDescription('This attribute represents the called (remote) address of the soft PVC.')
mscAtmIfVptVccSrcCalledVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 10, 1, 5), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcCalledVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcCalledVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC.')
mscAtmIfVptVccSrcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 11), )
if mibBuilder.loadTexts: mscAtmIfVptVccSrcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcOperTable.setDescription('This attribute group contains the operational attributes associated with the SrcPvp or SrcPvc component.')
mscAtmIfVptVccSrcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccSrcIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccSrcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcOperEntry.setDescription('An entry in the mscAtmIfVptVccSrcOperTable.')
mscAtmIfVptVccSrcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcState.setDescription('This attribute indicates the state of the soft PVP or soft PVC.')
mscAtmIfVptVccSrcRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcRetryCount.setDescription('This attribute indicates the number of failed attempts to set up the soft PVP or soft PVC since the last time the connection failed.')
mscAtmIfVptVccSrcLastFailureCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcLastFailureCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcLastFailureCauseCode.setDescription('This attribute contains the cause code in the last transmitted signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages. The default value for this attribute is set to 0.')
mscAtmIfVptVccSrcLastFailureDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 8, 11, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccSrcLastFailureDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSrcLastFailureDiagCode.setDescription('This attribute contains the diagnostic code in the last transmitted signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to NULL.')
mscAtmIfVptVccEp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9))
mscAtmIfVptVccEpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccEpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccEp components.')
mscAtmIfVptVccEpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccEpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccEpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccEp component.')
mscAtmIfVptVccEpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccEpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccEp components. These components cannot be added nor deleted.')
mscAtmIfVptVccEpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccEpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccEpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccEpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccEp tables.')
mscAtmIfVptVccEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpIndex.setDescription('This variable represents the index for the mscAtmIfVptVccEp tables.')
mscAtmIfVptVccEpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 10), )
if mibBuilder.loadTexts: mscAtmIfVptVccEpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpOperTable.setDescription('This attribute group contains the operational attributes for the AtmEndPoint component.')
mscAtmIfVptVccEpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccEpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccEpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpOperEntry.setDescription('An entry in the mscAtmIfVptVccEpOperTable.')
mscAtmIfVptVccEpApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 9, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccEpApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEpApplicationName.setDescription('This attribute indicates the component name associated with the application associated with the switched VCC.')
mscAtmIfVptVccRp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10))
mscAtmIfVptVccRpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccRpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccRp components.')
mscAtmIfVptVccRpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccRpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccRpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccRp component.')
mscAtmIfVptVccRpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccRp components. These components cannot be added nor deleted.')
mscAtmIfVptVccRpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccRpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccRp tables.')
mscAtmIfVptVccRpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccRpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpIndex.setDescription('This variable represents the index for the mscAtmIfVptVccRp tables.')
mscAtmIfVptVccRpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 10), )
if mibBuilder.loadTexts: mscAtmIfVptVccRpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpOperTable.setDescription('This attribute group contains the operational attributes for the AtmRelayPoint component.')
mscAtmIfVptVccRpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccRpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccRpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpOperEntry.setDescription('An entry in the mscAtmIfVptVccRpOperTable.')
mscAtmIfVptVccRpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRpNextHop.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRpNextHop.setDescription('This attribute indicates the component name of the Rp component with which this Rp component is associated.')
mscAtmIfVptVccRpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 430), )
if mibBuilder.loadTexts: mscAtmIfVptVccRpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpNextHopsTable.setDescription('This attribute indicates the component name(s) of the Rp component(s) with which this Rp component is associated. This attribute can have more than one component name only when the Vcc distributionType is pointToMultipoint and the callDirection is fromLink.')
mscAtmIfVptVccRpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 430, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccRpIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccRpNextHopsValue"))
if mibBuilder.loadTexts: mscAtmIfVptVccRpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpNextHopsEntry.setDescription('An entry in the mscAtmIfVptVccRpNextHopsTable.')
mscAtmIfVptVccRpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 10, 430, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRpNextHopsValue.setDescription('This variable represents both the value and the index for the mscAtmIfVptVccRpNextHopsTable.')
mscAtmIfVptVccDst = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11))
mscAtmIfVptVccDstRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccDstRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccDst components.')
mscAtmIfVptVccDstRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccDstIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccDstRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccDst component.')
mscAtmIfVptVccDstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccDstRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccDst components. These components cannot be added nor deleted.')
mscAtmIfVptVccDstComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccDstComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccDstStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccDstStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccDst tables.')
mscAtmIfVptVccDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstIndex.setDescription('This variable represents the index for the mscAtmIfVptVccDst tables.')
mscAtmIfVptVccDstOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 10), )
if mibBuilder.loadTexts: mscAtmIfVptVccDstOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstOperTable.setDescription('This attribute group contains the operational attributes for the DestinationPvc component.')
mscAtmIfVptVccDstOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", "mscAtmIfVptVccDstIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccDstOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstOperEntry.setDescription('An entry in the mscAtmIfVptVccDstOperTable.')
mscAtmIfVptVccDstCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccDstCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstCalledAddress.setDescription('This attribute represents the called address of the soft PVC.')
mscAtmIfVptVccDstCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 10, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccDstCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstCallingAddress.setDescription('This attribute represents the remote address of the soft PVC. If the address in not known, then the value of this address is Unknown.')
mscAtmIfVptVccDstCallingVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 11, 10, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccDstCallingVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDstCallingVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC. If the VPI and VCI values are not known, this attribute is set to Unknown.')
atmNetworkingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42, 1))
atmNetworkingGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42, 1, 1))
atmNetworkingGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42, 1, 1, 3))
atmNetworkingGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42, 1, 1, 3, 2))
atmNetworkingCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42, 3))
atmNetworkingCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42, 3, 1))
atmNetworkingCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42, 3, 1, 3))
atmNetworkingCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 42, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", mscARtgPnniThreshParmsTable=mscARtgPnniThreshParmsTable, mscARtgPnniCfgNodeNbrStatsEntry=mscARtgPnniCfgNodeNbrStatsEntry, mscARtgPnniCfgNodeDefSAddrIndex=mscARtgPnniCfgNodeDefSAddrIndex, mscARtgDnaDestInfoRowStatusEntry=mscARtgDnaDestInfoRowStatusEntry, mscARtgPnniPtseLifetimeFactor=mscARtgPnniPtseLifetimeFactor, mscARtgPnniCfgNodeDefSAddrAddress=mscARtgPnniCfgNodeDefSAddrAddress, atmNetworkingGroupCA02=atmNetworkingGroupCA02, atmNetworkingCapabilitiesCA02=atmNetworkingCapabilitiesCA02, mscARtgPnniRfFqpIndex=mscARtgPnniRfFqpIndex, mscARtgPnniCfgNodeDefSAddrOperTable=mscARtgPnniCfgNodeDefSAddrOperTable, mscARtgPnniPglInitTime=mscARtgPnniPglInitTime, mscARtgPnniCfgNodeSAddrPrefixLengthIndex=mscARtgPnniCfgNodeSAddrPrefixLengthIndex, mscAtmIfVptVccRpComponentName=mscAtmIfVptVccRpComponentName, mscAtmIfVccDstOperTable=mscAtmIfVccDstOperTable, mscARtgPnniRfBqpEntry=mscARtgPnniRfBqpEntry, mscARtgPnniCfgNodeNbrPtseTx=mscARtgPnniCfgNodeNbrPtseTx, mscARtgPnniTopNodeRowStatusTable=mscARtgPnniTopNodeRowStatusTable, mscARtgPnniDomain=mscARtgPnniDomain, mscAtmIfVptVccSrcComponentName=mscAtmIfVptVccSrcComponentName, mscARtgPnniRowStatus=mscARtgPnniRowStatus, mscARtgPnniTopIndex=mscARtgPnniTopIndex, mscARtgPnniRfTxTdpTable=mscARtgPnniRfTxTdpTable, mscARtgPnniCfgNodeSAddrRowStatusTable=mscARtgPnniCfgNodeSAddrRowStatusTable, mscAtmIfVccEpStorageType=mscAtmIfVccEpStorageType, mscAtmIfVpcSrcLastFailureDiagCode=mscAtmIfVpcSrcLastFailureDiagCode, mscARtgPnniCfgNodeDefSAddrStorageType=mscARtgPnniCfgNodeDefSAddrStorageType, mscAtmCRCallsRouted=mscAtmCRCallsRouted, mscARtgPnniRfFqpValue=mscARtgPnniRfFqpValue, mscARtgPnniSuccessfulRoutingAttempts=mscARtgPnniSuccessfulRoutingAttempts, mscAtmIfVptVccEpIndex=mscAtmIfVptVccEpIndex, mscARtgPnniReElectionInterval=mscARtgPnniReElectionInterval, mscARtgPnniCfgNodeDefSAddrRowStatus=mscARtgPnniCfgNodeDefSAddrRowStatus, mscARtgStorageType=mscARtgStorageType, mscARtgPnniCfgNodeNbrIndex=mscARtgPnniCfgNodeNbrIndex, mscARtgPnniCfgNodeNbrBadPtseAckRx=mscARtgPnniCfgNodeNbrBadPtseAckRx, mscAtmIfVccSrcProvEntry=mscAtmIfVccSrcProvEntry, mscARtgPnniTopologyMemoryExhaustion=mscARtgPnniTopologyMemoryExhaustion, mscAtmIfVptVccSrcCallingAddress=mscAtmIfVptVccSrcCallingAddress, mscAtmIfVptVccSrcStorageType=mscAtmIfVptVccSrcStorageType, mscARtgPnniHelloInterval=mscARtgPnniHelloInterval, mscAtmIfVccDstComponentName=mscAtmIfVccDstComponentName, mscARtgPnniPtseParmsTable=mscARtgPnniPtseParmsTable, mscAtmIfVpcSrcComponentName=mscAtmIfVpcSrcComponentName, mscAtmIfVptVccSrcRetryCount=mscAtmIfVptVccSrcRetryCount, mscAtmIfVptVccSrcRemoteVpiVci=mscAtmIfVptVccSrcRemoteVpiVci, mscAtmCRRowStatusEntry=mscAtmCRRowStatusEntry, mscARtgPnniIndex=mscARtgPnniIndex, mscAtmCRDnaStorageType=mscAtmCRDnaStorageType, mscARtgPnniTopNodeLinkRowStatusEntry=mscARtgPnniTopNodeLinkRowStatusEntry, mscAtmIfVptVccRpRowStatus=mscAtmIfVptVccRpRowStatus, mscAtmIfVptVccEp=mscAtmIfVptVccEp, mscAtmIfVptVccRpNextHop=mscAtmIfVptVccRpNextHop, mscAtmIfVccRpNextHop=mscAtmIfVccRpNextHop, mscAtmIfVpcDst=mscAtmIfVpcDst, mscARtgPnniTopNodeLinkComponentName=mscARtgPnniTopNodeLinkComponentName, mscAtmCRProvEntry=mscAtmCRProvEntry, mscARtgDnaDestInfoOperTable=mscARtgDnaDestInfoOperTable, mscARtgPnniThreshParmsEntry=mscARtgPnniThreshParmsEntry, mscARtgPnniCfgNodeNbr=mscARtgPnniCfgNodeNbr, mscARtgPnniHlParmsEntry=mscARtgPnniHlParmsEntry, mscAtmIfVccRpComponentName=mscAtmIfVccRpComponentName, mscARtgPnniCfgNodeDefSAddr=mscARtgPnniCfgNodeDefSAddr, mscAtmIfVptVccSrcProvTable=mscAtmIfVptVccSrcProvTable, mscARtgPnniDefaultScope=mscARtgPnniDefaultScope, mscARtgPnniTopComponentName=mscARtgPnniTopComponentName, mscAtmIfVccSrcStorageType=mscAtmIfVccSrcStorageType, mscARtgPnniCfgNodeNumRccs=mscARtgPnniCfgNodeNumRccs, mscAtmIfVptVccEpRowStatusTable=mscAtmIfVptVccEpRowStatusTable, mscARtgPnniRfRxTdpIndex=mscARtgPnniRfRxTdpIndex, mscAtmIfVpcRp=mscAtmIfVpcRp, mscARtgPnniNodeAddressPrefix=mscARtgPnniNodeAddressPrefix, mscAtmIfVpcRpRowStatus=mscAtmIfVpcRpRowStatus, mscAtmIfVptVccDstCalledAddress=mscAtmIfVptVccDstCalledAddress, mscAtmIfVccDstCallingAddress=mscAtmIfVccDstCallingAddress, mscARtgPnniCfgNodeSAddrRowStatusEntry=mscARtgPnniCfgNodeSAddrRowStatusEntry, mscARtgPnniRfTxTrafficDescType=mscARtgPnniRfTxTrafficDescType, mscAtmIfVptVccEpStorageType=mscAtmIfVptVccEpStorageType, mscARtgPnniAvcrPm=mscARtgPnniAvcrPm, mscAtmIfVpcSrcRowStatusTable=mscAtmIfVpcSrcRowStatusTable, mscAtmIfVpcSrcStorageType=mscAtmIfVpcSrcStorageType, mscARtgPnniCfgNodeSAddrScope=mscARtgPnniCfgNodeSAddrScope, mscAtmIfVccSrcCalledAddress=mscAtmIfVccSrcCalledAddress, mscAtmIfVpcDstRowStatusTable=mscAtmIfVpcDstRowStatusTable, mscAtmIfVpcDstIndex=mscAtmIfVpcDstIndex, mscARtgPnniCfgNodeNbrPtseRx=mscARtgPnniCfgNodeNbrPtseRx, atmNetworkingGroupCA=atmNetworkingGroupCA, mscARtgPnniTopNodeComponentName=mscARtgPnniTopNodeComponentName, atmNetworkingMIB=atmNetworkingMIB, mscARtgPnniCfgNodeNodeId=mscARtgPnniCfgNodeNodeId, mscAtmCRStatsEntry=mscAtmCRStatsEntry, mscAtmIfVccSrcState=mscAtmIfVccSrcState, mscARtgPnniCfgNodeSAddrSuppress=mscARtgPnniCfgNodeSAddrSuppress, mscAtmIfVccDstIndex=mscAtmIfVccDstIndex, mscAtmIfVccRp=mscAtmIfVccRp, mscAtmIfVccRpStorageType=mscAtmIfVccRpStorageType, mscARtgPnniOperEntry=mscARtgPnniOperEntry, mscARtgPnniRfRowStatusTable=mscARtgPnniRfRowStatusTable, mscARtgDnaRowStatus=mscARtgDnaRowStatus, mscARtgPnni=mscARtgPnni, mscARtgPnniTopNodeRowStatus=mscARtgPnniTopNodeRowStatus, mscAtmIfVccSrcProvTable=mscAtmIfVccSrcProvTable, mscARtgPnniStatsEntry=mscARtgPnniStatsEntry, mscAtmIfVptVccSrcOperTable=mscAtmIfVptVccSrcOperTable, mscAtmIfVptVccEpOperTable=mscAtmIfVptVccEpOperTable, mscAtmCRDnaDestinationNameValue=mscAtmCRDnaDestinationNameValue, mscAtmIfVpcRpNextHopsTable=mscAtmIfVpcRpNextHopsTable, mscAtmIfVptVccDstStorageType=mscAtmIfVptVccDstStorageType, mscAtmIfVpcRpStorageType=mscAtmIfVpcRpStorageType, mscARtgPnniTopStorageType=mscARtgPnniTopStorageType, mscAtmCRDnaDestinationNameTable=mscAtmCRDnaDestinationNameTable, mscARtgPnniRfFqpEntry=mscARtgPnniRfFqpEntry, mscAtmIfVptVccSrcRemoteAddress=mscAtmIfVptVccSrcRemoteAddress, mscARtgDnaDestInfoRowStatus=mscARtgDnaDestInfoRowStatus, mscAtmIfVccRpIndex=mscAtmIfVccRpIndex, mscAtmIfVptVccDstRowStatus=mscAtmIfVptVccDstRowStatus, mscARtgPnniCfgNodeDefSAddrOperEntry=mscARtgPnniCfgNodeDefSAddrOperEntry, mscAtmIfVccSrcOperEntry=mscAtmIfVccSrcOperEntry, mscARtgPnniCfgNodeComponentName=mscARtgPnniCfgNodeComponentName, mscAtmIfVptVccDst=mscAtmIfVptVccDst, mscAtmIfVptVccSrcRowStatus=mscAtmIfVptVccSrcRowStatus, mscARtgPnniPortComponentName=mscARtgPnniPortComponentName, mscARtgPnniHelloInactivityFactor=mscARtgPnniHelloInactivityFactor, mscAtmIfVpcSrcRetryCount=mscAtmIfVpcSrcRetryCount, mscAtmIfVccDstStorageType=mscAtmIfVccDstStorageType, mscARtgPnniCfgNodeOpNodeId=mscARtgPnniCfgNodeOpNodeId, mscARtgPnniRfBestEffort=mscARtgPnniRfBestEffort, mscARtgDnaDestInfoReachability=mscARtgDnaDestInfoReachability, mscARtgPnniRfCriteriaTable=mscARtgPnniRfCriteriaTable, mscARtgPnniRequestRxmtInterval=mscARtgPnniRequestRxmtInterval, mscARtg=mscARtg, mscARtgPnniCfgNodeNbrRowStatusEntry=mscARtgPnniCfgNodeNbrRowStatusEntry, mscARtgPnniHlParmsTable=mscARtgPnniHlParmsTable, mscAtmIfVccRpRowStatusEntry=mscAtmIfVccRpRowStatusEntry, mscARtgPnniRfClippingBbc=mscARtgPnniRfClippingBbc, mscARtgDnaDestInfoIndex=mscARtgDnaDestInfoIndex, mscAtmIfVptVccDstCallingAddress=mscAtmIfVptVccDstCallingAddress, mscARtgDnaDestInfoOperEntry=mscARtgDnaDestInfoOperEntry, mscARtgPnniAlternateRoutingAttempts=mscARtgPnniAlternateRoutingAttempts, mscARtgPnniCfgNodeNbrPtspTx=mscARtgPnniCfgNodeNbrPtspTx, mscARtgPnniFailedRoutingAttempts=mscARtgPnniFailedRoutingAttempts, mscAtmIfVptVccDstCallingVpiVci=mscAtmIfVptVccDstCallingVpiVci, mscARtgPnniCfgNodeStorageType=mscARtgPnniCfgNodeStorageType, mscARtgPnniRfAtmServiceCategory=mscARtgPnniRfAtmServiceCategory, mscAtmIfVccEpIndex=mscAtmIfVccEpIndex, mscAtmIfVccSrcRowStatus=mscAtmIfVccSrcRowStatus, mscARtgPnniCfgNodeNbrRccListValue=mscARtgPnniCfgNodeNbrRccListValue, mscARtgPnniCfgNodeProvTable=mscARtgPnniCfgNodeProvTable, mscAtmIfVptVccRpNextHopsValue=mscAtmIfVptVccRpNextHopsValue, mscAtmIfVpcSrcRowStatusEntry=mscAtmIfVpcSrcRowStatusEntry, mscARtgPnniTopNodeAddrAddressIndex=mscARtgPnniTopNodeAddrAddressIndex, mscAtmIfVccSrcRemoteAddress=mscAtmIfVccSrcRemoteAddress, mscARtgPnniTopOperTable=mscARtgPnniTopOperTable, mscAtmIfVccSrcLastFailureCauseCode=mscAtmIfVccSrcLastFailureCauseCode, mscARtgPnniRfTxTdpIndex=mscARtgPnniRfTxTdpIndex, mscARtgPnniCfgNodeIndex=mscARtgPnniCfgNodeIndex, mscAtmIfVptVccDstIndex=mscAtmIfVptVccDstIndex, mscAtmIfVpcSrcIndex=mscAtmIfVpcSrcIndex, mscARtgPnniCfgNodeNbrDbSummariesTx=mscARtgPnniCfgNodeNbrDbSummariesTx, mscARtgPnniCfgNodeSAddrComponentName=mscARtgPnniCfgNodeSAddrComponentName, mscARtgPnniRfFwdQosClass=mscARtgPnniRfFwdQosClass, mscAtmCRStatsTable=mscAtmCRStatsTable, mscAtmIfVpcRpRowStatusEntry=mscAtmIfVpcRpRowStatusEntry, mscARtgDnaDestInfo=mscARtgDnaDestInfo, mscARtgPnniCfgNodeNbrPtspRx=mscARtgPnniCfgNodeNbrPtspRx, mscAtmIfVccEp=mscAtmIfVccEp, mscAtmIfVptVccDstOperEntry=mscAtmIfVptVccDstOperEntry, mscARtgPnniTop=mscARtgPnniTop, mscAtmIfVpcSrcLastFailureCauseCode=mscAtmIfVpcSrcLastFailureCauseCode, mscARtgRowStatusTable=mscARtgRowStatusTable, mscAtmIfVptVccSrcCalledVpiVci=mscAtmIfVptVccSrcCalledVpiVci, mscAtmIfVptVccRpStorageType=mscAtmIfVptVccRpStorageType, mscARtgPnniCfgNodeNbrOperTable=mscARtgPnniCfgNodeNbrOperTable, mscARtgPnniTopNodeLinkOperEntry=mscARtgPnniTopNodeLinkOperEntry, mscAtmIfVpcRpOperTable=mscAtmIfVpcRpOperTable, mscAtmIfVccEpRowStatusEntry=mscAtmIfVccEpRowStatusEntry, mscARtgPnniTopNodeAddrScope=mscARtgPnniTopNodeAddrScope, mscAtmIfVpcRpOperEntry=mscAtmIfVpcRpOperEntry, mscARtgPnniRfDestinationAddress=mscARtgPnniRfDestinationAddress, mscARtgPnniCfgNodeNbrRowStatus=mscARtgPnniCfgNodeNbrRowStatus, mscARtgPnniTopNodeAddrRowStatus=mscARtgPnniTopNodeAddrRowStatus, mscARtgPnniCfgNodeRowStatus=mscARtgPnniCfgNodeRowStatus, mscARtgPnniCfgNodeDefSAddrRowStatusEntry=mscARtgPnniCfgNodeDefSAddrRowStatusEntry, mscARtgPnniCfgNodeDefSAddrDefAddrEntry=mscARtgPnniCfgNodeDefSAddrDefAddrEntry, mscAtmIfVptVccSrcOperEntry=mscAtmIfVptVccSrcOperEntry, mscAtmIfVpcSrcOperEntry=mscAtmIfVpcSrcOperEntry, mscARtgDnaDestInfoType=mscARtgDnaDestInfoType, mscARtgPnniPortRowStatus=mscARtgPnniPortRowStatus, mscARtgStatsTable=mscARtgStatsTable, mscAtmIfVptVccSrcLastFailureCauseCode=mscAtmIfVptVccSrcLastFailureCauseCode, mscAtmIfVptVccRpNextHopsEntry=mscAtmIfVptVccRpNextHopsEntry, mscAtmIfVptVccDstRowStatusTable=mscAtmIfVptVccDstRowStatusTable, mscARtgPnniRfBqpTable=mscARtgPnniRfBqpTable, mscARtgPnniRowStatusEntry=mscARtgPnniRowStatusEntry, mscARtgPnniOverrideDelay=mscARtgPnniOverrideDelay, mscARtgPnniRfIndex=mscARtgPnniRfIndex, mscAtmIfVccDstCallingVpiVci=mscAtmIfVccDstCallingVpiVci, mscARtgPnniCfgNodeNbrComponentName=mscARtgPnniCfgNodeNbrComponentName, mscAtmIfVccRpNextHopsEntry=mscAtmIfVccRpNextHopsEntry, mscARtgPnniPortRowStatusEntry=mscARtgPnniPortRowStatusEntry, mscARtgPnniStorageType=mscARtgPnniStorageType, mscAtmIfVptVccRpOperEntry=mscAtmIfVptVccRpOperEntry, mscARtgPnniTopNodeLinkRowStatus=mscARtgPnniTopNodeLinkRowStatus, mscARtgPnniRfTxTdpEntry=mscARtgPnniRfTxTdpEntry, mscARtgPnniCfgNodeOperEntry=mscARtgPnniCfgNodeOperEntry, mscARtgPnniCfgNodeSAddrState=mscARtgPnniCfgNodeSAddrState, mscARtgPnniCfgNodeSAddrProvEntry=mscARtgPnniCfgNodeSAddrProvEntry, mscARtgRowStatusEntry=mscARtgRowStatusEntry, mscARtgPnniRfRxTdpEntry=mscARtgPnniRfRxTdpEntry, mscAtmIfVccSrcIndex=mscAtmIfVccSrcIndex, mscARtgDnaDestInfoComponentName=mscARtgDnaDestInfoComponentName, mscAtmIfVptVccSrcState=mscAtmIfVptVccSrcState, mscAtmIfVccDstRowStatus=mscAtmIfVccDstRowStatus, mscARtgPnniProvTable=mscARtgPnniProvTable, mscARtgPnniRf=mscARtgPnniRf, mscAtmIfVccSrc=mscAtmIfVccSrc, mscARtgPnniCfgNodeCurrentLeadershipPriority=mscARtgPnniCfgNodeCurrentLeadershipPriority, mscARtgPnniPortStorageType=mscARtgPnniPortStorageType, mscAtmIfVccDstRowStatusEntry=mscAtmIfVccDstRowStatusEntry, mscARtgPnniCfgNodeNbrRowStatusTable=mscARtgPnniCfgNodeNbrRowStatusTable, mscARtgPnniRfBearerClassBbc=mscARtgPnniRfBearerClassBbc, mscARtgPnniCfgNodeNbrBadPtseReqRx=mscARtgPnniCfgNodeNbrBadPtseReqRx, mscAtmIfVpcDstOperTable=mscAtmIfVpcDstOperTable, mscAtmIfVptVccSrcProvEntry=mscAtmIfVptVccSrcProvEntry, mscARtgDnaDestInfoRowStatusTable=mscARtgDnaDestInfoRowStatusTable, mscARtgPnniRfRowStatusEntry=mscARtgPnniRfRowStatusEntry, mscAtmIfVpcSrcCalledVpi=mscAtmIfVpcSrcCalledVpi, mscAtmCRNodeAddress=mscAtmCRNodeAddress, mscAtmCRDna=mscAtmCRDna, mscAtmCRProvTable=mscAtmCRProvTable, mscARtgPnniCfgNodeSAddrRowStatus=mscARtgPnniCfgNodeSAddrRowStatus, mscAtmCRDnaRowStatusTable=mscAtmCRDnaRowStatusTable, mscARtgPnniRfRowStatus=mscARtgPnniRfRowStatus, mscAtmCRComponentName=mscAtmCRComponentName, mscAtmIfVccSrcRowStatusTable=mscAtmIfVccSrcRowStatusTable, mscAtmIfVptVccSrcRowStatusTable=mscAtmIfVptVccSrcRowStatusTable, mscARtgPnniCfgNodeDefSAddrRowStatusTable=mscARtgPnniCfgNodeDefSAddrRowStatusTable, mscARtgPnniTopNode=mscARtgPnniTopNode, mscARtgPnniPort=mscARtgPnniPort, mscAtmIfVpcSrcProvTable=mscAtmIfVpcSrcProvTable, mscARtgPnniTopNodeLinkIndex=mscARtgPnniTopNodeLinkIndex, mscARtgPnniOperTable=mscARtgPnniOperTable, mscARtgPnniPortIndex=mscARtgPnniPortIndex, mscAtmIfVptVccDstComponentName=mscAtmIfVptVccDstComponentName, mscAtmIfVccSrcRemoteVpiVci=mscAtmIfVccSrcRemoteVpiVci, mscARtgPnniTopPtsesInDatabase=mscARtgPnniTopPtsesInDatabase, mscAtmIfVccRpRowStatusTable=mscAtmIfVccRpRowStatusTable, mscARtgPnniRfOptimizationMetric=mscARtgPnniRfOptimizationMetric, mscAtmIfVpcSrcOperTable=mscAtmIfVpcSrcOperTable, mscARtgPnniTopNodeLinkOperTable=mscARtgPnniTopNodeLinkOperTable, mscAtmCRRowStatusTable=mscAtmCRRowStatusTable, mscARtgPnniCfgNodeDefSAddrDefAddrTable=mscARtgPnniCfgNodeDefSAddrDefAddrTable, mscAtmIfVpcDstStorageType=mscAtmIfVpcDstStorageType, mscARtgPnniTopNodeLinkRemoteNodeId=mscARtgPnniTopNodeLinkRemoteNodeId, mscARtgPnniCfgNodeOperTable=mscARtgPnniCfgNodeOperTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmNetworkingMIB", mscARtgPnniPglParmsEntry=mscARtgPnniPglParmsEntry, mscAtmIfVccSrcOperTable=mscAtmIfVccSrcOperTable, mscARtgPnniCfgNodeDefSAddrComponentName=mscARtgPnniCfgNodeDefSAddrComponentName, mscARtgPnniTopNodeAddrReachabilityIndex=mscARtgPnniTopNodeAddrReachabilityIndex, mscARtgPnniRfCriteriaEntry=mscARtgPnniRfCriteriaEntry, mscARtgPnniPeerDelayedAckInterval=mscARtgPnniPeerDelayedAckInterval, mscAtmIfVpcSrcRowStatus=mscAtmIfVpcSrcRowStatus, mscAtmIfVccDst=mscAtmIfVccDst, mscARtgPnniTopRowStatusEntry=mscARtgPnniTopRowStatusEntry, mscARtgPnniRfFqpTable=mscARtgPnniRfFqpTable, mscARtgPnniPortOperTable=mscARtgPnniPortOperTable, mscARtgPnniComponentName=mscARtgPnniComponentName, mscAtmIfVccSrcCalledVpiVci=mscAtmIfVccSrcCalledVpiVci, mscAtmIfVccSrcRowStatusEntry=mscAtmIfVccSrcRowStatusEntry, mscAtmIfVpcRpIndex=mscAtmIfVpcRpIndex, mscARtgPnniTopNodeLinkRemotePortId=mscARtgPnniTopNodeLinkRemotePortId, mscARtgPnniCfgNodeNbrBadPtspRx=mscARtgPnniCfgNodeNbrBadPtspRx, mscAtmIfVptVccRpRowStatusEntry=mscAtmIfVptVccRpRowStatusEntry, mscAtmIfVpcDstCallingAddress=mscAtmIfVpcDstCallingAddress, mscARtgPnniPglParmsTable=mscARtgPnniPglParmsTable, mscARtgPnniPortStdComponentName=mscARtgPnniPortStdComponentName, atmNetworkingGroup=atmNetworkingGroup, mscARtgDnaStorageType=mscARtgDnaStorageType, mscARtgDnaDestInfoStdComponentName=mscARtgDnaDestInfoStdComponentName, mscAtmCRCallsFailed=mscAtmCRCallsFailed, mscARtgRoutingAttempts=mscARtgRoutingAttempts, mscAtmIfVptVccDstOperTable=mscAtmIfVptVccDstOperTable, mscARtgPnniMaxAlternateRoutesOnCrankback=mscARtgPnniMaxAlternateRoutesOnCrankback, mscAtmIfVptVccSrcIndex=mscAtmIfVptVccSrcIndex, mscAtmIfVptVccRpRowStatusTable=mscAtmIfVptVccRpRowStatusTable, mscARtgPnniRfBqpIndex=mscARtgPnniRfBqpIndex, mscAtmIfVpcDstRowStatus=mscAtmIfVpcDstRowStatus, mscARtgPnniProvEntry=mscARtgPnniProvEntry, mscARtgPnniCfgNodeNbrPtseAcksRx=mscARtgPnniCfgNodeNbrPtseAcksRx, mscAtmIfVccRpNextHopsValue=mscAtmIfVccRpNextHopsValue, mscAtmIfVptVccRpNextHopsTable=mscAtmIfVptVccRpNextHopsTable, mscARtgPnniTopActiveParentNodeId=mscARtgPnniTopActiveParentNodeId, mscAtmIfVptVccEpRowStatusEntry=mscAtmIfVptVccEpRowStatusEntry, mscAtmIfVptVccEpApplicationName=mscAtmIfVptVccEpApplicationName, mscAtmIfVpcRpNextHopsValue=mscAtmIfVpcRpNextHopsValue, mscARtgPnniCfgNodeNbrRccListTable=mscARtgPnniCfgNodeNbrRccListTable, mscAtmIfVpcRpNextHop=mscAtmIfVpcRpNextHop, mscARtgPnniCfgNodeNbrPtseAcksTx=mscARtgPnniCfgNodeNbrPtseAcksTx, mscARtgPnniTopRowStatusTable=mscARtgPnniTopRowStatusTable, mscARtgPnniCfgNodeNbrStatsTable=mscARtgPnniCfgNodeNbrStatsTable, mscARtgPnniRestrictTransit=mscARtgPnniRestrictTransit, mscARtgPnniOptMetricTable=mscARtgPnniOptMetricTable, mscARtgPnniCfgNodeDefSAddrState=mscARtgPnniCfgNodeDefSAddrState, mscAtmIfVptVccSrcRowStatusEntry=mscAtmIfVptVccSrcRowStatusEntry, mscARtgIndex=mscARtgIndex, mscARtgPnniCfgNodeNumNeighbors=mscARtgPnniCfgNodeNumNeighbors, mscARtgPnniCfgNodeSAddrProvTable=mscARtgPnniCfgNodeSAddrProvTable, mscAtmIfVccRpRowStatus=mscAtmIfVccRpRowStatus, mscARtgPnniRfTransferCapabilityBbc=mscARtgPnniRfTransferCapabilityBbc, mscARtgPnniCfgNode=mscARtgPnniCfgNode, mscAtmIfVptVccRpIndex=mscAtmIfVptVccRpIndex, mscARtgPnniRfBwdQosClass=mscARtgPnniRfBwdQosClass, mscARtgPnniCfgNodeNbrPeerState=mscARtgPnniCfgNodeNbrPeerState, mscARtgPnniTopNodeAddrComponentName=mscARtgPnniTopNodeAddrComponentName, atmNetworkingGroupCA02A=atmNetworkingGroupCA02A, mscARtgPnniTopNodeRowStatusEntry=mscARtgPnniTopNodeRowStatusEntry, mscAtmCR=mscAtmCR, mscAtmIfVptVccEpComponentName=mscAtmIfVptVccEpComponentName, mscARtgPnniCfgNodeNbrDbSummariesRx=mscARtgPnniCfgNodeNbrDbSummariesRx, mscARtgPnniOptMetricValue=mscARtgPnniOptMetricValue, mscARtgPnniTopPglNodeId=mscARtgPnniTopPglNodeId, mscARtgDnaDestInfoStorageType=mscARtgDnaDestInfoStorageType, mscARtgDnaRowStatusEntry=mscARtgDnaRowStatusEntry, mscAtmIfVpcSrcState=mscAtmIfVpcSrcState, mscARtgPnniCfgNodeSAddrAddressIndex=mscARtgPnniCfgNodeSAddrAddressIndex, mscARtgPnniStatsTable=mscARtgPnniStatsTable, mscAtmIfVptVccRpOperTable=mscAtmIfVptVccRpOperTable, mscAtmIfVpcDstRowStatusEntry=mscAtmIfVpcDstRowStatusEntry, mscAtmIfVpcSrcProvEntry=mscAtmIfVpcSrcProvEntry, mscARtgStatsEntry=mscARtgStatsEntry, mscARtgPnniCfgNodeNodeAddress=mscARtgPnniCfgNodeNodeAddress, mscAtmIfVptVccEpRowStatus=mscAtmIfVptVccEpRowStatus, mscAtmIfVpcDstCalledAddress=mscAtmIfVpcDstCalledAddress, mscARtgPnniCfgNodeNbrPtseReqTx=mscARtgPnniCfgNodeNbrPtseReqTx, mscAtmIfVccDstCalledAddress=mscAtmIfVccDstCalledAddress, mscAtmIfVptVccRp=mscAtmIfVptVccRp, mscARtgPnniTopNodeAddrPrefixLengthIndex=mscARtgPnniTopNodeAddrPrefixLengthIndex, mscAtmIfVpcDstComponentName=mscAtmIfVpcDstComponentName, mscAtmIfVccSrcCallingAddress=mscAtmIfVccSrcCallingAddress, mscARtgPnniTopNodeIndex=mscARtgPnniTopNodeIndex, mscAtmIfVccDstRowStatusTable=mscAtmIfVccDstRowStatusTable, mscARtgPnniCfgNodeSAddr=mscARtgPnniCfgNodeSAddr, mscARtgPnniCfgNodeRowStatusEntry=mscARtgPnniCfgNodeRowStatusEntry, mscAtmCRDnaIndex=mscAtmCRDnaIndex, mscARtgPnniCfgNodeNbrRccListEntry=mscARtgPnniCfgNodeNbrRccListEntry, mscARtgPnniPtseHoldDown=mscARtgPnniPtseHoldDown, mscARtgPnniRfMaxRoutes=mscARtgPnniRfMaxRoutes, mscARtgPnniTopNodeAddrOperTable=mscARtgPnniTopNodeAddrOperTable, mscARtgDna=mscARtgDna, mscAtmIfVccEpApplicationName=mscAtmIfVccEpApplicationName, mscAtmIfVccEpComponentName=mscAtmIfVccEpComponentName, atmNetworkingCapabilitiesCA=atmNetworkingCapabilitiesCA, mscARtgPnniTopNodeLinkStorageType=mscARtgPnniTopNodeLinkStorageType, mscARtgPnniRfTxTdpValue=mscARtgPnniRfTxTdpValue, mscARtgRowStatus=mscARtgRowStatus, mscARtgPnniTopNodeLinkRowStatusTable=mscARtgPnniTopNodeLinkRowStatusTable, mscARtgPnniCfgNodeOpPeerGroupId=mscARtgPnniCfgNodeOpPeerGroupId, mscARtgPnniCfgNodeNbrOperEntry=mscARtgPnniCfgNodeNbrOperEntry, mscARtgPnniTopRowStatus=mscARtgPnniTopRowStatus, mscARtgPnniTopNodeAddrOperEntry=mscARtgPnniTopNodeAddrOperEntry, mscARtgPnniCfgNodeSAddrStorageType=mscARtgPnniCfgNodeSAddrStorageType, mscARtgPnniCfgNodeNbrPtseReqRx=mscARtgPnniCfgNodeNbrPtseReqRx, mscARtgPnniTopNodeLink=mscARtgPnniTopNodeLink, mscARtgDnaDestInfoScope=mscARtgDnaDestInfoScope, mscARtgPnniRfStorageType=mscARtgPnniRfStorageType, mscARtgPnniCfgNodeProvEntry=mscARtgPnniCfgNodeProvEntry, mscARtgPnniRfRxTrafficDescType=mscARtgPnniRfRxTrafficDescType, mscARtgDnaIndex=mscARtgDnaIndex, atmNetworkingCapabilitiesCA02A=atmNetworkingCapabilitiesCA02A, mscAtmCRIndex=mscAtmCRIndex, mscARtgPnniTopPreferredPglNodeId=mscARtgPnniTopPreferredPglNodeId, mscAtmIfVpcRpRowStatusTable=mscAtmIfVpcRpRowStatusTable, mscARtgPnniPtseParmsEntry=mscARtgPnniPtseParmsEntry, mscAtmCRRowStatus=mscAtmCRRowStatus, mscARtgPnniTopNodeStorageType=mscARtgPnniTopNodeStorageType, mscAtmIfVccDstOperEntry=mscAtmIfVccDstOperEntry, mscAtmIfVptVccSrc=mscAtmIfVptVccSrc, mscAtmIfVpcSrc=mscAtmIfVpcSrc, mscARtgDnaRowStatusTable=mscARtgDnaRowStatusTable, mscAtmIfVpcDstOperEntry=mscAtmIfVpcDstOperEntry, mscAtmIfVptVccSrcLastFailureDiagCode=mscAtmIfVptVccSrcLastFailureDiagCode, mscARtgPnniPortOperEntry=mscARtgPnniPortOperEntry, mscAtmIfVpcSrcCalledAddress=mscAtmIfVpcSrcCalledAddress, mscAtmCRDnaRowStatusEntry=mscAtmCRDnaRowStatusEntry, mscAtmIfVccSrcComponentName=mscAtmIfVccSrcComponentName, mscARtgPnniCfgNodeDefSAddrScope=mscARtgPnniCfgNodeDefSAddrScope, mscAtmIfVccSrcRetryCount=mscAtmIfVccSrcRetryCount, mscARtgPnniAvcrMt=mscARtgPnniAvcrMt, mscARtgPnniPtseRefreshInterval=mscARtgPnniPtseRefreshInterval, mscAtmIfVccEpOperTable=mscAtmIfVccEpOperTable, mscARtgPnniPortRowStatusTable=mscARtgPnniPortRowStatusTable, mscARtgPnniOptMetricEntry=mscARtgPnniOptMetricEntry, mscARtgPnniCfgNodeNbrStorageType=mscARtgPnniCfgNodeNbrStorageType, mscAtmCRDnaComponentName=mscAtmCRDnaComponentName, mscAtmIfVccRpOperEntry=mscAtmIfVccRpOperEntry, atmNetworkingCapabilities=atmNetworkingCapabilities, mscAtmIfVccRpOperTable=mscAtmIfVccRpOperTable, mscARtgPnniCfgNodePglElectionState=mscARtgPnniCfgNodePglElectionState, mscARtgPnniTopOperEntry=mscARtgPnniTopOperEntry, mscAtmIfVccEpRowStatus=mscAtmIfVccEpRowStatus, mscAtmIfVpcDstCallingVpi=mscAtmIfVpcDstCallingVpi, mscAtmIfVccRpNextHopsTable=mscAtmIfVccRpNextHopsTable, mscAtmIfVptVccDstRowStatusEntry=mscAtmIfVptVccDstRowStatusEntry, mscARtgPnniCfgNodeSAddrOperEntry=mscARtgPnniCfgNodeSAddrOperEntry, mscARtgPnniCfgNodeNbrBadPtseRx=mscARtgPnniCfgNodeNbrBadPtseRx, mscARtgPnniOptMetricIndex=mscARtgPnniOptMetricIndex, mscAtmCRStorageType=mscAtmCRStorageType, mscAtmCRDnaRowStatus=mscAtmCRDnaRowStatus, mscAtmIfVpcRpNextHopsEntry=mscAtmIfVpcRpNextHopsEntry, mscARtgPnniCfgNodeSAddrReachabilityIndex=mscARtgPnniCfgNodeSAddrReachabilityIndex, mscAtmIfVccSrcLastFailureDiagCode=mscAtmIfVccSrcLastFailureDiagCode, mscARtgPnniTopNodeAddr=mscARtgPnniTopNodeAddr, mscARtgPnniRfRxTdpValue=mscARtgPnniRfRxTdpValue, mscARtgPnniRfBqpValue=mscARtgPnniRfBqpValue, mscARtgPnniCfgNodeSAddrOperTable=mscARtgPnniCfgNodeSAddrOperTable, mscARtgPnniRfComponentName=mscARtgPnniRfComponentName, mscAtmIfVpcSrcCallingAddress=mscAtmIfVpcSrcCallingAddress, mscAtmIfVpcRpComponentName=mscAtmIfVpcRpComponentName, mscARtgPnniCfgNodeRowStatusTable=mscARtgPnniCfgNodeRowStatusTable, mscARtgPnniTopNodeAddrStorageType=mscARtgPnniTopNodeAddrStorageType, mscARtgPnniCfgNodeNbrBadDbSummariesRx=mscARtgPnniCfgNodeNbrBadDbSummariesRx, mscARtgPnniTopNodeAddrRowStatusTable=mscARtgPnniTopNodeAddrRowStatusTable, mscAtmIfVccEpOperEntry=mscAtmIfVccEpOperEntry, mscARtgPnniCfgNodePeerGroupId=mscARtgPnniCfgNodePeerGroupId, mscAtmIfVptVccEpOperEntry=mscAtmIfVptVccEpOperEntry, mscARtgFailedRoutingAttempts=mscARtgFailedRoutingAttempts, mscARtgComponentName=mscARtgComponentName, mscARtgDnaComponentName=mscARtgDnaComponentName, mscARtgPnniRowStatusTable=mscARtgPnniRowStatusTable, mscARtgPnniTopNodeAddrRowStatusEntry=mscARtgPnniTopNodeAddrRowStatusEntry, mscARtgPnniHelloHoldDown=mscARtgPnniHelloHoldDown, mscAtmCRDnaDestinationNameEntry=mscAtmCRDnaDestinationNameEntry, mscARtgPnniRfRxTdpTable=mscARtgPnniRfRxTdpTable, mscAtmIfVptVccSrcCalledAddress=mscAtmIfVptVccSrcCalledAddress, mscAtmIfVccEpRowStatusTable=mscAtmIfVccEpRowStatusTable)

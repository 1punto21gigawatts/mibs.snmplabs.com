#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-X25DteMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-X25DteMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
Gauge32, InterfaceIndex, Counter32, Unsigned32, DisplayString, Integer32, StorageType, RowStatus = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Gauge32", "InterfaceIndex", "Counter32", "Unsigned32", "DisplayString", "Integer32", "StorageType", "RowStatus")
PassportCounter64, AsciiString, DigitString, Link, NonReplicated, HexString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "PassportCounter64", "AsciiString", "DigitString", "Link", "NonReplicated", "HexString")
mscComponents, mscPassportMIBs = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscComponents", "mscPassportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, Gauge32, TimeTicks, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, ModuleIdentity, Counter64, Counter32, Unsigned32, Integer32, IpAddress, MibIdentifier, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Gauge32", "TimeTicks", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "ModuleIdentity", "Counter64", "Counter32", "Unsigned32", "Integer32", "IpAddress", "MibIdentifier", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
x25DteMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48))
mscX25Dte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90))
mscX25DteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 1), )
if mibBuilder.loadTexts: mscX25DteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRowStatusTable.setDescription('This entry controls the addition and deletion of mscX25Dte components.')
mscX25DteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRowStatusEntry.setDescription('A single entry in the table represents a single mscX25Dte component.')
mscX25DteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscX25Dte components. These components can be added and deleted.')
mscX25DteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscX25DteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteStorageType.setDescription('This variable represents the storage type value for the mscX25Dte tables.')
mscX25DteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mscX25DteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteIndex.setDescription('This variable represents the index for the mscX25Dte tables.')
mscX25DteCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 20), )
if mibBuilder.loadTexts: mscX25DteCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscX25DteCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 20, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteCidDataEntry.setDescription('An entry in the mscX25DteCidDataTable.')
mscX25DteCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscX25DteIfTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21), )
if mibBuilder.loadTexts: mscX25DteIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteIfTable.setDescription('This group provides the administrative set of parameters for the X.25 interface.')
mscX25DteIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteIfEntry.setDescription('An entry in the mscX25DteIfTable.')
mscX25DteInterfaceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2))).clone('dte')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInterfaceMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInterfaceMode.setDescription('This attribute specifies the packet mode in which the X.25 interface operates. When this attribute is set to dte, interface on the other side of the physical link must be configured as a dce.')
mscX25DteMaxActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteMaxActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteMaxActiveChannels.setDescription('This attribute specifies the maximum number of channels that can be active on this interface including the Permanent Lcns and the Switched Lcns. In total maxActiveChannel will determine the maximum number of Lcn components which may exist at a given time. This should be set to a value greater or equal to the numberOfPLcn provisioned.')
mscX25DteNumberOfPLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteNumberOfPLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteNumberOfPLcn.setDescription('This attribute specifies the number of Permanent Logical Channels that are supported on this X.25 interface (that is, the number of PermLcn components that may be provisioned at this interface). The PermLcn components use channel numbers starting from 1 and up to lowestILChannelNumber. A value of 0 for this attribute indicates that no Permanent Logical channels are supported on this X.25 interface.')
mscX25DtePacketSequencing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("modulo8", 1), ("modulo128", 2))).clone('modulo8')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePacketSequencing.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePacketSequencing.setDescription('This attribute specifies the sequence numbering of packets for the X.25 interface. The value of this attribute must be the same as the packet sequencing configured at the X.25 interface on the other side of the physical link.')
mscX25DteT20RestartTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65536000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteT20RestartTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteT20RestartTimer.setDescription('This attribute provides the period in milliseconds within which a restart request packet should be confirmed.')
mscX25DteT21CallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65536000)).clone(180000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteT21CallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteT21CallTimer.setDescription('This attribute provides the period in milliseconds within which a call request packet should be confirmed.')
mscX25DteT22ResetTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65536000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteT22ResetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteT22ResetTimer.setDescription('This attribute provides the period in milliseconds within which a reset request packet should be confirmed.')
mscX25DteT23ClearTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 21, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65536000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteT23ClearTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteT23ClearTimer.setDescription('This attribute provides the period in milliseconds within which a clear request packet should be confirmed.')
mscX25DteLcnCTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 22), )
if mibBuilder.loadTexts: mscX25DteLcnCTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCTable.setDescription('This group contains the provisionable attributes for the Logical Channel configuration of the X.25 Interface. The logical channel range table is ordered as follows: Permanent Logical Channels(PLC), One-way Incoming Channels (IC), Two-way Channels(TC) and One-way Outgoing Channels (OC), in a consecutive manner.')
mscX25DteLcnCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 22, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteLcnCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCEntry.setDescription('An entry in the mscX25DteLcnCTable.')
mscX25DteLowestILChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 22, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLowestILChannelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLowestILChannelNumber.setDescription('This attribute specifies the lowest Lcn number of the One-way Incoming Channel range for this X.25 interface. The value for this attribute must be greater than the numberOfPLcn attribute.')
mscX25DteHighestILChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 22, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteHighestILChannelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteHighestILChannelNumber.setDescription('This attribute specifies the highest Lcn number of the One-way Incoming Channel range for this X.25 interface. A value of 0 indicates that there are no channels in this range.')
mscX25DteLowestTLChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 22, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLowestTLChannelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLowestTLChannelNumber.setDescription('This attribute specifies the lowest Lcn number of the Two-way Channel range for this X.25 interface. The value for this attribute must be greater than the highestILChannelNumber attribute.')
mscX25DteHighestTLChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 22, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteHighestTLChannelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteHighestTLChannelNumber.setDescription('This attribute specifies the highest Lcn number of the Two-way Channel range for this X.25 interface. A value of 0 indicates that there are no channels in this range.')
mscX25DteLowestOLChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 22, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLowestOLChannelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLowestOLChannelNumber.setDescription('This attribute specifies the lowest Lcn number of the One-way Outgoing Channel range for this X.25 interface. The value for this attribute must be greater than the highestTLChannelNumber attribute.')
mscX25DteHighestOLChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 22, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteHighestOLChannelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteHighestOLChannelNumber.setDescription('This attribute specifies the highest Lcn number of the One-way Outgoing Channel range for this X.25 interface. A value of 0 indicates that there are no channels in this range.')
mscX25DteDcpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23), )
if mibBuilder.loadTexts: mscX25DteDcpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteDcpTable.setDescription('This group contains the provisionable attributes giving the default call parameters used by all the logical channels during call setup. It is possible that different default call parameters will be used for a particular call, based on the Peer component for the given call. The actual call parameters operational for a given call are found in the Lcn component.')
mscX25DteDcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteDcpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteDcpEntry.setDescription('An entry in the mscX25DteDcpTable.')
mscX25DteInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInPacketSize.setDescription('This attribute specifies the maximum receive packet size in octets for the X.25 interface.')
mscX25DteOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOutPacketSize.setDescription('This attribute specifies the maximum transmit packet size in octets for the X.25 interface.')
mscX25DteInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInWindowSize.setDescription('This attribute specifies the maximum receive window size for the X.25 interface. A window size greater than 7 is only valid when the packetSequencing attribute is set to modulo128.')
mscX25DteOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOutWindowSize.setDescription('This attribute specifies the maximum transmit window size for the X.25 interface. A window size greater than 7 is only valid when the packetSequencing is set to modulo128.')
mscX25DteAcceptReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("accept", 2), ("refuse", 3), ("neverAccept", 4))).clone('refuse')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteAcceptReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteAcceptReverseCharging.setDescription('This attribute specifies whether local end will accept or refuse charges for a call. A value of neverAccept is only used at the X.25 interface level and indicates that this interface will never accept reverse charging (that is no Peer component can override this parameter, allowing reverse charged calls to be accepted).')
mscX25DteProposeReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("reverse", 2), ("local", 3))).clone('local')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteProposeReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteProposeReverseCharging.setDescription('This attribute specifies whether local/reverse charging is signalled in the call request packet.')
mscX25DteOutThroughputClassSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 17))).clone(namedValues=NamedValues(("n75", 3), ("n150", 4), ("n300", 5), ("n600", 6), ("n1200", 7), ("n2400", 8), ("n4800", 9), ("n9600", 10), ("n19200", 11), ("n48000", 12), ("n64000", 13), ("notSpecified", 17))).clone('notSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteOutThroughputClassSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOutThroughputClassSize.setDescription('This attribute specifies the value of the transmit throughput class to be negotiated. A value of notSpecified means the facility is not signalled.')
mscX25DteInThroughputClassSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 17))).clone(namedValues=NamedValues(("n75", 3), ("n150", 4), ("n300", 5), ("n600", 6), ("n1200", 7), ("n2400", 8), ("n4800", 9), ("n9600", 10), ("n19200", 11), ("n48000", 12), ("n64000", 13), ("notSpecified", 17))).clone('notSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteInThroughputClassSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInThroughputClassSize.setDescription('This attribute specifies the value of the receive throughput class to be negotiated. A value of notSpecified means the facility is not signalled.')
mscX25DteCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteCugIndex.setDescription('This attribute specifies the index of the Closed User Group facility to signal. The index consists of two or four octets each representing a digit in the range of 0 to 9. A value of null (empty string) at the X.25 interface means no CUG facility is signalled. If a cugIndex is provisioned to be signalled, the cugoaIndex attribute must be null.')
mscX25DteCugoaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteCugoaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteCugoaIndex.setDescription('This attribute specifies the index of the Close User Group with Outgoing Access facility to signal. The index consists of two or four octets each representing a digit in the range of 0 to 9. A value of null (empty string) at the X.25 interface means no CUGOA facility is signalled. If a cugoaIndex is provisioned to be signalled, the cugIndex attribute must be null.')
mscX25DteChargingInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("notSpecified", 2), ("notRequested", 3), ("requested", 4))).clone('notSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteChargingInformation.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteChargingInformation.setDescription('This attribute specifies whether the charging information facility is to be signalled in a call request packet. A value of notSpecified means the facility is not signalled. A value of notRequested means the facility is signalled but charging information is not requested (that is, the charging info field of the facility is set Off). A value of requested means the facility is signalled to explicitly request charging information.')
mscX25DteRpoa = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 14), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRpoa.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRpoa.setDescription('This attribute specifies the value of the RPOA facility to signal in a call request packet. The value of null (empty string) at the X.25 interface means no RPOA facility is signalled.')
mscX25DteTrnstDlySlctnAInd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)).clone(65536)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteTrnstDlySlctnAInd.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteTrnstDlySlctnAInd.setDescription('This attribute specifies the value of the Transit Delay Selection and Indication facility to signal in a call request packet. A value of 65536 at the X.25 interface level means no TDSAI facility is signalled.')
mscX25DteCallingNetworkFax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 24), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteCallingNetworkFax.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteCallingNetworkFax.setDescription('This attribute specifies the Calling Network facilities to be signalled in a call request packet. A value of null (empty string) at the X.25 interface means no facilities are signalled.')
mscX25DteCalledNetworkFax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 25), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteCalledNetworkFax.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteCalledNetworkFax.setDescription('This attribute specifies the called network facilities to be signalled in a call request packet. A value of null (empty string) at the X.25 interface means no facilities are signalled.')
mscX25DteCallUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 23, 1, 26), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteCallUserData.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteCallUserData.setDescription('This attribute specifies the user data to be signalled in the call request packet. A value of null (empty string) means no user data is signalled.')
mscX25DteIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 24), )
if mibBuilder.loadTexts: mscX25DteIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscX25DteIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 24, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteIfEntryEntry.setDescription('An entry in the mscX25DteIfEntryTable.')
mscX25DteIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 24, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscX25DteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 24, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscX25DteStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 25), )
if mibBuilder.loadTexts: mscX25DteStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscX25DteStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 25, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteStateEntry.setDescription('An entry in the mscX25DteStateTable.')
mscX25DteAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 25, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscX25DteOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 25, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscX25DteUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 25, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscX25DteOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 26), )
if mibBuilder.loadTexts: mscX25DteOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscX25DteOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 26, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOperStatusEntry.setDescription('An entry in the mscX25DteOperStatusTable.')
mscX25DteSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 26, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscX25DteOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 27), )
if mibBuilder.loadTexts: mscX25DteOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOpTable.setDescription('This group contains the operational status of the X.25 interface.')
mscX25DteOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 27, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOpEntry.setDescription('An entry in the mscX25DteOpTable.')
mscX25DteInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 27, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notReady", 0), ("localRestarting", 1), ("remoteRestarting", 2), ("ready", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInterfaceState.setDescription('This attribute specifies the state of the interface. The notReady state, is the initial state of the service, when it is being initialized. The localRestarting state is entered when a Restart packet is sent to the link and the interface is waiting for a response. The remoteRestarting state is entered when a Restart packet is received from the link, and is being processed. In ready state, the service is operational and ready to provide service.')
mscX25DteStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28), )
if mibBuilder.loadTexts: mscX25DteStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteStatsTable.setDescription('This component contains the statistics for the X.25 interface.')
mscX25DteStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"))
if mibBuilder.loadTexts: mscX25DteStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteStatsEntry.setDescription('An entry in the mscX25DteStatsTable.')
mscX25DteInCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInCalls.setDescription('This attribute counts the number of call packets received from link.')
mscX25DteInCallRefusals = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInCallRefusals.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInCallRefusals.setDescription('This attribute counts the number of calls received from the link which have been cleared. This includes calls cleared by the X.25 interface and calls cleared by the higher level.')
mscX25DteInPrvdrInitiatedClrs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInPrvdrInitiatedClrs.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInPrvdrInitiatedClrs.setDescription('This attribute counts the number of clear packets received from the link with a cause code other than DTE initiated.')
mscX25DteInRmtInitiatedRsts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInRmtInitiatedRsts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInRmtInitiatedRsts.setDescription('This attribute counts the number of reset packets received from the link with the cause code DTE initiated.')
mscX25DteInPrvdrInitiatedRsts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInPrvdrInitiatedRsts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInPrvdrInitiatedRsts.setDescription('This attribute counts the number of reset packets received from the link with the cause code other than DTE initiated.')
mscX25DteInRestarts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInRestarts.setDescription('This attribute counts the number of restart packets received from the link while the service is in ready state.')
mscX25DteInDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInDataPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInDataPackets.setDescription('This attribute counts the number of data packets received from link.')
mscX25DteInPktsAcusdOfPrtclErr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInPktsAcusdOfPrtclErr.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInPktsAcusdOfPrtclErr.setDescription('This attribute counts the number of clear, reset, restart and diagnostic packets received from link containing a procedure error cause code.')
mscX25DteInInterruptPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInInterruptPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInInterruptPackets.setDescription('This attributes counts the number of interrupt packets received from link.')
mscX25DteOutCallAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteOutCallAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOutCallAttempts.setDescription('This attribute counts the number of call packets sent from this interface.')
mscX25DteOutCallFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteOutCallFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOutCallFailures.setDescription('This attribute counts the number of call attempts from this interface that failed. This includes calls that were cleared because of restrictive fast select.')
mscX25DteOutInterruptPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteOutInterruptPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOutInterruptPackets.setDescription('This attribute counts the number of interrupt packets sent to the link.')
mscX25DteOutDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteOutDataPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOutDataPackets.setDescription('This attribute counts the number of data packets sent to the link.')
mscX25DteOutActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteOutActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteOutActiveChannels.setDescription('This attribute indicates the number of One-way Outgoing Channels that are currently in use. This counter includes the call requests that have not been accepted.')
mscX25DteInActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteInActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteInActiveChannels.setDescription('This attribute indicates number of One-way Incoming Channels that are currently active.')
mscX25DteTwowayActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteTwowayActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteTwowayActiveChannels.setDescription('This attribute indicates the number of Two-way Channels that are in use. This includes call requests sent but not yet accepted.')
mscX25DteT20RestartTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteT20RestartTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteT20RestartTimeouts.setDescription('This attribute counts the number of times the T20 restart timer has expired.')
mscX25DteT21CallTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteT21CallTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteT21CallTimeouts.setDescription('This attribute counts the number of times the T21 call timer has expired.')
mscX25DteT22ResetTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteT22ResetTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteT22ResetTimeouts.setDescription('This attribute counts the number of times the T22 reset timer has expired.')
mscX25DteT23ClearTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 28, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteT23ClearTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteT23ClearTimeouts.setDescription('This attribute counts the number of times the T23 clear timer has expired.')
mscX25DtePeer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2))
mscX25DtePeerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 1), )
if mibBuilder.loadTexts: mscX25DtePeerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerRowStatusTable.setDescription('This entry controls the addition and deletion of mscX25DtePeer components.')
mscX25DtePeerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePeerIndex"))
if mibBuilder.loadTexts: mscX25DtePeerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerRowStatusEntry.setDescription('A single entry in the table represents a single mscX25DtePeer component.')
mscX25DtePeerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscX25DtePeer components. These components can be added and deleted.')
mscX25DtePeerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePeerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscX25DtePeerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePeerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerStorageType.setDescription('This variable represents the storage type value for the mscX25DtePeer tables.')
mscX25DtePeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: mscX25DtePeerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerIndex.setDescription('This variable represents the index for the mscX25DtePeer tables.')
mscX25DtePeerIfTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 10), )
if mibBuilder.loadTexts: mscX25DtePeerIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerIfTable.setDescription('This group provides the administrative set of parameters for the Peer interface.')
mscX25DtePeerIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePeerIndex"))
if mibBuilder.loadTexts: mscX25DtePeerIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerIfEntry.setDescription('An entry in the mscX25DtePeerIfTable.')
mscX25DtePeerEncAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(204))).clone(namedValues=NamedValues(("ip", 204))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerEncAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerEncAddressType.setDescription('This attribute specifies the encapsulation type for the address of the remote host with which this Peer component allows communication.')
mscX25DtePeerEncAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerEncAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerEncAddress.setDescription('This attribute specifies the encapsulation address of the remote host with which this Peer component allows communication. This address must correspond with the encapsulation address type. Thus in the case of IP, it will contain a IP address.')
mscX25DtePeerX25Address = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 10, 1, 3), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerX25Address.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerX25Address.setDescription("This attribute specifies the X.25 address that identifies the remote host with which this Peer component allows communication. The remote X.25 interface could be subdivided through the use of RemoteGroup components; in which case this x25Address is the X.25 address of the destination's RemoteGroup (not to be confused with the RemoteGroup indicated by the linkToRemoteGroup attribute of THIS Peer component).")
mscX25DtePeerLinkToRemoteGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 10, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerLinkToRemoteGroup.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerLinkToRemoteGroup.setDescription('This is a link to a RemoteGroup component. The RemoteGroup components logically divide up the X.25 Interface such that a number of Protocol Ports (and consequently a number of Virtual Routers) may share the same X.25 Interface into a Wide Area Network. In particular, the remote host identified by this Peer component is designated as belonging to the RemoteGroup linked by this attribute. The set of all Peer components and PermLcn components which link to a given RemoteGroup determine the subset of remote hosts which are accessible to a particular Protocol Port (and ultimately a Virtual Router).')
mscX25DtePeerCpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12), )
if mibBuilder.loadTexts: mscX25DtePeerCpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerCpTable.setDescription('This group contains the call parameters used to establish a call to/ from the remote host identified by this Peer component')
mscX25DtePeerCpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePeerIndex"))
if mibBuilder.loadTexts: mscX25DtePeerCpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerCpEntry.setDescription('An entry in the mscX25DtePeerCpTable.')
mscX25DtePeerInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerInPacketSize.setDescription('This attribute specifies the default maximum receive packet size in octets. A setting of 0 indicates the inPacketSize setting for the X.25 interface (in X25Dte component) is used during call setup to the remote host identified by this Peer component.')
mscX25DtePeerOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerOutPacketSize.setDescription('This attribute specifies the default maximum transmit packet size in octets. A setting of 0 indicates the outPacketSize setting for the X.25 interface (in the X25Dte component) is used during call setup to the remote host identified by this Peer component.')
mscX25DtePeerInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerInWindowSize.setDescription('This attribute specifies the default receive window size. A window size of 0 indicates the inWindowSize setting for the X.25 interface (in the X25Dte component) is used during call setup to the remote host identified by this Peer component. A window size greater than 7 is only valid when the packetSequencing attribute of the X25Dte component is set to modulo128.')
mscX25DtePeerOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerOutWindowSize.setDescription('This attribute specifies the default transmit window size. A window size of 0 indicates the outWindowSize setting for the X.25 interface is used during call setup to the Peer identified by this component. A window size greater than 7 is only valid when the packetSequencing attribute of the X25Dte component is set to modulo128.')
mscX25DtePeerAcceptReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("accept", 2), ("refuse", 3))).clone('refuse')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerAcceptReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerAcceptReverseCharging.setDescription('This attribute specifies whether the local end will accept or refuse charges for a call from the remote host identified by this Peer component. A value of default indicates the use of the acceptReverseCharging value from the X25Dte component. If the value at the X25Dte level is neverAccept, a value of accept in this Peer component will be ignored because no reverse charge calls are to be accepted by this X.25 Dte.')
mscX25DtePeerProposeReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("reverse", 2), ("local", 3))).clone('local')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerProposeReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerProposeReverseCharging.setDescription('This attribute specifies whether local/reverse charging is signalled in a call request packet. A value of default indicates the use of the value from the proposeReverseCharging attribute of the X25Dte component.')
mscX25DtePeerOutThroughputClassSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 17, 18))).clone(namedValues=NamedValues(("n75", 3), ("n150", 4), ("n300", 5), ("n600", 6), ("n1200", 7), ("n2400", 8), ("n4800", 9), ("n9600", 10), ("n19200", 11), ("n48000", 12), ("n64000", 13), ("notSpecified", 17), ("default", 18))).clone('notSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerOutThroughputClassSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerOutThroughputClassSize.setDescription('This attribute specifies the value of the transmit throughput class to be negotiated. A value of default indicates the use of the value from the outThroughputClassSize attribute of the X25Dte component. A value of notSpecified means the facility is not signalled.')
mscX25DtePeerInThroughputClassSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 17, 18))).clone(namedValues=NamedValues(("n75", 3), ("n150", 4), ("n300", 5), ("n600", 6), ("n1200", 7), ("n2400", 8), ("n4800", 9), ("n9600", 10), ("n19200", 11), ("n48000", 12), ("n64000", 13), ("notSpecified", 17), ("default", 18))).clone('notSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerInThroughputClassSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerInThroughputClassSize.setDescription('This attribute specifies the value of the receive throughput class to be negotiated. A value of default indicates the use of the value from the inThroughputClassSize attribute of the X25Dte component. A value of notSpecified means the facility is not signalled.')
mscX25DtePeerCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerCugIndex.setDescription("This attribute specifies the index of the Closed User Group facility to signal. A value of 'DEF' indicates the use of the value from the cugIndex attribute of the X25Dte component. A value of null (empty string) indicates no CUG facility is to be signalled. If a cugIndex is provisioned to be signalled, the cugoaIndex attribute must be null.")
mscX25DtePeerCugoaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerCugoaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerCugoaIndex.setDescription("This attribute specifies the index of the Closed User Group with Outgoing Access facility to signal. A value of 'DEF' indicates the use of the value from the cugoaIndex attribute of the X25Dte component. A value of null (empty string) indicates no CUGOA facility is to be signalled. If a cugoaIndex is provisioned to be signalled, the cugIndex attribute must be null.")
mscX25DtePeerNetworkUserIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 12), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerNetworkUserIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerNetworkUserIdentifier.setDescription('This attribute specifies the Network User Identifier facility to signal. A value of null (empty string) indicates no NUI facility is to be signalled.')
mscX25DtePeerChargingInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("default", 1), ("notSpecified", 2), ("notRequested", 3), ("requested", 4))).clone('notSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerChargingInformation.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerChargingInformation.setDescription('This attribute specifies whether the charging information facility is signalled in the call request packet. A value of default indicates the use of the value from the chargingInformation attribute of the X25Dte component. A value of notSpecified means the facility is not signalled. A value of notRequested means the facility is signalled but charging information is not requested (that is, the charging info field of the facility is set Off). A value of requested means the facility is signalled to explicitly request charging information.')
mscX25DtePeerRpoa = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 14), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerRpoa.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerRpoa.setDescription("This attribute specifies the RPOA facility to signal in a call request packet. A value of 'DEF' indicates the use of the value from the rpoa attribute of the X25Dte component. A value of null (empty string) indicates no RPOA facility is to be signalled.")
mscX25DtePeerTrnstDlySlctnAInd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65537)).clone(65536)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerTrnstDlySlctnAInd.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerTrnstDlySlctnAInd.setDescription('This attribute specifies the value of the Transit Delay Selection and Indication facility to signal in a call request packet. A value of 65536 indicates no facility is signalled. A value of 65537 indicates the use of the value from the trnstDlySlctnAInd attribute of the X25Dte component.')
mscX25DtePeerCallingNetworkFax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 24), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerCallingNetworkFax.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerCallingNetworkFax.setDescription('This attribute specifies the Calling Network facilities to signal in a call request packet. The facilities are encoded here exactly as they are encoded in the call packet. These facilities do not include the marker facility code. A value of null (empty string) indicates the callingNetworkFax from the X25Dte are to be signalled. If that value is also null, no Calling Network Facilities are signalled.')
mscX25DtePeerCalledNetworkFax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 25), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerCalledNetworkFax.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerCalledNetworkFax.setDescription('This attribute specifies the Called Network facilities to signal in a call request packet. The facilities are encoded here exactly as they are encoded in the call packet. These facilities do not include the marker facility code. A value of null (empty string) indicates the calledNetworkFax from the X25Dte are to be signalled. If that value is also null, no Called Network Facilities are signalled.')
mscX25DtePeerCallUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 12, 1, 26), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePeerCallUserData.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerCallUserData.setDescription('This attribute specifies the user data to signal in a call request packet. A value of null (empty string) indicates that the callUserData from the X25Dte is to be signalled. If callUserData of the X25Dte component is also null and protocolEncType of this Peer has the value IP, H.CC will be signalled as the call user data of a call request packet. Thus for IP encapsulation according to RFC1356, both the callUserData from the Peer and X25Dte components must be null and the protocolEncType set to IP.')
mscX25DtePeerPEncTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 208), )
if mibBuilder.loadTexts: mscX25DtePeerPEncTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerPEncTable.setDescription("Each instance of this replicated attribute describes an encapsulation method permitted for encapsulating the protocol data units (PDUs) of an upper layer protocol when communicating with the remote host identified by this Peer component. The index of a given replicated instance of this attribute represents the relative priority of the encapsulation method specified by the given attribute instance. An attribute with index '1' has the highest priority, so the encapsulation method described by it will be the first one attempted when signalling a call to the link. If the protocolEncType is set to IP to encapsulate IP traffic according to RFC1356, the callUserData for this Peer component and the X25Dte component must both be null, so that H.CC will be signalled as the call user data of the call request. This indicates that the protocol encapsulation type of IP is to be used for the channel. A call received from the link will be accepted as long as the encapsulation method indicated in the call user data of the incoming call packet is included in one of these replicated attributes. (This presupposes that the incoming call has been directed to the RemoteGroup to which this Peer is linked through the linkToRemoteGroup attribute.)")
mscX25DtePeerPEncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 208, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePeerIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePeerPEncIndex"))
if mibBuilder.loadTexts: mscX25DtePeerPEncEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerPEncEntry.setDescription('An entry in the mscX25DtePeerPEncTable.')
mscX25DtePeerPEncIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 208, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: mscX25DtePeerPEncIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerPEncIndex.setDescription('This variable represents the index for the mscX25DtePeerPEncTable.')
mscX25DtePeerPEncValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 208, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(204))).clone(namedValues=NamedValues(("ip", 204)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePeerPEncValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerPEncValue.setDescription('This variable represents an individual value for the mscX25DtePeerPEncTable.')
mscX25DtePeerPEncRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 208, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscX25DtePeerPEncRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerPEncRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscX25DtePeerPEncTable.')
mscX25DtePeerLcnTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 209), )
if mibBuilder.loadTexts: mscX25DtePeerLcnTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerLcnTable.setDescription('This attribute specifies the local logical channel numbers (Lcn) in use for the X.25 calls to the remote host identified by this Peer component.')
mscX25DtePeerLcnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 209, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePeerIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePeerLcnValue"))
if mibBuilder.loadTexts: mscX25DtePeerLcnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerLcnEntry.setDescription('An entry in the mscX25DtePeerLcnTable.')
mscX25DtePeerLcnValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 2, 209, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePeerLcnValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePeerLcnValue.setDescription('This variable represents both the value and the index for the mscX25DtePeerLcnTable.')
mscX25DtePLcn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3))
mscX25DtePLcnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 1), )
if mibBuilder.loadTexts: mscX25DtePLcnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnRowStatusTable.setDescription('This entry controls the addition and deletion of mscX25DtePLcn components.')
mscX25DtePLcnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePLcnIndex"))
if mibBuilder.loadTexts: mscX25DtePLcnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnRowStatusEntry.setDescription('A single entry in the table represents a single mscX25DtePLcn component.')
mscX25DtePLcnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscX25DtePLcn components. These components can be added and deleted.')
mscX25DtePLcnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePLcnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscX25DtePLcnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePLcnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnStorageType.setDescription('This variable represents the storage type value for the mscX25DtePLcn tables.')
mscX25DtePLcnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: mscX25DtePLcnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnIndex.setDescription('This variable represents the index for the mscX25DtePLcn tables.')
mscX25DtePLcnProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10), )
if mibBuilder.loadTexts: mscX25DtePLcnProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnProvTable.setDescription('This group contains the provisionable parameters for the permanent logical channels (PLcns) on the X.25 interface (corresponding to Permanent Virtual Circuits (PVCs) provisioned on the Wide Area Network).')
mscX25DtePLcnProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePLcnIndex"))
if mibBuilder.loadTexts: mscX25DtePLcnProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnProvEntry.setDescription('An entry in the mscX25DtePLcnProvTable.')
mscX25DtePLcnEncAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 204))).clone(namedValues=NamedValues(("none", 0), ("ip", 204))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnEncAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnEncAddressType.setDescription('This attribute specifies the encapsulation type for the address of the remote host with which this Peer component allows communication.')
mscX25DtePLcnEncAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnEncAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnEncAddress.setDescription('This attribute specifies the encapsulation address of the remote host with which this PermLcn component defines a connection')
mscX25DtePLcnProtocolEncType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 204, 257))).clone(namedValues=NamedValues(("null", 0), ("ip", 204), ("nscNull", 257))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnProtocolEncType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnProtocolEncType.setDescription('This attribute specifies the encapsulation method to use when exchanging protocol data units (PDUs) over this channel. IP and Null protocolEncTypes are as defined in RFC1356. NscNull is an encapsulation method for carrying IP datagrams which requires removing 3 padding octets of zeroes and the protocol identifier H.CC from the front of each data packet received from the link in order to obtain the PDU. PDUs sent to the link are propounded by a the protocol identifier H.CC. NscNull should only be set when the remote host is following this same encapsulation method.')
mscX25DtePLcnLinkToRemoteGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnLinkToRemoteGroup.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnLinkToRemoteGroup.setDescription('This attribute specifies the link to the RemoteGroup, indicating the RemoteGroup component with which this PermLcn component is associated. The RemoteGroup components logically divide up the X.25 Interface such that a number of Protocol Ports (and consequently a number of Virtual Routers) may share the same X.25 Interface into a Wide Area Network. In particular, the remote host identified by this PermLcn component is designated as belonging to the RemoteGroup linked by this attribute. The set of all PermLcn and Peer components which link to a given RemoteGroup determine the subset of remote hosts which are accessible to a particular Protocol Port (and ultimately a Virtual Router).')
mscX25DtePLcnInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnInPacketSize.setDescription('This attribute specifies the maximum receive packet size in octets.')
mscX25DtePLcnOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), )).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnOutPacketSize.setDescription('This attribute specifies the maximum transmit packet size in octets.')
mscX25DtePLcnInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnInWindowSize.setDescription('This attribute specifies the maximum receive window size. A inWindowSize greater than 7 is only valid when the packetSequencing attribute of the X25Dte component is set to modulo128.')
mscX25DtePLcnOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePLcnOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePLcnOutWindowSize.setDescription('This attribute specifies the maximum transmit window size. A outWindowSize greater than 7 is only valid when the packetSequencing attribute of the X25Dte component is set to modulo128.')
mscX25DteLcn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4))
mscX25DteLcnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 1), )
if mibBuilder.loadTexts: mscX25DteLcnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscX25DteLcn components.')
mscX25DteLcnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLcnIndex"))
if mibBuilder.loadTexts: mscX25DteLcnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnRowStatusEntry.setDescription('A single entry in the table represents a single mscX25DteLcn component.')
mscX25DteLcnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscX25DteLcn components. These components cannot be added nor deleted.')
mscX25DteLcnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscX25DteLcnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnStorageType.setDescription('This variable represents the storage type value for the mscX25DteLcn tables.')
mscX25DteLcnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: mscX25DteLcnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnIndex.setDescription('This variable represents the index for the mscX25DteLcn tables.')
mscX25DteLcnStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 10), )
if mibBuilder.loadTexts: mscX25DteLcnStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnStateTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscX25DteLcnStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLcnIndex"))
if mibBuilder.loadTexts: mscX25DteLcnStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnStateEntry.setDescription('An entry in the mscX25DteLcnStateTable.')
mscX25DteLcnAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscX25DteLcnOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscX25DteLcnUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscX25DteLcnCpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11), )
if mibBuilder.loadTexts: mscX25DteLcnCpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCpTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the call parameters that are in use for this logical channel. For a PVC only the packet size and the window size attributes are meaningful.')
mscX25DteLcnCpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLcnIndex"))
if mibBuilder.loadTexts: mscX25DteLcnCpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCpEntry.setDescription('An entry in the mscX25DteLcnCpTable.')
mscX25DteLcnInPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInPacketSize.setDescription('This attribute indicates the maximum receive packet size in octets.')
mscX25DteLcnOutPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnOutPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnOutPacketSize.setDescription('This attribute indicates the maximum transmit packet size in octets.')
mscX25DteLcnInWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInWindowSize.setDescription('This attribute indicates the receive window size.')
mscX25DteLcnOutWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnOutWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnOutWindowSize.setDescription('This attribute indicates the transmit window size.')
mscX25DteLcnProposeReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("reverse", 2), ("local", 3))).clone('local')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnProposeReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnProposeReverseCharging.setDescription('Specifies whether local/reverse charging was negotiated for this logical channel. To determine which end of the channel is paying for the call, this attribute must be examined in combination with the callDirection attribute. For example, if this attribute is set to reverse and the callDirection attribute indicates incoming, it means the incoming call signalled reverse charging, so the local end of the channel is being charged. On the other, if the value of this attribute is reverse and the callDirection is outgoing, it means that the call request sent to the link signalled reverse charging; so the remote end is charged. Similarly, a value of local must also be interpreted in combination with the callDirection to determine which end is being charged. If the value of the callDirection attribute is plcn, the proposeReverseCharging attribute is meaningless.')
mscX25DteLcnFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5))).clone(namedValues=NamedValues(("unrestricted", 3), ("restricted", 4), ("no", 5))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnFastSelect.setDescription('This attribute indicates whether the fast select was used in establishing this logical channel.')
mscX25DteLcnOutThroughputClassSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 17))).clone(namedValues=NamedValues(("n75", 3), ("n150", 4), ("n300", 5), ("n600", 6), ("n1200", 7), ("n2400", 8), ("n4800", 9), ("n9600", 10), ("n19200", 11), ("n48000", 12), ("n64000", 13), ("notSpecified", 17))).clone('notSpecified')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnOutThroughputClassSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnOutThroughputClassSize.setDescription('This attribute specifies the transmit throughput class.')
mscX25DteLcnInThroughputClassSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 17))).clone(namedValues=NamedValues(("n75", 3), ("n150", 4), ("n300", 5), ("n600", 6), ("n1200", 7), ("n2400", 8), ("n4800", 9), ("n9600", 10), ("n19200", 11), ("n48000", 12), ("n64000", 13), ("notSpecified", 17))).clone('notSpecified')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInThroughputClassSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInThroughputClassSize.setDescription('This attribute specifies the receive throughput class.')
mscX25DteLcnCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 9), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCugIndex.setDescription('This attribute indicates the index of the Closed User Group facility used in establishing this logical channel.')
mscX25DteLcnCugoaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 4)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnCugoaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCugoaIndex.setDescription('This attribute indicates the index of the Closed User Group with Outgoing Access facility used in establishing this logical channel.')
mscX25DteLcnNetworkUserIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 11), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnNetworkUserIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnNetworkUserIdentifier.setDescription('Specifies the Network User Identifier used for this logical channel.')
mscX25DteLcnChargingInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("notSpecified", 2), ("notRequested", 3), ("requested", 4))).clone('notSpecified')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnChargingInformation.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnChargingInformation.setDescription('This attribute indicates whether or not the charging information facility was used in establishing this logical channel. A value of notSpecified means the facility was not signalled. A value of notRequested means the facility was signalled but charging information was not requested (that is, the charging info field of the facility was set Off). A value of requested means the facility was signalled to explicitly request charging information. DESCRIPTION')
mscX25DteLcnRpoa = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 13), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnRpoa.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnRpoa.setDescription('This attribute indicates the RPOA facility which was signalled in establishing this logical channel.')
mscX25DteLcnTrnstDlySlctnAInd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536)).clone(65536)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnTrnstDlySlctnAInd.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnTrnstDlySlctnAInd.setDescription('This attribute indicates the Transit Delay Selection and Indication value used for this logical channel. A value of 65536 means no facility was signalled.')
mscX25DteLcnCallingNetworkFax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 23), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnCallingNetworkFax.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCallingNetworkFax.setDescription('This attribute indicates the Calling Network facilities which were signalled in the call packet. A value of null (empty string) means no calling network facilities were signalled.')
mscX25DteLcnCalledNetworkFax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 24), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 108)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnCalledNetworkFax.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCalledNetworkFax.setDescription('This attribute indicates the called network facilities which were signalled in the call packet. A value of null (empty string) means no called network facilities were signalled.')
mscX25DteLcnCallUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 11, 1, 25), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnCallUserData.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCallUserData.setDescription('This attribute indicates the user data which was signalled in the call packet. A value of null (empty string) means no user data was signalled.')
mscX25DteLcnLcnStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 12), )
if mibBuilder.loadTexts: mscX25DteLcnLcnStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnLcnStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the status for an X.25 Logical Channel.')
mscX25DteLcnLcnStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLcnIndex"))
if mibBuilder.loadTexts: mscX25DteLcnLcnStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnLcnStatusEntry.setDescription('An entry in the mscX25DteLcnLcnStatusTable.')
mscX25DteLcnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 7))).clone(namedValues=NamedValues(("closed", 2), ("calling", 3), ("dataTransfer", 4), ("clearing", 5), ("resetting", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnStatus.setDescription('This attribute indicates the current state of the logical channel.')
mscX25DteLcnCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2), ("permanentLcn", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCallDirection.setDescription('This attribute indicates the direction of the call that caused the establishment of this channel.')
mscX25DteLcnCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 12, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCalledAddress.setDescription('This attribute indicates the called X.25 address to which the call is established.')
mscX25DteLcnCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 12, 1, 5), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnCallingAddress.setDescription('This attribute indicates the calling X.25 address from which the call originated')
mscX25DteLcnOriginalCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 12, 1, 6), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnOriginalCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnOriginalCalledAddress.setDescription('This attribute indicates the X.25 address of the originally called DTE to which the call was attempted. This could be different from the value of the calledAddress attribute in the case where the original call was redirected.')
mscX25DteLcnStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13), )
if mibBuilder.loadTexts: mscX25DteLcnStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational statistics for an X.25 Logical Channel.')
mscX25DteLcnStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLcnIndex"))
if mibBuilder.loadTexts: mscX25DteLcnStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnStatsEntry.setDescription('An entry in the mscX25DteLcnStatsTable.')
mscX25DteLcnInUknownProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInUknownProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInUknownProtocols.setDescription('This attribute counts the number packets received from link which were discareded because of an unkown or unsupported protocols.')
mscX25DteLcnInDataOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInDataOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInDataOctets.setDescription('This attribute counts the number of octets of user data received from the link.')
mscX25DteLcnInDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInDataPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInDataPackets.setDescription('This attribute counts the number of data packets received from the link.')
mscX25DteLcnInRmtInitiatedRsts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInRmtInitiatedRsts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInRmtInitiatedRsts.setDescription("This attribute counts the number of reset packets, with a cause code of 'DTE initiated', which were received from the link")
mscX25DteLcnInPrvdrInitiatedRsts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInPrvdrInitiatedRsts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInPrvdrInitiatedRsts.setDescription("This attribute counts the number of reset packets, with a cause code other than 'DTE initiated', which were received from the link.")
mscX25DteLcnInInterruptPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnInInterruptPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnInInterruptPackets.setDescription('This attribute counts the number of interrupt packets received from the link.')
mscX25DteLcnOutDataOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnOutDataOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnOutDataOctets.setDescription('This attribute counts the number of octets of user data sent to the link.')
mscX25DteLcnOutDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnOutDataPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnOutDataPackets.setDescription('This attribute counts the number of data packets sent to link.')
mscX25DteLcnOutInterruptPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnOutInterruptPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnOutInterruptPackets.setDescription('This attribute counts the number of interrupt packets sent to link.')
mscX25DteLcnT22ResetTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 4, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLcnT22ResetTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLcnT22ResetTimeouts.setDescription('This attribute counts the number of times the t22 reset timer has expired.')
mscX25DteLapb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5))
mscX25DteLapbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 1), )
if mibBuilder.loadTexts: mscX25DteLapbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbRowStatusTable.setDescription('This entry controls the addition and deletion of mscX25DteLapb components.')
mscX25DteLapbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"))
if mibBuilder.loadTexts: mscX25DteLapbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbRowStatusEntry.setDescription('A single entry in the table represents a single mscX25DteLapb component.')
mscX25DteLapbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscX25DteLapb components. These components cannot be added nor deleted.')
mscX25DteLapbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscX25DteLapbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStorageType.setDescription('This variable represents the storage type value for the mscX25DteLapb tables.')
mscX25DteLapbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscX25DteLapbIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbIndex.setDescription('This variable represents the index for the mscX25DteLapb tables.')
mscX25DteLapbCpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10), )
if mibBuilder.loadTexts: mscX25DteLapbCpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbCpTable.setDescription('X25Dte/n Lapb This group contains the set of configuration parameters for the LAPB interface.')
mscX25DteLapbCpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"))
if mibBuilder.loadTexts: mscX25DteLapbCpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbCpEntry.setDescription('An entry in the mscX25DteLapbCpTable.')
mscX25DteLapbStationType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2))).clone('dte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbStationType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStationType.setDescription('This attribute specifies the DCE or the DTE role of operation for the LAPB interface. Changing this attribute will cause the lapb link to Reset.')
mscX25DteLapbFrameSequencing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("modulo8", 1), ("modulo128", 2))).clone('modulo8')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbFrameSequencing.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFrameSequencing.setDescription('This attribute specifies the modulo of the frame sequence numbering of the LAPB interface. Changing this attribute will cause the lapb link to Reset.')
mscX25DteLapbN1FrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(40, 32856)).clone(32856)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbN1FrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbN1FrameSize.setDescription('This attribute specifies the maximum frame size in bits that can be transmitted or received. This value must be greater than or equal to the maximum packet size across the interface(in bits)+ max level 3 header size(in bits)+ max level 2 header size(in bits)+ crc in bits. (max Pkt size + -------------> 4096*8 max level 3 header size + ---> 4*8 level 2 header size + --------> 5*8 crc -------------------> 2*8)')
mscX25DteLapbKWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbKWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbKWindowSize.setDescription('This attribute specifies the window size. This is the maximum number of unacknowledged sequenced frames that may be outstanding from or to this interface at any one time. A window size of greater than 7 is only valid when the sequence numbering of frames is modulo 128.')
mscX25DteLapbN2TransmitLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbN2TransmitLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbN2TransmitLimit.setDescription('This attribute specifies the maximum number of times a frame can be transmitted before appropriate recovery action is taken.')
mscX25DteLapbT1AckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 10000)).clone(3000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbT1AckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbT1AckTimer.setDescription('This attribute specifies the period in milliseconds within which an acknowledgment of a sent frame must be received. The value set for t1 ack timer must be less than the value set for the t4 idle probe timer.')
mscX25DteLapbT2AckDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbT2AckDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbT2AckDelayTimer.setDescription('This attribute specifies the maximum period in milliseconds permissible to wait before sending an acknowledgment for a received in sequenced I-frame. A value of 0 means there will be no delay in acknowledgment.')
mscX25DteLapbT4IdleProbeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbT4IdleProbeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbT4IdleProbeTimer.setDescription('This attribute specifies the time period in milliseconds the link will be permitted to remain idle (that is, no frames are exchanged on the data link). Upon expiry of this timer, LAPB will poll its peer for status. The value set for t4 idle probe timer must be greater than the value set for the t1 ack timer.')
mscX25DteLapbActionInitiate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("sendSABM", 1), ("sendDM", 3), ("none", 4))).clone('sendSABM')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbActionInitiate.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbActionInitiate.setDescription('This attribute specifies the action to be taken by the LAPB interface to initiate link setup.')
mscX25DteLapbActionRecvDM = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("sendSABM", 1))).clone('sendSABM')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbActionRecvDM.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbActionRecvDM.setDescription('This attribute specifies the action to be taken by the LAPB interface when it receives a DM response.')
mscX25DteLapbTxQDegradeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(65536)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbTxQDegradeThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbTxQDegradeThreshold.setDescription('This attribute specifies the threshold of the number of higher layer packets queued, beyond which LAPB should initiate a service degrade alarm. A value of 65536 means no threshold.')
mscX25DteLapbTxQResetThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 10, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(65536)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbTxQResetThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbTxQResetThreshold.setDescription('This attribute specifies the threshold of the number of higher layer packets queued, beyond which LAPB should initiate an overload alarm and reset the link. A value of 65536 means no threshold.')
mscX25DteLapbStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 11), )
if mibBuilder.loadTexts: mscX25DteLapbStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscX25DteLapbStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"))
if mibBuilder.loadTexts: mscX25DteLapbStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStateEntry.setDescription('An entry in the mscX25DteLapbStateTable.')
mscX25DteLapbAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscX25DteLapbOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscX25DteLapbUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscX25DteLapbStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 12), )
if mibBuilder.loadTexts: mscX25DteLapbStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStatusTable.setDescription('This group contains the status for the LAPB interface.')
mscX25DteLapbStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"))
if mibBuilder.loadTexts: mscX25DteLapbStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStatusEntry.setDescription('An entry in the mscX25DteLapbStatusTable.')
mscX25DteLapbCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7))).clone(namedValues=NamedValues(("disconnected", 1), ("linkSetup", 2), ("frameReject", 3), ("disconnectRequest", 4), ("informationTransfer", 5), ("waitingAck", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbCurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbCurrentState.setDescription('This attribute specifies the current state of the LAPB interface.')
mscX25DteLapbLastStateChangeReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("notStarted", 1), ("abmEntered", 2), ("abmeEntered", 3), ("abmReset", 4), ("abmeReset", 5), ("dmReceived", 6), ("dmSent", 7), ("discReceived", 8), ("discSent", 9), ("frmrReceived", 10), ("frmrSent", 11), ("n2TimeOut", 12), ("other", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbLastStateChangeReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbLastStateChangeReason.setDescription('This attribute specifies the reason for the most recent state change.')
mscX25DteLapbFrmrTransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 12, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 7)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFrmrTransmit.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFrmrTransmit.setDescription('This attribute specifies the Information field of the FRMR most recently sent.')
mscX25DteLapbFrmrReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 12, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 7)).clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFrmrReceive.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFrmrReceive.setDescription('This attribute specifies the Information field of the FRMR most recently received.')
mscX25DteLapbCurrentQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbCurrentQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbCurrentQueueSize.setDescription('This attribute specifies the number of packets on the lapb transmit queue.')
mscX25DteLapbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 13), )
if mibBuilder.loadTexts: mscX25DteLapbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStatsTable.setDescription('This group contains the statistics for the LAPB interface.')
mscX25DteLapbStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"))
if mibBuilder.loadTexts: mscX25DteLapbStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStatsEntry.setDescription('An entry in the mscX25DteLapbStatsTable.')
mscX25DteLapbStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbStateChanges.setDescription("This attribute counts the number of times LAPB state has changed. Refer to the attribute 'linkState' for the set of possible states.")
mscX25DteLapbRemoteBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbRemoteBusy.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbRemoteBusy.setDescription('This attribute counts the number of times transmission of an I-frame was un-successful due to a perceived remote busy condition (window closed or remote busy).')
mscX25DteLapbTransmitRejectFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbTransmitRejectFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbTransmitRejectFrames.setDescription('This attribute counts the number of REJ frames sent by the interface.')
mscX25DteLapbReceiveRejectFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbReceiveRejectFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbReceiveRejectFrames.setDescription('This attribute counts the number of REJ frames received by the interface.')
mscX25DteLapbT1AckTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbT1AckTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbT1AckTimeout.setDescription('This attribute counts the number of times the T1 timer has expired.')
mscX25DteLapbFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2))
mscX25DteLapbFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 1), )
if mibBuilder.loadTexts: mscX25DteLapbFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscX25DteLapbFramer components.')
mscX25DteLapbFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbFramerIndex"))
if mibBuilder.loadTexts: mscX25DteLapbFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscX25DteLapbFramer component.')
mscX25DteLapbFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscX25DteLapbFramer components. These components cannot be added nor deleted.')
mscX25DteLapbFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscX25DteLapbFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerStorageType.setDescription('This variable represents the storage type value for the mscX25DteLapbFramer tables.')
mscX25DteLapbFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscX25DteLapbFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerIndex.setDescription('This variable represents the index for the mscX25DteLapbFramer tables.')
mscX25DteLapbFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 10), )
if mibBuilder.loadTexts: mscX25DteLapbFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscX25DteLapbFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbFramerIndex"))
if mibBuilder.loadTexts: mscX25DteLapbFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerProvEntry.setDescription('An entry in the mscX25DteLapbFramerProvTable.')
mscX25DteLapbFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscX25DteLapbFramerLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 11), )
if mibBuilder.loadTexts: mscX25DteLapbFramerLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerLinkTable.setDescription('This group contains attributes defining the framing of data on the link interface.')
mscX25DteLapbFramerLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbFramerIndex"))
if mibBuilder.loadTexts: mscX25DteLapbFramerLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerLinkEntry.setDescription('An entry in the mscX25DteLapbFramerLinkTable.')
mscX25DteLapbFramerFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteLapbFramerFlagsBetweenFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerFlagsBetweenFrames.setDescription('This attribute defines the number of flags that are inserted between frames sent to the link interface.')
mscX25DteLapbFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 12), )
if mibBuilder.loadTexts: mscX25DteLapbFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscX25DteLapbFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbFramerIndex"))
if mibBuilder.loadTexts: mscX25DteLapbFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerStateEntry.setDescription('An entry in the mscX25DteLapbFramerStateTable.')
mscX25DteLapbFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscX25DteLapbFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscX25DteLapbFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscX25DteLapbFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13), )
if mibBuilder.loadTexts: mscX25DteLapbFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscX25DteLapbFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbFramerIndex"))
if mibBuilder.loadTexts: mscX25DteLapbFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerStatsEntry.setDescription('An entry in the mscX25DteLapbFramerStatsTable.')
mscX25DteLapbFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerFrmToIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscX25DteLapbFramerFrmToIf.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscX25DteLapbFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerFrmFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscX25DteLapbFramerFrmFromIf.setDescription('The number of frames received from the link interface by Framer.')
mscX25DteLapbFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerOctetFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscX25DteLapbFramerOctetFromIf.setDescription('The number of bytes received from the link interface by Framer.')
mscX25DteLapbFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerAborts.setDescription('This attribute is the total number of aborts received.')
mscX25DteLapbFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerCrcErrors.setDescription('This attribute is the total number of frames with CRC errors, occurring in the receive direction from the link.')
mscX25DteLapbFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerLrcErrors.setDescription('This attribute is the total number of frames with LRC errors, occurring in the Tx link prior to transmission onto the link.')
mscX25DteLapbFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerNonOctetErrors.setDescription('This attribute is the total number of frames that were non octet aligned.')
mscX25DteLapbFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerOverruns.setDescription('This attribute is the total number of frames received from the link for which overruns occurred.')
mscX25DteLapbFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerUnderruns.setDescription('This attribute is the total number of frames transmitted to the link for which underruns occurred.')
mscX25DteLapbFramerFrmToIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerFrmToIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerFrmToIf64.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscX25DteLapbFramerFrmFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerFrmFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerFrmFromIf64.setDescription('The number of frames received from the link interface by Framer.')
mscX25DteLapbFramerOctetFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 13, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerOctetFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerOctetFromIf64.setDescription('The number of bytes received from the link interface by Framer.')
mscX25DteLapbFramerUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 14), )
if mibBuilder.loadTexts: mscX25DteLapbFramerUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerUtilTable.setDescription('This group contains the link utilizaiton operational data for a Framer component.')
mscX25DteLapbFramerUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteLapbFramerIndex"))
if mibBuilder.loadTexts: mscX25DteLapbFramerUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerUtilEntry.setDescription('An entry in the mscX25DteLapbFramerUtilTable.')
mscX25DteLapbFramerNormPrioLinkUtilToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 14, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerNormPrioLinkUtilToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerNormPrioLinkUtilToIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) sent to the link as a percentage of the available bandwidth on the link. Note that this includes traffic with Transfer Priorities of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscX25DteLapbFramerNormPrioLinkUtilFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 5, 2, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteLapbFramerNormPrioLinkUtilFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteLapbFramerNormPrioLinkUtilFromIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) received from the link as a percentage of the available bandwidth on the link. Note that this includes traffic with Transfer Priorities of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscX25DtePle = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6))
mscX25DtePleRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 1), )
if mibBuilder.loadTexts: mscX25DtePleRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleRowStatusTable.setDescription('This entry controls the addition and deletion of mscX25DtePle components.')
mscX25DtePleRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePleIndex"))
if mibBuilder.loadTexts: mscX25DtePleRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleRowStatusEntry.setDescription('A single entry in the table represents a single mscX25DtePle component.')
mscX25DtePleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePleRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscX25DtePle components. These components cannot be added nor deleted.')
mscX25DtePleComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePleComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscX25DtePleStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePleStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleStorageType.setDescription('This variable represents the storage type value for the mscX25DtePle tables.')
mscX25DtePleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscX25DtePleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleIndex.setDescription('This variable represents the index for the mscX25DtePle tables.')
mscX25DtePleProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 10), )
if mibBuilder.loadTexts: mscX25DtePleProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleProvTable.setDescription('This group contains the provisionable attributes relevant to an interface used to carry Multiprotocol Interconnect traffic over X.25.')
mscX25DtePleProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePleIndex"))
if mibBuilder.loadTexts: mscX25DtePleProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleProvEntry.setDescription('An entry in the mscX25DtePleProvTable.')
mscX25DtePleInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536000)).clone(180000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DtePleInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleInactivityTimer.setDescription('This attribute specifies the period in milliseconds this interface will keep an idle connection open before closing it.')
mscX25DtePleOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 11), )
if mibBuilder.loadTexts: mscX25DtePleOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleOpTable.setDescription('This group contains the Operational attributes relevant to an interface used to carry Multiprotocol Interconnect traffic over X.25.')
mscX25DtePleOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DtePleIndex"))
if mibBuilder.loadTexts: mscX25DtePleOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleOpEntry.setDescription('An entry in the mscX25DtePleOpTable.')
mscX25DtePleEncAddrToX25LkupFlrs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePleEncAddrToX25LkupFlrs.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleEncAddrToX25LkupFlrs.setDescription('This attribute indicates the number of times a translation attempt from an Encapsulation address to an X.25 address failed to find a corresponding X.25 address. Such a failure could occur when a Protocol Port, linked to a RemoteGroup via the linkToProtocolPort attribute of the RemoteGroup, requests through the software that a X.25 call be established to a particular Encapsulation address. If the RemoteGroup does not have a Peer component linked in its linkToPeer attribute list, with the encAddress attribute equal to the Encapsulation address specified, this counter will be incremented, because the corresponding Peer component needed to establish an X.25 connection was not found.')
mscX25DtePleLastFailedEncAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 11, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(2, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePleLastFailedEncAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleLastFailedEncAddr.setDescription('This attribute indicates the last Encapsulation address for which no corresponding X.25 address was found and thus caused encAddressToX25LkupFlrs to be incremented.')
mscX25DtePleX25AddrToEncLkupFlrs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePleX25AddrToEncLkupFlrs.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleX25AddrToEncLkupFlrs.setDescription('This attribute indicates the number of times a translation attempt from an X.25 address to an Encapsulation address failed to find a corresponding Encapsulation address. Such a failure could occur when a incoming call received from the link by the X.25 DTE is directed to a specific RemoteGroup because the called address matches the localAddress attribute of the RemoteGroup component. If the RemoteGroup component does not have a Peer component linked in its linkToPeer attribute list, with the x25Address attribute equal to the calling address from the incoming call packet, there is no appropriate Peer component, so the call is cleared and this counter is incremented.')
mscX25DtePleLastFailedX25Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 6, 11, 1, 5), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DtePleLastFailedX25Addr.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DtePleLastFailedX25Addr.setDescription('This field specifies the last X.25 address that caused x25AddressToEncLkupFlrs to be incremented.')
mscX25DteRg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7))
mscX25DteRgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 1), )
if mibBuilder.loadTexts: mscX25DteRgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgRowStatusTable.setDescription('This entry controls the addition and deletion of mscX25DteRg components.')
mscX25DteRgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgIndex"))
if mibBuilder.loadTexts: mscX25DteRgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgRowStatusEntry.setDescription('A single entry in the table represents a single mscX25DteRg component.')
mscX25DteRgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscX25DteRg components. These components can be added and deleted.')
mscX25DteRgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteRgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscX25DteRgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteRgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgStorageType.setDescription('This variable represents the storage type value for the mscX25DteRg tables.')
mscX25DteRgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023)))
if mibBuilder.loadTexts: mscX25DteRgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgIndex.setDescription('This variable represents the index for the mscX25DteRg tables.')
mscX25DteRgIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 10), )
if mibBuilder.loadTexts: mscX25DteRgIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscX25DteRgIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgIndex"))
if mibBuilder.loadTexts: mscX25DteRgIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgIfEntryEntry.setDescription('An entry in the mscX25DteRgIfEntryTable.')
mscX25DteRgIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRgIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscX25DteRgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 10, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteRgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscX25DteRgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 11), )
if mibBuilder.loadTexts: mscX25DteRgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgProvTable.setDescription('This group contains the provisionable attributes of the RemoteGroup component.')
mscX25DteRgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgIndex"))
if mibBuilder.loadTexts: mscX25DteRgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgProvEntry.setDescription('An entry in the mscX25DteRgProvTable.')
mscX25DteRgLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 11, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRgLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLinkToProtocolPort.setDescription('This attribute contains a protocol port component name. The attribute associates the application with a protocol port.')
mscX25DteRgLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 11, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRgLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLocalAddress.setDescription('This attribute contains the unique X.25 address which identifies this RemoteGroup. It should correspond to the called address in X.25 incoming call packets which are to be directed to this RemoteGroup. This allows calls received from the link to be directed to the appropriate RemoteGroup based on the called address in the X.25 call packet. The RemoteGroup components allow the X.25 interface to be shared amongst a number of Protocol Ports (and ultimately Virtual Routers) because each RemoteGroup is coupled with a specific ProtocolPort through its linkToProtocolPort attribute.')
mscX25DteRgMtuSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(576, 9188)).clone(1600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRgMtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgMtuSize.setDescription('This attribute specifies the Maximum Transmit Unit (MTU); that is, the size of the largest datagram (in octets) which can be sent/ received on the interface.')
mscX25DteRgStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 12), )
if mibBuilder.loadTexts: mscX25DteRgStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscX25DteRgStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgIndex"))
if mibBuilder.loadTexts: mscX25DteRgStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgStateEntry.setDescription('An entry in the mscX25DteRgStateTable.')
mscX25DteRgAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteRgAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscX25DteRgOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteRgOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscX25DteRgUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteRgUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscX25DteRgOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 13), )
if mibBuilder.loadTexts: mscX25DteRgOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscX25DteRgOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgIndex"))
if mibBuilder.loadTexts: mscX25DteRgOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgOperStatusEntry.setDescription('An entry in the mscX25DteRgOperStatusTable.')
mscX25DteRgSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteRgSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscX25DteRgLTPlcnTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 210), )
if mibBuilder.loadTexts: mscX25DteRgLTPlcnTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLTPlcnTable.setDescription('This attribute is a list of links to PermLcn components. The set of all Peer and PermLcn components which link to a given RemoteGroup determine the subset of remote hosts which are accessible to a particular Protocol Port (and ultimately a Virtual Router).')
mscX25DteRgLTPlcnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 210, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgLTPlcnValue"))
if mibBuilder.loadTexts: mscX25DteRgLTPlcnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLTPlcnEntry.setDescription('An entry in the mscX25DteRgLTPlcnTable.')
mscX25DteRgLTPlcnValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 210, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRgLTPlcnValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLTPlcnValue.setDescription('This variable represents both the value and the index for the mscX25DteRgLTPlcnTable.')
mscX25DteRgLTPlcnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 210, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscX25DteRgLTPlcnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLTPlcnRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscX25DteRgLTPlcnTable.')
mscX25DteRgLtPeerTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 211), )
if mibBuilder.loadTexts: mscX25DteRgLtPeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLtPeerTable.setDescription('This attribute gives a list of links to Peer components. The set of all Peer and PermLcn components which link to a given RemoteGroup determine the subset of remote hosts which are accessible to a particular Protocol Port (and ultimately a Virtual Router).')
mscX25DteRgLtPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 211, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgLtPeerValue"))
if mibBuilder.loadTexts: mscX25DteRgLtPeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLtPeerEntry.setDescription('An entry in the mscX25DteRgLtPeerTable.')
mscX25DteRgLtPeerValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 211, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscX25DteRgLtPeerValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLtPeerValue.setDescription('This variable represents both the value and the index for the mscX25DteRgLtPeerTable.')
mscX25DteRgLtPeerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 211, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscX25DteRgLtPeerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLtPeerRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscX25DteRgLtPeerTable.')
mscX25DteRgLcnTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 212), )
if mibBuilder.loadTexts: mscX25DteRgLcnTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLcnTable.setDescription('This attribute lists the Lcn components for the X25Dte, which belong to this RemoteGroup. There is an Lcn component listed here for every lcn connection belonging to this RemoteGroup. The lcns were established using either a Peer component linked to this RemoteGroup (in response to a switched call) or using a PermLcn component linked to this RemoteGroup (a permanent connection).')
mscX25DteRgLcnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 212, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgIndex"), (0, "Nortel-MsCarrier-MscPassport-X25DteMIB", "mscX25DteRgLcnValue"))
if mibBuilder.loadTexts: mscX25DteRgLcnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLcnEntry.setDescription('An entry in the mscX25DteRgLcnTable.')
mscX25DteRgLcnValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 90, 7, 212, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscX25DteRgLcnValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscX25DteRgLcnValue.setDescription('This variable represents both the value and the index for the mscX25DteRgLcnTable.')
x25DteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48, 1))
x25DteGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48, 1, 1))
x25DteGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48, 1, 1, 3))
x25DteGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48, 1, 1, 3, 2))
x25DteCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48, 3))
x25DteCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48, 3, 1))
x25DteCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48, 3, 1, 3))
x25DteCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 48, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-X25DteMIB", mscX25DteLapbFramerUnderruns=mscX25DteLapbFramerUnderruns, mscX25DtePleOpTable=mscX25DtePleOpTable, mscX25DteLapbT1AckTimer=mscX25DteLapbT1AckTimer, mscX25DtePLcnProvTable=mscX25DtePLcnProvTable, mscX25DteLcnOutPacketSize=mscX25DteLcnOutPacketSize, mscX25DteLapbFramerStatsEntry=mscX25DteLapbFramerStatsEntry, mscX25DtePeer=mscX25DtePeer, mscX25DtePLcnProvEntry=mscX25DtePLcnProvEntry, mscX25DtePLcnOutPacketSize=mscX25DtePLcnOutPacketSize, mscX25DteT22ResetTimeouts=mscX25DteT22ResetTimeouts, mscX25DtePLcnComponentName=mscX25DtePLcnComponentName, mscX25DteLcnInWindowSize=mscX25DteLcnInWindowSize, mscX25DteLapbFramerOctetFromIf64=mscX25DteLapbFramerOctetFromIf64, mscX25DtePeerLinkToRemoteGroup=mscX25DtePeerLinkToRemoteGroup, mscX25DteRowStatusEntry=mscX25DteRowStatusEntry, mscX25DteRgIfEntryTable=mscX25DteRgIfEntryTable, mscX25DteRgLTPlcnRowStatus=mscX25DteRgLTPlcnRowStatus, mscX25DtePleComponentName=mscX25DtePleComponentName, mscX25DteLcnRowStatusTable=mscX25DteLcnRowStatusTable, mscX25DteCidDataEntry=mscX25DteCidDataEntry, mscX25DteRgStateTable=mscX25DteRgStateTable, mscX25DteLcnRowStatus=mscX25DteLcnRowStatus, mscX25DtePLcnProtocolEncType=mscX25DtePLcnProtocolEncType, mscX25DteLapbT2AckDelayTimer=mscX25DteLapbT2AckDelayTimer, mscX25DteLapbFramerUtilTable=mscX25DteLapbFramerUtilTable, x25DteGroupCA=x25DteGroupCA, mscX25DtePleX25AddrToEncLkupFlrs=mscX25DtePleX25AddrToEncLkupFlrs, mscX25DteLapbFramer=mscX25DteLapbFramer, mscX25DteLcnInThroughputClassSize=mscX25DteLcnInThroughputClassSize, mscX25DtePeerPEncRowStatus=mscX25DtePeerPEncRowStatus, mscX25DtePeerStorageType=mscX25DtePeerStorageType, mscX25DtePleLastFailedEncAddr=mscX25DtePleLastFailedEncAddr, mscX25DteRgLTPlcnValue=mscX25DteRgLTPlcnValue, mscX25DteLcnComponentName=mscX25DteLcnComponentName, mscX25DteLcnStateTable=mscX25DteLcnStateTable, mscX25DteLowestILChannelNumber=mscX25DteLowestILChannelNumber, mscX25DteLcnOriginalCalledAddress=mscX25DteLcnOriginalCalledAddress, mscX25DteRgStateEntry=mscX25DteRgStateEntry, mscX25DteT20RestartTimer=mscX25DteT20RestartTimer, mscX25DteLapbTxQDegradeThreshold=mscX25DteLapbTxQDegradeThreshold, mscX25DteIndex=mscX25DteIndex, mscX25DteInWindowSize=mscX25DteInWindowSize, mscX25DtePLcnInWindowSize=mscX25DtePLcnInWindowSize, mscX25DteRgLtPeerEntry=mscX25DteRgLtPeerEntry, mscX25DteLapbStationType=mscX25DteLapbStationType, mscX25DteOutActiveChannels=mscX25DteOutActiveChannels, mscX25DteLcnCpTable=mscX25DteLcnCpTable, mscX25DtePleInactivityTimer=mscX25DtePleInactivityTimer, mscX25DteLapbFramerFlagsBetweenFrames=mscX25DteLapbFramerFlagsBetweenFrames, mscX25DtePle=mscX25DtePle, mscX25DtePleLastFailedX25Addr=mscX25DtePleLastFailedX25Addr, mscX25DteLapbFrameSequencing=mscX25DteLapbFrameSequencing, mscX25DteLcnCalledAddress=mscX25DteLcnCalledAddress, mscX25DtePleStorageType=mscX25DtePleStorageType, mscX25DtePeerChargingInformation=mscX25DtePeerChargingInformation, mscX25DteLowestOLChannelNumber=mscX25DteLowestOLChannelNumber, mscX25DteT23ClearTimer=mscX25DteT23ClearTimer, mscX25DteStateEntry=mscX25DteStateEntry, mscX25DtePLcnOutWindowSize=mscX25DtePLcnOutWindowSize, mscX25DtePLcnIndex=mscX25DtePLcnIndex, mscX25DteLapbFramerNonOctetErrors=mscX25DteLapbFramerNonOctetErrors, mscX25DteRgLtPeerTable=mscX25DteRgLtPeerTable, mscX25DteLapbActionInitiate=mscX25DteLapbActionInitiate, mscX25DteLapbTransmitRejectFrames=mscX25DteLapbTransmitRejectFrames, mscX25DteLcnStatsTable=mscX25DteLcnStatsTable, mscX25DteUsageState=mscX25DteUsageState, mscX25DtePLcn=mscX25DtePLcn, mscX25DteLapbFramerCrcErrors=mscX25DteLapbFramerCrcErrors, mscX25DtePeerPEncEntry=mscX25DtePeerPEncEntry, mscX25DteLcnStatsEntry=mscX25DteLcnStatsEntry, mscX25DteRgLcnValue=mscX25DteRgLcnValue, mscX25DteLcnCallUserData=mscX25DteLcnCallUserData, mscX25DteRgSnmpOperStatus=mscX25DteRgSnmpOperStatus, mscX25DteCalledNetworkFax=mscX25DteCalledNetworkFax, mscX25DteIfIndex=mscX25DteIfIndex, x25DteMIB=x25DteMIB, mscX25DteLapbStatsEntry=mscX25DteLapbStatsEntry, mscX25DteLapbActionRecvDM=mscX25DteLapbActionRecvDM, mscX25DteProposeReverseCharging=mscX25DteProposeReverseCharging, mscX25DteRgLtPeerRowStatus=mscX25DteRgLtPeerRowStatus, mscX25DteLapbFrmrReceive=mscX25DteLapbFrmrReceive, mscX25DteLcnInPrvdrInitiatedRsts=mscX25DteLcnInPrvdrInitiatedRsts, mscX25DteLcnCallingNetworkFax=mscX25DteLcnCallingNetworkFax, mscX25DteStorageType=mscX25DteStorageType, mscX25DteDcpTable=mscX25DteDcpTable, mscX25DteLapbAdminState=mscX25DteLapbAdminState, mscX25DteLcnInPacketSize=mscX25DteLcnInPacketSize, mscX25DtePleRowStatusEntry=mscX25DtePleRowStatusEntry, mscX25DtePeerProposeReverseCharging=mscX25DtePeerProposeReverseCharging, mscX25DtePleProvTable=mscX25DtePleProvTable, mscX25DteRgIfEntryEntry=mscX25DteRgIfEntryEntry, mscX25DteComponentName=mscX25DteComponentName, mscX25DteLcnT22ResetTimeouts=mscX25DteLcnT22ResetTimeouts, mscX25DteIfTable=mscX25DteIfTable, mscX25DteTwowayActiveChannels=mscX25DteTwowayActiveChannels, mscX25DteRgLTPlcnEntry=mscX25DteRgLTPlcnEntry, mscX25DtePeerCalledNetworkFax=mscX25DtePeerCalledNetworkFax, mscX25DteLcnOutThroughputClassSize=mscX25DteLcnOutThroughputClassSize, x25DteCapabilitiesCA02A=x25DteCapabilitiesCA02A, mscX25DteRgLTPlcnTable=mscX25DteRgLTPlcnTable, mscX25DteLcnInDataOctets=mscX25DteLcnInDataOctets, mscX25DtePeerCpEntry=mscX25DtePeerCpEntry, mscX25DteLcnAdminState=mscX25DteLcnAdminState, mscX25DteLapbIndex=mscX25DteLapbIndex, mscX25DtePeerX25Address=mscX25DtePeerX25Address, mscX25DteLapbFramerFrmFromIf=mscX25DteLapbFramerFrmFromIf, mscX25DteIfEntry=mscX25DteIfEntry, mscX25DteLcnNetworkUserIdentifier=mscX25DteLcnNetworkUserIdentifier, mscX25DteRg=mscX25DteRg, mscX25DteLcnCEntry=mscX25DteLcnCEntry, mscX25DteLapbFramerLrcErrors=mscX25DteLapbFramerLrcErrors, mscX25DtePeerPEncValue=mscX25DtePeerPEncValue, mscX25DteRpoa=mscX25DteRpoa, mscX25DtePeerCugIndex=mscX25DtePeerCugIndex, mscX25DteLcnOutDataOctets=mscX25DteLcnOutDataOctets, mscX25DteLcnCalledNetworkFax=mscX25DteLcnCalledNetworkFax, mscX25DteT21CallTimeouts=mscX25DteT21CallTimeouts, mscX25DteLapbN2TransmitLimit=mscX25DteLapbN2TransmitLimit, mscX25DteInPrvdrInitiatedClrs=mscX25DteInPrvdrInitiatedClrs, mscX25DteLapbFramerProvEntry=mscX25DteLapbFramerProvEntry, mscX25DteLcnCallDirection=mscX25DteLcnCallDirection, mscX25DteCugIndex=mscX25DteCugIndex, mscX25DtePeerLcnEntry=mscX25DtePeerLcnEntry, mscX25DteLapbStorageType=mscX25DteLapbStorageType, mscX25DtePeerEncAddressType=mscX25DtePeerEncAddressType, mscX25DteLcn=mscX25DteLcn, mscX25DteHighestILChannelNumber=mscX25DteHighestILChannelNumber, x25DteCapabilitiesCA=x25DteCapabilitiesCA, mscX25DteAdminState=mscX25DteAdminState, mscX25DteRgAdminState=mscX25DteRgAdminState, mscX25DtePleEncAddrToX25LkupFlrs=mscX25DtePleEncAddrToX25LkupFlrs, mscX25DteLapbFramerUtilEntry=mscX25DteLapbFramerUtilEntry, mscX25DteLcnStateEntry=mscX25DteLcnStateEntry, mscX25DteRgIfIndex=mscX25DteRgIfIndex, mscX25DteLapbRowStatusTable=mscX25DteLapbRowStatusTable, mscX25DtePeerOutPacketSize=mscX25DtePeerOutPacketSize, mscX25DteLapbCurrentState=mscX25DteLapbCurrentState, mscX25DteOutInterruptPackets=mscX25DteOutInterruptPackets, mscX25DteInPacketSize=mscX25DteInPacketSize, mscX25DtePacketSequencing=mscX25DtePacketSequencing, mscX25DteStatsEntry=mscX25DteStatsEntry, mscX25DteOutCallFailures=mscX25DteOutCallFailures, mscX25DtePeerPEncIndex=mscX25DtePeerPEncIndex, mscX25DteInCalls=mscX25DteInCalls, mscX25DtePLcnEncAddressType=mscX25DtePLcnEncAddressType, mscX25DteSnmpOperStatus=mscX25DteSnmpOperStatus, mscX25DtePLcnInPacketSize=mscX25DtePLcnInPacketSize, mscX25DtePleIndex=mscX25DtePleIndex, mscX25DteTrnstDlySlctnAInd=mscX25DteTrnstDlySlctnAInd, mscX25DteOutDataPackets=mscX25DteOutDataPackets, mscX25DteLapbFramerStateTable=mscX25DteLapbFramerStateTable, mscX25DteDcpEntry=mscX25DteDcpEntry, mscX25DtePeerRowStatusEntry=mscX25DtePeerRowStatusEntry, mscX25DtePeerRpoa=mscX25DtePeerRpoa, mscX25DtePeerIfTable=mscX25DtePeerIfTable, mscX25DteRowStatusTable=mscX25DteRowStatusTable, mscX25DteLapbCpTable=mscX25DteLapbCpTable, mscX25DteLapbStateChanges=mscX25DteLapbStateChanges, mscX25DteOperationalState=mscX25DteOperationalState, mscX25DteLapbRemoteBusy=mscX25DteLapbRemoteBusy, mscX25DtePLcnLinkToRemoteGroup=mscX25DtePLcnLinkToRemoteGroup, mscX25Dte=mscX25Dte, mscX25DteRgOperationalState=mscX25DteRgOperationalState, mscX25DtePeerOutWindowSize=mscX25DtePeerOutWindowSize, mscX25DtePeerCallUserData=mscX25DtePeerCallUserData, mscX25DteRgProvEntry=mscX25DteRgProvEntry, mscX25DtePLcnRowStatus=mscX25DtePLcnRowStatus, mscX25DteLapbFramerRowStatusEntry=mscX25DteLapbFramerRowStatusEntry, mscX25DteIfEntryEntry=mscX25DteIfEntryEntry, mscX25DteInInterruptPackets=mscX25DteInInterruptPackets, mscX25DteHighestOLChannelNumber=mscX25DteHighestOLChannelNumber, mscX25DteOpEntry=mscX25DteOpEntry, mscX25DteLapbT1AckTimeout=mscX25DteLapbT1AckTimeout, mscX25DteLcnOutInterruptPackets=mscX25DteLcnOutInterruptPackets, mscX25DteOutPacketSize=mscX25DteOutPacketSize, mscX25DtePeerCpTable=mscX25DtePeerCpTable, mscX25DteRgProvTable=mscX25DteRgProvTable, mscX25DteLcnOutDataPackets=mscX25DteLcnOutDataPackets, mscX25DtePeerIfEntry=mscX25DtePeerIfEntry, mscX25DteLapbFramerLinkEntry=mscX25DteLapbFramerLinkEntry, mscX25DteLapbFrmrTransmit=mscX25DteLapbFrmrTransmit, mscX25DtePLcnStorageType=mscX25DtePLcnStorageType, mscX25DteInCallRefusals=mscX25DteInCallRefusals, mscX25DteLcnStatus=mscX25DteLcnStatus, mscX25DtePeerEncAddress=mscX25DtePeerEncAddress, mscX25DteRgRowStatusTable=mscX25DteRgRowStatusTable, mscX25DteLapbFramerLinkTable=mscX25DteLapbFramerLinkTable, mscX25DtePeerInThroughputClassSize=mscX25DtePeerInThroughputClassSize, mscX25DteLcnStorageType=mscX25DteLcnStorageType, mscX25DteLapbStatsTable=mscX25DteLapbStatsTable, mscX25DteLcnCTable=mscX25DteLcnCTable, mscX25DteLcnRpoa=mscX25DteLcnRpoa, mscX25DtePeerCugoaIndex=mscX25DtePeerCugoaIndex, mscX25DteInActiveChannels=mscX25DteInActiveChannels, mscX25DteLapbFramerFrmToIf=mscX25DteLapbFramerFrmToIf, mscX25DteLapbFramerUsageState=mscX25DteLapbFramerUsageState, mscX25DteLapbFramerComponentName=mscX25DteLapbFramerComponentName, mscX25DteLapbCurrentQueueSize=mscX25DteLapbCurrentQueueSize, mscX25DteInPktsAcusdOfPrtclErr=mscX25DteInPktsAcusdOfPrtclErr, mscX25DteLcnInDataPackets=mscX25DteLcnInDataPackets, mscX25DteHighestTLChannelNumber=mscX25DteHighestTLChannelNumber, mscX25DteCallUserData=mscX25DteCallUserData, mscX25DteLcnCallingAddress=mscX25DteLcnCallingAddress, mscX25DteLcnInUknownProtocols=mscX25DteLcnInUknownProtocols, mscX25DteLapbOperationalState=mscX25DteLapbOperationalState, mscX25DtePeerIndex=mscX25DtePeerIndex, mscX25DteAcceptReverseCharging=mscX25DteAcceptReverseCharging, mscX25DteLapbStateEntry=mscX25DteLapbStateEntry, mscX25DteRgIfAdminStatus=mscX25DteRgIfAdminStatus, mscX25DteLcnTrnstDlySlctnAInd=mscX25DteLcnTrnstDlySlctnAInd, mscX25DteLapb=mscX25DteLapb, mscX25DteLapbLastStateChangeReason=mscX25DteLapbLastStateChangeReason, mscX25DteRgRowStatusEntry=mscX25DteRgRowStatusEntry, mscX25DtePleOpEntry=mscX25DtePleOpEntry, mscX25DteLcnLcnStatusTable=mscX25DteLcnLcnStatusTable, mscX25DteLapbN1FrameSize=mscX25DteLapbN1FrameSize, mscX25DteChargingInformation=mscX25DteChargingInformation, mscX25DteRgRowStatus=mscX25DteRgRowStatus, mscX25DteLcnIndex=mscX25DteLcnIndex, mscX25DteInPrvdrInitiatedRsts=mscX25DteInPrvdrInitiatedRsts, mscX25DteRgLocalAddress=mscX25DteRgLocalAddress, mscX25DteLcnChargingInformation=mscX25DteLcnChargingInformation, mscX25DteRgOperStatusTable=mscX25DteRgOperStatusTable, mscX25DteLcnOutWindowSize=mscX25DteLcnOutWindowSize, mscX25DteOperStatusTable=mscX25DteOperStatusTable, mscX25DteLapbFramerAdminState=mscX25DteLapbFramerAdminState, mscX25DteCidDataTable=mscX25DteCidDataTable, mscX25DteRgLinkToProtocolPort=mscX25DteRgLinkToProtocolPort, mscX25DtePLcnRowStatusEntry=mscX25DtePLcnRowStatusEntry, mscX25DteLcnLcnStatusEntry=mscX25DteLcnLcnStatusEntry, mscX25DteInRmtInitiatedRsts=mscX25DteInRmtInitiatedRsts, mscX25DteLapbFramerIndex=mscX25DteLapbFramerIndex, mscX25DteLapbFramerProvTable=mscX25DteLapbFramerProvTable, mscX25DteRgOperStatusEntry=mscX25DteRgOperStatusEntry, mscX25DteLapbRowStatusEntry=mscX25DteLapbRowStatusEntry, mscX25DteOutWindowSize=mscX25DteOutWindowSize, mscX25DteLapbRowStatus=mscX25DteLapbRowStatus, mscX25DteStateTable=mscX25DteStateTable, mscX25DtePeerCallingNetworkFax=mscX25DtePeerCallingNetworkFax, mscX25DtePeerTrnstDlySlctnAInd=mscX25DtePeerTrnstDlySlctnAInd, mscX25DteLapbFramerOverruns=mscX25DteLapbFramerOverruns, mscX25DteLcnInRmtInitiatedRsts=mscX25DteLcnInRmtInitiatedRsts, mscX25DteInterfaceMode=mscX25DteInterfaceMode, mscX25DteLapbFramerRowStatusTable=mscX25DteLapbFramerRowStatusTable, mscX25DteLapbFramerFrmFromIf64=mscX25DteLapbFramerFrmFromIf64, mscX25DteLcnCugIndex=mscX25DteLcnCugIndex, mscX25DteLapbFramerStateEntry=mscX25DteLapbFramerStateEntry, mscX25DteOpTable=mscX25DteOpTable, mscX25DtePeerLcnValue=mscX25DtePeerLcnValue, mscX25DtePeerAcceptReverseCharging=mscX25DtePeerAcceptReverseCharging, mscX25DteRowStatus=mscX25DteRowStatus, mscX25DteRgLtPeerValue=mscX25DteRgLtPeerValue, mscX25DteLapbFramerOperationalState=mscX25DteLapbFramerOperationalState, mscX25DtePeerRowStatusTable=mscX25DtePeerRowStatusTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-X25DteMIB", mscX25DteIfEntryTable=mscX25DteIfEntryTable, mscX25DtePleRowStatus=mscX25DtePleRowStatus, mscX25DteCustomerIdentifier=mscX25DteCustomerIdentifier, x25DteCapabilitiesCA02=x25DteCapabilitiesCA02, mscX25DteInThroughputClassSize=mscX25DteInThroughputClassSize, mscX25DteLapbFramerStorageType=mscX25DteLapbFramerStorageType, mscX25DteRgLcnEntry=mscX25DteRgLcnEntry, mscX25DteInterfaceState=mscX25DteInterfaceState, mscX25DteLapbStateTable=mscX25DteLapbStateTable, mscX25DtePleProvEntry=mscX25DtePleProvEntry, mscX25DteLapbFramerNormPrioLinkUtilFromIf=mscX25DteLapbFramerNormPrioLinkUtilFromIf, mscX25DteIfAdminStatus=mscX25DteIfAdminStatus, mscX25DteCugoaIndex=mscX25DteCugoaIndex, mscX25DtePeerInPacketSize=mscX25DtePeerInPacketSize, mscX25DteLapbComponentName=mscX25DteLapbComponentName, mscX25DtePLcnEncAddress=mscX25DtePLcnEncAddress, mscX25DteLcnRowStatusEntry=mscX25DteLcnRowStatusEntry, mscX25DteRgMtuSize=mscX25DteRgMtuSize, mscX25DteLapbReceiveRejectFrames=mscX25DteLapbReceiveRejectFrames, mscX25DteStatsTable=mscX25DteStatsTable, mscX25DteT23ClearTimeouts=mscX25DteT23ClearTimeouts, mscX25DteLapbStatusEntry=mscX25DteLapbStatusEntry, mscX25DteLapbCpEntry=mscX25DteLapbCpEntry, mscX25DteRgUsageState=mscX25DteRgUsageState, mscX25DteLapbTxQResetThreshold=mscX25DteLapbTxQResetThreshold, mscX25DteLapbFramerStatsTable=mscX25DteLapbFramerStatsTable, mscX25DtePLcnRowStatusTable=mscX25DtePLcnRowStatusTable, mscX25DteLapbFramerInterfaceName=mscX25DteLapbFramerInterfaceName, mscX25DteLcnCugoaIndex=mscX25DteLcnCugoaIndex, mscX25DteMaxActiveChannels=mscX25DteMaxActiveChannels, mscX25DtePeerNetworkUserIdentifier=mscX25DtePeerNetworkUserIdentifier, mscX25DtePeerRowStatus=mscX25DtePeerRowStatus, mscX25DteLowestTLChannelNumber=mscX25DteLowestTLChannelNumber, x25DteGroupCA02=x25DteGroupCA02, mscX25DteLcnOperationalState=mscX25DteLcnOperationalState, mscX25DteLapbFramerRowStatus=mscX25DteLapbFramerRowStatus, x25DteGroup=x25DteGroup, mscX25DteLcnProposeReverseCharging=mscX25DteLcnProposeReverseCharging, mscX25DteLapbUsageState=mscX25DteLapbUsageState, mscX25DtePleRowStatusTable=mscX25DtePleRowStatusTable, mscX25DteRgStorageType=mscX25DteRgStorageType, mscX25DteLapbFramerOctetFromIf=mscX25DteLapbFramerOctetFromIf, mscX25DteRgIndex=mscX25DteRgIndex, x25DteCapabilities=x25DteCapabilities, mscX25DteLcnUsageState=mscX25DteLcnUsageState, mscX25DteCallingNetworkFax=mscX25DteCallingNetworkFax, mscX25DteT22ResetTimer=mscX25DteT22ResetTimer, mscX25DteNumberOfPLcn=mscX25DteNumberOfPLcn, mscX25DteT21CallTimer=mscX25DteT21CallTimer, mscX25DtePeerOutThroughputClassSize=mscX25DtePeerOutThroughputClassSize, mscX25DtePeerPEncTable=mscX25DtePeerPEncTable, mscX25DteLapbFramerAborts=mscX25DteLapbFramerAborts, mscX25DteOutCallAttempts=mscX25DteOutCallAttempts, mscX25DteLcnFastSelect=mscX25DteLcnFastSelect, mscX25DteLcnInInterruptPackets=mscX25DteLcnInInterruptPackets, mscX25DteLapbStatusTable=mscX25DteLapbStatusTable, mscX25DteLapbKWindowSize=mscX25DteLapbKWindowSize, mscX25DtePeerInWindowSize=mscX25DtePeerInWindowSize, mscX25DteInRestarts=mscX25DteInRestarts, mscX25DtePeerComponentName=mscX25DtePeerComponentName, x25DteGroupCA02A=x25DteGroupCA02A, mscX25DteLapbT4IdleProbeTimer=mscX25DteLapbT4IdleProbeTimer, mscX25DteOperStatusEntry=mscX25DteOperStatusEntry, mscX25DteLapbFramerFrmToIf64=mscX25DteLapbFramerFrmToIf64, mscX25DteRgLcnTable=mscX25DteRgLcnTable, mscX25DtePeerLcnTable=mscX25DtePeerLcnTable, mscX25DteOutThroughputClassSize=mscX25DteOutThroughputClassSize, mscX25DteInDataPackets=mscX25DteInDataPackets, mscX25DteRgComponentName=mscX25DteRgComponentName, mscX25DteT20RestartTimeouts=mscX25DteT20RestartTimeouts, mscX25DteLapbFramerNormPrioLinkUtilToIf=mscX25DteLapbFramerNormPrioLinkUtilToIf, mscX25DteLcnCpEntry=mscX25DteLcnCpEntry)

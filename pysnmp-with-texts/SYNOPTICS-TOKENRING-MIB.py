#
# PySNMP MIB module SYNOPTICS-TOKENRING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SYNOPTICS-TOKENRING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:14:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, Integer32, Gauge32, Unsigned32, ObjectIdentity, Counter64, Bits, MibIdentifier, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter32, NotificationType, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Integer32", "Gauge32", "Unsigned32", "ObjectIdentity", "Counter64", "Bits", "MibIdentifier", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter32", "NotificationType", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
s3000TokenRing, = mibBuilder.importSymbols("SYNOPTICS-COMMON-MIB", "s3000TokenRing")
s3000TrBoard = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 2))
s3000TrPort = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3))
s3000TrNmm = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4))
s3000TrNode = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5))
s3000TrRing = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7))
s3TrRingStats = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1))
s3TrCommonBoardTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 2, 2), )
if mibBuilder.loadTexts: s3TrCommonBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrCommonBoardTable.setDescription('Information maintained for each token ring board. The information can be retrieved for any token ring board, even if the board is not on the same backplane ring as this NMM. The instance is the slot number of the concentrator that the board occupies.')
s3TrCommonBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 2, 2, 1), ).setIndexNames((0, "SYNOPTICS-TOKENRING-MIB", "s3TrCommonBoardIndex"))
if mibBuilder.loadTexts: s3TrCommonBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrCommonBoardEntry.setDescription('There is one entry per board in this table.')
s3TrCommonBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrCommonBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrCommonBoardIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization. If a board is inserted or reinserted in a concentrator then the NMM has to be reinitialized.")
s3TrCommonBoardRing1or2 = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ring1", 2), ("ring2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrCommonBoardRing1or2.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrCommonBoardRing1or2.setDescription('Determines which ring the board is currently using on the concentrator backplane.')
s3TrCommonBoardRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("speed1M", 2), ("speed4M", 3), ("speed16M", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrCommonBoardRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrCommonBoardRingSpeed.setDescription('Token Ring speed of the ring that this board is connected to.')
s3TrPortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1), )
if mibBuilder.loadTexts: s3TrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortTable.setDescription('A table containing information about each port of a LattisNet concentrator. The number of entries is given by knowing the number of occupied slots in s3ChassisSlotConfigTable whose s3SlotModuleType is of a token ring type and is on the same physical ring as the agent NMM.')
s3TrPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1), ).setIndexNames((0, "SYNOPTICS-TOKENRING-MIB", "s3TrPortBoardIndex"), (0, "SYNOPTICS-TOKENRING-MIB", "s3TrPortIndex"))
if mibBuilder.loadTexts: s3TrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortEntry.setDescription('A port entry containing objects at the port level for a particular port.')
s3TrPortBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrPortBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortBoardIndex.setDescription("A unique value for each board. Its value ranges between 1 and 12. The value for each board must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization. If a board is inserted or reinserted in a concentrator then the NMM has to be reinitialized.")
s3TrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortIndex.setDescription("A unique value for each port. Its value ranges between 1 and 12. The value for each port must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization. If the board is an NMM board it will only have 2 ports, with Port 1 being for Ring In and Port 2 being for Ring Out.")
s3TrPortWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("wrap", 2), ("connect", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3TrPortWrap.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortWrap.setDescription('Status of the port. Setting wrap(2) disconnects the port from the ring and setting this object to connect(3) connects the port to the ring.')
s3TrPortTestLatch = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3TrPortTestLatch.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortTestLatch.setDescription('Status of the test latch which is used to set the channel decoder used to monitor the health of the communication path between the NMM and the module channel.')
s3TrPortRelayStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrPortRelayStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortRelayStatus.setDescription("Status of the channel's present relay mode. On(2) means the channel is in the ring and off(3) means the channel is bypassed.")
s3TrPortPhantomStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrPortPhantomStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortPhantomStatus.setDescription('Status of the ring access request signal.')
s3TrPortPhantomChangeFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("noChange", 2), ("change", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrPortPhantomChangeFlag.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortPhantomChangeFlag.setDescription('Change(3) indicates that port phantom has been changed from OFF to ON. After inquiry by NMS, it will be cleared to noChange(2). Port phantom changing from ON to OFF has no impact on this object.')
s3TrPortChgSyn2IBM = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("synoptics", 2), ("ibm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3TrPortChgSyn2IBM.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortChgSyn2IBM.setDescription('If the port is on a ring in/ring out module this object changes the strap state depending on the jumper setting retrieved as s3TrPortStrap. If the strap is set for SynOptics phantom option, this object can be changed to ibm(3). If the strap is set for non-SynOptics option, this object can not be changed. Non ring in/ring out modules or fiber ring in/ring out modules must take on the value of notSupported(1).')
s3TrPortStrap = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("synoptics", 2), ("ibm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrPortStrap.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrPortStrap.setDescription('If the port is on a ring in/ring out module this object signifies whether the hardware jumper is in synoptics(2) mode or ibm(3) mode. This information is retrieved using a NMI command. For ports on fiber ring in/ring out modules, and those ports not on ring in/ring out modules, the agent always returns notSupported(1).')
s3TrNmmFnNum = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3TrNmmFnNum.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmFnNum.setDescription('Defines the flat network number that this NMM is part of.')
s3TrNmmRingNum = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmRingNum.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmRingNum.setDescription('Defines the segment number that this NMM is connected to.')
s3TrNmmSlotNum = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmSlotNum.setStatus('deprecated')
if mibBuilder.loadTexts: s3TrNmmSlotNum.setDescription('Defines the slot number that this NMM is connected to. New NMS implementations should use the object s3AgentMySlotId defined in the common MIB.')
s3TrNmmFpuIdRev = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmFpuIdRev.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmFpuIdRev.setDescription('The revision of the Front-end Frame Processing unit. 0=Rev. A, 1=Rev. B, etc.')
s3TrNmmFpuStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("notOperational", 2), ("operational", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmFpuStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmFpuStatus.setDescription('The status of the Front-end Frame Processing Unit.')
s3TrNmmDramSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("k512", 2), ("oneMeg", 3), ("twoMeg", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmDramSize.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmDramSize.setDescription('The highest address of the DRAM in the NMM memory map.')
s3TrNmmEepromSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("k2kby8", 2), ("k8kby8", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmEepromSize.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmEepromSize.setDescription('The size of the EEPROM in the NMM memory map.')
s3TrNmmGrpAddrFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmGrpAddrFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmGrpAddrFrmsRxOk.setDescription('Number of Group Address frames received without error by this NMM. Note: The NMM counts only Group Address frames that are addressed to its own Group Address(es).')
s3TrNmmRing1or2 = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ring1", 2), ("ring2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmRing1or2.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmRing1or2.setDescription('Determines which ring the NMM is currently using on the concentrator backplane.')
s3TrNmmRingSpeed = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("speed1M", 2), ("speed4M", 3), ("speed16M", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmRingSpeed.setDescription('Token Ring speed.')
s3TrNmmHexDisplay = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmHexDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmHexDisplay.setDescription('4 octet hex display string that is displayed on the NMM control panel.')
s3TrNmmEpromSize = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("k2kby8", 2), ("k8kby8", 3), ("k16kby8", 4), ("k32kby8", 5), ("k64kby8", 6), ("k128kby8", 7), ("k256kby8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNmmEpromSize.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNmmEpromSize.setDescription('The size of the EPROM in the NMM memory map.')
s3TrNodeTable = MibTable((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1), )
if mibBuilder.loadTexts: s3TrNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeTable.setDescription('Table containing station specific information.')
s3TrNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1), ).setIndexNames((0, "SYNOPTICS-TOKENRING-MIB", "s3TrNodeEntMacAddress"))
if mibBuilder.loadTexts: s3TrNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntry.setDescription('Entry in the table containing counters and profiling information for each node detected on the local token ring.')
s3TrNodeEntMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntMacAddress.setDescription('MAC address of node that this entry in the table is for.')
s3TrNodeEntStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("beaconing", 1), ("notBeaconing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntStatus.setDescription('Tells whether the station is currently beaconing or not.')
s3TrNodeEntNodeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntNodeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntNodeStatus.setDescription('Node status as defined in 802.5 specification (section 3.3.2.18).')
s3TrNodeLineErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeLineErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeLineErrs.setDescription('Number of line errors. Section 3.8.1 of IEEE 802.5 specification.')
s3TrNodeBurstErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeBurstErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeBurstErrs.setDescription('Number of burst errors. Section 3.8.3 of IEEE 802.5 specification.')
s3TrNodeAriFciErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeAriFciErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeAriFciErrs.setDescription('Number of ARI FCI errors. See AC errors, Section 3.8.4 of IEEE 802.5 specification.')
s3TrNodeLostFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeLostFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeLostFrames.setDescription('Number of frames lost. Section 3.8.6 of IEEE 802.5 specification.')
s3TrNodeRcvCongestErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeRcvCongestErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeRcvCongestErrs.setDescription('Number of receive congestion errors. Section 3.8.7 of IEEE 802.5 specification.')
s3TrNodeFrmCopyErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeFrmCopyErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeFrmCopyErrs.setDescription('Number of frame copy errors. Section 3.8.8 of IEEE 802.5 specification.')
s3TrNodeTokenErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeTokenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeTokenErrs.setDescription('Number of token errors. Section 3.8.10 of IEEE 802.5 specification.')
s3TrNodeInternalErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeInternalErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeInternalErrs.setDescription('Number of internal errors. Section 3.8.2 of IEEE 802.5 specification.')
s3TrNodeAbortTransErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeAbortTransErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeAbortTransErrs.setDescription('Number of abort delimiter transmitted errors. Section 3.8.5 of IEEE 802.5 specification.')
s3TrNodeFrequencyErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeFrequencyErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeFrequencyErrs.setDescription('Number of frequency errors. Section 3.8.9 of IEEE 802.5 specification.')
s3TrNodeEntProductId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(18, 18)).setFixedLength(18)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntProductId.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntProductId.setDescription('A brief string describing the product specified by the vendor. Section 3.3.2.14 of IEEE 802.5 specification. The characters in the string are represented in EBCDIC for IBM products, in ASCII for others.')
s3TrNodeEntUna = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntUna.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntUna.setDescription('The Upstream Neighbor Address. Section 3.3.2.15 of IEEE 802.5 specification.')
s3TrNodeEntNodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntNodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntNodeVersion.setDescription('String that represents the version of the station software. Section 3.3.2.17 of IEEE 802.5 specification. The characters in the string are represented in EBCDIC for IBM products, in ASCII for others.')
s3TrNodeEntPhysDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntPhysDrop.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntPhysDrop.setDescription('This reports the physical location of this node on the ring. Section 3.3.2.13 of IEEE 802.5 specification.')
s3TrNodeEntFuncAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntFuncAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntFuncAddr.setDescription('Specifies the functional addresses used by this station. Section 3.3.2.8 of IEEE 802.5 specification.')
s3TrNodeEntAuthFuncClass = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntAuthFuncClass.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntAuthFuncClass.setDescription('This specifies the functional classes that are allowed to be active in the station. Section 3.3.2.3 of IEEE 802.5 specification.')
s3TrNodeEntAuthAccPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntAuthAccPriority.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntAuthAccPriority.setDescription('The maximum priority this station is allowed to use. Section 3.3.2.2 of IEEE 802.5 specification.')
s3TrNodeEntGrpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntGrpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntGrpAddr.setDescription('This contains the group address of this station. Section 3.3.2.9 of IEEE 802.5 specification.')
s3TrNodeEntStationId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntStationId.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntStationId.setDescription("This string is used to uniquely identify the station. It may be equal to the station's MAC address. Section 3.3.2.21 of IEEE 802.5 specification.")
s3TrNodeEntBeaconType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reconfiguration", 1), ("signal-loss", 2), ("bit-streaming", 3), ("contention-streaming", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeEntBeaconType.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeEntBeaconType.setDescription('This specifies the type of beacon frame seen. Section 3.3.2.4 of IEEE 802.5 specification.')
s3TrNodeBeaconCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeBeaconCnt.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeBeaconCnt.setDescription('Number of beacon frames that have been sent by this station.')
s3TrNodeLastBeaconTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 27), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeLastBeaconTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeLastBeaconTime.setDescription('The time of the last beacon frame sent by this station.')
s3TrNodeLastInsertTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 28), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeLastInsertTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeLastInsertTime.setDescription('The time of the last ring insertion by this station. Time is relative from the system uptime.')
s3TrNodeFirstInsertTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 29), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeFirstInsertTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeFirstInsertTime.setDescription('The time of the first ring insertion by this station. Time is relative from the system uptime.')
s3TrNodeLastDeinsertTime = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 30), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrNodeLastDeinsertTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeLastDeinsertTime.setDescription('The time of the last ring deinsertion by this station. Time is relative from the system uptime.')
s3TrNodeRemoveStation = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 5, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("remove", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: s3TrNodeRemoveStation.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrNodeRemoveStation.setDescription('Removes the MAC address associated with this entry from the ring by sending a REMOVE MAC frame if this object is written to with remove(2).')
s3TrRingStatus = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("beaconing", 1), ("notbeaconing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingStatus.setDescription('The status of the ring.')
s3TrRingFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingFrmsRxOk.setDescription('Number of frames received successfully by the NMM.')
s3TrRingOctetsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingOctetsRxOk.setDescription('Number of octets received successfully by the NMM.')
s3TrRingBcastFrmsRxOk = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingBcastFrmsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingBcastFrmsRxOk.setDescription('Number of broadcast frames received successfully by the NMM.')
s3TrRingLineErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingLineErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingLineErrs.setDescription('Number of line errors. Section 3.8.1 of IEEE 802.5 specification.')
s3TrRingBurstErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingBurstErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingBurstErrs.setDescription('Number of burst errors. Section 3.8.3 of IEEE 802.5 specification.')
s3TrRingAriFciErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingAriFciErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingAriFciErrs.setDescription('Number of ARI FCI errors. See AC errors, Section 3.8.4 of IEEE 802.5 specification.')
s3TrRingLostFrames = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingLostFrames.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingLostFrames.setDescription('Number of frames lost. Section 3.8.6 of IEEE 802.5 specification.')
s3TrRingRcvCongestErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingRcvCongestErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingRcvCongestErrs.setDescription('Number of receive congestion errors. Section 3.8.7 of IEEE 802.5 specification.')
s3TrRingFrmCopyErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingFrmCopyErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingFrmCopyErrs.setDescription('Number of frame copy errors. Section 3.8.8 of IEEE 802.5 specification.')
s3TrRingTokenErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingTokenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingTokenErrs.setDescription('Number of token errors. Section 3.8.10 of IEEE 802.5 specification.')
s3TrRingInternalErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingInternalErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingInternalErrs.setDescription('Number of internal errors. Section 3.8.2 of IEEE 802.5 specification.')
s3TrRingAbortTransErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingAbortTransErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingAbortTransErrs.setDescription('Number of abort delimiter transmitted errors. Section 3.8.5 of IEEE 802.5 specification.')
s3TrRingFrequencyErrs = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingFrequencyErrs.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingFrequencyErrs.setDescription('Number of frequency errors. Section 3.8.9 of IEEE 802.5 specification.')
s3TrRingBeaconCnt = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingBeaconCnt.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingBeaconCnt.setDescription('Number of beacon frames that have been seen.')
s3TrRingBeaconType = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("reconfiguration", 1), ("signal-loss", 2), ("bit-streaming", 3), ("contention-streaming", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingBeaconType.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingBeaconType.setDescription('This specifies the type of beacon frame seen. Section 3.3.2.4 of IEEE 802.5 Specification.')
s3TrRingLastBeaconTime = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 17), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingLastBeaconTime.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingLastBeaconTime.setDescription('The time of the last beacon frame sent on the ring. Time is relative from the system uptime.')
s3TrRingBeaconStation = MibScalar((1, 3, 6, 1, 4, 1, 45, 1, 3, 3, 7, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: s3TrRingBeaconStation.setStatus('mandatory')
if mibBuilder.loadTexts: s3TrRingBeaconStation.setDescription('The MAC address of station last beaconing.')
mibBuilder.exportSymbols("SYNOPTICS-TOKENRING-MIB", s3TrRingFrmCopyErrs=s3TrRingFrmCopyErrs, s3TrNmmGrpAddrFrmsRxOk=s3TrNmmGrpAddrFrmsRxOk, s3TrPortRelayStatus=s3TrPortRelayStatus, s3TrNmmFpuStatus=s3TrNmmFpuStatus, s3TrNodeEntry=s3TrNodeEntry, s3TrRingAbortTransErrs=s3TrRingAbortTransErrs, s3TrNodeLastDeinsertTime=s3TrNodeLastDeinsertTime, s3TrNmmHexDisplay=s3TrNmmHexDisplay, s3TrNodeEntNodeStatus=s3TrNodeEntNodeStatus, s3TrNodeLastInsertTime=s3TrNodeLastInsertTime, s3TrNodeRemoveStation=s3TrNodeRemoveStation, s3TrCommonBoardTable=s3TrCommonBoardTable, s3TrNodeEntAuthAccPriority=s3TrNodeEntAuthAccPriority, s3TrNodeAbortTransErrs=s3TrNodeAbortTransErrs, s3TrRingOctetsRxOk=s3TrRingOctetsRxOk, s3TrRingFrmsRxOk=s3TrRingFrmsRxOk, s3TrRingRcvCongestErrs=s3TrRingRcvCongestErrs, s3TrRingLostFrames=s3TrRingLostFrames, s3TrNodeInternalErrs=s3TrNodeInternalErrs, s3TrNodeFrmCopyErrs=s3TrNodeFrmCopyErrs, s3TrPortPhantomStatus=s3TrPortPhantomStatus, s3TrNodeEntStationId=s3TrNodeEntStationId, s3TrNodeLostFrames=s3TrNodeLostFrames, s3TrNodeTable=s3TrNodeTable, s3TrRingLastBeaconTime=s3TrRingLastBeaconTime, s3TrNmmEepromSize=s3TrNmmEepromSize, s3TrRingBcastFrmsRxOk=s3TrRingBcastFrmsRxOk, s3TrCommonBoardEntry=s3TrCommonBoardEntry, s3TrNodeFirstInsertTime=s3TrNodeFirstInsertTime, s3000TrNmm=s3000TrNmm, s3TrNmmFnNum=s3TrNmmFnNum, s3TrNmmFpuIdRev=s3TrNmmFpuIdRev, s3TrRingInternalErrs=s3TrRingInternalErrs, s3TrNodeEntAuthFuncClass=s3TrNodeEntAuthFuncClass, s3TrNmmDramSize=s3TrNmmDramSize, s3TrRingBurstErrs=s3TrRingBurstErrs, s3TrNodeTokenErrs=s3TrNodeTokenErrs, s3TrNodeEntFuncAddr=s3TrNodeEntFuncAddr, s3TrPortChgSyn2IBM=s3TrPortChgSyn2IBM, s3TrRingBeaconStation=s3TrRingBeaconStation, s3TrPortWrap=s3TrPortWrap, s3TrPortTable=s3TrPortTable, s3TrPortPhantomChangeFlag=s3TrPortPhantomChangeFlag, s3TrNmmSlotNum=s3TrNmmSlotNum, s3TrNmmRingSpeed=s3TrNmmRingSpeed, s3TrNodeLineErrs=s3TrNodeLineErrs, s3TrRingBeaconCnt=s3TrRingBeaconCnt, s3TrRingFrequencyErrs=s3TrRingFrequencyErrs, s3TrPortEntry=s3TrPortEntry, s3TrRingLineErrs=s3TrRingLineErrs, s3TrPortIndex=s3TrPortIndex, s3TrNodeBeaconCnt=s3TrNodeBeaconCnt, s3TrNodeLastBeaconTime=s3TrNodeLastBeaconTime, s3TrPortStrap=s3TrPortStrap, s3TrNodeEntProductId=s3TrNodeEntProductId, s3TrNodeEntGrpAddr=s3TrNodeEntGrpAddr, s3TrNodeEntNodeVersion=s3TrNodeEntNodeVersion, s3TrNmmRing1or2=s3TrNmmRing1or2, s3TrNodeEntBeaconType=s3TrNodeEntBeaconType, s3TrCommonBoardRingSpeed=s3TrCommonBoardRingSpeed, s3TrCommonBoardIndex=s3TrCommonBoardIndex, s3TrPortBoardIndex=s3TrPortBoardIndex, s3TrNodeEntStatus=s3TrNodeEntStatus, s3TrNmmEpromSize=s3TrNmmEpromSize, s3TrNodeEntPhysDrop=s3TrNodeEntPhysDrop, s3TrRingAriFciErrs=s3TrRingAriFciErrs, s3000TrNode=s3000TrNode, s3TrNmmRingNum=s3TrNmmRingNum, s3TrRingTokenErrs=s3TrRingTokenErrs, s3TrNodeEntMacAddress=s3TrNodeEntMacAddress, s3TrNodeRcvCongestErrs=s3TrNodeRcvCongestErrs, s3TrRingStats=s3TrRingStats, s3000TrRing=s3000TrRing, s3000TrBoard=s3000TrBoard, s3TrCommonBoardRing1or2=s3TrCommonBoardRing1or2, s3TrRingStatus=s3TrRingStatus, s3TrNodeBurstErrs=s3TrNodeBurstErrs, s3TrNodeEntUna=s3TrNodeEntUna, s3TrPortTestLatch=s3TrPortTestLatch, s3TrNodeFrequencyErrs=s3TrNodeFrequencyErrs, s3TrRingBeaconType=s3TrRingBeaconType, s3TrNodeAriFciErrs=s3TrNodeAriFciErrs, s3000TrPort=s3000TrPort)

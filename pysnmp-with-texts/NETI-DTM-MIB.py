#
# PySNMP MIB module NETI-DTM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NETI-DTM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:19:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint")
FaultStatus, netiExperimentalGeneric = mibBuilder.importSymbols("NETI-COMMON-MIB", "FaultStatus", "netiExperimentalGeneric")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, Gauge32, Bits, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Integer32, NotificationType, ObjectIdentity, Counter32, ModuleIdentity, Counter64, Unsigned32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "Bits", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Integer32", "NotificationType", "ObjectIdentity", "Counter32", "ModuleIdentity", "Counter64", "Unsigned32", "IpAddress")
RowPointer, MacAddress, TextualConvention, DisplayString, RowStatus, DateAndTime, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "MacAddress", "TextualConvention", "DisplayString", "RowStatus", "DateAndTime", "TruthValue")
netiDTMMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4))
netiDTMMIB.setRevisions(('2013-11-12 08:00', '2013-09-10 13:00', '2010-09-01 14:00', '2010-03-03 09:00', '2009-06-25 14:00', '2008-02-06 17:00', '2006-08-22 10:00', '2006-05-16 13:00', '2004-09-29 00:00', '2003-02-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: netiDTMMIB.setRevisionsDescriptions(('Updated descriptions.', 'Added support for time transfer sources (the dtmTimeSourceTable and dtmTimeSourceCalibrationReference) to the dtmSyncGroup.', 'Added dtmIfSyncEnabled', 'Added dtmTimeScaleStatus. Following objects are obsoleted: dtmIfTxCapacityOwnedFirstSlot', 'Added dtmIfPurpose. Added lowerLayerDown in dtmIfOperStatus. Following objects are obsoleted: dtmIfTxCapacityBorrowed dtmIfTxCapacityMaxLend dtmIfTxCapacityLent dtmIfAbsent dtmIfIfIndex', 'Added dtmNodeId. Added dtmSyncGroup and its objects. Corrected some typos in descriptions.', 'Added hosts to address resolution table dtmHostsTable.', 'Added objects for Persistent Channel functionality: dtmIfLinkClass dtmLinkStateLocalSubIf dtmLinkStateIfNodeStatus dtmNodeStatus dtmNodeRestartOnError Added objects for configuration of DRP: dtmIfRouteMetric dtmDrpNodeRouteMetric dtmDrpNodeType dtmDrpAreaNumber dtmDrpDetectAreaNumber dtmDrpDetectDefaultGateway Removed all objects in obsoleted history group (dtmHistroyGroup).', 'The history group (dtmHistoryGroup) is obsoleted.', 'dtmRouteTable was never implemented, and is therefore removed.',))
if mibBuilder.loadTexts: netiDTMMIB.setLastUpdated('201311120800Z')
if mibBuilder.loadTexts: netiDTMMIB.setOrganization('Net Insight AB')
if mibBuilder.loadTexts: netiDTMMIB.setContactInfo('Net Insight AB Box 42093 SE-126 14 Stockholm Sweden Tel +46-8-685 0400 info@netinsight.net')
if mibBuilder.loadTexts: netiDTMMIB.setDescription('The Net Insight DTM MIB. The MIB implements objects for managing the DTM configuration in a network element.')
netiDTMMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1))
dtmAddrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1))
dtmIfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2))
dtmLinkStateGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3))
dtmRouteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 4))
dtmHistoryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 5))
dtmNodeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 6))
dtmSyncGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7))
class DtmAddress(TextualConvention, OctetString):
    description = 'A (Net Insight) DTM address is 64 bits.'
    status = 'current'
    displayHint = '1x.'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class DtmSourceRoute(TextualConvention, OctetString):
    description = "A (Net Insight) DTM source route specification. The source route specification is composed of a list of intermediate nodes and optionally outgoing interface for the same node. This means that the destination should typically not be included in the route specification. To specify the outgoing interface in the source node add the originating node as the first entry in the route. The string is composed of one (zero) or more 10 byte sequences of the following format: field octets description range 1 0-7 DTM address - 2 8 Card position 0, 1-255 3 9 Port position 0, 1-255 The address denotes the next hop address for an intermediate note. The interface identifier identifies the outgoing interface of the intermediate node. For the interface 'dtm2.1' field 2 should contain 2 and field 3 should contain 1. To user any interface is denoted assign 0 to both card and interface position. The empty route is specified by an empty string. The application using a source route should specify whether strict or loose source routing is used or provide a separate parameter to configure the type of routing."
    status = 'current'
    displayHint = '1x.1x.1x.1x.1x.1x.1x.1x 1x:1x'

dtmAddrTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 1), )
if mibBuilder.loadTexts: dtmAddrTable.setStatus('current')
if mibBuilder.loadTexts: dtmAddrTable.setDescription("The table of addressing information relevant to this entity's DTM addresses.")
dtmAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 1, 1), ).setIndexNames((0, "NETI-DTM-MIB", "dtmAddrEntryIndex"))
if mibBuilder.loadTexts: dtmAddrEntry.setStatus('current')
if mibBuilder.loadTexts: dtmAddrEntry.setDescription("The addressing information for one of this entity's DTM addresses.")
dtmAddrEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmAddrEntryIndex.setStatus('current')
if mibBuilder.loadTexts: dtmAddrEntryIndex.setDescription('An arbitrary index in the link table.')
dtmAddrEntryAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 1, 1, 2), DtmAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmAddrEntryAddr.setStatus('current')
if mibBuilder.loadTexts: dtmAddrEntryAddr.setDescription("The DTM address to which this entry's addressing information pertains.")
dtmAddrEntryIsAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 1, 1, 3), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmAddrEntryIsAlias.setStatus('current')
if mibBuilder.loadTexts: dtmAddrEntryIsAlias.setDescription("Indicates if this address is the network address for this entity. There is only one network address for each entity. Values: true(1) This address is an alias. false(2) This address is the 'real' address for this entity.")
dtmAddrEntryAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("loopback", 2), ("local", 3), ("multicast", 4), ("global", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmAddrEntryAddrType.setStatus('current')
if mibBuilder.loadTexts: dtmAddrEntryAddrType.setDescription('Indicates the type of address. This type is derived from the prefixes defined below, so this is really just a more user-friendly manner of presenting the address type. unspecified(1) The unspecified address; does not really belong in the address table. Prefix 00.00.00.00.00.00.00.00-64. loopback(2) The loopback address; always assigned to the local node. Prefix 00.00.00.00.00.00.00.01-64. local(3) Site local addresses, prefix 00.00.00.00.00.00.00.00-16 (except the unspecified and loopback addresses). multicast(4) Multicast addresses, prefix FF.00.00.00.00.00.00.00-8. global(5) Global addresses, all other prefixes.')
dtmAddrEntryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmAddrEntryRowStatus.setStatus('current')
if mibBuilder.loadTexts: dtmAddrEntryRowStatus.setDescription('See SNMPv2-TC.')
dtmHostsTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 2), )
if mibBuilder.loadTexts: dtmHostsTable.setStatus('current')
if mibBuilder.loadTexts: dtmHostsTable.setDescription("The table of addressing information relevant to this entity's DTM addresses.")
dtmHostsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 2, 1), ).setIndexNames((0, "NETI-DTM-MIB", "dtmHostsEntryIndex"))
if mibBuilder.loadTexts: dtmHostsEntry.setStatus('current')
if mibBuilder.loadTexts: dtmHostsEntry.setDescription("The addressing information for one of this entity's DTM addresses.")
dtmHostsEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: dtmHostsEntryIndex.setStatus('current')
if mibBuilder.loadTexts: dtmHostsEntryIndex.setDescription('An arbitrary index in the hosts database table.')
dtmHostsEntryAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 2, 1, 2), DtmAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmHostsEntryAddr.setStatus('current')
if mibBuilder.loadTexts: dtmHostsEntryAddr.setDescription('The DTM address to which this hosts name is mapped.')
dtmHostsEntryName = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 2, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmHostsEntryName.setStatus('current')
if mibBuilder.loadTexts: dtmHostsEntryName.setDescription('The hosts name representing the DTM address. The host name is a text string up to 64 characters drawn from the alphabet (A-Z, a-z), digits (0-9), and minus sign (-). No blank or space characters are permitted as part of a name. No distinction is made between upper and lower case. The first character must be an alpha character. The last character must not be a minus sign or period.')
dtmHostsEntryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 1, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmHostsEntryRowStatus.setStatus('current')
if mibBuilder.loadTexts: dtmHostsEntryRowStatus.setDescription('See SNMPv2-TC. The following values are supported: createAndGo(4). A new conceptual row is created representing the mapping between DTM address and DTM host name. destroy(6). The conceptual row is deleted.')
dtmIfTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1), )
if mibBuilder.loadTexts: dtmIfTable.setStatus('current')
if mibBuilder.loadTexts: dtmIfTable.setDescription('A conceptual table containing with DTM interfaces.')
dtmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1), ).setIndexNames((0, "NETI-DTM-MIB", "dtmIfIndex"))
if mibBuilder.loadTexts: dtmIfEntry.setStatus('current')
if mibBuilder.loadTexts: dtmIfEntry.setDescription('An entry in the DTM interface table.')
dtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfIndex.setStatus('current')
if mibBuilder.loadTexts: dtmIfIndex.setDescription('Index in to the table.')
dtmIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 2), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfName.setStatus('current')
if mibBuilder.loadTexts: dtmIfName.setDescription("The interface name, on the form <type><card position>:<port>, for example 'dtm4:1'. Should correlate to what it says on the front of the actual hardware.")
dtmIfMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfMacAddress.setStatus('current')
if mibBuilder.loadTexts: dtmIfMacAddress.setDescription('The interfaces DTM physical address, i.e. a MAC identity.')
dtmIfTxCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfTxCapacity.setStatus('current')
if mibBuilder.loadTexts: dtmIfTxCapacity.setDescription('The upper transmit capability (in slots) for this interface. Set to 0 if not known.')
dtmIfTxCapacityCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 5), Gauge32().clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfTxCapacityCtrl.setStatus('current')
if mibBuilder.loadTexts: dtmIfTxCapacityCtrl.setDescription('The transmit capability (in slots) used for control traffic (when dedicated control channels are used). See also dtmIfreducedCtrlCapacity.')
dtmIfTxCapacityStart = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 6), Gauge32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfTxCapacityStart.setStatus('deprecated')
if mibBuilder.loadTexts: dtmIfTxCapacityStart.setDescription('The start slot for owned transmit capability (in slots) for this interface. Valid range is between 1 and the upper transmit capacity of the interface - 1.')
dtmIfTxCapacityOwned = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfTxCapacityOwned.setStatus('deprecated')
if mibBuilder.loadTexts: dtmIfTxCapacityOwned.setDescription('The owned transmit capability (in slots) for this interface. Total capacity for use is Owned + Borrowed - Lent. Set to 0 if not known.')
dtmIfTxCapacityBorrowed = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfTxCapacityBorrowed.setStatus('deprecated')
if mibBuilder.loadTexts: dtmIfTxCapacityBorrowed.setDescription('The borrowed transmit capability (in slots) for this interface. Set to 0 if not known.')
dtmIfTxCapacityMaxLend = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 9), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfTxCapacityMaxLend.setStatus('deprecated')
if mibBuilder.loadTexts: dtmIfTxCapacityMaxLend.setDescription('The maximum amount of transmit capability (in slots) that this interface will lend to other interfaces. Set to 0 if not known.')
dtmIfTxCapacityLent = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfTxCapacityLent.setStatus('deprecated')
if mibBuilder.loadTexts: dtmIfTxCapacityLent.setDescription('The lent transmit capability (in slots) for this interface. Set to 0 if not known.')
dtmIfTxCapacityUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfTxCapacityUsed.setStatus('current')
if mibBuilder.loadTexts: dtmIfTxCapacityUsed.setDescription('The transmit capability (in slots) used for data traffic for this interface.')
dtmIfRxCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfRxCapacity.setStatus('current')
if mibBuilder.loadTexts: dtmIfRxCapacity.setDescription('The upper receive capability (in slots) for this interface. Set to 0 if not known.')
dtmIfRxCapacityUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfRxCapacityUsed.setStatus('current')
if mibBuilder.loadTexts: dtmIfRxCapacityUsed.setDescription('The receive capability (in slots) used for data traffic for this interface.')
dtmIfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dtmIfIfIndex.setDescription('Index in to the MIB-II ifTable. Set to 0 if not known.')
dtmIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: dtmIfAdminStatus.setDescription('The desired state of the interface. The administrative status controls whether the interface should be active or not.')
dtmIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("absent", 3), ("lowerLayerDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfOperStatus.setStatus('current')
if mibBuilder.loadTexts: dtmIfOperStatus.setDescription("The actual state of the interface. The value should follow the state of the Administrative Status (dtmIfAdminStatus) unless something fails, or be `absent' if the interface is absent.")
dtmIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: dtmIfRowStatus.setDescription('See SNMPv2-TC.')
dtmIfAbsent = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 18), FaultStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfAbsent.setStatus('deprecated')
if mibBuilder.loadTexts: dtmIfAbsent.setDescription("Indicates that a configured interface can not be activated because there are no hardware resources. This happens if the dtmIfAdminStatus is set to `up', and the interface is absent.")
dtmIfLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 19), FaultStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfLOS.setStatus('current')
if mibBuilder.loadTexts: dtmIfLOS.setDescription('Indicates Loss Of Signal from the DTM domain.')
dtmIfReducedCtrlCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 20), FaultStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmIfReducedCtrlCapacity.setStatus('current')
if mibBuilder.loadTexts: dtmIfReducedCtrlCapacity.setDescription('Indicates that the node has not been able to allocate dedicated capacity for control traffic.')
dtmIfTxCapacityOwnedFirstSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 21), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfTxCapacityOwnedFirstSlot.setStatus('deprecated')
if mibBuilder.loadTexts: dtmIfTxCapacityOwnedFirstSlot.setDescription('The lower end of the transmit capability range (in slots) for this interface.')
dtmIfTxCapacityOwnedLastSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 22), Gauge32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfTxCapacityOwnedLastSlot.setStatus('current')
if mibBuilder.loadTexts: dtmIfTxCapacityOwnedLastSlot.setDescription('The upper end of the transmit capability range (in slots) for this interface.')
dtmIfRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 23), Unsigned32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfRouteMetric.setStatus('current')
if mibBuilder.loadTexts: dtmIfRouteMetric.setDescription('The route metric used by the DTM Routing Protocol (DRP) when calculating cost for routing through this interface. The value zero (0) indicates that the DRP protocol shall be disabled for this interface and no routing information shall be exchanged.')
dtmIfLinkClass = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("persistent", 2), ("nailed", 3))).clone('normal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfLinkClass.setStatus('current')
if mibBuilder.loadTexts: dtmIfLinkClass.setDescription("The link class controls the behavior of a link when a failure is detected on the link or on the node connected to the remote end of the link. The link class decides which values the dtmLinkStateNodeStatus object can take. A link is monitored with the following mechanisms: - The underlying trunk interface will detect when the signal on the receiving interface disappears or is impossible to use due to errors. This is called a Signal Failure. - The communication with the node at the remote end of the link is monitored by periodically sending messages, and expecting responses. If no response is received within a reasonable time, a failure is assumed. This is called a Supervision Failure. The error detection mechanisms can detect failures in one or both directions of a bi-directional link. If a failure is detected in only one direction of a bi-directional link and there is another fully working link in the opposite direction, the remaining working links will all have status `up'. The link classes are: normal(1) If either a Signal Failure or Supervision Failure is detected on the link, the link is considered as `down' and its entry is removed from the dtmLinkStateTable. persistent(2) If a Signal Failure is detected on the link, the link is considered as `down' and its entry is removed from the dtmLinkStateTable. If a Supervision Failure is detected on the link, the object dtmLinkStateIfNodeStatus for the link is assigned `noControl'. nailed(3) If a Signal Failure is detected on the link, the object dtmLinkStateIfNodeStatus for the link is assigned `downKeep'. If a Supervision Failure is detected on the link, the object dtmLinkStateIfNodeStatus for the link is assigned `noControl'. ")
dtmIfPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 25), SnmpAdminString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfPurpose.setStatus('current')
if mibBuilder.loadTexts: dtmIfPurpose.setDescription('A string describing the purpose of the interface. The string is for administrative use.')
dtmIfSyncEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dtmIfSyncEnabled.setStatus('current')
if mibBuilder.loadTexts: dtmIfSyncEnabled.setDescription('Controls if the trunk interface on which this interface is stacked on top, can be considered a source for synchronization. disabled(1) The interface shall not be considered. enabled(2). The interface shall be considered.')
dtmLinkStateTableLastChangedTime = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 1), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateTableLastChangedTime.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateTableLastChangedTime.setDescription('This is the time the link information table last changed.')
dtmLinkStateNrOfLinks = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateNrOfLinks.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateNrOfLinks.setDescription('The number of entries in the link table.')
dtmLinkStateTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 3), )
if mibBuilder.loadTexts: dtmLinkStateTable.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateTable.setDescription('The link information table.')
dtmLinkStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 3, 1), ).setIndexNames((0, "NETI-DTM-MIB", "dtmLinkStateIndex"))
if mibBuilder.loadTexts: dtmLinkStateEntry.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateEntry.setDescription('One entry per discovered link.')
dtmLinkStateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateIndex.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateIndex.setDescription('An arbitrary index in the link table.')
dtmLinkStateType = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("looped", 2), ("open", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateType.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateType.setDescription("The 'simple' topological type of the link: unknown(1) Type cannot be determined. looped(2) Looped topology; i.e. a ring. open(3) Open topology; i.e. part of a bus.")
dtmLinkStateLocalIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateLocalIf.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateLocalIf.setDescription('The name of the local interface that belongs to the link.')
dtmLinkStateNrOfIfs = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateNrOfIfs.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateNrOfIfs.setDescription('The number of entries in the link interface table.')
dtmLinkStateIfTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 5), )
if mibBuilder.loadTexts: dtmLinkStateIfTable.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateIfTable.setDescription('The link interface information table.')
dtmLinkStateIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 5, 1), ).setIndexNames((0, "NETI-DTM-MIB", "dtmLinkStateIndex"), (0, "NETI-DTM-MIB", "dtmLinkStateIfIndex"))
if mibBuilder.loadTexts: dtmLinkStateIfEntry.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateIfEntry.setDescription('One entry for every interface on each link. On each link the interfaces are ordered in downstream order.')
dtmLinkStateIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 5, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateIfIndex.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateIfIndex.setDescription('An arbitrary index in the link interface table.')
dtmLinkStateIfMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 5, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateIfMacAddress.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateIfMacAddress.setDescription('The interfaces DTM physical address, i.e. a MAC identity.')
dtmLinkStateIfNodeMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 5, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateIfNodeMacAddress.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateIfNodeMacAddress.setDescription('The node DTM physical address, i.e. a MAC identity.')
dtmLinkStateIfNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 5, 1, 4), DtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateIfNodeAddress.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateIfNodeAddress.setDescription('The nodes network DTM address. Returns the unspecified address (00.00.00.00.00.00.00.00) if unknown.')
dtmLinkStateLocalSubIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateLocalSubIf.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateLocalSubIf.setDescription("The name of the sub-interface that is connected to this link, e.g. 'dtm2:1/rx' for a receiving part of an interface, or dtm2:1/tx for a transmitting part of an interface.")
dtmLinkStateIfNodeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 3, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notApplicable", 0), ("up", 1), ("recover", 2), ("limited", 3), ("noControl", 4), ("downKeep", 5), ("pending", 6), ("loopback", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmLinkStateIfNodeStatus.setStatus('current')
if mibBuilder.loadTexts: dtmLinkStateIfNodeStatus.setDescription('The status of the communication with the neighboring node via this link. The link entry is removed from this table when the link is down. notApplicable(0) This value notApplicable(0) is always set for the entry representing the local node, and never set for any other entry. up(1) The communication with the neighboring node is fully functioning. This is the only state where it is possible to establish new channels over the link. recover(2) The neighboring node is in a recovery state after a node or control function sub-system failure, where it is in the process of recovering the state of all channels. When the process of recovering the channels is completed, the state will change to either up(1) if all channels state were successfully recovered, or limited(3) if the state of any channels failed to be recovered. limited(3) The neighboring node is not or has not been able to recover the state of all its channels after a node or control function sub-system failure. The already existing channels over the link may be fully functional, but the neighboring node is not accepting any channel signaling. The link must be taken down by the neighboring node for its control function sub-system to be able to assume a known state, which typically requires operator intervention. noControl(4) A valid signal is detected from the neighboring node, but the control function sub-system on the neighboring node is not responding, indicating a remote node or control function sub-system failure. Signaling to the neighboring node is thus not possible. Already existing channels over the link may be fully functional. downKeep(5) The bi-directional communication with the neighboring node is lost. The link is not removed because the interface link class is configured as nailed. pending(6) This status is only valid for the entry representing the receiving sub-interface. Indicates that a neighbor has been detected on the receiving part of an interface, but no bi-directional communication has yet been established with the neighboring node. loopback(7) This status is only valid for the entry representing the receiving sub-interface. The link is connected from an interface located on the local node. ')
dtmDrpNodeRouteMetric = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 4, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmDrpNodeRouteMetric.setStatus('current')
if mibBuilder.loadTexts: dtmDrpNodeRouteMetric.setDescription('The route metric used by the DTM Routing Protocol (DRP) when calculating cost for routing through this node. The value zero (0) means no cost.')
dtmDrpNodeType = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switch", 1), ("endNode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmDrpNodeType.setStatus('current')
if mibBuilder.loadTexts: dtmDrpNodeType.setDescription('The type of node as seen by the DTM Routing Protocol (DRP). switch(1) The node is to be considered located within the network, where channels may be switched via this node. endNode(2) The node is to be considered located the edge of a network, and channels only originates or terminates on this node. The node does not participate in DRP.')
dtmDrpAreaNumber = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 4, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmDrpAreaNumber.setStatus('current')
if mibBuilder.loadTexts: dtmDrpAreaNumber.setDescription('The DTM Routing Protocol (DRP) area number. The value zero (0) indicates that the area number is unconfigured.')
dtmDrpDetectAreaNumber = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 4, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmDrpDetectAreaNumber.setStatus('current')
if mibBuilder.loadTexts: dtmDrpDetectAreaNumber.setDescription("Defines if the area number shall be detected automatically. true(1) If set to `true', and if the area number (dtmDrpAreaNumber) is unconfigured, then the node will assume the area number of its neighboring nodes. false(2) The area number is not automatically detected.")
dtmDrpDetectDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 4, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmDrpDetectDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: dtmDrpDetectDefaultGateway.setDescription('Defines if the default gateway shall be detected automatically by DTM Routing Protocol (DRP). true(1) The default gateway is automatically detected. false(2) The default gateway is not automatically detected.')
dtmNodeStatus = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("recover", 2), ("limited", 3), ("noControl", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmNodeStatus.setStatus('current')
if mibBuilder.loadTexts: dtmNodeStatus.setDescription('This object describes and controls the control function sub-system on the node. up(1) The control function sub-system is fully functioning. This is the only state where it is possible to establish new channels. This is the only value possible to write to this object. When writing this value, the control function sub-system is forced to this state, which may result in all established channels to be removed or re-established. recover(2) The control function sub-system is in the process of recovering the state of all channels after a node or control function sub-system failure, where it is When the process of recovering the channels is completed, the state will change to either up(1) if all channels state were successfully recovered, or limited(3) if the state of any channels failed to be recovered. limited(3) The control function sub-system is not or has not been able to recover the state of all its channels after a node or control function sub-system failure. The already existing channels through the node may be fully functional, but it is not accepting any channel signaling. All link must be taken down for the control function sub-system to be able to assume a known state, which typically requires operator intervention. This state can be exited by writing up(1) to the object. noControl(4) The control function sub-system is failing and is not responding. Signaling to the neighboring node is thus not possible. Already existing channels through the node may still be fully functional, but their state is not known. This state can be exited by writing up(1) to the object.')
dtmNodeRestartOnError = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 6, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmNodeRestartOnError.setStatus('current')
if mibBuilder.loadTexts: dtmNodeRestartOnError.setDescription("The value of this object is only used if any DTM interface (table dtmIfTable) is configured as persistent (e.g. dtmIfLinkClass is `persistent' or `nailed'). It is controlling what status (dtmNodeStatus) the node shall enter when it reboots or the control function sub-system restarts. Note that the node always enters status `up' at cold-start. true(1) The node shall enter the status (dtmNodeStatus) `up'. All channels are torn down. false(2) The node shall enter the status (dtmNodeStatus) `noControl' or `limited', as applicable.")
dtmNodeId = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 6, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmNodeId.setStatus('current')
if mibBuilder.loadTexts: dtmNodeId.setDescription('The physical identity of the node. This is a fixed, unique address for each node.')
dtmSyncNodeId = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmSyncNodeId.setStatus('current')
if mibBuilder.loadTexts: dtmSyncNodeId.setDescription('The physical identity of the node that is the origin of the synchronization of this node, i.e. the node where the timing reference is connected.')
dtmCurrentTimingSourceName = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmCurrentTimingSourceName.setStatus('current')
if mibBuilder.loadTexts: dtmCurrentTimingSourceName.setDescription('The name of the currently used timing source. If the node is synchronized from an interface that is derived from a DTM interface, then this name is the name of the DTM interface.')
dtmCurrentTimingSourcePeerId = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmCurrentTimingSourcePeerId.setStatus('current')
if mibBuilder.loadTexts: dtmCurrentTimingSourcePeerId.setDescription('The physical identity of the node on the peering side of the interface identified by dtmCurrentTimingSourceName. This identifies the neighboring node from where the synchronization is taken. If the node is synchronized from a local interface, i.e. not from a timing source derived from a trunk interface but instead from a connected timing reference or the local oscillator, then the this is the id of the local node (dtmNodeId).')
dtmTimeScaleStatus = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("uninitiated", 2), ("reassigned", 3), ("compensated", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmTimeScaleStatus.setStatus('current')
if mibBuilder.loadTexts: dtmTimeScaleStatus.setDescription('The time scale status of the synchronization clock of this node. notSupported(1) Time Transfer is not supported or not enabled. uninitiated(2) The initial state which indicates that the time of the time scale is not initiated and may not be used for any time keeping. The time scale is however running, so it may be used for relative measures such as those used in round-trip estimates. During the uninitiated state the Time Transfer Control Processing attempts to initiate the TAI/UTC time from either another DTM node in state compensated, or some local UTC source. When the such a source is available, it reassigns the time scale and enters the reassigned state. reassigned(3) When the time scale of this node have a degenerated time-offset from neighbor nodes being compensated, or a local TAI/UTC source, the node reassigns the time scale and enters the reassigned state, during which the time scale may not be used for precision time-keeping. During the reassigned state the Time Transfer Control Processing attempts to retrace the TAI/UTC time from either another DTM node in state compensated, or some local TAI/UTC source. When the retracing have reduced the time error to within defined limits (1 us), it enters the compensated state. compensated(4) When the time scale of the node has been initiated to TAI/UTC, it can be used for time keeping, but the time error of the time scale is too high (and thus stability and precision is limited). During the compensated state the Time Transfer Control Processing will use the TLL to maintain the TAI/UTC time scale from any neighboring nodes in the compensated state.')
dtmTimeSourceCalibrationReference = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmTimeSourceCalibrationReference.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceCalibrationReference.setDescription('The index of the dtmTimeSourceEntry of the time source that is used as calibration reference. The special value 0 is used if the field is not set, and means that the node clock is used as reference.')
dtmTimeSourceTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6), )
if mibBuilder.loadTexts: dtmTimeSourceTable.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceTable.setDescription('A conceptual table containing time sources associated to time transfer capable interfaces.')
dtmTimeSourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1), ).setIndexNames((0, "NETI-DTM-MIB", "dtmTimeSourceIndex"))
if mibBuilder.loadTexts: dtmTimeSourceEntry.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceEntry.setDescription('An entry in the time source table.')
dtmTimeSourceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: dtmTimeSourceIndex.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceIndex.setDescription('Index in the dtmTimeSourceTable.')
dtmTimeSourceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmTimeSourceName.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceName.setDescription('The name of the time source.')
dtmTimeSourceAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmTimeSourceAdminStatus.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceAdminStatus.setDescription('The desired state of the interface. The administrative status controls whether the time source should be active or not.')
dtmTimeSourceOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("absent", 3), ("lowerLayerDown", 4), ("dormant", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmTimeSourceOperStatus.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceOperStatus.setDescription("The actual state of the time source. The value should follow the state of the Administrative Status (dtmIfAdminStatus) unless something fails (dtmTimeSourceOperStatus=down), `dormant' if another time source is the active time source or be `absent' if the associated interface is not present.")
dtmTimeSourceType = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dsyp", 1), ("sqc", 2), ("ssm", 3), ("internal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmTimeSourceType.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceType.setDescription('The type of time interface that provides the time source represented by this entry. dsyp(1) A DTM synchronization source (dsyp) represents a DTM interface timing source and the synchronization control information is distributed using the DTM Synchronization Protocol (DSYP). sqc(2) A squelchable clock (sqc) represents a clock interface that squelches its output to announce that it can not provide a source at the expected quality level. ssm(3) An SSM clock (ssm) represents a clock interface that also transports the Quality Level (QL) as a 4-bit Synchronization Signal Marker (SSM). internal(4) An internal clock (internal) represents a holdover clock that is internal to the node.')
dtmTimeSourceRef = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 6), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmTimeSourceRef.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceRef.setDescription('A reference to the time interface that provides the time source represented by this entry. The value .0.0 is used when no such reference is available.')
dtmTimeSourceRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmTimeSourceRoundTripTime.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceRoundTripTime.setDescription('The round trip time in nanoseconds for sending data to the peer of the time interface providing this time source and back. The value 0 is used, the round trip time is not available.')
dtmTimeSourceTimeError = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmTimeSourceTimeError.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceTimeError.setDescription('The time error in nanoseconds of the time source relative the node clock. The value 0 is used when the time error is not available.')
dtmTimeSourceCalibrationTimeError = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtmTimeSourceCalibrationTimeError.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceCalibrationTimeError.setDescription('The time error in nanoseconds of the time source relative the calibration reference. The value 0 is used when the time error is not available.')
dtmTimeSourceCalibrationRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 4, 1, 7, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-499999, 499999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dtmTimeSourceCalibrationRatio.setStatus('current')
if mibBuilder.loadTexts: dtmTimeSourceCalibrationRatio.setDescription('The configured calibration offset in ppm compared to the nominal value of of the one-way (i.e. remote to local) to round trip time ratio. The nominal value of the ratio is 1/2, which is equivalent to a value of 0.')
mibBuilder.exportSymbols("NETI-DTM-MIB", dtmLinkStateIfIndex=dtmLinkStateIfIndex, dtmLinkStateType=dtmLinkStateType, dtmTimeScaleStatus=dtmTimeScaleStatus, dtmTimeSourceIndex=dtmTimeSourceIndex, dtmLinkStateIfEntry=dtmLinkStateIfEntry, dtmLinkStateIfNodeAddress=dtmLinkStateIfNodeAddress, dtmIfPurpose=dtmIfPurpose, dtmHistoryGroup=dtmHistoryGroup, dtmIfTable=dtmIfTable, dtmAddrEntryRowStatus=dtmAddrEntryRowStatus, dtmTimeSourceCalibrationRatio=dtmTimeSourceCalibrationRatio, dtmTimeSourceRef=dtmTimeSourceRef, dtmHostsEntryRowStatus=dtmHostsEntryRowStatus, dtmIfIndex=dtmIfIndex, dtmIfOperStatus=dtmIfOperStatus, dtmSyncNodeId=dtmSyncNodeId, dtmDrpDetectDefaultGateway=dtmDrpDetectDefaultGateway, dtmDrpNodeType=dtmDrpNodeType, dtmIfLinkClass=dtmIfLinkClass, dtmIfTxCapacity=dtmIfTxCapacity, dtmLinkStateIfMacAddress=dtmLinkStateIfMacAddress, dtmAddrEntryAddrType=dtmAddrEntryAddrType, dtmAddrEntryAddr=dtmAddrEntryAddr, dtmIfTxCapacityBorrowed=dtmIfTxCapacityBorrowed, dtmHostsTable=dtmHostsTable, dtmIfSyncEnabled=dtmIfSyncEnabled, dtmTimeSourceAdminStatus=dtmTimeSourceAdminStatus, netiDTMMIB=netiDTMMIB, dtmLinkStateLocalSubIf=dtmLinkStateLocalSubIf, dtmLinkStateTableLastChangedTime=dtmLinkStateTableLastChangedTime, dtmLinkStateGroup=dtmLinkStateGroup, dtmIfTxCapacityOwnedFirstSlot=dtmIfTxCapacityOwnedFirstSlot, dtmAddrEntryIsAlias=dtmAddrEntryIsAlias, dtmHostsEntryIndex=dtmHostsEntryIndex, dtmIfTxCapacityLent=dtmIfTxCapacityLent, dtmLinkStateTable=dtmLinkStateTable, dtmTimeSourceTimeError=dtmTimeSourceTimeError, dtmLinkStateIfTable=dtmLinkStateIfTable, dtmIfIfIndex=dtmIfIfIndex, dtmAddrEntry=dtmAddrEntry, dtmIfTxCapacityStart=dtmIfTxCapacityStart, dtmLinkStateIndex=dtmLinkStateIndex, dtmTimeSourceOperStatus=dtmTimeSourceOperStatus, dtmHostsEntryName=dtmHostsEntryName, dtmIfTxCapacityOwnedLastSlot=dtmIfTxCapacityOwnedLastSlot, dtmIfRouteMetric=dtmIfRouteMetric, dtmTimeSourceName=dtmTimeSourceName, dtmIfTxCapacityOwned=dtmIfTxCapacityOwned, dtmTimeSourceTable=dtmTimeSourceTable, dtmIfTxCapacityUsed=dtmIfTxCapacityUsed, dtmIfTxCapacityCtrl=dtmIfTxCapacityCtrl, dtmLinkStateIfNodeStatus=dtmLinkStateIfNodeStatus, dtmDrpNodeRouteMetric=dtmDrpNodeRouteMetric, netiDTMMIBObjects=netiDTMMIBObjects, dtmNodeRestartOnError=dtmNodeRestartOnError, dtmDrpDetectAreaNumber=dtmDrpDetectAreaNumber, dtmNodeGroup=dtmNodeGroup, dtmAddrEntryIndex=dtmAddrEntryIndex, dtmHostsEntry=dtmHostsEntry, dtmIfRowStatus=dtmIfRowStatus, dtmIfName=dtmIfName, dtmCurrentTimingSourcePeerId=dtmCurrentTimingSourcePeerId, DtmSourceRoute=DtmSourceRoute, dtmLinkStateIfNodeMacAddress=dtmLinkStateIfNodeMacAddress, dtmLinkStateNrOfIfs=dtmLinkStateNrOfIfs, dtmIfMacAddress=dtmIfMacAddress, dtmSyncGroup=dtmSyncGroup, PYSNMP_MODULE_ID=netiDTMMIB, dtmIfTxCapacityMaxLend=dtmIfTxCapacityMaxLend, dtmIfAbsent=dtmIfAbsent, dtmIfRxCapacityUsed=dtmIfRxCapacityUsed, dtmTimeSourceCalibrationTimeError=dtmTimeSourceCalibrationTimeError, dtmIfRxCapacity=dtmIfRxCapacity, dtmCurrentTimingSourceName=dtmCurrentTimingSourceName, dtmTimeSourceCalibrationReference=dtmTimeSourceCalibrationReference, dtmLinkStateEntry=dtmLinkStateEntry, dtmIfEntry=dtmIfEntry, dtmAddrGroup=dtmAddrGroup, dtmTimeSourceType=dtmTimeSourceType, dtmIfAdminStatus=dtmIfAdminStatus, dtmIfReducedCtrlCapacity=dtmIfReducedCtrlCapacity, dtmLinkStateLocalIf=dtmLinkStateLocalIf, dtmNodeStatus=dtmNodeStatus, dtmRouteGroup=dtmRouteGroup, dtmAddrTable=dtmAddrTable, dtmTimeSourceEntry=dtmTimeSourceEntry, dtmDrpAreaNumber=dtmDrpAreaNumber, dtmIfLOS=dtmIfLOS, dtmTimeSourceRoundTripTime=dtmTimeSourceRoundTripTime, dtmHostsEntryAddr=dtmHostsEntryAddr, DtmAddress=DtmAddress, dtmIfGroup=dtmIfGroup, dtmNodeId=dtmNodeId, dtmLinkStateNrOfLinks=dtmLinkStateNrOfLinks)

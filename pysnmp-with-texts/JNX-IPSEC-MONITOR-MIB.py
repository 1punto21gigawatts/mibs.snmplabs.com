#
# PySNMP MIB module JNX-IPSEC-MONITOR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/JNX-IPSEC-MONITOR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:58:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
jnxMibs, = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs")
jnxSpSvcSetName, = mibBuilder.importSymbols("JUNIPER-SP-MIB", "jnxSpSvcSetName")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, Integer32, ModuleIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, iso, Unsigned32, Counter32, Counter64, IpAddress, MibIdentifier, Bits, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Integer32", "ModuleIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "iso", "Unsigned32", "Counter32", "Counter64", "IpAddress", "MibIdentifier", "Bits", "NotificationType")
TextualConvention, TimeInterval, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TimeInterval", "DisplayString")
jnxIpSecMonitorMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 22))
jnxIpSecMonitorMIB.setRevisions(('2012-02-10 21:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: jnxIpSecMonitorMIB.setRevisionsDescriptions(('Initial version implements only the following tables: - IKE tunnel table - IPSec tunnel table - IPSec security associations table ',))
if mibBuilder.loadTexts: jnxIpSecMonitorMIB.setLastUpdated('201202102100Z')
if mibBuilder.loadTexts: jnxIpSecMonitorMIB.setOrganization('Juniper Networks, Inc.')
if mibBuilder.loadTexts: jnxIpSecMonitorMIB.setContactInfo('Juniper Technical Assistance Center Juniper Networks, Inc. 1194 N. Mathilda Avenue Sunnyvale, CA 94089 E-mail: support@juniper.net')
if mibBuilder.loadTexts: jnxIpSecMonitorMIB.setDescription(' ')
class JnxIkePeerType(TextualConvention, Integer32):
    description = 'The type of IPsec Phase-1 IKE peer identity. The IKE peer may be identified by one of the ID types defined in IPSEC DOI.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("unknown", 0), ("idIpv4Addr", 1), ("idFqdn", 2), ("idDn", 3))

class JnxIkeNegoMode(TextualConvention, Integer32):
    description = 'The IPsec Phase-1 IKE negotiation mode.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("main", 1), ("aggressive", 2), ("ikev2", 3))

class JnxIkeHashAlgo(TextualConvention, Integer32):
    description = 'The hash algorithm used in IPsec Phase-1 IKE negotiations.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("md5", 1), ("sha", 2), ("sha256", 3), ("sha384", 4))

class JnxIkeAuthMethod(TextualConvention, Integer32):
    description = 'The authentication method used in IPsec Phase-1 IKE negotiations.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("preSharedKey", 1), ("dssSignature", 2), ("rsaSignature", 3), ("rsaEncryption", 4), ("revRsaEncryption", 5))

class JnxIkePeerRole(TextualConvention, Integer32):
    description = 'Role of the local endpoint in negotiating the IPsec Phase-1 IKE security association. It can be either Initiator or Responder.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("initiator", 1), ("responder", 2))

class JnxIkeNegState(TextualConvention, Integer32):
    description = 'State of the Phase-1 IKE negotiation.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("matured", 1), ("notmatured", 2))

class JnxDiffHellmanGrp(TextualConvention, Integer32):
    description = 'The Diffie Hellman Group used in negotiations. modp768 -- 768-bit MODP modp1024 -- 1024-bit MODP modp1536 -- 1536-bit MODP modp2048 -- 2048-bit MODP ec-modp256 -- 256-bit EC-MODP ec-modp384 -- 384-bit EC-MODP '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 14, 19, 20))
    namedValues = NamedValues(("unknown", 0), ("modp768", 1), ("modp1024", 2), ("modp1536", 5), ("modp2048", 14), ("ecmodp256", 19), ("ecmodp384", 20))

class JnxKeyType(TextualConvention, Integer32):
    description = 'The type of key used by an IPsec Phase-2 Tunnel.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unknown", 0), ("keyIke", 1), ("keyManual", 2))

class JnxEncapMode(TextualConvention, Integer32):
    description = 'The encapsulation mode used by an IPsec Phase-2 Tunnel.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unknown", 0), ("tunnel", 1), ("transport", 2))

class JnxEncryptAlgo(TextualConvention, Integer32):
    description = 'The encryption algorithm used in negotiations.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("espDes", 1), ("esp3des", 2), ("espNull", 3), ("espAes128", 4), ("espAes192", 5), ("espAes256", 6))

class JnxSpi(TextualConvention, Unsigned32):
    description = 'The type of the SPI associated with IPsec Phase-2 security associations.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(256, 4294967295)

class JnxAuthAlgo(TextualConvention, Integer32):
    description = 'The authentication algorithm used by a security association of an IPsec Phase-2 Tunnel.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 2, 3, 4))
    namedValues = NamedValues(("unknown", 0), ("hmacMd5", 2), ("hmacSha", 3), ("hmacSha256", 4))

class JnxRemotePeerType(TextualConvention, Integer32):
    description = 'The type of the remote peer gateway (endpoint). It can be one of the following two types: - static (Remote peer whose IP address is known beforehand) - dynamic (Remote peer whose IP address is not known beforehand)'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unknown", 0), ("static", 1), ("dynamic", 2))

class JnxSAType(TextualConvention, Integer32):
    description = 'SA Type manual or dynamic'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unknown", 0), ("manual", 1), ("dynamic", 2))

jnxIpSecMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1))
jnxIpSecLevels = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 1))
jnxIpSecPhaseOne = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2))
jnxIpSecPhaseTwo = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3))
jnxIpSecMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecMibLevel.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecMibLevel.setDescription('The version of the IPsec MIB.')
jnxIkeTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1), )
if mibBuilder.loadTexts: jnxIkeTunnelTable.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunnelTable.setDescription('The IPsec Phase-1 Internet Key Exchange Tunnel Table. There is one entry in this table for each active IPsec Phase-1 IKE Tunnel.')
jnxIkeTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1), ).setIndexNames((0, "JUNIPER-SP-MIB", "jnxSpSvcSetName"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIkeTunRemoteGwAddrType"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIkeTunRemoteGwAddr"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIkeTunIndex"))
if mibBuilder.loadTexts: jnxIkeTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunnelEntry.setDescription('Each entry contains the attributes associated with an active IPsec Phase-1 IKE Tunnel.')
jnxIkeTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: jnxIkeTunIndex.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunIndex.setDescription('The index of the IPsec Phase-1 IKE Tunnel Table. The value of the index is a number which begins at one and is incremented with each tunnel that is created. The value of this object will wrap at 2,147,483,647.')
jnxIkeTunLocalRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 2), JnxIkePeerRole()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalRole.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunLocalRole.setDescription('The role of local peer identity. The Role of the local peer can be: 1. initiator. 2. or responder.')
jnxIkeTunNegState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 3), JnxIkeNegState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunNegState.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunNegState.setDescription('The state of the current negotiation , It can be 1. matured 2. not matured ')
jnxIkeTunInitiatorCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunInitiatorCookie.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunInitiatorCookie.setDescription('Cookie as generated by the peer that initiated the IKE Phase-1 negotiation. This cookie is carried in the ISAKMP header.')
jnxIkeTunResponderCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunResponderCookie.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunResponderCookie.setDescription('Cookie as generated by the peer responding to the IKE Phase-1 negotiation initiated by the remote peer. This cookie is carried in the ISAKMP header.')
jnxIkeTunLocalIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 6), JnxIkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalIdType.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunLocalIdType.setDescription('The type of local peer identity. The local peer may be identified by: 1. an IP address, or 2. or a fully qualified domain name string. 3. or a distinguished name string.')
jnxIkeTunLocalIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalIdValue.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunLocalIdValue.setDescription('The value of the local peer identity. If the local peer type is an IP Address, then this is the IP Address used to identify the local peer. If the local peer type is id_fqdn, then this is the FQDN of the remote peer. If the local peer type is a id_dn, then this is the distinguished name string of the local peer.')
jnxIkeTunLocalGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalGwAddrType.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunLocalGwAddrType.setDescription('The IP address type of the local endpoint (gateway) for the IPsec Phase-1 IKE Tunnel.')
jnxIkeTunLocalGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalGwAddr.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunLocalGwAddr.setDescription('The IP address of the local endpoint (gateway) for the IPsec Phase-1 IKE Tunnel.')
jnxIkeTunLocalCertName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalCertName.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunLocalCertName.setDescription('Name of the certificate used for authentication of the local tunnel endpoint. This object will have some valid value only if negotiated IKE authentication method is other than pre-saherd key. If the IKE negotiation do not use certificate based authentication method, then the value of this object will be a NULL string.')
jnxIkeTunRemoteIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 11), JnxIkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunRemoteIdType.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunRemoteIdType.setDescription('The type of remote peer identity. The remote peer may be identified by: 1. an IP address, or 2. or a fully qualified domain name string. 3. or a distinguished name string.')
jnxIkeTunRemoteIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunRemoteIdValue.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunRemoteIdValue.setDescription('The value of the remote peer identity. If the remote peer type is an IP Address, then this is the IP Address used to identify the remote peer. If the remote peer type is id_fqdn, then this is the FQDN of the remote peer. If the remote peer type is a id_dn, then this is the distinguished named string of the remote peer.')
jnxIkeTunRemoteGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 13), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunRemoteGwAddrType.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunRemoteGwAddrType.setDescription('The IP address type of the remote gateway (endpoint) for the IPsec Phase-1 IKE Tunnel.')
jnxIkeTunRemoteGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 14), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunRemoteGwAddr.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunRemoteGwAddr.setDescription('The IP address of the remote gateway (endpoint) for the IPsec Phase-1 IKE Tunnel.')
jnxIkeTunNegoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 15), JnxIkeNegoMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunNegoMode.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunNegoMode.setDescription('The negotiation mode of the IPsec Phase-1 IKE Tunnel.')
jnxIkeTunDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 16), JnxDiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunDiffHellmanGrp.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunDiffHellmanGrp.setDescription('The Diffie Hellman Group used in IPsec Phase-1 IKE negotiations.')
jnxIkeTunEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 17), JnxEncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunEncryptAlgo.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunEncryptAlgo.setDescription('The encryption algorithm used in IPsec Phase-1 IKE negotiations.')
jnxIkeTunHashAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 18), JnxIkeHashAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunHashAlgo.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunHashAlgo.setDescription('The hash algorithm used in IPsec Phase-1 IKE negotiations.')
jnxIkeTunAuthMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 19), JnxIkeAuthMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunAuthMethod.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunAuthMethod.setDescription('The authentication method used in IPsec Phase-1 IKE negotiations.')
jnxIkeTunLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLifeTime.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunLifeTime.setDescription('The negotiated LifeTime of the IPsec Phase-1 IKE Tunnel in seconds.')
jnxIkeTunActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 21), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunActiveTime.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunActiveTime.setDescription('The length of time the IPsec Phase-1 IKE tunnel has been active in hundredths of seconds.')
jnxIkeTunInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 22), Counter64()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunInOctets.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunInOctets.setDescription('The total number of octets received by this IPsec Phase-1 IKE security association.')
jnxIkeTunInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 23), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunInPkts.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunInPkts.setDescription('The total number of packets received by this IPsec Phase-1 IKE security association.')
jnxIkeTunOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 24), Counter64()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunOutOctets.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunOutOctets.setDescription('The total number of octets sent by this IPsec Phase-1 IKE security association.')
jnxIkeTunOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 25), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunOutPkts.setStatus('current')
if mibBuilder.loadTexts: jnxIkeTunOutPkts.setDescription('The total number of packets sent by this IPsec Phase-1 IKE security association.')
jnxIpSecTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1), )
if mibBuilder.loadTexts: jnxIpSecTunnelTable.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunnelTable.setDescription('The IPsec Phase-2 Tunnel Table. There is one entry in this table for each active IPsec Phase-2 Tunnel.')
jnxIpSecTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1), ).setIndexNames((0, "JUNIPER-SP-MIB", "jnxSpSvcSetName"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunRemoteGwAddrType"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunRemoteGwAddr"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunIndex"))
if mibBuilder.loadTexts: jnxIpSecTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunnelEntry.setDescription('Each entry contains the attributes associated with an active IPsec Phase-2 Tunnel.')
jnxIpSecTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: jnxIpSecTunIndex.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunIndex.setDescription('The index of the IPsec Phase-2 Tunnel Table. The value of the index is a number which begins at one and is incremented with each tunnel that is created. The value of this object will wrap at 2,147,483,647.')
jnxIpSecRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecRuleName.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecRuleName.setDescription('Name of the rule configured in IPSec configuration.')
jnxIpSecTermName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTermName.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTermName.setDescription('Name of the term configured under IPSec rule.')
jnxIpSecTunLocalGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunLocalGwAddrType.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunLocalGwAddrType.setDescription('The IP address type of the local gateway (endpoint) for the IPsec Phase-2 Tunnel.')
jnxIpSecTunLocalGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunLocalGwAddr.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunLocalGwAddr.setDescription('The IP address of the local gateway (endpoint) for the IPsec Phase-2 Tunnel.')
jnxIpSecTunRemoteGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunRemoteGwAddrType.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunRemoteGwAddrType.setDescription('The IP address type of the remote gateway (endpoint) for the IPsec Phase-2 Tunnel.')
jnxIpSecTunRemoteGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunRemoteGwAddr.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunRemoteGwAddr.setDescription('The IP address of the remote gateway (endpoint) for the IPsec Phase-2 Tunnel.')
jnxIpSecTunLocalProxyId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunLocalProxyId.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunLocalProxyId.setDescription('Identifier for the local end.')
jnxIpSecTunRemoteProxyId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunRemoteProxyId.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunRemoteProxyId.setDescription('Identifier for the remote end.')
jnxIpSecTunKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 10), JnxKeyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunKeyType.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunKeyType.setDescription('The type of key used by the IPsec Phase-2 Tunnel. It can be one of the following two types: - IKE negotiated - Manually installed')
jnxIpSecRemotePeerType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 11), JnxRemotePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecRemotePeerType.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecRemotePeerType.setDescription('The type of the remote peer gateway (endpoint). It can be one of the following two types: - static (Remote peer whose IP address is known beforehand) - dynamic (Remote peer whose IP address is not known beforehand)')
jnxIpSecTunMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMtu.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunMtu.setDescription('MTU value of this Phase-2 tunnel.')
jnxIpSecTunOutEncryptedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunOutEncryptedBytes.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunOutEncryptedBytes.setDescription('Number of bytes encrypted by this Phase-2 tunnel.')
jnxIpSecTunOutEncryptedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunOutEncryptedPkts.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunOutEncryptedPkts.setDescription('Number of packets encrypted by this Phase-2 tunnel.')
jnxIpSecTunInDecryptedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunInDecryptedBytes.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunInDecryptedBytes.setDescription('Number of bytes decrypted by this Phase-2 tunnel.')
jnxIpSecTunInDecryptedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunInDecryptedPkts.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunInDecryptedPkts.setDescription('Number of packets decrypted by this Phase-2 tunnel.')
jnxIpsSecTunAHInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpsSecTunAHInBytes.setStatus('current')
if mibBuilder.loadTexts: jnxIpsSecTunAHInBytes.setDescription('Number of incoming bytes authenticated using AH by this Phase-2 tunnel.')
jnxIpsSecTunAHInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpsSecTunAHInPkts.setStatus('current')
if mibBuilder.loadTexts: jnxIpsSecTunAHInPkts.setDescription('Number of incoming packets authenticated using AH by this Phase-2 tunnel.')
jnxIpsSecTunAHOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpsSecTunAHOutBytes.setStatus('current')
if mibBuilder.loadTexts: jnxIpsSecTunAHOutBytes.setDescription('Number of outgoing bytes applied AH by this Phase-2 tunnel.')
jnxIpsSecTunAHOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpsSecTunAHOutPkts.setStatus('current')
if mibBuilder.loadTexts: jnxIpsSecTunAHOutPkts.setDescription('Number of outgoing packets applied AH by this Phase-2 tunnel.')
jnxIpSecTunReplayDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunReplayDropPkts.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunReplayDropPkts.setDescription('Number of packets dropped by this Phase-2 tunnel due to anti replay check failure.')
jnxIpSecTunAhAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunAhAuthFails.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunAhAuthFails.setDescription('Number of packets received by this Phase-2 tunnel that failed AH authentication.')
jnxIpSecTunEspAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunEspAuthFails.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunEspAuthFails.setDescription('Number of packets received by this Phase-2 tunnel that failed ESP authentication.')
jnxIpSecTunDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunDecryptFails.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunDecryptFails.setDescription('Number of packets received by this Phase-2 tunnel that failed decryption.')
jnxIpSecTunBadHeaders = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 25), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunBadHeaders.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunBadHeaders.setDescription('Number of packets received by this Phase-2 tunnel that failed due to bad headers.')
jnxIpSecTunBadTrailers = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunBadTrailers.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunBadTrailers.setDescription('Number of packets received by this Phase-2 tunnel that failed due to bad ESP trailers.')
jnxIpSecTunDroppedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunDroppedPkts.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecTunDroppedPkts.setDescription('Total number of dropped packets for this Phase-2 tunnel.')
jnxIpSecSaTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2), )
if mibBuilder.loadTexts: jnxIpSecSaTable.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaTable.setDescription('The IPsec Phase-2 Security Association Table. This table identifies the structure (in terms of component SAs) of each active Phase-2 IPsec tunnel. This table contains an entry for each active and expiring security association and maps each entry in the active Phase-2 tunnel table (ipSecTunTable) into a number of entries in this table. The index of this table reflects the <destination-address, protocol, spi> rule for identifying Security Associations.')
jnxIpSecSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1), ).setIndexNames((0, "JUNIPER-SP-MIB", "jnxSpSvcSetName"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunRemoteGwAddrType"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunRemoteGwAddr"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunIndex"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecSaIndex"))
if mibBuilder.loadTexts: jnxIpSecSaEntry.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaEntry.setDescription('Each entry contains the attributes associated with active and expiring IPsec Phase-2 security associations.')
jnxIpSecSaProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ah", 1), ("esp", 2))))
if mibBuilder.loadTexts: jnxIpSecSaProtocol.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaProtocol.setDescription('The index, represents the security protocol (AH, ESP or IPComp) for which this security association was setup.')
jnxIpSecSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: jnxIpSecSaIndex.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaIndex.setDescription('The index, in the context of the IPsec tunnel ipSecTunIndex, of the security association represented by this table entry. The value of this index is a number which begins at one and is incremented with each SPI associated with an IPsec Phase-2 Tunnel. The value of this object will wrap at 2,147,483,647.')
jnxIpSecSaInSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 3), JnxSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaInSpi.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaInSpi.setDescription('The value of the incoming SPI.')
jnxIpSecSaOutSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 4), JnxSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaOutSpi.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaOutSpi.setDescription('The value of the outgoing SPI.')
jnxIpSecSaInAuxSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 5), JnxSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaInAuxSpi.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaInAuxSpi.setDescription('The value of the incoming auxiliary SPI. This is valid for AH and ESP bundles.')
jnxIpSecSaOutAuxSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 6), JnxSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaOutAuxSpi.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaOutAuxSpi.setDescription('The value of the outgoing auxiliary SPI. This is valid for AH and ESP bundles.')
jnxIpSecSaType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 7), JnxSAType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaType.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaType.setDescription('This field represents the type of security associations which can be either manual or dynamic')
jnxIpSecSaEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 8), JnxEncapMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaEncapMode.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaEncapMode.setDescription('The encapsulation mode used by an IPsec Phase-2 Tunnel. ')
jnxIpSecSaLifeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaLifeSize.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaLifeSize.setDescription('The negotiated LifeSize of the IPsec Phase-2 Tunnel in kilobytes. ')
jnxIpSecSaLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaLifeTime.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaLifeTime.setDescription('The negotiated LifeTime of the IPsec Phase-2 Tunnel in seconds. ')
jnxIpSecSaActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 11), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaActiveTime.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaActiveTime.setDescription('The length of time the IPsec Phase-2 Tunnel has been active in seconds. ')
jnxIpSecSaLifeSizeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaLifeSizeThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaLifeSizeThreshold.setDescription('The security association LifeSize refresh threshold in kilobytes. ')
jnxIpSecSaLifeTimeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaLifeTimeThreshold.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaLifeTimeThreshold.setDescription('The security association LifeTime refresh threshold in seconds. ')
jnxIpSecSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 14), JnxEncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaEncryptAlgo.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaEncryptAlgo.setDescription('The Encryption algorithm used to encrypt the packets which can be either es-cbc or 3des-cbc. ')
jnxIpSecSaAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 15), JnxAuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaAuthAlgo.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaAuthAlgo.setDescription('The algorithm used for authentication of packets which can be hmac-md5-96 or hmac-sha1-96')
jnxIpSecSaState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("active", 1), ("expiring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaState.setStatus('current')
if mibBuilder.loadTexts: jnxIpSecSaState.setDescription("This column represents the status of the security association represented by this table entry. If the status of the SA is 'active', the SA is ready for active use. The status 'expiring' represents any of the various states that the security association transitions through before being purged.")
mibBuilder.exportSymbols("JNX-IPSEC-MONITOR-MIB", jnxIpSecTunDecryptFails=jnxIpSecTunDecryptFails, jnxIpSecSaIndex=jnxIpSecSaIndex, JnxSAType=JnxSAType, jnxIpSecTunOutEncryptedBytes=jnxIpSecTunOutEncryptedBytes, jnxIpSecSaActiveTime=jnxIpSecSaActiveTime, jnxIpSecMIBObjects=jnxIpSecMIBObjects, jnxIpSecSaProtocol=jnxIpSecSaProtocol, jnxIkeTunLocalIdType=jnxIkeTunLocalIdType, jnxIpSecTunRemoteGwAddrType=jnxIpSecTunRemoteGwAddrType, jnxIpSecMibLevel=jnxIpSecMibLevel, jnxIkeTunLocalRole=jnxIkeTunLocalRole, jnxIkeTunRemoteGwAddr=jnxIkeTunRemoteGwAddr, jnxIkeTunResponderCookie=jnxIkeTunResponderCookie, jnxIkeTunInitiatorCookie=jnxIkeTunInitiatorCookie, jnxIpSecRuleName=jnxIpSecRuleName, jnxIpSecTunDroppedPkts=jnxIpSecTunDroppedPkts, jnxIpSecTunInDecryptedBytes=jnxIpSecTunInDecryptedBytes, jnxIpSecLevels=jnxIpSecLevels, jnxIpSecPhaseOne=jnxIpSecPhaseOne, jnxIkeTunHashAlgo=jnxIkeTunHashAlgo, JnxAuthAlgo=JnxAuthAlgo, jnxIpSecTunInDecryptedPkts=jnxIpSecTunInDecryptedPkts, jnxIpSecSaLifeSizeThreshold=jnxIpSecSaLifeSizeThreshold, jnxIpSecSaLifeTimeThreshold=jnxIpSecSaLifeTimeThreshold, jnxIpSecSaLifeTime=jnxIpSecSaLifeTime, jnxIkeTunAuthMethod=jnxIkeTunAuthMethod, JnxIkeNegState=JnxIkeNegState, jnxIpSecSaEncapMode=jnxIpSecSaEncapMode, jnxIpSecTunLocalGwAddrType=jnxIpSecTunLocalGwAddrType, jnxIkeTunDiffHellmanGrp=jnxIkeTunDiffHellmanGrp, jnxIpSecTunRemoteGwAddr=jnxIpSecTunRemoteGwAddr, jnxIpSecRemotePeerType=jnxIpSecRemotePeerType, jnxIkeTunRemoteGwAddrType=jnxIkeTunRemoteGwAddrType, jnxIpsSecTunAHOutBytes=jnxIpsSecTunAHOutBytes, jnxIpSecTunMtu=jnxIpSecTunMtu, jnxIkeTunnelTable=jnxIkeTunnelTable, JnxSpi=JnxSpi, jnxIpSecTunKeyType=jnxIpSecTunKeyType, jnxIkeTunLocalGwAddr=jnxIkeTunLocalGwAddr, JnxEncryptAlgo=JnxEncryptAlgo, jnxIpSecTunnelTable=jnxIpSecTunnelTable, jnxIkeTunOutOctets=jnxIkeTunOutOctets, PYSNMP_MODULE_ID=jnxIpSecMonitorMIB, jnxIkeTunIndex=jnxIkeTunIndex, JnxDiffHellmanGrp=JnxDiffHellmanGrp, jnxIpSecTunLocalProxyId=jnxIpSecTunLocalProxyId, jnxIpSecTunEspAuthFails=jnxIpSecTunEspAuthFails, jnxIpSecSaState=jnxIpSecSaState, jnxIkeTunNegState=jnxIkeTunNegState, jnxIpSecTermName=jnxIpSecTermName, jnxIkeTunLocalGwAddrType=jnxIkeTunLocalGwAddrType, jnxIpSecTunBadTrailers=jnxIpSecTunBadTrailers, JnxIkeHashAlgo=JnxIkeHashAlgo, jnxIkeTunOutPkts=jnxIkeTunOutPkts, jnxIkeTunEncryptAlgo=jnxIkeTunEncryptAlgo, JnxIkePeerRole=JnxIkePeerRole, jnxIpsSecTunAHInBytes=jnxIpsSecTunAHInBytes, jnxIpSecSaTable=jnxIpSecSaTable, JnxIkePeerType=JnxIkePeerType, jnxIpSecSaOutSpi=jnxIpSecSaOutSpi, jnxIpSecSaEncryptAlgo=jnxIpSecSaEncryptAlgo, jnxIkeTunRemoteIdType=jnxIkeTunRemoteIdType, jnxIkeTunLocalCertName=jnxIkeTunLocalCertName, jnxIpSecSaEntry=jnxIpSecSaEntry, jnxIpSecSaOutAuxSpi=jnxIpSecSaOutAuxSpi, jnxIpSecTunBadHeaders=jnxIpSecTunBadHeaders, jnxIkeTunLifeTime=jnxIkeTunLifeTime, jnxIpSecSaLifeSize=jnxIpSecSaLifeSize, jnxIpSecTunAhAuthFails=jnxIpSecTunAhAuthFails, jnxIkeTunActiveTime=jnxIkeTunActiveTime, jnxIpsSecTunAHInPkts=jnxIpsSecTunAHInPkts, jnxIkeTunNegoMode=jnxIkeTunNegoMode, jnxIkeTunInOctets=jnxIkeTunInOctets, jnxIkeTunLocalIdValue=jnxIkeTunLocalIdValue, jnxIpSecTunReplayDropPkts=jnxIpSecTunReplayDropPkts, jnxIpSecTunIndex=jnxIpSecTunIndex, jnxIkeTunRemoteIdValue=jnxIkeTunRemoteIdValue, JnxKeyType=JnxKeyType, jnxIkeTunnelEntry=jnxIkeTunnelEntry, jnxIpSecSaInSpi=jnxIpSecSaInSpi, jnxIpsSecTunAHOutPkts=jnxIpsSecTunAHOutPkts, jnxIpSecSaInAuxSpi=jnxIpSecSaInAuxSpi, JnxIkeNegoMode=JnxIkeNegoMode, JnxIkeAuthMethod=JnxIkeAuthMethod, JnxRemotePeerType=JnxRemotePeerType, jnxIpSecPhaseTwo=jnxIpSecPhaseTwo, JnxEncapMode=JnxEncapMode, jnxIpSecSaAuthAlgo=jnxIpSecSaAuthAlgo, jnxIpSecSaType=jnxIpSecSaType, jnxIpSecTunOutEncryptedPkts=jnxIpSecTunOutEncryptedPkts, jnxIpSecTunnelEntry=jnxIpSecTunnelEntry, jnxIkeTunInPkts=jnxIkeTunInPkts, jnxIpSecTunRemoteProxyId=jnxIpSecTunRemoteProxyId, jnxIpSecTunLocalGwAddr=jnxIpSecTunLocalGwAddr, jnxIpSecMonitorMIB=jnxIpSecMonitorMIB)

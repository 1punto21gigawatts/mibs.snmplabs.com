#
# PySNMP MIB module FASTTRAKIDERAID-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/FASTTRAKIDERAID-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:12:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Counter32, Counter64, enterprises, Gauge32, NotificationType, ObjectIdentity, NotificationType, IpAddress, Integer32, ModuleIdentity, iso, Bits, Unsigned32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter32", "Counter64", "enterprises", "Gauge32", "NotificationType", "ObjectIdentity", "NotificationType", "IpAddress", "Integer32", "ModuleIdentity", "iso", "Bits", "Unsigned32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class DmiInteger(Integer32):
    pass

class DmiDisplaystring(DisplayString):
    pass

class DmiDateX(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(28, 28)
    fixedLength = 28

class DmiComponentIndex(Integer32):
    pass

promise = MibIdentifier((1, 3, 6, 1, 4, 1, 7933))
intel = MibIdentifier((1, 3, 6, 1, 4, 1, 7933, 343))
fasttrak = MibIdentifier((1, 3, 6, 1, 4, 1, 7933, 343, 1))
isc3xtraps = MibIdentifier((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1))
dmtfGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1))
tComponentid = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 1), )
if mibBuilder.loadTexts: tComponentid.setStatus('mandatory')
if mibBuilder.loadTexts: tComponentid.setDescription('This group defines the attributes common to all components. This group is required.')
eComponentid = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 1, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"))
if mibBuilder.loadTexts: eComponentid.setStatus('mandatory')
if mibBuilder.loadTexts: eComponentid.setDescription('')
a1Manufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 1, 1, 1), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a1Manufacturer.setStatus('mandatory')
if mibBuilder.loadTexts: a1Manufacturer.setDescription('Manufacturer of this system.')
a1Product = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 1, 1, 2), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a1Product.setStatus('mandatory')
if mibBuilder.loadTexts: a1Product.setDescription('Product name for this system.')
a1Version = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 1, 1, 3), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a1Version.setStatus('mandatory')
if mibBuilder.loadTexts: a1Version.setDescription('Version number of this system.')
a1SerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 1, 1, 4), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a1SerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: a1SerialNumber.setDescription('Serial number for this system.')
a1Installation = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 1, 1, 5), DmiDateX()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a1Installation.setStatus('mandatory')
if mibBuilder.loadTexts: a1Installation.setDescription('The time and date when this component was installed.')
a1Verify = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("vAnErrorOccurredCheckStatusCode", 0), ("vThisComponentDoesNotExist", 1), ("vVerificationIsNotSupported", 2), ("vReserved", 3), ("vThisComponentExistsButTheFunctionalityI", 4), ("vThisComponentExistsButTheFunctionality1", 5), ("vThisComponentExistsAndIsNotFunctioningC", 6), ("vThisComponentExistsAndIsFunctioningCorr", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a1Verify.setStatus('mandatory')
if mibBuilder.loadTexts: a1Verify.setDescription('A code that provides a level of verification that the component is still installed and working.')
tDiskController = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45), )
if mibBuilder.loadTexts: tDiskController.setStatus('mandatory')
if mibBuilder.loadTexts: tDiskController.setDescription('This group defines the disk controller in this system.')
eDiskController = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a45DiskControllerIndex"))
if mibBuilder.loadTexts: eDiskController.setStatus('mandatory')
if mibBuilder.loadTexts: eDiskController.setDescription('')
a45DiskControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1, 1), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a45DiskControllerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a45DiskControllerIndex.setDescription('Index value used by the system to identify the disk controller.')
a45FruGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1, 2), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a45FruGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a45FruGroupIndex.setDescription("If this is a Field Replaceable Unit or if it is part of another FRU, this provides an index into the FRU table; 'value = -1' indicates that the group is not a FRU.")
a45OperationalGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1, 3), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a45OperationalGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a45OperationalGroupIndex.setDescription('The index into the Operational State table for this device.')
a45SystemSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1, 4), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a45SystemSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a45SystemSlotIndex.setDescription('Index value in System Slot table of disk Controller. 0 = no slot')
a45DiskControllerIdentification = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1, 5), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a45DiskControllerIdentification.setStatus('mandatory')
if mibBuilder.loadTexts: a45DiskControllerIdentification.setDescription('Name, brand and hardware revision level of the disk controller.')
a45ControllerSoftwareRevisionLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1, 6), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a45ControllerSoftwareRevisionLevel.setStatus('mandatory')
if mibBuilder.loadTexts: a45ControllerSoftwareRevisionLevel.setDescription('Level and version of the software associated with this controlle .')
a45ControllerChannelCount = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1, 7), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a45ControllerChannelCount.setStatus('mandatory')
if mibBuilder.loadTexts: a45ControllerChannelCount.setDescription('The number of channels supported by this controller. 0x80000000 = Unknown')
a45ControllerMaximumDevices = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 45, 1, 8), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a45ControllerMaximumDevices.setStatus('mandatory')
if mibBuilder.loadTexts: a45ControllerMaximumDevices.setDescription('The maximum number of devices for all channels which can be controlled by this disk controller. 0x80000000 = Unknown ')
tDisks = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49), )
if mibBuilder.loadTexts: tDisks.setStatus('mandatory')
if mibBuilder.loadTexts: tDisks.setDescription('This group defines the physical attributes of disk mass storage devices in this system.')
eDisks = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a49StorageType"), (0, "FASTTRAKIDERAID-MIB", "a49DiskIndex"))
if mibBuilder.loadTexts: eDisks.setStatus('mandatory')
if mibBuilder.loadTexts: eDisks.setDescription('')
a49StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vHardDisk", 3), ("vFloppyDisk", 4), ("vOpticalRom", 5), ("vOpticalWorm", 6), ("vOpticalRw", 7), ("vCompactDisk", 8), ("vFlashDisk", 9), ("vBernoulli", 10), ("vOpticalFloppyDisk", 11), ("vDigitalVersatileDiskDvdDrive", 12), ("vDigitalVersatileDiskDvdRamDrive", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: a49StorageType.setDescription('The type of this mass storage device.')
a49DiskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 2), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49DiskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a49DiskIndex.setDescription('An index into the disk table.')
a49StorageInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vScsi", 3), ("vEsdi", 4), ("vIde", 5), ("vCmd", 6), ("vIpi", 7), ("vSt506", 8), ("vDssi", 9), ("vParallelPort", 10), ("vHippi", 11), ("vQic2", 12), ("vFloppyDiskInterface", 13), ("vPcmcia", 14), ("vEnhancedAtaide", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49StorageInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: a49StorageInterfaceType.setDescription('The interface used by this mass storage device.')
a49InterfaceDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 4), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49InterfaceDescription.setStatus('mandatory')
if mibBuilder.loadTexts: a49InterfaceDescription.setDescription('A longer description of the mass storage interface. For example, SCSI2 fast wide.')
a49MediaLoaded = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vFalse", 0), ("vTrue", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49MediaLoaded.setStatus('mandatory')
if mibBuilder.loadTexts: a49MediaLoaded.setDescription('If true, the media is loaded.')
a49RemovableDrive = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vFalse", 0), ("vTrue", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49RemovableDrive.setStatus('mandatory')
if mibBuilder.loadTexts: a49RemovableDrive.setDescription('If true, this drive is removable.')
a49RemovableMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vFalse", 0), ("vTrue", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49RemovableMedia.setStatus('mandatory')
if mibBuilder.loadTexts: a49RemovableMedia.setDescription('If true, the media in this drive is removable.')
a49DeviceId = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 8), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49DeviceId.setStatus('mandatory')
if mibBuilder.loadTexts: a49DeviceId.setDescription('The SCSI address of this device.')
a49LogicalUnitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 9), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49LogicalUnitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: a49LogicalUnitNumber.setDescription('The logical unit number of this SCSI device.')
a49NumberOfPhysicalCylinders = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 10), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49NumberOfPhysicalCylinders.setStatus('mandatory')
if mibBuilder.loadTexts: a49NumberOfPhysicalCylinders.setDescription('The number of reported physical cylinders on this device.')
a49NumberOfPhysicalSectorsPerTrack = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 11), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49NumberOfPhysicalSectorsPerTrack.setStatus('mandatory')
if mibBuilder.loadTexts: a49NumberOfPhysicalSectorsPerTrack.setDescription('The number of reported physical sectors per track for this device.')
a49NumberOfPhysicalHeads = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 12), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49NumberOfPhysicalHeads.setStatus('mandatory')
if mibBuilder.loadTexts: a49NumberOfPhysicalHeads.setDescription('The number of reported physical heads for this device.')
a49PhysicalCylinderForWritePrecompensati = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 13), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49PhysicalCylinderForWritePrecompensati.setStatus('mandatory')
if mibBuilder.loadTexts: a49PhysicalCylinderForWritePrecompensati.setDescription('Specifies the physical cylinder used for write precompensation on this device.')
a49PhysicalCylinderForLandingZone = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 14), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49PhysicalCylinderForLandingZone.setStatus('mandatory')
if mibBuilder.loadTexts: a49PhysicalCylinderForLandingZone.setDescription('The physical landing zone cylinder of this device.')
a49SectorSize = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 15), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49SectorSize.setStatus('mandatory')
if mibBuilder.loadTexts: a49SectorSize.setDescription('The size in bytes of the physical disk sector or logical block as reported by the disk.')
a49TotalPhysicalSize = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 16), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49TotalPhysicalSize.setStatus('mandatory')
if mibBuilder.loadTexts: a49TotalPhysicalSize.setDescription('The total size in kilobytes (1024 bytes) of this device that is available to users')
a49NumberOfCurrentBadBlocksOrSectors = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 17), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49NumberOfCurrentBadBlocksOrSectors.setStatus('mandatory')
if mibBuilder.loadTexts: a49NumberOfCurrentBadBlocksOrSectors.setDescription('The number of current bad blocks or sectors to include total of both factory assigned and grown defects.')
a49Partitions = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 18), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49Partitions.setStatus('mandatory')
if mibBuilder.loadTexts: a49Partitions.setDescription('The number of partitions on this storage unit.')
a49PhysicalLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vInternal", 3), ("vExternal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49PhysicalLocation.setStatus('mandatory')
if mibBuilder.loadTexts: a49PhysicalLocation.setDescription('The physical location of this disk drive assembly relative to the system enclosure.')
a49FruGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 20), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49FruGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a49FruGroupIndex.setDescription("If this is a Field Replaceable Unit or if it is part of another FRU, this provides an index into the FRU table; 'value = -1' indicates that the group is not a FRU.")
a49OperationalGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 21), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49OperationalGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a49OperationalGroupIndex.setDescription('The index into the Operational State table for this device.')
a49SecuritySettings = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 49, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vNone", 3), ("vRead-only", 4), ("vLockoutEnabled", 5), ("vBoot-bypass", 6), ("vBoot-bypass-Read-only", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a49SecuritySettings.setStatus('mandatory')
if mibBuilder.loadTexts: a49SecuritySettings.setDescription('Enum describing the current hardware security settings on this device')
tMassStoreArrayInfoTable = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 85), )
if mibBuilder.loadTexts: tMassStoreArrayInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: tMassStoreArrayInfoTable.setDescription("This table is a parallel table to the Mass Store Logical Drives Table; it has entries keyed by the same unique index as is used for the logical drives table. This table has one entry corresponding to each entry in the Mass Store Logical Drives Table whose 'Drive Array' field is set to TRUE.")
eMassStoreArrayInfoTable = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 85, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a85LogicalDriveIndex"))
if mibBuilder.loadTexts: eMassStoreArrayInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: eMassStoreArrayInfoTable.setDescription('')
a85LogicalDriveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 85, 1, 1), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a85LogicalDriveIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a85LogicalDriveIndex.setDescription("This is the same index as the 'Logical Drive Index' field in the Mass Store Logical Drives Table. ")
a85DriveArrayLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 85, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vRaid0", 3), ("vRaid1", 4), ("vRaid2", 5), ("vRaid3", 6), ("vRaid4", 7), ("vRaid5", 8), ("vRaid7", 9), ("vRaid10", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a85DriveArrayLevel.setStatus('mandatory')
if mibBuilder.loadTexts: a85DriveArrayLevel.setDescription('This attribute is an Enum of the different possible types of drive arrays that could compose the logical drive represented by the correspo ding entry in the Mass Store Logical Drives Table.')
a85DriveArrayRedundancyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 85, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vFullyRedundant", 3), ("vDegradedRedundancy", 4), ("vRedundancyLost", 5), ("vNotApplicableUnitNotRedundant", 6), ("vUnitFailed", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a85DriveArrayRedundancyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a85DriveArrayRedundancyStatus.setDescription('This attribute identifies which of the different states of the available redundancy in the drive array currently applies.')
a85DriveArrayOperationInProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 85, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vVerify", 3), ("vRebuild", 5), ("vNone", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a85DriveArrayOperationInProgress.setStatus('mandatory')
if mibBuilder.loadTexts: a85DriveArrayOperationInProgress.setDescription('This value of this attribute describes whether the drive array is currently undergoing array operations of some sort.')
tMassStoreLogicalDrivesTable = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 86), )
if mibBuilder.loadTexts: tMassStoreLogicalDrivesTable.setStatus('mandatory')
if mibBuilder.loadTexts: tMassStoreLogicalDrivesTable.setDescription('This table describes the logical drives contained in this component. Logical drives are typically composed of one or more other logical drives or physical segments. Each entry of this table contains information about the size of a logical drive, its string name as set by driver software, and a boolean that describes whether this logical drive is at the top of the logical drive hierarchy or not.')
eMassStoreLogicalDrivesTable = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 86, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a86LogicalDriveIndex"))
if mibBuilder.loadTexts: eMassStoreLogicalDrivesTable.setStatus('mandatory')
if mibBuilder.loadTexts: eMassStoreLogicalDrivesTable.setDescription('')
a86LogicalDriveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 86, 1, 1), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a86LogicalDriveIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a86LogicalDriveIndex.setDescription('A unique index (key) into the Mass Store Logical Drives Table.')
a86TopOfHierarchy = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 86, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vFalse", 0), ("vTrue", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a86TopOfHierarchy.setStatus('mandatory')
if mibBuilder.loadTexts: a86TopOfHierarchy.setDescription('This attribute identifies whether the logical drive represented by this entry is a part of some higher order logical drive or not. If the value of this boolean attribute is TRUE, then this means that this logical drive is not a constituent part of any other logical drive in this component.')
a86DriveArray = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 86, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vFalse", 0), ("vTrue", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a86DriveArray.setStatus('mandatory')
if mibBuilder.loadTexts: a86DriveArray.setDescription('This boolean attribute identifies whether the logical drive represented by this table entry is composed of an array of drives or not. If the value of this attribute is TRUE, then the entry with the same index (as this entry) in the Mass Store Array Info Table will give information about the drive array that comprises this logical drive')
a86LogicalDriveSizeInKb = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 86, 1, 4), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a86LogicalDriveSizeInKb.setStatus('mandatory')
if mibBuilder.loadTexts: a86LogicalDriveSizeInKb.setDescription('This attribute holds the size of this logical drive in kilobytes')
a86LogicalDriveBlockSizeInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 86, 1, 5), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a86LogicalDriveBlockSizeInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: a86LogicalDriveBlockSizeInBytes.setDescription('This attribute holds the size of the allocatable unit of storage on this logical drive. The size of the allocatable unit is given in bytes')
a86LogicalDriveNameString = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 86, 1, 6), DmiDisplaystring()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a86LogicalDriveNameString.setStatus('mandatory')
if mibBuilder.loadTexts: a86LogicalDriveNameString.setDescription('This attribute is simply a container for a string name for the logical drive. The instrumentation code does not assign or manipulate this attribute. It is simply a convenience provided so that driver software may put in this container the string name by which it refers to this logical drive.')
tMassStoreMappingTable = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 87), )
if mibBuilder.loadTexts: tMassStoreMappingTable.setStatus('mandatory')
if mibBuilder.loadTexts: tMassStoreMappingTable.setDescription("This table represents mappings between logical drives and logical or physical drive segments. Each entry in this table describes *one* such mapping. A logical drive may be composed of one, *or more*, such mappings. A segment may be a part of a physical or logical drive or, in the degenerate case, the entire drive may be one segment. The table also contains two fields, namely: (a) 'Parent Drive' a unique index into the Mass Store Logical Drives Table describing the logical drive involved in the mapping, ")
eMassStoreMappingTable = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 87, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a87MappingIndex"))
if mibBuilder.loadTexts: eMassStoreMappingTable.setStatus('mandatory')
if mibBuilder.loadTexts: eMassStoreMappingTable.setDescription('')
a87MappingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 87, 1, 1), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a87MappingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a87MappingIndex.setDescription('Unique index into the Mass Store Mapping Table')
a87ParentDrive = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 87, 1, 2), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a87ParentDrive.setStatus('mandatory')
if mibBuilder.loadTexts: a87ParentDrive.setDescription('Unique index into the Mass Store Logical Drives Table of the entry that represents the parent drive in this mapping.')
a87ChildSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 87, 1, 3), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a87ChildSegment.setStatus('mandatory')
if mibBuilder.loadTexts: a87ChildSegment.setDescription("This field contains the index of the logical or physical segment that is one of the constituents of the parent logical drive referenced by the attribute 'Parent Drive'.This index is a key into the Mass Store Segment Table.")
tMassStoreSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88), )
if mibBuilder.loadTexts: tMassStoreSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: tMassStoreSegmentTable.setDescription('This table describes the various segments on the various physical or logical drives in the component. In some cases a segment may represent an entire drive. In other cases there may be multiple segments on a drive.')
eMassStoreSegmentTable = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a88SegmentIndex"))
if mibBuilder.loadTexts: eMassStoreSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: eMassStoreSegmentTable.setDescription('')
a88SegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1, 1), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a88SegmentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a88SegmentIndex.setDescription('This is a unique index for this segment and is used as a key into this table')
a88SegmentType = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vPhysical", 1), ("vLogical", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a88SegmentType.setStatus('mandatory')
if mibBuilder.loadTexts: a88SegmentType.setDescription("Describes whether the segment is a physical segment on a physical drive or a logical segment on a logical drive. If the value of this attribute is 'Physical' then the physical drive is identified in the Disks table by Drive Key 1 and Drive Key 2 attributes. If the value of this attribute is 'Logical' then the logical drive is identified in the Mass Store Logical Drives table by the Drive Key 2 attribute and the Drive Key 1 attribute is irrelevant")
a88SegmentStart = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1, 3), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a88SegmentStart.setStatus('mandatory')
if mibBuilder.loadTexts: a88SegmentStart.setDescription('This is the index of the allocation unit on the drive at which the media extent corresponding to this segment starts.')
a88SegmentLength = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1, 4), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a88SegmentLength.setStatus('mandatory')
if mibBuilder.loadTexts: a88SegmentLength.setDescription("This is the length of the segment in allocation units inclusive of the starting allocation unit whose index is contained in the attribute 'Segment Start'.")
a88SegmentAllocationUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vPhysicalSector", 3), ("vLogicalBlock", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a88SegmentAllocationUnit.setStatus('mandatory')
if mibBuilder.loadTexts: a88SegmentAllocationUnit.setDescription('The value of this attribute identifies the type of unit of space that can be allocated on the drive.')
a88SegmentAllocationState = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vAllocated", 3), ("vAvailable", 4), ("vDefective", 5), ("vReserved1", 6), ("vSpare", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a88SegmentAllocationState.setStatus('mandatory')
if mibBuilder.loadTexts: a88SegmentAllocationState.setDescription('The value of this attribute identifies the current allocation state of the segment represented by this table entry. NOTE: Reserved = This segment is reserved for vendor use (DO NOT USE this segment for other purposes); Spare = This segment is currently in use being held in reserve for hot sparing.')
a88DriveKey1 = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("vOther", 1), ("vUnknown", 2), ("vHardDisk", 3), ("vFloppyDisk", 4), ("vOpticalRom", 5), ("vOpticalWorm", 6), ("vOpticalRw", 7), ("vCompactDisk", 8), ("vFlashDisk", 9), ("vBernoulli", 10), ("vOpticalFloppyDisk", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a88DriveKey1.setStatus('mandatory')
if mibBuilder.loadTexts: a88DriveKey1.setDescription("If Segment Type is 'Physical' this is one of two keys used to identify a specific disk in the Disks group. If the Segment Type is 'Logical' this attribute is unused and its value is irrelevant.")
a88DriveKey2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 88, 1, 8), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a88DriveKey2.setStatus('mandatory')
if mibBuilder.loadTexts: a88DriveKey2.setDescription("(A) If the value of the attribute Segment Type is 'Physical' then this attribute holds the second of two keys that identify the physical drive in the Disks table group. (B) If the value of the Segment Type is 'Logical then this is the single integer key that identifies the logical drive in the Mass Store Logical Drives table.")
tMiftomib = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 99), )
if mibBuilder.loadTexts: tMiftomib.setStatus('mandatory')
if mibBuilder.loadTexts: tMiftomib.setDescription('This group defines attributes required for DMI to SNMP translati n.')
eMiftomib = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 99, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"))
if mibBuilder.loadTexts: eMiftomib.setStatus('mandatory')
if mibBuilder.loadTexts: eMiftomib.setDescription('')
a99MibName = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 99, 1, 1), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a99MibName.setStatus('mandatory')
if mibBuilder.loadTexts: a99MibName.setDescription('The MIB name that defines this MIF')
a99MibOid = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 99, 1, 2), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a99MibOid.setStatus('mandatory')
if mibBuilder.loadTexts: a99MibOid.setDescription('The MIB Object Identifier that corresponds to this MIF')
a99DisableTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 99, 1, 3), DmiInteger()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: a99DisableTrap.setStatus('mandatory')
if mibBuilder.loadTexts: a99DisableTrap.setDescription('This attribute can be changed to disable sending of traps from this component')
tEventState = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 100), )
if mibBuilder.loadTexts: tEventState.setStatus('mandatory')
if mibBuilder.loadTexts: tEventState.setDescription('This table holds the current state of each state-based event')
eEventState = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 100, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a100EventIndex"))
if mibBuilder.loadTexts: eEventState.setStatus('mandatory')
if mibBuilder.loadTexts: eEventState.setDescription('')
a100EventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 100, 1, 1), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a100EventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: a100EventIndex.setDescription('A unique index into the Event State table')
a100EventGenerationGroupClass = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 100, 1, 2), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a100EventGenerationGroupClass.setStatus('mandatory')
if mibBuilder.loadTexts: a100EventGenerationGroupClass.setDescription('The Class String of the event generator group within the generatingComponent')
a100EventType = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 100, 1, 3), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a100EventType.setStatus('mandatory')
if mibBuilder.loadTexts: a100EventType.setDescription('Integer value that identifies one of the event types enumeratedi the associated Event Generation group')
a100CurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 100, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 8, 16, 32))).clone(namedValues=NamedValues(("vOk", 4), ("vNon-critical", 8), ("vCritical", 16), ("vNon-recoverable", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a100CurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: a100CurrentState.setDescription('The current state of the Event type identified by the Event Typeattribute in this row')
a100AssociatedGroupObject = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 100, 1, 5), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a100AssociatedGroupObject.setStatus('mandatory')
if mibBuilder.loadTexts: a100AssociatedGroupObject.setDescription('A list of integer keys that identify the instance of theAssociat d Group that actually generated the state-based event.The list of integer keys are represented in the value of thisattribute as a string containing a comma-separated list ofintegers. The management application must parse this string toobtain the list of integer keys.')
tEventGenerationForDiskController = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238), )
if mibBuilder.loadTexts: tEventGenerationForDiskController.setStatus('mandatory')
if mibBuilder.loadTexts: tEventGenerationForDiskController.setDescription('')
eEventGenerationForDiskController = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a238AssociatedGroup"))
if mibBuilder.loadTexts: eEventGenerationForDiskController.setStatus('mandatory')
if mibBuilder.loadTexts: eEventGenerationForDiskController.setDescription('')
a238EventType = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vInitializationFailure", 1), ("vConfigurationError", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a238EventType.setStatus('mandatory')
if mibBuilder.loadTexts: a238EventType.setDescription('The type of event that has occurred.')
a238EventSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("vMonitor", 1), ("vInformation", 2), ("vOk", 4), ("vNon-critical1", 8), ("vCritical", 16), ("vNon-recoverable1", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a238EventSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: a238EventSeverity.setDescription('The severity of this event.')
a238IsEventState_based = MibScalar((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vFalse", 0), ("vTrue", 1)))).setLabel("a238IsEventState-based").setMaxAccess("readonly")
if mibBuilder.loadTexts: a238IsEventState_based.setStatus('mandatory')
if mibBuilder.loadTexts: a238IsEventState_based.setDescription('The value of this attribute determines whether the Event being reported is a state-based Event or not. If the value of this attribute is TRUE then the Event is state-based. Otherwise the Event is not state-based.')
a238EventStateKey = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238, 1, 4), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a238EventStateKey.setStatus('mandatory')
if mibBuilder.loadTexts: a238EventStateKey.setDescription("A unique, single integer key into the EventState group if this is a state-based Event. If this is not a state-based Event then this attribute's value is not defined.")
a238AssociatedGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238, 1, 5), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a238AssociatedGroup.setStatus('mandatory')
if mibBuilder.loadTexts: a238AssociatedGroup.setDescription('The class name of the group that is associated with the events defined in this EventGeneration group.')
a238EventSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vOther", 0), ("vUnknown", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a238EventSystem.setStatus('mandatory')
if mibBuilder.loadTexts: a238EventSystem.setDescription('The major functional aspect of the product causing the fault.')
a238EventSubsystem = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 238, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vOther", 0), ("vUnknown", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a238EventSubsystem.setStatus('mandatory')
if mibBuilder.loadTexts: a238EventSubsystem.setDescription('The minor functional aspect of the product causing the fault.')
tEventGenerationForDisks = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239), )
if mibBuilder.loadTexts: tEventGenerationForDisks.setStatus('mandatory')
if mibBuilder.loadTexts: tEventGenerationForDisks.setDescription('')
eEventGenerationForDisks = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a239AssociatedGroup"))
if mibBuilder.loadTexts: eEventGenerationForDisks.setStatus('mandatory')
if mibBuilder.loadTexts: eEventGenerationForDisks.setDescription('')
a239EventType = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("vPhysicalDeviceStatusChange", 1), ("vInitializationFailure", 2), ("vConfigurationError", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a239EventType.setStatus('mandatory')
if mibBuilder.loadTexts: a239EventType.setDescription('The type of event that has occurred.')
a239EventSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("vMonitor", 1), ("vInformation", 2), ("vOk", 4), ("vNon-critical", 8), ("vCritical", 16), ("vNon-recoverable", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a239EventSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: a239EventSeverity.setDescription('The severity of this event.')
a239IsEventState_based = MibScalar((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vFalse", 0), ("vTrue", 1)))).setLabel("a239IsEventState-based").setMaxAccess("readonly")
if mibBuilder.loadTexts: a239IsEventState_based.setStatus('mandatory')
if mibBuilder.loadTexts: a239IsEventState_based.setDescription('The value of this attribute determines whether the Event being reported is a state-based Event or not. If the value of this attribute is TRUE then the Event is state-based. Otherwise the Event is not state-based.')
a239EventStateKey = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239, 1, 4), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a239EventStateKey.setStatus('mandatory')
if mibBuilder.loadTexts: a239EventStateKey.setDescription("A unique, single integer key into the Event State group if this is a state-based Event. If this is not a state-based Event then this attribute's value is not defined.")
a239AssociatedGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239, 1, 5), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a239AssociatedGroup.setStatus('mandatory')
if mibBuilder.loadTexts: a239AssociatedGroup.setDescription('The class name of the group that is associated with the events defined in this EventGeneration group.')
a239EventSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vOther", 0), ("vUnknown", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a239EventSystem.setStatus('mandatory')
if mibBuilder.loadTexts: a239EventSystem.setDescription('The major functional aspect of the product causing the fault.')
a239EventSubsystem = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 239, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vOther", 0), ("vUnknown", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a239EventSubsystem.setStatus('mandatory')
if mibBuilder.loadTexts: a239EventSubsystem.setDescription('The minor functional aspect of the product causing the fault.')
tEventGenerationForMassStoreLogicalDrive = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244), )
if mibBuilder.loadTexts: tEventGenerationForMassStoreLogicalDrive.setStatus('mandatory')
if mibBuilder.loadTexts: tEventGenerationForMassStoreLogicalDrive.setDescription('')
eEventGenerationForMassStoreLogicalDrive = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"), (0, "FASTTRAKIDERAID-MIB", "a244AssociatedGroup"))
if mibBuilder.loadTexts: eEventGenerationForMassStoreLogicalDrive.setStatus('mandatory')
if mibBuilder.loadTexts: eEventGenerationForMassStoreLogicalDrive.setDescription('')
a244EventType = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("vPhysicalDeviceStatusChange", 1), ("vHotSpareActivated", 2), ("vLogicalDeviceStatusChange", 3), ("vInitializationFailure", 4), ("vConfigurationError", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a244EventType.setStatus('mandatory')
if mibBuilder.loadTexts: a244EventType.setDescription('The type of event that has occurred.')
a244EventSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("vMonitor", 1), ("vInformation", 2), ("vOk", 4), ("vNon-critical", 8), ("vCritical", 16), ("vNon-recoverable", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a244EventSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: a244EventSeverity.setDescription('The severity of this event.')
a244IsEventState_based = MibScalar((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vFalse", 0), ("vTrue", 1)))).setLabel("a244IsEventState-based").setMaxAccess("readonly")
if mibBuilder.loadTexts: a244IsEventState_based.setStatus('mandatory')
if mibBuilder.loadTexts: a244IsEventState_based.setDescription('The value of this attribute determines whether the Event being reported is a state-based Event or not. If the value of this attribute is TRUE then the Event is state-based. Otherwise the Event is not state-based.')
a244EventStateKey = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244, 1, 4), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a244EventStateKey.setStatus('mandatory')
if mibBuilder.loadTexts: a244EventStateKey.setDescription("A unique, single integer key into the Event State group if this is a state-based Event. If this is not a state-based Event then this attribute's value is not defined.")
a244AssociatedGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244, 1, 5), DmiDisplaystring()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a244AssociatedGroup.setStatus('mandatory')
if mibBuilder.loadTexts: a244AssociatedGroup.setDescription('The class name of the group that is associated with the events defined in this EventGeneration group.')
a244EventSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vOther", 0), ("vUnknown", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a244EventSystem.setStatus('mandatory')
if mibBuilder.loadTexts: a244EventSystem.setDescription('The major functional aspect of the product causing the fault.')
a244EventSubsystem = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 244, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("vOther", 0), ("vUnknown", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: a244EventSubsystem.setStatus('mandatory')
if mibBuilder.loadTexts: a244EventSubsystem.setDescription('The minor functional aspect of the product causing the fault.')
tTrapGroup = MibTable((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999), )
if mibBuilder.loadTexts: tTrapGroup.setStatus('mandatory')
if mibBuilder.loadTexts: tTrapGroup.setDescription('This group defines attributes needed for Trap definition. This group does not exist in MIF file')
eTrapGroup = MibTableRow((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1), ).setIndexNames((0, "FASTTRAKIDERAID-MIB", "DmiComponentIndex"))
if mibBuilder.loadTexts: eTrapGroup.setStatus('mandatory')
if mibBuilder.loadTexts: eTrapGroup.setDescription('')
a9999ErrorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999ErrorTime.setStatus('mandatory')
if mibBuilder.loadTexts: a9999ErrorTime.setDescription('The Date & Time when the error occured')
a9999ErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 2), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999ErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: a9999ErrorStatus.setDescription('Error Status Code')
a9999ErrorGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 3), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999ErrorGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: a9999ErrorGroupId.setDescription('Group ID of the errorControl Group')
a9999ErrorInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 4), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999ErrorInstanceId.setStatus('mandatory')
if mibBuilder.loadTexts: a9999ErrorInstanceId.setDescription('Instance ID of the errorControl Group')
a9999ComponentId = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 5), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999ComponentId.setStatus('mandatory')
if mibBuilder.loadTexts: a9999ComponentId.setDescription('Component ID of the component that caused this error')
a9999GroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 6), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999GroupId.setStatus('mandatory')
if mibBuilder.loadTexts: a9999GroupId.setDescription('Group ID of the Group that caused this error')
a9999InstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 7), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999InstanceId.setStatus('mandatory')
if mibBuilder.loadTexts: a9999InstanceId.setDescription('Instance ID of the Group that caused this error')
a9999VendorCode1 = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 8), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999VendorCode1.setStatus('mandatory')
if mibBuilder.loadTexts: a9999VendorCode1.setDescription('Vendor specific code 1')
a9999VendorCode2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 9), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999VendorCode2.setStatus('mandatory')
if mibBuilder.loadTexts: a9999VendorCode2.setDescription('Vendor specific code 2')
a9999VendorText = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999VendorText.setStatus('mandatory')
if mibBuilder.loadTexts: a9999VendorText.setDescription('Vendor specific octet string info')
a9999ParentGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 11), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999ParentGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: a9999ParentGroupId.setDescription('Group ID of parent of Group that caused this error')
a9999ParentInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1, 12), DmiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: a9999ParentInstanceId.setStatus('mandatory')
if mibBuilder.loadTexts: a9999ParentInstanceId.setDescription('Instance ID of parent of Group that caused this error')
dmtfEventError = NotificationType((1, 3, 6, 1, 4, 1, 7933, 343, 1, 1, 1, 9999, 1) + (0,1)).setObjects(("FASTTRAKIDERAID-MIB", "a9999ErrorTime"), ("FASTTRAKIDERAID-MIB", "a9999ErrorStatus"), ("FASTTRAKIDERAID-MIB", "a9999ErrorGroupId"), ("FASTTRAKIDERAID-MIB", "a9999ErrorInstanceId"), ("FASTTRAKIDERAID-MIB", "a9999ComponentId"), ("FASTTRAKIDERAID-MIB", "a9999GroupId"), ("FASTTRAKIDERAID-MIB", "a9999InstanceId"), ("FASTTRAKIDERAID-MIB", "a9999VendorCode1"), ("FASTTRAKIDERAID-MIB", "a9999VendorCode2"), ("FASTTRAKIDERAID-MIB", "a9999VendorText"), ("FASTTRAKIDERAID-MIB", "a9999ParentGroupId"), ("FASTTRAKIDERAID-MIB", "a9999ParentInstanceId"))
if mibBuilder.loadTexts: dmtfEventError.setDescription('DMI Service Layer generated event for FastTrak IDE RAID')
mibBuilder.exportSymbols("FASTTRAKIDERAID-MIB", a244EventType=a244EventType, tEventState=tEventState, a238EventSeverity=a238EventSeverity, a86LogicalDriveSizeInKb=a86LogicalDriveSizeInKb, a86LogicalDriveNameString=a86LogicalDriveNameString, a239IsEventState_based=a239IsEventState_based, eEventGenerationForMassStoreLogicalDrive=eEventGenerationForMassStoreLogicalDrive, eMassStoreArrayInfoTable=eMassStoreArrayInfoTable, eMassStoreSegmentTable=eMassStoreSegmentTable, promise=promise, a239EventSystem=a239EventSystem, a244EventSubsystem=a244EventSubsystem, a9999ErrorTime=a9999ErrorTime, eDiskController=eDiskController, a88DriveKey2=a88DriveKey2, a238EventType=a238EventType, tDiskController=tDiskController, tMassStoreMappingTable=tMassStoreMappingTable, a99DisableTrap=a99DisableTrap, a49StorageInterfaceType=a49StorageInterfaceType, a49SecuritySettings=a49SecuritySettings, a45SystemSlotIndex=a45SystemSlotIndex, intel=intel, tMassStoreLogicalDrivesTable=tMassStoreLogicalDrivesTable, a239EventSeverity=a239EventSeverity, a49RemovableMedia=a49RemovableMedia, a87ParentDrive=a87ParentDrive, a238IsEventState_based=a238IsEventState_based, a45ControllerMaximumDevices=a45ControllerMaximumDevices, a49PhysicalLocation=a49PhysicalLocation, a45ControllerSoftwareRevisionLevel=a45ControllerSoftwareRevisionLevel, fasttrak=fasttrak, a45DiskControllerIdentification=a45DiskControllerIdentification, eEventState=eEventState, a1SerialNumber=a1SerialNumber, a244EventSystem=a244EventSystem, a100AssociatedGroupObject=a100AssociatedGroupObject, tDisks=tDisks, tEventGenerationForMassStoreLogicalDrive=tEventGenerationForMassStoreLogicalDrive, DmiDateX=DmiDateX, a45OperationalGroupIndex=a45OperationalGroupIndex, a85DriveArrayRedundancyStatus=a85DriveArrayRedundancyStatus, tEventGenerationForDisks=tEventGenerationForDisks, a238EventStateKey=a238EventStateKey, a1Product=a1Product, eEventGenerationForDisks=eEventGenerationForDisks, tMassStoreSegmentTable=tMassStoreSegmentTable, a49SectorSize=a49SectorSize, a9999ParentInstanceId=a9999ParentInstanceId, a9999ErrorStatus=a9999ErrorStatus, a9999ParentGroupId=a9999ParentGroupId, eEventGenerationForDiskController=eEventGenerationForDiskController, a49DiskIndex=a49DiskIndex, a85DriveArrayOperationInProgress=a85DriveArrayOperationInProgress, a9999VendorText=a9999VendorText, a1Version=a1Version, a100EventGenerationGroupClass=a100EventGenerationGroupClass, dmtfGroups=dmtfGroups, eTrapGroup=eTrapGroup, a239EventStateKey=a239EventStateKey, a1Verify=a1Verify, eDisks=eDisks, tEventGenerationForDiskController=tEventGenerationForDiskController, a87ChildSegment=a87ChildSegment, a86TopOfHierarchy=a86TopOfHierarchy, a1Manufacturer=a1Manufacturer, a99MibName=a99MibName, a88SegmentAllocationState=a88SegmentAllocationState, tMiftomib=tMiftomib, a49OperationalGroupIndex=a49OperationalGroupIndex, a100EventType=a100EventType, a49NumberOfPhysicalCylinders=a49NumberOfPhysicalCylinders, tTrapGroup=tTrapGroup, a85LogicalDriveIndex=a85LogicalDriveIndex, a244EventStateKey=a244EventStateKey, a99MibOid=a99MibOid, a49StorageType=a49StorageType, tComponentid=tComponentid, a86LogicalDriveIndex=a86LogicalDriveIndex, a9999GroupId=a9999GroupId, eMassStoreMappingTable=eMassStoreMappingTable, a88SegmentType=a88SegmentType, a88SegmentStart=a88SegmentStart, a49MediaLoaded=a49MediaLoaded, a244AssociatedGroup=a244AssociatedGroup, a49PhysicalCylinderForWritePrecompensati=a49PhysicalCylinderForWritePrecompensati, a49FruGroupIndex=a49FruGroupIndex, a88SegmentIndex=a88SegmentIndex, a100CurrentState=a100CurrentState, a49NumberOfPhysicalHeads=a49NumberOfPhysicalHeads, a88SegmentLength=a88SegmentLength, DmiInteger=DmiInteger, a9999VendorCode1=a9999VendorCode1, a45FruGroupIndex=a45FruGroupIndex, a86DriveArray=a86DriveArray, a49DeviceId=a49DeviceId, a238EventSubsystem=a238EventSubsystem, a9999ComponentId=a9999ComponentId, a9999VendorCode2=a9999VendorCode2, a9999InstanceId=a9999InstanceId, a244IsEventState_based=a244IsEventState_based, a49NumberOfCurrentBadBlocksOrSectors=a49NumberOfCurrentBadBlocksOrSectors, a100EventIndex=a100EventIndex, a238AssociatedGroup=a238AssociatedGroup, a49TotalPhysicalSize=a49TotalPhysicalSize, a85DriveArrayLevel=a85DriveArrayLevel, eMassStoreLogicalDrivesTable=eMassStoreLogicalDrivesTable, a239EventType=a239EventType, a45ControllerChannelCount=a45ControllerChannelCount, a88DriveKey1=a88DriveKey1, a49Partitions=a49Partitions, a9999ErrorGroupId=a9999ErrorGroupId, a244EventSeverity=a244EventSeverity, a49RemovableDrive=a49RemovableDrive, a86LogicalDriveBlockSizeInBytes=a86LogicalDriveBlockSizeInBytes, eComponentid=eComponentid, DmiComponentIndex=DmiComponentIndex, isc3xtraps=isc3xtraps, a49PhysicalCylinderForLandingZone=a49PhysicalCylinderForLandingZone, a9999ErrorInstanceId=a9999ErrorInstanceId, a88SegmentAllocationUnit=a88SegmentAllocationUnit, a239EventSubsystem=a239EventSubsystem, eMiftomib=eMiftomib, a87MappingIndex=a87MappingIndex, a239AssociatedGroup=a239AssociatedGroup, a49NumberOfPhysicalSectorsPerTrack=a49NumberOfPhysicalSectorsPerTrack, a49InterfaceDescription=a49InterfaceDescription, a238EventSystem=a238EventSystem, DmiDisplaystring=DmiDisplaystring, a45DiskControllerIndex=a45DiskControllerIndex, tMassStoreArrayInfoTable=tMassStoreArrayInfoTable, a49LogicalUnitNumber=a49LogicalUnitNumber, a1Installation=a1Installation, dmtfEventError=dmtfEventError)

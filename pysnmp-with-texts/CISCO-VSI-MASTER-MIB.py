#
# PySNMP MIB module CISCO-VSI-MASTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-VSI-MASTER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:19:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
NotificationType, Integer32, Unsigned32, iso, Counter32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, ModuleIdentity, Gauge32, MibIdentifier, TimeTicks, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Integer32", "Unsigned32", "iso", "Counter32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "ModuleIdentity", "Gauge32", "MibIdentifier", "TimeTicks", "ObjectIdentity")
DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention")
ciscoVsiMasterMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 162))
if mibBuilder.loadTexts: ciscoVsiMasterMIB.setLastUpdated('200006010000Z')
if mibBuilder.loadTexts: ciscoVsiMasterMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoVsiMasterMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-tagswitching@cisco.com')
if mibBuilder.loadTexts: ciscoVsiMasterMIB.setDescription('This MIB module contains objects related to the master side of the the Virtual Switch Interface protocol used for control of ATM switches.')
class VsiControllerIndex(TextualConvention, Integer32):
    description = 'This textual convention defines the controller index for each Virtual Switch Interface (VSI) controller in the domain of the VSI Master. The value is an internally generated unique number with local significance only. It must remain constant after the VSI Master sub-system is initialized.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class VsiSessionIndex(TextualConvention, Integer32):
    description = 'This textual convention defines a unique value, greater than zero, for each VSI session in the managed system. The value should remain constant after a VSI session is reinitialized.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class VsiLogicalIfIndex(TextualConvention, Integer32):
    description = 'This textual convention defines a unique value, greater than zero, for each VSI logical interface controlled by the managed system. A logical interface index is an abstract number that is generated and provided by a Slave, and represents a virtual interface. It is used by the Master, when communicating with the Slave, to gain access to interface data, including ifIndex. This is not a selector index for ifType, ifName, ifOperState, and ifAdminState, etc.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class VsiXCIndex(TextualConvention, Integer32):
    description = 'This textual convention defines a unique value, greater than zero, for each cross connect on a managed system controlled by VSI. The value should remain constant after a crossconnect is initialized, for the duration of the life of the cross connect.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

ciscoVsiMasterObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 162, 1))
ciscoVsiMasterNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 162, 2))
ciscoVsiMasterConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 162, 3))
vsiMasterControllerTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1), )
if mibBuilder.loadTexts: vsiMasterControllerTable.setStatus('current')
if mibBuilder.loadTexts: vsiMasterControllerTable.setDescription('A table containing a set of VSI controllers. Each controller represents an instance of the VSI Master control protocol. A controller communicates with a set of VSI Slaves across a control interface. Running the VSI protocol, the controller supports a network control application. Through VSI, such an application can control the Virtual Circuit cross-connect table inside the ATM switch, perform monitoring and statistics collection of interfaces and virtual circuits on the switch, and discover configuration information from within the switch.')
vsiMasterControllerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1), ).setIndexNames((0, "CISCO-VSI-MASTER-MIB", "vsiControllerIndex"))
if mibBuilder.loadTexts: vsiMasterControllerEntry.setStatus('current')
if mibBuilder.loadTexts: vsiMasterControllerEntry.setDescription("An entry containing management information applicable to a controller which uses the VSI protocol. Controller entries represent internally generated control structures. Therefore each row is created by the agent in response to the learning of a controller's instantiation. Instantiation of a controller is performed by the VSI Master protocol implementation under management via this MIB. These structures, once instantiated, are never deleted. Each controller manages a set of VSI slaves, via a protocol instance called a Session.")
vsiControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 1), VsiControllerIndex())
if mibBuilder.loadTexts: vsiControllerIndex.setStatus('current')
if mibBuilder.loadTexts: vsiControllerIndex.setDescription('A unique value per VSI controller, greater than 0. This object gets its value from the vsiControllerId, and is used for row selection within the vsiMasterControllerTable.')
vsiControllerId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiControllerId.setStatus('current')
if mibBuilder.loadTexts: vsiControllerId.setDescription('The controller identifier for the VSI controller. Values are arbitrarily assigned by the VSI protocol implementation being managed via this MIB, with local significance only. These values appear in the header of all VSI protocol messages.')
vsiCrossConnects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiCrossConnects.setStatus('current')
if mibBuilder.loadTexts: vsiCrossConnects.setDescription('This object contains a value equal to the number of cross-connects being controlled via VSI protocol via this controller.')
vsiControllerType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("mpls", 2), ("pnni", 3), ("par", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiControllerType.setStatus('current')
if mibBuilder.loadTexts: vsiControllerType.setDescription('A VSI controller represents an instance of a service layer accessible to a network control application. This object serves to identify the type of the network control application currently being supported by this controller. other(1): the type is unspecified. mpls(2): indicates that the client is a Label Switch Controller performing Multi Protocol Label Switching. pnni(3): indicates that the client is an instance of the ATM Private Network to Network Interface. par(4): indicates that the client is an instance of ATM Portable Autoroute.')
vsiBaseVersionSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiBaseVersionSupported.setStatus('current')
if mibBuilder.loadTexts: vsiBaseVersionSupported.setDescription('A VSI Master protocol instance defines internally a set of versions of the protocol that it will support. These versions are numbered, by default, starting from 1. This object makes available the lowest numbered version that the VSI Master protocol supports. This object is related to the other vsiMasterControllerEntry objects, vsiTopVersionSupported and vsiVersionInUse.')
vsiTopVersionSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiTopVersionSupported.setStatus('current')
if mibBuilder.loadTexts: vsiTopVersionSupported.setDescription('A VSI Master protocol instance defines internally a set of versions of the protocol that it will support. These versions are numbered, by default, starting from 1. This object makes available the highest numbered version that the VSI Master protocol supports. This object is related to the other vsiMasterControllerEntry objects, vsiBaseVersionSupported and vsiVersionInUse.')
vsiVersionInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiVersionInUse.setStatus('current')
if mibBuilder.loadTexts: vsiVersionInUse.setDescription('The number of the VSI version currently being used by this controller. Protocol selection procedures dictate that this should be the highest value of protocol version, between vsiBaseVersionSupported and vsiTopVersionSupported, that is supported by all slaves. An exception to this rule will occur when the version is constrained to a specific value indicated by the vsiSpecifiedVersion object.')
vsiSpecifiedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vsiSpecifiedVersion.setStatus('current')
if mibBuilder.loadTexts: vsiSpecifiedVersion.setDescription('When this object is written with a non-zero value, re-synchronization procedures will be initiated, if necessary, in order to constrain the master and slaves to use the indicated protocol version. When written with zero (0), the master and slaves should use the version dictated by the usual protocol version selection procedures; resynchronization procedures will be invoked, if necessary, to achieve this result.')
vsiControlInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 9), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiControlInterface.setStatus('current')
if mibBuilder.loadTexts: vsiControlInterface.setDescription('A VSI controller communicates with a set of VSI Slaves across a control interface. The controller is connected to the ATM switch via an ATM link called the Slave Control Link. The interface at the Master end of the link is the Master Control Port, and is described by this object; it is the ifIndex of this Master Control Port.')
vsiLogicalControlInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 1, 1, 10), VsiLogicalIfIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalControlInterface.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalControlInterface.setDescription('This object describes the instance of a logical interface index bound to the slave end of the Slave Control Link, which is referred to in the description of vsiControlInterface.')
vsiSessionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2), )
if mibBuilder.loadTexts: vsiSessionTable.setStatus('current')
if mibBuilder.loadTexts: vsiSessionTable.setDescription('A table containing VSI master-slave session status information. Each VSI controller manages a set of VSI slaves, via a protocol instance called a Session. VSI slaves are entities that reside on the controlled ATM switch. Their number and characteristics are discovered by the VSI controller via the VSI protocol. This table has an entry for each slave so discovered.')
vsiSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1), ).setIndexNames((0, "CISCO-VSI-MASTER-MIB", "vsiSessionControllerIndex"), (0, "CISCO-VSI-MASTER-MIB", "vsiSessionIndex"))
if mibBuilder.loadTexts: vsiSessionEntry.setStatus('current')
if mibBuilder.loadTexts: vsiSessionEntry.setDescription('A vsiSessionEntry is a set of objects that together represent the status of each instance of VSI protocol and the slave in an ATM switch to which that instance corresponds. There is one vsiSession for each slave. The number of slaves is discovered via the VSI protocol. Each slave is responsible for a subset of the total number of external interfaces on the ATM switch. Session entries refer back to their respective controllers via vsiSessionControllerIndex, and are in turn referred to by vsiLogicalIfSessionIndex in the VsiLogicalIfEntry. These entries are never deleted.')
vsiSessionControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 1), VsiControllerIndex())
if mibBuilder.loadTexts: vsiSessionControllerIndex.setStatus('current')
if mibBuilder.loadTexts: vsiSessionControllerIndex.setDescription('The ID of the controller which controls this master-slave session. This identifies which vsiMasterControllerEntry represents the controller communicating with a slave through this Session.')
vsiSessionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 2), VsiSessionIndex())
if mibBuilder.loadTexts: vsiSessionIndex.setStatus('current')
if mibBuilder.loadTexts: vsiSessionIndex.setDescription('A VSI controller discovers a set of slaves through VSI protocol. Each of the discovered slaves is bound to a protocol Session and each of these Sessions occupies a row in the vsiSessionTable. This object is the row selector. The value should remain constant after a VSI session is reinitialized.')
vsiSessionVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionVpi.setStatus('current')
if mibBuilder.loadTexts: vsiSessionVpi.setDescription('The virtual path identifier for this VSI master-slave session. The Slave Control Link, referred to in the description of vsiLogicalControlInterface, supports an ATM control VC. This is the vpi for that link.')
vsiSessionVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionVci.setStatus('current')
if mibBuilder.loadTexts: vsiSessionVci.setDescription('The virtual channel identifier for this VSI master-slave session. The Slave Control Link, referred to in the description of vsiLogicalControlInterface, supports an ATM control VC. This is the vci for that link.')
vsiSessionSwitchId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionSwitchId.setStatus('current')
if mibBuilder.loadTexts: vsiSessionSwitchId.setDescription('The identifier of the switch which participates in this VSI master-slave session. The switch terminates the virtual circuit identified by the vpi/vci pair referred to by vsiSessionVpi and vsiSessionVci.')
vsiSessionSwitchName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionSwitchName.setStatus('current')
if mibBuilder.loadTexts: vsiSessionSwitchName.setDescription('The IP hostname for the slave switch which is controlled by this session. This is an ascii string of maximum length 64 characters, learned from the ATM switch.')
vsiSessionSlaveId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionSlaveId.setStatus('current')
if mibBuilder.loadTexts: vsiSessionSlaveId.setDescription('The identifier of the slave for this VSI master-slave session. This value is learned from the slave on the switch.')
vsiSessionState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("inactive", 1), ("unknown", 2), ("configuring", 3), ("resyncStarting", 4), ("resyncUnderway", 5), ("resyncEnding", 6), ("discovery", 7), ("established", 8), ("shutdownStarting", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionState.setStatus('current')
if mibBuilder.loadTexts: vsiSessionState.setDescription('The state of the VSI session. inactive(1): communications data structures for communicating with the slave have been created, but the VSI protocol has not been started. unknown(2): slave has been queried, but its configuration data has not yet been recieved. configuring(3): configuration data has been sent to the slave, but a response has not yet been received. resyncStarting(4): a re-sync command has been sent to the slave, but a response has not yet been recieved. resyncUnderway(5): a re-sync command response has been received from the slave, but the network applications have not yet completed reasserting connections. resyncEnding(6): a command has been sent to end re-sync, but a response has not yet been received. discovery(7): a query has been sent to the slave for interface information, but a response has not yet been received. established(8): discovery has completed. shutdownStarting(9): the master has started an orderly shutdown of the slave.')
vsiSessionWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionWindowSize.setStatus('current')
if mibBuilder.loadTexts: vsiSessionWindowSize.setDescription('The maximum number of command messages the VSI master will send before requiring a response from slave. If the value is 0, then flow control is not enabled.')
vsiSessionCmdsPending = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionCmdsPending.setStatus('current')
if mibBuilder.loadTexts: vsiSessionCmdsPending.setDescription('The number of unacknowledged command messages. The VSI master sends commands to the slave, without receiving acknowledgement, until the window size threshold has been reached. This object is a count of the number of commands that have been sent and that are awaiting acknowledgment.')
vsiSessionActiveId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionActiveId.setStatus('current')
if mibBuilder.loadTexts: vsiSessionActiveId.setDescription('ID supplied by the slave to identify the session. This value is interpreted by the master, when a change occurs, to indicate that a resync should be inititated.')
vsiSessionPowerupId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiSessionPowerupId.setStatus('current')
if mibBuilder.loadTexts: vsiSessionPowerupId.setDescription('ID supplied by the slave to identify the session at powerup. This is the initial value for vsiSessionActiveId, and its default is zero. Changes in vsiSessionActiveId signal a resync.')
vsiLogicalIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3), )
if mibBuilder.loadTexts: vsiLogicalIfTable.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfTable.setDescription('A table containing information about logical interfaces on the slave switch controlled via VSI. Logical interfaces are an abstraction of exposed, external ATM interfaces that are available for connections. When two external interfaces, represented by two logical interfaces, are paired, they provide physical paths through the switch. These physical pathways support cross-connects.')
vsiLogicalIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1), ).setIndexNames((0, "CISCO-VSI-MASTER-MIB", "vsiLogicalIfControllerIndex"), (0, "CISCO-VSI-MASTER-MIB", "vsiLogicalIfIndex"))
if mibBuilder.loadTexts: vsiLogicalIfEntry.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfEntry.setDescription('An entry containing information about a single VSI logical interface. Entries are instantiated and removed as signalled by the slave which controls the external interface. Each entry contains information about the capacity of cross-connects the interface can bear, cell rate, merge capability, vpi/vci ranges, and statistics. Pairs of logical interfaces support potential cross-connects that, when actualized, are represented by the vsiXCEntrys in the vsiXCTable. Logical interfaces are controlled by a designated slave, as determined by the switch. The slave is in the domain of the controller whose identity is given by vsiLogicalIfControllerIndex. This object is an opaque identifier, provided by the slave, and used as a key to identify the entry.')
vsiLogicalIfControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 1), VsiControllerIndex())
if mibBuilder.loadTexts: vsiLogicalIfControllerIndex.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfControllerIndex.setDescription('The VSI controller index of the controller through which this logical interface was learned.')
vsiLogicalIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 2), VsiLogicalIfIndex())
if mibBuilder.loadTexts: vsiLogicalIfIndex.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfIndex.setDescription('A unique value, greater than zero, for each VSI logical interface. Logical interface numbers are selected by the switch to be unique and persistent. The same number is preserved through power failures. This index is not the same as an ifIndex. It is an abstract number provided by the slave, representing a virtual interface, which is an identifier to be used when communicating with the slave about an interface.')
vsiLogicalIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfName.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfName.setDescription('The physical descriptor of the logical interface, as reported by the VSI slave. It is distinct from ifName.')
vsiLogicalIfOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("removed", 1), ("active", 2), ("failedExternal", 3), ("failedInternal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfOperState.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfOperState.setDescription('The VSI operational state of the logical interface as reported to the VSI master by the VSI slave. removed(1): the interface is not a valid interface for this controller. active(2): the interface is active and ready for use. failedExternal(3): external failure, such as a line alarm, detected. failedInternal(4): local hardware has detected a failure, making the interface unusable.')
vsiLogicalIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("down", 1), ("up", 2), ("pendingDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfAdminState.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfAdminState.setDescription('The current administrative (configured) state of the interface, as reported to the VSI master by the VSI slave. down(1): the interface is not a valid interface for the controller. up(2): the interface is configured for use by the controller. pendingDown(3): the interface is being removed from service, and the controller is requested to remove all connections.')
vsiLogicalIfRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfRxCells.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfRxCells.setDescription('The number of cells received via this logical interface as reported to the VSI master by the VSI slave.')
vsiLogicalIfTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfTxCells.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfTxCells.setDescription('The number of cells transmitted via this logical interface as reported to the VSI master by the VSI slave.')
vsiLogicalIfRxCellsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfRxCellsDiscarded.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfRxCellsDiscarded.setDescription('The number of received cells discarded by this logical interface as reported to the VSI master by the VSI slave.')
vsiLogicalIfTxCellsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfTxCellsDiscarded.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfTxCellsDiscarded.setDescription('The number of transmitted cells discarded by this logical interface as reported to the VSI master by the VSI slave.')
vsiLogicalIfRxHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfRxHeaderErrors.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfRxHeaderErrors.setDescription('The number of cells received via this logical interface which had header errors, as reported to the VSI master by the VSI slave.')
vsiLogicalIfRxInvalidAddrs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfRxInvalidAddrs.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfRxInvalidAddrs.setDescription('The number of cells received by this logical interface which had invalid addresses, as reported to the VSI master by the VSI slave. An unknown vpi/vci value set is an example of of an invalid address.')
vsiLogicalIfEndPointsInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfEndPointsInUse.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfEndPointsInUse.setDescription('The number of end points in use on this logical interface, as reported to the VSI master by the VSI slave. If this logical interface has not been removed, but does not currently support any cross connects, this object will be reported as zero (0).')
vsiLogicalIfAvailIngressChnls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfAvailIngressChnls.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfAvailIngressChnls.setDescription('The number of ingress channels available for this logical interface, as reported to the VSI master by the VSI slave.')
vsiLogicalIfAvailEgressChnls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfAvailEgressChnls.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfAvailEgressChnls.setDescription('The number of egress channels available for this logical interface, as reported to the VSI master by the VSI slave.')
vsiLogicalIfAvailIngressCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfAvailIngressCellRate.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfAvailIngressCellRate.setDescription('The available ingress cell rate in cells/second for the logical interface, as reported to the VSI master by the VSI slave.')
vsiLogicalIfAvailEgressCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfAvailEgressCellRate.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfAvailEgressCellRate.setDescription('The available egress cell rate in cells/second for the logical interface, as reported to the VSI master by the VSI slave.')
vsiLogicalIfVcMergeSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfVcMergeSupported.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfVcMergeSupported.setDescription('If this object has the value true(1) then VC merge capability is supported for this logical interface. Otherwise VC merge capability is not supported on this logical interface.')
vsiLogicalIfMulticastSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfMulticastSupported.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfMulticastSupported.setDescription('If this object has the value true(1) then multicast capability is supported for this logical interface. Otherwise multicast capability is not supported on this logical interface.')
vsiLogicalIfVpiTranslated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfVpiTranslated.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfVpiTranslated.setDescription('If this object has the value true(1) then vpi values entering on this logical interface are translated at the other end of the link. This translation may be an indication that the link is supporting a tunnel. Otherwise, vpi values are not translated for traversal of the link.')
vsiLogicalIfStrictSigRange = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfStrictSigRange.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfStrictSigRange.setDescription('If this object has the value true(1) then signalling addresses must be in the strict advertised range for the high-address (vpi). Otherwise, signalling addresses are not so constrained.')
vsiLogicalIfMaxIngressCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfMaxIngressCellRate.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfMaxIngressCellRate.setDescription('The maximum ingress cell rate in cells/second for the logical interface, as reported to the VSI. This value is the limiting value for vsiLogicalIfAvailIngressCellRate.')
vsiLogicalIfMaxEgressCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfMaxEgressCellRate.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfMaxEgressCellRate.setDescription('The maximum egress cell rate in cells/second for the logical interface, as reported to the VSI master by the VSI slave.')
vsiLogicalIfMinVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfMinVpi.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfMinVpi.setDescription('Minimum allowed vpi value for this interface as reported by VSI slave switch.')
vsiLogicalIfMaxVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfMaxVpi.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfMaxVpi.setDescription('Maximum allowed vpi value for this interface as reported by VSI slave switch.')
vsiLogicalIfMinVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfMinVci.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfMinVci.setDescription('Minimum allowed vci value for this interface as reported by VSI slave switch.')
vsiLogicalIfMaxVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfMaxVci.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfMaxVci.setDescription('Maximum allowed vci value for this interface as reported by VSI slave switch.')
vsiLogicalControlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 27), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalControlIfIndex.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalControlIfIndex.setDescription('The interface index for the interface which controls this logical interface. This is the ifIndex of the controlling xtagatm interface, and is a direct manifestation of the mapping between a logical interface and the real ifIndex.')
vsiLogicalIfSessionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 3, 1, 28), VsiSessionIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiLogicalIfSessionIndex.setStatus('current')
if mibBuilder.loadTexts: vsiLogicalIfSessionIndex.setDescription('All logical interfaces are in the domain of a VSI slave, which communicates with the VSI master through a Session. This object is a selector for an entry in the table vsiSessionTable. It is the VSI session index for the VSI session which controls this logical interface.')
vsiXCTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4), )
if mibBuilder.loadTexts: vsiXCTable.setStatus('current')
if mibBuilder.loadTexts: vsiXCTable.setDescription('A table containing information about crossconnects on the slave switch controlled via VSI. Cross connects represent virtual links across two interfaces. The participating interfaces that support these links are represented in this MIB by the vsiLogicalIfTable entries.')
vsiXCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1), ).setIndexNames((0, "CISCO-VSI-MASTER-MIB", "vsiXCControllerIndex"), (0, "CISCO-VSI-MASTER-MIB", "vsiXCLogicalIfLow"), (0, "CISCO-VSI-MASTER-MIB", "vsiXCLogicalIfHi"), (0, "CISCO-VSI-MASTER-MIB", "vsiXCIndex"))
if mibBuilder.loadTexts: vsiXCEntry.setStatus('current')
if mibBuilder.loadTexts: vsiXCEntry.setDescription('An entry containing information about one unidirectional or bidirectional crossconnect on the slave switch controlled via VSI. A VSI controller represents an instance of a service layer accessible to a network control application. The application creates virtual links via service requests to the controller, which in turn sends commands to the VSI slave, indicating the participating logical interfaces. Conversely, links are taken down by a reverse process. Virtual link creation and deletion come about as a result of routing decisions.')
vsiXCControllerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 1), VsiControllerIndex())
if mibBuilder.loadTexts: vsiXCControllerIndex.setStatus('current')
if mibBuilder.loadTexts: vsiXCControllerIndex.setDescription('The index of the VSI controller through which this crossconnect was instantiated. This object is the index for a vsiControllerTable entry; the controller indexed is the VSI protocol partner to the slave that is controlling the logical interfaces on which this cross connect is supported.')
vsiXCLogicalIfLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 2), VsiLogicalIfIndex())
if mibBuilder.loadTexts: vsiXCLogicalIfLow.setStatus('current')
if mibBuilder.loadTexts: vsiXCLogicalIfLow.setDescription("The VSI logical interface index for the first endpoint of the cross-connect. This object is the selector index for one of the two vsiLogicalIfTable entries that support this cross connect. Further, this index value is constrained to be 'numerically lower than' the index value of the other vsiLogicalIfTable entry, indexed by vsiXCLogicalIfHi, supporting this cross connect.")
vsiXCLogicalIfHi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 3), VsiLogicalIfIndex())
if mibBuilder.loadTexts: vsiXCLogicalIfHi.setStatus('current')
if mibBuilder.loadTexts: vsiXCLogicalIfHi.setDescription("The VSI logical interface index for the second endpoint of the cross-connect. This object is the selector index for one of the two vsiLogicalIfTable entries that support this cross connect. Further, this index value is constrained to be 'numerically higher than' the index value of the other vsiLogicalIfTable entry, indexed by vsiXCLogicalIfLow, supporting this cross connect.")
vsiXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 4), VsiXCIndex())
if mibBuilder.loadTexts: vsiXCIndex.setStatus('current')
if mibBuilder.loadTexts: vsiXCIndex.setDescription('A unique value greater than zero, for each crossconnect within the set of VsiXCTable entries indexed by vsiXCLogicalIfLow and vsiXCLogicalIfHi. The value should remain constant after a crossconnect is initialized. These values are assigned in sequence by the management agent, starting from one (1).')
vsiXCState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("deleted", 1), ("reserved", 2), ("committed", 3), ("reservedFail", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiXCState.setStatus('current')
if mibBuilder.loadTexts: vsiXCState.setDescription('The operational state of the cross connect, as reported to the VSI master by the VSI slave. deleted(1): the connection does not exist. reserved(2): connection is in the reserved state. committed(3): connection is in the committed state. reservedFail(4): connection is reserved but has an internal failure.')
vsiXCVpiLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiXCVpiLow.setStatus('current')
if mibBuilder.loadTexts: vsiXCVpiLow.setDescription('The vpi of that endpoint of the cross-connect which terminates on the logical interface whose index is given by vsiXCLogicalIfLow.')
vsiXCVciLow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiXCVciLow.setStatus('current')
if mibBuilder.loadTexts: vsiXCVciLow.setDescription('The vci of that endpoint of the cross-connect which terminates on the logical interface whose index is given by vsiXCLogicalIfLow.')
vsiXCVpiHi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiXCVpiHi.setStatus('current')
if mibBuilder.loadTexts: vsiXCVpiHi.setDescription('The vpi of that endpoint of the cross-connect which terminates on the logical interface whose index is given by vsiXCLogicalIfHi.')
vsiXCVciHi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 162, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vsiXCVciHi.setStatus('current')
if mibBuilder.loadTexts: vsiXCVciHi.setDescription('The vci of that endpoint of the cross-connect which terminates on the logical interface whose index is given by vsiXCLogicalIfHi.')
ciscoVsiMasterGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 162, 3, 1))
ciscoVsiMasterCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 162, 3, 2))
ciscoVsiMasterModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 162, 3, 2, 1)).setObjects(("CISCO-VSI-MASTER-MIB", "ciscoVsiMasterGeneralGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVsiMasterModuleCompliance = ciscoVsiMasterModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoVsiMasterModuleCompliance.setDescription('The basic implentation requirements for agents that support this VSI Master MIB.')
ciscoVsiMasterGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 162, 3, 1, 1)).setObjects(("CISCO-VSI-MASTER-MIB", "vsiControllerId"), ("CISCO-VSI-MASTER-MIB", "vsiCrossConnects"), ("CISCO-VSI-MASTER-MIB", "vsiControllerType"), ("CISCO-VSI-MASTER-MIB", "vsiBaseVersionSupported"), ("CISCO-VSI-MASTER-MIB", "vsiTopVersionSupported"), ("CISCO-VSI-MASTER-MIB", "vsiVersionInUse"), ("CISCO-VSI-MASTER-MIB", "vsiSpecifiedVersion"), ("CISCO-VSI-MASTER-MIB", "vsiControlInterface"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalControlInterface"), ("CISCO-VSI-MASTER-MIB", "vsiSessionVpi"), ("CISCO-VSI-MASTER-MIB", "vsiSessionVci"), ("CISCO-VSI-MASTER-MIB", "vsiSessionSwitchId"), ("CISCO-VSI-MASTER-MIB", "vsiSessionSwitchName"), ("CISCO-VSI-MASTER-MIB", "vsiSessionSlaveId"), ("CISCO-VSI-MASTER-MIB", "vsiSessionState"), ("CISCO-VSI-MASTER-MIB", "vsiSessionWindowSize"), ("CISCO-VSI-MASTER-MIB", "vsiSessionCmdsPending"), ("CISCO-VSI-MASTER-MIB", "vsiSessionActiveId"), ("CISCO-VSI-MASTER-MIB", "vsiSessionPowerupId"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfName"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfOperState"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfAdminState"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfRxCells"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfTxCells"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfRxCellsDiscarded"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfTxCellsDiscarded"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfRxHeaderErrors"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfRxInvalidAddrs"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfEndPointsInUse"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfAvailIngressChnls"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfAvailEgressChnls"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfAvailIngressCellRate"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfAvailEgressCellRate"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfMaxIngressCellRate"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfMaxEgressCellRate"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfVcMergeSupported"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfMulticastSupported"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfVpiTranslated"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfStrictSigRange"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfMinVpi"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfMaxVpi"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfMinVci"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfMaxVci"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalControlIfIndex"), ("CISCO-VSI-MASTER-MIB", "vsiLogicalIfSessionIndex"), ("CISCO-VSI-MASTER-MIB", "vsiXCState"), ("CISCO-VSI-MASTER-MIB", "vsiXCVpiLow"), ("CISCO-VSI-MASTER-MIB", "vsiXCVciLow"), ("CISCO-VSI-MASTER-MIB", "vsiXCVpiHi"), ("CISCO-VSI-MASTER-MIB", "vsiXCVciHi"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVsiMasterGeneralGroup = ciscoVsiMasterGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVsiMasterGeneralGroup.setDescription('Objects that apply to all VSI Master implementations.')
mibBuilder.exportSymbols("CISCO-VSI-MASTER-MIB", vsiLogicalIfMaxVci=vsiLogicalIfMaxVci, vsiXCTable=vsiXCTable, vsiSpecifiedVersion=vsiSpecifiedVersion, vsiSessionPowerupId=vsiSessionPowerupId, vsiLogicalIfSessionIndex=vsiLogicalIfSessionIndex, vsiSessionCmdsPending=vsiSessionCmdsPending, vsiLogicalIfEndPointsInUse=vsiLogicalIfEndPointsInUse, vsiXCLogicalIfLow=vsiXCLogicalIfLow, vsiTopVersionSupported=vsiTopVersionSupported, vsiLogicalIfAvailEgressCellRate=vsiLogicalIfAvailEgressCellRate, vsiLogicalControlInterface=vsiLogicalControlInterface, vsiSessionControllerIndex=vsiSessionControllerIndex, vsiLogicalIfMaxEgressCellRate=vsiLogicalIfMaxEgressCellRate, vsiXCVpiHi=vsiXCVpiHi, vsiVersionInUse=vsiVersionInUse, vsiLogicalIfTxCellsDiscarded=vsiLogicalIfTxCellsDiscarded, ciscoVsiMasterGroups=ciscoVsiMasterGroups, vsiSessionTable=vsiSessionTable, ciscoVsiMasterGeneralGroup=ciscoVsiMasterGeneralGroup, ciscoVsiMasterMIB=ciscoVsiMasterMIB, vsiLogicalIfMinVci=vsiLogicalIfMinVci, vsiLogicalIfRxHeaderErrors=vsiLogicalIfRxHeaderErrors, vsiLogicalIfStrictSigRange=vsiLogicalIfStrictSigRange, vsiXCIndex=vsiXCIndex, vsiControllerType=vsiControllerType, vsiLogicalIfVpiTranslated=vsiLogicalIfVpiTranslated, vsiLogicalIfMaxVpi=vsiLogicalIfMaxVpi, vsiMasterControllerEntry=vsiMasterControllerEntry, ciscoVsiMasterNotifications=ciscoVsiMasterNotifications, vsiSessionWindowSize=vsiSessionWindowSize, vsiXCState=vsiXCState, vsiBaseVersionSupported=vsiBaseVersionSupported, vsiSessionState=vsiSessionState, vsiControllerIndex=vsiControllerIndex, ciscoVsiMasterConformance=ciscoVsiMasterConformance, vsiSessionSwitchId=vsiSessionSwitchId, vsiLogicalIfAvailEgressChnls=vsiLogicalIfAvailEgressChnls, vsiLogicalIfOperState=vsiLogicalIfOperState, vsiCrossConnects=vsiCrossConnects, vsiXCVciHi=vsiXCVciHi, vsiXCControllerIndex=vsiXCControllerIndex, vsiLogicalIfControllerIndex=vsiLogicalIfControllerIndex, ciscoVsiMasterObjects=ciscoVsiMasterObjects, vsiLogicalIfRxCells=vsiLogicalIfRxCells, vsiLogicalIfMulticastSupported=vsiLogicalIfMulticastSupported, vsiMasterControllerTable=vsiMasterControllerTable, vsiSessionActiveId=vsiSessionActiveId, vsiSessionSlaveId=vsiSessionSlaveId, vsiLogicalIfTable=vsiLogicalIfTable, vsiLogicalIfName=vsiLogicalIfName, vsiLogicalIfAvailIngressChnls=vsiLogicalIfAvailIngressChnls, vsiLogicalIfEntry=vsiLogicalIfEntry, VsiSessionIndex=VsiSessionIndex, vsiSessionVci=vsiSessionVci, vsiLogicalControlIfIndex=vsiLogicalControlIfIndex, vsiLogicalIfMinVpi=vsiLogicalIfMinVpi, VsiXCIndex=VsiXCIndex, vsiSessionIndex=vsiSessionIndex, vsiLogicalIfVcMergeSupported=vsiLogicalIfVcMergeSupported, vsiSessionEntry=vsiSessionEntry, ciscoVsiMasterModuleCompliance=ciscoVsiMasterModuleCompliance, vsiLogicalIfMaxIngressCellRate=vsiLogicalIfMaxIngressCellRate, vsiLogicalIfRxCellsDiscarded=vsiLogicalIfRxCellsDiscarded, vsiLogicalIfTxCells=vsiLogicalIfTxCells, vsiLogicalIfRxInvalidAddrs=vsiLogicalIfRxInvalidAddrs, vsiXCEntry=vsiXCEntry, vsiControlInterface=vsiControlInterface, VsiControllerIndex=VsiControllerIndex, VsiLogicalIfIndex=VsiLogicalIfIndex, vsiControllerId=vsiControllerId, vsiLogicalIfIndex=vsiLogicalIfIndex, vsiLogicalIfAdminState=vsiLogicalIfAdminState, vsiXCVciLow=vsiXCVciLow, vsiSessionVpi=vsiSessionVpi, vsiXCVpiLow=vsiXCVpiLow, ciscoVsiMasterCompliances=ciscoVsiMasterCompliances, vsiLogicalIfAvailIngressCellRate=vsiLogicalIfAvailIngressCellRate, PYSNMP_MODULE_ID=ciscoVsiMasterMIB, vsiSessionSwitchName=vsiSessionSwitchName, vsiXCLogicalIfHi=vsiXCLogicalIfHi)

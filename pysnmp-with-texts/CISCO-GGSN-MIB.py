#
# PySNMP MIB module CISCO-GGSN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-GGSN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:59:07 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
cGtpPathAddressType, cGtpPathAddress, cGtpPathPort = mibBuilder.importSymbols("CISCO-GTP-MIB", "cGtpPathAddressType", "cGtpPathAddress", "cGtpPathPort")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoAlarmSeverity, CiscoInetAddressMask = mibBuilder.importSymbols("CISCO-TC", "CiscoAlarmSeverity", "CiscoInetAddressMask")
ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero")
InetAddressType, InetAddress, InetAddressPrefixLength, InetAddressDNS = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress", "InetAddressPrefixLength", "InetAddressDNS")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
MibIdentifier, IpAddress, Counter64, Unsigned32, Integer32, iso, NotificationType, TimeTicks, ObjectIdentity, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Counter32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "IpAddress", "Counter64", "Unsigned32", "Integer32", "iso", "NotificationType", "TimeTicks", "ObjectIdentity", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Counter32", "ModuleIdentity")
RowStatus, TimeStamp, TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TimeStamp", "TextualConvention", "DisplayString", "TruthValue")
cGgsnMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 240))
cGgsnMIB.setRevisions(('2012-05-04 00:00', '2012-01-11 00:00', '2011-03-21 00:00', '2011-03-01 00:00', '2010-03-23 00:00', '2010-02-19 00:00', '2008-11-03 00:00', '2008-02-04 00:00', '2006-10-05 00:00', '2006-03-30 09:00', '2005-08-24 18:00', '2005-01-04 18:00', '2004-11-23 01:00', '2004-02-23 01:00', '2003-12-31 01:00', '2001-12-08 15:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cGgsnMIB.setRevisionsDescriptions(('Modified description for cGgsnSentSigMessages and cGgsnReceivedSigMessages.', 'Modified description for cGgsnSlbVserAddrType.', 'Added the following objects to cGgsnIpDupProtectTable cGgsnMsExcludeRangeStartIpv6Prefixlen, cGgsnMsExcludeRangeEndIpv6Prefixlen. Added the following objects to cGgsnPlmnIpAddrRangeTable cGgsnPlmnAddrRangeFirstIpv6Prefixlen, cGgsnPlmnAddrRangeLastIpv6Prefixlen. Modified the description of the following objects cGgsnMsExcludeRangeStartIpType, cGgsnMsExcludeRangeEndIpType, cGgsnPlmnAddrRangeIpAddrType, cGgsnIpDupProtectRowStatus and cGgsnPlmnAddrRangeRowStatus. Added a OBJECT-GROUP cGgsnConfigurationsGroupSup1. Deprecated the compliance group cGgsnMIBComplianceRev9 and added a new compliance group cGgsnMIBComplianceRev10.', 'Modified description for cGgsnSlbVserNextHopAddrType and cGgsnDefaultAggregIpAddrType.', "Added the 'release100' enumeration to cGgsnVersion.", 'Added new table cGgsnGtpEncapsuTable. Added OBJECT-GROUP cGgsnStatusGroupR90. Added MODULE-COMPLIANCE cGgsnMIBComplianceRev9, which deprecates cGgsnMIBComplianceRev8.', "Added the 'release90' enumeration to cGgsnVersion.", 'Deprecated cGgsnCompliance3GppGgsn. Added a Enumerated value to cGgsnVersion.', '+ Added cGgsnTotalCreatedIpv6Pdps, cGgsnTotalDeletedIpv6Pdps, cGgsnTotalRejectedIpv6Pdps, cGgsnSentIpv6SigMessages, cGgsnReceivedIpv6SigMessages, cGgsnSentIpv6PDUs, cGgsnReceivedIpv6PDUs, cGgsnSentIpv6PDUOctets, cGgsnReceivedIpv6PDUOctets, to cGgsnStatistics. + Added cGgsnActivatedIpv6Gtpv0Pdp, cGgsnActivatedIpv6Gtpv1Pdp, cGgsnActivatedIpv6Ms to cGgsnStatus. - Deprecated cGgsnCreateReqV1UpdExistPdp. - Deprecated all the objects of cGgsnPdpsRejStatistics. + Added cGgsnVersionNotSupportedMsgs, cGgsnUnkownGtpMsgs, cGgsnTooShortMsgs, cGgsnMandIeMissingMsgs, cGgsnMandIeIncorrectMsgs, cGgsnOptIeInvalidMsgs, cGgsnIeUnknownMsgs, cGgsnIeOutOfOrderMsgs, cGgsnIeUnexpectedMsgs, cGgsnIeDuplicatedMsgs, cGgsnOptIeIncorrectMsgs, cGgsnPdpWithoutTftExistsPdps to cGgsnStatistics. - Deprecated cGgsnPdfTable and all the table objects. - Deprecated cGgsnPdfNotifEnabled, cGgsnPdfServerAddrType,cGgsnPdfServerAddr, cGgsnPdfStateUpNotif, cGgsnPdfStateDownNotif.', '- Deprecated cGgsnSlbNotif. + Added cGgsnSlbNotifyCacFailure and cGgsnSlbNotifySessionDeletion to cGgsnConfigurations.', 'Added cGgsnSlbCacFailures, cGgsnSlbSessionFailures, cGgsnRedundancyStatistics to cGgsnStatistics. + Added cGgsnSlbVserverTable, cGgsnSlbVserverEntry, cGgsnSlbVserAddrType, cGgsnSlbVserAddress to cGgsnConfigurations. + Added cGgsnPrepaidPDPs, cGgsnPostpaidPDPs to cGgsnStatus. + Added cGgsnNotifPdpMsisdn to cGgsnNotifInfo.', 'Added cGgsnConfigVersion to cGgsnStatus.', '- Deprecated cGgsnNotification + Added cGgsnGlobalErrorNotif, cGgsnAccessPointNameNotif, cGgsnPacketDataProtocolNotif. + Added cGgsnNotifAccessPointName, cGgsnNotifPdpImsi, cGgsnGlobalErrorTypes, cGgsnAccessPointErrorTypes, cGgsnPacketDataProtoErrorTypes to cGgsnNotifInfo. - Deprecated cGgsnNotifEnabled + Added cGgsnServiceNotifEnabled, cGgsnMemoryNotifEnabled, cGgsnPdfNotifEnabled, cGgsnGlobalErrorNotifEnabled, cGgsnAccessPointNotifEnabled, cGgsnPdpNotifEnabled to cGgsnNotifMgmt', '+ Added cGgsnInServiceNotif, cGgsnMaintenanceNotif, cGgsnMemThresholdReachedNotif, cGgsnMemThresholdClearedNotif, cGgsnPdfStateUpNotif, cGgsnPdfStateDownNotif to cGgsnNotifications. + Added cGgsnPdfTable, cGgsnPcscfTable, cGgsnMemoryThreshold, cGgsnServiceMode, cGgsnPlmnTable, cGgsnSessionTimeout, cGgsnThruputIntervalOne, cGgsnThruputIntervalTwo, cGgsnCompliance3GppGgsn, cGgsnCreateReqV1UpdExistPdp, cGgsnRadAttrSessTimeout, cGgsnDownlinkVerifyMsDisable to cGgsnConfigurations. + Added cGgsnVersionNotSupportedRejPdps, cGgsnUnkownMessageRejPdps, cGgsnMsgTooShortRejPdps, cGgsnMandIeMissingRejPdps, cGgsnMandIeIncorrectRejPdps, cGgsnOptIeInvalidRejPdps, cGgsnIeUnknownRejPdps, cGgsnIeOutOfOrderRejPdps, cGgsnIeUnexpectedRejPdps, cGgsnIeDuplicatedRejPdps, cGgsnOptIeIncorrectRejPdps, cGgsnPdpWithoutTftExistsRejPdps to cGgsnPdpsRejStatistics. + Added cGgsnSgsnStatTable to cGgsnStatistics. + Added cGgsnHCSentGPDUOctets and deprecated cGgsnSentGPDUOctets. + Added cGgsnHCReceivedGPDUOctets and deprecated cGgsnReceivedGPDUOctets. + Added cGgsnServiceModeStatus to cGgsnStatus. + Added cGgsnPdfServerAddrType, cGgsnPdfServerAddr to cGgsnNotifInfo.', '+ Added cGgsnPlmnIpAddrRangeTable to cGgsnConfigurations. + Added cGgsnTftSemanticErrorPdps, cGgsnTftSyntacticErrorPdps, cGgsnPktFilterSemanticErrorPdps, cGgsnPktFilterSyntacticErrorPdps to cGgsnStatistics. + Added cGgsnActiveGtpVersion0Pdps, cGgsnActiveGtpVersion1Pdps, cGgsnGtpEncapInterface to cGgsnStatus.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: cGgsnMIB.setLastUpdated('201205040000Z')
if mibBuilder.loadTexts: cGgsnMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: cGgsnMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-gprs@cisco.com')
if mibBuilder.loadTexts: cGgsnMIB.setDescription("This MIB module manages the Gateway GPRS Support Node (GGSN) devices. A GGSN device provides interworking with external packet-data network of a particular GPRS service provider. It provides a combination of IP routing and GPRS specific functionality to support mobile users. GTP version1 is introduced in UMTS release 99 and Cisco GGSN will support both GTP version 1 (GTP v1) and version zero (GTP v0) simultaneously. GTP v1 supports multiple PDP contexts sharing one IP address. TFTs are introduced to achieve this. Each TFT is associated with a PDP context and there may exist one PDP context without TFT amongst all PDP contexts sharing the same IP address. Each TFT has one to eight packet filters each assigned with a precedence index. These packet filters are evaluated one at a time against the packet header information in sequence of their precedence index. A match is claimed if all the filters are matched and the PDP context that the TFT belongs to will be selected, else the checks are performed against the filters of another PDP context. If the packet header doesn't contain any TFT packet filter information, then the PDP context without the TFT is selected for further processing. Note on notifications: When an alarm occurs on the device, if the alarm's severity is higher than the severity filter threshold, a notification is generated by the device; and if cGgsnNotifEnabled is 'true', then the device's SNMP-engine configuration will be searched to determine where to send the notification. Acronyms and terms: APN Access Point Name CSG Content Service Gateway CDR Charging Data Record DCCA Diameter Credit Control Application ETSI European Telecommunications Standards Institute GGSN Gateway GPRS Support Node GPRS General Packet Radio Service GSM Global System for Mobile communication GTP GPRS Tunneling Protocol G-PDU GTP PDU IE Information Element MS Mobile Station MSISDN Mobile Station ISDN number PDP Packet Data Protocol PDU Protocol Data Unit PLMN Public Land Mobile Network SGSN Serving GPRS support Node SLB Server Load Balancing TFT Traffic Flow Template T-PDU the payload of G-PDU UMTS Universal Mobile Telecommunications System IMS IP Multimedia Subsystem COPS Common Open Policy Service protocol PEP Policy Enforcement Point PDF Policy Decision Function P-CSCF Proxy Call Session Control Function PLMN Public Land Mobile Network QS Quota Server UE User Equipment REFERENCE [1] GSM 03.60: Digital cellular telecommunications system (Phase 2+); General Packet Radio Service (GPRS); Service description; Stage 2. V7.1.0 [2] GSM 09.60: Digital cellular telecommunication system (Phase 2+); General Packet Radio Service (GPRS); GPRS Tunnelling Protocol (GTP) across Gn and Gp Interface. V7.3.0 [3] 3GPP; Technical Specification Group Services and System Aspects; QoS Concept and Architecture. 3G TS 23.107 v3.2.0. [4] 3GPP; Technical Specification Group Core Network; General Packet Radio Service(GPRS); GPRS Tunnelling Protocol (GTP) across Gn and Gp Interface (Release 1999). 3G TS 29.060 v3.5.0. [5] 3GPP: Technical Specification Group Core Network; Policy control over Go interface (Release 5). 3GPP TS 29.207 V5.2.0")
cGgsnMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1))
cGgsnStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1))
cGgsnNotifMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2))
cGgsnConfigurations = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3))
cGgsnStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4))
cGgsnNotifInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5))
cGgsnSentSigMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 1), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSentSigMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnSentSigMessages.setDescription('The number of GTPv0 and GTPv1 signalling messages sent. Trigger Condition: This counter is updated whenever a GTPv0 and GTPv1 signalling messages is sent out, including retries.')
cGgsnReceivedSigMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 2), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnReceivedSigMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnReceivedSigMessages.setDescription('The number of GTPv0 and GTPv1 signalling messages received. Trigger Condition: This counter is updated whenever a GTPv0 and GTPv1 signalling message is received.')
cGgsnUnexpectedSigMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 3), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnUnexpectedSigMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnUnexpectedSigMessages.setDescription('The number of unexpected GTP signalling messages received. Trigger Condition: This counter is updated whenever an unexpected Signalling message is received. Condition includes, a) A Response message for which there is no corresponding outstanding Request. b) A GTP control plane message a GSN is not expected to handle (such as a PDU Notification Request received by a GGSN). c) Charging messages in GTP path and vice-versa. d) LFN bit not being set when CG path uses short-header and vice-versa.')
cGgsnSentGPDUs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 4), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSentGPDUs.setStatus('current')
if mibBuilder.loadTexts: cGgsnSentGPDUs.setDescription('The number of G-PDU messages sent. Trigger Condition: This counter is updated whenever a G-PDU is sent out by the GGSN.')
cGgsnReceivedGPDUs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 5), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnReceivedGPDUs.setStatus('current')
if mibBuilder.loadTexts: cGgsnReceivedGPDUs.setDescription('The number of G-PDU messages received. Trigger Condition: This counter is incremented for each G-PDU received.')
cGgsnSentGPDUOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 6), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSentGPDUOctets.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnSentGPDUOctets.setDescription('The number of total bytes sent in G-PDU messages. Trigger Condition: This counter is updated whenever a G-PDU is sent out by the GGSN.')
cGgsnReceivedGPDUOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 7), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnReceivedGPDUOctets.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnReceivedGPDUOctets.setDescription('The number of total bytes received in G-PDU messages. Trigger Condition: This counter is incremented for each G-PDU received.')
cGgsnUnexpectedGPDUs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 8), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnUnexpectedGPDUs.setStatus('current')
if mibBuilder.loadTexts: cGgsnUnexpectedGPDUs.setDescription('The number of unexpected G-PDU messages, for example, non existent PDP contexts and ACL denial. Trigger Condition: This counter is updated whenever an unexpected G-PDU message is received. Conditions include, a) G-PDU for a non existent PDP. b) ACL denial.')
cGgsnActivationRejectedPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 9), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActivationRejectedPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnActivationRejectedPdps.setDescription('The number of PDP contexts that the activation request was rejected. Trigger Condition: This counter is updated when a PDP activation request is rejected. The cause for rejection can be a) Resource limitations like max PDP limit is reached, Out of memory. b) Config restrictions like trying to create NIPDP on an APN on which the same is disabled, c) Creating secondary contexts on PPP/PPP-Regen PDPs.')
cGgsnOutOfResourcePdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 10), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnOutOfResourcePdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnOutOfResourcePdps.setDescription('The number of PDP contexts that the activation request rejected due to the GGSN running out of resources for transmitting GTP packets. Examples: - Out of memory; - The number of PDPs on GGSN reached limit; - all dynamic PDP address are occupied; Trigger Condition: a) Out of memory. b) Number of PDPs on GGSN reached limit. c) Number of of PPP-regen PDPs reaches max limit. d) All dynamic PDP address are occupied. e) Incorrect configs for create pdp req. f) Qos negotiation fails. g) Create PDP req received for non-transparent APN but no radius server is present for authorization. h) Attempt to create a PDP with IP address that is already in use. i) Attempt to create a PPP-Regen PDP but the vtemplate for PPP-regen is not properly configured or VPDN configs are not proper. j) Number of pending signalling messages that needs to be processed by the GGSN is beyond the max limit(100).')
cGgsnParserErrorMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 11), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnParserErrorMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnParserErrorMessages.setDescription("The number of GTP messages received with wrong value. It includes the following cases: - mandatory and optional information element in the GTP packet is duplicated, missing, unknown, incorrect or out of order. - the GTP message is too short to hold the GTP header for the supported version. - the GTP messages running an unsupported version of GTP. - Unknown GTP message type. Trigger Condition: This counter is triggered when a signalling message is received with parsing related errors such as missing/unknown/invalid/unexpected/duplicate mandatory/optional IE's in the messages.")
cGgsnTotalCreatedPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 12), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalCreatedPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalCreatedPdps.setDescription('This object represents the total number of PDP contexts created. Trigger Condition: This counter is updated whenever a PDP context is created. This includes static, dynamic, IP, PPP, network init PDPs.')
cGgsnTotalDeletedPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 13), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalDeletedPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalDeletedPdps.setDescription('This object represents the total number of PDP contexts deleted. Trigger Condition: This counter is updated whenever a PDP context is deleted. This includes static, dynamic, IP, PPP, network init PDPs.')
cGgsnTotalNetworkInitPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 14), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalNetworkInitPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalNetworkInitPdps.setDescription('This object represents the total number of PDP contexts activated by the GGSN that were initiated by the PDN. Trigger Condition: This counter will be updated on successful creation of network initiated PDP.')
cGgsnTotalPppPdpsCreated = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 15), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalPppPdpsCreated.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalPppPdpsCreated.setDescription('This object represents the total number of PPP PDP contexts created. Trigger Condition: This counter is updated whenever a PPP PDP context is created.')
cGgsnTotalPppPdpsDeleted = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 16), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalPppPdpsDeleted.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalPppPdpsDeleted.setDescription('This object represents the total number of PPP PDP contexts deleted. Trigger Condition: This counter is updated whenever a PPP PDP context is deleted.')
cGgsnOutOfResourcePppRegenPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 17), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnOutOfResourcePppRegenPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnOutOfResourcePppRegenPdps.setDescription('This object represents the total number of create PDP context and delete PDP context requests rejected due to unavailable resource on the GGSN for PPP regeneration. Trigger Condition: a) Out of memory. b) Number of PPP-regen PDPs reaches max limit. c) All dynamic PDP address are occupied. d) Attempt to create a PPP-Regen PDP but the vtemplate for PPP-regen is not properly configured or VPDN configs are not proper.')
cGgsnDroppedPppRegenPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 18), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnDroppedPppRegenPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnDroppedPppRegenPdps.setDescription('This object represents the total number of create PDP context and delete PDP context requests that were dropped due to the threshold limit being reached for maximum number of PPP regeneration sessions allowed on the GGSN. Trigger Condition: This counter is updated when a new PPP regen PDP activation request is received by GGSN and max allowed PPP Regen session is reached.')
cGgsnTftSemanticErrorPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTftSemanticErrorPdps.setReference('3GPP; Technical Specification Group Core Network; General Packet Radio Service(GPRS); GPRS Tunnelling Protocol (GTP) across Gn and Gp Interface (Release 1999). 3G TS 29.060 v3.5.0.')
if mibBuilder.loadTexts: cGgsnTftSemanticErrorPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnTftSemanticErrorPdps.setDescription('This object represents the total number of received PDP context messages that had TFTs with semantic errors. Trigger Condition: This counter is triggered by the create, update PDP context request message.')
cGgsnTftSyntacticErrorPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTftSyntacticErrorPdps.setReference('3GPP; Technical Specification Group Core Network; General Packet Radio Service(GPRS); GPRS Tunnelling Protocol (GTP) across Gn and Gp Interface (Release 1999). 3G TS 29.060 v3.5.0.')
if mibBuilder.loadTexts: cGgsnTftSyntacticErrorPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnTftSyntacticErrorPdps.setDescription('This object represents the total number of received PDP context messages that had TFTs with syntactic errors. Trigger Condition: This counter is triggered by the create, update PDP context request message.')
cGgsnPktFilterSemanticErrorPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPktFilterSemanticErrorPdps.setReference('3GPP; Technical Specification Group Core Network; General Packet Radio Service(GPRS); GPRS Tunnelling Protocol (GTP) across Gn and Gp Interface (Release 1999). 3G TS 29.060 v3.5.0.')
if mibBuilder.loadTexts: cGgsnPktFilterSemanticErrorPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnPktFilterSemanticErrorPdps.setDescription('This object represents the total number of received PDP context messages that had packet filters with semantic errors. Trigger Condition: This counter is triggered by the create, update PDP context request message.')
cGgsnPktFilterSyntacticErrorPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPktFilterSyntacticErrorPdps.setReference('3GPP; Technical Specification Group Core Network; General Packet Radio Service(GPRS); GPRS Tunnelling Protocol (GTP) across Gn and Gp Interface (Release 1999). 3G TS 29.060 v3.5.0.')
if mibBuilder.loadTexts: cGgsnPktFilterSyntacticErrorPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnPktFilterSyntacticErrorPdps.setDescription('This object represents the total number of received PDP context messages that had packet filters with syntactic errors. Trigger Condition: This counter is triggered by the create, update PDP context request message.')
cGgsnHCSentGPDUOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 23), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHCSentGPDUOctets.setStatus('current')
if mibBuilder.loadTexts: cGgsnHCSentGPDUOctets.setDescription('The number of total bytes sent in G-PDU messages. Trigger Condition: This counter is updated whenever a G-PDU is sent out by the GGSN.')
cGgsnHCReceivedGPDUOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 24), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHCReceivedGPDUOctets.setStatus('current')
if mibBuilder.loadTexts: cGgsnHCReceivedGPDUOctets.setDescription('The number of total bytes received in G-PDU messages. Trigger Condition: This counter is incremented for each G-PDU received.')
cGgsnPdpsRejStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25))
cGgsnVersionNotSupportedRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 1), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnVersionNotSupportedRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnVersionNotSupportedRejPdps.setDescription('The number of PDP contexts that were rejected due to the cause of Version Not Supported. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnVersionNotSupportedMsgs.')
cGgsnUnkownMessageRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 2), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnUnkownMessageRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnUnkownMessageRejPdps.setDescription('The number of PDP contexts that were rejected due to the cause of Unknown Message. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnUnkownGtpMsgs.')
cGgsnMsgTooShortRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 3), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnMsgTooShortRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMsgTooShortRejPdps.setDescription('The number of PDP contexts that were rejected due to the cause of Message Too Short. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnTooShortMsgs.')
cGgsnMandIeMissingRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 4), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnMandIeMissingRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMandIeMissingRejPdps.setDescription('The number of PDP contexts that were rejected due to the cause of Mandatory IE Missing. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnMandIeMissingMsgs.')
cGgsnMandIeIncorrectRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 5), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnMandIeIncorrectRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMandIeIncorrectRejPdps.setDescription('The number of PDP contexts that were rejected due to the cause of Mandatory IE Incorrect. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnMandIeIncorrectMsgs.')
cGgsnOptIeInvalidRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 6), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnOptIeInvalidRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnOptIeInvalidRejPdps.setDescription('The number of PDP contexts that rejected due to the cause of Optional IE Invalid. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnOptIeInvalidMsgs.')
cGgsnIeUnknownRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 7), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIeUnknownRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnIeUnknownRejPdps.setDescription('The number of PDP contexts that rejected due to the cause of IE Unknown. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnIeUnknownMsgs.')
cGgsnIeOutOfOrderRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 8), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIeOutOfOrderRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnIeOutOfOrderRejPdps.setDescription('The number of PDP contexts that rejected due to the cause of IE Out of Order. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnIeOutOfOrderMsgs.')
cGgsnIeUnexpectedRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 9), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIeUnexpectedRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnIeUnexpectedRejPdps.setDescription('The number of PDP contexts that rejected due to the cause of IE Unexpected. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnIeUnexpectedMsgs.')
cGgsnIeDuplicatedRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 10), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIeDuplicatedRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnIeDuplicatedRejPdps.setDescription('The number of PDP contexts that rejected due to the cause of IE Duplicated. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnIeDuplicatedMsgs.')
cGgsnOptIeIncorrectRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 11), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnOptIeIncorrectRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnOptIeIncorrectRejPdps.setDescription('The number of PDP contexts that rejected due to the cause of Optional IE Incorrect. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnOptIeIncorrectMsgs.')
cGgsnPdpWithoutTftExistsRejPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 25, 12), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPdpWithoutTftExistsRejPdps.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdpWithoutTftExistsRejPdps.setDescription('The number of PDP contexts that are rejected due to the cause of PDP context without TFT already exists. Trigger Condition: This counter is triggered by create/update PDP / PPP PDP context request message. This object is deprecated by cGgsnPdpWithoutTftExistsPdps.')
cGgsnSgsnStatTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 26), )
if mibBuilder.loadTexts: cGgsnSgsnStatTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnSgsnStatTable.setDescription('This table has the statistics of the interface (Gi, Gn, Gp) upstream and downstream traffic per SGSN for a configurable duration set in cGgsnThruputIntervalOne and cGgsnThruputIntervalTwo. Creation of row(s) will happen when there is a valid value set to cGgsnThruputIntervalOne or cGgsnThruputIntervalTwo and when a PATH is established. Deletion of row(s) will happen when either the PATH gets removed or the throughput intervals(cGgsnThruputIntervalOne, cGgsnThruputIntervalTwo) is unset.')
cGgsnSgsnStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 26, 1), ).setIndexNames((0, "CISCO-GTP-MIB", "cGtpPathAddressType"), (0, "CISCO-GTP-MIB", "cGtpPathAddress"), (0, "CISCO-GTP-MIB", "cGtpPathPort"), (0, "CISCO-GGSN-MIB", "cGgsnSgsnThruPutInterval"))
if mibBuilder.loadTexts: cGgsnSgsnStatEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnSgsnStatEntry.setDescription('An entry in this table.')
cGgsnSgsnThruPutInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 26, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('minutes')
if mibBuilder.loadTexts: cGgsnSgsnThruPutInterval.setStatus('current')
if mibBuilder.loadTexts: cGgsnSgsnThruPutInterval.setDescription("This object should be one of the values set in the objects cGgsnThruputIntervalOne or cGgsnThruputIntervalTwo except for value '0', which means the throughput collection is disabled.")
cGgsnSgsnThruPutLastCollected = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 26, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSgsnThruPutLastCollected.setStatus('current')
if mibBuilder.loadTexts: cGgsnSgsnThruPutLastCollected.setDescription('This object represents the delta value between the time when this data is collected and the time it is been retrieved.')
cGgsnSgsnUpStreamPktCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 26, 1, 3), Gauge32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSgsnUpStreamPktCnt.setStatus('current')
if mibBuilder.loadTexts: cGgsnSgsnUpStreamPktCnt.setDescription("This object represents the total number of upstream packets sent on this SGSN data path. Data flow from MS to PDN is considered to be upstream traffic. When the throughput intervals (cGgsnThruputIntervalOne or cGgsnThruputIntervalTwo) is set to some valid value this object is set to '0' (meaning, a fresh throughput collection is started). Until the first expiry of the throughput interval , this object will be '0'. On further periodic expiry, the throughput upstream packet count per SGSN is collected and updated to this object")
cGgsnSgsnUpStreamByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 26, 1, 4), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSgsnUpStreamByteCnt.setStatus('current')
if mibBuilder.loadTexts: cGgsnSgsnUpStreamByteCnt.setDescription("This object represents the total number of upstream bytes sent on this SGSN data path. Data flow from MS to PDN is considered to be upstream traffic. When the throughput intervals (cGgsnThruputIntervalOne or cGgsnThruputIntervalTwo) is set to some valid value this object is set to '0' (meaning, a fresh throughput collection is started). Until the first expiry of the throughput interval , this object will be '0'. On further periodic expiry, the throughput upstream byte count per SGSN is collected and updated to this object")
cGgsnSgsnDownStreamPktCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 26, 1, 5), Gauge32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSgsnDownStreamPktCnt.setStatus('current')
if mibBuilder.loadTexts: cGgsnSgsnDownStreamPktCnt.setDescription("This object represents the total number of downstream packets sent on this SGSN data path. Data flow from PDN to MS is considered to be downstream traffic. When the throughput interval (cGgsnThruputIntervalOne or cGgsnThruputIntervalTwo) is set to some valid value, this object is set to '0' (meaning, a fresh throughput collection is started). Until the first expiry of the throughput interval , this object will be '0'. On further periodic expiry, the throughput downstream packet count per SGSN is collected and updated to this object.")
cGgsnSgsnDownStreamByteCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 26, 1, 6), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSgsnDownStreamByteCnt.setStatus('current')
if mibBuilder.loadTexts: cGgsnSgsnDownStreamByteCnt.setDescription("This object represents the total number of downstream bytes sent on this SGSN data path. Data flow from PDN to MS is considered to be downstream traffic. When the throughput interval (cGgsnThruputIntervalOne or cGgsnThruputIntervalTwo) is set to some valid value, this object is set to '0' (meaning, a fresh throughput collection is started). Until the first expiry of the throughput interval , this object will be '0'. On further periodic expiry, the throughput downstream byte count per SGSN is collected and updated to this object.")
cGgsnRedundancyStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27))
cGgsnTotalMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalMessages.setDescription('This counter will maintain the count of total number of messages of all kind. Trigger Condition: The counter is increamented whenever a redundancy message is sent.')
cGgsnContextSetupMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnContextSetupMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnContextSetupMessages.setDescription('The PDP context is check pointed to standby only after it goes to active. This object is a counter, which maintains the total count of PDP context setup messages. Trigger Condition: This counter is updated whenever a PDP context setup message is check pointed to standby.')
cGgsnContextModifyMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnContextModifyMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnContextModifyMessages.setDescription('For modify or update PDP context, the categories get affected and new quota is assigned to them. This new info must be check pointed to the standby. This object maintains the total number of context modify messages which are check pointed to standby. Trigger Condition: This counter is incremented whenever a context modify message is check pointed to standby.')
cGgsnContextRemoveMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnContextRemoveMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnContextRemoveMessages.setDescription('When the PDP context is deleted, deletion event is check pointed to the standby, so that the corresponding backup context deleted as well. This object will maintain the total number of context removed messages which are check pointed to standby. Trigger Condition: The counter is incremented for every context remove message, which is check pointed.')
cGgsnPathSetupMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPathSetupMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnPathSetupMessages.setDescription('Messages (of any kind PDP create/delete etc)indicate the presence of other GSN. Path is setup between the GSNs when they transmit the messages. This object contains the number of path setup messages between SGSN and GGSN. Trigger Condition: This counter is updated for every path setup messages sent.')
cGgsnPathModifyMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPathModifyMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnPathModifyMessages.setDescription('This object will contain the total number of path Modify messages. The IE recovery count is used to indicate restart of other GSN. Any change related to path or GSN will be check pointed to standby. Trigger Condition: This counter is incremented for every change related to path.')
cGgsnPathRemoveMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPathRemoveMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnPathRemoveMessages.setDescription('This object will keep track of all the messages which are responsible for path removal between the GSNs. As long as context remain established, the path between the GSNs is alive. In an instant where the last context is released and the echo timer is not enabled, the path timer is started within which the PDP context is expected to keep the path live, when the timer expires, path is Removed. Trigger Condition: This timer is triggered when the path between the GSNs is removed.')
cGgsnCGFReadyMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnCGFReadyMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnCGFReadyMessages.setDescription("The charging information are sent from GGSN to charging gateway. GTP' protocol is used between them. This object will consists of total number of CGF ready messages. Trigger Condition: The counter is incremented when CGF ready message is check pointed to standby.")
cGgsnCGFModifyMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnCGFModifyMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnCGFModifyMessages.setDescription('Significant information related to change in state of CGF must be check pointed to GGSN. This object indicates the total number of CGF modify messages recieved. Trigger condition: This counter is triggered when there is a change in CGF state.')
cGgsnCGFRemoveMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnCGFRemoveMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnCGFRemoveMessages.setDescription('This object maintains the count for all the messages responsible for CGF removal Trigger Condition: This counter is triggered when context is deleted.')
cGgsnInternalStateMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 27, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnInternalStateMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnInternalStateMsgs.setDescription("The GGSN certain information which are sent out to other GSN's (SGSN) and CGF. On failover these information must be consistent. Information like, IE recovery count sent to the other GSN's for path management, local record sequence number and charging ID etc. Trigger Condition: The counter is incremented for each of these kind of messages.")
cGgsnSlbCacFailures = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSlbCacFailures.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbCacFailures.setDescription('This object will keep track of number of CAC Failure notifications sent to SLB. Trigger Condition: The counter is incremented whenever GGSN sends CAC failure notification to SLB.')
cGgsnSlbSessionFailures = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSlbSessionFailures.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbSessionFailures.setDescription('This object will keep track of number of Session failure notifications sent to SLB. Trigger Condition: The counter is incremented whenever GGSN sends Session failure notification to SLB.')
cGgsnTotalCreatedIpv6Pdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 30), Counter32()).setUnits('PDPs').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalCreatedIpv6Pdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalCreatedIpv6Pdps.setDescription('This object represents the total number of successfully created ipv6 PDP contexts. Trigger Condition: The counter is incremented whenever a ipv6 PDP context is created. This includes static, dynamic, IP PDPs.')
cGgsnTotalDeletedIpv6Pdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 31), Counter32()).setUnits('PDPs').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalDeletedIpv6Pdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalDeletedIpv6Pdps.setDescription('This object represents the total number of ipv6 PDP contexts deleted. Trigger Condition: The counter is incremented whenever a ipv6 PDP context is deleted. This includes static, dynamic, IP, PPP PDPs.')
cGgsnTotalRejectedIpv6Pdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 32), Counter32()).setUnits('PDPs').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTotalRejectedIpv6Pdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnTotalRejectedIpv6Pdps.setDescription('This object represents the total number of rejected ipv6 PDP context activation requests. Trigger Condition: The counter is incremented when a ipv6 PDP activation request is rejected.')
cGgsnSentIpv6SigMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 33), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSentIpv6SigMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnSentIpv6SigMessages.setDescription('The total number of GTP signalling messages related to the IPv6 PDP sent by GGSN. Trigger Condition: The counter is incremented whenever a GTP signalling message for IPv6 PDP is sent out, including retries.')
cGgsnReceivedIpv6SigMessages = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 34), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnReceivedIpv6SigMessages.setStatus('current')
if mibBuilder.loadTexts: cGgsnReceivedIpv6SigMessages.setDescription('The total number of GTP signalling messages related to the IPv6 PDP received by GGSN. Trigger Condition: The counter is incremented whenever a GTP signalling message for IPv6 PDP is received.')
cGgsnSentIpv6PDUs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 35), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSentIpv6PDUs.setStatus('current')
if mibBuilder.loadTexts: cGgsnSentIpv6PDUs.setDescription('The number of ipv6 data packets sent by GGSN. Trigger Condition: The counter is incremented whenever a G-PDU is sent out by the GGSN.')
cGgsnReceivedIpv6PDUs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 36), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnReceivedIpv6PDUs.setStatus('current')
if mibBuilder.loadTexts: cGgsnReceivedIpv6PDUs.setDescription('The number of ipv6 data packets receivd by GGSN. Trigger Condition: This counter is incremented for each G-PDU received.')
cGgsnSentIpv6PDUOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 37), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnSentIpv6PDUOctets.setStatus('current')
if mibBuilder.loadTexts: cGgsnSentIpv6PDUOctets.setDescription('The number of ipv6 data bytes sent, in PDU messages, by GGSN. Trigger Condition: The counter is incremented whenever a G-PDU is sent out by the GGSN.')
cGgsnReceivedIpv6PDUOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 38), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnReceivedIpv6PDUOctets.setStatus('current')
if mibBuilder.loadTexts: cGgsnReceivedIpv6PDUOctets.setDescription('The number of ipv6 data bytes received, in PDU messages, by GGSN. Trigger Condition: The counter is incremented for each G-PDU received.')
cGgsnVersionNotSupportedMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 39), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnVersionNotSupportedMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnVersionNotSupportedMsgs.setDescription('The number of GTP messages received from devices running an unsupported version of the GTP.')
cGgsnUnkownGtpMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 40), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnUnkownGtpMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnUnkownGtpMsgs.setDescription('The number of unknown GTP messages received.')
cGgsnTooShortMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 41), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnTooShortMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnTooShortMsgs.setDescription('The number of GTP messages received that are too short to hold the GTP header for the supported GTP version.')
cGgsnMandIeMissingMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 42), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnMandIeMissingMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnMandIeMissingMsgs.setDescription('The number of GTP messages received with a missing mandatory information element.')
cGgsnMandIeIncorrectMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 43), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnMandIeIncorrectMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnMandIeIncorrectMsgs.setDescription('The number of GTP messages received with an incorrect mandatory information element, for example, with an information element that has an incorrect length.')
cGgsnOptIeInvalidMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 44), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnOptIeInvalidMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnOptIeInvalidMsgs.setDescription('The number of GTP messages received with an information element that contains a value that is not within the defined range for that IE. GTP messages with invalid optional IEs are processed as if the IE was not present.')
cGgsnIeUnknownMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 45), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIeUnknownMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnIeUnknownMsgs.setDescription('The number of GTP messages received with an information element of an unknown type.')
cGgsnIeOutOfOrderMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 46), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIeOutOfOrderMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnIeOutOfOrderMsgs.setDescription('The number of GTP messages received with an information element out of order.')
cGgsnIeUnexpectedMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 47), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIeUnexpectedMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnIeUnexpectedMsgs.setDescription('The number of GTP messages received with an information element that is not expected in the GTP message, but is defined in GTP. GTP messages with unexpected IEs are processed as if the IE was not present.')
cGgsnIeDuplicatedMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 48), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIeDuplicatedMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnIeDuplicatedMsgs.setDescription('The number of GTP messages received with a duplicated information element.')
cGgsnOptIeIncorrectMsgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 49), Counter32()).setUnits('messages').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnOptIeIncorrectMsgs.setStatus('current')
if mibBuilder.loadTexts: cGgsnOptIeIncorrectMsgs.setDescription('The number of GTP messages received with an optional IE that is incorrect, which prevents the GGSN from processing the GTP message correctly.')
cGgsnPdpWithoutTftExistsPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 1, 50), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPdpWithoutTftExistsPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnPdpWithoutTftExistsPdps.setDescription('The number of create PDP context requests received without traffic flow template information element.')
cGgsnNotifEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnNotifEnabled.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotifEnabled.setDescription("Indicates whether cGgsnNotification notification will be sent when a notification is generated by the device. - 'true', it will enable the device to send a notification, as well as logging the notification to the cGgsnHistNotifTable. - 'false', it will prevent the device from sending out a notification, but it will still log the notification into cGgsnHistNotifTable.")
cGgsnNotifLeastSeverLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 2), CiscoAlarmSeverity().clone('info')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnNotifLeastSeverLevel.setStatus('current')
if mibBuilder.loadTexts: cGgsnNotifLeastSeverLevel.setDescription('Indicates the least severity level of the cGgsnNotification notifications to be generated by the device. Thus, notifications are not generated for alarms with a severity level less urgent than the value of this object. This object cannot be set to cleared(1) or indeterminate(2).')
cGgsnGeneratedNotifs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 3), Counter32()).setUnits('notifications').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnGeneratedNotifs.setStatus('current')
if mibBuilder.loadTexts: cGgsnGeneratedNotifs.setDescription('The number of cGgsnNotification notifications that have been generated since sysUpTime.')
cGgsnIgnoredAlarms = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 4), Counter32()).setUnits('notifications').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnIgnoredAlarms.setStatus('current')
if mibBuilder.loadTexts: cGgsnIgnoredAlarms.setDescription('The number of alarms which are less severe than cGgsnNotifLeastSeverLevel since sysUpTime, and thus, for which no notification was generated.')
cGgsnHistNotifMaxLength = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(100)).setUnits('entries').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnHistNotifMaxLength.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifMaxLength.setDescription('The maximum number of entries to be retained in the cGgsnHistNotifTable. When the table is full, the oldest entries are removed to make space for new entries.')
cGgsnHistNotifLatestIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHistNotifLatestIndex.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifLatestIndex.setDescription('The value of cGgsnHistNotifIndex for the most recently created entry in cGgsnHistNotifTable.')
cGgsnHistNotifTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7), )
if mibBuilder.loadTexts: cGgsnHistNotifTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifTable.setDescription('A history table of the most recent cGgsnNotification notifications generated by this device. If a new cGgsnNotification notification is generated when the number of entries is equal to cGgsnHistNotifMaxLength, then the oldest entry is deleted and replaced with an entry for the latest notification.')
cGgsnHistNotifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7, 1), ).setIndexNames((0, "CISCO-GGSN-MIB", "cGgsnHistNotifIndex"))
if mibBuilder.loadTexts: cGgsnHistNotifEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifEntry.setDescription('Detailed information concerning a particular notification that previously generated from this device.')
cGgsnHistNotifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cGgsnHistNotifIndex.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifIndex.setDescription('A monotonically increasing integer for the sole purpose of indexing notifications. When it reaches the maximum value, it wraps the value back to 1.')
cGgsnHistNotifType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("ggsnServiceUp", 1), ("ggsnServiceDown", 2), ("mapSgsnUp", 3), ("mapSgsnDown", 4), ("noResource", 5), ("noRADIUS", 6), ("noDHCPServer", 7), ("ipAllocationFail", 8), ("authenticationFail", 9), ("apnUnreachable", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHistNotifType.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifType.setDescription('This object indicates the type of notification.')
cGgsnHistNotifSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7, 1, 3), CiscoAlarmSeverity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHistNotifSeverity.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifSeverity.setDescription('This object indicates the severity level of the notification. This object cannot be set to cleared(1) or indeterminate(2).')
cGgsnHistNotifTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHistNotifTimestamp.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifTimestamp.setDescription('This object indicates the value of sysUpTime when this notification was generated.')
cGgsnHistNotifGgsnIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHistNotifGgsnIpAddrType.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifGgsnIpAddrType.setDescription('This object indicates the type of Internet address by which cGgsnHistNotifGgsnIpAddr is reachable.')
cGgsnHistNotifGgsnIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHistNotifGgsnIpAddr.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifGgsnIpAddr.setDescription('The object indicates the IP address that uniquely identifies the device which generated the notification.')
cGgsnHistNotifInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 7, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnHistNotifInfo.setStatus('current')
if mibBuilder.loadTexts: cGgsnHistNotifInfo.setDescription("A textual description of cGgsnHistNotifType, which potentially contains additional information (more than just the type of alarm). If the text of the message exceeds 64 bytes, the message will be truncated to 63 bytes and a '*' character will be appended to indicate the message has been truncated.")
cGgsnServiceNotifEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnServiceNotifEnabled.setStatus('current')
if mibBuilder.loadTexts: cGgsnServiceNotifEnabled.setDescription("Indicates whether cGgsnInServiceNotif notification and cGgsnMaintenanceNotif notification will be sent when a notification is generated by the device. - 'true', it will enable the device to send a notification. - 'false', it will prevent the device from sending out a notification.")
cGgsnMemoryNotifEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnMemoryNotifEnabled.setStatus('current')
if mibBuilder.loadTexts: cGgsnMemoryNotifEnabled.setDescription("Indicates whether cGgsnMemThresholdReachedNotif notification and cGgsnMemThresholdClearedNotif notification will be sent when a notification is generated by the device. - 'true', it will enable the device to send a notification. - 'false', it will prevent the device from sending out a notification.")
cGgsnPdfNotifEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnPdfNotifEnabled.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfNotifEnabled.setDescription("Indicates whether cGgsnPdfStateUpNotif notification and cGgsnPdfStateDownNotiff notification will be sent when a notification is generated by the device. - 'true', it will enable the device to send a notification. - 'false', it will prevent the device from sending out a notification.")
cGgsnGlobalErrorNotifEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 11), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnGlobalErrorNotifEnabled.setStatus('current')
if mibBuilder.loadTexts: cGgsnGlobalErrorNotifEnabled.setDescription("Indicates whether cGgsnGlobalErrorNotif notification will be sent when a notification is generated by the device. - 'true', it will enable the device to send a notification. - 'false', it will prevent the device from sending out a notification.")
cGgsnAccessPointNotifEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 12), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnAccessPointNotifEnabled.setStatus('current')
if mibBuilder.loadTexts: cGgsnAccessPointNotifEnabled.setDescription("Indicates whether cGgsnAccessPointNameNotif notification will be sent when a notification is generated by the device. - 'true', it will enable the device to send a notification. - 'false', it will prevent the device from sending out a notification.")
cGgsnPdpNotifEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 2, 13), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnPdpNotifEnabled.setStatus('current')
if mibBuilder.loadTexts: cGgsnPdpNotifEnabled.setDescription("Indicates whether cGgsnPacketDataProtocolNotif notification will be sent when a notification is generated by the device. - 'true', it will enable the device to send a notification. - 'false', it will prevent the device from sending out a notification.")
cGgsnDefaultIpAllocationMethod = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("dhcp", 2), ("radius", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnDefaultIpAllocationMethod.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultIpAllocationMethod.setDescription("Specifies the default method by which the GGSN obtains address leases for mobile user sessions. - 'disable', which indicates that dynamic address allocation is disabled. - 'dhcp', which indicates that the DHCP server will be used. - 'radius', which indicates that the radius server will be used.")
cGgsnIdlePdpPurgeTimer = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(72)).setUnits('hours').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnIdlePdpPurgeTimer.setStatus('current')
if mibBuilder.loadTexts: cGgsnIdlePdpPurgeTimer.setDescription("This object specifies the time that the GGSN waits before purging idle PDP contexts. A value '0' will disable the purge timer.")
cGgsnIpDupProtectTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3), )
if mibBuilder.loadTexts: cGgsnIpDupProtectTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnIpDupProtectTable.setDescription('This table contains the range of IP address used in the GPRS PLMN. These IP addresses are used to avoid IP address duplication in GPRS network. IP address duplication occurs when a MS uses an IP address which is already used in the PLMN. The IP addresses configured inside GPRS network should be in these ranges and MS IP address should not be in this range.')
cGgsnIpDupProtectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3, 1), ).setIndexNames((0, "CISCO-GGSN-MIB", "cGgsnMsExcludeRangeStartIpType"), (0, "CISCO-GGSN-MIB", "cGgsnMsExcludeRangeStartIp"), (0, "CISCO-GGSN-MIB", "cGgsnMsExcludeRangeEndIpType"), (0, "CISCO-GGSN-MIB", "cGgsnMsExcludeRangeEndIp"))
if mibBuilder.loadTexts: cGgsnIpDupProtectEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnIpDupProtectEntry.setDescription('Entry containing the start and end IP address in the address range. An Entry with start IP > end IP is not allowed. No new entry will be accepted if that would cause any IP address(es) to be represented by more than one row in this table.')
cGgsnMsExcludeRangeStartIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cGgsnMsExcludeRangeStartIpType.setStatus('current')
if mibBuilder.loadTexts: cGgsnMsExcludeRangeStartIpType.setDescription('The type of Internet address by which cGgsnMsExcludeRangeStartIp is reachable. The value of this object should be same as cGgsnMsExcludeRangeEndIpType.')
cGgsnMsExcludeRangeStartIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20)))
if mibBuilder.loadTexts: cGgsnMsExcludeRangeStartIp.setStatus('current')
if mibBuilder.loadTexts: cGgsnMsExcludeRangeStartIp.setDescription('Starting IP address in the address range.')
cGgsnMsExcludeRangeEndIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3, 1, 3), InetAddressType())
if mibBuilder.loadTexts: cGgsnMsExcludeRangeEndIpType.setStatus('current')
if mibBuilder.loadTexts: cGgsnMsExcludeRangeEndIpType.setDescription('The type of Internet address by which cGgsnMsExcludeRangeEndIp is reachable. The value of this object should be same as cGgsnMsExcludeRangeStartIpType.')
cGgsnMsExcludeRangeEndIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3, 1, 4), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20)))
if mibBuilder.loadTexts: cGgsnMsExcludeRangeEndIp.setStatus('current')
if mibBuilder.loadTexts: cGgsnMsExcludeRangeEndIp.setDescription('Ending IP address in the address range.')
cGgsnIpDupProtectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnIpDupProtectRowStatus.setStatus('current')
if mibBuilder.loadTexts: cGgsnIpDupProtectRowStatus.setDescription("This object is used to create a new row or delete an existing row in this table. To create a row, set this object to 'createAndGo' and the objects cGgsnMsExcludeRangeStartIpv6Prefixlen and cGgsnMsExcludeRangeEndIpv6Prefixlen should be set to valid values. To delete a row, set this object to 'destroy'.")
cGgsnMsExcludeRangeStartIpv6Prefixlen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3, 1, 6), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnMsExcludeRangeStartIpv6Prefixlen.setStatus('current')
if mibBuilder.loadTexts: cGgsnMsExcludeRangeStartIpv6Prefixlen.setDescription('This object represents the IPv6 prefix length supplied for the cGgsnMsExcludeRangeStartIp.The value of this object will be zero when cGgsnMsExcludeRangeStartIpType is IPv4.')
cGgsnMsExcludeRangeEndIpv6Prefixlen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 3, 1, 7), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnMsExcludeRangeEndIpv6Prefixlen.setStatus('current')
if mibBuilder.loadTexts: cGgsnMsExcludeRangeEndIpv6Prefixlen.setDescription('This object represents the IPv6 prefix length supplied for the cGgsnMsExcludeRangeEndIp.The value of this object will be zero when cGgsnMsExcludeRangeEndIpType is IPv4.')
cGgsnDefaultAggregTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 4), )
if mibBuilder.loadTexts: cGgsnDefaultAggregTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultAggregTable.setDescription('This table contains the list of default aggregate routes configured on the GGSN. GGSN uses a static host route to forward user data packets for each PDP context received from Gi interface to Gn interface. Using the aggregate route (address range), the total number of static routes implemented in the GGSN for PDP requests can be greatly reduced.')
cGgsnDefaultAggregEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 4, 1), ).setIndexNames((0, "CISCO-GGSN-MIB", "cGgsnDefaultAggregIpAddrType"), (0, "CISCO-GGSN-MIB", "cGgsnDefaultAggregIpAddr"), (0, "CISCO-GGSN-MIB", "cGgsnDefaultAggregIpMask"))
if mibBuilder.loadTexts: cGgsnDefaultAggregEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultAggregEntry.setDescription('An Entry contains the IP network prefix which is used to combine the routes of PDP requests for the same network as a single route on the GGSN.')
cGgsnDefaultAggregIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cGgsnDefaultAggregIpAddrType.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultAggregIpAddrType.setDescription('This object specifies the type of Internet address denoted by cGgsnDefaultAggregIpAddr.')
cGgsnDefaultAggregIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 4, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20)))
if mibBuilder.loadTexts: cGgsnDefaultAggregIpAddr.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultAggregIpAddr.setDescription('This object specifies the IP address whose network prefix is going to be defined by cGgsnDefaultAggregIpMask.')
cGgsnDefaultAggregIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 4, 1, 3), CiscoInetAddressMask())
if mibBuilder.loadTexts: cGgsnDefaultAggregIpMask.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultAggregIpMask.setDescription('This object specifies the net-mask pertaining to cGgsnDefaultAggregIpAddr.')
cGgsnDefaultAggregRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnDefaultAggregRowStatus.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultAggregRowStatus.setDescription("This object is used to create a new row or delete an existing row in this table. To create a row, set this object to 'createAndGo'. To delete a row, set this object to 'destroy'. The values 'createAndWait' and 'notInService' are not supported.")
cGgsnDefaultAaaAuthServerGroup = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnDefaultAaaAuthServerGroup.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultAaaAuthServerGroup.setDescription("This object specifies the AAA radius server group that is used for authentication by all APN's on this GGSN.")
cGgsnDefaultAaaAccServerGroup = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnDefaultAaaAccServerGroup.setStatus('current')
if mibBuilder.loadTexts: cGgsnDefaultAaaAccServerGroup.setDescription("This object specifies the AAA radius server group that is used for accounting by all APN's on this GGSN.")
cGgsnPppVirtualTemplate = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 7), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnPppVirtualTemplate.setStatus('current')
if mibBuilder.loadTexts: cGgsnPppVirtualTemplate.setDescription("This object represents the virtual template interface used by PPP Type PDP's.")
cGgsnPppRegenVirtualTemplate = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 8), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnPppRegenVirtualTemplate.setStatus('current')
if mibBuilder.loadTexts: cGgsnPppRegenVirtualTemplate.setDescription("This object represents the virtual template interface used for PPP Regeneration by the APN's on which PPP Regeneration is configured. The value zero indicates that no interface is specified.")
cGgsnPlmnIpAddrRangeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9), )
if mibBuilder.loadTexts: cGgsnPlmnIpAddrRangeTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnIpAddrRangeTable.setDescription('This table contains the range of IP addresses that belong to the PLMN nodes in a GPRS network. This range does not include address of various entities like RADIUS, DHCP, DNS servers, etc., which are not part of PLMN.')
cGgsnPlmnIpAddrRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9, 1), ).setIndexNames((0, "CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeIpAddrType"), (0, "CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeFirstIp"), (0, "CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeLastIp"))
if mibBuilder.loadTexts: cGgsnPlmnIpAddrRangeEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnIpAddrRangeEntry.setDescription('Entry containing the first and last IP address in the address range. An Entry with first-IP > last-IP is not allowed. No new entry will be accepted if that would cause any IP address(es) to be represented by more than one row in this table.')
cGgsnPlmnAddrRangeIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeIpAddrType.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeIpAddrType.setDescription('The address type for cGgsnPlmnAddrRangeFirstIp and cGgsnPlmnAddrRangeLastIp addresses.')
cGgsnPlmnAddrRangeFirstIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20)))
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeFirstIp.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeFirstIp.setDescription('First IP address in the address range.')
cGgsnPlmnAddrRangeLastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20)))
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeLastIp.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeLastIp.setDescription('Last IP address in the address range.')
cGgsnPlmnAddrRangeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeRowStatus.setDescription("This object is used to create a new row or delete an existing row in this table. To create a row, set this object to 'createAndGo' and the objects cGgsnPlmnAddrRangeFirstIpv6Prefixlen and cGgsnPlmnAddrRangeLastIpv6Prefixlen should be set to valid values. To delete a row, set this object to 'destroy'. To modify a row, the row needs to be deleted and created fresh with new values.")
cGgsnPlmnAddrRangeUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("security", 1), ("sgsn", 2))).clone('security')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeUsage.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeUsage.setDescription("This object specifies how the address range will be used by the GGSN. When set to 'security', the address range is used for GGSN security feature i.e. any TPDU with destination address that falls in this address range will be discarded. When set to 'sgsn', the address range denotes the sgsn address range in the local PLMN which can be used to check roaming MS.")
cGgsnPlmnAddrRangeFirstIpv6Prefixlen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9, 1, 6), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeFirstIpv6Prefixlen.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeFirstIpv6Prefixlen.setDescription('This object represents the IPv6 prefix length supplied for the cGgsnPlmnAddrRangeFirstIp .The value of this object will be zero when cGgsnPlmnAddrRangeFirstIpType is IPv4.')
cGgsnPlmnAddrRangeLastIpv6Prefixlen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 9, 1, 7), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeLastIpv6Prefixlen.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnAddrRangeLastIpv6Prefixlen.setDescription('This object represents the IPv6 prefix length supplied for the cGgsnPlmnAddrRangeLastIp .The value of this object will be zero when cGgsnPlmnAddrRangeLastIpType is IPv4.')
cGgsnImsConfigurations = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10))
cGgsnPdfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1), )
if mibBuilder.loadTexts: cGgsnPdfTable.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfTable.setDescription("This table contains the details of PDF server that the GGSN supports. The table elements describes their properties. PDF's are the server's to which the client GGSN makes the TCP connection using the COPS protocol over the Go interface. GGSN can have connections with multiple PDF's.")
cGgsnPdfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1), ).setIndexNames((0, "CISCO-GGSN-MIB", "cGgsnPdfGroupName"), (0, "CISCO-GGSN-MIB", "cGgsnPdfDomainName"), (0, "CISCO-GGSN-MIB", "cGgsnPdfIpAddressType"), (0, "CISCO-GGSN-MIB", "cGgsnPdfIpAddress"))
if mibBuilder.loadTexts: cGgsnPdfEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfEntry.setDescription('Entry containing the PDF servers details (name and IP address) and also how the GGSN should communicate with PDF, like timeout when there is no response, number of retries.')
cGgsnPdfGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 100)))
if mibBuilder.loadTexts: cGgsnPdfGroupName.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfGroupName.setDescription('This object specifies the PDF group name. Currently this group name is just an identity to this group.')
cGgsnPdfDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 2), InetAddressDNS().subtype(subtypeSpec=ValueSizeConstraint(1, 100)))
if mibBuilder.loadTexts: cGgsnPdfDomainName.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfDomainName.setDescription('This is a Fully Qualified Domain Name (FQDN), which has to be configured along with the IP address of the PDF. There will be no name resolving for the FQDN, it will be used as it is.')
cGgsnPdfIpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 3), InetAddressType())
if mibBuilder.loadTexts: cGgsnPdfIpAddressType.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfIpAddressType.setDescription('This object specifies the type of IP address of the PDF server.')
cGgsnPdfIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 4), InetAddress())
if mibBuilder.loadTexts: cGgsnPdfIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfIpAddress.setDescription('This object specifies the IP address of the PDF server. The type of the address is specified by the object cGgsnPdfIpAddressType.')
cGgsnPdfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPdfRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfRowStatus.setDescription("This object is used to create a new row or delete an existing row in this table. To create a row, set this object to 'createAndGo(4)'. To delete a row, set this object to 'destroy(6)'.")
cGgsnPdfReconnectTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPdfReconnectTimeOut.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfReconnectTimeOut.setDescription('Whenever a connection outage is detected (by keepalive mechanism etc.) by GGSN to the PDF server. The GGSN waits for the interval configured in this object. Once this timer is expired, another attempt is made for connection establishment.')
cGgsnPdfReconnectRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 10), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPdfReconnectRetries.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfReconnectRetries.setDescription("This is the number of attempts for connection establishment after the timeout value set in cGgsnPdfReconnectTimeOut. After the configured number of retries, all the COPS sessions (and associated PDP contexts) are cleared. The value '65535' which is default, will be infinite retries.")
cGgsnPdfReconExpPdpDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPdfReconExpPdpDelete.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfReconExpPdpDelete.setDescription('This objects defines the handling of the PDP context in the connection loss scenario. When this object is set to true, then on connection loss, the PDP delete will be initiated.')
cGgsnPdfReqRetryTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPdfReqRetryTimeOut.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfReqRetryTimeOut.setDescription('For each COPS REQ sent to PDF, GGSN will start a request retry timer with this value. If DEC is not received within the timeout, the REQ is resent for cGgsnPdfReqRetries times.')
cGgsnPdfReqRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPdfReqRetries.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfReqRetries.setDescription('This is the number of retries which has to be sent for the COPS REQ being sent. If DEC is not received even after sending the COPS REQ for configured number of retries, the PDP context activation/modification (which had triggered this REQ) is rejected.')
cGgsnPcscfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 2), )
if mibBuilder.loadTexts: cGgsnPcscfTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnPcscfTable.setDescription('This table contains the entries of P-CSCF groups with the addresses configured. One or more IP address can be configured per group name. This group in turn will be mapped to the APN. P-CSCF is a network element providing session management services. When the UE request the GGSN for P-CSCF address through activate PDP Request, these addresses will be returned to the UE in the order which they are configured.')
cGgsnPcscfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 2, 1), ).setIndexNames((0, "CISCO-GGSN-MIB", "cGgsnPcscfGroupName"), (0, "CISCO-GGSN-MIB", "cGgsnPcscfIpAddressType"), (0, "CISCO-GGSN-MIB", "cGgsnPcscfIpAddress"))
if mibBuilder.loadTexts: cGgsnPcscfEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnPcscfEntry.setDescription('An entry is created when the user configures the group name and an IP address is set.')
cGgsnPcscfGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 100)))
if mibBuilder.loadTexts: cGgsnPcscfGroupName.setStatus('current')
if mibBuilder.loadTexts: cGgsnPcscfGroupName.setDescription('This group name is the identifier for the P-CSCF addresses configured.')
cGgsnPcscfIpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 2, 1, 2), InetAddressType())
if mibBuilder.loadTexts: cGgsnPcscfIpAddressType.setStatus('current')
if mibBuilder.loadTexts: cGgsnPcscfIpAddressType.setDescription('This object specifies the type of the P-CSCF IP address.')
cGgsnPcscfIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 2, 1, 3), InetAddress())
if mibBuilder.loadTexts: cGgsnPcscfIpAddress.setStatus('current')
if mibBuilder.loadTexts: cGgsnPcscfIpAddress.setDescription('This object specifies the IP address of the P-CSCF. The type of this address is specified by the object cGgsnPcscfIpAddressType.')
cGgsnPcscfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 10, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPcscfRowStatus.setStatus('current')
if mibBuilder.loadTexts: cGgsnPcscfRowStatus.setDescription("This object is used to create a new row or delete an existing row in this table. To create a row, set this object to 'createAndGo(4)'. To delete a row, set this object to 'destroy(6)'.")
cGgsnMemoryThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setUnits('98304Bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnMemoryThreshold.setStatus('current')
if mibBuilder.loadTexts: cGgsnMemoryThreshold.setDescription("GGSN memory overload protection is a mechanism to prevent GGSN from completely running out of memory when GGSN is running near its capacity or in some failure scenarios like CG down. A protection mechanism was put into place where charging triggers would be ignored, PDP create would be rejected, PDP update request will delete PDP, once the available memory on the GGSN drops below a configured threshold. Charging triggers occurs due to certain criteria's like volume limit, time limit. When one of the conditions is met , the CDR's are closed and will be updated to the charging gateway.")
cGgsnServiceMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("maintenance", 2))).clone('inService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnServiceMode.setStatus('current')
if mibBuilder.loadTexts: cGgsnServiceMode.setDescription("GGSN supports this GPRS service mode for maintenance purposes. Two modes are supported in GGSN, operational and maintenance mode. 'inService' mode represents nominal operation, and there will be no change in the way the GGSN operates. 'maintenance' mode imposes restrictions, such as some of the configurations allowed by the GGSN, and no new PDPs will be accepted. 'maintenance' mode can be useful to make some changes to the configuration of the GGSN without affecting the existing PDPs. 'maintenance' mode gloablly applies to the GGSN, which means the whole box will be put in maintenance mode. There also exists APN level maintenance mode, which is defined in CISCO-GPRS_ACC-PT-MIB, and charging maintenance mode which is defined in CISCO-GPRS-CHARGING-MIB, which is out of scope of this MIB. Internally GGSN maintains three states (inService, maintenance and outOfService ), which can be viewed with cGgsnServiceModeStatus. The SNMP entity generates notification when switching modes. It uses the cGgsnInServiceNotif and cGgsnMaintenanceNotif for this purpose.")
cGgsnPlmnTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 13), )
if mibBuilder.loadTexts: cGgsnPlmnTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnTable.setDescription('Mobile Country Code (MCC) and Mobile Network Code (MNC) together identify a GPRS PLMN of an operator. PLMN Ids other than home PLMNs are considered as foreign. There will be some situations where some foreign PLMNs has to be treated as trusted PLMNs. This table contains the list of PLMNs, there can be one home PLMN entry and multiple trusted PLMN entry.')
cGgsnPlmnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 13, 1), ).setIndexNames((0, "CISCO-GGSN-MIB", "cGgsnPlmnMcc"), (0, "CISCO-GGSN-MIB", "cGgsnPlmnMnc"))
if mibBuilder.loadTexts: cGgsnPlmnEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnEntry.setDescription('Entry containing list of home PLMN Ids and the Trusted PLMN Ids.')
cGgsnPlmnMcc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 13, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3))
if mibBuilder.loadTexts: cGgsnPlmnMcc.setReference('Digital cellular telecommunications system (Phase 2+); Numbering, addressing and identification (GSM 03.03 version 7.3.0 Release 1998) Available SMG only')
if mibBuilder.loadTexts: cGgsnPlmnMcc.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnMcc.setDescription('The Mobile Country Code (MCC) is part of the PLMN Id.')
cGgsnPlmnMnc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 13, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(2, 3)))
if mibBuilder.loadTexts: cGgsnPlmnMnc.setReference('Digital cellular telecommunications system (Phase 2+); Numbering, addressing and identification (GSM 03.03 version 7.3.0 Release 1998) Available SMG only')
if mibBuilder.loadTexts: cGgsnPlmnMnc.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnMnc.setDescription('The Mobile Network Code (MNC) is part of the PLMN Id.')
cGgsnPlmnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 13, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPlmnRowStatus.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnRowStatus.setDescription("This object is used to create a new row or delete an existing row in this table. To create a row, set this object to 'createAndGo'. To delete a row, set this object to 'destroy'. To modify a row, the row needs to be deleted and created fresh with new values.")
cGgsnPlmnScope = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("home", 1), ("trusted", 2))).clone('home')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnPlmnScope.setStatus('current')
if mibBuilder.loadTexts: cGgsnPlmnScope.setDescription('This object specifies whether the PLMN is home or trusted. Only one PLMN entry can be home')
cGgsnSessionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(30, 4294967), ))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnSessionTimeout.setStatus('current')
if mibBuilder.loadTexts: cGgsnSessionTimeout.setDescription("This object specifies the PDP context timeout value. The PDP context will be terminated after this timer expiry. The value present in this will have meaning when the object cGgsnRadAttrSessTimeout is set to 'true' and if the attribute#27 not received from the AAA.")
cGgsnThruputIntervalOne = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnThruputIntervalOne.setStatus('current')
if mibBuilder.loadTexts: cGgsnThruputIntervalOne.setDescription("This object and cGgsnThruputIntervalTwo specifies the interval at which the data throughput needs to be collected per APN/SGSN. Once this object is set to some valid value, the data throughput collections gets started for per configured APN and per PATH created. The data throughput collection is updated periodically (each expiry of configured throughput interval) to the corresponding objects (cGgsnSgsnStatTable for per SGSN and cgprsAccPtThruputStatsTable for per APN). When this object is set to '0', the collection for this interval get stopped and the data related to this interval is deleted from the tables (cGgsnSgsnStatTable and cgprsAccPtThruputStatsTable). INCONSISTENT value SNMP error will happen when trying to set cGgsnThruputIntervalOne and cGgsnThruputIntervalTwo with same value expect '0'. Setting the same value to the same object will reset the value / collection status for that interval.")
cGgsnThruputIntervalTwo = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnThruputIntervalTwo.setStatus('current')
if mibBuilder.loadTexts: cGgsnThruputIntervalTwo.setDescription("This object specifies the time interval TWO for collecting the throughput per APN/SGSN. This object is same as cGgsnThruputIntervalOne. It's just an option for a second throughput collection for a different throughput interval time. The value 0 means the timer TWO will be disabled. INCONSISTENT value SNMP error will happen when trying to set cGgsnThruputIntervalOne and cGgsnThruputIntervalTwo with same value expect '0'. Setting the same value to the same object will reset the value / collection status for that interval.")
cGgsnCompliance3GppGgsn = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("default", 0), ("release40", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnCompliance3GppGgsn.setReference('3GPP TS 29.060 v3.15.0/v4.6.0/v5.4.0')
if mibBuilder.loadTexts: cGgsnCompliance3GppGgsn.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnCompliance3GppGgsn.setDescription("This object specifies the compliance level for the particular GGSN version present in cGgsnVersion. This object can be used to set back the compliance level to the previous GGSN version. When set to 'default', the compliance level for that GGSN version indicated by the object cGgsnVersion will be considered. Currently, when the cGgsnVersion is holding a value of 'release50', the compliance level can be set back to 'release40'. This object is deprecated as the standard GGSN 8.0 release deprecated this configuration.")
cGgsnCreateReqV1UpdExistPdp = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 18), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnCreateReqV1UpdExistPdp.setReference('3GPP TS 29.060 v3.15.0/v4.6.0/v5.4.0')
if mibBuilder.loadTexts: cGgsnCreateReqV1UpdExistPdp.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnCreateReqV1UpdExistPdp.setDescription("This object is used for backward compatibility due to to implementation of CR 311. CR 311: The SGSN shall not send a Create PDP Context Request for an already active context. If a new Create PDP Context Request is incoming on TEID 0 for an already active PDP context, this Create PDP Context Request must be considered related to a new session. The existing PDP context shall be torn down locally, and the associated PDP contexts deleted locally, before the new session is created. If a new Create PDP Context Request is incoming on a TEID which is different from 0 and this TEID is already allocated to one or more activated PDP contexts, and the NSAPI IE value in this message matches the NSAPI value of an active PDP context, the GGSN shall send back a Create PDP Context Response with a rejection cause code. It is implementation dependent deciding whether to teardown or keep the existing PDP context. 'false' - The changes due to CR 311 will be applicable. 'true' - The changes due to CR 311 will not be taken into account. This object has no meaning when the object cGgsnCompliance3GppGgsn holds a value of 'release40'. This object is deprecated as the standerd GGSN release 5.2 deprecated this configuration.")
cGgsnRadAttrSessTimeout = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 19), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnRadAttrSessTimeout.setStatus('current')
if mibBuilder.loadTexts: cGgsnRadAttrSessTimeout.setDescription("This object is used for enabling the session timeout feature on the global (router) level set using cGgsnSessionTimeout, APN level (cgprsAccPtAbsoluteSessionTimer, which is defined in CISCO-GPRS-ACC-PT-MIB and is outside the scope of this MIB) and also parse the RADIUS attribute #27 present in the access-accept request. 'true' - Session timeout is enabled. 'false' - Session timeout is disabled.")
cGgsnDownlinkVerifyMsDisable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 20), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnDownlinkVerifyMsDisable.setStatus('current')
if mibBuilder.loadTexts: cGgsnDownlinkVerifyMsDisable.setDescription("This object enables the feature which will allow the GGSN to route IP packets beyond MS. This works only if a static route is added in GGSN to the node beyond the MS. On enabling this feature, GGSN will route the packets in both process switch path and cef switch path. This is supported only for IP PDP type. This feature has some limitations: - This is not scalable, since the operator has to add static route to all the node beyond the MS. - Only works for MS having static address. - In case of GTPv1 the MS has to select TFT's so as to allow traffic flow in the downlink direction. - IP address assignment/Radius for the devices behind the MS needs to be done within the scope of that network; the GGSN will not provide this facility in anyway for the hosts behind the MS. - In case for MWAM and Cat6500/7600 environment, the static route should be added only on that particular GGSN on the MWAM from where the MS is reachable. 'true' - Routing beyond MS is enabled. 'false' - Routing beyond MS is disabled.")
cGgsnSlbMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("directed", 1), ("dispatched", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnSlbMode.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbMode.setDescription("GTP SLB can operate in two modes-dispatched and directed. - 'dispatched' mode: It forwards the create request without changing the destination IP address (vserver address) and the create response comes from the same (vserver) address. - 'directed' mode: It changes the destination IP address to that of GGSN's VT and the create response comes from the GGSN VT.")
cGgsnSlbNotif = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cacFailure", 1), ("sessionDeletion", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnSlbNotif.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnSlbNotif.setDescription('This object is used to enable or disable the GGSN behavior of sending CAC failure notification to SLB, or session failure notification to SLB. If this object is set to cacFailure(1), then this object is required to enable the feature in the dispatched mode of operation of SLB. If this object is set to sessionDeletion(2), then GGSN will send delete notification message to SLB when the last PDP associated with a IMSI is deleted. This object is deprecated by cGgsnSlbNotifyCacFailure and cGgsnSlbNotifySessionDeletion.')
cGgsnSlbVserverTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 23), )
if mibBuilder.loadTexts: cGgsnSlbVserverTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbVserverTable.setDescription('This table includes the different virtual servers (IP address of virtual servers) and the elements gives the interface to reach these servers. The table is indexed on the vserver address. The table objects can be modified, when the RowStatus (cGgsnSlbVserRowStatus) is active.')
cGgsnSlbVserverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 23, 1), ).setIndexNames((0, "CISCO-GGSN-MIB", "cGgsnSlbVserAddrType"), (0, "CISCO-GGSN-MIB", "cGgsnSlbVserAddress"))
if mibBuilder.loadTexts: cGgsnSlbVserverEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbVserverEntry.setDescription('Entry contains the Virtual server details(IP address type, IP address)and next hop address and VRF name.')
cGgsnSlbVserAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 23, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cGgsnSlbVserAddrType.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbVserAddrType.setDescription('This object specifies the address type of the vserver.')
cGgsnSlbVserAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 23, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20)))
if mibBuilder.loadTexts: cGgsnSlbVserAddress.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbVserAddress.setDescription('This object specifies the address of GTP vservers. It is required only in directed mode. If SLB is running in directed mode and this object is not configured, then the feature remains disabled. If SLB is running in the dispatched mode, the vserver that forwarded the create request is known to the GGSN and thus it is possible to send the notification directly to the vserver.')
cGgsnSlbVserNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 23, 1, 3), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnSlbVserNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbVserNextHopAddrType.setDescription('This object specifies the IP address type to reach the virtual server.')
cGgsnSlbVserNextHopAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 23, 1, 4), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnSlbVserNextHopAddress.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbVserNextHopAddress.setDescription('This object specifies the IP address to reach the vserver.')
cGgsnSlbVserVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 23, 1, 5), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnSlbVserVrfName.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbVserVrfName.setDescription('This object specifies the VRF name on an interface on GGSN connected to SLB, to reach the vserver.')
cGgsnSlbVserRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 23, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cGgsnSlbVserRowStatus.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbVserRowStatus.setDescription("This object will create new row into the table or deletes the existing one. To create a row, set this object to 'createAndGo(4)'. To delete a row, set this object to 'destroy(6)'.")
cGgsnSlbNotifyCacFailure = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 24), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnSlbNotifyCacFailure.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbNotifyCacFailure.setDescription("This object is used to enable or disable the GGSN behavior of sending CAC failure notification to SLB. CAC fails on GGSN if either the maximum number of PDPs reaches limit or there is not enough bandwidth for the traffic class for the APN. If this object is set to 'true', GGSN sends the notification to all the SLB vservers when UMTS CAC fails.")
cGgsnSlbNotifySessionDeletion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 3, 25), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cGgsnSlbNotifySessionDeletion.setStatus('current')
if mibBuilder.loadTexts: cGgsnSlbNotifySessionDeletion.setDescription("This object is used to enable or disable the GGSN behavior of sending session deletion notification to SLB. If this object is set to 'true', GGSN sends delete notification message to SLB when the last PDP associated with a IMSI is deleted.")
cGgsnVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("release14", 1), ("release30", 2), ("release40", 3), ("release31", 4), ("release50", 5), ("release60", 6), ("release70", 7), ("release80", 8), ("release90", 9), ("release100", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnVersion.setStatus('current')
if mibBuilder.loadTexts: cGgsnVersion.setDescription('This object specifies the which release of GPRS image is currently running on the GGSN.')
cGgsnActiveNetworkInitPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 2), Gauge32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActiveNetworkInitPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnActiveNetworkInitPdps.setDescription('This object represents the number of network initiated PDP contexts that are currently active. Trigger Condition: This counter is incremented / decremented by the create/delete PDP context request message respectively.')
cGgsnActivePppPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 3), Gauge32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActivePppPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnActivePppPdps.setDescription('This object represents the number of PPP PDP contexts that are currently active. Trigger Condition: This counter is incremented / decremented by the create/delete PPP PDP context request message respectively.')
cGgsnActivePppRegenPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 4), Gauge32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActivePppRegenPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnActivePppRegenPdps.setDescription('This object represents the number of PPP-Regen PDP contexts that are currently active. Trigger Condition: This counter is incremented / decremented by the create/delete PPP Regeneration PDP context request message respectively.')
cGgsnPendingPppRegenPdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 5), Gauge32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPendingPppRegenPdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnPendingPppRegenPdps.setDescription('This object represents the current number of pending PPP regeneration sessions. Trigger Condition: This counter is triggered by the create PPP Regeneration PDP context request message.')
cGgsnActiveGtpVersion0Pdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActiveGtpVersion0Pdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnActiveGtpVersion0Pdps.setDescription('This object represents the current number of active GTP v0 PDP contexts. Trigger Condition: This counter is incremented / decremented by the create/delete PDP context request message respectively.')
cGgsnActiveGtpVersion1Pdps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActiveGtpVersion1Pdps.setStatus('current')
if mibBuilder.loadTexts: cGgsnActiveGtpVersion1Pdps.setDescription('This object represents the current number of active GTP v1 PDP contexts. Trigger Condition: This counter is incremented / decremented by the create/delete PDP context request message respectively.')
cGgsnGtpEncapInterface = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 8), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnGtpEncapInterface.setStatus('current')
if mibBuilder.loadTexts: cGgsnGtpEncapInterface.setDescription('This object represents the ifIndex of the interface on which gtp encapsulation is configured. Only one interface can be configured with gtp encapsulation on the GGSN. A zero value indicates that no interface is configured with gtp encapsulation.')
cGgsnServiceModeStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inService", 1), ("maintenance", 2), ("outOfServiceInProgress", 3), ("outOfService", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnServiceModeStatus.setStatus('current')
if mibBuilder.loadTexts: cGgsnServiceModeStatus.setDescription('This object represents the internal service mode which GGSN maintains. The service switching is done with object cGgsnServiceMode.')
cGgsnConfigVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 10), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnConfigVersion.setStatus('current')
if mibBuilder.loadTexts: cGgsnConfigVersion.setDescription('This object specifies the config version of GPRS image. The value of this object will be of the form Version.Release.Maintenence. This object provides information on the ability of the devices to support configuration operations.')
cGgsnPrepaidPDPs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPrepaidPDPs.setStatus('current')
if mibBuilder.loadTexts: cGgsnPrepaidPDPs.setDescription('This object specifies the number of prepaid PDPs created since the last clearance of statistics (GPRS service aware statistics).')
cGgsnPostpaidPDPs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnPostpaidPDPs.setStatus('current')
if mibBuilder.loadTexts: cGgsnPostpaidPDPs.setDescription('This object specifies the current number of postpaid PDPs, created since the last clearance of statistics (GPRS service aware statistics).')
cGgsnActivatedIpv6Gtpv0Pdp = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 13), Gauge32()).setUnits('PDPs').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActivatedIpv6Gtpv0Pdp.setStatus('current')
if mibBuilder.loadTexts: cGgsnActivatedIpv6Gtpv0Pdp.setDescription('This object represents the current number of active GTP v0 ipv6 PDP contexts. Trigger Condition: This counter is incremented by the create PDP context request and decremented by the delete PDP context request message.')
cGgsnActivatedIpv6Gtpv1Pdp = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 14), Gauge32()).setUnits('PDPs').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActivatedIpv6Gtpv1Pdp.setStatus('current')
if mibBuilder.loadTexts: cGgsnActivatedIpv6Gtpv1Pdp.setDescription('This object represents the current number of active GTP v1 ipv6 PDP contexts. Trigger Condition: This counter is incremented by the create PDP context request and decremented by the delete PDP context request message.')
cGgsnActivatedIpv6Ms = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 15), Gauge32()).setUnits('PDPs').setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnActivatedIpv6Ms.setStatus('current')
if mibBuilder.loadTexts: cGgsnActivatedIpv6Ms.setDescription('This object represents the current number of MS with active IPv6 PDPs.')
cGgsnGtpEncapsuTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 16), )
if mibBuilder.loadTexts: cGgsnGtpEncapsuTable.setStatus('current')
if mibBuilder.loadTexts: cGgsnGtpEncapsuTable.setDescription('This table contains information about ifIndex of the interfaces on which gtp encapsulation is configured.')
cGgsnGtpEncapsuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 16, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cGgsnGtpEncapsuEntry.setStatus('current')
if mibBuilder.loadTexts: cGgsnGtpEncapsuEntry.setDescription('The cGgsnGtpEncapsuEntry represents the ifIndex of the interface on which gtp encapsulation is configured. Only one interface can be configured with gtp encapsulation on the GGSN. Entry in the table created whenever interface is configured with gtp encapsulation, Entry is deleted whenever unconfiguring the gtp encapsulation from the interface.')
cGgsnGtpEncapsuInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 4, 16, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cGgsnGtpEncapsuInterface.setStatus('current')
if mibBuilder.loadTexts: cGgsnGtpEncapsuInterface.setDescription('This object represents the ifIndex of the interface on which gtp encapsulation is configured. Only one interface can be configured with gtp encapsulation on the GGSN. A zero value indicates that no interface is configured with gtp encapsulation.')
cGgsnPdfServerAddrType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5, 1), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cGgsnPdfServerAddrType.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfServerAddrType.setDescription('This object specifies the type of IP address of the PDF server.')
cGgsnPdfServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5, 2), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cGgsnPdfServerAddr.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfServerAddr.setDescription('This object specifies the IP address of the PDF server. The type of this address is specified by the object cGgsnPdfServerAddrType.')
cGgsnNotifAccessPointName = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 100))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cGgsnNotifAccessPointName.setStatus('current')
if mibBuilder.loadTexts: cGgsnNotifAccessPointName.setDescription('This object specifies the Access Point Name and is used specify the name in the cGgsnAccessPointNameNotif notification.')
cGgsnNotifPdpImsi = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cGgsnNotifPdpImsi.setStatus('current')
if mibBuilder.loadTexts: cGgsnNotifPdpImsi.setDescription('This object specifies the International Mobile Subscriber Identity (IMSI) of the user for whom the notification is generated. This object is used to specify IMSI of the user in the cGgsnPacketDataProtocolNotif notification.')
cGgsnGlobalErrorTypes = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ggsnServiceUp", 1), ("ggsnServiceDown", 2), ("mapSgsnUp", 3), ("mapSgsnDown", 4), ("noDHCPServer", 5)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cGgsnGlobalErrorTypes.setStatus('current')
if mibBuilder.loadTexts: cGgsnGlobalErrorTypes.setDescription("This object indicates the types of global errors as follows. 'ggsnServiceUp' - GGSN service has started 'ggsnServiceDown' - GGSN service is shutdown 'mapSgsnUp' - MAP-SGSN service has started 'mapSgsnDown' - MAP-SGSN service is shutdown 'noDHCPServer' -- DHCP server is not configured")
cGgsnAccessPointErrorTypes = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noRadius", 1), ("ipAllocationFail", 2), ("apnUnreachable", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cGgsnAccessPointErrorTypes.setStatus('current')
if mibBuilder.loadTexts: cGgsnAccessPointErrorTypes.setDescription("This object indicates the types access point errors as follows. 'noRadius' - RADIUS Server is not configured. 'ipAllocationFail' - Unable to allocate IP address. 'apnUnreachable' - Unable to reach access point.")
cGgsnPacketDataProtoErrorTypes = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noResource", 1), ("authenticationFail", 2), ("ccrInitFail", 3), ("quotaPushFail", 4)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cGgsnPacketDataProtoErrorTypes.setStatus('current')
if mibBuilder.loadTexts: cGgsnPacketDataProtoErrorTypes.setDescription("This object indicates the types of Packet Data Protocol errors as follows. 'noResource' - Mobile Station initiated PDP count reaches the specified limit or Network initiated PDP count reaches the specified limit. 'authenticationFail' - Authentication failed. 'ccrInitFail' - CCR(initial)is sent to diameter server, and Tx timer expires before getting CCA (initial) response. The action on the PDP context creation is determined by the configured failure handling, as specified in cGgsnSADccaCcfh object in CISCO-GGSN-SERVICE-AWARE-MIB. 'quotaPushFail' - Quota Push failed, when the path between CSG-QS is down or when CSG sends a negative Response for quota push request.")
cGgsnNotifPdpMsisdn = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 240, 1, 5, 8), SnmpAdminString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cGgsnNotifPdpMsisdn.setStatus('current')
if mibBuilder.loadTexts: cGgsnNotifPdpMsisdn.setDescription('This object specifies the Mobile Subscriber ISDN (MSISDN) value of the user for whom the notification is generated. This object is used to specify MSISDN of the user in the cGgsnPacketDataProtocolNotif notification.')
cGgsnNotifPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 2))
cGgsnNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0))
cGgsnNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 1)).setObjects(("CISCO-GGSN-MIB", "cGgsnHistNotifType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifSeverity"), ("CISCO-GGSN-MIB", "cGgsnHistNotifTimestamp"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddrType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddr"), ("CISCO-GGSN-MIB", "cGgsnHistNotifInfo"))
if mibBuilder.loadTexts: cGgsnNotification.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotification.setDescription('This notification indicates the occurrence of a GGSN related alarm. If and when additional useful information is available for specific types of alarms, then that information may be appended to the end of the notification in additional varbinds.')
cGgsnInServiceNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 2))
if mibBuilder.loadTexts: cGgsnInServiceNotif.setStatus('current')
if mibBuilder.loadTexts: cGgsnInServiceNotif.setDescription('A notification of this type is generated when GGSN is placed in inService mode which is specified by cGgsnServiceModeStatus.')
cGgsnMaintenanceNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 3))
if mibBuilder.loadTexts: cGgsnMaintenanceNotif.setStatus('current')
if mibBuilder.loadTexts: cGgsnMaintenanceNotif.setDescription('A notification of this type is generated when GGSN is placed in maintenance mode which is specified by cGgsnServiceModeStatus.')
cGgsnMemThresholdReachedNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 4))
if mibBuilder.loadTexts: cGgsnMemThresholdReachedNotif.setStatus('current')
if mibBuilder.loadTexts: cGgsnMemThresholdReachedNotif.setDescription('A notification of this type is generated when GGSN reaches the memory threshold value specified by cGgsnMemoryThreshold.')
cGgsnMemThresholdClearedNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 5))
if mibBuilder.loadTexts: cGgsnMemThresholdClearedNotif.setStatus('current')
if mibBuilder.loadTexts: cGgsnMemThresholdClearedNotif.setDescription('A notification of this type is generated when GGSN retains the memory and falls below threshold value speficied by cGgsnMemoryThreshold.')
cGgsnPdfStateUpNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 6)).setObjects(("CISCO-GGSN-MIB", "cGgsnPdfServerAddrType"), ("CISCO-GGSN-MIB", "cGgsnPdfServerAddr"))
if mibBuilder.loadTexts: cGgsnPdfStateUpNotif.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfStateUpNotif.setDescription('A notification of this type is generated when PDF connection comes UP.')
cGgsnPdfStateDownNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 7)).setObjects(("CISCO-GGSN-MIB", "cGgsnPdfServerAddrType"), ("CISCO-GGSN-MIB", "cGgsnPdfServerAddr"))
if mibBuilder.loadTexts: cGgsnPdfStateDownNotif.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnPdfStateDownNotif.setDescription('A notification of this type is generated when PDF connection goes DOWN.')
cGgsnGlobalErrorNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 8)).setObjects(("CISCO-GGSN-MIB", "cGgsnGlobalErrorTypes"), ("CISCO-GGSN-MIB", "cGgsnHistNotifSeverity"), ("CISCO-GGSN-MIB", "cGgsnHistNotifTimestamp"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddrType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddr"), ("CISCO-GGSN-MIB", "cGgsnHistNotifInfo"))
if mibBuilder.loadTexts: cGgsnGlobalErrorNotif.setStatus('current')
if mibBuilder.loadTexts: cGgsnGlobalErrorNotif.setDescription('This notification indicates the occurrence of a GGSN related alarm.')
cGgsnAccessPointNameNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 9)).setObjects(("CISCO-GGSN-MIB", "cGgsnAccessPointErrorTypes"), ("CISCO-GGSN-MIB", "cGgsnHistNotifSeverity"), ("CISCO-GGSN-MIB", "cGgsnHistNotifTimestamp"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddrType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddr"), ("CISCO-GGSN-MIB", "cGgsnHistNotifInfo"), ("CISCO-GGSN-MIB", "cGgsnNotifAccessPointName"))
if mibBuilder.loadTexts: cGgsnAccessPointNameNotif.setStatus('current')
if mibBuilder.loadTexts: cGgsnAccessPointNameNotif.setDescription('This notification indicates the occurrence of a APN related alarm.')
cGgsnPacketDataProtocolNotif = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 240, 2, 0, 10)).setObjects(("CISCO-GGSN-MIB", "cGgsnPacketDataProtoErrorTypes"), ("CISCO-GGSN-MIB", "cGgsnHistNotifSeverity"), ("CISCO-GGSN-MIB", "cGgsnHistNotifTimestamp"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddrType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddr"), ("CISCO-GGSN-MIB", "cGgsnHistNotifInfo"), ("CISCO-GGSN-MIB", "cGgsnNotifPdpImsi"), ("CISCO-GGSN-MIB", "cGgsnNotifPdpMsisdn"), ("CISCO-GGSN-MIB", "cGgsnNotifAccessPointName"))
if mibBuilder.loadTexts: cGgsnPacketDataProtocolNotif.setStatus('current')
if mibBuilder.loadTexts: cGgsnPacketDataProtocolNotif.setDescription('This notification indicates the occurrence of a User related alarm.')
cGgsnMIBConformances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 3))
cGgsnMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1))
cGgsnMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2))
cGgsnMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 1)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroup"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroup"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroup"), ("CISCO-GGSN-MIB", "cGgsnNotifGroup"), ("CISCO-GGSN-MIB", "cGgsnStatusGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBCompliance = cGgsnMIBCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: cGgsnMIBCompliance.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB. This is deprecated by cGgsnMIBComplianceRev1.')
cGgsnMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 2)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroup"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroup"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifGroup"), ("CISCO-GGSN-MIB", "cGgsnStatusGroup"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev1 = cGgsnMIBComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev1.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB. This is deprecated by cGgsnMIBComplianceRev2')
cGgsnMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 3)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroup"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroup"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev2 = cGgsnMIBComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev2.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB.')
cGgsnMIBComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 4)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev3 = cGgsnMIBComplianceRev3.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev3.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB. This is deprecated by cGgsnMIBComplianceRev4.')
cGgsnMIBComplianceRev4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 5)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupConfigVer"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev4 = cGgsnMIBComplianceRev4.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev4.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB. This is deprecated by cGgsnMIBComplianceRev5.')
cGgsnMIBComplianceRev5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 6)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupConfigVer"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupR60"), ("CISCO-GGSN-MIB", "cGgsnStatisticsGroupR60"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR60"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupR60"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev5 = cGgsnMIBComplianceRev5.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev5.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB. This is deprecated by cGgsnMIBComplianceRev6.')
cGgsnMIBComplianceRev6 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 7)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupConfigVer"), ("CISCO-GGSN-MIB", "cGgsnStatisticsGroupR60"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR60"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupR60Rev1"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev6 = cGgsnMIBComplianceRev6.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev6.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB.')
cGgsnMIBComplianceRev7 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 8)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev3"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev3"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupConfigVer"), ("CISCO-GGSN-MIB", "cGgsnStatisticsGroupR60"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR60"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupR60"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupR60Rev1"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR70"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev7 = cGgsnMIBComplianceRev7.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev7.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB. This is deprecated by cGgsnMIBComplianceRev8.')
cGgsnMIBComplianceRev8 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 9)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev4"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev3"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupConfigVer"), ("CISCO-GGSN-MIB", "cGgsnStatisticsGroupR60"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR60"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupR60"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupR60Rev1"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR70"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev8 = cGgsnMIBComplianceRev8.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev8.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB.This is deprecated by cGgsnMIBComplianceRev9.')
cGgsnMIBComplianceRev9 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 10)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev4"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev3"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupConfigVer"), ("CISCO-GGSN-MIB", "cGgsnStatisticsGroupR60"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR60"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupR60"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupR60Rev1"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR70"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR90"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev9 = cGgsnMIBComplianceRev9.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev9.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB.This is deprecated by cGgsnMIBComplianceRev10.')
cGgsnMIBComplianceRev10 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 1, 11)).setObjects(("CISCO-GGSN-MIB", "cGgsnStatisticsGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnNotifMgmtGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupRev4"), ("CISCO-GGSN-MIB", "cGgsnNotifGroupRev3"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupRev1"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupRev2"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupConfigVer"), ("CISCO-GGSN-MIB", "cGgsnStatisticsGroupR60"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR60"), ("CISCO-GGSN-MIB", "cGgsnNotifInfoGroupR60"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupR60Rev1"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR70"), ("CISCO-GGSN-MIB", "cGgsnStatusGroupR90"), ("CISCO-GGSN-MIB", "cGgsnConfigurationsGroupSup1"), ("CISCO-GGSN-MIB", "cGgsnUmtsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnMIBComplianceRev10 = cGgsnMIBComplianceRev10.setStatus('current')
if mibBuilder.loadTexts: cGgsnMIBComplianceRev10.setDescription('The compliance statements for entities which implement the CISCO GGSN MIB.')
cGgsnStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 1)).setObjects(("CISCO-GGSN-MIB", "cGgsnSentSigMessages"), ("CISCO-GGSN-MIB", "cGgsnReceivedSigMessages"), ("CISCO-GGSN-MIB", "cGgsnUnexpectedSigMessages"), ("CISCO-GGSN-MIB", "cGgsnSentGPDUs"), ("CISCO-GGSN-MIB", "cGgsnReceivedGPDUs"), ("CISCO-GGSN-MIB", "cGgsnSentGPDUOctets"), ("CISCO-GGSN-MIB", "cGgsnReceivedGPDUOctets"), ("CISCO-GGSN-MIB", "cGgsnUnexpectedGPDUs"), ("CISCO-GGSN-MIB", "cGgsnActivationRejectedPdps"), ("CISCO-GGSN-MIB", "cGgsnOutOfResourcePdps"), ("CISCO-GGSN-MIB", "cGgsnParserErrorMessages"), ("CISCO-GGSN-MIB", "cGgsnTotalCreatedPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalDeletedPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalNetworkInitPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalPppPdpsCreated"), ("CISCO-GGSN-MIB", "cGgsnTotalPppPdpsDeleted"), ("CISCO-GGSN-MIB", "cGgsnOutOfResourcePppRegenPdps"), ("CISCO-GGSN-MIB", "cGgsnDroppedPppRegenPdps"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatisticsGroup = cGgsnStatisticsGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnStatisticsGroup.setDescription('A collection of statistics on GGSN.')
cGgsnNotifMgmtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 2)).setObjects(("CISCO-GGSN-MIB", "cGgsnNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnNotifLeastSeverLevel"), ("CISCO-GGSN-MIB", "cGgsnGeneratedNotifs"), ("CISCO-GGSN-MIB", "cGgsnIgnoredAlarms"), ("CISCO-GGSN-MIB", "cGgsnHistNotifMaxLength"), ("CISCO-GGSN-MIB", "cGgsnHistNotifLatestIndex"), ("CISCO-GGSN-MIB", "cGgsnHistNotifType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifSeverity"), ("CISCO-GGSN-MIB", "cGgsnHistNotifTimestamp"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddrType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddr"), ("CISCO-GGSN-MIB", "cGgsnHistNotifInfo"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifMgmtGroup = cGgsnNotifMgmtGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotifMgmtGroup.setDescription('A collection of objects related with notification management on GGSN.')
cGgsnConfigurationsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 3)).setObjects(("CISCO-GGSN-MIB", "cGgsnDefaultIpAllocationMethod"), ("CISCO-GGSN-MIB", "cGgsnIdlePdpPurgeTimer"), ("CISCO-GGSN-MIB", "cGgsnIpDupProtectRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAggregRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAuthServerGroup"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAccServerGroup"), ("CISCO-GGSN-MIB", "cGgsnPppVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPppRegenVirtualTemplate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnConfigurationsGroup = cGgsnConfigurationsGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnConfigurationsGroup.setDescription('A collection of objects related with configurations on GGSN. This is deprecated by cGgsnConfigurationsGroupRev1.')
cGgsnNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 4)).setObjects(("CISCO-GGSN-MIB", "cGgsnNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifGroup = cGgsnNotifGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotifGroup.setDescription('A collection of notifications.')
cGgsnStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 5)).setObjects(("CISCO-GGSN-MIB", "cGgsnVersion"), ("CISCO-GGSN-MIB", "cGgsnActiveNetworkInitPdps"), ("CISCO-GGSN-MIB", "cGgsnActivePppPdps"), ("CISCO-GGSN-MIB", "cGgsnActivePppRegenPdps"), ("CISCO-GGSN-MIB", "cGgsnPendingPppRegenPdps"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatusGroup = cGgsnStatusGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnStatusGroup.setDescription('A collection of objects representing status on GGSN.')
cGgsnConfigurationsGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 6)).setObjects(("CISCO-GGSN-MIB", "cGgsnDefaultIpAllocationMethod"), ("CISCO-GGSN-MIB", "cGgsnIdlePdpPurgeTimer"), ("CISCO-GGSN-MIB", "cGgsnIpDupProtectRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAggregRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAuthServerGroup"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAccServerGroup"), ("CISCO-GGSN-MIB", "cGgsnPppVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPppRegenVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnConfigurationsGroupRev1 = cGgsnConfigurationsGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnConfigurationsGroupRev1.setDescription('A collection of objects related with configurations on GGSN.')
cGgsnUmtsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 7)).setObjects(("CISCO-GGSN-MIB", "cGgsnTftSemanticErrorPdps"), ("CISCO-GGSN-MIB", "cGgsnTftSyntacticErrorPdps"), ("CISCO-GGSN-MIB", "cGgsnPktFilterSemanticErrorPdps"), ("CISCO-GGSN-MIB", "cGgsnPktFilterSyntacticErrorPdps"), ("CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeUsage"), ("CISCO-GGSN-MIB", "cGgsnActiveGtpVersion0Pdps"), ("CISCO-GGSN-MIB", "cGgsnActiveGtpVersion1Pdps"), ("CISCO-GGSN-MIB", "cGgsnGtpEncapInterface"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnUmtsGroup = cGgsnUmtsGroup.setStatus('current')
if mibBuilder.loadTexts: cGgsnUmtsGroup.setDescription('A collection of objects pertaining to GTP v1.')
cGgsnStatisticsGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 8)).setObjects(("CISCO-GGSN-MIB", "cGgsnSentSigMessages"), ("CISCO-GGSN-MIB", "cGgsnReceivedSigMessages"), ("CISCO-GGSN-MIB", "cGgsnUnexpectedSigMessages"), ("CISCO-GGSN-MIB", "cGgsnSentGPDUs"), ("CISCO-GGSN-MIB", "cGgsnReceivedGPDUs"), ("CISCO-GGSN-MIB", "cGgsnUnexpectedGPDUs"), ("CISCO-GGSN-MIB", "cGgsnActivationRejectedPdps"), ("CISCO-GGSN-MIB", "cGgsnOutOfResourcePdps"), ("CISCO-GGSN-MIB", "cGgsnParserErrorMessages"), ("CISCO-GGSN-MIB", "cGgsnTotalCreatedPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalDeletedPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalNetworkInitPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalPppPdpsCreated"), ("CISCO-GGSN-MIB", "cGgsnTotalPppPdpsDeleted"), ("CISCO-GGSN-MIB", "cGgsnOutOfResourcePppRegenPdps"), ("CISCO-GGSN-MIB", "cGgsnDroppedPppRegenPdps"), ("CISCO-GGSN-MIB", "cGgsnHCSentGPDUOctets"), ("CISCO-GGSN-MIB", "cGgsnHCReceivedGPDUOctets"), ("CISCO-GGSN-MIB", "cGgsnVersionNotSupportedRejPdps"), ("CISCO-GGSN-MIB", "cGgsnUnkownMessageRejPdps"), ("CISCO-GGSN-MIB", "cGgsnMsgTooShortRejPdps"), ("CISCO-GGSN-MIB", "cGgsnMandIeMissingRejPdps"), ("CISCO-GGSN-MIB", "cGgsnMandIeIncorrectRejPdps"), ("CISCO-GGSN-MIB", "cGgsnOptIeInvalidRejPdps"), ("CISCO-GGSN-MIB", "cGgsnIeUnknownRejPdps"), ("CISCO-GGSN-MIB", "cGgsnIeOutOfOrderRejPdps"), ("CISCO-GGSN-MIB", "cGgsnIeUnexpectedRejPdps"), ("CISCO-GGSN-MIB", "cGgsnIeDuplicatedRejPdps"), ("CISCO-GGSN-MIB", "cGgsnOptIeIncorrectRejPdps"), ("CISCO-GGSN-MIB", "cGgsnPdpWithoutTftExistsRejPdps"), ("CISCO-GGSN-MIB", "cGgsnSgsnThruPutLastCollected"), ("CISCO-GGSN-MIB", "cGgsnSgsnUpStreamPktCnt"), ("CISCO-GGSN-MIB", "cGgsnSgsnUpStreamByteCnt"), ("CISCO-GGSN-MIB", "cGgsnSgsnDownStreamPktCnt"), ("CISCO-GGSN-MIB", "cGgsnSgsnDownStreamByteCnt"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatisticsGroupRev1 = cGgsnStatisticsGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnStatisticsGroupRev1.setDescription('A collection of statistics on GGSN. This group is deprecated by cGgsnStatisticsGroupRev2.')
cGgsnNotifGroupRev1 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 9)).setObjects(("CISCO-GGSN-MIB", "cGgsnNotification"), ("CISCO-GGSN-MIB", "cGgsnInServiceNotif"), ("CISCO-GGSN-MIB", "cGgsnMaintenanceNotif"), ("CISCO-GGSN-MIB", "cGgsnMemThresholdReachedNotif"), ("CISCO-GGSN-MIB", "cGgsnMemThresholdClearedNotif"), ("CISCO-GGSN-MIB", "cGgsnPdfStateUpNotif"), ("CISCO-GGSN-MIB", "cGgsnPdfStateDownNotif"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifGroupRev1 = cGgsnNotifGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotifGroupRev1.setDescription('A collection of notifications.')
cGgsnConfigurationsGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 10)).setObjects(("CISCO-GGSN-MIB", "cGgsnDefaultIpAllocationMethod"), ("CISCO-GGSN-MIB", "cGgsnIdlePdpPurgeTimer"), ("CISCO-GGSN-MIB", "cGgsnIpDupProtectRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAggregRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAuthServerGroup"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAccServerGroup"), ("CISCO-GGSN-MIB", "cGgsnPppVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPppRegenVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeRowStatus"), ("CISCO-GGSN-MIB", "cGgsnPdfRowStatus"), ("CISCO-GGSN-MIB", "cGgsnPdfReconnectTimeOut"), ("CISCO-GGSN-MIB", "cGgsnPdfReconnectRetries"), ("CISCO-GGSN-MIB", "cGgsnPdfReconExpPdpDelete"), ("CISCO-GGSN-MIB", "cGgsnPdfReqRetryTimeOut"), ("CISCO-GGSN-MIB", "cGgsnPdfReqRetries"), ("CISCO-GGSN-MIB", "cGgsnPcscfRowStatus"), ("CISCO-GGSN-MIB", "cGgsnMemoryThreshold"), ("CISCO-GGSN-MIB", "cGgsnServiceMode"), ("CISCO-GGSN-MIB", "cGgsnPlmnRowStatus"), ("CISCO-GGSN-MIB", "cGgsnPlmnScope"), ("CISCO-GGSN-MIB", "cGgsnSessionTimeout"), ("CISCO-GGSN-MIB", "cGgsnThruputIntervalOne"), ("CISCO-GGSN-MIB", "cGgsnThruputIntervalTwo"), ("CISCO-GGSN-MIB", "cGgsnCompliance3GppGgsn"), ("CISCO-GGSN-MIB", "cGgsnCreateReqV1UpdExistPdp"), ("CISCO-GGSN-MIB", "cGgsnRadAttrSessTimeout"), ("CISCO-GGSN-MIB", "cGgsnDownlinkVerifyMsDisable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnConfigurationsGroupRev2 = cGgsnConfigurationsGroupRev2.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnConfigurationsGroupRev2.setDescription('A collection of objects related with configurations on GGSN. This object group is superceded by cGgsnConfigurationsGroupRev3.')
cGgsnStatusGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 11)).setObjects(("CISCO-GGSN-MIB", "cGgsnVersion"), ("CISCO-GGSN-MIB", "cGgsnActiveNetworkInitPdps"), ("CISCO-GGSN-MIB", "cGgsnActivePppPdps"), ("CISCO-GGSN-MIB", "cGgsnActivePppRegenPdps"), ("CISCO-GGSN-MIB", "cGgsnPendingPppRegenPdps"), ("CISCO-GGSN-MIB", "cGgsnServiceModeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatusGroupRev1 = cGgsnStatusGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cGgsnStatusGroupRev1.setDescription('A collection of objects representing status on GGSN.')
cGgsnNotifInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 12)).setObjects(("CISCO-GGSN-MIB", "cGgsnPdfServerAddrType"), ("CISCO-GGSN-MIB", "cGgsnPdfServerAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifInfoGroup = cGgsnNotifInfoGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotifInfoGroup.setDescription('A collection of objects representing Notif Info on GGSN.')
cGgsnNotifGroupRev2 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 13)).setObjects(("CISCO-GGSN-MIB", "cGgsnInServiceNotif"), ("CISCO-GGSN-MIB", "cGgsnMaintenanceNotif"), ("CISCO-GGSN-MIB", "cGgsnMemThresholdReachedNotif"), ("CISCO-GGSN-MIB", "cGgsnMemThresholdClearedNotif"), ("CISCO-GGSN-MIB", "cGgsnPdfStateUpNotif"), ("CISCO-GGSN-MIB", "cGgsnPdfStateDownNotif"), ("CISCO-GGSN-MIB", "cGgsnGlobalErrorNotif"), ("CISCO-GGSN-MIB", "cGgsnAccessPointNameNotif"), ("CISCO-GGSN-MIB", "cGgsnPacketDataProtocolNotif"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifGroupRev2 = cGgsnNotifGroupRev2.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotifGroupRev2.setDescription('A collection of notifications. This object group is superceded by cGgsnNotifGroupRev3.')
cGgsnNotifInfoGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 14)).setObjects(("CISCO-GGSN-MIB", "cGgsnPdfServerAddrType"), ("CISCO-GGSN-MIB", "cGgsnPdfServerAddr"), ("CISCO-GGSN-MIB", "cGgsnNotifAccessPointName"), ("CISCO-GGSN-MIB", "cGgsnNotifPdpImsi"), ("CISCO-GGSN-MIB", "cGgsnGlobalErrorTypes"), ("CISCO-GGSN-MIB", "cGgsnAccessPointErrorTypes"), ("CISCO-GGSN-MIB", "cGgsnPacketDataProtoErrorTypes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifInfoGroupRev1 = cGgsnNotifInfoGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotifInfoGroupRev1.setDescription('A collection of objects representing Notif Info on GGSN. This object group is superceded by cGgsnNotifInfoGroupRev2.')
cGgsnNotifMgmtGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 15)).setObjects(("CISCO-GGSN-MIB", "cGgsnNotifLeastSeverLevel"), ("CISCO-GGSN-MIB", "cGgsnGeneratedNotifs"), ("CISCO-GGSN-MIB", "cGgsnIgnoredAlarms"), ("CISCO-GGSN-MIB", "cGgsnHistNotifMaxLength"), ("CISCO-GGSN-MIB", "cGgsnHistNotifLatestIndex"), ("CISCO-GGSN-MIB", "cGgsnHistNotifType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifSeverity"), ("CISCO-GGSN-MIB", "cGgsnHistNotifTimestamp"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddrType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddr"), ("CISCO-GGSN-MIB", "cGgsnHistNotifInfo"), ("CISCO-GGSN-MIB", "cGgsnServiceNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnMemoryNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnPdfNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnGlobalErrorNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnAccessPointNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnPdpNotifEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifMgmtGroupRev1 = cGgsnNotifMgmtGroupRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnNotifMgmtGroupRev1.setDescription('A collection of objects related with notification management on GGSN. This object group is superceded by cGgsnNotifMgmtGroupRev2.')
cGgsnStatusGroupConfigVer = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 16)).setObjects(("CISCO-GGSN-MIB", "cGgsnConfigVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatusGroupConfigVer = cGgsnStatusGroupConfigVer.setStatus('current')
if mibBuilder.loadTexts: cGgsnStatusGroupConfigVer.setDescription('A collection of objects representing config version of GGSN.')
cGgsnConfigurationsGroupR60 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 17)).setObjects(("CISCO-GGSN-MIB", "cGgsnSlbMode"), ("CISCO-GGSN-MIB", "cGgsnSlbNotif"), ("CISCO-GGSN-MIB", "cGgsnSlbVserRowStatus"), ("CISCO-GGSN-MIB", "cGgsnSlbVserNextHopAddrType"), ("CISCO-GGSN-MIB", "cGgsnSlbVserNextHopAddress"), ("CISCO-GGSN-MIB", "cGgsnSlbVserVrfName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnConfigurationsGroupR60 = cGgsnConfigurationsGroupR60.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnConfigurationsGroupR60.setDescription('A collection of objects representing configurations on GGSN. This group is deprecated by cGgsnConfigurationsGroupR60Rev1.')
cGgsnStatisticsGroupR60 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 18)).setObjects(("CISCO-GGSN-MIB", "cGgsnTotalMessages"), ("CISCO-GGSN-MIB", "cGgsnContextSetupMessages"), ("CISCO-GGSN-MIB", "cGgsnContextModifyMessages"), ("CISCO-GGSN-MIB", "cGgsnContextRemoveMessages"), ("CISCO-GGSN-MIB", "cGgsnPathSetupMessages"), ("CISCO-GGSN-MIB", "cGgsnPathModifyMessages"), ("CISCO-GGSN-MIB", "cGgsnPathRemoveMessages"), ("CISCO-GGSN-MIB", "cGgsnCGFReadyMessages"), ("CISCO-GGSN-MIB", "cGgsnCGFModifyMessages"), ("CISCO-GGSN-MIB", "cGgsnCGFRemoveMessages"), ("CISCO-GGSN-MIB", "cGgsnInternalStateMsgs"), ("CISCO-GGSN-MIB", "cGgsnSlbCacFailures"), ("CISCO-GGSN-MIB", "cGgsnSlbSessionFailures"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatisticsGroupR60 = cGgsnStatisticsGroupR60.setStatus('current')
if mibBuilder.loadTexts: cGgsnStatisticsGroupR60.setDescription('A collection of objects related with statistics.')
cGgsnStatusGroupR60 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 19)).setObjects(("CISCO-GGSN-MIB", "cGgsnPrepaidPDPs"), ("CISCO-GGSN-MIB", "cGgsnPostpaidPDPs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatusGroupR60 = cGgsnStatusGroupR60.setStatus('current')
if mibBuilder.loadTexts: cGgsnStatusGroupR60.setDescription('A collection of objects related to gtp status.')
cGgsnNotifInfoGroupR60 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 20)).setObjects(("CISCO-GGSN-MIB", "cGgsnNotifPdpMsisdn"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifInfoGroupR60 = cGgsnNotifInfoGroupR60.setStatus('current')
if mibBuilder.loadTexts: cGgsnNotifInfoGroupR60.setDescription('A collection of objects representing the Notif info on GGSN.')
cGgsnConfigurationsGroupR60Rev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 21)).setObjects(("CISCO-GGSN-MIB", "cGgsnSlbMode"), ("CISCO-GGSN-MIB", "cGgsnSlbVserRowStatus"), ("CISCO-GGSN-MIB", "cGgsnSlbVserNextHopAddrType"), ("CISCO-GGSN-MIB", "cGgsnSlbVserNextHopAddress"), ("CISCO-GGSN-MIB", "cGgsnSlbVserVrfName"), ("CISCO-GGSN-MIB", "cGgsnSlbNotifyCacFailure"), ("CISCO-GGSN-MIB", "cGgsnSlbNotifySessionDeletion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnConfigurationsGroupR60Rev1 = cGgsnConfigurationsGroupR60Rev1.setStatus('current')
if mibBuilder.loadTexts: cGgsnConfigurationsGroupR60Rev1.setDescription('A collection of objects representing configurations on GGSN.')
cGgsnStatisticsGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 22)).setObjects(("CISCO-GGSN-MIB", "cGgsnSentSigMessages"), ("CISCO-GGSN-MIB", "cGgsnReceivedSigMessages"), ("CISCO-GGSN-MIB", "cGgsnUnexpectedSigMessages"), ("CISCO-GGSN-MIB", "cGgsnSentGPDUs"), ("CISCO-GGSN-MIB", "cGgsnReceivedGPDUs"), ("CISCO-GGSN-MIB", "cGgsnUnexpectedGPDUs"), ("CISCO-GGSN-MIB", "cGgsnActivationRejectedPdps"), ("CISCO-GGSN-MIB", "cGgsnOutOfResourcePdps"), ("CISCO-GGSN-MIB", "cGgsnParserErrorMessages"), ("CISCO-GGSN-MIB", "cGgsnTotalCreatedPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalDeletedPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalNetworkInitPdps"), ("CISCO-GGSN-MIB", "cGgsnTotalPppPdpsCreated"), ("CISCO-GGSN-MIB", "cGgsnTotalPppPdpsDeleted"), ("CISCO-GGSN-MIB", "cGgsnOutOfResourcePppRegenPdps"), ("CISCO-GGSN-MIB", "cGgsnDroppedPppRegenPdps"), ("CISCO-GGSN-MIB", "cGgsnHCSentGPDUOctets"), ("CISCO-GGSN-MIB", "cGgsnHCReceivedGPDUOctets"), ("CISCO-GGSN-MIB", "cGgsnSgsnThruPutLastCollected"), ("CISCO-GGSN-MIB", "cGgsnSgsnUpStreamPktCnt"), ("CISCO-GGSN-MIB", "cGgsnSgsnUpStreamByteCnt"), ("CISCO-GGSN-MIB", "cGgsnSgsnDownStreamPktCnt"), ("CISCO-GGSN-MIB", "cGgsnSgsnDownStreamByteCnt"), ("CISCO-GGSN-MIB", "cGgsnTotalCreatedIpv6Pdps"), ("CISCO-GGSN-MIB", "cGgsnTotalDeletedIpv6Pdps"), ("CISCO-GGSN-MIB", "cGgsnTotalRejectedIpv6Pdps"), ("CISCO-GGSN-MIB", "cGgsnSentIpv6SigMessages"), ("CISCO-GGSN-MIB", "cGgsnReceivedIpv6SigMessages"), ("CISCO-GGSN-MIB", "cGgsnSentIpv6PDUs"), ("CISCO-GGSN-MIB", "cGgsnReceivedIpv6PDUs"), ("CISCO-GGSN-MIB", "cGgsnSentIpv6PDUOctets"), ("CISCO-GGSN-MIB", "cGgsnReceivedIpv6PDUOctets"), ("CISCO-GGSN-MIB", "cGgsnVersionNotSupportedMsgs"), ("CISCO-GGSN-MIB", "cGgsnUnkownGtpMsgs"), ("CISCO-GGSN-MIB", "cGgsnTooShortMsgs"), ("CISCO-GGSN-MIB", "cGgsnMandIeMissingMsgs"), ("CISCO-GGSN-MIB", "cGgsnMandIeIncorrectMsgs"), ("CISCO-GGSN-MIB", "cGgsnOptIeInvalidMsgs"), ("CISCO-GGSN-MIB", "cGgsnIeUnknownMsgs"), ("CISCO-GGSN-MIB", "cGgsnIeOutOfOrderMsgs"), ("CISCO-GGSN-MIB", "cGgsnIeUnexpectedMsgs"), ("CISCO-GGSN-MIB", "cGgsnIeDuplicatedMsgs"), ("CISCO-GGSN-MIB", "cGgsnOptIeIncorrectMsgs"), ("CISCO-GGSN-MIB", "cGgsnPdpWithoutTftExistsPdps"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatisticsGroupRev2 = cGgsnStatisticsGroupRev2.setStatus('current')
if mibBuilder.loadTexts: cGgsnStatisticsGroupRev2.setDescription('A collection of objects related with statistics.')
cGgsnStatusGroupR70 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 23)).setObjects(("CISCO-GGSN-MIB", "cGgsnActivatedIpv6Gtpv0Pdp"), ("CISCO-GGSN-MIB", "cGgsnActivatedIpv6Gtpv1Pdp"), ("CISCO-GGSN-MIB", "cGgsnActivatedIpv6Ms"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatusGroupR70 = cGgsnStatusGroupR70.setStatus('current')
if mibBuilder.loadTexts: cGgsnStatusGroupR70.setDescription('A collection of objects related with status.')
cGgsnConfigurationsGroupRev3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 24)).setObjects(("CISCO-GGSN-MIB", "cGgsnDefaultIpAllocationMethod"), ("CISCO-GGSN-MIB", "cGgsnIdlePdpPurgeTimer"), ("CISCO-GGSN-MIB", "cGgsnIpDupProtectRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAggregRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAuthServerGroup"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAccServerGroup"), ("CISCO-GGSN-MIB", "cGgsnPppVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPppRegenVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeRowStatus"), ("CISCO-GGSN-MIB", "cGgsnPcscfRowStatus"), ("CISCO-GGSN-MIB", "cGgsnMemoryThreshold"), ("CISCO-GGSN-MIB", "cGgsnServiceMode"), ("CISCO-GGSN-MIB", "cGgsnPlmnRowStatus"), ("CISCO-GGSN-MIB", "cGgsnPlmnScope"), ("CISCO-GGSN-MIB", "cGgsnSessionTimeout"), ("CISCO-GGSN-MIB", "cGgsnThruputIntervalOne"), ("CISCO-GGSN-MIB", "cGgsnThruputIntervalTwo"), ("CISCO-GGSN-MIB", "cGgsnCompliance3GppGgsn"), ("CISCO-GGSN-MIB", "cGgsnRadAttrSessTimeout"), ("CISCO-GGSN-MIB", "cGgsnDownlinkVerifyMsDisable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnConfigurationsGroupRev3 = cGgsnConfigurationsGroupRev3.setStatus('deprecated')
if mibBuilder.loadTexts: cGgsnConfigurationsGroupRev3.setDescription('A collection of objects related with configurations on GGSN. This is deprecated by cGgsnConfigurationsGroupRev4.')
cGgsnNotifMgmtGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 25)).setObjects(("CISCO-GGSN-MIB", "cGgsnNotifLeastSeverLevel"), ("CISCO-GGSN-MIB", "cGgsnGeneratedNotifs"), ("CISCO-GGSN-MIB", "cGgsnIgnoredAlarms"), ("CISCO-GGSN-MIB", "cGgsnHistNotifMaxLength"), ("CISCO-GGSN-MIB", "cGgsnHistNotifLatestIndex"), ("CISCO-GGSN-MIB", "cGgsnHistNotifType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifSeverity"), ("CISCO-GGSN-MIB", "cGgsnHistNotifTimestamp"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddrType"), ("CISCO-GGSN-MIB", "cGgsnHistNotifGgsnIpAddr"), ("CISCO-GGSN-MIB", "cGgsnHistNotifInfo"), ("CISCO-GGSN-MIB", "cGgsnServiceNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnMemoryNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnGlobalErrorNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnAccessPointNotifEnabled"), ("CISCO-GGSN-MIB", "cGgsnPdpNotifEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifMgmtGroupRev2 = cGgsnNotifMgmtGroupRev2.setStatus('current')
if mibBuilder.loadTexts: cGgsnNotifMgmtGroupRev2.setDescription('A collection of objects related with notification management on GGSN.')
cGgsnNotifGroupRev3 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 26)).setObjects(("CISCO-GGSN-MIB", "cGgsnInServiceNotif"), ("CISCO-GGSN-MIB", "cGgsnMaintenanceNotif"), ("CISCO-GGSN-MIB", "cGgsnMemThresholdReachedNotif"), ("CISCO-GGSN-MIB", "cGgsnMemThresholdClearedNotif"), ("CISCO-GGSN-MIB", "cGgsnGlobalErrorNotif"), ("CISCO-GGSN-MIB", "cGgsnAccessPointNameNotif"), ("CISCO-GGSN-MIB", "cGgsnPacketDataProtocolNotif"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifGroupRev3 = cGgsnNotifGroupRev3.setStatus('current')
if mibBuilder.loadTexts: cGgsnNotifGroupRev3.setDescription('A collection of notifications.')
cGgsnNotifInfoGroupRev2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 27)).setObjects(("CISCO-GGSN-MIB", "cGgsnNotifAccessPointName"), ("CISCO-GGSN-MIB", "cGgsnNotifPdpImsi"), ("CISCO-GGSN-MIB", "cGgsnGlobalErrorTypes"), ("CISCO-GGSN-MIB", "cGgsnAccessPointErrorTypes"), ("CISCO-GGSN-MIB", "cGgsnPacketDataProtoErrorTypes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnNotifInfoGroupRev2 = cGgsnNotifInfoGroupRev2.setStatus('current')
if mibBuilder.loadTexts: cGgsnNotifInfoGroupRev2.setDescription('A collection of objects representing Notif Info on GGSN.')
cGgsnConfigurationsGroupRev4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 28)).setObjects(("CISCO-GGSN-MIB", "cGgsnDefaultIpAllocationMethod"), ("CISCO-GGSN-MIB", "cGgsnIdlePdpPurgeTimer"), ("CISCO-GGSN-MIB", "cGgsnIpDupProtectRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAggregRowStatus"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAuthServerGroup"), ("CISCO-GGSN-MIB", "cGgsnDefaultAaaAccServerGroup"), ("CISCO-GGSN-MIB", "cGgsnPppVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPppRegenVirtualTemplate"), ("CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeRowStatus"), ("CISCO-GGSN-MIB", "cGgsnPcscfRowStatus"), ("CISCO-GGSN-MIB", "cGgsnMemoryThreshold"), ("CISCO-GGSN-MIB", "cGgsnServiceMode"), ("CISCO-GGSN-MIB", "cGgsnPlmnRowStatus"), ("CISCO-GGSN-MIB", "cGgsnPlmnScope"), ("CISCO-GGSN-MIB", "cGgsnSessionTimeout"), ("CISCO-GGSN-MIB", "cGgsnThruputIntervalOne"), ("CISCO-GGSN-MIB", "cGgsnThruputIntervalTwo"), ("CISCO-GGSN-MIB", "cGgsnRadAttrSessTimeout"), ("CISCO-GGSN-MIB", "cGgsnDownlinkVerifyMsDisable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnConfigurationsGroupRev4 = cGgsnConfigurationsGroupRev4.setStatus('current')
if mibBuilder.loadTexts: cGgsnConfigurationsGroupRev4.setDescription('A collection of objects related with configurations on GGSN.')
cGgsnStatusGroupR90 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 29)).setObjects(("CISCO-GGSN-MIB", "cGgsnGtpEncapsuInterface"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnStatusGroupR90 = cGgsnStatusGroupR90.setStatus('current')
if mibBuilder.loadTexts: cGgsnStatusGroupR90.setDescription('A collection of objects which maintains the mapping between CGSN interfaces and gtp encapsulated interfaces.')
cGgsnConfigurationsGroupSup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 240, 3, 2, 30)).setObjects(("CISCO-GGSN-MIB", "cGgsnMsExcludeRangeStartIpv6Prefixlen"), ("CISCO-GGSN-MIB", "cGgsnMsExcludeRangeEndIpv6Prefixlen"), ("CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeFirstIpv6Prefixlen"), ("CISCO-GGSN-MIB", "cGgsnPlmnAddrRangeLastIpv6Prefixlen"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cGgsnConfigurationsGroupSup1 = cGgsnConfigurationsGroupSup1.setStatus('current')
if mibBuilder.loadTexts: cGgsnConfigurationsGroupSup1.setDescription('This group is supplementary to cGgsnConfigurationsGroupRev4.')
mibBuilder.exportSymbols("CISCO-GGSN-MIB", cGgsnHistNotifGgsnIpAddr=cGgsnHistNotifGgsnIpAddr, cGgsnPlmnAddrRangeLastIpv6Prefixlen=cGgsnPlmnAddrRangeLastIpv6Prefixlen, cGgsnPcscfTable=cGgsnPcscfTable, cGgsnHistNotifLatestIndex=cGgsnHistNotifLatestIndex, cGgsnSlbCacFailures=cGgsnSlbCacFailures, cGgsnPlmnAddrRangeRowStatus=cGgsnPlmnAddrRangeRowStatus, cGgsnActiveNetworkInitPdps=cGgsnActiveNetworkInitPdps, cGgsnTotalRejectedIpv6Pdps=cGgsnTotalRejectedIpv6Pdps, cGgsnRedundancyStatistics=cGgsnRedundancyStatistics, cGgsnDefaultIpAllocationMethod=cGgsnDefaultIpAllocationMethod, cGgsnSlbVserverTable=cGgsnSlbVserverTable, cGgsnMIBComplianceRev6=cGgsnMIBComplianceRev6, cGgsnTotalCreatedIpv6Pdps=cGgsnTotalCreatedIpv6Pdps, cGgsnPdfIpAddressType=cGgsnPdfIpAddressType, cGgsnSentIpv6PDUOctets=cGgsnSentIpv6PDUOctets, cGgsnPdfStateDownNotif=cGgsnPdfStateDownNotif, cGgsnMIBCompliance=cGgsnMIBCompliance, cGgsnOutOfResourcePdps=cGgsnOutOfResourcePdps, cGgsnPdfDomainName=cGgsnPdfDomainName, cGgsnOptIeInvalidMsgs=cGgsnOptIeInvalidMsgs, cGgsnMsExcludeRangeStartIpv6Prefixlen=cGgsnMsExcludeRangeStartIpv6Prefixlen, cGgsnSlbVserAddrType=cGgsnSlbVserAddrType, cGgsnMsgTooShortRejPdps=cGgsnMsgTooShortRejPdps, cGgsnNotifications=cGgsnNotifications, cGgsnSlbVserAddress=cGgsnSlbVserAddress, cGgsnStatusGroup=cGgsnStatusGroup, cGgsnDefaultAggregTable=cGgsnDefaultAggregTable, cGgsnActivatedIpv6Ms=cGgsnActivatedIpv6Ms, cGgsnPdpWithoutTftExistsRejPdps=cGgsnPdpWithoutTftExistsRejPdps, cGgsnTooShortMsgs=cGgsnTooShortMsgs, cGgsnMsExcludeRangeEndIpType=cGgsnMsExcludeRangeEndIpType, cGgsnSentGPDUOctets=cGgsnSentGPDUOctets, cGgsnSentSigMessages=cGgsnSentSigMessages, cGgsnSlbNotifySessionDeletion=cGgsnSlbNotifySessionDeletion, cGgsnStatisticsGroupRev1=cGgsnStatisticsGroupRev1, cGgsnHistNotifGgsnIpAddrType=cGgsnHistNotifGgsnIpAddrType, cGgsnTotalPppPdpsCreated=cGgsnTotalPppPdpsCreated, cGgsnOptIeIncorrectRejPdps=cGgsnOptIeIncorrectRejPdps, cGgsnInternalStateMsgs=cGgsnInternalStateMsgs, cGgsnMandIeIncorrectMsgs=cGgsnMandIeIncorrectMsgs, cGgsnPdpNotifEnabled=cGgsnPdpNotifEnabled, cGgsnPlmnAddrRangeFirstIpv6Prefixlen=cGgsnPlmnAddrRangeFirstIpv6Prefixlen, cGgsnVersion=cGgsnVersion, cGgsnPrepaidPDPs=cGgsnPrepaidPDPs, cGgsnPdfServerAddr=cGgsnPdfServerAddr, cGgsnTftSemanticErrorPdps=cGgsnTftSemanticErrorPdps, cGgsnSentIpv6SigMessages=cGgsnSentIpv6SigMessages, cGgsnHistNotifTimestamp=cGgsnHistNotifTimestamp, cGgsnPathRemoveMessages=cGgsnPathRemoveMessages, cGgsnPdfRowStatus=cGgsnPdfRowStatus, cGgsnAccessPointErrorTypes=cGgsnAccessPointErrorTypes, cGgsnSlbVserRowStatus=cGgsnSlbVserRowStatus, cGgsnNotifInfoGroupRev2=cGgsnNotifInfoGroupRev2, cGgsnUnexpectedSigMessages=cGgsnUnexpectedSigMessages, cGgsnIeDuplicatedMsgs=cGgsnIeDuplicatedMsgs, cGgsnReceivedSigMessages=cGgsnReceivedSigMessages, cGgsnHCSentGPDUOctets=cGgsnHCSentGPDUOctets, cGgsnTftSyntacticErrorPdps=cGgsnTftSyntacticErrorPdps, cGgsnReceivedIpv6PDUOctets=cGgsnReceivedIpv6PDUOctets, cGgsnAccessPointNameNotif=cGgsnAccessPointNameNotif, cGgsnServiceNotifEnabled=cGgsnServiceNotifEnabled, cGgsnPlmnAddrRangeFirstIp=cGgsnPlmnAddrRangeFirstIp, cGgsnDefaultAggregIpAddrType=cGgsnDefaultAggregIpAddrType, cGgsnNotifMgmtGroupRev2=cGgsnNotifMgmtGroupRev2, cGgsnStatistics=cGgsnStatistics, cGgsnCompliance3GppGgsn=cGgsnCompliance3GppGgsn, cGgsnNotifMgmt=cGgsnNotifMgmt, cGgsnNotifInfoGroup=cGgsnNotifInfoGroup, cGgsnGtpEncapInterface=cGgsnGtpEncapInterface, cGgsnPlmnRowStatus=cGgsnPlmnRowStatus, cGgsnPlmnAddrRangeUsage=cGgsnPlmnAddrRangeUsage, cGgsnThruputIntervalOne=cGgsnThruputIntervalOne, cGgsnMandIeIncorrectRejPdps=cGgsnMandIeIncorrectRejPdps, cGgsnTotalPppPdpsDeleted=cGgsnTotalPppPdpsDeleted, cGgsnTotalDeletedPdps=cGgsnTotalDeletedPdps, cGgsnPacketDataProtocolNotif=cGgsnPacketDataProtocolNotif, cGgsnConfigurationsGroupRev2=cGgsnConfigurationsGroupRev2, cGgsnIeDuplicatedRejPdps=cGgsnIeDuplicatedRejPdps, cGgsnReceivedGPDUs=cGgsnReceivedGPDUs, cGgsnPppVirtualTemplate=cGgsnPppVirtualTemplate, cGgsnContextRemoveMessages=cGgsnContextRemoveMessages, cGgsnGtpEncapsuEntry=cGgsnGtpEncapsuEntry, cGgsnGtpEncapsuInterface=cGgsnGtpEncapsuInterface, cGgsnStatusGroupR60=cGgsnStatusGroupR60, cGgsnActivatedIpv6Gtpv1Pdp=cGgsnActivatedIpv6Gtpv1Pdp, cGgsnPcscfIpAddress=cGgsnPcscfIpAddress, cGgsnPlmnScope=cGgsnPlmnScope, cGgsnMIBComplianceRev7=cGgsnMIBComplianceRev7, cGgsnActivePppRegenPdps=cGgsnActivePppRegenPdps, cGgsnNotifGroupRev2=cGgsnNotifGroupRev2, cGgsnNotifGroupRev3=cGgsnNotifGroupRev3, cGgsnVersionNotSupportedRejPdps=cGgsnVersionNotSupportedRejPdps, cGgsnPlmnAddrRangeIpAddrType=cGgsnPlmnAddrRangeIpAddrType, cGgsnHistNotifEntry=cGgsnHistNotifEntry, cGgsnPdfServerAddrType=cGgsnPdfServerAddrType, cGgsnSlbNotif=cGgsnSlbNotif, cGgsnVersionNotSupportedMsgs=cGgsnVersionNotSupportedMsgs, cGgsnPathSetupMessages=cGgsnPathSetupMessages, cGgsnDefaultAggregIpMask=cGgsnDefaultAggregIpMask, cGgsnPostpaidPDPs=cGgsnPostpaidPDPs, cGgsnActiveGtpVersion1Pdps=cGgsnActiveGtpVersion1Pdps, cGgsnIeUnknownRejPdps=cGgsnIeUnknownRejPdps, cGgsnTotalDeletedIpv6Pdps=cGgsnTotalDeletedIpv6Pdps, cGgsnRadAttrSessTimeout=cGgsnRadAttrSessTimeout, cGgsnPdfGroupName=cGgsnPdfGroupName, cGgsnCGFRemoveMessages=cGgsnCGFRemoveMessages, cGgsnMsExcludeRangeStartIpType=cGgsnMsExcludeRangeStartIpType, cGgsnAccessPointNotifEnabled=cGgsnAccessPointNotifEnabled, cGgsnMIBObjects=cGgsnMIBObjects, cGgsnHistNotifInfo=cGgsnHistNotifInfo, cGgsnHistNotifMaxLength=cGgsnHistNotifMaxLength, cGgsnPcscfGroupName=cGgsnPcscfGroupName, cGgsnNotifGroup=cGgsnNotifGroup, cGgsnMIBComplianceRev1=cGgsnMIBComplianceRev1, cGgsnNotifMgmtGroup=cGgsnNotifMgmtGroup, cGgsnNotifInfo=cGgsnNotifInfo, cGgsnNotification=cGgsnNotification, cGgsnPlmnTable=cGgsnPlmnTable, cGgsnNotifGroupRev1=cGgsnNotifGroupRev1, cGgsnNotifMgmtGroupRev1=cGgsnNotifMgmtGroupRev1, cGgsnMsExcludeRangeEndIp=cGgsnMsExcludeRangeEndIp, cGgsnNotifAccessPointName=cGgsnNotifAccessPointName, cGgsnMemThresholdReachedNotif=cGgsnMemThresholdReachedNotif, cGgsnSlbMode=cGgsnSlbMode, cGgsnPcscfEntry=cGgsnPcscfEntry, cGgsnPdfStateUpNotif=cGgsnPdfStateUpNotif, cGgsnStatusGroupR90=cGgsnStatusGroupR90, cGgsnMandIeMissingRejPdps=cGgsnMandIeMissingRejPdps, cGgsnPdfTable=cGgsnPdfTable, cGgsnPlmnEntry=cGgsnPlmnEntry, cGgsnOptIeIncorrectMsgs=cGgsnOptIeIncorrectMsgs, cGgsnPendingPppRegenPdps=cGgsnPendingPppRegenPdps, cGgsnNotifPdpImsi=cGgsnNotifPdpImsi, cGgsnPacketDataProtoErrorTypes=cGgsnPacketDataProtoErrorTypes, cGgsnParserErrorMessages=cGgsnParserErrorMessages, cGgsnPktFilterSemanticErrorPdps=cGgsnPktFilterSemanticErrorPdps, cGgsnSentIpv6PDUs=cGgsnSentIpv6PDUs, cGgsnUnexpectedGPDUs=cGgsnUnexpectedGPDUs, cGgsnConfigurations=cGgsnConfigurations, cGgsnPlmnMnc=cGgsnPlmnMnc, cGgsnGtpEncapsuTable=cGgsnGtpEncapsuTable, cGgsnPdfEntry=cGgsnPdfEntry, cGgsnMandIeMissingMsgs=cGgsnMandIeMissingMsgs, cGgsnGlobalErrorNotifEnabled=cGgsnGlobalErrorNotifEnabled, cGgsnIpDupProtectTable=cGgsnIpDupProtectTable, cGgsnIpDupProtectEntry=cGgsnIpDupProtectEntry, cGgsnMsExcludeRangeStartIp=cGgsnMsExcludeRangeStartIp, cGgsnPlmnIpAddrRangeTable=cGgsnPlmnIpAddrRangeTable, cGgsnContextModifyMessages=cGgsnContextModifyMessages, cGgsnPlmnMcc=cGgsnPlmnMcc, cGgsnActivePppPdps=cGgsnActivePppPdps, cGgsnStatisticsGroup=cGgsnStatisticsGroup, cGgsnConfigurationsGroup=cGgsnConfigurationsGroup, cGgsnTotalNetworkInitPdps=cGgsnTotalNetworkInitPdps, cGgsnSlbVserverEntry=cGgsnSlbVserverEntry, cGgsnNotifPrefix=cGgsnNotifPrefix, cGgsnMaintenanceNotif=cGgsnMaintenanceNotif, cGgsnStatusGroupRev1=cGgsnStatusGroupRev1, cGgsnInServiceNotif=cGgsnInServiceNotif, cGgsnStatisticsGroupR60=cGgsnStatisticsGroupR60, cGgsnCGFReadyMessages=cGgsnCGFReadyMessages, cGgsnStatusGroupR70=cGgsnStatusGroupR70, cGgsnSlbSessionFailures=cGgsnSlbSessionFailures, cGgsnReceivedIpv6PDUs=cGgsnReceivedIpv6PDUs, cGgsnIgnoredAlarms=cGgsnIgnoredAlarms, cGgsnServiceModeStatus=cGgsnServiceModeStatus, cGgsnMIBComplianceRev8=cGgsnMIBComplianceRev8, cGgsnDefaultAggregRowStatus=cGgsnDefaultAggregRowStatus, cGgsnSgsnDownStreamByteCnt=cGgsnSgsnDownStreamByteCnt, cGgsnMemoryThreshold=cGgsnMemoryThreshold, cGgsnMIBComplianceRev3=cGgsnMIBComplianceRev3, cGgsnActivationRejectedPdps=cGgsnActivationRejectedPdps, cGgsnMIB=cGgsnMIB, cGgsnOptIeInvalidRejPdps=cGgsnOptIeInvalidRejPdps, cGgsnContextSetupMessages=cGgsnContextSetupMessages, cGgsnThruputIntervalTwo=cGgsnThruputIntervalTwo, cGgsnMIBComplianceRev9=cGgsnMIBComplianceRev9, cGgsnStatus=cGgsnStatus, cGgsnHCReceivedGPDUOctets=cGgsnHCReceivedGPDUOctets, cGgsnMIBComplianceRev4=cGgsnMIBComplianceRev4, cGgsnActiveGtpVersion0Pdps=cGgsnActiveGtpVersion0Pdps, cGgsnConfigVersion=cGgsnConfigVersion, cGgsnSentGPDUs=cGgsnSentGPDUs, cGgsnIeUnexpectedRejPdps=cGgsnIeUnexpectedRejPdps, cGgsnTotalMessages=cGgsnTotalMessages, cGgsnReceivedIpv6SigMessages=cGgsnReceivedIpv6SigMessages, cGgsnHistNotifSeverity=cGgsnHistNotifSeverity, cGgsnPlmnAddrRangeLastIp=cGgsnPlmnAddrRangeLastIp, cGgsnImsConfigurations=cGgsnImsConfigurations, cGgsnMIBGroups=cGgsnMIBGroups, cGgsnConfigurationsGroupR60=cGgsnConfigurationsGroupR60, cGgsnIdlePdpPurgeTimer=cGgsnIdlePdpPurgeTimer, cGgsnCreateReqV1UpdExistPdp=cGgsnCreateReqV1UpdExistPdp, cGgsnMsExcludeRangeEndIpv6Prefixlen=cGgsnMsExcludeRangeEndIpv6Prefixlen, cGgsnDefaultAaaAccServerGroup=cGgsnDefaultAaaAccServerGroup, cGgsnPdfReconExpPdpDelete=cGgsnPdfReconExpPdpDelete, cGgsnHistNotifTable=cGgsnHistNotifTable, cGgsnPdfIpAddress=cGgsnPdfIpAddress, cGgsnSgsnUpStreamByteCnt=cGgsnSgsnUpStreamByteCnt, cGgsnSgsnDownStreamPktCnt=cGgsnSgsnDownStreamPktCnt, cGgsnPdfReconnectTimeOut=cGgsnPdfReconnectTimeOut, cGgsnIeUnexpectedMsgs=cGgsnIeUnexpectedMsgs, cGgsnSlbNotifyCacFailure=cGgsnSlbNotifyCacFailure, cGgsnDownlinkVerifyMsDisable=cGgsnDownlinkVerifyMsDisable, cGgsnPcscfRowStatus=cGgsnPcscfRowStatus, cGgsnPdpsRejStatistics=cGgsnPdpsRejStatistics, cGgsnMemThresholdClearedNotif=cGgsnMemThresholdClearedNotif, cGgsnMIBComplianceRev5=cGgsnMIBComplianceRev5, cGgsnHistNotifType=cGgsnHistNotifType, cGgsnConfigurationsGroupRev3=cGgsnConfigurationsGroupRev3, cGgsnNotifPdpMsisdn=cGgsnNotifPdpMsisdn, cGgsnTotalCreatedPdps=cGgsnTotalCreatedPdps, cGgsnPktFilterSyntacticErrorPdps=cGgsnPktFilterSyntacticErrorPdps, cGgsnGlobalErrorTypes=cGgsnGlobalErrorTypes, cGgsnIeOutOfOrderRejPdps=cGgsnIeOutOfOrderRejPdps, cGgsnMIBCompliances=cGgsnMIBCompliances, cGgsnSessionTimeout=cGgsnSessionTimeout, cGgsnStatusGroupConfigVer=cGgsnStatusGroupConfigVer, cGgsnDroppedPppRegenPdps=cGgsnDroppedPppRegenPdps, cGgsnUnkownMessageRejPdps=cGgsnUnkownMessageRejPdps, cGgsnIeUnknownMsgs=cGgsnIeUnknownMsgs, PYSNMP_MODULE_ID=cGgsnMIB, cGgsnConfigurationsGroupRev1=cGgsnConfigurationsGroupRev1, cGgsnGlobalErrorNotif=cGgsnGlobalErrorNotif, cGgsnMIBComplianceRev10=cGgsnMIBComplianceRev10, cGgsnIeOutOfOrderMsgs=cGgsnIeOutOfOrderMsgs, cGgsnDefaultAaaAuthServerGroup=cGgsnDefaultAaaAuthServerGroup, cGgsnPdfReqRetries=cGgsnPdfReqRetries, cGgsnReceivedGPDUOctets=cGgsnReceivedGPDUOctets, cGgsnSgsnStatEntry=cGgsnSgsnStatEntry, cGgsnSgsnThruPutInterval=cGgsnSgsnThruPutInterval, cGgsnPdfReconnectRetries=cGgsnPdfReconnectRetries, cGgsnConfigurationsGroupRev4=cGgsnConfigurationsGroupRev4, cGgsnSlbVserNextHopAddress=cGgsnSlbVserNextHopAddress, cGgsnMIBComplianceRev2=cGgsnMIBComplianceRev2, cGgsnHistNotifIndex=cGgsnHistNotifIndex, cGgsnMemoryNotifEnabled=cGgsnMemoryNotifEnabled, cGgsnPdpWithoutTftExistsPdps=cGgsnPdpWithoutTftExistsPdps, cGgsnPdfNotifEnabled=cGgsnPdfNotifEnabled, cGgsnUmtsGroup=cGgsnUmtsGroup, cGgsnStatisticsGroupRev2=cGgsnStatisticsGroupRev2, cGgsnIpDupProtectRowStatus=cGgsnIpDupProtectRowStatus, cGgsnPppRegenVirtualTemplate=cGgsnPppRegenVirtualTemplate, cGgsnNotifEnabled=cGgsnNotifEnabled, cGgsnPcscfIpAddressType=cGgsnPcscfIpAddressType, cGgsnNotifInfoGroupR60=cGgsnNotifInfoGroupR60, cGgsnConfigurationsGroupSup1=cGgsnConfigurationsGroupSup1, cGgsnSlbVserVrfName=cGgsnSlbVserVrfName, cGgsnConfigurationsGroupR60Rev1=cGgsnConfigurationsGroupR60Rev1, cGgsnServiceMode=cGgsnServiceMode, cGgsnSgsnThruPutLastCollected=cGgsnSgsnThruPutLastCollected, cGgsnSgsnStatTable=cGgsnSgsnStatTable, cGgsnCGFModifyMessages=cGgsnCGFModifyMessages, cGgsnMIBConformances=cGgsnMIBConformances)
mibBuilder.exportSymbols("CISCO-GGSN-MIB", cGgsnOutOfResourcePppRegenPdps=cGgsnOutOfResourcePppRegenPdps, cGgsnActivatedIpv6Gtpv0Pdp=cGgsnActivatedIpv6Gtpv0Pdp, cGgsnNotifInfoGroupRev1=cGgsnNotifInfoGroupRev1, cGgsnPdfReqRetryTimeOut=cGgsnPdfReqRetryTimeOut, cGgsnNotifLeastSeverLevel=cGgsnNotifLeastSeverLevel, cGgsnDefaultAggregIpAddr=cGgsnDefaultAggregIpAddr, cGgsnDefaultAggregEntry=cGgsnDefaultAggregEntry, cGgsnSgsnUpStreamPktCnt=cGgsnSgsnUpStreamPktCnt, cGgsnSlbVserNextHopAddrType=cGgsnSlbVserNextHopAddrType, cGgsnGeneratedNotifs=cGgsnGeneratedNotifs, cGgsnPlmnIpAddrRangeEntry=cGgsnPlmnIpAddrRangeEntry, cGgsnPathModifyMessages=cGgsnPathModifyMessages, cGgsnUnkownGtpMsgs=cGgsnUnkownGtpMsgs)

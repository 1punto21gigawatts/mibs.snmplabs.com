#
# PySNMP MIB module BROCADE-ROUTEMAP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BROCADE-ROUTEMAP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:41:16 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint")
Action, AclNumber = mibBuilder.importSymbols("FOUNDRY-SN-IP-ACL-MIB", "Action", "AclNumber")
brcdRouteMap, FdryVlanIdOrNoneTC = mibBuilder.importSymbols("FOUNDRY-SN-SWITCH-GROUP-MIB", "brcdRouteMap", "FdryVlanIdOrNoneTC")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, iso, MibIdentifier, ObjectIdentity, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, NotificationType, Bits, Counter32, Unsigned32, Integer32, ModuleIdentity, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "iso", "MibIdentifier", "ObjectIdentity", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "NotificationType", "Bits", "Counter32", "Unsigned32", "Integer32", "ModuleIdentity", "Counter64")
MacAddress, DisplayString, TruthValue, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "DisplayString", "TruthValue", "TextualConvention", "RowStatus")
brcdRouteMapMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1))
brcdRouteMapMIB.setRevisions(('2011-11-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: brcdRouteMapMIB.setRevisionsDescriptions(('Initial revision',))
if mibBuilder.loadTexts: brcdRouteMapMIB.setLastUpdated('201111280000Z')
if mibBuilder.loadTexts: brcdRouteMapMIB.setOrganization('Brocade Communications Systems, Inc.')
if mibBuilder.loadTexts: brcdRouteMapMIB.setContactInfo('Technical Support Center 130 Holger Way, San Jose, CA 95134 Email: ipsupport@brocade.com Phone: 1-800-752-8061 URL: www.brocade.com')
if mibBuilder.loadTexts: brcdRouteMapMIB.setDescription("This MIB module contains the managed object definitions for routemaps within the IP Routers. Copyright 1996-2011 Brocade Communications Systems, Inc. All rights reserved. This Brocade Communications Systems SNMP Management Information Base Specification embodies Brocade Communications Systems' confidential and proprietary intellectual property. Brocade Communications Systems retains all title and ownership in the Specification, including any revisions. This Specification is supplied AS IS, and Brocade Communications Systems makes no warranty, either express or implied, as to the use, operation, condition, or performance of the specification, and any unintended consequence it may on the user environment.")
brcdRouteMapConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1))
brcdRouteMapShow = MibIdentifier((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2))
brcdRouteMapTable = MibTable((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 1), )
if mibBuilder.loadTexts: brcdRouteMapTable.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapTable.setDescription('This table contains the routemap entries.')
brcdRouteMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 1, 1), ).setIndexNames((0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapName"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapSequence"))
if mibBuilder.loadTexts: brcdRouteMapEntry.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapEntry.setDescription('A row in this table represents a routemap entry.')
brcdRouteMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 1, 1, 1), DisplayString())
if mibBuilder.loadTexts: brcdRouteMapName.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapName.setDescription('Identifies the route map. In NetIron, the name can have max 80 characters.')
brcdRouteMapSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 1, 1, 2), Unsigned32())
if mibBuilder.loadTexts: brcdRouteMapSequence.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapSequence.setDescription('Identifies the sequence to insert to/delete from existing route-map entry.')
brcdRouteMapAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 1, 1, 3), Action()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapAction.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapAction.setDescription('Identifies the action to be taken for this Route Map entry.')
brcdRouteMapRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 1, 1, 4), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapRuleName.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapRuleName.setDescription('Identifies the path name for this map. Max size is 127. This object is not supported in CES/CER platform.')
brcdRouteMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapRowStatus.setDescription('Setting this object to createAndGo(4) results in addition of new row. Setting this object to destroy( 6)results in removal of a row. The value active(1) is returned for get and get-next requests. Other values in the enumeration are not used.')
brcdRouteMapMatchTable = MibTable((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 2), )
if mibBuilder.loadTexts: brcdRouteMapMatchTable.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapMatchTable.setDescription('RouteMap Match Clause Config Table for a given routemap.')
brcdRouteMapMatchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 2, 1), ).setIndexNames((0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapName"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapSequence"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapMatchSequence"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapMatchType"))
if mibBuilder.loadTexts: brcdRouteMapMatchEntry.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapMatchEntry.setDescription('A row in this table represents a routemap match clause entry. Before creating an instance row in this table using a name, a corresponding entry with that name needs to be existing in the brcdRouteMapTable.')
brcdRouteMapMatchSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: brcdRouteMapMatchSequence.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapMatchSequence.setDescription('This object identifies the position in this table where this match rule is added. This is running integer. If the brcdRouteMapMatchRowStatus is createAndGo then the row is inserted if there is no match rule is present at brcdRouteMapMatchIndex position. If there is a rule present it should be of same kind. If not then the set request fails. Application can obtain value for this object in the last row and use the next value to insert a new row in this table.')
brcdRouteMapMatchType = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("matchUndefined", 0), ("matchAsPath", 1), ("matchBgpCommunityName", 2), ("matchBgpCommunityNameExact", 3), ("matchBgpExtCommunityNumber", 4), ("matchInterfaces", 5), ("matchIpv4AddressAclNames", 6), ("matchIpv4AddressAclNumbers", 7), ("matchIpv4AddressPrefixList", 8), ("matchIpv4NextHopAclNames", 9), ("matchIpv4NextHopAclNumbers", 10), ("matchIpv4NextHopPrefixList", 11), ("matchIpv4RouteSourceAclNames", 12), ("matchIpv4RouteSourceAclNumbers", 13), ("matchIpv4RouteSourcePrefixList", 14), ("matchIpv6AddressAclNames", 15), ("matchIpv6AddressPrefixList", 16), ("matchIpv6NextHopPrefixList", 17), ("matchIpv6RouteSourcePrefixList", 18), ("matchMetric", 19), ("matchRoutingProtocol", 20), ("matchRouteType", 21), ("matchTags", 22))))
if mibBuilder.loadTexts: brcdRouteMapMatchType.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapMatchType.setDescription('A pair of brcdRouteMapMatchType and brcdRouteMapMatchValue objects specifies a particular match clause.')
brcdRouteMapMatchValue = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 2, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapMatchValue.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapMatchValue.setDescription('This object specifies the value corresponding to the brcdRouteMapMatchType. matchAsPath - Identifies one or more BGP AS Paths to be matched. This list of AS Path names are separated by one or more spaces. matchBgpCommunityName ֠Identifies one or more BGP community ACL names to be matched. This list of BGP community ACL names separated by one or more spaces. matchBgpCommunityNameExact ֠Identifies one or more BGP community ACL names to be matched (which requires exact match). This list of BGP community ACL names separated by one or more spaces. matchBgpExtCommunityNumber ֠ Identifies one or more BGP community list numbers to be matched. This is list of BGP community list numbers separated by one or more spaces. matchInterfaces ֠Identifies the list of IfIndices that need to be matched in this Routemap. It means traffic from these interfaces will satisfy this match. Value 0 matches to null0 interface. In NetIron, supported interfaces are ethernet, pos, ve, loopback and tunnel. Each IfIndex is a 32-bit integer in big endian order. One or more Interface IfIndices can be specified by separating each IfIndex by one or more spaces. matchIpv4AddressAclNames ֠Matches Ipv4 address of route. Identifies the list of Ipv4 standard or extended ACL names to be matched. The value is list of ACL names separated by one or more spaces. matchIpv4AddressAclNumbers ֠Matches Ipv4 address of route. Identifies the list of Ipv4 ACL numbers to be matched. The value is list of ACL numbers separated by one or more spaces. matchIpv4AddressPrefixList ֠Matches Ipv4 address of route. Identifies the list of Ipv4 prefix-lists to be matched. The value is list of IPv4 prefix-list names separated by one or more spaces. matchIpv4NextHopAclNames ֠Matches next hop Ipv4 address of route. Identifies the list of Ipv4 standard or extended ACL names to be matched. The value is list of ACL names separated by one or more spaces. matchIpv4NextHopAclNumbers ֠ Matches next hop Ipv4 address of route. Identifies the list of Ipv4 ACL numbers to be matched. The value is list of ACL numbers separated by one or more spaces. matchIpv4NextHopPrefixList ֠Matches next hop Ipv4 address of route. Identifies the list of Ipv4 prefix-lists to be matched. The value is list of IPv4 prefix-list names separated by one or more spaces. matchIpv4RouteSourceAclNames ֠Matches advertising source Ipv4 address of route.Identifies the list of Ipv4 standard or extended ACL names to be matched. The value is list of ACL names separated by one or more spaces. matchIpv4RouteSourceAclNumbers ֠ Matches advertising source Ipv4 address of route.Identifies the list of Ipv4 ACL numbers to be matched. The value is list of ACL numbers separated by one or more spaces. matchIpv4RouteSourcePrefixList ֠Matches advertising source Ipv4 address of route. Identifies the list of Ipv4 prefix-lists to be matched. The value is list of IPv4 prefix-list names separated by one or more spaces. matchIpv6AddressAclNames ֠Matches Ipv6 address of route. Identifies the list of Ipv6 ACL names to be matched. The value is list of ACL names separated by one or more spaces. matchIpv6AddressPrefixList ֠Matches Ipv6 address of route. Identifies the list of Ipv6 prefix-lists to be matched. The value is list of IPv6 prefix-list names separated by one or more spaces. matchIpv6NextHopPrefixList ֠Matches next hop Ipv6 address of route. Identifies the list of Ipv6 prefix-lists to be matched. The value is list of IPv6 prefix-list names separated by one or more spaces. matchIpv6RouteSourcePrefixList ֠Matches advertising source Ipv6 address of route. Identifies the list of Ipv6 prefix-lists to be matched. The value is list of IPv6 prefix-list names separated by one or more spaces. matchMetric ֠Specifies the route metric to be used for the match. Value is string representation of the decimal metric value. Agent will do ascii to integer conversion before using this value. matchRoutingProtocol ֠Specifies the routing protocol to be used for the match. Value is string representation of one of the following decimal values. static-BGP(1), iBGP(2), eBGP(3), non-staticBGP(4), isisLevel1(5), isisLevel2(6), isis(7),rip(8),static(9). The other values are not supported. The agent will do ascii to integer conversion before using this value. matchRouteType ֠Specifies the route type to be used for the match. Value is string representation of one of the following decimal values. ospfExternalType1(2), ospfExternalType2(3), ospfInternal(4), isisLevel1(5), isisLevel2(6). The other values are not supported. The agent will do ascii to integer conversion before using this value. matchTags ֠Specifies list of tag values to be matched (string representation of decimal values) Each tag value is separated by one or more spaces. There cannot be more than 16 values.')
brcdRouteMapMatchCliString = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brcdRouteMapMatchCliString.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapMatchCliString.setDescription('This is read-only object. This object is for informative purpose only. For a pair of brcdRouteMapMatchType and brcdRouteMapMatchValue, this object represents equivalent CLI routemap match command.')
brcdRouteMapMatchRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapMatchRowStatus.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapMatchRowStatus.setDescription('Setting this object to createAndGo(4) results in addition of new row. Setting this object to destroy( 6)results in removal of a row. The value active(1) is returned for get and get-next requests. Other values in the enumeration are not used.')
brcdRouteMapSetTable = MibTable((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 3), )
if mibBuilder.loadTexts: brcdRouteMapSetTable.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapSetTable.setDescription('RouteMap Set Clause Config Table for a given routemap.')
brcdRouteMapSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 3, 1), ).setIndexNames((0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapName"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapSequence"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapSetSequence"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapSetType"))
if mibBuilder.loadTexts: brcdRouteMapSetEntry.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapSetEntry.setDescription('A row in this table represents a routemap set clause entry. Before creating an instance row in this table using a name, a corresponding entry with that name needs to be existing in the brcdRouteMapTable.')
brcdRouteMapSetSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: brcdRouteMapSetSequence.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapSetSequence.setDescription('This object identifies the position in this table where this match rule is added. This is running integer. If the brcdRouteMapSetRowStatus is createAndGo then the row is inserted if there is no match rule is present at brcdRouteMapSetIndex position. If there is a rule present it should be of same kind. If not then the set request fails. Application can obtain value for this object in the last row and use the next value to insert a new row in this table.')
brcdRouteMapSetType = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("setUnDefinedType", 0), ("setAsPath", 1), ("setAutomaticTag", 2), ("setDeleteCommunityList", 3), ("setCommunityNumber", 4), ("setCommunityFlag", 5), ("setDampening", 6), ("setDistance", 7), ("setExtCommunityRT", 8), ("setExtCommunityRTAdditive", 9), ("setExtCommunitySOO", 10), ("setOutputInterfaces", 11), ("setNextHopIpv4Addr", 12), ("setNextHopIpv4AddrWithPreserveVlan", 13), ("setNextHopIpv6Addr", 14), ("setNextHopIpv6AddrWithPreserveVlan", 15), ("setNextHopIpPeerAddr", 16), ("setIsisLevel", 17), ("setLocalPreference", 18), ("setMetricType", 19), ("setMetric", 20), ("setNextHopFloodVlan", 21), ("setNextHopFloodVlanPreserveVlan", 22), ("setNextHopFloodVlanOutgoingDa", 23), ("setNextHopIpTunnel", 24), ("setNextHopLsp", 25), ("setBgpOrigin", 26), ("setTag", 27), ("setWeight", 28))))
if mibBuilder.loadTexts: brcdRouteMapSetType.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapSetType.setDescription('A pair of brcdRouteMapSetType and brcdRouteMapSetValue objects specifies a particular set clause.')
brcdRouteMapSetValue = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 3, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapSetValue.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapSetValue.setDescription("This object specifies the value corresponding to the brcdRouteMapSetType. setAsPath ֠Identifies the prepend string for BGP AS path attribute. The value is the string representation of BGP AS number to be prepended with the AS Path. If the value specified is the string ҴagҠinstead of the AS path number then itwill set the tag as an AS path attribute. setAutomaticTag ֠Specifies that the routemap tag is to be computed automatically. Value is string representation of a truth value 1. This object will not be present if it is not configured. Truth value of 0 can be used to mark its deletion. setDeleteCommunityList ֠Specifies the name of the BGP community List to be set for deletion. setCommunityNumber ֠Specifies the BGP community number to be added. Format is either ӁA:NNҠor '<community number>'. setCommunityFlag ֠This value relates to setCommunityNumber. It specifies that the BGP community in setCommunityNumber have the following behavior noExport(1),noAdvertise(2), localAs(3),additive(4). The value is string representation of one of the above decimal values. For additive(4), the value is followed by the community number in either 'AA:NN' or <community number> format. setDampening ֠It consists of four values separated by space. The first value specifies the string representation of decimal value for BGP route flap dampening. It should be enabled with half-time in minutes for the penalty. Default value is 15 minutes. Valid range is 1-45. The second value relates to the 1st value and specifies the string representation of the value to start reusing a BGP route. Default is 750, with each flap penalty as 1000. Valid range is 1-20000. The third value relates to the 1st value and specifies the string representation of value to start suppressing a BGP route. Default is 2000, with each flap penalty as 1000. Valid range is 1-20000. The Fourth value relates to the 1st value and specifies the string representation of maximum duration in minutes to suppress a stable route. Default is 40. Valid range is 1-255. If a value is not provided then the default value will be picked up. setDistance ֠Specifies the string representation of admin distance to be set for matching OSPF routes. setExtCommunityRT ֠Specifies one or more (separated by space) VPN extended community attributes. Each VPN community is of format ҁSN:nnҮ setExtCommunityRTAdditive ֠This object is related to earlier object setExtCommunityRT. It specifies that the VPN communities in earlier should be added to the existing extended community. setExtCommunitySOO ֠Specifies site-of-origin VPN extended community attributes. The VPN community is of format ҁSN:nnҮ setOutputInterfaces ֠Identifies the list of output IfIndices. Value 0 matches to null0 interface. Each IfIndex is a 32-bit integer in big endian order. One or more Interface IfIndices can be specified by separating each IfIndex by one or more spaces. If the ifIndex is not null0 then the preserve-vlan flag is mandatory and which is always implicitly set. setNextHopIpv4Addr ֠Identifies the string representation of the next hop ipv4 address without preserve vlan flag. setNextHopIpv4AddrWithPreserveVlan ֠Identifies the string representation of the next hop ipv4 address with preserve vlan flag. setNextHopIpv6Addr ֠Identifies the string representation of the next hop ipv6 address without preserve vlan flag. setNextHopIpv6AddrWithPreserveVlan ֠Identifies the string representation of the next hop ipv6 address with preserve vlan flag. setNextHopIpPeerAddr ֠The value is string representation of truth value. Identifies that the next hop is BGP IPv4 peer address. When set to Ѱҍ this object is deleted. setIsisLevel ֠Identifies the level to which the ISIS route to import. The value is string representation of one of the following decimal values, level1(1), level2(2) level1or2(3). setLocalPreference ֠Identifies the BGP local preference path attribute value to be set. The value is string representation of the decimal preference value. setMetricType ֠Specifies the route metric type for the destination routing protocol. Value is string representation of one of the following internal(1), external(2), type1(3), type2(4). setMetric ֠Specifies the metric value set for the destination routing protocol. Value is string representation of the following: <n>: Metric value +<n>: Add <n> to metric -<n>: Subtract <n> to metric None: remove metric value setNextHopFloodVlan ֠Specifies the next hop vlan without preserve vlan to be set. Value is string representation of vlan Id (1-4090) setNextHopFloodVlanPreserveVlan ֠Specifies the next hop vlan with preserve vlan to be set. Value is string representation of vlan Id (1-4090) setNextHopFloodVlanOutgoingDa ֠Specifies the next hop vlan with outgoing destination address flag set. Value is string representation of vlan id (1-4090) followed with MAC address. setNextHopIpTunnel ֠ Specifies the next hop IP tunnel, it can only be configured for configured GRE tunnels. The value is string representation of decimal tunnel ID setNextHopLsp ֠Specifies the next hop LSP name. setBgpOrigin ֠Specifies the BGP origin code. The value is string representation of one the following decimal value, igp(1), incomplete(2) setTag ֠Specifies the string representation of the decimal tag value for the destination routing protocol. setWeight ֠Specifies the string representation of the decimal value for BGP weight for the routing table.")
brcdRouteMapSetCliString = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brcdRouteMapSetCliString.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapSetCliString.setDescription('This is read-only object. This object is for informative purpose only. For a pair of brcdRouteMapSetType and brcdRouteMapSetValue, this object represents equivalent CLI routemap set command.')
brcdRouteMapSetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 3, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapSetRowStatus.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapSetRowStatus.setDescription('Setting this object to createAndGo(4) results in addition of new row. Setting this object to destroy( 6)results in removal of a row. The value active(1) is returned for get and get-next requests. Other values in the enumeration are not used.')
brcdRouteMapBindTable = MibTable((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 4), )
if mibBuilder.loadTexts: brcdRouteMapBindTable.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapBindTable.setDescription('This table contains the bindings for routemap entries to interfaces. Only one route map can be bounded to a given interface. Attempting to bind a second routemap to the same interface will return an error.')
brcdRouteMapBindEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 4, 1), ).setIndexNames((0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapBindIfIndex"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRouteMapBindIpType"))
if mibBuilder.loadTexts: brcdRouteMapBindEntry.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapBindEntry.setDescription('A row in this table represents a binding of a routemap to one interface.')
brcdRouteMapBindIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 4, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: brcdRouteMapBindIfIndex.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapBindIfIndex.setDescription('Identifies the interface to bind a routemap. The interface can only be of type physical or virtual.')
brcdRouteMapBindIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 4, 1, 2), InetAddressType())
if mibBuilder.loadTexts: brcdRouteMapBindIpType.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapBindIpType.setDescription('Identifies the IP type for the bind. Route map can be bound only to ipv4 or ipv6 policy.')
brcdRouteMapBindMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 4, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapBindMapName.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapBindMapName.setDescription('Identifies the route map name. In NetIron, the name can have max 80 characters.')
brcdRouteMapBindRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: brcdRouteMapBindRowStatus.setStatus('current')
if mibBuilder.loadTexts: brcdRouteMapBindRowStatus.setDescription('Setting this object to createAndGo(4) results in addition of new row. Setting this object to destroy( 6)results in removal of a row. The value active(1) is returned for get and get-next requests. Other values in the enumeration are not used. Once created, a row cannot be modified')
brcdRMapRuleDisplayTable = MibTable((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1), )
if mibBuilder.loadTexts: brcdRMapRuleDisplayTable.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayTable.setDescription('This table contains the various route map rule entries. A routemap rule instance (map and sequence number) can have only one rule name. The same rule name could be applied to multiple routemaps')
brcdRMapRuleDisplayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1), ).setIndexNames((0, "BROCADE-ROUTEMAP-MIB", "brcdRMapRuleDisplayRuleName"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRMapRuleDisplayRouteMapName"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRMapRuleDisplaySequence"), (0, "BROCADE-ROUTEMAP-MIB", "brcdRMapRuleDisplayIpType"))
if mibBuilder.loadTexts: brcdRMapRuleDisplayEntry.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayEntry.setDescription('A row in this table represents a route map rule entry.')
brcdRMapRuleDisplayRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 1), DisplayString())
if mibBuilder.loadTexts: brcdRMapRuleDisplayRuleName.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayRuleName.setDescription('Identifies the rule name.')
brcdRMapRuleDisplayRouteMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 2), DisplayString())
if mibBuilder.loadTexts: brcdRMapRuleDisplayRouteMapName.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayRouteMapName.setDescription('Identifies the route map that has this rule.')
brcdRMapRuleDisplaySequence = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 3), Unsigned32())
if mibBuilder.loadTexts: brcdRMapRuleDisplaySequence.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplaySequence.setDescription('Identifies the instance sequence number.')
brcdRMapRuleDisplayIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 4), InetAddressType())
if mibBuilder.loadTexts: brcdRMapRuleDisplayIpType.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayIpType.setDescription('Identifies the IP type for the Rule Display (1(ipv4), or 2(ipv6)). A row is present if the corresponding ipv4 or ipv6 AclMatchFilter is present.')
brcdRMapRuleDisplayInputInterfaceList = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brcdRMapRuleDisplayInputInterfaceList.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayInputInterfaceList.setDescription('A list of space separated interface indices which are the port membership of this rule. An * here means the path is configured but disabled.')
brcdRMapRuleDisplayAclMatchFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brcdRMapRuleDisplayAclMatchFilter.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayAclMatchFilter.setDescription('The list of space separated ACL match filters name or number used in this rule.')
brcdRMapRuleDisplayOutputVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brcdRMapRuleDisplayOutputVlan.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayOutputVlan.setDescription('Identifies the next-hop-flood VLAN selected (by the interface card). Empty string will be returned if there is no value.')
brcdRMapRuleDisplayOutputPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brcdRMapRuleDisplayOutputPort.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayOutputPort.setDescription('A list of space separated egress interfaces selected (by the interface card). Empty string will be returned if there is no value.')
brcdRMapRuleDisplayOutputIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1991, 1, 1, 3, 39, 1, 2, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: brcdRMapRuleDisplayOutputIPAddress.setStatus('current')
if mibBuilder.loadTexts: brcdRMapRuleDisplayOutputIPAddress.setDescription('A list of space separated selected IPv4 next-hop or IPv6 next-hop address.Empty string will be returned if there is no value.')
mibBuilder.exportSymbols("BROCADE-ROUTEMAP-MIB", brcdRouteMapSetEntry=brcdRouteMapSetEntry, brcdRouteMapAction=brcdRouteMapAction, PYSNMP_MODULE_ID=brcdRouteMapMIB, brcdRouteMapMatchValue=brcdRouteMapMatchValue, brcdRouteMapMatchCliString=brcdRouteMapMatchCliString, brcdRouteMapBindIfIndex=brcdRouteMapBindIfIndex, brcdRouteMapBindRowStatus=brcdRouteMapBindRowStatus, brcdRouteMapTable=brcdRouteMapTable, brcdRMapRuleDisplayOutputVlan=brcdRMapRuleDisplayOutputVlan, brcdRMapRuleDisplayTable=brcdRMapRuleDisplayTable, brcdRouteMapMatchSequence=brcdRouteMapMatchSequence, brcdRouteMapSequence=brcdRouteMapSequence, brcdRouteMapName=brcdRouteMapName, brcdRouteMapSetType=brcdRouteMapSetType, brcdRMapRuleDisplayIpType=brcdRMapRuleDisplayIpType, brcdRMapRuleDisplayEntry=brcdRMapRuleDisplayEntry, brcdRouteMapBindTable=brcdRouteMapBindTable, brcdRouteMapShow=brcdRouteMapShow, brcdRMapRuleDisplayAclMatchFilter=brcdRMapRuleDisplayAclMatchFilter, brcdRouteMapMatchEntry=brcdRouteMapMatchEntry, brcdRouteMapRowStatus=brcdRouteMapRowStatus, brcdRouteMapSetTable=brcdRouteMapSetTable, brcdRMapRuleDisplayOutputIPAddress=brcdRMapRuleDisplayOutputIPAddress, brcdRMapRuleDisplayOutputPort=brcdRMapRuleDisplayOutputPort, brcdRouteMapMIB=brcdRouteMapMIB, brcdRouteMapEntry=brcdRouteMapEntry, brcdRMapRuleDisplayInputInterfaceList=brcdRMapRuleDisplayInputInterfaceList, brcdRouteMapConfig=brcdRouteMapConfig, brcdRouteMapBindIpType=brcdRouteMapBindIpType, brcdRMapRuleDisplayRuleName=brcdRMapRuleDisplayRuleName, brcdRouteMapSetValue=brcdRouteMapSetValue, brcdRouteMapRuleName=brcdRouteMapRuleName, brcdRouteMapSetRowStatus=brcdRouteMapSetRowStatus, brcdRouteMapBindEntry=brcdRouteMapBindEntry, brcdRouteMapMatchTable=brcdRouteMapMatchTable, brcdRouteMapMatchType=brcdRouteMapMatchType, brcdRouteMapSetCliString=brcdRouteMapSetCliString, brcdRMapRuleDisplayRouteMapName=brcdRMapRuleDisplayRouteMapName, brcdRouteMapBindMapName=brcdRouteMapBindMapName, brcdRouteMapMatchRowStatus=brcdRouteMapMatchRowStatus, brcdRouteMapSetSequence=brcdRouteMapSetSequence, brcdRMapRuleDisplaySequence=brcdRMapRuleDisplaySequence)

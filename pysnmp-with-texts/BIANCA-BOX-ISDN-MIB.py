#
# PySNMP MIB module BIANCA-BOX-ISDN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BOX-ISDN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:37:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, ObjectIdentity, Integer32, IpAddress, Gauge32, ModuleIdentity, iso, MibIdentifier, Counter64, NotificationType, TimeTicks, Counter32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "ObjectIdentity", "Integer32", "IpAddress", "Gauge32", "ModuleIdentity", "iso", "MibIdentifier", "Counter64", "NotificationType", "TimeTicks", "Counter32", "Unsigned32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
isdn = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 2))
class Date(Integer32):
    pass

class HexValue(Integer32):
    pass

isdnIfTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 1), )
if mibBuilder.loadTexts: isdnIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfTable.setDescription('The isdnIfTable contains information relating to the interfaces found on the system. Each entry corresponds to a connected ISDN interface (BRI or PRI). Entries can only be added or deleted by the system. Creating entries: Entries are created by the system only when a new BRI or PRI module is installed. Deleting entries: Entries are removed by the system after the appropriate BRI or PRI module is removed.')
isdnIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnIfIndex"))
if mibBuilder.loadTexts: isdnIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfEntry.setDescription('')
isdnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfIndex.setDescription('Unique index of the basic or primary rate interface.')
isdnIfDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfDescription.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfDescription.setDescription('Textual description of the basic rate interface including its slot and number (e.g. bri2-0 means slot 2, unit 0).')
isdnIfLayer1State = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("f1", 1), ("f2", 2), ("f3", 3), ("f4", 4), ("f5", 5), ("f6", 6), ("f7", 7), ("f8", 8), ("g1", 9), ("g2", 10), ("g3", 11), ("g4", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfLayer1State.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfLayer1State.setDescription('The ISDN physical layer state according to I.430 f1(1) = inactive; f2(2) = sensing; f3(3) = deactivated; f4(4) = awaiting signal; f5(5) = identifying input; f6(6) = synchronized; f7(7) = activated; f8(8) = lost framing; g1(9) = deactive; g2(10) = pending activation; g3(11) = active; g4(12) = pending deactivation')
isdnIfBchannelControl = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uncontrolled", 1), ("controlled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfBchannelControl.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfBchannelControl.setDescription('B-channels are controlled by a call control protocol in the D-channel. Otherwise they may be used as permanent links.')
isdnIfActivationRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nooperation", 1), ("activate", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnIfActivationRequest.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfActivationRequest.setDescription("When this object is set to 'activate' the BRICK will start an activation sequence of ISDN-Layer1 of the basic rate interface.")
isdnIfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("te", 1), ("nt", 2), ("pabx-terminal", 3), ("pabx-trunk", 4), ("pabx-tie", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnIfMode.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfMode.setDescription('Specifies the mode of the interface. TE or NT Mode will be set for ISDN interfaces without PABX control. For PRI both NT (network termination) and TE (terminal equipment) modes are supported.')
isdnIfTimerT3 = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnIfTimerT3.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfTimerT3.setDescription('Value of Timer T3 in milliseconds.T3 is started whenever ISDNLayer-1 is activated (i.e. Activation Request is started).')
isdnIfUsePowerDetector = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("use", 1), ("dontuse", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnIfUsePowerDetector.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfUsePowerDetector.setDescription('Use the PS1 Power Detector to control the layer 1 automaton.This object is only valid for basic rate interfaces.')
isdnIfNumberOfChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfNumberOfChannels.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfNumberOfChannels.setDescription('Number of Channels including the D channel, that are available on this ISDN Interface (3 = BRI, 31 = PRI).')
isdnIfTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfTimeouts.setDescription('Number of timeouts of T3 during lifetime of the system.')
isdnIfActivates = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfActivates.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfActivates.setDescription('Number of successful activation cycles during lifetime of the system.')
isdnIfDeactivates = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfDeactivates.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfDeactivates.setDescription('Number of deactivations during lifetime of the system.')
isdnIfAutoconfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("start", 1), ("running", 2), ("done", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnIfAutoconfigState.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfAutoconfigState.setDescription("Start auto configuration on this ISDN Interface. Auto configuration is a mechanism to automatically detect the attributes of an ISDN interface. This can be done at boot time (if isdnIfAutoConfig is set to 'on') or by manually setting this field to 'start'. Refer to Chapter 3 on Features and Methods.")
isdnIfAutoconfig = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnIfAutoconfig.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfAutoconfig.setDescription('Start Autoconfiguration on this ISDN interface at bootup.')
isdnChTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 2), )
if mibBuilder.loadTexts: isdnChTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChTable.setDescription('The isdnChTable contains information for each physical B or D channel on the system. The entries contain information regarding the configuration of the channel and various statistical data for active connections. Only the system can add entries to this table. Creating entries: Entries are created by the system when a new interface appears in the isdnIfTable; when a new BRI or PRI module is installed. Deleting entries: Are not possible.')
isdnChEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnChIsdnIfIndex"), (0, "BIANCA-BOX-ISDN-MIB", "isdnChNumber"))
if mibBuilder.loadTexts: isdnChEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChEntry.setDescription('')
isdnChIsdnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChIsdnIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChIsdnIfIndex.setDescription('Unique index of an Interface.')
isdnChNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChNumber.setDescription('The channel number. 0 is D-channel, 1..2 are the B- channels of a BRI module, and 1..31 are the B-channels of a PRI module.')
isdnChState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-connected", 1), ("connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChState.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChState.setDescription('Status of the Channel controlled either by the call control protocol or the physical state of the interface.')
isdnChType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 6, 7))).clone(namedValues=NamedValues(("dialup", 1), ("leased-dte", 2), ("leased-dce", 3), ("loopback", 6), ("not-available", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnChType.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChType.setDescription('Type of Channel.Setting this object to one of the leased values creates a new entry in the ifTable.')
isdnChBundle = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnChBundle.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChBundle.setDescription('Index of the bundle to aggregate multiple Channels to one interface. Not valid in dialup mode.')
isdnChThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChThroughput.setDescription('Throughput of the channel in bits/second (64000 for B-channels, 16000 for BRI D-Channels.')
isdnChReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChReceivedPackets.setDescription('Count of received valid HDLC Frames.')
isdnChReceivedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChReceivedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChReceivedOctets.setDescription('Count of received valid HDLC bytes.')
isdnChReceivedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChReceivedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChReceivedErrors.setDescription('Count of received valid errors (can be detected by HDLC-Checksum-Errors).')
isdnChTransmitPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChTransmitPackets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChTransmitPackets.setDescription('Count of received valid HDLC Frames.')
isdnChTransmitOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChTransmitOctets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChTransmitOctets.setDescription('Count of received valid HDLC Frames.')
isdnChTransmitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnChTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: isdnChTransmitErrors.setDescription('Count of transmitted valid HDLC errors. Can occur when the transmitter can not be reloaded fast enough when transmitting large packets. This should only happen when the system is over encumbered.')
isdnStkTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 3), )
if mibBuilder.loadTexts: isdnStkTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkTable.setDescription("The isdnStkTable contains information for each ISDN protocol stack currently configured on the system. Entries are normally created by the system at boot time, during the auto configuration process, but can also be added manually. Creating entries: Entries are created by the system during the ISDN auto configuration procedure at boot time (see Chapter 3). Entries can also be created by assigning a value to the Number and isdnIfNumber objects. Deleting entries: Entries can be removed by assigning the value 'delete' to the ProtocolProfile object.")
isdnStkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnStkNumber"))
if mibBuilder.loadTexts: isdnStkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkEntry.setDescription('')
isdnStkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkNumber.setDescription('Unique number of an ISDN stack (0..n). This number can be used in the isdnDispatchTable.')
isdnStkIsdnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkIsdnIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkIsdnIfIndex.setDescription('The index of the ISDN interface. The isdnIfTable lists all available ISDN interfaces.')
isdnStkProtocolProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("delete", 1), ("permanent", 2), ("d1tr6", 3), ("dss1", 4), ("ni1", 5), ("not-used", 6), ("ess5", 7), ("dms100", 8), ("ins64", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkProtocolProfile.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkProtocolProfile.setDescription("The protocol for the D channel. Assigning `delete' to this object has the effect of removing the entry from this table.")
isdnStkConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("point-to-multipoint", 1), ("point-to-point", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkConfiguration.setDescription('')
isdnStkSPID = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkSPID.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkSPID.setDescription('The service profile identifier; only required for the national ISDN1 protocol in North America.')
isdnStkTeiProc = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("fixed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkTeiProc.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkTeiProc.setDescription('The Tei procedure used. Note that for point-to-point configurations this object should be set to fixed(2).')
isdnStkTeiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkTeiValue.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkTeiValue.setDescription('The Tei value. Note that for point-to-point configurations this object should be 0.')
isdnStkClearAllCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-operation", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkClearAllCalls.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkClearAllCalls.setDescription('Setting this value to clear(2) will force all current connections on this stack to terminate.')
isdnStkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("loaded", 1), ("not-loaded", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnStkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkStatus.setDescription('Shows the status of this ISDN stack. If auto configuration was successful for this stack, this object will be loaded(1). If this stack is not loaded, ISDN calls are not possible.')
isdnStkLayer2State = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tei-unassigned", 1), ("tei-assigned", 2), ("aw-est", 3), ("established", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnStkLayer2State.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkLayer2State.setDescription('Shows the current state of Layer2. To allow ISDN connections, the state established(4) must be assigned.')
isdnStkBchannels = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkBchannels.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkBchannels.setDescription('Number of B channels that correspond to that stack.')
isdnStkDialOutPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 3, 1, 26), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnStkDialOutPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: isdnStkDialOutPrefix.setDescription('Prefix for PABX dialout. This entry is added to a dialing number provided by the calling site via PPP negotiation (LCP Callback Option / PPP Bandwith Alllocation Protocol).')
isdnCallTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 4), )
if mibBuilder.loadTexts: isdnCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallTable.setDescription('The isdnCallTable displays all currently active ISDN calls (incoming and outgoing). Only the system can add or remove entries to this table. Creating entries: Entries are added when an outgoing call is made or when an incoming call is connected. Deleting entries: Entries are removed once the respective call is disconnected.')
isdnCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnCallStkNumber"), (0, "BIANCA-BOX-ISDN-MIB", "isdnCallType"), (0, "BIANCA-BOX-ISDN-MIB", "isdnCallReference"))
if mibBuilder.loadTexts: isdnCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallEntry.setDescription('')
isdnCallStkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallStkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallStkNumber.setDescription('The number of the ISDN-Stack, this call is going through. Refer to the isdnStkTable.')
isdnCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallType.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallType.setDescription('The direction of the call.')
isdnCallReference = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallReference.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallReference.setDescription('The corresponding Call-Reference Value on the ISDN D-channel.')
isdnCallAge = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallAge.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallAge.setDescription('The age of the call. For outgoing calls, the time since the call began, or for incoming calls, the time since the call was received. The format is in hh:mm:ss.00.')
isdnCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 10, 11, 12, 13, 16, 18, 26))).clone(namedValues=NamedValues(("null", 1), ("c-initiated", 2), ("ovl-send", 3), ("oc-procd", 4), ("c-deliverd", 5), ("c-present", 7), ("c-recvd", 8), ("ic-procd", 10), ("active", 11), ("discon-req", 12), ("discon-ind", 13), ("suspd-req", 16), ("resum-req", 18), ("ovl-recv", 26)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCallState.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallState.setDescription('The state of the call.')
isdnCallIsdnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallIsdnIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallIsdnIfIndex.setDescription('The corresponding ISDN interface that is used for this call. Refer to the isdnIfTable.')
isdnCallChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallChannel.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallChannel.setDescription('The corresponding B-channel on this ISDN interface. Refer to the isdnIfTable.')
isdnCallDspItem = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58))).clone(namedValues=NamedValues(("ppp", 1), ("login", 2), ("undefined", 10), ("ppp-64k", 11), ("ppp-56k", 12), ("ppp-modem", 13), ("ppp-dovb", 14), ("ppp-v110-1200", 15), ("ppp-v110-2400", 16), ("ppp-v110-4800", 17), ("ppp-v110-9600", 18), ("ppp-v110-14400", 19), ("ppp-v110-19200", 20), ("ppp-v110-38400", 21), ("ppp-x75", 22), ("extern", 24), ("pots", 25), ("ppp-modem-profile-1", 26), ("ppp-modem-profile-2", 27), ("ppp-modem-profile-3", 28), ("ppp-modem-profile-4", 29), ("ppp-modem-profile-5", 30), ("ppp-modem-profile-6", 31), ("ppp-modem-profile-7", 32), ("ppp-modem-profile-8", 33), ("eaz0", 48), ("eaz1", 49), ("eaz2", 50), ("eaz3", 51), ("eaz4", 52), ("eaz5", 53), ("eaz6", 54), ("eaz7", 55), ("eaz8", 56), ("eaz9", 57), ("x25-pad", 58)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallDspItem.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallDspItem.setDescription('The item to or from which this call is connected. For any routing tasks (IP, IPX, X.25, bridging, ...) the ppp(1) item is used. For the isdnlogin program, login(2) is used. For CAPI 1.1 programs, the items eaz0(48) .. eaz9(57) are used.')
isdnCallRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallRemoteNumber.setDescription('The ISDN number that was called (for outgoing calls) or was calling (for incoming calls).')
isdnCallRemoteSubaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallRemoteSubaddress.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallRemoteSubaddress.setDescription('The subaddress of the remote number. The subaddress is coded in NSAP format as octets. See isdnCallRemoteNumber.')
isdnCallLocalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallLocalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallLocalNumber.setDescription('The calling party number that was sent (with the outgoing call) or was received (with incoming calls). Refer to the isdnStkTable.')
isdnCallLocalSubaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallLocalSubaddress.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallLocalSubaddress.setDescription('The subaddress of the calling party number. See isdnCallRLocalNumber.')
isdnCallServiceIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 9, 10, 13, 14, 15, 16))).clone(namedValues=NamedValues(("telephony", 1), ("ab-services", 2), ("x21-services", 3), ("fax-group4", 4), ("btx", 5), ("data-transfer", 7), ("x25-services", 8), ("facsimile64", 9), ("mixed-mode", 10), ("telecontrol", 13), ("graphics-phone", 14), ("teletex", 15), ("video-phone", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallServiceIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallServiceIndicator.setDescription('Service indicator that was sent on the ISDN D-channel when the call was established.')
isdnCallAddInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallAddInfo.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallAddInfo.setDescription('Additional information that was sent on the ISDN D-channel when the call was established. Only sent/received when using the 1TR6 protocol.')
isdnCallBC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallBC.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallBC.setDescription('Bearer Capability that was sent on the ISDN D-channel when the call was established.')
isdnCallLLC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallLLC.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallLLC.setDescription('Low Layer Capability that was sent on the ISDN D-channel when the call was established.')
isdnCallHLC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHLC.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHLC.setDescription("The number of charging ticks received since this connection was established. Actual charges can be computed by multiplying this value with the unit price (e.g. .12 DM in Germany). If you aren't receiving charging information for outgoing calls, verify with your local ISDN provider to make sure this option is being provided/is available.")
isdnCallCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallCharge.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallCharge.setDescription('This object contains the charge for this call either as units or as 1/1000 of the respective currency. Which type of information is choosen, depends on the information provided by the ISDN service provide. See also ChargeInfo for textual information.')
isdnCallReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallReceivedPackets.setDescription('Count of received valid HDLC Frames.')
isdnCallReceivedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallReceivedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallReceivedOctets.setDescription('Count of received valid HDLC Octets.')
isdnCallReceivedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallReceivedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallReceivedErrors.setDescription('Count of received invalid HDLC Frames.')
isdnCallTransmitPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallTransmitPackets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallTransmitPackets.setDescription('Count of transmitted HDLC Frames.')
isdnCallTransmitOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallTransmitOctets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallTransmitOctets.setDescription('Count of transmitted Octets.')
isdnCallTransmitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallTransmitErrors.setDescription('Count of transmit errors (Collision, TX underrun).')
isdnCallChargeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 25), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallChargeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallChargeInfo.setDescription('Textual information of charge, i.e. 0.12 DM or 3 units')
isdnCallScreening = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("user", 1), ("user-verified", 2), ("user-failed", 3), ("network", 4), ("undefined", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallScreening.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallScreening.setDescription("Screening Indicator of the calling party number of incoming calls. The calling partys number (CPN) may be assigned either by the user placing the call or by the telephone switching station. If the CPN was assigned by the user the switching station may optionally verify the address. indicator: CPN assigned: verification: `user' by user none `user-verified' by user verification successful `user-failed' by user verification failed `network' by network none")
isdnCallInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 4, 1, 27), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallInfo.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallInfo.setDescription('Additional information to identify the call')
isdnDispatchTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 5), )
if mibBuilder.loadTexts: isdnDispatchTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDispatchTable.setDescription("The isdnDispatchTable is the central distribution center for all incoming ISDN connections. Incoming ISDN connections are `dispatched' to a service (isdnDspItem) based on the calling party's number sent over the ISDN. Creating entries: Entries can be created by assigning a value to both the isdnDspStkNumber and isdnDspItem objects within one operation. Deleting entries: Entries are removed by setting the isdnDspItem to 'delete'.")
isdnDispatchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnDspStkNumber"), (0, "BIANCA-BOX-ISDN-MIB", "isdnDspItem"))
if mibBuilder.loadTexts: isdnDispatchEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDispatchEntry.setDescription('')
isdnDspStkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspStkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspStkNumber.setDescription('The ISDN stack number for this entry.')
isdnDspItem = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59))).clone(namedValues=NamedValues(("ppp", 1), ("login", 2), ("delete", 10), ("ppp-64k", 11), ("ppp-56k", 12), ("ppp-modem", 13), ("ppp-dovb", 14), ("ppp-v110-1200", 15), ("ppp-v110-2400", 16), ("ppp-v110-4800", 17), ("ppp-v110-9600", 18), ("ppp-v110-14400", 19), ("ppp-v110-19200", 20), ("ppp-v110-38400", 21), ("ppp-x75", 22), ("extern", 24), ("pots", 25), ("ppp-modem-profile-1", 26), ("ppp-modem-profile-2", 27), ("ppp-modem-profile-3", 28), ("ppp-modem-profile-4", 29), ("ppp-modem-profile-5", 30), ("ppp-modem-profile-6", 31), ("ppp-modem-profile-7", 32), ("ppp-modem-profile-8", 33), ("eaz0", 48), ("eaz1", 49), ("eaz2", 50), ("eaz3", 51), ("eaz4", 52), ("eaz5", 53), ("eaz6", 54), ("eaz7", 55), ("eaz8", 56), ("eaz9", 57), ("x25-pad", 58), ("capi2", 59)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspItem.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspItem.setDescription('The item to connect this call to. Routing tasks (IP, IPX, X.25, bridging, ...) should use the ppp(1). For the isdnlogin program use the login(2) item. For CAPI 1.1 programs, use items eaz0(48) .. eaz9(57).')
isdnDspLocalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspLocalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspLocalNumber.setDescription('If the Called Party Number of the incoming call on the specified ISDN stack matches this value, the call is dispatched to the defined item. For outgoing calls from this item, the local number is sent as the Calling Party Number. Note: The matching of isdnDspLocalNumber value is done from right to left based on the number of digits in isdnDspLocalNumber. For example: if isdnDspLocalNumber is set to 124 then an incoming Called Party Number of 6501124 would match while one with 650024 would not.')
isdnDspLocalSubaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspLocalSubaddress.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspLocalSubaddress.setDescription('If the Called Party Subaddress of the incoming call on the specified ISDN stack matches this value, the call is dispatched to the defined item. For outgoing calls from this item, the local subaddress is sent as the Calling Party Subaddress. Note: The matching of isdnDspLocalSubaddress values is done by comparing the entire string of numbers in the Called Party Subaddress field. For example: if issdnDspLocalSubaddress is set to 072522 then only calls with an incoming Called Party Subaddress of 072522 would match, i.e. one with 522 would not match.')
isdnDspBearer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("data", 2), ("voice", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspBearer.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspBearer.setDescription('The isdnDspBearer is used for dispatching different types of calls')
isdnDspSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspSlot.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspSlot.setDescription('Identification number of the used slot.')
isdnDspUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspUnit.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspUnit.setDescription('Identification number of the used unit.')
isdnDspDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspDirection.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspDirection.setDescription('Specifies whether the entry is to be used for outgoing calls, incoming calls or both.')
isdnDspMode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("right-to-left", 1), ("left-to-right", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspMode.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspMode.setDescription('This object specifies the matching direction for incoming calls. When set to right-to-left, the rightmost digits of the called address of an incoming call are compared against the LocalNumber. This is useful for normal basic rate interfaces without DDI, because only few last digits have to be specified to be unique. When set to left-to-right, the leftmost digits of an incoming call are compared against the LocalNumber. Only the latter mode may be used for direct dialing in (DDI). ')
isdnDspUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 5, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnDspUserName.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDspUserName.setDescription('The name of the user.')
isdnDChanX31Table = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 6), )
if mibBuilder.loadTexts: isdnDChanX31Table.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDChanX31Table.setDescription("The isdnDChanX31Table contains information for the X.31 stack for each available ISDN D-channel. This information is mainly used for X.25 packet-switching functions but can be used for CAPI applications. The table is initialized during the auto configure process. By default the system polls each D-channel for an assigned TEI (terminal endpoint identifier). Creating entries: Entries can be added by assigning a new value (valid IfIndex) to isdnX31IsdnIfIndex. Deleting entries: Entries are removed by assigning 'delete' to the approprate isdnX31IsdnAssignedTo object.")
isdnDChanX31Entry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 6, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnX31IsdnIfIndex"))
if mibBuilder.loadTexts: isdnDChanX31Entry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnDChanX31Entry.setDescription('')
isdnX31IsdnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 6, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnX31IsdnIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnX31IsdnIfIndex.setDescription('The corresponding ISDN interface that is used for this call. Refer to the isdnIfTable.')
isdnX31TeiProc = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("fixed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnX31TeiProc.setStatus('mandatory')
if mibBuilder.loadTexts: isdnX31TeiProc.setDescription('The procedure used for polling of TEI (terminal end-point identifiers) values.')
isdnX31TeiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnX31TeiValue.setStatus('mandatory')
if mibBuilder.loadTexts: isdnX31TeiValue.setDescription('The TEI value for this interface.')
isdnX31AssignedTo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("packet-switch", 1), ("capi-default", 2), ("capi", 3), ("delete", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnX31AssignedTo.setStatus('mandatory')
if mibBuilder.loadTexts: isdnX31AssignedTo.setDescription('The service this TEI value is assigned to.')
isdnAccountingTemplate = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnAccountingTemplate.setStatus('mandatory')
if mibBuilder.loadTexts: isdnAccountingTemplate.setDescription("Specifies the format of accounting messages sent by the syslog protocol. The format can consist of any order of the following variables. Tag Meaning %S Date the connection opened; in DD.MM.YY format. %s Time the connection was established: in HH:MM:SS format %R Date the connection closed; in DD.MM.YY format. %r Time the connection was closed: in HH:MM:SS format. %d The duration of the connection in seconds. %D Call identification: internal/external, ID, slot/unit (PABX only) %P Call classification: Private/Business, project number (PABX only) %y Total number of bytes received over the connection. %Y Total number of bytes sent over the connection. %g Total packets received over the connection %G Total packets sent over the connection. %c Total number of charging units (value) incurred for the connection. %C Total number of charging units (string) incurred for the connection. %n The call's direction; either incoming (I) or outgoing (O). %Z The local address (Calling or Called party's number, see %n). %z The local subaddress (Calling or Called party's number, see %n). %T The remote address (Calling or Called party's number %n). %t The remote subaddress (Calling or Called party's number %n). %i Service indicator and additional information for the call. %b Bearer capability for the call. %l Low layer capability for the call. %h High layer capability for the call. %u DSS1 error cause, if applicable. %U 1tr6 error cause, if applicable. %L Local (internal) error cause. %F Call reference (internal). %e Calling extension (for call assiciation; PABX only) %I Information about the subsystem the call was given to. The default accounting template setting contains the following tags: %S,%s,%r,%d,%y,%Y,%g,%G,%C,%n,%Z,%T,%i,%u,%L,%I. This template produces accounting messages similar to the following. ISDN:18.08.1997,13:53:19,13:53:34,12,1096,1875,33,33,1Units,O,2,091196730,7/0,9F,0 ")
isdnCallHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 8), )
if mibBuilder.loadTexts: isdnCallHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryTable.setDescription('The isdnCallHistoryTable contains information pertaining to the last 20 ISDN calls made, since the last system startup. Each call that appears in the isdnCallTable, will have its information stored here (temporarily), once it disconnects. Creating entries: Entries are added by the system once a call is disconnected. Deleting entries: Entries are removed by the system. The table is designed as a circular queue (or FIFO); the most calls are stored at inx 19 with older calls rolling off the top of the table at inx 00.')
isdnCallHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnCallHistoryStkNumber"), (0, "BIANCA-BOX-ISDN-MIB", "isdnCallHistoryType"))
if mibBuilder.loadTexts: isdnCallHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryEntry.setDescription('')
isdnCallHistoryStkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryStkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryStkNumber.setDescription('The number of the ISDN-Stack, this call went through.')
isdnCallHistoryType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryType.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryType.setDescription('The direction of the call, incoming or outgoing.')
isdnCallHistoryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 3), Date()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryTime.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryTime.setDescription('The time the call was received (incoming) or was placed (outgoing).')
isdnCallHistoryDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryDuration.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryDuration.setDescription('The duration of the call in seconds.')
isdnCallHistoryIsdnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryIsdnIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryIsdnIfIndex.setDescription('The corresponding ISDN interface that this call used.')
isdnCallHistoryChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryChannel.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryChannel.setDescription('The corresponding B-channel on this ISDN interface.')
isdnCallHistoryDspItem = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58))).clone(namedValues=NamedValues(("ppp", 1), ("login", 2), ("undefined", 10), ("ppp-64k", 11), ("ppp-56k", 12), ("ppp-modem", 13), ("ppp-dovb", 14), ("ppp-v110-1200", 15), ("ppp-v110-2400", 16), ("ppp-v110-4800", 17), ("ppp-v110-9600", 18), ("ppp-v110-14400", 19), ("ppp-v110-19200", 20), ("ppp-v110-38400", 21), ("ppp-x75", 22), ("extern", 24), ("pots", 25), ("ppp-modem-profile-1", 26), ("ppp-modem-profile-2", 27), ("ppp-modem-profile-3", 28), ("ppp-modem-profile-4", 29), ("ppp-modem-profile-5", 30), ("ppp-modem-profile-6", 31), ("ppp-modem-profile-7", 32), ("ppp-modem-profile-8", 33), ("eaz0", 48), ("eaz1", 49), ("eaz2", 50), ("eaz3", 51), ("eaz4", 52), ("eaz5", 53), ("eaz6", 54), ("eaz7", 55), ("eaz8", 56), ("eaz9", 57), ("x25-pad", 58)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryDspItem.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryDspItem.setDescription('The item this call was connected to. Routing tasks (IP, IPX, X.25, bridging, ...) use ppp(1). The isdnlogin program uses login(2). CAPI 1.1 programs, use the items eaz0(48) .. eaz9(57) are used.')
isdnCallHistoryRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryRemoteNumber.setDescription('The ISDN number that was called (for outgoing calls) or was calling (for incoming calls).')
isdnCallHistoryRemoteSubaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryRemoteSubaddress.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryRemoteSubaddress.setDescription('The subaddress of the remote number. See isdnCall- HistoryRemoteNumber.')
isdnCallHistoryLocalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryLocalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryLocalNumber.setDescription('The calling party number that was sent (with the outgoing call) or was received (with incoming calls).')
isdnCallHistoryLocalSubaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryLocalSubaddress.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryLocalSubaddress.setDescription('The subaddress of the calling party number.')
isdnCallHistoryServiceIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 9, 10, 13, 14, 15, 16))).clone(namedValues=NamedValues(("telephony", 1), ("ab-services", 2), ("x21-services", 3), ("fax-group4", 4), ("btx", 5), ("data-transfer", 7), ("x25-services", 8), ("facsimile64", 9), ("mixed-mode", 10), ("telecontrol", 13), ("graphics-phone", 14), ("teletex", 15), ("video-phone", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryServiceIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryServiceIndicator.setDescription('Service indicator that was sent on the ISDN D-channel when the call was established.')
isdnCallHistoryAddInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryAddInfo.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryAddInfo.setDescription('Additional information that was sent on the ISDN D-channel when the call was established. Only sent/received when using the 1TR6 protocol.')
isdnCallHistoryBC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryBC.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryBC.setDescription('Bearer Capability that was sent on the ISDN D-channel when the call was established.')
isdnCallHistoryLLC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryLLC.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryLLC.setDescription('Low Layer Capability that was sent on the ISDN D-channel when the call was established.')
isdnCallHistoryHLC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryHLC.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryHLC.setDescription('High Layer Capability that was sent on the ISDN D-channel when the call was established.')
isdnCallHistoryCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryCharge.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryCharge.setDescription("The number of charging ticks received for this connection. Actual charges can be computed by multiplying this value with the unit price, e.g. .12 DM in Germany. If you aren't receiving charging information for outgoing calls, verify with your local ISDN provider to make sure this option being provided/is available. As an option, this Object may contain the charge measured in 1/1000 of the respective currency. See also ChargeInfo for textual information.")
isdnCallHistoryDSS1Cause = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 18), HexValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryDSS1Cause.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryDSS1Cause.setDescription("ISDN error condition reported by the DSS1 protocol, for Euro ISDN. See Appendix C in the User's Guide.")
isdnCallHistory1TR6Cause = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 19), HexValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistory1TR6Cause.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistory1TR6Cause.setDescription("ISDN error condition reported by the 1TR6 protocol, for National ISDN in Germany. See Appendix C in the User's Guide.")
isdnCallHistoryLocalCause = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknownprim", 1), ("outstate", 2), ("iemissing", 3), ("ienotallowed", 4), ("look", 5), ("nolink", 6), ("nocallref", 7), ("nomem", 8), ("notready", 9), ("busy", 10), ("chanbusy", 11), ("l3timer", 12), ("l3restart", 13), ("l3error", 14), ("l1error", 15), ("nocontrl", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryLocalCause.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryLocalCause.setDescription("ISDN error condition reported by the system locally. See Appendix C in the User's Guide.")
isdnCallHistoryChargeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryChargeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryChargeInfo.setDescription('Textual information of charge, i.e. 0.12 DM or 3 units')
isdnCallHistoryScreening = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("user", 1), ("user-verified", 2), ("user-failed", 3), ("network", 4), ("undefined", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryScreening.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryScreening.setDescription("Screening Indicator of the calling party number of incoming calls. The calling partys number (CPN) may be assigned either by the user placing the call or by the telephone switching station. If the CPN was assigned by the user the switching station may optionally verify the address. indicator: CPN assigned: verification: `user' by user none `user-verified' by user verification successful `user-failed' by user verification failed `network' by network none")
isdnCallHistoryInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 23), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryInfo.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryInfo.setDescription('Additional information to identify the call')
isdnCallHistoryReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryReceivedPackets.setDescription('Count of received valid HDLC Frames.')
isdnCallHistoryReceivedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryReceivedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryReceivedOctets.setDescription('Count of received valid HDLC Octets.')
isdnCallHistoryReceivedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryReceivedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryReceivedErrors.setDescription('Count of received invalid HDLC Frames.')
isdnCallHistoryTransmitPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryTransmitPackets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryTransmitPackets.setDescription('Count of transmitted HDLC Frames.')
isdnCallHistoryTransmitOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryTransmitOctets.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryTransmitOctets.setDescription('Count of transmitted Octets.')
isdnCallHistoryTransmitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 8, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCallHistoryTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCallHistoryTransmitErrors.setDescription('Count of transmit errors (Collision, TX underrun).')
isdnLoginOnPPPDispatch = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("disallow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnLoginOnPPPDispatch.setStatus('mandatory')
if mibBuilder.loadTexts: isdnLoginOnPPPDispatch.setDescription("Allows or disallows incoming ISDN calls (with an ISDN service indicator of 'telephony'), to be connected to the isdnlogin daemon even though the call has a matching service in the isdnDispatchTable (isdnDspItem). These calls must be initiated using isdnlogin <telno> telephony.")
isdnHistoryMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnHistoryMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: isdnHistoryMaxEntries.setDescription('Maximum number of isdnCallHistory entries in memory.')
isdnloginAllowTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 11), )
if mibBuilder.loadTexts: isdnloginAllowTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnloginAllowTable.setDescription("The isdnloginAllowTable contains information about the ISDN partners that are allowed to login to the BRICK via the isdnlogin service. ISDN callers are identified by their calling partner number. Incoming isdnlogin requests can be restricted to single ISDN stacks. If this table is empty all calls given to the isdnlogind, are accepted. (Note that the isdnDispatchTable is consulted first.) Creating entries: Entries are created by assigning a value to the isdnloginAllowStkNumber object. Deleting entries: An entry can be removed by assigning the value `delete' to its isdnloginAllowScreening object.")
isdnloginAllowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 11, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnloginAllowStkNumber"))
if mibBuilder.loadTexts: isdnloginAllowEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnloginAllowEntry.setDescription('')
isdnloginAllowStkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnloginAllowStkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnloginAllowStkNumber.setDescription("The number of the ISDN stack, that accepts incoming isdnlogin calls. Refer to the isdnStkTable. The value `-1' matches all available stacks.")
isdnloginAllowRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 11, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnloginAllowRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnloginAllowRemoteNumber.setDescription("The number of the ISDN partner that is allowed to login via isdnlogin through the corresponding ISDN Stack. The wildcards '*', '?', '[', ']', '{', '}' may be used. See isdnCallRemoteNumber.")
isdnloginAllowRemoteSubaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 11, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnloginAllowRemoteSubaddress.setStatus('mandatory')
if mibBuilder.loadTexts: isdnloginAllowRemoteSubaddress.setDescription('The subaddress of the remote number. The subaddress is coded in NSAP format as octets. See isdnloginAllowRemoteNumber.')
isdnloginAllowScreening = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("user", 1), ("user-verified", 2), ("user-failed", 3), ("network", 4), ("dont-care", 5), ("delete", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnloginAllowScreening.setStatus('mandatory')
if mibBuilder.loadTexts: isdnloginAllowScreening.setDescription("The screening indicator of the calling party number (CPN). The isdnloginAllowScreening field can be used to gauge the `trustworthiness' of the CPN field (see isdnCallScreening). Indicators are ordered from highest to lowest as follows: indicator: CPN assigned: verification: `network' by network none `user-verified' by user verification successful `user' by user none `user-failed' by user verification failed Set this field to `dont-care' to accept all calls. Set this field to `delete' to delete this entry. Otherwise calls are accepted only if the screening indicator matches or is higher than the set value.")
isdnCreditsTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 2, 12), )
if mibBuilder.loadTexts: isdnCreditsTable.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsTable.setDescription('The isdnCreditsTable contains informations about current used resources and maximum allowed resources for each during a specified interval subsystem. Creating entries: Entries are added by the system during startup. Deleting entries: Is not possible.')
isdnCreditsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1), ).setIndexNames((0, "BIANCA-BOX-ISDN-MIB", "isdnCreditsSubsysNumber"))
if mibBuilder.loadTexts: isdnCreditsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsEntry.setDescription('')
isdnCreditsSubsysNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ppp", 1), ("capi", 2), ("isdnlogin", 3), ("pots", 4), ("doorintercom", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsSubsysNumber.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsSubsysNumber.setDescription('Type of Subsystem.')
isdnCreditsSurveillance = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsSurveillance.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsSurveillance.setDescription('Surveillance on or off.')
isdnCreditsMeasuretime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMeasuretime.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMeasuretime.setDescription('Time of one observation interval in seconds.')
isdnCreditsMaxInCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMaxInCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMaxInCon.setDescription('Maximum number of allowed incoming connections during the observation interval. -1 disables this limit.')
isdnCreditsMaxOutCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMaxOutCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMaxOutCon.setDescription('Maximum number of allowed outgoing connections during the observation interval. -1 disables this limit.')
isdnCreditsMaxCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMaxCharge.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMaxCharge.setDescription('Maximum allowed charge amount during the observation interval. -1 disables this limit.')
isdnCreditsMaxInDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMaxInDuration.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMaxInDuration.setDescription('Maximum connect time for incoming connections in seconds during the observation interval. -1 disables this limit.')
isdnCreditsMaxOutDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMaxOutDuration.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMaxOutDuration.setDescription('Maximum connect time for outgoing connections in seconds during the observation interval. -1 disables this limit')
isdnCreditsTimeleft = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsTimeleft.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsTimeleft.setDescription('Time in seconds left in current interval. Writing to Timeleft will restart the observation interval.')
isdnCreditsCurrentInCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsCurrentInCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsCurrentInCon.setDescription('Current number of incoming connections.')
isdnCreditsCurrentOutCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsCurrentOutCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsCurrentOutCon.setDescription('Current number of outgoing connections.')
isdnCreditsTotalInCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsTotalInCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsTotalInCon.setDescription('Total count of incoming connections during the observation interval.')
isdnCreditsTotalOutCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsTotalOutCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsTotalOutCon.setDescription('Total count of outgoing connections during the observation interval.')
isdnCreditsTotalMaxCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsTotalMaxCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsTotalMaxCon.setDescription('Maximum number of simultaniously established connections during the observation interval.')
isdnCreditsTotalCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsTotalCharge.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsTotalCharge.setDescription('Total accounted charge during the observation interval.')
isdnCreditsTotalInDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsTotalInDuration.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsTotalInDuration.setDescription('Total connect time of incoming connections during the observation interval.')
isdnCreditsTotalOutDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnCreditsTotalOutDuration.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsTotalOutDuration.setDescription('Total connect time of outgoing connections during the observation interval.')
isdnCreditsMaxCurrentInCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMaxCurrentInCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMaxCurrentInCon.setDescription('Maximum number of currently allowed incoming connections. -1 disables this limit.')
isdnCreditsMaxCurrentOutCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMaxCurrentOutCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMaxCurrentOutCon.setDescription('Maximum number of currently allowed outgoing connections. -1 disables this limit.')
isdnCreditsMaxCurrentCon = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 12, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isdnCreditsMaxCurrentCon.setStatus('mandatory')
if mibBuilder.loadTexts: isdnCreditsMaxCurrentCon.setDescription('Maximum number of currently allowed connections in both directions. -1 disables this limit.')
isdnIfSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isdnIfSlips.setStatus('mandatory')
if mibBuilder.loadTexts: isdnIfSlips.setDescription('Slip conditions detected since startup. Flags that the frequency of receive clock is different than frequency of internal system clock.')
mibBuilder.exportSymbols("BIANCA-BOX-ISDN-MIB", isdnCallHistoryTransmitErrors=isdnCallHistoryTransmitErrors, isdnCallReceivedPackets=isdnCallReceivedPackets, isdnDspDirection=isdnDspDirection, isdnX31IsdnIfIndex=isdnX31IsdnIfIndex, isdnCallHistoryLLC=isdnCallHistoryLLC, isdnChTransmitPackets=isdnChTransmitPackets, isdnCallState=isdnCallState, isdnCallReceivedOctets=isdnCallReceivedOctets, isdnCallHistoryReceivedOctets=isdnCallHistoryReceivedOctets, isdnCallHistoryReceivedErrors=isdnCallHistoryReceivedErrors, isdnStkStatus=isdnStkStatus, isdnStkClearAllCalls=isdnStkClearAllCalls, isdnCreditsMaxCurrentInCon=isdnCreditsMaxCurrentInCon, HexValue=HexValue, internet=internet, isdnCallHistoryLocalCause=isdnCallHistoryLocalCause, isdnloginAllowRemoteSubaddress=isdnloginAllowRemoteSubaddress, isdnChEntry=isdnChEntry, isdnCallReference=isdnCallReference, isdnCallReceivedErrors=isdnCallReceivedErrors, isdnDChanX31Entry=isdnDChanX31Entry, isdnCallHistoryBC=isdnCallHistoryBC, isdn=isdn, isdnCallHLC=isdnCallHLC, isdnChThroughput=isdnChThroughput, isdnChState=isdnChState, isdnCreditsTotalOutDuration=isdnCreditsTotalOutDuration, isdnIfTable=isdnIfTable, Date=Date, isdnCallTable=isdnCallTable, isdnCreditsMaxOutDuration=isdnCreditsMaxOutDuration, isdnloginAllowTable=isdnloginAllowTable, isdnCallHistory1TR6Cause=isdnCallHistory1TR6Cause, isdnCallHistoryScreening=isdnCallHistoryScreening, isdnIfEntry=isdnIfEntry, bintec=bintec, isdnCallHistoryTable=isdnCallHistoryTable, isdnCallHistoryRemoteNumber=isdnCallHistoryRemoteNumber, isdnIfAutoconfig=isdnIfAutoconfig, isdnChTransmitErrors=isdnChTransmitErrors, isdnloginAllowRemoteNumber=isdnloginAllowRemoteNumber, isdnCreditsTotalCharge=isdnCreditsTotalCharge, isdnCreditsCurrentInCon=isdnCreditsCurrentInCon, isdnCreditsTotalInCon=isdnCreditsTotalInCon, isdnCallHistoryChannel=isdnCallHistoryChannel, isdnCallHistoryChargeInfo=isdnCallHistoryChargeInfo, isdnStkEntry=isdnStkEntry, isdnIfAutoconfigState=isdnIfAutoconfigState, bibo=bibo, isdnloginAllowStkNumber=isdnloginAllowStkNumber, isdnCallScreening=isdnCallScreening, isdnCallHistoryLocalSubaddress=isdnCallHistoryLocalSubaddress, isdnCallHistoryReceivedPackets=isdnCallHistoryReceivedPackets, isdnCreditsMaxInDuration=isdnCreditsMaxInDuration, isdnCreditsTotalInDuration=isdnCreditsTotalInDuration, isdnChIsdnIfIndex=isdnChIsdnIfIndex, isdnCallHistoryType=isdnCallHistoryType, isdnX31TeiValue=isdnX31TeiValue, isdnCallHistoryDuration=isdnCallHistoryDuration, isdnCallLocalSubaddress=isdnCallLocalSubaddress, isdnDspItem=isdnDspItem, isdnCreditsTotalOutCon=isdnCreditsTotalOutCon, isdnStkTeiValue=isdnStkTeiValue, isdnCallIsdnIfIndex=isdnCallIsdnIfIndex, isdnChReceivedErrors=isdnChReceivedErrors, isdnStkNumber=isdnStkNumber, isdnCallHistoryLocalNumber=isdnCallHistoryLocalNumber, isdnDispatchTable=isdnDispatchTable, isdnX31TeiProc=isdnX31TeiProc, isdnDspLocalSubaddress=isdnDspLocalSubaddress, isdnIfActivates=isdnIfActivates, isdnCreditsMaxInCon=isdnCreditsMaxInCon, isdnCallRemoteSubaddress=isdnCallRemoteSubaddress, isdnCallHistoryRemoteSubaddress=isdnCallHistoryRemoteSubaddress, isdnCallHistoryTransmitOctets=isdnCallHistoryTransmitOctets, isdnCreditsMaxCurrentCon=isdnCreditsMaxCurrentCon, enterprises=enterprises, isdnCallHistoryCharge=isdnCallHistoryCharge, isdnIfMode=isdnIfMode, isdnStkDialOutPrefix=isdnStkDialOutPrefix, isdnloginAllowScreening=isdnloginAllowScreening, isdnCallLLC=isdnCallLLC, isdnCreditsTimeleft=isdnCreditsTimeleft, isdnStkTable=isdnStkTable, isdnCallInfo=isdnCallInfo, isdnCallTransmitOctets=isdnCallTransmitOctets, isdnCallDspItem=isdnCallDspItem, isdnCreditsTotalMaxCon=isdnCreditsTotalMaxCon, isdnDispatchEntry=isdnDispatchEntry, isdnChType=isdnChType, isdnloginAllowEntry=isdnloginAllowEntry, isdnDspSlot=isdnDspSlot, isdnIfUsePowerDetector=isdnIfUsePowerDetector, isdnCallHistoryIsdnIfIndex=isdnCallHistoryIsdnIfIndex, org=org, isdnCreditsEntry=isdnCreditsEntry, isdnCallAge=isdnCallAge, isdnIfIndex=isdnIfIndex, isdnStkTeiProc=isdnStkTeiProc, isdnCallHistoryInfo=isdnCallHistoryInfo, isdnCallHistoryEntry=isdnCallHistoryEntry, isdnCallTransmitPackets=isdnCallTransmitPackets, isdnCallServiceIndicator=isdnCallServiceIndicator, isdnIfSlips=isdnIfSlips, isdnCreditsMaxCharge=isdnCreditsMaxCharge, isdnCallHistoryStkNumber=isdnCallHistoryStkNumber, isdnCreditsMaxCurrentOutCon=isdnCreditsMaxCurrentOutCon, isdnIfTimerT3=isdnIfTimerT3, isdnHistoryMaxEntries=isdnHistoryMaxEntries, isdnStkProtocolProfile=isdnStkProtocolProfile, isdnCallEntry=isdnCallEntry, isdnIfDescription=isdnIfDescription, isdnCallRemoteNumber=isdnCallRemoteNumber, isdnStkSPID=isdnStkSPID, isdnChTransmitOctets=isdnChTransmitOctets, isdnIfBchannelControl=isdnIfBchannelControl, isdnIfLayer1State=isdnIfLayer1State, isdnChReceivedOctets=isdnChReceivedOctets, isdnCreditsCurrentOutCon=isdnCreditsCurrentOutCon, isdnChNumber=isdnChNumber, isdnChBundle=isdnChBundle, isdnDspUnit=isdnDspUnit, isdnCallCharge=isdnCallCharge, isdnDspMode=isdnDspMode, isdnCallStkNumber=isdnCallStkNumber, isdnDspLocalNumber=isdnDspLocalNumber, isdnCreditsSurveillance=isdnCreditsSurveillance, isdnCreditsSubsysNumber=isdnCreditsSubsysNumber, isdnIfNumberOfChannels=isdnIfNumberOfChannels, isdnCallType=isdnCallType, isdnCallChargeInfo=isdnCallChargeInfo, isdnCallHistoryDSS1Cause=isdnCallHistoryDSS1Cause, isdnCreditsTable=isdnCreditsTable, isdnLoginOnPPPDispatch=isdnLoginOnPPPDispatch, isdnDspUserName=isdnDspUserName, isdnCreditsMeasuretime=isdnCreditsMeasuretime, isdnCallLocalNumber=isdnCallLocalNumber, isdnStkConfiguration=isdnStkConfiguration, isdnChTable=isdnChTable, isdnStkLayer2State=isdnStkLayer2State, isdnCallAddInfo=isdnCallAddInfo, isdnCallHistoryHLC=isdnCallHistoryHLC, isdnCallTransmitErrors=isdnCallTransmitErrors, isdnIfTimeouts=isdnIfTimeouts, isdnDChanX31Table=isdnDChanX31Table, isdnIfDeactivates=isdnIfDeactivates, isdnIfActivationRequest=isdnIfActivationRequest, isdnDspBearer=isdnDspBearer, private=private, isdnStkIsdnIfIndex=isdnStkIsdnIfIndex, isdnCallHistoryTime=isdnCallHistoryTime, isdnCallHistoryServiceIndicator=isdnCallHistoryServiceIndicator, isdnCallHistoryTransmitPackets=isdnCallHistoryTransmitPackets, isdnCreditsMaxOutCon=isdnCreditsMaxOutCon, isdnCallHistoryAddInfo=isdnCallHistoryAddInfo, dod=dod, isdnStkBchannels=isdnStkBchannels, isdnDspStkNumber=isdnDspStkNumber, isdnX31AssignedTo=isdnX31AssignedTo, isdnAccountingTemplate=isdnAccountingTemplate, isdnCallChannel=isdnCallChannel, isdnCallBC=isdnCallBC, isdnCallHistoryDspItem=isdnCallHistoryDspItem, isdnChReceivedPackets=isdnChReceivedPackets)

#
# PySNMP MIB module APPIAN-TRUNK-PPP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APPIAN-TRUNK-PPP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:24:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
acTrunks, = mibBuilder.importSymbols("APPIAN-SMI-MIB", "acTrunks")
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, ObjectIdentity, IpAddress, NotificationType, Counter64, Integer32, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, ModuleIdentity, TimeTicks, Unsigned32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "ObjectIdentity", "IpAddress", "NotificationType", "Counter64", "Integer32", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "ModuleIdentity", "TimeTicks", "Unsigned32", "iso")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
acPppTrunk = ModuleIdentity((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3))
acPppTrunk.setRevisions(('1900-03-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: acPppTrunk.setRevisionsDescriptions(('Appian Initial release.',))
if mibBuilder.loadTexts: acPppTrunk.setLastUpdated('0003200000Z')
if mibBuilder.loadTexts: acPppTrunk.setOrganization('Appian Communications, Inc.')
if mibBuilder.loadTexts: acPppTrunk.setContactInfo('Gerry Pednault')
if mibBuilder.loadTexts: acPppTrunk.setDescription('Appian Communications PPP/MLPPP Services MIB.')
acPppTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1), )
if mibBuilder.loadTexts: acPppTrunkTable.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkTable.setDescription("A table containing PPP-link specific configuration information. This table is created, with reasonable defaults, whenever the associated acTrunkTable acTrunkProt field is set to 'PPP' or 'MLPPP'. Managment of this record is required only when it is desired to change the reasonable default. ")
acPppTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1), ).setIndexNames((0, "APPIAN-TRUNK-PPP-MIB", "acPppTrunkIndex"))
if mibBuilder.loadTexts: acPppTrunkEntry.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkEntry.setDescription('Configuration information about a particular PPP Link.')
acPppTrunkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: acPppTrunkIndex.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkIndex.setDescription('The trunk entry that this PPP / MLPPP configuration is associated.')
acPppTrunkMru = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 2048)).clone(1520)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkMru.setStatus('deprecated')
if mibBuilder.loadTexts: acPppTrunkMru.setDescription('This attribute has been deprecated - it no longer has an effect.')
acPppTrunkMrru = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 2048)).clone(1520)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkMrru.setStatus('deprecated')
if mibBuilder.loadTexts: acPppTrunkMrru.setDescription('This attribute has been deprecated - it no longer has an effect.')
acPppTrunkSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("long", 0), ("short", 1))).clone('long')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkSeqNum.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkSeqNum.setDescription('Defines the type of multilink sequence number to use. There are two possible sequence number types: long and short. Long sequence numbers are 24 bit values. Short sequence numbers are 12 bit values. The default is the PPP standard of long sequence numbers')
acPppTrunkMagicNumberEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkMagicNumberEnable.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkMagicNumberEnable.setDescription('Enables the inclusion of magic numbers in LCP messages. This, in conjunction with LCP echo is useful to detect non-transitory loopback conditions. This feature defaults to enabled (True).')
acPppTrunkLCPEchoEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkLCPEchoEnable.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkLCPEchoEnable.setDescription('Enables the OSAP initiation of LCP Echo message sequence processing. This attribute also controls link keepalive processing which is based upon LCP echo processing. This feature defaults to enabled (True).')
acPppTrunkLCPEchoInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkLCPEchoInterval.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkLCPEchoInterval.setDescription('Time in seconds between OSAP initiated echo sequences. The default is 60 seconds. The range is an integer which is expressed in seconds supporting 1 second to 1 hour in length. This value has a direct relationship to how long it takes to detect a PPP link down condition via keepalive processing. The lower this value the quicker a PPP link down condition will be detected. The default for this value is 1')
acPppTrunkMgmtAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkMgmtAccess.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkMgmtAccess.setDescription('This attribute controls how a PPP trunk starts up. It is used to indicate if this is an inband managment trunk. TRUE indicates the trunk can be exclusively used for inband managment. FALSE indicates the trunk is a data trunk only. A PPP trunk can not be used for inband managment and data passing at the same time. The default for this attribute is FALSE')
acPppTrunkIPCPAddressEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkIPCPAddressEnable.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkIPCPAddressEnable.setDescription('This attribute controls if IP address negotiation occurs during the IPCP phase of a PPP trunk startup. If this attribute is set to TRUE the IP address negotiation will occur. If this attribute is set to FALSE then IP address negotiation will not occur. The default for this attribute will be FALSE')
acPppTrunkMaxTerminate = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 10), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkMaxTerminate.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkMaxTerminate.setDescription('Max-Terminate indicates the number of Terminate-Request packets sent without receiving a Terminate-Ack before assuming that the peer is unable to respond.')
acPppTrunkMaxConfigure = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 11), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkMaxConfigure.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkMaxConfigure.setDescription('Max-Configure indicates the number of Configure-Request packets sent without receiving a valid Configure-Ack, Configure-Nak or Configure-Reject before assuming that the peer is unable to respond.')
acPppTrunkMaxFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 6, 3, 1, 1, 12), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acPppTrunkMaxFailure.setStatus('current')
if mibBuilder.loadTexts: acPppTrunkMaxFailure.setDescription('Max-Failure indicates the number of Configure-Nak packets sent without sending a Configure-Ack before assuming that configuration is not converging.')
mibBuilder.exportSymbols("APPIAN-TRUNK-PPP-MIB", acPppTrunkMaxTerminate=acPppTrunkMaxTerminate, acPppTrunkLCPEchoInterval=acPppTrunkLCPEchoInterval, acPppTrunk=acPppTrunk, acPppTrunkMgmtAccess=acPppTrunkMgmtAccess, acPppTrunkMrru=acPppTrunkMrru, acPppTrunkMagicNumberEnable=acPppTrunkMagicNumberEnable, acPppTrunkIndex=acPppTrunkIndex, acPppTrunkIPCPAddressEnable=acPppTrunkIPCPAddressEnable, acPppTrunkMaxConfigure=acPppTrunkMaxConfigure, acPppTrunkMru=acPppTrunkMru, acPppTrunkTable=acPppTrunkTable, acPppTrunkSeqNum=acPppTrunkSeqNum, acPppTrunkEntry=acPppTrunkEntry, PYSNMP_MODULE_ID=acPppTrunk, acPppTrunkMaxFailure=acPppTrunkMaxFailure, acPppTrunkLCPEchoEnable=acPppTrunkLCPEchoEnable)

#
# PySNMP MIB module CISCO-SWITCH-ENGINE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-SWITCH-ENGINE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:52:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoPort, CiscoNetworkProtocol = mibBuilder.importSymbols("CISCO-TC", "CiscoPort", "CiscoNetworkProtocol")
VlanIndex, = mibBuilder.importSymbols("CISCO-VTP-MIB", "VlanIndex")
entPhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
ifIndex, InterfaceIndexOrZero, OwnerString = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero", "OwnerString")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
MplsVpnId, = mibBuilder.importSymbols("MPLS-VPN-MIB", "MplsVpnId")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
IpAddress, Gauge32, NotificationType, Counter64, iso, Counter32, Integer32, ObjectIdentity, Unsigned32, TimeTicks, Bits, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Gauge32", "NotificationType", "Counter64", "iso", "Counter32", "Integer32", "ObjectIdentity", "Unsigned32", "TimeTicks", "Bits", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
RowStatus, TruthValue, MacAddress, TimeStamp, TimeInterval, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TruthValue", "MacAddress", "TimeStamp", "TimeInterval", "TextualConvention", "DisplayString")
ciscoSwitchEngineMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 97))
ciscoSwitchEngineMIB.setRevisions(('2013-02-13 00:00', '2012-03-12 00:00', '2010-12-17 00:00', '2008-11-11 00:00', '2008-01-29 00:00', '2005-09-16 00:00', '2005-04-12 00:00', '2004-11-15 00:00', '2004-06-09 00:00', '2003-11-07 00:00', '2003-08-20 00:00', '2003-06-10 00:00', '2003-05-06 00:00', '2003-02-21 00:00', '2002-08-05 00:00', '2002-02-07 00:00', '2001-10-26 00:00', '2001-09-13 00:00', '2001-05-16 00:00', '2001-03-09 00:00', '2000-06-23 00:00', '2000-01-31 11:30', '1999-12-09 11:30', '1998-06-24 11:30', '1998-05-28 11:30',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoSwitchEngineMIB.setRevisionsDescriptions(('Add enumerated value 37 - 85 to cseTcamResourceType.', 'Add cseStatisticsFlowGroup1.', 'Add the following new enumerations to cseTcamResourceType: dgtSgtRegion(31), anyAnyRegion(32), tcamALabel(33), tcamBLabel(34), destInfoIn(35) and destInfoOut(36).', 'Add new enumerations to cseTcamResourceType.', 'Add cseL3SwitchedPktsPerSecGroup. Add cseCacheStatisticsGroup. Add new enumerations to cseTcamResourceType. Add new enumerations to cseFlowIPFlowMask object.', 'Add cseFlowMcastMgmtGroup2. Deprecate the objects: cseFlowMcastQuerySrc, cseFlowMcastQueryGrp, cseFlowMcastResultGrp, cseFlowMcastResultSrc. Add new enumerations to cseFlowMcastQueryMask.', 'Add new enumerations to cseFlowIPFlowMask object. Add ingressInterfaceMapping and egressInterfaceMapping enumerations to cseTcamResourceType object.', 'Add cseMetUsageGroup.', 'Add the following Groups: cseNetflowASInfoExportGroup cseNetflowPerVlanIfGroup', 'Add cseErrorStatsLCTable.', 'Add the following tables to support forwarding information base: cseCefFibTable, cseCefAdjacencyTable. Add the following table to support TCAM (Ternary Content Addressable Memory) resource usage: cseTcamUsageTable. Add default value for the following objects: cseFlowQuerySource, cseFlowQuerySourceMask, cseFlowQueryDestination, cseFlowQueryDestinationMask, cseFlowQueryOwner.', 'Deprecated the objects: cseNetflowLSExportHost, cseNetflowLSExportTransportNumber', 'Added the object cseFlowQuerySkipNFlows', 'Added the following objects and table: cseFlowLongAgingTime, cseNetFlowIfIndexEnable, cseFlowStatsTable, cseFlowExcludeTable. Modified the description of the following objects: cseL2IpPkts, cseL2IpxPkts, cseL2AssignedProtoPkts, cseL2OtherProtoPkts, cseL2HCIpPkts, cseL2HCIpxPkts, cseL2HCAssignedProtoPkts, cseL2HCOtherProtoPkts.', 'Added the following objects: cseFlowIPFlowMask, cseFlowIPXFlowMask, cseProtocolFilterEnable.', 'Added the objects in cseBridgedFlowStatsCtrlTable and cseErrorStatsTable. Added the following objects: cseL3VlanInUnicastPkts cseL3VlanInUnicastOctets cseL3VlanOutUnicastPkts cseL3VlanOutUnicastOctets.', 'Added the object cseFlowQueryTotalFlows', 'Added the follwowing objects o cseNetflowLSFilterSupport o cseNetflowLSFilterTable. Also created the new groups o cseNDEMandatoryGroup o cseNDESingleFilterGroup o cseNDEMultipleFiltersGroup', 'Added 4k Vlan support', 'Update the range of cseFlowEstablishedAgingTime, cseFlowIPXEstablishedAgingTime, cseFlowOperEstablishedAgingTime, cseFlowOperIPXAgingTime. Replace cseFlowQueryResult with cseFlowQueryResultingRows.', 'Added the following objects: o cseFlowOperEstablishedAgingTime. o cseFlowOperFastAgingTime. o cseFlowOperFastAgePktThreshold. o cseFlowOperIPXAgingTime.', 'Added one High Capacity L2 Statistics table, an extension of cseL2StatsTable and new objects in NetflowLS group for new netflow export features. Also added a new enum type of cseRouterFlowMask to support L3 multicast.', 'Added MIB objects to manage Switch Engine (SE) portion of Multicast MLS control protocol.', 'Added 2 groups, for the purging (clearing) of layer 3 unicast and multicast flow entries stored in the cache. Also added new objects for layer 3 flow statistics.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoSwitchEngineMIB.setLastUpdated('201302130000Z')
if mibBuilder.loadTexts: ciscoSwitchEngineMIB.setOrganization('Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoSwitchEngineMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-lan-switch-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoSwitchEngineMIB.setDescription("This MIB module defines management objects for Cisco Layer 2/3 switches. These devices may either have a single (central) switching engine entity or may consist of multiple (distributed) switching engine entities which are inter-connected via a common 'switching fabric'. In the central switching engine model, all the physical ports in the system are handled by the only switching engine in the system. In the distributed switching model, each switching engine will handle a set of 'local' physical ports and when necessary, packets are also switched between switching engines over the switching fabric. Cisco L2/L3 switching devices use regular routers to assist them in learning packet 'flows' by observing how a router routes a candidate flow. A flow is some combination of source network address, destination network address and the transport port numbers, as applicable. Once a flow is established (learned), all traffic belonging to that flow will be switched at Layer 3 by the switch engine, effectively bypassing the router, until the flow has been 'aged' out. Most Cisco L2/L3 switching devices employ built-in (internal) router module(s) for integrating Layer 3 switching with Layer 2 forwarding. However, they can also learn 'flows' through other physically-separate (external) Cisco routers that are connected to the switch-engine through the network.")
cseMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1))
cseL2Objects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1))
cseFlow = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2))
cseNetflowLS = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3))
cseL3Objects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4))
cseProtocolFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 5))
cseUcastCache = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6))
cseMcastCache = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7))
cseCef = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8))
cseTcamUsage = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 9))
cseMet = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 10))
class CiscoGauge64(TextualConvention, Counter64):
    description = 'This TC describes an object with a nonnegative integer value that may increase or decrease, with a maximum value of 2^64-1.'
    status = 'current'

class ControlStatus(TextualConvention, Integer32):
    description = 'This TC describes the current status of a controlled object value.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

class McastGroupIp(TextualConvention, IpAddress):
    description = 'This TC specifies an multicast group IP address, a class D IP address with the first byte in the range of 224 to 239.'
    status = 'current'
    displayHint = '1d.1d.1d.1d'

class FlowAddressComponent(TextualConvention, OctetString):
    description = "Represents a network layer address. The length and format of the address is protocol dependent as follows: ip 6 octets first 4 octets are the IP address in network order last 2 bytes is the transport's port number. ipx 10 octets first 4 octets are the net number last 6 octets are the host number"
    status = 'current'
    displayHint = '1x:'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(6, 6), ValueSizeConstraint(10, 10), )
cseL2StatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1), )
if mibBuilder.loadTexts: cseL2StatsTable.setStatus('current')
if mibBuilder.loadTexts: cseL2StatsTable.setDescription("A table containing switching engine's L2 statistics counters.")
cseL2StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: cseL2StatsEntry.setStatus('current')
if mibBuilder.loadTexts: cseL2StatsEntry.setDescription('A conceptual row containing L2 statistics maintained by a switching engine (identified by entPhysicalIndex). Each switching engine managed by this MIB module has an entry in this table.')
cseL2ForwardedLocalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2ForwardedLocalPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2ForwardedLocalPkts.setDescription('Number of packets received from ports local to this switching engine and forwarded at layer 2.')
cseL2ForwardedLocalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2ForwardedLocalOctets.setStatus('current')
if mibBuilder.loadTexts: cseL2ForwardedLocalOctets.setDescription('Number of octets in the packets received from ports local to this switching engine and forwarded at layer 2.')
cseL2ForwardedTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2ForwardedTotalPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2ForwardedTotalPkts.setDescription('Total number of packets received from all sources (local and over the fabric) and forwarded at layer 2 by this switching engine.')
cseL2NewAddressLearns = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2NewAddressLearns.setStatus('current')
if mibBuilder.loadTexts: cseL2NewAddressLearns.setDescription('Number of new MAC addresses learned by the switching engine.')
cseL2AddrLearnFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2AddrLearnFailures.setStatus('current')
if mibBuilder.loadTexts: cseL2AddrLearnFailures.setDescription('Number of MAC addresses failed to be learned because the L2 forwarding address table was full. If the value keeps increasing, the network topology should be reconfigured.')
cseL2DstAddrLookupMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2DstAddrLookupMisses.setStatus('current')
if mibBuilder.loadTexts: cseL2DstAddrLookupMisses.setDescription('Number of misses during destination MAC address table lookups. A few misses happen normally. Large numbers of misses occur as a result of cseL2AddrLearnFailures.')
cseL2IpPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2IpPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2IpPkts.setDescription('Number of packets belonging to the IP family received by this switching engine from all sources. This value includes L3 switched packets.')
cseL2IpxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2IpxPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2IpxPkts.setDescription('Number of packets belonging to the IPX family received by this switching engine from all sources. This value includes L3 switched packets.')
cseL2AssignedProtoPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2AssignedProtoPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2AssignedProtoPkts.setDescription('Number of packets belonging to an assigned group of network protocols (typically AppleTalk, DecNet and Vines) received by this switching engine from all sources. This value includes L3 switched packets.')
cseL2OtherProtoPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2OtherProtoPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2OtherProtoPkts.setDescription('Number of packets belonging to all other protocol families, received by this switching engine from all sources. This value includes L3 switched packets.')
cseL2StatsHCTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2), )
if mibBuilder.loadTexts: cseL2StatsHCTable.setStatus('current')
if mibBuilder.loadTexts: cseL2StatsHCTable.setDescription('Contains the High Capacity L2 Statistics extensions to the cseL2StatsTable.')
cseL2StatsHCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: cseL2StatsHCEntry.setStatus('current')
if mibBuilder.loadTexts: cseL2StatsHCEntry.setDescription('Contains the High Capacity L2 Statistics extensions to cseL2StatsEntry. These objects will be created by the agent for all cseL2StatsEntries it deems appropriate.')
cseL2HCOverflowForwardedLocalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCOverflowForwardedLocalPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCOverflowForwardedLocalPkts.setDescription('The number of times the associated cseL2ForwardedLocalPkts counter has overflowed.')
cseL2HCForwardedLocalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCForwardedLocalPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCForwardedLocalPkts.setDescription('Number of packets received from ports local to this switching engine and forwarded at layer 2.')
cseL2HCOverflowForwardedTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCOverflowForwardedTotalPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCOverflowForwardedTotalPkts.setDescription('The number of times the associated cseL2ForwardeTotalPkts counter has overflowed.')
cseL2HCForwardedTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCForwardedTotalPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCForwardedTotalPkts.setDescription('Total number of packets received from all sources (local and over the fabric) and forwarded at layer 2 by this switching engine.')
cseL2HCOverflowIpPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCOverflowIpPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCOverflowIpPkts.setDescription('The number of times the associated cseL2IpPkts counter has overflowed.')
cseL2HCIpPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCIpPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCIpPkts.setDescription('Number of packets belonging to the IP family received by this switching engine from all sources. This value includes L3 switched packets.')
cseL2HCOverflowIpxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCOverflowIpxPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCOverflowIpxPkts.setDescription('The number of times the associated cseL2IpxPkts counter has overflowed.')
cseL2HCIpxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCIpxPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCIpxPkts.setDescription('Number of packets belonging to the IPX family received by this switching engine from all sources. This value includes L3 switched packets.')
cseL2HCOverflowAssignedProtoPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCOverflowAssignedProtoPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCOverflowAssignedProtoPkts.setDescription('The number of times the associated cseL2HCAssignedProtoPkts counter has overflowed.')
cseL2HCAssignedProtoPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCAssignedProtoPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCAssignedProtoPkts.setDescription('Number of packets belonging to an assigned group of network protocols (typically AppleTalk, DecNet and Vines) received by this switching engine from all sources. This value includes L3 switched packets.')
cseL2HCOverflowOtherProtoPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCOverflowOtherProtoPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCOverflowOtherProtoPkts.setDescription('The number of times the associated cseL2HCOtherProtoPkts counter has overflowed.')
cseL2HCOtherProtoPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 1, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL2HCOtherProtoPkts.setStatus('current')
if mibBuilder.loadTexts: cseL2HCOtherProtoPkts.setDescription('Number of packets belonging to all other protocol families, received by this switching engine from all sources. This value includes L3 switched packets.')
cseFlowEstablishedAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowEstablishedAgingTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowEstablishedAgingTime.setDescription('The adminstrative aging time for IP established flows. The default value for this object is implementation specific. If the cseFlowEstablishedAgingTime is not configured to the appropriate value, it will be adjusted to the closest value. The corresponding operational object, taken effect on the a device, is cseFlowOperIPEstablishedAgingTime.')
cseFlowFastAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 2), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowFastAgingTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowFastAgingTime.setDescription('The administrative fast aging time for the established flow entries, that have less number of packets than the value set in the cseFlowFastAgePktThreshold, switched within this time. Setting to value of 0 turns off fast aging. The default value for this object is implementation specific. If the cseFlowFastAgingTime is not configured to the appropriate value, it will be adjusted to the closest value. The corresponding operational object, taken effect on the device, is cseFlowOperFastAgingTime.')
cseFlowFastAgePktThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 3), Unsigned32()).setUnits('packets').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowFastAgePktThreshold.setStatus('current')
if mibBuilder.loadTexts: cseFlowFastAgePktThreshold.setDescription('The administrative packet threshold setting for the cseFlowFastAgingTime. The default for Fast Aging Packet Threshold is 0, i.e. no packets switched within the time set in cseFlowFastAgingTime, after an L3 flow was established. If the cseFlowFastAgingTime is not configured to the appropriate value, it will be adjusted to the closest value. The corresponding operational object, taken effect on the device, is cseFlowOperFastAgePktThreshold.')
cseRouterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 4), )
if mibBuilder.loadTexts: cseRouterTable.setStatus('current')
if mibBuilder.loadTexts: cseRouterTable.setDescription('A table containing information about all routers that are discovered by the switch, including internal and external routers.')
cseRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 4, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseRouterIndex"))
if mibBuilder.loadTexts: cseRouterEntry.setStatus('current')
if mibBuilder.loadTexts: cseRouterEntry.setDescription('A conceptual row in the cseRouterTable containing information about a router. A row appears either directly through dynamic learning or indirectly through management configuration (via SNMP,by creating an entry in the cseStaticExtRouterTable or via CLI).')
cseRouterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 4, 1, 1), IpAddress())
if mibBuilder.loadTexts: cseRouterIndex.setStatus('current')
if mibBuilder.loadTexts: cseRouterIndex.setDescription("The router's IP address which is used to uniquely identify it for L3 flows.")
cseRouterFlowMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("dstOnly", 1), ("srcDst", 2), ("fullFlow", 3), ("notApplicable", 4), ("srcDstVlan", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseRouterFlowMask.setStatus('current')
if mibBuilder.loadTexts: cseRouterFlowMask.setDescription('The IP type of mask configured for the router represented by this row. Each flow known to the switching engine has a mask which is applied to all packets in order to compare them to that flow. Each hardware-learned flow has the mask configured for the router which logically forwards that flow.')
cseRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseRouterName.setStatus('current')
if mibBuilder.loadTexts: cseRouterName.setDescription('DNS name (if available) of the router.')
cseRouterStatic = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 4, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseRouterStatic.setStatus('current')
if mibBuilder.loadTexts: cseRouterStatic.setDescription('If the value of the object is true, this router was configured via SNMP or CLI. Otherwise, this router was learned automatically.')
cseRouterIpxFlowMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dstOnly", 1), ("srcDst", 2), ("fullFlow", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseRouterIpxFlowMask.setStatus('current')
if mibBuilder.loadTexts: cseRouterIpxFlowMask.setDescription('The IPX type of mask configured for the router represented by this row. Each flow known to the switching engine has a mask which is applied to all packets in order to compare them to that flow. Each hardware-learned flow has the mask configured for the router which logically forwards that flow.')
cseStaticExtRouterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 5), )
if mibBuilder.loadTexts: cseStaticExtRouterTable.setStatus('current')
if mibBuilder.loadTexts: cseStaticExtRouterTable.setDescription('A table of external routers which are enabled for Layer 3 IP switching by the switching engine. This table may contain routers that have not yet been discovered by the device.')
cseStaticExtRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 5, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseRouterIndex"))
if mibBuilder.loadTexts: cseStaticExtRouterEntry.setStatus('current')
if mibBuilder.loadTexts: cseStaticExtRouterEntry.setDescription("A conceptual row in the cseStaticExtRouterTable for enabling an external router to be installed in the switch's router table. The entry is created and deleted by using cseStaticRouterStatus.")
cseStaticRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 5, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseStaticRouterName.setStatus('current')
if mibBuilder.loadTexts: cseStaticRouterName.setDescription('DNS name (if available) of the external router.')
cseStaticRouterOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 5, 1, 2), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseStaticRouterOwner.setStatus('current')
if mibBuilder.loadTexts: cseStaticRouterOwner.setDescription('String indicating the owner who created the static entry.')
cseStaticRouterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 5, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseStaticRouterStatus.setStatus('current')
if mibBuilder.loadTexts: cseStaticRouterStatus.setDescription('Used to manage creation and deletion of rows in this table. Once a row becomes active, values within that row cannot be modified except by deleting and creating the row.')
cseStaticRouterType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 5, 1, 4), Bits().clone(namedValues=NamedValues(("unicast", 0), ("multicast", 1))).clone(namedValues=NamedValues(("unicast", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseStaticRouterType.setStatus('current')
if mibBuilder.loadTexts: cseStaticRouterType.setDescription('Indicates if the router is included for unicast switching, or multicast switching, or both.')
cseRouterVlanTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 6), )
if mibBuilder.loadTexts: cseRouterVlanTable.setStatus('current')
if mibBuilder.loadTexts: cseRouterVlanTable.setDescription('The table listing the MAC address used by routers on particular VLANs.')
cseRouterVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 6, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseRouterIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseRouterMac"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseRouterVlan"))
if mibBuilder.loadTexts: cseRouterVlanEntry.setStatus('current')
if mibBuilder.loadTexts: cseRouterVlanEntry.setDescription('A conceptual row of the cseRouterVlanTable. An entry exists for each known VLAN of each known router.')
cseRouterMac = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 6, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseRouterMac.setStatus('current')
if mibBuilder.loadTexts: cseRouterMac.setDescription('Mac address used by the router for this VLAN number.')
cseRouterVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 6, 1, 2), VlanIndex())
if mibBuilder.loadTexts: cseRouterVlan.setStatus('current')
if mibBuilder.loadTexts: cseRouterVlan.setDescription("The Vlan number associated with the router's MAC address.")
cseRouterProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 6, 1, 3), Bits().clone(namedValues=NamedValues(("ip", 0), ("ipx", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseRouterProtocol.setStatus('current')
if mibBuilder.loadTexts: cseRouterProtocol.setDescription('Indicates which protocols are routed by this router on this VLAN using this Mac address.')
cseFlowMaxQueries = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMaxQueries.setStatus('current')
if mibBuilder.loadTexts: cseFlowMaxQueries.setDescription('Maximum number of query entries allowed to be outstanding at any time, in the cseFlowQueryTable. The typical value for this object is 5.')
cseFlowQueryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8), )
if mibBuilder.loadTexts: cseFlowQueryTable.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryTable.setDescription('A control table used to query the switching engine by specifying retrieval criteria for L3 flows. The resulting data for each instance of a query in this table is returned in the cseFlowDataTable. The maximum number of entries (rows) in this table cannot exceed the value returned by cseFlowMaxQueries.')
cseFlowQueryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryIndex"))
if mibBuilder.loadTexts: cseFlowQueryEntry.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryEntry.setDescription("A conceptual row of the cesFlowQueryTable used to setup retrieval criteria to search for L3 flows on a particular switching engine entity identified by entPhysicalIndex. The actual search is started by setting the value of cseFlowQueryStatus to 'active'. Once a row becomes active, values within the row cannot be modified, except by deleting and re-creating the row.")
cseFlowQueryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseFlowQueryIndex.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryIndex.setDescription('An arbitrary integer which uniquely identifies the control query among all those specified for the switching engine indicated by entPhysicalIndex.')
cseFlowQueryMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("dstOnly", 1), ("srcOrDst", 2), ("srcAndDst", 3), ("fullFlow", 4), ("ipxDstOnly", 5), ("ipxSrcAndDst", 6), ("any", 7))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQueryMask.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryMask.setDescription("Setting each value causes the appropriate action: 'dstOnly' - causes the creation of rows in the cseFlowDataTable corresponding to the current L3 flow information for the absolute destination IP address set in the cseFlowQueryDestination object in this table. If cseFlowQueryDestinationMask is also specified at the same time, it will be applied to the address part of cseFlowQueryDestination. 'srcOrDst' - causes the creation of rows in the cseFlowDataTable corresponding to the current L3 flow information for EITHER of the absolute IP addresses set in the cseFlowQueryDestination or cseFlowQuerySource objects. If either of cseFlowQueryDestinationMask and cseFlowQuerySourceMask objects are also specified at the same time, they will be applied to the respective address parts of cseFlowQueryDestination and cseFlowQuerySource objects. This option is typically used to setup queries for flows on traffic in either directions. 'srcAndDst' - causes the creation of rows in the cseFlowDataTable corresponding to the current L3 flow information for BOTH the absolute IP addresses set in the cseFlowQueryDestination and cseFlowQuerySource objects. If either of cseFlowQueryDestinationMask and cseFlowQuerySourceMask objects are also specified at the same time, they will be applied to the respective address parts of cseFlowQueryDestination and cseFlowQuerySource objects. This option is typically used to setup queries for flows on traffic in one direction only. 'fullFlow' - causes the creation of row(s) in the cseFlowDataTable exactly corresponding to the current L3 flow information for the complete IP flow (including the transport port numbers) set in the cseFlowQueryDestination and cseFlowQuerySource objects. If either of cseFlowQueryDestinationMask and cseFlowQuerySourceMask objects are also specified at the same time, they will be applied to the respective address parts of cseFlowQueryDestination and cseFlowQuerySource objects. This option is typically used to setup queries for flows on traffic for specific (TCP/UDP) port numbers corresponding to standard protocols such as FTP, WWW, TELNET, etc. 'ipxDstOnly' - causes the creation of rows in the cseFlowDataTable corresponding to the current L3 flow information for the absolute destination IPX address set in the cseFlowQueryDestination object in this table. If cseFlowQueryDestinationMask is also specified at the same time, it will be applied to the address part of cseFlowQueryDestination. 'ipxSrcAndDst' - causes the creation of rows in the cseFlowDataTable corresponding to the current L3 flow information for BOTH the absolute IPX addresses set in the cseFlowQueryDestination and cseFlowQuerySource objects. If either of cseFlowQueryDestinationMask and cseFlowQuerySourceMask objects are also specified at the same time, they will be applied to the respective address parts of cseFlowQueryDestination and cseFlowQuerySource objects. 'any' - returns all rows corresponding to all established flow entries in the cseFlowDataTable. Note: 1. The type FlowAddressComponent used for objects cseFlowQuerySource and cseFlowQueryDestination, has the network address part and also the transport port number part, if applicable. 2. The value of this object cannot be modified when the corresponding instance of cseFlowQueryStatus is 'active'.")
cseFlowQueryTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 3), Bits().clone(namedValues=NamedValues(("udp", 0), ("tcp", 1))).clone(namedValues=NamedValues(("udp", 0), ("tcp", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQueryTransport.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryTransport.setDescription("The IP transport protocol type specified for this query. Ignored for IPX flow queries. The value of this object cannot be modified when the corresponding instance of cseFlowQueryStatus is 'active'.")
cseFlowQuerySource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 4), FlowAddressComponent().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQuerySource.setStatus('current')
if mibBuilder.loadTexts: cseFlowQuerySource.setDescription("The source network address and port (if applicable). The value of this object cannot be modified when the corresponding instance of cseFlowQueryStatus is 'active'.")
cseFlowQuerySourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 5), FlowAddressComponent().clone(hexValue="FFFFFFFFFFFF")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQuerySourceMask.setStatus('current')
if mibBuilder.loadTexts: cseFlowQuerySourceMask.setDescription("The source address mask to be applied to the corresponding instance of cseFlowQuerySource. The value of this object cannot be modified when the corresponding instance of cseFlowQueryStatus is 'active'.")
cseFlowQueryDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 6), FlowAddressComponent().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQueryDestination.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryDestination.setDescription("The destination network address and port (if applicable). The value of this object cannot be modified when the corresponding instance of cseFlowQueryStatus is 'active'.")
cseFlowQueryDestinationMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 7), FlowAddressComponent().clone(hexValue="FFFFFFFFFFFF")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQueryDestinationMask.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryDestinationMask.setDescription("The destination address mask to be applied to the corresponding instance of cseFlowQueryDestination. The value of this object cannot be modified when the corresponding instance of cseFlowQueryStatus is 'active'.")
cseFlowQueryRouterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQueryRouterIndex.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryRouterIndex.setDescription("Index of the router for which the flows are available. An 'all-zero' IP address indicates that the query is for any router. The value of this object cannot be modified when the corresponding instance of cseFlowQueryStatus is 'active'.")
cseFlowQueryOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 9), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQueryOwner.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryOwner.setDescription('The manager entity that configured this entry and is therefore using the resources assigned to it.')
cseFlowQueryResultingRows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowQueryResultingRows.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryResultingRows.setDescription('The result status of the query. Possible values are: -1 - Either the query has not been initiated or the agent is busy processing this query instance. Time to completion of the query processing depends on the complexity of the query and the number of matches that satisfy this query. 0..2147483647 - The search has ended and this is the number of rows in the cseFlowDataTable, resulting from this query.')
cseFlowQueryResultTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 11), CiscoGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowQueryResultTotalPkts.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryResultTotalPkts.setDescription('The aggregate number of total packets switched by the system on all the flows matching this query. This is a snapshot value and is valid only when the corresponding instance of cseFlowQueryResultingRows is greater than or equal to 0.')
cseFlowQueryResultTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 12), CiscoGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowQueryResultTotalOctets.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryResultTotalOctets.setDescription('The aggregate number of total octets switched by the system on all the flows matching this query. This is a snapshot value and is valid only when the corresponding instance of cseFlowQueryResultingRows is greater than or equal to 0.')
cseFlowQueryResultAvgDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 13), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowQueryResultAvgDuration.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryResultAvgDuration.setDescription('The average duration of the flows matching this query. This is a snapshot value and is valid only when the corresponding instance of cseFlowQueryResultingRows is greater than or equal to 0.')
cseFlowQueryResultAvgIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 14), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowQueryResultAvgIdle.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryResultAvgIdle.setDescription('The elapsed time since the flows were last used, averaged over all flows matching this query. This is a snapshot value and is valid only when the corresponding instance of cseFlowQueryResultingRows is greater than or equal to 0.')
cseFlowQueryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQueryStatus.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryStatus.setDescription('The status object used to manage rows in this table. When set to active(1), the query is initiated. Once initiated, the value may not be modified until the value of cseFlowQueryResultingRows is greater than or equal to 0. However, this object can be set to active(1) only after all the appropriate objects for this query as defined by the value set in the cseFlowQueryMask object, have also been set. Once a row becomes active, values within the row cannot be modified, except by deleting and re-creating it.')
cseFlowQueryCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 16), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowQueryCreateTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryCreateTime.setDescription('Time when this query was created.')
cseFlowQueryTotalFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowQueryTotalFlows.setStatus('current')
if mibBuilder.loadTexts: cseFlowQueryTotalFlows.setDescription('The total number of L3 flows matching the query criterion.')
cseFlowQuerySkipNFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 8, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowQuerySkipNFlows.setStatus('current')
if mibBuilder.loadTexts: cseFlowQuerySkipNFlows.setDescription("The number of searched flows to be skipped before storing any L3 flows in cseFlowDataTable. This object can be used along with cseFloQueryTotalFlows object to skip previously found flows by setting the variable equal to the number of the associated rows in cseFlowDataTable, and only query the remaining flows in the table. Note that due to the dynamical nature of the L3 flows, the queried flows may be missed or repeated by setting this object. The value of this object cannot be modified when the corresponding instance of cseFlowQueryStatus is 'active'.")
cseFlowDataTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9), )
if mibBuilder.loadTexts: cseFlowDataTable.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataTable.setDescription('A table containing L3 flow information corresponding to all the completed queries setup in the cseFlowQueryTable, that were initiated on the switch engine(s).')
cseFlowDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseFlowDataIndex"))
if mibBuilder.loadTexts: cseFlowDataEntry.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataEntry.setDescription('A conceptual row of the cseFlowDataTable used to return information about one of the L3 flows which matched the search criteria set by the cseFlowQueryMask object in the corresponding instance of the cseFlowQueryTable.')
cseFlowDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseFlowDataIndex.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataIndex.setDescription('A number to uniquely identify a result entry that matches a particular query for a specific switching engine.')
cseFlowDataSrcMac = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataSrcMac.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataSrcMac.setDescription("Source Mac Address of the router's outgoing interface.")
cseFlowDataDstMac = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataDstMac.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataDstMac.setDescription('Destination Mac Address used to forward the packets in this flow.')
cseFlowDataStaticFlow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataStaticFlow.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataStaticFlow.setDescription('Indicates whether this flow was software-installed.')
cseFlowDataEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ipArpa", 1), ("ipxEthernet", 2), ("ipx802raw", 3), ("ipx802sap", 4), ("ipx802snap", 5), ("other", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataEncapType.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataEncapType.setDescription('Protocol encapsulation type used to forward packets in this flow to their destination.')
cseFlowDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 6), FlowAddressComponent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataSource.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataSource.setDescription('The source network address and the port (if appropriate) of this flow.')
cseFlowDataDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 7), FlowAddressComponent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataDestination.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataDestination.setDescription('The destination network address and port (if appropriate) of this flow.')
cseFlowDataDestVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 8), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataDestVlan.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataDestVlan.setDescription('The vlan number on which packets belonging to this flow are forwarded.')
cseFlowDataIpQOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataIpQOS.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataIpQOS.setDescription('Level of Quality of service for this IP flow. If it is not an IP flow, this object will not be instantiated.')
cseFlowDataIpQOSPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataIpQOSPolicy.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataIpQOSPolicy.setDescription('Level of the Quality of service policy for this IP flow. If it is not an IP flow, this object will not be instantiated.')
cseFlowDataWhenCreated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataWhenCreated.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataWhenCreated.setDescription('Time when this flow was created in the switching engine.')
cseFlowDataLastUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataLastUsed.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataLastUsed.setDescription('Time since this flow was last used to forward a packet by the switching engine.')
cseFlowDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataPkts.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataPkts.setDescription('A snapshot value of the number of packets forwarded on this flow at the time of corresponding query.')
cseFlowDataOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 9, 1, 14), CiscoGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowDataOctets.setStatus('current')
if mibBuilder.loadTexts: cseFlowDataOctets.setDescription('A snapshot value of octets forwarded on this flow at the time of corresponding query.')
cseFlowSwitchControlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 10), )
if mibBuilder.loadTexts: cseFlowSwitchControlTable.setStatus('current')
if mibBuilder.loadTexts: cseFlowSwitchControlTable.setDescription('A table used to control the L3 flow switching operation, per protocol type.')
cseFlowSwitchControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 10, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseFlowSwitchProtocol"))
if mibBuilder.loadTexts: cseFlowSwitchControlEntry.setStatus('current')
if mibBuilder.loadTexts: cseFlowSwitchControlEntry.setDescription('A conceptual row for the configuration of Flow switching feature for an L3 protocol type.')
cseFlowSwitchProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 10, 1, 1), CiscoNetworkProtocol())
if mibBuilder.loadTexts: cseFlowSwitchProtocol.setStatus('current')
if mibBuilder.loadTexts: cseFlowSwitchProtocol.setDescription('Protocol type for which this row instance. Only ip(1) and ipx(14) values are currently supported.')
cseFlowSwitchStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 10, 1, 2), ControlStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowSwitchStatus.setStatus('current')
if mibBuilder.loadTexts: cseFlowSwitchStatus.setDescription('The current status of the global flow switching capability for the specified L3 protocol type.')
cseFlowMcastMaxQueries = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastMaxQueries.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastMaxQueries.setDescription('Maximum number of query entries allowed to be outstanding at any time, in the cseFlowMcastQueryTable. The typical value for this object is 5.')
cseFlowMcastQueryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12), )
if mibBuilder.loadTexts: cseFlowMcastQueryTable.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryTable.setDescription("A control table used to query the switching engine by specifying retrieval criteria for IP multicast L3 flows. Each row instance in the table represents a query with its parameters. The resulting data for each instance of a query in this table is returned in the cseFlowMcastResultTable. The maximum number of entries (rows) in this table cannot exceed the value of cseFlowMcastMaxQueries object. Unlike unicast switched layer 3 flows, an IP multicast switched flow is created and installed by software, and is uniquely identified by flow's source IP address, and multicast group IP address. It is stored with input Vlan ID in the cache entry, so that the packets in the flow will not be replicated and forwarded to the receivers on the same (input) Vlan. Another difference is that all IP multicast hardware switched flows belonging to the same (source, group) are stored only on one switch engine on a Cisco L3 switch with distributed switch engines, whereas unicast flows identified by certain criterion may resident on multiple switch engines in the system.")
cseFlowMcastQueryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryIndex"))
if mibBuilder.loadTexts: cseFlowMcastQueryEntry.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryEntry.setDescription("A conceptual row of the cesMcastFlowQueryTable used to setup retrieval criteria to search for IP multicast L3 flows on all switching engine entities in the device. The actual search is started by setting the value of cseFlowMcastQueryStatus to 'active'. Once a row becomes active, values within the row cannot be modified, without setting the associated RowStatus object to 'notInService' first, or deleting and re-creating the row.")
cseFlowMcastQueryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseFlowMcastQueryIndex.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryIndex.setDescription('An arbitrary integer in the range of 1 to cseFlowMcastMaxQueries to identify this control query.')
cseFlowMcastQueryMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 2), Bits().clone(namedValues=NamedValues(("source", 0), ("group", 1), ("vlan", 2), ("router", 3), ("mvrf", 4), ("sourceip", 5), ("groupip", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQueryMask.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryMask.setDescription("This object is used to set up the query criterion for the multicast flows of interest. If any one of the defined BITs is set, then the value of the corresponding object in the same row instance will be used for the search. Specifically, if the 'source(0)' BIT is set, then the cseFlowMcastQuerySrc object will be included in the search criterion. If the group(1) BIT is set, then the cseFlowMcastQueryGrp object will be included in the search criterion. If the vlan(2) BIT is set, then the cseFlowMcastQuerySrcVlan object will be included in the search criterion. If the router(3) BIT is set, then the cseFlowMcastQueryRtrIndex object will be included in the search criterion. If the mvrf(4) BIT is set, then the cseFlowMcastQueryMvrf object will be included in the search criterion; If the sourceip(5) BIT is set, then the cseFlowMcastQueryAddrType and cseFlowMcastQuerySource objects will be included in the search criterion. If the groupip(6) BIT is set, then the cseFlowMcastQueryAddrType and cseFlowMcastQueryGroup objects will be included in the search criterion. If the source(0) or group(1) BIT is set, then the sourceip(5) or groupip(6) cannot be set, and vice-versa. If any of the BITs in this variable is cleared, the corresponding parameter object in the same row is treated as a wildcard. When the row is instantiated, the BITs in the variable will be cleared, and none of query parameter objects in this row will be instantiated. This will be considered as a wildcard search for flows on the default Multicast Virtual Private Network (MVPN) routing/forwarding (MVRF) instance. i.e. it will return all rows corresponding to all established multicast flow entries in the default MVRF, in cseFlowMcastResultTable. The address type of this wildcard search will be specified be cseFlowMcastQueryAddrType. It is SNMP managers' responsibility to set certain bits on in this object instance, if necessary, and the corresponding flow parameter variables to the appropriate values in order to setup the desired query criteria. The value of this object can not be altered when the corresponding instance of cseFlowMcastQueryStatus is 'active'.")
cseFlowMcastQuerySrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQuerySrc.setStatus('deprecated')
if mibBuilder.loadTexts: cseFlowMcastQuerySrc.setDescription("The source address of the IP multicast layer 3 flows. This object should be instantiated and assigned a proper IP address whenever the 'source' bit of cseFlowMcastQueryMask object in the same row is on. If the 'source' bit is set, and an appropriate IP address is assigned to this object, then only flows with the specified source address will be containing in the result table. If the 'source' bit in the associated cseFlowMcastQueryMask is cleared, this object is ignored during the query, and all flows will be considered regardless of their source IP address. This object is deprecated and replaced by cseFlowMcastQueryAddrType and cseFlowMcastQuerySource.")
cseFlowMcastQueryGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 4), McastGroupIp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQueryGrp.setStatus('deprecated')
if mibBuilder.loadTexts: cseFlowMcastQueryGrp.setDescription("The IP multicast group address of the queried flows. This object should be instantiated and set whenever the 'group' bit of the associated cseFlowMcastQueryMask object is on. If the 'group' bit is set, and a multicast group address is assigned to the object, only flows with the specified group address will be contained in the result table. If the 'group' bit in the associated cseFlowMcastQueryMask is cleared, this object is ignored during the query, and all flows will be considered regardless of their group address. This object is deprecated and replaced by cseFlowMcastQueryAddrType and cseFlowMcastQueryGroup.")
cseFlowMcastQuerySrcVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 5), VlanIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQuerySrcVlan.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQuerySrcVlan.setDescription("The source Vlan ID of the IP multicast layer 3 flows. This object should be instantiated and set whenever the 'vlan' bit of the associated cseFlowMcastQueryMask object is on. If the 'vlan' bit is set, and a Vlan ID is assigned to this object, only flows belonging to that vlan will be contained in the result table. If the 'vlan' bit in the associated cseFlowMcastQueryMask object is cleared, this object is ignored during the query, and all flows will be considered regardless of their vlan IDs.")
cseFlowMcastQueryRtrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 6), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQueryRtrIndex.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryRtrIndex.setDescription("Index of the router for which the multicast flows are available, that is the flows would be replicated and routed by the specified router, should the flows did not get switched. This object should be instantiated and set whenever the 'router' bit of the asociated cseFlowMcastQueryMask object is on. If the 'router' bit is set, and a router's IP address is assigned to this object, then only flows associated with that router will be contained in the result table. If the 'router' bit in the cseFlowMcastQueryMask object is cleared, this object is ignored during the query, and all flows will be considered regardless of the routers being switched.")
cseFlowMcastQuerySkipNFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQuerySkipNFlows.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQuerySkipNFlows.setDescription('The number of searched flows to be skipped before storing any multicast flows in cseFlowMcastResultTable. This object can be used along with cseFlowMcastQueryTotalFlows object to skip previously found flows by setting the variable equal to the number of the associated rows in cseFlowMcastResultTable, and only query the remaining flows in the table. Note that due to the dynamical nature of the L3 flows, the queried flows may be missed or repeated by setting this object.')
cseFlowMcastQueryOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 8), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQueryOwner.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryOwner.setDescription("The manager entity that configured this entry and is therefore using the resources assigned to it. It is used to model an administratively assigned name of the owner of a resource. It is recommended that this object have one or more the following information: IP address, management station name, network manager's name, location, or phone number.")
cseFlowMcastQueryTotalFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastQueryTotalFlows.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryTotalFlows.setDescription('The number of flows matching the query criterion.')
cseFlowMcastQueryRows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastQueryRows.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryRows.setDescription('Indicating the status of the query by following values: -1 - Either the query has not been started or the agent is still processing this query instance. It is the default value when the row is instantiated. 0..2147483647 - The search has ended and this is the number of rows in the cseFlowMcastResultTable, resulting from this query.')
cseFlowMcastQueryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQueryStatus.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryStatus.setDescription("The status object used to manage rows in this table. When set to 'active', the query of flows is initiated. This object can be set to active only after all the appropriate objects for this query as defined by the bits in the cseFlowMcastQueryMask object, have also been instantiated. The completion of the query is indicated by the value of cseFlowMcastQueryRows as soon as it becomes greater than or equal to 0. Once a row becomes active, values within the row cannot be modified without setting it to 'notInService' first, or just deleting and re-creating it. To abort a lengthy on-going query, setting this object to 'notInService', or 'destroy' will terminate a search if one is in progress, and cause the associated rows in cseFlowMcastResultTable, if any, to be deleted.")
cseFlowMcastQueryCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastQueryCreateTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryCreateTime.setDescription('Time when this query was last set to active.')
cseFlowMcastQueryMvrf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 13), MplsVpnId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQueryMvrf.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryMvrf.setDescription("The human-readable name of the Multicast Virtual Private Network (MVPN) routing/forwarding instance (MVRF). When the 'mvrf' bit of cseFlowMcastQueryMask object in the same row is on, an appropriate value should be specified and only flows with the specified MVRF name will be contained in the result table. If the 'mvrf' bit in the associated cseFlowMcastQueryMask is cleared, this object is ignored during the query, and all the flows corresponding to the default MVRF will be considered.")
cseFlowMcastQueryAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 14), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQueryAddrType.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryAddrType.setDescription('The Internet address type for this multicast search query.')
cseFlowMcastQuerySource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 15), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQuerySource.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQuerySource.setDescription("The source Internet address of the IP multicast layer 3 flows. When the 'sourceip' bit of cseFlowMcastQueryMask cseFlowMcastQueryMask object in the same row is on, an appropriate value should be specified and only flows with the specified source address will be contained in the result table. If the 'sourceip' bit in the associated cseFlowMcastQueryMask is cleared, this object is ignored during the query, and all flows will be considered regardless of their source address. The type of this address is determined by the value of the cseFlowMcastQueryAddrType object. The default value of this object is all zeros.")
cseFlowMcastQueryGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 12, 1, 16), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowMcastQueryGroup.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastQueryGroup.setDescription("The multicast group Internet address of the queried flows. When the 'mvrf' bit of cseFlowMcastQueryMask object in the same row is on, an appropriate value should be specified and only flows with the specified group address will be contained in the result table. If the 'groupip' bit in the associated cseFlowMcastQueryMask is cleared, this object is ignored during the query, and all flows will be considered regardless of their group address. The type of this address is determined by the value of the cseFlowMcastQueryAddrType object. The default value of this object is all zeros.")
cseFlowMcastResultTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13), )
if mibBuilder.loadTexts: cseFlowMcastResultTable.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultTable.setDescription('A table containing current IP multicast flow information corresponding to all the completed queries set up in the cseFlowMcastQueryTable, that were initiated on the switch engine(s). The query result will not become available until the current search completes.')
cseFlowMcastResultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryIndex"), (0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultIndex"))
if mibBuilder.loadTexts: cseFlowMcastResultEntry.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultEntry.setDescription('A conceptual row of cseFlowMcastResultTable, containing information about an IP multicast layer 3 flow that matchs the search criteria set in the corresponding row of cseFlowMcastQueryTable. This row instance is indexed by the query index (cseFlowMcastQueryIndex), the switch engine entity (entPhysicalIndex), and data entry index (cseFlowMcastResultIndex). The value of entPhysicalIndex object is assigned by Entity-MIB, and uniquely identifies a switching engine on which the IP multicast flow is stored.')
cseFlowMcastResultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cseFlowMcastResultIndex.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultIndex.setDescription('A positive integer which uniquely identify a result entry on a specific switching engine matching a particular query.')
cseFlowMcastResultGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 2), McastGroupIp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultGrp.setStatus('deprecated')
if mibBuilder.loadTexts: cseFlowMcastResultGrp.setDescription('The multicast group IP address of the multicast layer 3 flow. This object is deprecated and replaced by cseFlowMcastResultAddrType and cseFlowMcastResultGroup.')
cseFlowMcastResultSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultSrc.setStatus('deprecated')
if mibBuilder.loadTexts: cseFlowMcastResultSrc.setDescription('The source address of the multicast layer 3 flow. This object is deprecated and replaced by cseFlowMcastResultAddrType and cseFlowMcastResultSource.')
cseFlowMcastResultSrcVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 4), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultSrcVlan.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultSrcVlan.setDescription('The source Vlan ID of the IP multicast layer 3 flow.')
cseFlowMcastResultRtrIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultRtrIp.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultRtrIp.setDescription("The interface IP address of the router this multicast flow is switching for. Since IP multicast flows can only be established for a router's trunk ports, it is the primary IP address of the router's trunk link that connects to the switch.")
cseFlowMcastResultRtrMac = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultRtrMac.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultRtrMac.setDescription('The default MAC address of the router the multicast flow is switching for. Different multicast flows switching different ports of the same router will have the identical value of this object.')
cseFlowMcastResultCreatedTS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultCreatedTS.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultCreatedTS.setDescription('Time when the IP multicast flow was created.')
cseFlowMcastResultLastUsedTS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultLastUsedTS.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultLastUsedTS.setDescription('Time when this IP multicast flow was last used.')
cseFlowMcastResultPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultPkts.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultPkts.setDescription('The total number of multicast traffic packets forwarded for this flow (replicated packets are not counted).')
cseFlowMcastResultOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultOctets.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultOctets.setDescription('The total number of multicast traffic octets forwarded for this flow (replicated packets are not counted).')
cseFlowMcastResultDstVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultDstVlans.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultDstVlans.setDescription("A string of octets containing one bit per VLAN. Each octet within the value of this object specifies a set of eight VLANs, e.g. the first octet corresponding to VLANs with VlanIndex values of 0 through 7, the second octet to VLANs 8 through 15, etc. Within each octet, the most significant bit represents the lowest numbered VLAN, and the least significant bit represents the highest numbered VLAN, thus each vlan is represented by a single bit within the octet. The bits in this object will be set to '1' if the corresponding Vlans are in the out-going interface (vlan) list of the IP multicast flow described by this row instance.")
cseFlowMcastResultDstVlans2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultDstVlans2k.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultDstVlans2k.setDescription("A string of octets containing one bit per VLAN, with VlanIndex values of 1024 through 2047,with each octet within the value of this object specifies a set of eight VLANs, e.g. the first octet corresponding to VLANs with VlanIndex values of 1024 through 1031, the second octet to VLANs 1032 through 1039 etc. Within each octet, the most significant bit represents the lowest numbered VLAN, and the least significant bit represents the highest numbered VLAN, thus each vlan is represented by a single bit within the octet. The bits in this object will be set to '1' if the corresponding Vlans are in the out-going interface (vlan) list of the IP multicast flow described by this row instance.")
cseFlowMcastResultDstVlans3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultDstVlans3k.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultDstVlans3k.setDescription("A string of octets containing one bit per VLAN. With VlanIndex values of 2048 through 3071 with each octet within the value of this object specifies a set of eight VLANs, e.g. the first octet corresponding to VLANs with VlanIndex values of 2048 through 2055, the second octet to VLANs 2056 through 2063 etc. Within each octet, the most significant bit represents the lowest numbered VLAN, and the least significant bit represents the highest numbered VLAN, thus each vlan is represented by a single bit within the octet. The bits in this object will be set to '1' if the corresponding Vlans are in the out-going interface (vlan) list of the IP multicast flow described by this row instance.")
cseFlowMcastResultDstVlans4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultDstVlans4k.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultDstVlans4k.setDescription("A string of octets containing one bit per VLAN. With VlanIndex values of 3072 through 4095, with each octet within the value of this object specifies a set of eight VLANs, e.g. the first octet corresponding to VLANs with VlanIndex values of 3072 through 3079 the second octet to VLANs 3080 through 3087 etc. Within each octet, the most significant bit represents the lowest numbered VLAN, and the least significant bit represents the highest numbered VLAN, thus each vlan is represented by a single bit within the octet. The bits in this object will be set to '1' if the corresponding Vlans are in the out-going interface (vlan) list of the IP multicast flow described by this row instance.")
cseFlowMcastResultMvrf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 15), MplsVpnId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultMvrf.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultMvrf.setDescription('The MVRF to which this flow belongs to.')
cseFlowMcastResultAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 16), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultAddrType.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultAddrType.setDescription('The Internet address type of cseFlowMcastResultGroup and cseFlowMcastResultSource.')
cseFlowMcastResultGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 17), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultGroup.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultGroup.setDescription('The multicast group IP address of the multicast layer 3 flow.')
cseFlowMcastResultSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 18), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultSource.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultSource.setDescription('The source address of the multicast layer 3 flow.')
cseFlowMcastResultFlowType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("rpfMfd", 2), ("partialSC", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultFlowType.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultFlowType.setDescription('Indicates the type of multicast layer 3 flow. other - Multicast flow type is none of the followoing. rpfMfd - This flow is a RPF MFD flow. partial - This flow is a partial shortcut flow.')
cseFlowMcastResultHFlag1k2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultHFlag1k2k.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultHFlag1k2k.setDescription("A string of octets containing one bit per out-going interface (VLAN) with VlanIndex values of 0 through 2047. Each octet within the value of this object specifies a set of eight VLANs, e.g. the first octet corresponding to VLANs with VlanIndex values of 0 through 7, the second octet to VLANs 8 through 15, etc. Within each octet, the most significant bit represents the lowest numbered VLAN, and the least significant bit represents the highest numbered VLAN, thus each vlan is represented by a single bit within the octet. The bits in this object will be set to '1' if the multicast layer 3 flow described by this row instance is hardware switched on the corresponding VLAN. If the length of this string is less than 256 octets, any 'missing' octets are assumed to contain the value of zero.")
cseFlowMcastResultHFlag3k4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 13, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowMcastResultHFlag3k4k.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastResultHFlag3k4k.setDescription("A string of octets containing one bit per out-going interface (VLAN) with VlanIndex values of 2048 through 4095. Each octet within the value of this object specifies a set of eight VLANs, e.g. the first octet corresponding to VLANs with VlanIndex values of 2048 through 2055, the second octet to VLANs 2056 through 2063 etc. Within each octet, the most significant bit represents the lowest numbered VLAN, and the least significant bit represents the highest numbered VLAN, thus each vlan is represented by a single bit within the octet. The bits in this object will be set to '1' if the multicast layer 3 flow described by this row instance is hardware switched on the corresponding VLAN. If the length of this string is less than 256 octets, any 'missing' octets are assumed to contain the value of zero.")
cseFlowMcastSwitchStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 14), ControlStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowMcastSwitchStatus.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastSwitchStatus.setDescription('The current status of the global IP multicast flow switching capability. When enabled, the switch engine will be able to install multicast flow entries in its L3 forwarding table, and perform hardware assisted switching for the flows.')
cseFlowIPXEstablishedAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowIPXEstablishedAgingTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowIPXEstablishedAgingTime.setDescription('The administrative aging time for established IPX flows. The default value for this object is implementation specific. The corresponding operational object is cseFlowOperIPXAgingTime.')
cseStaticIpxExtRouterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 16), )
if mibBuilder.loadTexts: cseStaticIpxExtRouterTable.setStatus('current')
if mibBuilder.loadTexts: cseStaticIpxExtRouterTable.setDescription('A table of external routers which are enabled for Layer 3 IPX switching by the switching engine. This table may contain routers that have not yet been discovered by the device.')
cseStaticIpxExtRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 16, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseRouterIndex"))
if mibBuilder.loadTexts: cseStaticIpxExtRouterEntry.setStatus('current')
if mibBuilder.loadTexts: cseStaticIpxExtRouterEntry.setDescription("A conceptual row in the cseStaticIpxExtRouterTable for enabling an external router to be installed in the switch's router table. The entry is created and deleted by using cseStaticIpxRouterStatus.")
cseStaticIpxRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 16, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseStaticIpxRouterName.setStatus('current')
if mibBuilder.loadTexts: cseStaticIpxRouterName.setDescription('DNS name (if available) of the external router.')
cseStaticIpxRouterOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 16, 1, 2), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseStaticIpxRouterOwner.setStatus('current')
if mibBuilder.loadTexts: cseStaticIpxRouterOwner.setDescription('String indicating the owner who created the static entry.')
cseStaticIpxRouterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 16, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseStaticIpxRouterStatus.setStatus('current')
if mibBuilder.loadTexts: cseStaticIpxRouterStatus.setDescription('Used to manage creation and deletion of rows in this table. Once a row becomes active, values within that row cannot be modified except by deleting and creating the row.')
cseFlowOperEstablishedAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowOperEstablishedAgingTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowOperEstablishedAgingTime.setDescription('The operational aging time for IP established flows.')
cseFlowOperFastAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 18), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowOperFastAgingTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowOperFastAgingTime.setDescription('The operational fast aging time for the established flow entries, that have less number of packets than the value set in the cseFlowOperFastAgePktThreshold,switched within this time.')
cseFlowOperFastAgePktThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 19), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowOperFastAgePktThreshold.setStatus('current')
if mibBuilder.loadTexts: cseFlowOperFastAgePktThreshold.setDescription('The operational packet threshold for the cseFlowOperFastAgingTime.')
cseFlowOperIPXAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowOperIPXAgingTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowOperIPXAgingTime.setDescription('The operational aging time for established IPX flows.')
cseBridgedFlowStatsCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 21), )
if mibBuilder.loadTexts: cseBridgedFlowStatsCtrlTable.setStatus('current')
if mibBuilder.loadTexts: cseBridgedFlowStatsCtrlTable.setDescription('A table controls the reporting of intra-vlan statistics for bridged flow per vlan. When a vlan is created in a device supporting this table, a corresponding entry of this table will be added.')
cseBridgedFlowStatsCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 21, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseBridgedFlowVlan"))
if mibBuilder.loadTexts: cseBridgedFlowStatsCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: cseBridgedFlowStatsCtrlEntry.setDescription('A row instance contains the configuration to enable or disable the reporting of intra-vlan statistics for bridged flow per vlan.')
cseBridgedFlowVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 21, 1, 1), VlanIndex())
if mibBuilder.loadTexts: cseBridgedFlowVlan.setStatus('current')
if mibBuilder.loadTexts: cseBridgedFlowVlan.setDescription('Indicates the Vlan number on which the reporting of intra-vlan bridged flow statistics is configured.')
cseFlowBridgedFlowStatsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 21, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowBridgedFlowStatsEnable.setStatus('current')
if mibBuilder.loadTexts: cseFlowBridgedFlowStatsEnable.setDescription("Indicates whether intra-vlan bridged flow statistics is enabled. If this object is set to 'true', intra-vlan bridged flow statistics is reported in cseFlowDataTable when a corresponding query is set up in cseFlowQueryTable. If this object is set to 'false', intra-vlan bridged flow statistics is not reported. The default is false.")
cseFlowIPFlowMask = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("dstOnly", 1), ("srcDst", 2), ("fullFlow", 3), ("srcOnly", 4), ("intDstSrc", 5), ("intFull", 6), ("null", 7), ("intDstOnly", 8), ("intSrcOnly", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowIPFlowMask.setStatus('current')
if mibBuilder.loadTexts: cseFlowIPFlowMask.setDescription('Indicates the flow mask for IP flows. If dstOnly(1) is used, it enables flows based on Layer 3 destination addresses only. If srcDst(2) is used, it enables flows based on both Layer 3 source and destination addresses only. If fullFlow(3) is used, it enables flows based on Layer 4 port numbers in addition to source and destination addresses. If srcOnly(4) is used, it enables flows based on Layer 3 source addresses only. If intDstSrc(5) is used, it enables flows based on source interface in addition to source and destination addresses. If intFull(6) is used, it enables flows based on source interface in addition to Layer 4 port numbers, source and destination addresses. If null(7) is used, no flow will be enabled. If intDstOnly(8) is used, it enables flows based on source interface in addition to the destination addresses. If intSrcOnly(9) is used, it enables flows based on source interface in addition to the source addresses.')
cseFlowIPXFlowMask = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dstOnly", 1), ("srcDst", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowIPXFlowMask.setStatus('current')
if mibBuilder.loadTexts: cseFlowIPXFlowMask.setDescription('Indicates the flow mask for IPX flows. If dstOnly(1) is used, it enables flows based on Layer 3 destination addresses only. If srcDst(2) is used, it enables flows based on both Layer 3 source and destination addresses only.')
cseFlowLongAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 24), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseFlowLongAgingTime.setStatus('current')
if mibBuilder.loadTexts: cseFlowLongAgingTime.setDescription('The administrative long aging time for the established flow entries. Setting to value of 0 turns off long aging.')
cseFlowExcludeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 25), )
if mibBuilder.loadTexts: cseFlowExcludeTable.setStatus('current')
if mibBuilder.loadTexts: cseFlowExcludeTable.setDescription('A table controls the flow creation based on protocol and port number. If a packet matches the protocol and port number specified in this table entries, a flow entry will not be established.')
cseFlowExcludeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 25, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseFlowExcludePort"))
if mibBuilder.loadTexts: cseFlowExcludeEntry.setStatus('current')
if mibBuilder.loadTexts: cseFlowExcludeEntry.setDescription('A row instance contains the configuration to enable or disable the establishment of flow entry for matching traffic.')
cseFlowExcludePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 25, 1, 1), CiscoPort())
if mibBuilder.loadTexts: cseFlowExcludePort.setStatus('current')
if mibBuilder.loadTexts: cseFlowExcludePort.setDescription('Indicates the TCP or UDP port number that matching traffic will be excluded from flow establishment. The value of 0 is not allowed.')
cseFlowExcludeProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 25, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("udp", 1), ("tcp", 2), ("both", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowExcludeProtocol.setStatus('current')
if mibBuilder.loadTexts: cseFlowExcludeProtocol.setDescription('Indicates the protocol that matching traffic will be excluded from flow establishment.')
cseFlowExcludeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 25, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseFlowExcludeStatus.setStatus('current')
if mibBuilder.loadTexts: cseFlowExcludeStatus.setDescription("The status of this conceptual row. New rows are created using 'createAndGo' and deleted using 'destroy'. Once 'active' this object may be set to only 'destroy'. cseFlowExcludeProtocol may be modified at any time (even while the row is active).")
cseFlowStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 26), )
if mibBuilder.loadTexts: cseFlowStatsTable.setStatus('current')
if mibBuilder.loadTexts: cseFlowStatsTable.setDescription('A table containing flow statistics information on each switching engine.')
cseFlowStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 26, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: cseFlowStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cseFlowStatsEntry.setDescription('A conceptual row of cseFlowStatsTable, containing flow statistics maintained by a switching engine entity (identified by entPhysicalIndex). Each switching engine managed by this MIB module has an entry in this table.')
cseFlowTotalFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 26, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowTotalFlows.setStatus('current')
if mibBuilder.loadTexts: cseFlowTotalFlows.setDescription('Indicates the total number of flow entries installed in this switching engine.')
cseFlowTotalIpv4Flows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 2, 26, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseFlowTotalIpv4Flows.setStatus('current')
if mibBuilder.loadTexts: cseFlowTotalIpv4Flows.setDescription('Indicates the total number of IPv4 flow entries in this switching engine.')
cseNetflowLSExportStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 1), ControlStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportStatus.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSExportStatus.setDescription('Status of the Netflow LAN Switching data export feature.')
cseNetflowLSExportHost = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportHost.setStatus('deprecated')
if mibBuilder.loadTexts: cseNetflowLSExportHost.setDescription('Network(IP) address in dotted decimal format or the DNS hostname of the host to which Netflow LAN switching statistics are exported. This object is deprecated and replaced by cndeCollectorAddress in CISCO-NDE-MIB.')
cseNetflowLSExportTransportNumber = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportTransportNumber.setStatus('deprecated')
if mibBuilder.loadTexts: cseNetflowLSExportTransportNumber.setDescription('The transport(UDP) port number to be used for the Netflow LAN switching statistics being exported. This object is deprecated and replaced by cndeCollectorPort in CISCO-NDE-MIB.')
cseNetflowLSExportDataSource = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 4), FlowAddressComponent()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportDataSource.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSExportDataSource.setDescription('The source network address used as a filter for selecting the flows to which the netflow LAN switching data export feature is applied.')
cseNetflowLSExportDataSourceMask = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 5), FlowAddressComponent()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportDataSourceMask.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSExportDataSourceMask.setDescription('The mask to be applied to the corresponding instance of cseNetflowExportDataSource.')
cseNetflowLSExportDataDest = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 6), FlowAddressComponent()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportDataDest.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSExportDataDest.setDescription('The destination network address used as a filter for selecting the flows to which the netflow LAN switching data export feature is applied.')
cseNetflowLSExportDataDestMask = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 7), FlowAddressComponent()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportDataDestMask.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSExportDataDestMask.setDescription('The mask to be applied to its corresponding instance of cseNetflowExportDataDest.')
cseNetflowLSExportDataProtocol = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportDataProtocol.setReference('The protocol value is defined in the RFC 1700.')
if mibBuilder.loadTexts: cseNetflowLSExportDataProtocol.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSExportDataProtocol.setDescription('The protocol used as a filter for selecting the flows to which the netflow LAN switching data export feature is applied.')
cseNetflowLSExportDataFilterSelection = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("included", 1), ("excluded", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportDataFilterSelection.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSExportDataFilterSelection.setDescription("The filter set can be chosen either included(1) or excluded(2) mutually exclusive. If this object is set to included(1) - exports the flows that match cseNetflowLSExportDataSource, cseNetflowLSExportDataSourceMask, cseNetflowLSExportDataDest, cseNetflowLSExportDataDestMask and cseNetflowLSExportDataProtocol. excluded(2) - exports the flows that don't match cseNetflowLSExportDataSource, cseNetflowLSExportDataSourceMask, cseNetflowLSExportDataDest, cseNetflowLSExportDataDestMask and cseNetflowLSExportDataProtocol.")
cseNetflowLSExportNDEVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowLSExportNDEVersionNumber.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSExportNDEVersionNumber.setDescription('The netflow data export version number which is supported by the device. The typical value of this object can be 1, 7 or 8.')
cseNetflowLSFilterSupport = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("single", 1), ("multiple", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseNetflowLSFilterSupport.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterSupport.setDescription('Indicates whether this device supports single filter or multiple filters. single - use objects in cseNDESingleFilterGroupRev1 to configure NDE filtering paramaters. multiple - use objects in cseNDEMultipleFiltersGroup to configure NDE filtering paramaters.')
cseNetflowLSFilterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12), )
if mibBuilder.loadTexts: cseNetflowLSFilterTable.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterTable.setDescription('A Table containing Netflow Data Export filtering configuration.')
cseNetflowLSFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterIndex"))
if mibBuilder.loadTexts: cseNetflowLSFilterEntry.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterEntry.setDescription('A conceptutal row in the cseNetflowLSFilterTable, representing a NDE filter configuration.')
cseNetflowLSFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseNetflowLSFilterIndex.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterIndex.setDescription('An arbitrary integer which uniquely identifies the filter')
cseNetflowLSFilterDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1, 2), FlowAddressComponent().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseNetflowLSFilterDataSource.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterDataSource.setDescription('The source network address used as a filter for selecting the flows to which the netflow LAN switching data export feature is applied. If cseNetflowLSNDEFilterDataSource contains all zeros, then the cseNetflowLSNDEFilterDataSource object will not be included in the filtering criterion.')
cseNetflowLSFilterDataSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1, 3), FlowAddressComponent().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseNetflowLSFilterDataSourceMask.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterDataSourceMask.setDescription('The mask to be applied to the corresponding instance of cseNetflowExportDataSource. If cseNetflowLSFilterDataSourceMask contains all zeros, then the cseNetflowLSFilterDataSourceMask object will not be included in the filtering criterion.')
cseNetflowLSFilterDataDest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1, 4), FlowAddressComponent().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseNetflowLSFilterDataDest.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterDataDest.setDescription('The destination network address used as a filter for selecting the flows to which the netflow LAN switching data export feature is applied. If cseNetflowLSFilterDataDest contains all zeros, then the cseNetflowLSFilterDataDest object will not be included in the filtering criterion.')
cseNetflowLSFilterDataDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1, 5), FlowAddressComponent().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseNetflowLSFilterDataDestMask.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterDataDestMask.setDescription('The mask to be applied to its corresponding instance of cseNetflowExportDataDest. If cseNetflowLSFilterDataDestMask contains all zeros, then the cseNetflowLSFilterDataDestMask object will not be included in the filtering criterion.')
cseNetflowLSFilterDataProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseNetflowLSFilterDataProtocol.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterDataProtocol.setDescription('The protocol used as a filter for selecting the flows to which the netflow LAN switching data export feature is applied. The default value is set to 0, to specify that no value has been set. If cseNetflowLSFilterDataProtocol is set to 0, then the cseNetflowLSFilterDataProtocol object will not be included in the filtering criterion.')
cseNetflowLSFilterSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("included", 1), ("excluded", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseNetflowLSFilterSelection.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterSelection.setDescription("The filter set can be chosen either included(1) or excluded(2). If this object is set to included(1) - exports the flows that match cseNetflowLSFilterDataSource, cseNetflowLSFilterDataSourceMask, cseNetflowLSFilterDataDest, cseNetflowLSFilterDataDestMask and cseNetflowLSFilterDataProtocol. excluded(2) - exports the flows that don't match cseNetflowLSFilterDataSource, cseNetflowLSFilterDataSourceMask, cseNetflowLSFilterDataDest, cseNetflowLSFilterDataDestMask and cseNetflowLSFilterDataProtocol.")
cseNetflowLSFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 12, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseNetflowLSFilterStatus.setStatus('current')
if mibBuilder.loadTexts: cseNetflowLSFilterStatus.setDescription('The status object used to manage the rows in this table. Once a row becomes active, values within that row cannot be modified except by deleting and creating the row.')
cseNetFlowIfIndexEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 13), Bits().clone(namedValues=NamedValues(("destIfIndex", 0), ("srcIfIndex", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetFlowIfIndexEnable.setStatus('current')
if mibBuilder.loadTexts: cseNetFlowIfIndexEnable.setDescription('Indicates whether ifIndex reporting in NDE (Netflow Data Export) is enabled. if bit destIfIndex(0) is on, destination ifIndex reporting in NDE is enabled. if bit srcIfIndex(1) is on, source ifIndex reporting in NDE is enabled.')
cseNetflowASInfoExportCtrl = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("originate", 2), ("peer", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowASInfoExportCtrl.setStatus('current')
if mibBuilder.loadTexts: cseNetflowASInfoExportCtrl.setDescription('Indicates whether export of Autonomous System(AS) number information, in the NDE records, is enabled. disable - Disables the export of AS number information. originate - Enables the export of origination AS numbers of source and destination IP addresses. peer - Enables the export of peer AS numbers of source and destination IP addresses.')
cseNetflowPerVlanIfGlobalEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowPerVlanIfGlobalEnable.setStatus('current')
if mibBuilder.loadTexts: cseNetflowPerVlanIfGlobalEnable.setDescription("Indicates whether 'creation of Netflow entries per VLAN interface' feature is enabled at the device level. If this object is set to 'false', netflow entries will be created for all VLANs. If this object is set to 'true', creation of netflow entries can be controlled by cseNetflowPerVlanIfCtrlTable.")
cseNetflowPerVlanIfCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 16), )
if mibBuilder.loadTexts: cseNetflowPerVlanIfCtrlTable.setStatus('current')
if mibBuilder.loadTexts: cseNetflowPerVlanIfCtrlTable.setDescription('A table to control netflow entry creation for each VLAN. When a VLAN is created, a corresponding entry is added to this table.')
cseNetflowPerVlanIfCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 16, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseNetflowPerVlanIfCtrlVlan"))
if mibBuilder.loadTexts: cseNetflowPerVlanIfCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: cseNetflowPerVlanIfCtrlEntry.setDescription('An entry containing the configuration to enable or disable netflow entry creation for each VLAN.')
cseNetflowPerVlanIfCtrlVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 16, 1, 1), VlanIndex())
if mibBuilder.loadTexts: cseNetflowPerVlanIfCtrlVlan.setStatus('current')
if mibBuilder.loadTexts: cseNetflowPerVlanIfCtrlVlan.setDescription('Indicates the VLAN number on which creation of netflow entries is configured.')
cseNetflowPerVlanIfEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 3, 16, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseNetflowPerVlanIfEnable.setStatus('current')
if mibBuilder.loadTexts: cseNetflowPerVlanIfEnable.setDescription("Specifies whether creation of netflow entries is enabled on this VLAN. If this object is set to 'true', the system will create netflow entries for this VLAN. If this object is set to 'false', the system will not create any netflow entries for this VLAN. When the value of cseNetflowPerVlanIfGlobalEnable is 'false', this object will not take effect.")
cseL3StatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1), )
if mibBuilder.loadTexts: cseL3StatsTable.setStatus('current')
if mibBuilder.loadTexts: cseL3StatsTable.setDescription('A table containing L3 statistics information on each switching engine.')
cseL3StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: cseL3StatsEntry.setStatus('current')
if mibBuilder.loadTexts: cseL3StatsEntry.setDescription('A conceptual row of cseL3StatsTable, containing L3 statistics maintained by a switching engine entity (identified by entPhysicalIndex). Each switching engine managed by this MIB module has an entry in this table.')
cseL3SwitchedTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3SwitchedTotalPkts.setStatus('current')
if mibBuilder.loadTexts: cseL3SwitchedTotalPkts.setDescription('Total number of packets switched at Layer 3 by this switching engine.')
cseL3SwitchedTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3SwitchedTotalOctets.setStatus('current')
if mibBuilder.loadTexts: cseL3SwitchedTotalOctets.setDescription('Number of octets in the total packets switched at Layer 3 by this switching engine.')
cseL3CandidateFlowHits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3CandidateFlowHits.setStatus('current')
if mibBuilder.loadTexts: cseL3CandidateFlowHits.setDescription('Number of L3 Cache hits for the candidate flow entries in this switching engine.')
cseL3EstablishedFlowHits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3EstablishedFlowHits.setStatus('current')
if mibBuilder.loadTexts: cseL3EstablishedFlowHits.setDescription('Number of L3 Cache hits for established flow entries in this switching engine.')
cseL3ActiveFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3ActiveFlows.setStatus('current')
if mibBuilder.loadTexts: cseL3ActiveFlows.setDescription('Number of active flows in the Layer 3 flow table of this switching engine.')
cseL3FlowLearnFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3FlowLearnFailures.setStatus('current')
if mibBuilder.loadTexts: cseL3FlowLearnFailures.setDescription('Number of flows that failed to be learned because the Layer 3 flow table in this switching engine was full.')
cseL3IntFlowInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3IntFlowInvalids.setStatus('current')
if mibBuilder.loadTexts: cseL3IntFlowInvalids.setDescription('Number of flow invalidation events received by this switching engine from the internal router(s).')
cseL3ExtFlowInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3ExtFlowInvalids.setStatus('current')
if mibBuilder.loadTexts: cseL3ExtFlowInvalids.setDescription('Number of flow invalidation events received by this switching engine from external routers.')
cseL3SwitchedPktsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3SwitchedPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: cseL3SwitchedPktsPerSec.setDescription('Number of packets switched per second at Layer 3 by this switching engine.')
cseL3VlanStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2), )
if mibBuilder.loadTexts: cseL3VlanStatsTable.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanStatsTable.setDescription('A table containing per-VLAN, Layer 3 statistics information per switching engine.')
cseL3VlanStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseL3VlanIndex"))
if mibBuilder.loadTexts: cseL3VlanStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanStatsEntry.setDescription('A conceptual row of cseL3VlanStatsTable, containing per-VLAN Layer 3 statistics maintained by a switching engine (identified by entPhysicalIndex). An entry exists for each known VLAN for each switching engine.')
cseL3VlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 1), VlanIndex())
if mibBuilder.loadTexts: cseL3VlanIndex.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanIndex.setDescription('Vlan number for which the statistics are maintained by this entry.')
cseL3VlanInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3VlanInPkts.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanInPkts.setDescription('Number of packets Layer 3 forwarded from this Vlan to some other VLAN by this switching engine.')
cseL3VlanInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3VlanInOctets.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanInOctets.setDescription('Number of octets in packets Layer-3 forwarded from this Vlan to some other VLAN by this switching engine.')
cseL3VlanOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3VlanOutPkts.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanOutPkts.setDescription('Number of packets Layer-3 forwarded to this Vlan by this switching engine.')
cseL3VlanOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3VlanOutOctets.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanOutOctets.setDescription('Number of octets in packets Layer-3 forwarded to this Vlan by this switching engine.')
cseL3VlanInUnicastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3VlanInUnicastPkts.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanInUnicastPkts.setDescription('Number of unicast packets Layer 3 forwarded from this Vlan to some other VLAN by this switching engine.')
cseL3VlanInUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3VlanInUnicastOctets.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanInUnicastOctets.setDescription('Number of octets in unicast packets Layer-3 forwarded from this Vlan to some other VLAN by this switching engine.')
cseL3VlanOutUnicastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3VlanOutUnicastPkts.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanOutUnicastPkts.setDescription('Number of unicast packets Layer 3 forwarded to this Vlan by this switching engine.')
cseL3VlanOutUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3VlanOutUnicastOctets.setStatus('current')
if mibBuilder.loadTexts: cseL3VlanOutUnicastOctets.setDescription('Number of octets in unicast packets Layer-3 forwarded to this Vlan by this switching engine.')
cseStatsFlowTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 3), )
if mibBuilder.loadTexts: cseStatsFlowTable.setStatus('current')
if mibBuilder.loadTexts: cseStatsFlowTable.setDescription('A table of flow statistics per switch engine that is not covered in cseL3StatsTable.')
cseStatsFlowEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 3, 1), )
cseL3StatsEntry.registerAugmentions(("CISCO-SWITCH-ENGINE-MIB", "cseStatsFlowEntry"))
cseStatsFlowEntry.setIndexNames(*cseL3StatsEntry.getIndexNames())
if mibBuilder.loadTexts: cseStatsFlowEntry.setStatus('current')
if mibBuilder.loadTexts: cseStatsFlowEntry.setDescription('A conceptual row about slot based L3 flow statistics.')
cseStatsFlowAged = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseStatsFlowAged.setStatus('current')
if mibBuilder.loadTexts: cseStatsFlowAged.setDescription('Total number of layer 3 flows aged out by hardware. Management applications can control flow aging by setting the value of cseFlowEstablishedAgingTime object.')
cseStatsFlowPurged = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseStatsFlowPurged.setStatus('current')
if mibBuilder.loadTexts: cseStatsFlowPurged.setDescription('Total number of layer 3 flows purged by software; it may happen because a router invalidates certain flows, or a router for which flows are being switched has been excluded from cseRouterTable, or access-list has changed, or certain features have been enabled that would purge certain flows (TCP interception, Web cache are examples of such features).')
cseStatsFlowParityFail = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseStatsFlowParityFail.setStatus('current')
if mibBuilder.loadTexts: cseStatsFlowParityFail.setDescription('Total number of memory parity errors on accessing flows in the cache pools. It may be due to the internal RAM reading error, not necessarily the corrupted flow data.')
cseCacheUtilTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 4), )
if mibBuilder.loadTexts: cseCacheUtilTable.setStatus('current')
if mibBuilder.loadTexts: cseCacheUtilTable.setDescription('A table of utilization levels in percentage of cache capacity per switch engine. Each row instance is the current flow utilization information in the cache pool of the corresponding switching engine.')
cseCacheUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 4, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: cseCacheUtilEntry.setStatus('current')
if mibBuilder.loadTexts: cseCacheUtilEntry.setDescription('A row instance represents layer 3 flow utilization of a particular cache pool on a switching engine.')
cseCacheUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 4, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCacheUtilization.setStatus('current')
if mibBuilder.loadTexts: cseCacheUtilization.setDescription('Flow utilization level in percentage in this switching engine. It includes the flow entries for both unicast and multicast. The lighter the utilization level, the less risk of dropping flows, i.e. the higher success-rate of flow insertion.')
cseCacheEntriesCreated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 4, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCacheEntriesCreated.setStatus('current')
if mibBuilder.loadTexts: cseCacheEntriesCreated.setDescription('This object indicates the total number of flow entries successfully created in this switching engine.')
cseCacheEntriesFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 4, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCacheEntriesFailed.setStatus('current')
if mibBuilder.loadTexts: cseCacheEntriesFailed.setDescription('This object indicates the number of flow entries which were failed to be created in this switching engine.')
cseErrorStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 5), )
if mibBuilder.loadTexts: cseErrorStatsTable.setStatus('current')
if mibBuilder.loadTexts: cseErrorStatsTable.setDescription('A table of IP and IPX error counters per switch engine.')
cseErrorStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 5, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: cseErrorStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cseErrorStatsEntry.setDescription('A row instance represents layer-3 IP and IPX error counters on a switching engine.')
cseIpPlenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 5, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseIpPlenErrors.setStatus('current')
if mibBuilder.loadTexts: cseIpPlenErrors.setDescription('Indicates the number of IP length against physical length errors.')
cseIpTooShortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseIpTooShortErrors.setStatus('current')
if mibBuilder.loadTexts: cseIpTooShortErrors.setDescription('Indicates the number of IP length too short errors.')
cseIpCheckSumErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 5, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseIpCheckSumErrors.setStatus('current')
if mibBuilder.loadTexts: cseIpCheckSumErrors.setDescription('Indicates the number of IP checksum errors.')
cseIpxPlenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 5, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseIpxPlenErrors.setStatus('current')
if mibBuilder.loadTexts: cseIpxPlenErrors.setDescription('Indicates the number of IPX length against physical length errors.')
cseIpxTooShortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 5, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseIpxTooShortErrors.setStatus('current')
if mibBuilder.loadTexts: cseIpxTooShortErrors.setDescription('Indicates the number of IPX length too short errors.')
cseErrorStatsLCTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 6), )
if mibBuilder.loadTexts: cseErrorStatsLCTable.setStatus('current')
if mibBuilder.loadTexts: cseErrorStatsLCTable.setDescription('A table of IP and IPX error counters per switch engine.')
cseErrorStatsLCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 6, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: cseErrorStatsLCEntry.setStatus('current')
if mibBuilder.loadTexts: cseErrorStatsLCEntry.setDescription('A row instance represents layer-3 IP and IPX error counters on a switching engine.')
cseLCIpPlenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseLCIpPlenErrors.setStatus('current')
if mibBuilder.loadTexts: cseLCIpPlenErrors.setDescription('Indicates the number of IP length against physical length errors.')
cseLCIpTooShortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseLCIpTooShortErrors.setStatus('current')
if mibBuilder.loadTexts: cseLCIpTooShortErrors.setDescription('Indicates the number of IP length too short errors.')
cseLCIpCheckSumErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseLCIpCheckSumErrors.setStatus('current')
if mibBuilder.loadTexts: cseLCIpCheckSumErrors.setDescription('Indicates the number of IP checksum errors.')
cseLCIpxPlenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseLCIpxPlenErrors.setStatus('current')
if mibBuilder.loadTexts: cseLCIpxPlenErrors.setDescription('Indicates the number of IPX length against physical length errors.')
cseLCIpxTooShortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseLCIpxTooShortErrors.setStatus('current')
if mibBuilder.loadTexts: cseLCIpxTooShortErrors.setDescription('Indicates the number of IPX length too short errors.')
cseL3SwitchedAggrPktsPerSec = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseL3SwitchedAggrPktsPerSec.setStatus('current')
if mibBuilder.loadTexts: cseL3SwitchedAggrPktsPerSec.setDescription('Number of packets switched per second at Layer 3 by the entire system.')
cseProtocolFilterEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 5, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseProtocolFilterEnable.setStatus('current')
if mibBuilder.loadTexts: cseProtocolFilterEnable.setDescription('Indicates if protocol filtering is enabled in the device.')
cseProtocolFilterPortTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 5, 2), )
if mibBuilder.loadTexts: cseProtocolFilterPortTable.setStatus('current')
if mibBuilder.loadTexts: cseProtocolFilterPortTable.setDescription('A table containing the protocol filtering configuration and status information on ports.')
cseProtocolFilterPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 5, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterPortProtocol"))
if mibBuilder.loadTexts: cseProtocolFilterPortEntry.setStatus('current')
if mibBuilder.loadTexts: cseProtocolFilterPortEntry.setDescription('A conceptual row in the cseProtocolFilterPortTable, representing a Protocol filter configuration status information for a particular port (identified by ifIndex) and protocol type.')
cseProtocolFilterPortProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ip", 1), ("ipx", 2), ("grpProtocols", 3))))
if mibBuilder.loadTexts: cseProtocolFilterPortProtocol.setStatus('current')
if mibBuilder.loadTexts: cseProtocolFilterPortProtocol.setDescription('The protocol (group) to filter, used here as the secondary index.')
cseProtocolFilterPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cseProtocolFilterPortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cseProtocolFilterPortAdminStatus.setDescription("An indication of the administrative status of the protocol filtering on this interface. - on(1) indicates that the interface will send and receive the traffic for protocol specified in cseProtocolFilterPortProtocol. - off(2) indicates that the interface will not receive traffic for this protocol, or if this feature is not supported. - auto(3) indicates that the corresponding cseProtocolFilterPortOperStatus will transit to 'on' after receiving one packet of this protocol type.")
cseProtocolFilterPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseProtocolFilterPortOperStatus.setStatus('current')
if mibBuilder.loadTexts: cseProtocolFilterPortOperStatus.setDescription('An indication of the operational status of filtering for this protocol on this interface. - on(1) indicates that the interface will send and receive the protocol traffic. - off(2) indicates that the interface will drop all traffic belonging to this protocol. - notSupported(3) indicates the hardware does not support protocol filtering.')
cseUcastCacheTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1), )
if mibBuilder.loadTexts: cseUcastCacheTable.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheTable.setDescription('A control table used to purge certain types of IP/IPX layer 3 unicast flows stored in the cache pool.')
cseUcastCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheIndex"))
if mibBuilder.loadTexts: cseUcastCacheEntry.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheEntry.setDescription("A conceptual row in the cseUcastCacheTable, used to set up flow clearing criteria. The actual purging is started by setting the value of cseUcastCacheStatus to 'active'. Once a row becomes active, values within the row cannot be modified, except by setting it to 'notInService' first or deleting and re-creating the row.")
cseUcastCacheIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseUcastCacheIndex.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheIndex.setDescription('An arbitrary integer which uniquely identifies the flow purge contained in this row instance.')
cseUcastCacheFlowType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("any", 1), ("dstOnly", 2), ("srcOrDst", 3), ("srcAndDst", 4), ("fullFlow", 5), ("ipxDstOnly", 6), ("ipxSrcAndDst", 7))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheFlowType.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheFlowType.setDescription("Setting each value causes the appropriate action: 'dstOnly' - causes purge of flows in the cache whose absolute destination IP addresses match the address part of the value set in the cseUcastCacheDest object. If cseUcastCacheDestMask is also specified at the same time, it will be applied to the address part of cseUcastCacheDest. 'srcOrDst' - causes purge of flows in the cache whose either absolute source or destination IP addresses match the address parts of the values set in cseUcastCacheSource or cseUcastCacheDest. If cseUcastCacheDestMask/cseUcastCacheSrcMask also specified, they will be applied to the address parts of cseUcastCacheSource/ cseUcastCacheDest appropriately. 'srcAndDst' - causes purge of flows in the cache whose both absolute source and destination IP addresses match the address parts of values set in cseUcastCacheSource and cseUcastCacheDest objects. If cseUcastCacheSrcMask and cseUcastCacheDestMask also specified, they will be applied to the address parts of cseUcastCacheSource and cseUcastCacheDest. 'fullFlow' - causes purge of IP flows whose IP addresses and transport port numbers match the values set in cseUcastCacheDest and cseUcastCacheSource objects. If either cseUcastCacheDestMask or cseUcastCacheSrcMask objects have valid values, they will be applied to the respective address parts of cseUcastCacheDest and cseUcastCacheSource objects. This option is typically used to purge flows relevant to specific applications such as FTP, WWW, TELNET, etc. 'ipxDstOnly' - causes purge of IPX flows in the cache whose absolute destination IPX address match the address part of the value set in cseUcastCacheDest object. if cseUcastCacheDestMask holds valid value at the same time, it will be applied to the address part of cseUcastCacheDest. 'ipxSrcAndDst' - causes purge of IPX flows in the cache whose both absolute source and destination IPX addresses match the address parts of the values set in cseUcastCacheSource and cseUcastCacheDest objects. If either of cseUcastCacheSrcMask or cseUcastCacheDestMask have valid values at the same time, they will be applied to the respective address parts of cseUcastCacheSource and cseUcastCacheDest objects. 'any' - causes purge of all established flows currently in the cache. The values of cseUcastCacheDest, cseUcastCacheSource, cseUcastCacheDestMask, cseUcastCacheSrcMask, and cseUcastCacheTransport should be ignored in this case. Note: 1. When the row instance is initialized, the value of this object instance will be set to 'any'. 2. The rest flow parameter variables will not be instantiated until they get set by management applications based on the value of cseUcastCacheFlowType object.")
cseUcastCacheTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("udp", 1), ("tcp", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheTransport.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheTransport.setDescription("The IP transport protocol type (if applicable) of the specified switched flows to be purged; it will be instantiated if and only if it gets set by the management applications and the value of cseUcastCacheFlowMask is equal to 'fullFlow'. Its value can not be modified when the corresponding instance of cseUcastCacheStatus is 'active'.")
cseUcastCacheDest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 4), FlowAddressComponent()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheDest.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheDest.setDescription("Destination network address and port number (if applicable). The port field is ignored for IPX flows and IP flows if the value of cseUcastCacheFlowMask is not equal to 'fullFlow'. Its value can not be modified when the corresponding instance of cseUcastCacheStatus is 'active'.")
cseUcastCacheDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 5), FlowAddressComponent()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheDestMask.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheDestMask.setDescription("If instantiated, specified and applicable, the destination address mask will be applied to the value of cseUcastCacheDest in the same row instance. Its value can not be modified when the corresponding instance of cseUcastCacheStatus is 'active'.")
cseUcastCacheSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 6), FlowAddressComponent()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheSource.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheSource.setDescription("Source network address and port number (if applicable). The port field is ignored for IPX flows and IP flows if the value of cseUcastCacheFlowMask is not equal to 'fullFlow'. Its value can not be modified when the corresponding instance of cseUcastCacheStatus is 'active'.")
cseUcastCacheSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 7), FlowAddressComponent()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheSrcMask.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheSrcMask.setDescription("If instantiated, specified and applicable, the source address mask will be applied to the value of cseUcastCacheSource in the same row instance. Its value can not be modified when the corresponding instance of cseUcastCacheStatus is 'active'.")
cseUcastCacheRtrIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheRtrIp.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheRtrIp.setDescription("IP address of the router (internal or external) for which the flows are being switched, and need to be purged. An 'all-zero' value is a wildcard IP address for any router. Its value can not be modified when the corresponding instance of cseUcastCacheStatus is 'active'.")
cseUcastCacheOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 9), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheOwner.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheOwner.setDescription('The manager entity that configured this entry and is therefore using the resources assigned to it.')
cseUcastCacheResult = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("purging", 1), ("notPurging", 2))).clone('notPurging')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseUcastCacheResult.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheResult.setDescription("state of the flow purging operation. 'purging' - purging operation is proceeding 'notPurging' - the purging operation completed, or not started yet.")
cseUcastCacheStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 6, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseUcastCacheStatus.setStatus('current')
if mibBuilder.loadTexts: cseUcastCacheStatus.setDescription("The status object used to manage rows in this table. When set to active(1), the flow purge is initiated, and the value of cseUcastCacheResult object becomes 'purging'. However, this object can be set to active(1) only after all the appropriate objects for this query as defined by the value set in the cseUcastCacheFlowType object, have also been set. Upon the completion of flow purge, the value of cseUcastCacheResult object changes to 'notPurging'. Once a row becomes active, values within the row cannot be modified, except by setting it to 'notInService' first, or deleting and re-creating it.")
cseMcastCacheTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1), )
if mibBuilder.loadTexts: cseMcastCacheTable.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheTable.setDescription('A control table used to purge specified IP multicast flows from the switch engine.')
cseMcastCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseMcastCacheIndex"))
if mibBuilder.loadTexts: cseMcastCacheEntry.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheEntry.setDescription("A conceptual row in the cseMcastCacheTable, used to set up flow clearing criteria. The actual purging is started by setting the value of cseMcastCacheStatus to 'active'. Once a row becomes active, values within the row cannot be modified, except by setting it to 'notInService' first, or deleting and re-creating the row.")
cseMcastCacheIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseMcastCacheIndex.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheIndex.setDescription('An arbitrary integer which uniquely identifies the flow purge contained in the current row instance.')
cseMcastCacheFlowType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("group", 2), ("grpAndSrc", 3))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseMcastCacheFlowType.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheFlowType.setDescription("Setting each value causes the appropriate action: 'any' - causes purge of all established IP multicast layer 3 flows in the cache. The value of cseMcastCacheGrp, and cseMcastCacheSrc will be ignored in this case. 'group' - causes purge of flows whose multicast group IP address match the values of cseMcastCacheGrp. 'grpAndSrc' - causes purge of multicast flows whose both group IP address and source Ip address match the values of cseMcastCacheGrp and cseMcastCacheSrc. Note: 1. The instance of this object is initialized to 'any' when the corresponding row instance is being instantiated. 2. Flow parameter variables, cseMcastCacheGrp, cseMcastCacheSrc, cseMcastCacheRtrIp will not be instantiated until they get set by management applications (in such cases, cseMcastCacheFlowType object should be set to a value other than 'any').")
cseMcastCacheGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1, 3), McastGroupIp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseMcastCacheGrp.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheGrp.setDescription("Specifying multicast group IP address of the flows to be cleared. Its value can not be modified when the corresponding instance of cseMcastCacheStatus is 'active'.")
cseMcastCacheSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseMcastCacheSrc.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheSrc.setDescription("The source address of the IP multicast flows to be purged. Its value can not be modified when the corresponding instance of cseMcastCacheStatus is 'active'.")
cseMcastCacheRtrIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseMcastCacheRtrIp.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheRtrIp.setDescription("The IP address of the router whose flows are currently being switched, and will be purged. An 'all-zero' value is a wildcard IP address for any router. Its value can not be modified when the corresponding instance of cseMcastCacheStatus is 'active'.")
cseMcastCacheOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1, 6), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseMcastCacheOwner.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheOwner.setDescription('The manager entity that configured this entry and is therefore using the resources assigned to it.')
cseMcastCacheResult = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("purging", 1), ("notPurging", 2))).clone('notPurging')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseMcastCacheResult.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheResult.setDescription("state of the flow purging operation. 'purging' - purging operation is proceeding 'notPurging' - the purging operation completed, or not started yet.")
cseMcastCacheStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 7, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cseMcastCacheStatus.setStatus('current')
if mibBuilder.loadTexts: cseMcastCacheStatus.setDescription("The status object used to manage rows in this table. When set to active(1), the flow purge is initiated, and the value of cseMcastCacheResult object becomes 'purging'. However, this object can be set to active(1) only after all the appropriate objects for this query as defined by the value set in the cseMcastCacheFlowType object, have also been set. Upon the completion of flow purge, the value of cseMcastCacheResult object changes to 'notPurging'. Once a row becomes active, values within the row cannot be modified, except by setting it to 'notInService' first, or deleting and re-creating it.")
cseCefFibTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 1), )
if mibBuilder.loadTexts: cseCefFibTable.setStatus('current')
if mibBuilder.loadTexts: cseCefFibTable.setDescription("This table contains the information stored in the device's forwarding information base (FIB). FIB is a forwarding scheme that utilizes matching pattern to provide optimized lookup for efficient packet forwarding. It contains a forwarding table which consist of matching criteria for incoming traffic as well as information to forward traffic that matched defined criteria.")
cseCefFibEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 1, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseCefFibIndex"))
if mibBuilder.loadTexts: cseCefFibEntry.setStatus('current')
if mibBuilder.loadTexts: cseCefFibEntry.setDescription('Each row contains the IP address type, the final destination IP address, the final destination IP address mask as well as the FIB entry type.')
cseCefFibIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseCefFibIndex.setStatus('current')
if mibBuilder.loadTexts: cseCefFibIndex.setDescription('The index of this table entry.')
cseCefFibAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 1, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefFibAddrType.setStatus('current')
if mibBuilder.loadTexts: cseCefFibAddrType.setDescription('The type of IP address denoted in cseCefFibDestIp and cseCefFibDestIpMask object.')
cseCefFibDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 1, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefFibDestIp.setStatus('current')
if mibBuilder.loadTexts: cseCefFibDestIp.setDescription('The destination IP address specified in IP packet header.')
cseCefFibDestIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 1, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefFibDestIpMask.setStatus('current')
if mibBuilder.loadTexts: cseCefFibDestIpMask.setDescription('The specified destination IP address mask.')
cseCefFibType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("resolved", 2), ("bridge", 3), ("drop", 4), ("connected", 5), ("receive", 6), ("wildcard", 7), ("tunnel", 8), ("default", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefFibType.setStatus('current')
if mibBuilder.loadTexts: cseCefFibType.setDescription('Indicates the FIB entry type. other(1) indicates that this FIB entry type is none of the following. resolved(2) indicates that IP traffic matched the destination prefix of this entry is associated with a valid next-hop address. bridge(3) indicates that IP traffic matched the destination prefix of this entry will be forwarded using Layer 2 look up result. drop(4) indicates that IP traffic matched the destination prefix of this entry will be dropped. connected(5) indicates that IP traffic matched the destination prefix of this entry is associated with a connected network. receive(6) indicates that IP traffic matched the destination prefix of this entry will be sent to a router interface. wildcard(7) indicates this FIB entry will match all traffic. tunnel(8) indicates this FIB entry applied to tunneling traffic. default(9) indicates that IP traffic matched the destination prefix of this entry will be forwarded using a default route.')
cseCefAdjacencyTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3), )
if mibBuilder.loadTexts: cseCefAdjacencyTable.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyTable.setDescription("This table contains information stored in the device's adjacency table. Entry in this table is linked to entry of cseCefFibTable by its cseCefFibIndex object.")
cseCefAdjacencyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1), ).setIndexNames((0, "CISCO-SWITCH-ENGINE-MIB", "cseCefFibIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyIndex"))
if mibBuilder.loadTexts: cseCefAdjacencyEntry.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyEntry.setDescription('Each row contains next hop IP address, next-hop Ethernet address, adjacency type, and number of bytes and packets transmitted to each adjacency entry. Next hop encapsulation type and MTU value are also available if supported by the device.')
cseCefAdjacencyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseCefAdjacencyIndex.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyIndex.setDescription('The adjacency index of this table entry.')
cseCefAdjacencyAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyAddrType.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyAddrType.setDescription('The type of IP address denoted in cseCefAdjacencyNextHopIp object.')
cseCefAdjacencyNextHopIp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyNextHopIp.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyNextHopIp.setDescription('The next hop IP address.')
cseCefAdjacencyNextHopMac = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyNextHopMac.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyNextHopMac.setDescription('The next hop Ethernet address.')
cseCefAdjacencyNextHopIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyNextHopIfIndex.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyNextHopIfIndex.setDescription('Indicates the next hop interface ifIndex.')
cseCefAdjacencyType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("punt", 2), ("glean", 3), ("drop", 4), ("null", 5), ("noRewrite", 6), ("forceDrop", 7), ("connect", 8), ("unresolved", 9), ("loopback", 10), ("tunnel", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyType.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyType.setDescription('Indicates this adjacency entry type. other(1) indicates the adjacency entry type is none of the following. punt(2) indicates entry that sends traffic to the router. glean(3) indicates entry that needs to be gleaned for incoming traffic. drop(4) indicates entry that drops packets. null(5) indicates entry that drops packets destined for the Null0 interface. noRewrite(6) indicates entry that sends traffic to the router when rewrite information is incomplete. forceDrop(7) indicates entry that drop packets due to ARP throttling. connect(8) indicates entry that contains complete rewrite information. unresolved(9) indicates entry that next hop traffic is unresolved. loopback(10) indicates entry that drops packets destined for loopback interface. tunnel(11) indicates entry that next hop traffic is through a tunnel.')
cseCefAdjacencyPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyPkts.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyPkts.setDescription('Indicates the number of Layer 3 packets transmitted to this adjacency entry.')
cseCefAdjacencyOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyOctets.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyOctets.setDescription('Indicates the number of Layer 3 octets transmitted to this adjacency entry.')
cseCefAdjacencyEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("arpa", 1), ("raw", 2), ("sap", 3), ("snap", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyEncap.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyEncap.setDescription('Indicates the next hop destination encapsulation type. arpa(1) indicates that next hop destination used ARPA encapsulation type to forward packets. raw(2) indicates that next hop destination used RAW encapsulation type to forward packets. sap(3) indicates that next hop destination used SAP encapsulation type to forward packets. snap(4) indicates that next hop destination used SNAP encapsulation type to forward packets.')
cseCefAdjacencyMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 8, 3, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseCefAdjacencyMTU.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyMTU.setDescription('Indicates the next hop destination MTU value.')
cseTcamUsageTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 9, 1), )
if mibBuilder.loadTexts: cseTcamUsageTable.setStatus('current')
if mibBuilder.loadTexts: cseTcamUsageTable.setDescription('This table contains the resource usage of TCAM (Ternary Content Addressable Memory) in the device. Not all the resource types denoted by cseTcamResourceType object are supported. If that is the case, the corresponding row for that type will not be instantiated in this table.')
cseTcamUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 9, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseTcamResourceType"))
if mibBuilder.loadTexts: cseTcamUsageEntry.setStatus('current')
if mibBuilder.loadTexts: cseTcamUsageEntry.setDescription('Each row contains a short description of the resource type, the total amount of TCAM allocated for that type as well as the amount of allocated resource has been used up.')
cseTcamResourceType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85))).clone(namedValues=NamedValues(("aclStorageMask", 1), ("aclStorageValue", 2), ("aclDynamicStorageMask", 3), ("aclDynamicStorageValue", 4), ("qosStorageMask", 5), ("qosStorageValue", 6), ("qosDynamicStorageMask", 7), ("qosDynamicStorageValue", 8), ("l4PortOperator", 9), ("interfaceMapping", 10), ("ingressInterfaceMapping", 11), ("egressInterfaceMapping", 12), ("louSource", 13), ("louDestination", 14), ("andOr", 15), ("orAnd", 16), ("aclAdjacency", 17), ("aclHighStorageMask", 18), ("aclHighStorageValue", 19), ("aclLowStorageMask", 20), ("aclLowStorageValue", 21), ("qosHighStorageMask", 22), ("qosHighStorageValue", 23), ("qosLowStorageMask", 24), ("qosLowStorageValue", 25), ("sgacl", 26), ("accounting", 27), ("ipv6Ext", 28), ("ethertype", 29), ("destInfo", 30), ("dgtSgtRegion", 31), ("anyAnyRegion", 32), ("tcamALabel", 33), ("tcamBLabel", 34), ("destInfoIn", 35), ("destInfoOut", 36), ("tcam0Bank0", 37), ("tcam0Bank1", 38), ("tcam1Bank0", 39), ("tcam1Bank1", 40), ("tcam0Aggregate", 41), ("tcam1Aggregate", 42), ("bank0Aggregate", 43), ("bank1Aggregate", 44), ("lou", 45), ("bothLouOperands", 46), ("singleLouOperands", 47), ("louL4SourcePort", 48), ("louL4DstPort", 49), ("louL3PacketLength", 50), ("louIpTos", 51), ("louIpDscp", 52), ("louIpPrecedence", 53), ("louIpTtl", 54), ("tcpFlags", 55), ("l4DynamicProtocolCam", 56), ("macEtypeOrProtoCam", 57), ("nonL4OpLabelsTcam0", 58), ("nonL4OpLabelsTcam1", 59), ("l4OpLabelTcam0", 60), ("l4OpLabelTcam1", 61), ("ingressDestInfoTable", 62), ("egressDestInfoTable", 63), ("ingressTcam", 64), ("ingressIpv6Tcam", 65), ("ingressLou", 66), ("ingressBothLouOperands", 67), ("ingressSingleLouOperands", 68), ("ingressLouL4SourcePort", 69), ("ingressLouL4DstPort", 70), ("ingressLouL3PacketLength", 71), ("ingressLouL3Ttl", 72), ("ingressLouL2Ttl", 73), ("ingressTcpFlags", 74), ("egressTcam", 75), ("egressIpv6Tcam", 76), ("egressLou", 77), ("egressBothLouOperands", 78), ("egressSingleLouOperands", 79), ("egressLouL4SourcePort", 80), ("egressLouL4DstPort", 81), ("egressLouL3PacketLength", 82), ("egressLouL3Ttl", 83), ("egressLouL2Ttl", 84), ("egressTcpFlags", 85))))
if mibBuilder.loadTexts: cseTcamResourceType.setStatus('current')
if mibBuilder.loadTexts: cseTcamResourceType.setDescription('The resource type which take up TCAM space. aclStorageMask(1) indicates that TCAM space is allocated to store ACL masks. aclStorageValue(2) indicates that TCAM space is allocated to store ACL value. aclDynamicStorageMask(3) indicates that TCAM space is allocated to dynamically store ACL masks. aclDynamicStorageValue(4) indicates that TCAM space is allocated to dynamically store ACL values. qosStorageMask(5) indicates that TCAM space is allocated to store QoS masks. qosStorageValue(6) indicates that TCAM space is allocated to store QoS value. qosDynamicStorageMask(7) indicates that TCAM space is allocated to dynamically store QoS masks. qosDynamicStorageValue(8) indicates that TCAM space is allocated to dynamically store QoS values. l4PortOperator(9) indicates that TCAM space is allocated for layer 4 port operators purpose. interfaceMapping(10) indicates that TCAM space is allocated for interface mapping purpose. ingressInterfaceMapping(11) indicates that TCAM space is allocated for ingress interface mapping purpose. egressInterfaceMapping(12) indicates that TCAM space is allocated for egress interface mapping purpose. louSource(13) indicates that TCAM space is allocated as source LOUs (Logical Operation Unit). louDestination(14) indicates that TCAM space is allocated as destination LOUs. andOr(15) indicates that TCAM space is allocated for ANDOR purpose. orAnd(16) indicates that TCAM space is allocated for ORAND purpose. aclAdjacency(17) indicates that TCAM space is allocated for ACL adjacency purpose. aclHighStorageMask(18) indicates that high bank TCAM space is allocated to store ACL masks. aclHighStorageValue(19) indicates that high bank TCAM space is allocated to store ACL value. aclLowStorageMask(20) indicates that low bank TCAM space is allocated to store ACL masks. aclLowStorageValue(21) indicates that low bank TCAM space is allocated to store ACL values. qosHighStorageMask(22) indicates that high bank TCAM space is allocated to store QoS masks. qosHighStorageValue(23) indicates that high bank TCAM space is allocated to store QoS value. qosLowStorageMask(24) indicates that low bank TCAM space is allocated to store QoS masks. qosLowStorageValue(25) indicates that low bank TCAM space is allocated to store QoS values. sgacl(26) indicates that TCAM space is allocated for SGACL (Security Group Access Control List) purpose. accounting(27) indicates that TCAM space is allocated for accounting purpose such as AS (Autonomous System) based accounting, classification based accounting. ipv6Ext(28) indicates that TCAM space is allocated for IPv6 Extended Header lookup purpose. ethertype(29) indicates that TCAM space is allocated for layer2 ethertype lookup purpose. destInfo(30) indicates that TCAM space is allocated for destination information lookup purpose. dgtSgtRegion(31) indicates that TCAM space is allocated for specific SGT (Secutiry Group Tag), DGT (Destination Group Tag) pairs. anyAnyRegion(32) indicates that TCAM space is allocated for SGT (Secutiry Group Tag), DGT (Destination Group Tag) pairs with one or both of them as ANY. tcamALabel(33) indicates that TCAM space is allocated for labels used by TCAM A entries. tcamBLabel(34) indicates that TCAM space is allocated for labels used by TCAM B entries. destInfoIn(35) indicates that TCAM space is allocated for destination information table for IFE (Ingress Forwarding Engine) ACL redirects. destInfoOut(36) indicates that TCAM space is allocated for destination information table for OFE (Output/Egress Forwarding Engine) ACL redirects. tcam0Bank0(37) indicates that TCAM space is allocated for TCAM 0 Bank 0. tcam0Bank1(38) indicates that TCAM space is allocated for TCAM 0 Bank 1. tcam1Bank0(39) indicates that TCAM space is allocated for TCAM 1 Bank 0. tcam1Bank1(40) indicates that TCAM space is allocated for TCAM 1 Bank 1. tcam0Aggregate(41) indicates that TCAM space is allocated for the aggregate of Bank 0 and Bank 1 on TCAM 0. tcam1Aggregate(42) indicates that TCAM space is allocated for the aggregate of Bank 0 and Bank 1 on TCAM 1. bank0Aggregate(43) indicates that TCAM space is allocated for the aggregate of TCAM 0 and TCAM 1 for Bank 0. bank1Aggregate(44) indicates that TCAM space is allocated for the aggregate of TCAM 0 and TCAM 1 for Bank 1. lou(45) indicates that TCAM space is allocated for LOUs (Logical Operation Unit). bothLouOperands(46) indicates that TCAM space is allocated for LOUs with both operands. singleLouOperands(47) indicates that TCAM space is allocated for LOUs with single operands. louL4SourcePort(48) indicates that TCAM space is allocated for LOUs with L4 source port in comparison. louL4DstPort(49) indicates that TCAM space is allocated for LOUs with L4 destination port in comparison. louL3PacketLength(50) indicates that TCAM space is allocated for LOUs with L3 Length in comparison. louIpTos(51) indicates that TCAM space is allocated for LOUs with IP ToS (Type of Service) in comparison. louIpDscp(52) indicates that TCAM space is allocated for LOUs with IP DSCP (Differentiated Services Code Point) in comparison. louIpPrecedence(53) indicates that TCAM space is allocated for LOUs with IP Precedence in comparison. louIpTtl(54) indicates that TCAM space is allocated for LOUs with IP TTL in comparison. tcpFlags(55) indicates that TCAM space is allocated for TCP Flags. l4DynamicProtocolCam(56) indicates that TCAM space is allocated for L4 Dynamic Protocol CAM. macEtypeOrProtoCam(57) indicates that TCAM space is allocated for MAC Etype or Protocol CAM. nonL4OpLabelsTcam0(58) indicates that TCAM space is allocated for labels without using any L4 operator resources like LOUs or TCP Flags for TCAM 0. nonL4OpLabelsTcam1(59) indicates that TCAM space is allocated for labels without using any L4 operator resources like LOUs or TCP Flags for TCAM 1. l4OpLabelTcam0(60) indicates that TCAM space is allocated for labels using any L4 operator resources like LOUs or TCP Flags for TCAM 0. l4OpLabelTcam1(61) indicates that TCAM space is allocated for labels using any L4 operator resources like LOUs or TCP Flags for TCAM 1. ingressDestInfoTable(62) indicates that TCAM space is allocated for Ingress Destination Info Table. egressDestInfoTable(63) indicates that TCAM space is allocated for Egress Destination Info Table. ingressTcam(64) indicates that ingress TCAM resource utilization. ingressIpv6Tcam(65) indicates that ingress TCAM space is allocated for IPv6 compression. ingressLou(66) indicates that ingress TCAM space is allocated for LOUs (Logical Operation Unit). ingressBothLouOperands(67) indicates that ingress TCAM space is allocated for LOUs with both operands. ingressSingleLouOperands(68) indicates that ingress TCAM space is allocated for LOUs with single operands. ingressLouL4SourcePort(69) indicates that ingress TCAM space is allocated for LOUs with L4 source port in comparison. ingressLouL4DstPort(70) indicates that ingress TCAM space is allocated for LOUs with L4 destination port in comparison. ingressLouL3PacketLength(71) indicates that ingress TCAM space is allocated for LOUs with L3 Length in comparison. ingressLouL3Ttl(72) indicates that ingress TCAM space is allocated for LOUs with L3 TTL in comparison. ingressLouL2Ttl(73) indicates that ingress TCAM space is allocated for LOUs with L2 TTL in comparison. ingressTcpFlags(74) indicates that ingress TCAM space is allocated for TCP Flags. egressTcam(75) indicates that egress TCAM resource utilization. egressIpv6Tcam(76) indicates that egress TCAM space is allocated for IPv6 compression. egressLou(77)indicates that egress TCAM space is allocated for LOUs (Logical Operation Unit). egressBothLouOperands(78) indicates that egress TCAM space is allocated for LOUs with both operands. egressSingleLouOperands(79) indicates that egress TCAM space is allocated for LOUs with single operands. egressLouL4SourcePort(80) indicates that egress TCAM space is allocated for LOUs with L4 source port in comparison. egressLouL4DstPort(81) indicates that egress TCAM space is allocated for LOUs with L4 destination port in comparison. egressLouL3PacketLength(82) indicates that egress TCAM space is allocated for LOUs with L3 Length in comparison. egressLouL3Ttl(83) indicates that egress TCAM space is allocated for the LOUs with L3 TTL in comparison. egressLouL2Ttl(84) indicates that egress TCAM space is allocated for LOUs with L2 TTL in comparison. egressTcpFlags(85) indicates that egress TCAM space is allocated for TCP Flags.')
cseTcamResourceDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 9, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseTcamResourceDescr.setStatus('current')
if mibBuilder.loadTexts: cseTcamResourceDescr.setDescription('The short description of the resource type.')
cseTcamResourceUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 9, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseTcamResourceUsed.setStatus('current')
if mibBuilder.loadTexts: cseTcamResourceUsed.setDescription('The amount of TCAM resource has been used up for this resource type.')
cseTcamResourceTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 9, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseTcamResourceTotal.setStatus('current')
if mibBuilder.loadTexts: cseTcamResourceTotal.setDescription('The total amount of TCAM resource is allocated for this resource type.')
cseMetUsageTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 10, 1), )
if mibBuilder.loadTexts: cseMetUsageTable.setStatus('current')
if mibBuilder.loadTexts: cseMetUsageTable.setDescription('This table contains the resource usage of MET (Multicast Expansion Table) in the device.')
cseMetUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 10, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-SWITCH-ENGINE-MIB", "cseMetIndex"))
if mibBuilder.loadTexts: cseMetUsageEntry.setStatus('current')
if mibBuilder.loadTexts: cseMetUsageEntry.setDescription('Each row contains the total number of entries in each MET, the number of free entries in unallocated as well as allocated space of the MET. Each row represents MET data maintained by each module (identified by its entPhysicalIndex) which is capable of this feature.')
cseMetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 10, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: cseMetIndex.setStatus('current')
if mibBuilder.loadTexts: cseMetIndex.setDescription('A value uniquely identifies a MET in a module.')
cseMetTotalEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 10, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseMetTotalEntries.setStatus('current')
if mibBuilder.loadTexts: cseMetTotalEntries.setDescription('The total number of entries in this MET.')
cseMetUnallocatedSpcFreeEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 10, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseMetUnallocatedSpcFreeEntries.setStatus('current')
if mibBuilder.loadTexts: cseMetUnallocatedSpcFreeEntries.setDescription('The number of free entries reside in unallocated space of this MET.')
cseMetAllocatedSpcFreeEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 97, 1, 10, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cseMetAllocatedSpcFreeEntries.setStatus('current')
if mibBuilder.loadTexts: cseMetAllocatedSpcFreeEntries.setDescription('The number of free entries reside in allocated space of this MET.')
cseMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 2))
cseMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 3))
cseMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1))
cseMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2))
cseMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1, 1)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseVlanStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCachePurgeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMIBCompliance = cseMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: cseMIBCompliance.setDescription('The compliance statement for the CISCO-SWITCH_ENGINE-MIB MIB.')
cseMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1, 2)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseVlanStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtOperStatusGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMIBCompliance2 = cseMIBCompliance2.setStatus('deprecated')
if mibBuilder.loadTexts: cseMIBCompliance2.setDescription('The compliance statement for the CISCO-SWITCH-ENGINE-MIB MIB.')
cseMIBCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1, 3)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseVlanStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtOperStatusGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cse4kVlanGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMIBCompliance3 = cseMIBCompliance3.setStatus('deprecated')
if mibBuilder.loadTexts: cseMIBCompliance3.setDescription('The compliance statement for the CISCO-SWITCH-ENGINE-MIB MIB.')
cseMIBCompliance4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1, 4)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseVlanStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtOperStatusGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cse4kVlanGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMandatoryGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDESingleFilterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMultipleFiltersGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMIBCompliance4 = cseMIBCompliance4.setStatus('deprecated')
if mibBuilder.loadTexts: cseMIBCompliance4.setDescription('The compliance statement for the CISCO-SWITCH-ENGINE-MIB MIB.')
cseMIBCompliance5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1, 5)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseVlanStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtGroupRev1"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtOperStatusGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cse4kVlanGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMandatoryGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDESingleFilterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMultipleFiltersGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMIBCompliance5 = cseMIBCompliance5.setStatus('deprecated')
if mibBuilder.loadTexts: cseMIBCompliance5.setDescription('The compliance statement for the CISCO-SWITCH-ENGINE-MIB MIB.')
cseMIBCompliance6 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1, 6)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseVlanStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtGroupRev1"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtOperStatusGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cse4kVlanGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMandatoryGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDESingleFilterGroupRev1"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMultipleFiltersGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup2"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtExtGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMIBCompliance6 = cseMIBCompliance6.setStatus('deprecated')
if mibBuilder.loadTexts: cseMIBCompliance6.setDescription('The compliance statement for the CISCO-SWITCH-ENGINE-MIB MIB.')
cseMIBCompliance7 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1, 7)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseVlanStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtGroupRev1"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup1"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtOperStatusGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cse4kVlanGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMandatoryGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDESingleFilterGroupRev1"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMultipleFiltersGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup2"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtExtGroup2"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastRtrMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMIBCompliance7 = cseMIBCompliance7.setStatus('deprecated')
if mibBuilder.loadTexts: cseMIBCompliance7.setDescription('The compliance statement for the CISCO-SWITCH-ENGINE-MIB MIB.')
cseMIBCompliance8 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 1, 8)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseVlanStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtGroupRev1"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup1"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCachePurgeGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtOperStatusGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cse4kVlanGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMandatoryGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDESingleFilterGroupRev1"), ("CISCO-SWITCH-ENGINE-MIB", "cseNDEMultipleFiltersGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsGroup2"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMgmtExtGroup2"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastRtrMgmtGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMgmtGroup2"), ("CISCO-SWITCH-ENGINE-MIB", "cseCacheStatisticsGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3SwitchedPktsPerSecGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseStatisticsFlowGroup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMIBCompliance8 = cseMIBCompliance8.setStatus('current')
if mibBuilder.loadTexts: cseMIBCompliance8.setDescription('The compliance statement for the CISCO-SWITCH-ENGINE-MIB MIB.')
cseStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 1)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseL2ForwardedLocalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2ForwardedLocalOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2ForwardedTotalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2NewAddressLearns"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2AddrLearnFailures"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2DstAddrLookupMisses"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3SwitchedTotalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3SwitchedTotalOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3CandidateFlowHits"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3EstablishedFlowHits"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3ActiveFlows"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3FlowLearnFailures"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3IntFlowInvalids"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3ExtFlowInvalids"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCOverflowForwardedLocalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCForwardedLocalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCOverflowForwardedTotalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCForwardedTotalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCOverflowIpPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCIpPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCOverflowIpxPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCIpxPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCOverflowAssignedProtoPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCAssignedProtoPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCOverflowOtherProtoPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2HCOtherProtoPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseStatisticsGroup = cseStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: cseStatisticsGroup.setDescription('A collection of objects providing switch engine statistics.')
cseStatisticsGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 2)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseStatsFlowAged"), ("CISCO-SWITCH-ENGINE-MIB", "cseStatsFlowPurged"), ("CISCO-SWITCH-ENGINE-MIB", "cseStatsFlowParityFail"), ("CISCO-SWITCH-ENGINE-MIB", "cseCacheUtilization"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseStatisticsGroup2 = cseStatisticsGroup2.setStatus('current')
if mibBuilder.loadTexts: cseStatisticsGroup2.setDescription('A collection of objects providing switch engine statistics on aged/purged flows, and the cache utilizations.')
cseVlanStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 3)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseL3VlanInPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3VlanInOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3VlanOutPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3VlanOutOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseVlanStatisticsGroup = cseVlanStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: cseVlanStatisticsGroup.setDescription('A collection of objects providing per-vlan switch engine statistics, if supported.')
cseRouterGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 4)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseRouterFlowMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterName"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterStatic"), ("CISCO-SWITCH-ENGINE-MIB", "cseStaticRouterOwner"), ("CISCO-SWITCH-ENGINE-MIB", "cseStaticRouterName"), ("CISCO-SWITCH-ENGINE-MIB", "cseStaticRouterType"), ("CISCO-SWITCH-ENGINE-MIB", "cseStaticRouterStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterIpxFlowMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseStaticIpxRouterOwner"), ("CISCO-SWITCH-ENGINE-MIB", "cseStaticIpxRouterName"), ("CISCO-SWITCH-ENGINE-MIB", "cseStaticIpxRouterStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterMac"), ("CISCO-SWITCH-ENGINE-MIB", "cseRouterProtocol"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseRouterGroup = cseRouterGroup.setStatus('current')
if mibBuilder.loadTexts: cseRouterGroup.setDescription('A collection of objects providing information on routers which are used to support layer 3 switching in the system.')
cseFlowMgmtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 5)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowEstablishedAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowFastAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowFastAgePktThreshold"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowIPXEstablishedAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMaxQueries"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryTransport"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQuerySource"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQuerySourceMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryDestination"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryDestinationMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryRouterIndex"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryOwner"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultingRows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultTotalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultTotalOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultAvgDuration"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultAvgIdle"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryCreateTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataSrcMac"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataDstMac"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataEncapType"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataSource"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataStaticFlow"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataDestination"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataDestVlan"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataIpQOS"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataIpQOSPolicy"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataWhenCreated"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataLastUsed"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowSwitchStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMgmtGroup = cseFlowMgmtGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cseFlowMgmtGroup.setDescription('A collection of objects providing information for determining the L3 flow switching performance in the switching engine. There may be some platform specific limitations when performing a SET on some of these objects. The following are valid for Catalyst 5000 platforms: - cseFlowEstablishedAgingTime has a default value of 256. - cseFlowFastAgePktThreshold can only be set to 1, 3, 7, 15, 31 or 63 packets. If the packet threshold is not configured to one of these values, it will be adjusted to the closest value. - cseFlowFastAgingTime can be set to only values that are multiples of 8 in the range (0..128). If it is set to a value that is not multiple of 8, then the closest value that is a multiple of 8 will take effect. The default value for fast aging time is 32 seconds. (i.e. less than cseFlowFastAgePktThreshold number of packets were switched within 32 seconds after the an L3 flow entry was established). - cseFlowIPXEstablishedAgingTime has a default value of 256. cseFlowMgmtGroup object is superseded by cseFlowMgmtGroupRev1.')
cseNetflowLSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 6)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportHost"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportTransportNumber"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataSource"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataSourceMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataDest"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataDestMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataProtocol"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataFilterSelection"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportNDEVersionNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseNetflowLSGroup = cseNetflowLSGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cseNetflowLSGroup.setDescription('A collection of objects providing information on the Netflow LAN switching Data Export feature, if supported. cseNetflowLSGroup object is superseded by cseNDESingleFilterGroupRev1.')
cseProtocolFilterGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 7)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterPortAdminStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterPortOperStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2IpPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2IpxPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2AssignedProtoPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL2OtherProtoPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseProtocolFilterGroup = cseProtocolFilterGroup.setStatus('current')
if mibBuilder.loadTexts: cseProtocolFilterGroup.setDescription('A collection of objects providing information on the Protocol filter feature, if supported.')
cseFlowMcastMgmtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 8)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMaxQueries"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQuerySrc"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryGrp"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQuerySrcVlan"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryRtrIndex"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQuerySkipNFlows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryOwner"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryTotalFlows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryRows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryCreateTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultSrc"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultGrp"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultSrcVlan"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultRtrIp"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultRtrMac"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultCreatedTS"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultLastUsedTS"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultDstVlans"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastSwitchStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMcastMgmtGroup = cseFlowMcastMgmtGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cseFlowMcastMgmtGroup.setDescription('A collection of objects for querying IP multicast flows stored in hardware switching cache. cseFlowMcastMgmtGroup object is superseded by cseFlowMcastMgmtGroup1.')
cseUcastCachePurgeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 9)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheFlowType"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheTransport"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheDest"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheDestMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheSource"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheSrcMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheRtrIp"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheOwner"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseUcastCacheResult"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseUcastCachePurgeGroup = cseUcastCachePurgeGroup.setStatus('current')
if mibBuilder.loadTexts: cseUcastCachePurgeGroup.setDescription('A collection of objects providing IP/IPX unicast flow cache purging function.')
cseMcastCachePurgeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 10)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseMcastCacheFlowType"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCacheGrp"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCacheSrc"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCacheRtrIp"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCacheOwner"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCacheStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseMcastCacheResult"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMcastCachePurgeGroup = cseMcastCachePurgeGroup.setStatus('current')
if mibBuilder.loadTexts: cseMcastCachePurgeGroup.setDescription('A collection of objects providing IP multicast flow cache purge function.')
cseFlowMgmtOperStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 11)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowOperEstablishedAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowOperFastAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowOperFastAgePktThreshold"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowOperIPXAgingTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMgmtOperStatusGroup = cseFlowMgmtOperStatusGroup.setStatus('current')
if mibBuilder.loadTexts: cseFlowMgmtOperStatusGroup.setDescription('A collection of objects providing operating status information on aging time for flows used in L3 switching.')
cse4kVlanGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 12)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultDstVlans2k"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultDstVlans3k"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultDstVlans4k"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cse4kVlanGroup = cse4kVlanGroup.setStatus('current')
if mibBuilder.loadTexts: cse4kVlanGroup.setDescription('A collection of objects providing information for VLANS with VlanIndex from 1024 to 4095.')
cseNDEMandatoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 13)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterSupport"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportNDEVersionNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseNDEMandatoryGroup = cseNDEMandatoryGroup.setStatus('current')
if mibBuilder.loadTexts: cseNDEMandatoryGroup.setDescription('A collection of objects providing information on the type of filter support, status and the version of NDE used.')
cseNDESingleFilterGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 14)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportHost"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportTransportNumber"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataSource"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataSourceMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataDest"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataDestMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataProtocol"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataFilterSelection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseNDESingleFilterGroup = cseNDESingleFilterGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cseNDESingleFilterGroup.setDescription('A collection of objects providing information on the Netflow LAN switching Data Export feature, with a single host and a single filter support. cseNDESingleFilterGroup object is superseded by cseNDESingleFilterGroupRev1.')
cseNDEMultipleFiltersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 15)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterDataSource"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterDataSourceMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterDataDest"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterDataDestMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterDataProtocol"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterSelection"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSFilterStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseNDEMultipleFiltersGroup = cseNDEMultipleFiltersGroup.setStatus('current')
if mibBuilder.loadTexts: cseNDEMultipleFiltersGroup.setDescription('A collection of objects providing information on the Netflow LAN switching Data Export feature, with multiple filter support.')
cseFlowMgmtGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 16)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowEstablishedAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowFastAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowFastAgePktThreshold"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowIPXEstablishedAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMaxQueries"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryTransport"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQuerySource"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQuerySourceMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryDestination"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryDestinationMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryRouterIndex"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryOwner"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultingRows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultTotalPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultTotalOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultAvgDuration"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryResultAvgIdle"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryCreateTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowQueryTotalFlows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataSrcMac"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataDstMac"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataEncapType"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataSource"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataStaticFlow"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataDestination"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataDestVlan"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataIpQOS"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataIpQOSPolicy"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataWhenCreated"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataLastUsed"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowDataOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowSwitchStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMgmtGroupRev1 = cseFlowMgmtGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cseFlowMgmtGroupRev1.setDescription('A collection of objects providing information for determining the L3 flow switching performance in the switching engine. There may be some platform specific limitations when performing a SET on some of these objects. The following are valid for Catalyst 5000 platforms: - cseFlowEstablishedAgingTime has a default value of 256. - cseFlowFastAgePktThreshold can only be set to 1, 3, 7, 15, 31 or 63 packets. If the packet threshold is not configured to one of these values, it will be adjusted to the closest value. - cseFlowFastAgingTime can be set to only values that are multiples of 8 in the range (0..128). If it is set to a value that is not multiple of 8, then the closest value that is a multiple of 8 will take effect. The default value for fast aging time is 32 seconds. (i.e. less than cseFlowFastAgePktThreshold number of packets were switched within 32 seconds after the an L3 flow entry was established). - cseFlowIPXEstablishedAgingTime has a default value of 256.')
cseL3ErrorsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 17)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseIpPlenErrors"), ("CISCO-SWITCH-ENGINE-MIB", "cseIpTooShortErrors"), ("CISCO-SWITCH-ENGINE-MIB", "cseIpCheckSumErrors"), ("CISCO-SWITCH-ENGINE-MIB", "cseIpxPlenErrors"), ("CISCO-SWITCH-ENGINE-MIB", "cseIpxTooShortErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseL3ErrorsGroup = cseL3ErrorsGroup.setStatus('current')
if mibBuilder.loadTexts: cseL3ErrorsGroup.setDescription('A collection of objects providing the IP and IPX error statistics.')
cseBridgedFlowGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 18)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowBridgedFlowStatsEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseBridgedFlowGroup = cseBridgedFlowGroup.setStatus('current')
if mibBuilder.loadTexts: cseBridgedFlowGroup.setDescription('A collection of objects control the reporting of intra-vlan bridged flow statistics.')
cseVlanStatisticsExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 19)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseL3VlanInUnicastPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3VlanInUnicastOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3VlanOutUnicastPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3VlanOutUnicastOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseVlanStatisticsExtGroup = cseVlanStatisticsExtGroup.setStatus('current')
if mibBuilder.loadTexts: cseVlanStatisticsExtGroup.setDescription('A collection of objects providing additional per-vlan switch engine statistics, if supported.')
cseProtocolFilterExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 20)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseProtocolFilterEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseProtocolFilterExtGroup = cseProtocolFilterExtGroup.setStatus('current')
if mibBuilder.loadTexts: cseProtocolFilterExtGroup.setDescription('A collection of objects providing additional information on the Protocol filter feature, if supported.')
cseFlowMgmtExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 21)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowIPFlowMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowIPXFlowMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMgmtExtGroup = cseFlowMgmtExtGroup.setStatus('current')
if mibBuilder.loadTexts: cseFlowMgmtExtGroup.setDescription('A collection of objects providing additional information on the L3 flow switching in the switching engine.')
cseFlowMgmtExtGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 22)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowLongAgingTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowExcludeProtocol"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowExcludeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMgmtExtGroup1 = cseFlowMgmtExtGroup1.setStatus('current')
if mibBuilder.loadTexts: cseFlowMgmtExtGroup1.setDescription('A collection of objects providing additional information on the L3 flow switching in the switching engine.')
cseNDEReportGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 23)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseNetFlowIfIndexEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseNDEReportGroup = cseNDEReportGroup.setStatus('current')
if mibBuilder.loadTexts: cseNDEReportGroup.setDescription('A collection of objects providing the configuration on NDE ifIndex report feature.')
cseStatisticsFlowGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 24)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowTotalFlows"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseStatisticsFlowGroup = cseStatisticsFlowGroup.setStatus('current')
if mibBuilder.loadTexts: cseStatisticsFlowGroup.setDescription('A collection of object providing switch engine statistics on total number of installed flows.')
cseFlowMgmtExtGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 25)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowQuerySkipNFlows"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMgmtExtGroup2 = cseFlowMgmtExtGroup2.setStatus('current')
if mibBuilder.loadTexts: cseFlowMgmtExtGroup2.setDescription('A collection of objects providing additional information on the L3 flow switching in the switching engine.')
cseNDESingleFilterGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 26)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataSource"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataSourceMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataDest"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataDestMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataProtocol"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowLSExportDataFilterSelection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseNDESingleFilterGroupRev1 = cseNDESingleFilterGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cseNDESingleFilterGroupRev1.setDescription('A collection of objects providing information on the Netflow LAN switching Data Export feature, with a single filter support.')
cseCefFibAdjacencyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 27)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseCefFibAddrType"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefFibDestIp"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefFibDestIpMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefFibType"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyAddrType"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyNextHopIp"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyNextHopMac"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyNextHopIfIndex"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyType"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseCefFibAdjacencyGroup = cseCefFibAdjacencyGroup.setStatus('current')
if mibBuilder.loadTexts: cseCefFibAdjacencyGroup.setDescription('A collection of objects providing FIB and adjacency information available in the device.')
cseCefAdjacencyEncapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 28)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyEncap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseCefAdjacencyEncapGroup = cseCefAdjacencyEncapGroup.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyEncapGroup.setDescription('A collection of object providing adjacency next hop encapsulation information available in the device.')
cseCefAdjacencyMTUGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 29)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseCefAdjacencyMTU"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseCefAdjacencyMTUGroup = cseCefAdjacencyMTUGroup.setStatus('current')
if mibBuilder.loadTexts: cseCefAdjacencyMTUGroup.setDescription('A collection of object providing adjacency next hop MTU information available in the device.')
cseTcamUsageGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 30)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseTcamResourceDescr"), ("CISCO-SWITCH-ENGINE-MIB", "cseTcamResourceUsed"), ("CISCO-SWITCH-ENGINE-MIB", "cseTcamResourceTotal"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseTcamUsageGroup = cseTcamUsageGroup.setStatus('current')
if mibBuilder.loadTexts: cseTcamUsageGroup.setDescription('A collection of objects providing the resource usage information on TCAM available in the device.')
cseL3ErrorsLCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 31)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseLCIpPlenErrors"), ("CISCO-SWITCH-ENGINE-MIB", "cseLCIpTooShortErrors"), ("CISCO-SWITCH-ENGINE-MIB", "cseLCIpCheckSumErrors"), ("CISCO-SWITCH-ENGINE-MIB", "cseLCIpxPlenErrors"), ("CISCO-SWITCH-ENGINE-MIB", "cseLCIpxTooShortErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseL3ErrorsLCGroup = cseL3ErrorsLCGroup.setStatus('current')
if mibBuilder.loadTexts: cseL3ErrorsLCGroup.setDescription('A collection of objects providing the IP and IPX error statistics.')
cseNetflowASInfoExportGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 32)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseNetflowASInfoExportCtrl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseNetflowASInfoExportGroup = cseNetflowASInfoExportGroup.setStatus('current')
if mibBuilder.loadTexts: cseNetflowASInfoExportGroup.setDescription('A collection of object providing AS number information export control.')
cseNetflowPerVlanIfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 33)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseNetflowPerVlanIfGlobalEnable"), ("CISCO-SWITCH-ENGINE-MIB", "cseNetflowPerVlanIfEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseNetflowPerVlanIfGroup = cseNetflowPerVlanIfGroup.setStatus('current')
if mibBuilder.loadTexts: cseNetflowPerVlanIfGroup.setDescription('A collection of objects providing control of netflow entry creation per vlan.')
cseMetUsageGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 34)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseMetTotalEntries"), ("CISCO-SWITCH-ENGINE-MIB", "cseMetUnallocatedSpcFreeEntries"), ("CISCO-SWITCH-ENGINE-MIB", "cseMetAllocatedSpcFreeEntries"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseMetUsageGroup = cseMetUsageGroup.setStatus('current')
if mibBuilder.loadTexts: cseMetUsageGroup.setDescription('A collection of objects providing MET utilization information.')
cseFlowMcastMgmtGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 35)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastMaxQueries"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryMask"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQuerySrcVlan"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQuerySkipNFlows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryOwner"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryTotalFlows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryRows"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryStatus"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryCreateTime"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultSrcVlan"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultCreatedTS"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultLastUsedTS"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultPkts"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultOctets"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultDstVlans"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastSwitchStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMcastMgmtGroup1 = cseFlowMcastMgmtGroup1.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastMgmtGroup1.setDescription('A collection of objects for querying IP multicast flows stored in hardware switching cache.')
cseFlowMcastRtrMgmtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 36)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryRtrIndex"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultRtrIp"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultRtrMac"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMcastRtrMgmtGroup = cseFlowMcastRtrMgmtGroup.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastRtrMgmtGroup.setDescription('A collection of objects for specifying the router based information while IP multicast flows stored in the hardware switching cache are queried.')
cseFlowMcastMgmtGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 37)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryMvrf"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryAddrType"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQuerySource"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastQueryGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultMvrf"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultAddrType"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultGroup"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultSource"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultFlowType"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultHFlag1k2k"), ("CISCO-SWITCH-ENGINE-MIB", "cseFlowMcastResultHFlag3k4k"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseFlowMcastMgmtGroup2 = cseFlowMcastMgmtGroup2.setStatus('current')
if mibBuilder.loadTexts: cseFlowMcastMgmtGroup2.setDescription('A collection of objects for enhanced querying of IP multicast flows stored in hardware switching cache.')
cseCacheStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 38)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseCacheEntriesCreated"), ("CISCO-SWITCH-ENGINE-MIB", "cseCacheEntriesFailed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseCacheStatisticsGroup = cseCacheStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: cseCacheStatisticsGroup.setDescription('A collection of objects providing switch engine statistics on the flow cache entries.')
cseL3SwitchedPktsPerSecGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 39)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseL3SwitchedPktsPerSec"), ("CISCO-SWITCH-ENGINE-MIB", "cseL3SwitchedAggrPktsPerSec"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseL3SwitchedPktsPerSecGroup = cseL3SwitchedPktsPerSecGroup.setStatus('current')
if mibBuilder.loadTexts: cseL3SwitchedPktsPerSecGroup.setDescription('A collection of objects providing switch engine statistics on total number of packets switched per second.')
cseStatisticsFlowGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 97, 3, 2, 40)).setObjects(("CISCO-SWITCH-ENGINE-MIB", "cseFlowTotalIpv4Flows"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cseStatisticsFlowGroup1 = cseStatisticsFlowGroup1.setStatus('current')
if mibBuilder.loadTexts: cseStatisticsFlowGroup1.setDescription('A collection of object providing switch engine statistics on total number of Ipv4 flow entries.')
mibBuilder.exportSymbols("CISCO-SWITCH-ENGINE-MIB", cseFlowStatsTable=cseFlowStatsTable, cseUcastCache=cseUcastCache, cseNetflowPerVlanIfGroup=cseNetflowPerVlanIfGroup, cseRouterProtocol=cseRouterProtocol, cseL3EstablishedFlowHits=cseL3EstablishedFlowHits, cseNetflowLSFilterDataDestMask=cseNetflowLSFilterDataDestMask, cseFlowMcastSwitchStatus=cseFlowMcastSwitchStatus, cseFlowMcastResultEntry=cseFlowMcastResultEntry, cseMIBCompliance7=cseMIBCompliance7, cseCefAdjacencyMTU=cseCefAdjacencyMTU, cseL2AddrLearnFailures=cseL2AddrLearnFailures, cseFlowMcastMgmtGroup2=cseFlowMcastMgmtGroup2, cseL2OtherProtoPkts=cseL2OtherProtoPkts, cseFlowMcastQueryMask=cseFlowMcastQueryMask, cseUcastCacheOwner=cseUcastCacheOwner, cseNDESingleFilterGroupRev1=cseNDESingleFilterGroupRev1, cseMIBCompliance8=cseMIBCompliance8, cseFlowTotalIpv4Flows=cseFlowTotalIpv4Flows, cseFlowQueryRouterIndex=cseFlowQueryRouterIndex, cseProtocolFilterPortProtocol=cseProtocolFilterPortProtocol, cseL2Objects=cseL2Objects, cseCacheStatisticsGroup=cseCacheStatisticsGroup, cseFlowDataIndex=cseFlowDataIndex, cseLCIpPlenErrors=cseLCIpPlenErrors, cseNetflowLSExportDataDest=cseNetflowLSExportDataDest, cseStatsFlowAged=cseStatsFlowAged, cseNetflowLSExportHost=cseNetflowLSExportHost, cseStaticExtRouterTable=cseStaticExtRouterTable, cseFlowQueryResultAvgDuration=cseFlowQueryResultAvgDuration, cseL2StatsTable=cseL2StatsTable, cseUcastCacheDestMask=cseUcastCacheDestMask, cseMcastCacheRtrIp=cseMcastCacheRtrIp, cseL3Objects=cseL3Objects, cseRouterIndex=cseRouterIndex, cseFlowMaxQueries=cseFlowMaxQueries, cseNetflowPerVlanIfCtrlEntry=cseNetflowPerVlanIfCtrlEntry, cseNetflowLSFilterSelection=cseNetflowLSFilterSelection, cseCefAdjacencyIndex=cseCefAdjacencyIndex, cseFlowDataDstMac=cseFlowDataDstMac, cseMetAllocatedSpcFreeEntries=cseMetAllocatedSpcFreeEntries, cseLCIpTooShortErrors=cseLCIpTooShortErrors, cseFlowQuerySkipNFlows=cseFlowQuerySkipNFlows, cseFlowMcastResultGrp=cseFlowMcastResultGrp, cseErrorStatsEntry=cseErrorStatsEntry, cseFlowMcastResultDstVlans3k=cseFlowMcastResultDstVlans3k, cseMetTotalEntries=cseMetTotalEntries, cseL2DstAddrLookupMisses=cseL2DstAddrLookupMisses, cseFlowOperFastAgingTime=cseFlowOperFastAgingTime, cseFlowMcastResultCreatedTS=cseFlowMcastResultCreatedTS, cseL2HCOverflowForwardedTotalPkts=cseL2HCOverflowForwardedTotalPkts, cseMetUsageTable=cseMetUsageTable, cseNetflowLSFilterIndex=cseNetflowLSFilterIndex, cseL3VlanStatsTable=cseL3VlanStatsTable, cseFlowTotalFlows=cseFlowTotalFlows, cseCefAdjacencyAddrType=cseCefAdjacencyAddrType, cseFlowMcastResultLastUsedTS=cseFlowMcastResultLastUsedTS, cseIpxTooShortErrors=cseIpxTooShortErrors, cseL3VlanInUnicastPkts=cseL3VlanInUnicastPkts, cseMcastCacheTable=cseMcastCacheTable, cseCefAdjacencyOctets=cseCefAdjacencyOctets, cseNetflowLSExportNDEVersionNumber=cseNetflowLSExportNDEVersionNumber, cseCefAdjacencyPkts=cseCefAdjacencyPkts, cseBridgedFlowGroup=cseBridgedFlowGroup, cseFlowMcastQueryTotalFlows=cseFlowMcastQueryTotalFlows, cseRouterVlan=cseRouterVlan, cseLCIpCheckSumErrors=cseLCIpCheckSumErrors, cseL3SwitchedPktsPerSecGroup=cseL3SwitchedPktsPerSecGroup, cseUcastCacheDest=cseUcastCacheDest, cseFlowMcastMgmtGroup=cseFlowMcastMgmtGroup, cseNDEMultipleFiltersGroup=cseNDEMultipleFiltersGroup, cseUcastCacheIndex=cseUcastCacheIndex, cseFlowMcastQueryStatus=cseFlowMcastQueryStatus, cseL2HCAssignedProtoPkts=cseL2HCAssignedProtoPkts, cseMcastCacheIndex=cseMcastCacheIndex, cseFlowMcastQueryTable=cseFlowMcastQueryTable, cseNetflowLSFilterDataSource=cseNetflowLSFilterDataSource, cseVlanStatisticsGroup=cseVlanStatisticsGroup, cseTcamUsageGroup=cseTcamUsageGroup, cseRouterFlowMask=cseRouterFlowMask, cseMcastCacheResult=cseMcastCacheResult, cseL2StatsEntry=cseL2StatsEntry, cseFlowQuerySourceMask=cseFlowQuerySourceMask, cseNetFlowIfIndexEnable=cseNetFlowIfIndexEnable, cseMIBConformance=cseMIBConformance, cseFlowQueryResultingRows=cseFlowQueryResultingRows, cseTcamResourceType=cseTcamResourceType, cseFlowQueryDestination=cseFlowQueryDestination, cseL3VlanInUnicastOctets=cseL3VlanInUnicastOctets, cseCefAdjacencyTable=cseCefAdjacencyTable, cseFlowExcludeStatus=cseFlowExcludeStatus, cseRouterGroup=cseRouterGroup, cseNetflowLSFilterTable=cseNetflowLSFilterTable, cseL3VlanOutPkts=cseL3VlanOutPkts, cseFlowDataDestVlan=cseFlowDataDestVlan, cseVlanStatisticsExtGroup=cseVlanStatisticsExtGroup, cseCefFibDestIp=cseCefFibDestIp, cseL3VlanInPkts=cseL3VlanInPkts, cseCacheUtilEntry=cseCacheUtilEntry, cseTcamResourceTotal=cseTcamResourceTotal, cseFlowQuerySource=cseFlowQuerySource, cseFlowQueryStatus=cseFlowQueryStatus, cseFlowMcastResultAddrType=cseFlowMcastResultAddrType, cseL3VlanStatsEntry=cseL3VlanStatsEntry, cseErrorStatsTable=cseErrorStatsTable, cseNetflowLSFilterDataDest=cseNetflowLSFilterDataDest, cseStatsFlowEntry=cseStatsFlowEntry, cseFlowExcludePort=cseFlowExcludePort, cseStaticIpxRouterName=cseStaticIpxRouterName, cseBridgedFlowStatsCtrlTable=cseBridgedFlowStatsCtrlTable, cseCefAdjacencyEncapGroup=cseCefAdjacencyEncapGroup, cseNetflowLSExportDataDestMask=cseNetflowLSExportDataDestMask, cseFlowMcastResultGroup=cseFlowMcastResultGroup, cseIpCheckSumErrors=cseIpCheckSumErrors, cseFlowSwitchControlEntry=cseFlowSwitchControlEntry, cseMIBNotifications=cseMIBNotifications, CiscoGauge64=CiscoGauge64, cseFlowQueryMask=cseFlowQueryMask, cseLCIpxPlenErrors=cseLCIpxPlenErrors, cseL2StatsHCEntry=cseL2StatsHCEntry, cseFlowQueryResultAvgIdle=cseFlowQueryResultAvgIdle, cseFlowDataOctets=cseFlowDataOctets, cseFlowDataEntry=cseFlowDataEntry, cseUcastCacheSource=cseUcastCacheSource, cseNDEMandatoryGroup=cseNDEMandatoryGroup, cseStaticIpxRouterStatus=cseStaticIpxRouterStatus, cseNetflowLSExportStatus=cseNetflowLSExportStatus, cseFlowExcludeTable=cseFlowExcludeTable, cseCefAdjacencyNextHopMac=cseCefAdjacencyNextHopMac, cseCefFibDestIpMask=cseCefFibDestIpMask, cseL3SwitchedTotalPkts=cseL3SwitchedTotalPkts, cseProtocolFilterPortTable=cseProtocolFilterPortTable, cseL2HCForwardedTotalPkts=cseL2HCForwardedTotalPkts, cseErrorStatsLCEntry=cseErrorStatsLCEntry, cseFlowMcastResultTable=cseFlowMcastResultTable, cseL2HCForwardedLocalPkts=cseL2HCForwardedLocalPkts, cseL3ErrorsGroup=cseL3ErrorsGroup, cseL3ErrorsLCGroup=cseL3ErrorsLCGroup, cseFlowMcastResultMvrf=cseFlowMcastResultMvrf, cseFlowMcastQueryIndex=cseFlowMcastQueryIndex, cseFlowMcastResultPkts=cseFlowMcastResultPkts, cseMIBCompliances=cseMIBCompliances, cseFlowDataDestination=cseFlowDataDestination, cseFlowMcastResultDstVlans=cseFlowMcastResultDstVlans, cseFlowMcastResultDstVlans2k=cseFlowMcastResultDstVlans2k, cseFlowOperFastAgePktThreshold=cseFlowOperFastAgePktThreshold, cseFlowMcastQueryRtrIndex=cseFlowMcastQueryRtrIndex, cseMetIndex=cseMetIndex, cseFlowQueryTransport=cseFlowQueryTransport, cseCefFibAdjacencyGroup=cseCefFibAdjacencyGroup, cseFlowQueryEntry=cseFlowQueryEntry, cseMIBCompliance=cseMIBCompliance, cseBridgedFlowVlan=cseBridgedFlowVlan, cseCefAdjacencyEncap=cseCefAdjacencyEncap, cseFlowMcastQuerySrcVlan=cseFlowMcastQuerySrcVlan, cseMetUsageGroup=cseMetUsageGroup, cseTcamResourceDescr=cseTcamResourceDescr, cseNetflowPerVlanIfEnable=cseNetflowPerVlanIfEnable, cseFlowMcastResultSource=cseFlowMcastResultSource, cseCefAdjacencyMTUGroup=cseCefAdjacencyMTUGroup, cseFlowDataTable=cseFlowDataTable, cseStaticIpxRouterOwner=cseStaticIpxRouterOwner, cseFlowQueryOwner=cseFlowQueryOwner, cseTcamUsageTable=cseTcamUsageTable, cseNetflowLSExportDataFilterSelection=cseNetflowLSExportDataFilterSelection, cseFlowFastAgingTime=cseFlowFastAgingTime, cseStatsFlowParityFail=cseStatsFlowParityFail, cseL3VlanIndex=cseL3VlanIndex, cseNDESingleFilterGroup=cseNDESingleFilterGroup, cseFlowDataPkts=cseFlowDataPkts, cseFlowFastAgePktThreshold=cseFlowFastAgePktThreshold, cseCefAdjacencyEntry=cseCefAdjacencyEntry, ControlStatus=ControlStatus, cseCefFibTable=cseCefFibTable, cseFlowMcastResultFlowType=cseFlowMcastResultFlowType, cseProtocolFilterGroup=cseProtocolFilterGroup, cseFlowMcastResultSrc=cseFlowMcastResultSrc, cseProtocolFilterExtGroup=cseProtocolFilterExtGroup, cseRouterEntry=cseRouterEntry, cseMIBCompliance4=cseMIBCompliance4, cseCefFibEntry=cseCefFibEntry, cseL3ActiveFlows=cseL3ActiveFlows, cseFlowMcastRtrMgmtGroup=cseFlowMcastRtrMgmtGroup, cseFlowQueryTotalFlows=cseFlowQueryTotalFlows, cseUcastCacheResult=cseUcastCacheResult, cseL2AssignedProtoPkts=cseL2AssignedProtoPkts, cseCefFibIndex=cseCefFibIndex, cseL2ForwardedTotalPkts=cseL2ForwardedTotalPkts, cseCacheUtilTable=cseCacheUtilTable, cseUcastCacheEntry=cseUcastCacheEntry, cseFlowLongAgingTime=cseFlowLongAgingTime, cseMetUnallocatedSpcFreeEntries=cseMetUnallocatedSpcFreeEntries, cse4kVlanGroup=cse4kVlanGroup, cseIpTooShortErrors=cseIpTooShortErrors, cseFlowDataWhenCreated=cseFlowDataWhenCreated, cseCefAdjacencyNextHopIfIndex=cseCefAdjacencyNextHopIfIndex, cseStaticExtRouterEntry=cseStaticExtRouterEntry, cseFlowDataEncapType=cseFlowDataEncapType, cseFlowMcastQueryOwner=cseFlowMcastQueryOwner, cseFlowMcastMgmtGroup1=cseFlowMcastMgmtGroup1, cseNetflowPerVlanIfCtrlTable=cseNetflowPerVlanIfCtrlTable, cseL3ExtFlowInvalids=cseL3ExtFlowInvalids, cseRouterStatic=cseRouterStatic, cseIpxPlenErrors=cseIpxPlenErrors, cseFlowIPFlowMask=cseFlowIPFlowMask, cseProtocolFilter=cseProtocolFilter, cseL2HCIpxPkts=cseL2HCIpxPkts, cseNetflowLSExportDataSource=cseNetflowLSExportDataSource, cseNetflowLSFilterDataSourceMask=cseNetflowLSFilterDataSourceMask, cseMcastCacheOwner=cseMcastCacheOwner, cseFlowStatsEntry=cseFlowStatsEntry, cseFlowDataIpQOSPolicy=cseFlowDataIpQOSPolicy, cseFlowMgmtGroup=cseFlowMgmtGroup, cseTcamResourceUsed=cseTcamResourceUsed, cseL2IpxPkts=cseL2IpxPkts, cseL3SwitchedTotalOctets=cseL3SwitchedTotalOctets, cseL2ForwardedLocalOctets=cseL2ForwardedLocalOctets, cseFlowMcastQuerySrc=cseFlowMcastQuerySrc, cseFlowDataSource=cseFlowDataSource, cseFlowQueryDestinationMask=cseFlowQueryDestinationMask, cseFlowMcastQueryEntry=cseFlowMcastQueryEntry, cseMcastCacheFlowType=cseMcastCacheFlowType, cseL3VlanOutUnicastPkts=cseL3VlanOutUnicastPkts, cseNetflowASInfoExportGroup=cseNetflowASInfoExportGroup, cseL2HCOverflowOtherProtoPkts=cseL2HCOverflowOtherProtoPkts, cseFlowMgmtOperStatusGroup=cseFlowMgmtOperStatusGroup, cseMcastCacheSrc=cseMcastCacheSrc, cseUcastCacheSrcMask=cseUcastCacheSrcMask, cseCacheEntriesFailed=cseCacheEntriesFailed, cseFlowMgmtGroupRev1=cseFlowMgmtGroupRev1, cseL2HCOverflowAssignedProtoPkts=cseL2HCOverflowAssignedProtoPkts, cseFlowMcastQueryGrp=cseFlowMcastQueryGrp, cseMetUsageEntry=cseMetUsageEntry, cseUcastCacheStatus=cseUcastCacheStatus, cseMcastCacheStatus=cseMcastCacheStatus, cseStatsFlowTable=cseStatsFlowTable, cseStaticRouterType=cseStaticRouterType, cseFlowDataLastUsed=cseFlowDataLastUsed, cseFlowMgmtExtGroup=cseFlowMgmtExtGroup, cseProtocolFilterPortOperStatus=cseProtocolFilterPortOperStatus, cseFlowQueryResultTotalPkts=cseFlowQueryResultTotalPkts, cseStatsFlowPurged=cseStatsFlowPurged, cseRouterVlanEntry=cseRouterVlanEntry, cseRouterName=cseRouterName, cseMIBCompliance3=cseMIBCompliance3, cseL3SwitchedAggrPktsPerSec=cseL3SwitchedAggrPktsPerSec, cseRouterIpxFlowMask=cseRouterIpxFlowMask, cseCefAdjacencyType=cseCefAdjacencyType, cseMIBGroups=cseMIBGroups, cseMcastCacheGrp=cseMcastCacheGrp, cseStatisticsFlowGroup=cseStatisticsFlowGroup, cseTcamUsage=cseTcamUsage, cseStaticRouterOwner=cseStaticRouterOwner, cseMIBObjects=cseMIBObjects, cseRouterVlanTable=cseRouterVlanTable)
mibBuilder.exportSymbols("CISCO-SWITCH-ENGINE-MIB", cseL3StatsTable=cseL3StatsTable, cseFlowDataStaticFlow=cseFlowDataStaticFlow, cseStatisticsGroup=cseStatisticsGroup, cseFlowDataSrcMac=cseFlowDataSrcMac, cseFlowMcastQueryCreateTime=cseFlowMcastQueryCreateTime, cseStaticIpxExtRouterTable=cseStaticIpxExtRouterTable, cseMIBCompliance2=cseMIBCompliance2, cseFlowMcastResultRtrMac=cseFlowMcastResultRtrMac, cseMcastCache=cseMcastCache, PYSNMP_MODULE_ID=ciscoSwitchEngineMIB, cseFlowMcastResultSrcVlan=cseFlowMcastResultSrcVlan, cseFlowMcastResultHFlag1k2k=cseFlowMcastResultHFlag1k2k, cseFlowMgmtExtGroup1=cseFlowMgmtExtGroup1, cseFlowMcastQueryMvrf=cseFlowMcastQueryMvrf, cseL3VlanOutOctets=cseL3VlanOutOctets, cseNetflowLSGroup=cseNetflowLSGroup, cseL2ForwardedLocalPkts=cseL2ForwardedLocalPkts, cseErrorStatsLCTable=cseErrorStatsLCTable, cseStaticRouterName=cseStaticRouterName, cseFlowMcastResultOctets=cseFlowMcastResultOctets, cseNetflowLSFilterDataProtocol=cseNetflowLSFilterDataProtocol, cseFlowMcastQuerySkipNFlows=cseFlowMcastQuerySkipNFlows, cseFlowEstablishedAgingTime=cseFlowEstablishedAgingTime, cseNetflowLSFilterStatus=cseNetflowLSFilterStatus, cseIpPlenErrors=cseIpPlenErrors, cseL2HCIpPkts=cseL2HCIpPkts, cseCefFibAddrType=cseCefFibAddrType, cseNetflowLSFilterSupport=cseNetflowLSFilterSupport, cseFlowMcastQueryAddrType=cseFlowMcastQueryAddrType, cseNetflowLS=cseNetflowLS, cseRouterTable=cseRouterTable, cseFlowIPXFlowMask=cseFlowIPXFlowMask, cseL2HCOverflowIpPkts=cseL2HCOverflowIpPkts, FlowAddressComponent=FlowAddressComponent, cseFlowMcastQueryRows=cseFlowMcastQueryRows, cseFlowOperIPXAgingTime=cseFlowOperIPXAgingTime, cseFlowQueryTable=cseFlowQueryTable, cseFlow=cseFlow, cseNetflowPerVlanIfGlobalEnable=cseNetflowPerVlanIfGlobalEnable, cseL2HCOtherProtoPkts=cseL2HCOtherProtoPkts, cseL2HCOverflowIpxPkts=cseL2HCOverflowIpxPkts, cseStatisticsGroup2=cseStatisticsGroup2, cseFlowMcastMaxQueries=cseFlowMcastMaxQueries, cseFlowMcastResultIndex=cseFlowMcastResultIndex, cseFlowExcludeProtocol=cseFlowExcludeProtocol, cseNDEReportGroup=cseNDEReportGroup, cseFlowMcastQuerySource=cseFlowMcastQuerySource, cseRouterMac=cseRouterMac, cseFlowQueryIndex=cseFlowQueryIndex, cseFlowQueryCreateTime=cseFlowQueryCreateTime, cseNetflowASInfoExportCtrl=cseNetflowASInfoExportCtrl, McastGroupIp=McastGroupIp, cseFlowMcastQueryGroup=cseFlowMcastQueryGroup, cseL2HCOverflowForwardedLocalPkts=cseL2HCOverflowForwardedLocalPkts, cseFlowMgmtExtGroup2=cseFlowMgmtExtGroup2, cseCacheEntriesCreated=cseCacheEntriesCreated, cseCefFibType=cseCefFibType, cseMIBCompliance6=cseMIBCompliance6, cseL3StatsEntry=cseL3StatsEntry, cseUcastCachePurgeGroup=cseUcastCachePurgeGroup, cseFlowMcastResultDstVlans4k=cseFlowMcastResultDstVlans4k, cseStatisticsFlowGroup1=cseStatisticsFlowGroup1, cseNetflowLSFilterEntry=cseNetflowLSFilterEntry, cseUcastCacheFlowType=cseUcastCacheFlowType, cseUcastCacheRtrIp=cseUcastCacheRtrIp, cseFlowQueryResultTotalOctets=cseFlowQueryResultTotalOctets, cseProtocolFilterPortAdminStatus=cseProtocolFilterPortAdminStatus, cseLCIpxTooShortErrors=cseLCIpxTooShortErrors, cseFlowDataIpQOS=cseFlowDataIpQOS, cseFlowMcastResultRtrIp=cseFlowMcastResultRtrIp, cseL3SwitchedPktsPerSec=cseL3SwitchedPktsPerSec, cseL2NewAddressLearns=cseL2NewAddressLearns, cseL3VlanOutUnicastOctets=cseL3VlanOutUnicastOctets, cseUcastCacheTransport=cseUcastCacheTransport, cseFlowSwitchControlTable=cseFlowSwitchControlTable, cseNetflowPerVlanIfCtrlVlan=cseNetflowPerVlanIfCtrlVlan, cseUcastCacheTable=cseUcastCacheTable, cseCacheUtilization=cseCacheUtilization, cseMcastCachePurgeGroup=cseMcastCachePurgeGroup, cseFlowSwitchStatus=cseFlowSwitchStatus, cseL3FlowLearnFailures=cseL3FlowLearnFailures, cseFlowBridgedFlowStatsEnable=cseFlowBridgedFlowStatsEnable, cseL3CandidateFlowHits=cseL3CandidateFlowHits, cseMet=cseMet, cseStaticRouterStatus=cseStaticRouterStatus, cseProtocolFilterEnable=cseProtocolFilterEnable, cseTcamUsageEntry=cseTcamUsageEntry, cseFlowMcastResultHFlag3k4k=cseFlowMcastResultHFlag3k4k, cseBridgedFlowStatsCtrlEntry=cseBridgedFlowStatsCtrlEntry, ciscoSwitchEngineMIB=ciscoSwitchEngineMIB, cseStaticIpxExtRouterEntry=cseStaticIpxExtRouterEntry, cseFlowSwitchProtocol=cseFlowSwitchProtocol, cseCef=cseCef, cseL3IntFlowInvalids=cseL3IntFlowInvalids, cseProtocolFilterPortEntry=cseProtocolFilterPortEntry, cseFlowOperEstablishedAgingTime=cseFlowOperEstablishedAgingTime, cseFlowIPXEstablishedAgingTime=cseFlowIPXEstablishedAgingTime, cseL3VlanInOctets=cseL3VlanInOctets, cseNetflowLSExportDataSourceMask=cseNetflowLSExportDataSourceMask, cseMcastCacheEntry=cseMcastCacheEntry, cseMIBCompliance5=cseMIBCompliance5, cseL2IpPkts=cseL2IpPkts, cseCefAdjacencyNextHopIp=cseCefAdjacencyNextHopIp, cseL2StatsHCTable=cseL2StatsHCTable, cseNetflowLSExportDataProtocol=cseNetflowLSExportDataProtocol, cseNetflowLSExportTransportNumber=cseNetflowLSExportTransportNumber, cseFlowExcludeEntry=cseFlowExcludeEntry)

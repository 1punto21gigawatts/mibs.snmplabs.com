#
# PySNMP MIB module PROPLANE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PROPLANE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:42:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
lannet, = mibBuilder.importSymbols("GEN-MIB", "lannet")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, IpAddress, Gauge32, Counter32, Counter64, Unsigned32, ModuleIdentity, Integer32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, ObjectIdentity, Bits, iso = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "IpAddress", "Gauge32", "Counter32", "Counter64", "Unsigned32", "ModuleIdentity", "Integer32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "ObjectIdentity", "Bits", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class AtmAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

propLane = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 34))
propLaneMgmtLEC = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 34, 1))
propLaneElan = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 34, 2))
propLaneLes = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 34, 3))
propLaneLecs = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 34, 4))
propLaneResLecs = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 34, 5))
propLaneSlot = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 34, 6))
propLaneMgmtLECCurrentAddress = MibScalar((1, 3, 6, 1, 4, 1, 81, 34, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneMgmtLECCurrentAddress.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneMgmtLECCurrentAddress.setDescription('The actual address currently being used by the management LEC.')
propLaneMgmtLECIfIndexMap = MibScalar((1, 3, 6, 1, 4, 1, 81, 34, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneMgmtLECIfIndexMap.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneMgmtLECIfIndexMap.setDescription('The corresponding entry in the interfaces table of MIB II')
propLaneMgmtLECLecIndexMap = MibScalar((1, 3, 6, 1, 4, 1, 81, 34, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneMgmtLECLecIndexMap.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneMgmtLECLecIndexMap.setDescription('The corresponding entry in the ATM LEC MIB')
propLaneElanConfTable = MibTable((1, 3, 6, 1, 4, 1, 81, 34, 2, 1), )
if mibBuilder.loadTexts: propLaneElanConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanConfTable.setDescription('A table containing information about each ELAN.')
propLaneElanConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1), ).setIndexNames((0, "PROPLANE-MIB", "propLaneElanConfIndex"))
if mibBuilder.loadTexts: propLaneElanConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanConfEntry.setDescription('An entry containing information about a particular ELAN.')
propLaneElanConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneElanConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanConfIndex.setDescription('Index into this table, matches the ELAN MIB elanConfIndex.')
propLaneElanSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("closed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneElanSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanSecurity.setDescription('The status of the ELAN security. open - a LEC can join this ELAN without any ELAN info closed - a LEC can ONLY join this ELAN if it has some ELAN info.')
propLaneElanLesDiscovery = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("manual", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneElanLesDiscovery.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesDiscovery.setDescription('Determines how the ELAN discovers its LES. auto - LES discovered automatically if we have a Prop LES. manual - the user must enter a LES address.')
propLaneElanLesRgstrType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("autosense", 1), ("single", 2), ("resilient", 3), ("distributed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneElanLesRgstrType.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesRgstrType.setDescription('The LES registration mode to be supported by LECS. autosense - the LECS will adopt the proprietary registration version from the first registering LES. single - the LECS will only allow a LES using the proprietary registration method. resilient - the LECS will only allow a LES using the proprietary registration method which supports resilient LESes. distributed - the LECS will only allow a LES using the proprietary registration method which supports LNNI phase 1 LESes.')
propLaneElanLesActualRgstrType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("single", 2), ("resilient", 3), ("distrib", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneElanLesActualRgstrType.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesActualRgstrType.setDescription('The actual LES registration mode that the LECS has adopted. single - the LES has used the proprietary registration method with the LECS. resilient - the LES has used the proprietary registration method to register with the LECS. distrib - the LES has used the proprietary registration method to register with the LECS. none - the registration mode is undefined as no LES has registered yet.')
propLaneElanMaximumActiveLes = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneElanMaximumActiveLes.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanMaximumActiveLes.setDescription("The maximum number of active LES's for the ELAN. Can only be written when the propLaneElanLesType is distributed. If propLaneElanLesActualType is not distributed then reading will always return the value 1.")
propLaneElanLesAddrForm = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("groupAddr", 1), ("roundRobin", 2), ("longMatch", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneElanLesAddrForm.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesAddrForm.setDescription('The method by which the LES address will be formulated. Can only be written when the propLaneElanLesType is distributed. groupAddr - a user-provided group address will be used roundRobin - the address will be picked on a round robin basis longMatch - the longest matching LES address will be used.')
propLaneElanGroupLesAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 8), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneElanGroupLesAddress.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanGroupLesAddress.setDescription('The group LES address of the ELAN. Can only be written when the propLaneElanLesType is distributed.')
propLaneElanLuni2capability = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneElanLuni2capability.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLuni2capability.setDescription('The configured LUNI 2 capability of the ELAN. If yes, then the ELAN is LUNI 2 capable, and LECs using either LANE 1 or LUNI 2 can join the ELAN. If no, then LUNI 2 clients will be told to use LANE 1 instead of LUNI 2. If auto, then the capability is determined by the capability of the first LES to register for the ELAN (auto-register ELANs only).')
propLaneElanLuni2capabilityOper = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("auto", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneElanLuni2capabilityOper.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLuni2capabilityOper.setDescription('The detected LUNI 2 capability of the ELAN. If yes, then the ELAN is LUNI 2 capable, and LECs using either LANE 1 or LUNI 2 can join the ELAN. If no, then LUNI 2 clients will be told to use LANE 1 instead of LUNI 2. Auto is an interim state which indicates that the ELAN capability will be determined by the first LES to register the ELAN, and it has not been autodetected yet.')
propLaneElanLesTable = MibTable((1, 3, 6, 1, 4, 1, 81, 34, 2, 2), )
if mibBuilder.loadTexts: propLaneElanLesTable.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesTable.setDescription('A table containing information about each LES of an ELAN.')
propLaneElanLesTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 34, 2, 2, 1), ).setIndexNames((0, "PROPLANE-MIB", "propLaneElanConfIndex"), (0, "PROPLANE-MIB", "propLaneElanLesIndex"))
if mibBuilder.loadTexts: propLaneElanLesTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesTableEntry.setDescription('An entry containing information about a particular LES of an ELAN.')
propLaneElanLesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneElanLesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesIndex.setDescription('Index into this table, matches the ELAN MIB elanLesIndex.')
propLaneElanLesLecIdLow = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneElanLesLecIdLow.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesLecIdLow.setDescription('The lower end of the LES LEC ID range.')
propLaneElanLesLecIdHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneElanLesLecIdHigh.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneElanLesLecIdHigh.setDescription('The higher end of the LES LEC ID range.')
propLaneLesConfTable = MibTable((1, 3, 6, 1, 4, 1, 81, 34, 3, 1), )
if mibBuilder.loadTexts: propLaneLesConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesConfTable.setDescription('A table containing information about each LES.')
propLaneLesConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 34, 3, 1, 1), ).setIndexNames((0, "PROPLANE-MIB", "propLaneLesConfIndex"))
if mibBuilder.loadTexts: propLaneLesConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesConfEntry.setDescription('An entry containing information about a particular LES.')
propLaneLesConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLesConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesConfIndex.setDescription('Index into this table, matches the LES MIB lesConfIndex.')
propLaneLesMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("manual", 1), ("single", 2), ("resilient", 3), ("distrib", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLesMode.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesMode.setDescription('The LES registration mode. manual - the LES is ATM Forum compliant as per LANE v1.0 and will not attempt to register with the LECS. This means that management must tell the LECS the address of the LES. single - the LES will use a proprietary registration method. resilient - the LES will use a proprietary registration method. distrib - the LES will use a proprietary registration method, and can register with a LNNI phase 1 or better Prop LECS.')
propLaneLesActiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("not-registered", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLesActiveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesActiveStatus.setDescription("The LES active status. active - the LES has resilient capability and is ACTIVE. standby - the LES has resilient capability and is on STANDBY. not-registered - the LES has resilient capability but is not yet registered. none - the LES doesn't have resilient capability.")
propLaneLesLecIdLow = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLesLecIdLow.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesLecIdLow.setDescription('The lower end of the LES LEC ID range.')
propLaneLesLecIdHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLesLecIdHigh.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesLecIdHigh.setDescription('The higher end of the LES LEC ID range.')
propLaneLesBusUnicastFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLesBusUnicastFilter.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesBusUnicastFilter.setDescription('Whether BUS filter unicast filtering is enabled or disabled.')
propLaneLesLuni2capability = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLesLuni2capability.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesLuni2capability.setDescription('The configured LUNI 2 capability of the LES. If yes, then the LES is LUNI 2 capable, and LECs using either LANE 1 or LUNI 2 can join the ELAN. If no, then LUNI 2 clients will be told to use LANE 1 instead of LUNI 2. Default value is yes (2).')
propLaneLesLecTable = MibTable((1, 3, 6, 1, 4, 1, 81, 34, 3, 2), )
if mibBuilder.loadTexts: propLaneLesLecTable.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesLecTable.setDescription('A table containing information about each LEC of a LES.')
propLaneLesLecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 34, 3, 2, 1), ).setIndexNames((0, "PROPLANE-MIB", "propLaneLesConfIndex"), (0, "PROPLANE-MIB", "propLaneLesLecIndex"))
if mibBuilder.loadTexts: propLaneLesLecEntry.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesLecEntry.setDescription('An entry containing information about a particular LEC of a LES.')
propLaneLesLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLesLecIndex.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesLecIndex.setDescription('Index into this table, matches the LES MIB lesLecIndex.')
propLaneLesLecLuni2granted = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLesLecLuni2granted.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesLecLuni2granted.setDescription('Whether the LEC joined the LES as a LUNI2 client or a LANE v1 client.')
propLaneLesLecSelectiveMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLesLecSelectiveMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLesLecSelectiveMulticast.setDescription('Whether the LEC joined the LES requesting selective multicast.')
propLaneLecsTable = MibTable((1, 3, 6, 1, 4, 1, 81, 34, 4, 1), )
if mibBuilder.loadTexts: propLaneLecsTable.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsTable.setDescription('A table containing information about a LECS in a Slot.')
propLaneLecsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1), ).setIndexNames((0, "PROPLANE-MIB", "propLaneLecsSlotIndex"))
if mibBuilder.loadTexts: propLaneLecsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsEntry.setDescription('An entry containing information about a LECS.')
propLaneLecsSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsSlotIndex.setDescription('An index into this table.')
propLaneLecsLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local-wka", 1), ("local-selector", 2), ("remote-wka", 3), ("remote-atm-addr", 4), ("remote-res-lecs", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLecsLocation.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsLocation.setDescription('The LECS location. local-wka - The LECS is local at the WKA. local-selector - The LECS is local. remote-wka - The LECS is remote at the WKA. remote-atm-addr - The LECS is remote at the address given in RemoteAddress below. remote-res-lecs - The LECS is a remote resilient LECS, found at the address given below. By setting location to remote, this implies that this device IS NOT taking part in the resilient LECS scheme itself.')
propLaneLecsRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 3), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLecsRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsRemoteAddress.setDescription('The remote (non-WKA) LECS address.')
propLaneLecsLocalSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLecsLocalSelector.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsLocalSelector.setDescription('The local LECS address selector.')
propLaneLecsDefTRElan = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLecsDefTRElan.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsDefTRElan.setDescription('The name of the default TR ELAN.')
propLaneLecsDefEthElan = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLecsDefEthElan.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsDefEthElan.setDescription('The name of the default ethernet ELAN.')
propLaneLecsDefUnspecElan = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLecsDefUnspecElan.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsDefUnspecElan.setDescription('The name of the default unspecified ELAN.')
propLaneLecsResilientNetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("discovering", 1), ("forming", 2), ("synchronising", 3), ("running", 4), ("not-resilient", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResilientNetStatus.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResilientNetStatus.setDescription('Status of the resilient LECS network as a whole. discovering - The algorithm is trying to find all participating devices in the scheme. forming - The algorithm is trying to contact each device. synchronising - The algorithm is checking that all parties have connectivity to all other parties. running - The scheme is running normally. not-resilient - This device is not taking part in the resilient scheme.')
propLaneLecsResilientMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLecsResilientMode.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResilientMode.setDescription('Whether this LECS is taking part in the resilient LECS election scheme.')
propLaneLecsResilientStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("not-resilient", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResilientStatus.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResilientStatus.setDescription('Status of this LECS in the resilient scheme.')
propLaneLecsResilientPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: propLaneLecsResilientPriority.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResilientPriority.setDescription('LECS priority in the resilient scheme.')
propLaneLecsResTable = MibTable((1, 3, 6, 1, 4, 1, 81, 34, 5, 1), )
if mibBuilder.loadTexts: propLaneLecsResTable.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResTable.setDescription('A table containing information about each LECS in the resilient LECS scheme.')
propLaneLecsResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1), ).setIndexNames((0, "PROPLANE-MIB", "propLaneLecsSlotIndex"), (0, "PROPLANE-MIB", "propLaneLecsResIndex"))
if mibBuilder.loadTexts: propLaneLecsResEntry.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResEntry.setDescription('An entry containing information about a particular LECS in the resilient scheme.')
propLaneLecsResIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResIndex.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResIndex.setDescription('An index into this table.')
propLaneLecsResAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 2), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResAddress.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResAddress.setDescription('The ATM address of this resilient LECS.')
propLaneLecsResPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResPriority.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResPriority.setDescription('The priority of this LECS in the scheme.')
propLaneLecsResStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("timing-out", 3), ("not-found", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResStatus.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResStatus.setDescription('The resilient status and link status of this LECS from the viewpoint of this agent. - timing-out means this agent has temporarily failed to contact the LECS. - not-found means that either communication to the LECS has timed-out, or that the LECS has never been found.')
propLaneLecsResOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("manual", 1), ("pvc-svc", 2), ("pvc", 3), ("local", 4), ("snmp", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResOrigin.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResOrigin.setDescription('How this LECS was found.')
propLaneLecsResRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("delete", 1), ("undercreation", 2), ("valid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResRowStatus.setDescription('The status of this entry. For row creation (currently unsupported) : The manager should first set this field to undercreation(2) before setting any of the other fields. When all values required have been given it shoud be set to valid(3). If insufficient entries have been given when it is set to valid(3) then the agent will reject the request with BAD_VALUE.')
propLaneLecsResActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResActiveTime.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResActiveTime.setDescription('The time in centiseconds since this RLECS last transitioned to active. Only non-zero values are valid here; a zero value meaning that either the RLECS was never active, or that no info is available for it.')
propLaneLecsResAddrForm = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("wka", 1), ("selector", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResAddrForm.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResAddrForm.setDescription('The type of address that this LECS will use when it is active. Selector means switch address plus the selector given below.')
propLaneLecsResSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneLecsResSelector.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneLecsResSelector.setDescription('The selector if the LECS is using its switch address.')
propLaneSlotTable = MibTable((1, 3, 6, 1, 4, 1, 81, 34, 6, 1), )
if mibBuilder.loadTexts: propLaneSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotTable.setDescription(' A table containing information about a LANE Server in a Slot of the ATM switch. ')
propLaneSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1), ).setIndexNames((0, "PROPLANE-MIB", "propLaneSlotIndex"))
if mibBuilder.loadTexts: propLaneSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotEntry.setDescription('An entry containing information about a particular Slot in the switch. ')
propLaneSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotIndex.setDescription('Index into this table.')
propLaneSlotElanConfNextId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneSlotElanConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotElanConfNextId.setDescription('The next available ELAN index in this Slot provided by the agent. The value of this object can be used as the index to the standard elanConfTable during creation. Instead of the standard elanConfNextId.')
propLaneSlotLecsConfNextId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneSlotLecsConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotLecsConfNextId.setDescription('The next available LECS index in this Slot. The value of this object can be used as the index to the lecsTable during creation. Instead of the standard lecsConfNextId.')
propLaneSlotLesConfNextId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneSlotLesConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotLesConfNextId.setDescription('The next available LES index in this Slot. The value of this object can be used as the index by the network manager to create an entry in the lesConfTable. Instead of the standard lesConfNextId.')
propLaneSlotBusConfNextId = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneSlotBusConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotBusConfNextId.setDescription('The next available BUS index in this Slot. The value of this object can be used as the index by the network manager to create an entry in the busConfTable. Instead of the standard busConfNextId.')
propLaneSlotNextLesSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneSlotNextLesSelector.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotNextLesSelector.setDescription('A suitable value for the next LES selector in this Slot.')
propLaneSlotNextBusSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneSlotNextBusSelector.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotNextBusSelector.setDescription('A suitable value for the next BUS selector in this Slot.')
propLaneSlotNextLecsSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 34, 6, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: propLaneSlotNextLecsSelector.setStatus('mandatory')
if mibBuilder.loadTexts: propLaneSlotNextLecsSelector.setDescription('A suitable value for the next LECS selector in this Slot.')
mibBuilder.exportSymbols("PROPLANE-MIB", propLaneLesBusUnicastFilter=propLaneLesBusUnicastFilter, propLaneLecsResPriority=propLaneLecsResPriority, propLaneElanConfIndex=propLaneElanConfIndex, propLaneSlotTable=propLaneSlotTable, propLaneLecsResActiveTime=propLaneLecsResActiveTime, propLaneLecsTable=propLaneLecsTable, propLaneSlotNextLesSelector=propLaneSlotNextLesSelector, propLaneLecsResOrigin=propLaneLecsResOrigin, propLaneElanLesIndex=propLaneElanLesIndex, propLaneMgmtLEC=propLaneMgmtLEC, propLaneLesLecEntry=propLaneLesLecEntry, propLaneLesLecLuni2granted=propLaneLesLecLuni2granted, propLaneLecsResEntry=propLaneLecsResEntry, propLaneMgmtLECLecIndexMap=propLaneMgmtLECLecIndexMap, propLaneLesLecSelectiveMulticast=propLaneLesLecSelectiveMulticast, propLaneElanLesLecIdHigh=propLaneElanLesLecIdHigh, propLaneElanLesTable=propLaneElanLesTable, propLaneElanLesLecIdLow=propLaneElanLesLecIdLow, propLaneElanLesRgstrType=propLaneElanLesRgstrType, propLaneSlotNextBusSelector=propLaneSlotNextBusSelector, propLaneLecsEntry=propLaneLecsEntry, MacAddress=MacAddress, propLaneElanGroupLesAddress=propLaneElanGroupLesAddress, propLaneSlotElanConfNextId=propLaneSlotElanConfNextId, propLaneElanSecurity=propLaneElanSecurity, propLaneElanLesActualRgstrType=propLaneElanLesActualRgstrType, propLaneLecsDefUnspecElan=propLaneLecsDefUnspecElan, propLaneLecsResilientMode=propLaneLecsResilientMode, propLaneLesLecIdLow=propLaneLesLecIdLow, propLaneLesLecIndex=propLaneLesLecIndex, propLaneResLecs=propLaneResLecs, propLaneLecsLocation=propLaneLecsLocation, propLaneLecs=propLaneLecs, propLaneSlotNextLecsSelector=propLaneSlotNextLecsSelector, propLaneLecsResAddrForm=propLaneLecsResAddrForm, propLaneLecsResIndex=propLaneLecsResIndex, propLaneLesConfEntry=propLaneLesConfEntry, propLaneElanConfTable=propLaneElanConfTable, propLaneLecsDefTRElan=propLaneLecsDefTRElan, propLaneElanMaximumActiveLes=propLaneElanMaximumActiveLes, propLaneElanLesTableEntry=propLaneElanLesTableEntry, AtmAddress=AtmAddress, propLaneLesConfTable=propLaneLesConfTable, propLaneLecsLocalSelector=propLaneLecsLocalSelector, propLaneLecsResAddress=propLaneLecsResAddress, propLaneElanLuni2capability=propLaneElanLuni2capability, propLaneLesLuni2capability=propLaneLesLuni2capability, propLaneLesLecTable=propLaneLesLecTable, propLaneMgmtLECIfIndexMap=propLaneMgmtLECIfIndexMap, propLaneSlot=propLaneSlot, propLaneElanLesDiscovery=propLaneElanLesDiscovery, propLaneSlotIndex=propLaneSlotIndex, propLaneSlotLesConfNextId=propLaneSlotLesConfNextId, propLaneLecsResStatus=propLaneLecsResStatus, propLaneLecsResilientNetStatus=propLaneLecsResilientNetStatus, propLaneLes=propLaneLes, propLaneElanConfEntry=propLaneElanConfEntry, propLaneLecsResilientStatus=propLaneLecsResilientStatus, propLaneLecsDefEthElan=propLaneLecsDefEthElan, propLaneLesActiveStatus=propLaneLesActiveStatus, propLaneElanLesAddrForm=propLaneElanLesAddrForm, propLaneElan=propLaneElan, propLaneLecsResRowStatus=propLaneLecsResRowStatus, propLaneElanLuni2capabilityOper=propLaneElanLuni2capabilityOper, propLaneSlotLecsConfNextId=propLaneSlotLecsConfNextId, propLaneLecsRemoteAddress=propLaneLecsRemoteAddress, propLaneSlotEntry=propLaneSlotEntry, propLaneLecsResSelector=propLaneLecsResSelector, propLaneLecsResilientPriority=propLaneLecsResilientPriority, propLaneLesConfIndex=propLaneLesConfIndex, propLaneLecsResTable=propLaneLecsResTable, propLaneLesMode=propLaneLesMode, propLaneLesLecIdHigh=propLaneLesLecIdHigh, propLaneMgmtLECCurrentAddress=propLaneMgmtLECCurrentAddress, propLaneLecsSlotIndex=propLaneLecsSlotIndex, propLaneSlotBusConfNextId=propLaneSlotBusConfNextId, propLane=propLane)

#
# PySNMP MIB module SC5002-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SC5002-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:00:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, enterprises, Counter32, iso, NotificationType, TimeTicks, Bits, MibIdentifier, ModuleIdentity, IpAddress, ObjectIdentity, Counter64, Unsigned32, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "enterprises", "Counter32", "iso", "NotificationType", "TimeTicks", "Bits", "MibIdentifier", "ModuleIdentity", "IpAddress", "ObjectIdentity", "Counter64", "Unsigned32", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
dsx1 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6))
sc5002 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8))
sc5002Version = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 1))
sc5002NetworkCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 2))
sc5002Alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3))
sc5002Diagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 4))
sc5002Maintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 5))
sc5002Performance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 6))
sc5002MIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002MIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002MIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Upon formal release, no designation for the test revision will be present. Acceptable values for the individual revision components are as follows: x: 1 - 9, y: 0 - 9, z: 0 - 9, T: A - Z")
sc5002VersionTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2), )
if mibBuilder.loadTexts: sc5002VersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002VersionTable.setDescription(' ')
sc5002VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002VersionIndex"))
if mibBuilder.loadTexts: sc5002VersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002VersionEntry.setDescription('An entry in the GDC SC5002 Version Table.')
sc5002VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002VersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002VersionIndex.setDescription('Identifies Version parameters associated with the managed object.')
sc5002ActiveFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002ActiveFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002ActiveFirmwareRev.setDescription('The version number of the firmware currently executing. The format is MM.NN.BB where: MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ')
sc5002StoredFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002StoredFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002StoredFirmwareRev.setDescription('The version number of the firmware stored (in a compressed format) but not currently executing. MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ')
sc5002BootRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002BootRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002BootRev.setDescription('The version number of the bootstrap firmware. The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. ')
sc5002StoredFirmwareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("statBlank", 1), ("statDownLoading", 2), ("statOK", 3), ("statCheckSumBad", 4), ("statUnZipping", 5), ("statBadUnZip", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002StoredFirmwareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002StoredFirmwareStatus.setDescription('This object represents the state of the Non-Active or Stored firmware: statBlank(1) Factory Default statDownLoading(2) In process of downloading firmware statOK(3) Zipped version checksum succesful (OK to switch) (can set sc5002SwitchActive to switchActive(2)) statCheckSumBad(4) Failed checksum after download statUnZipping(5) In process of uncompressing into active area statBadUnZip(6) Failed last uncompress The object is read only. ')
sc5002SwitchActiveFirmware = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNorm", 1), ("switchActive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002SwitchActiveFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002SwitchActiveFirmware.setDescription('This object is used to switch the active executing firmware from the version in sc5002ActiveRev to the version in sc5002StoredRev. When a switchActive(2) is set (write only) the element will: 1) reboot 2) uncompress stored code into active area 3) perform checksum on active area 4) Set sc5002StoredStatus object to indicate results 5) If succesfull: update sc5002ActiveFirmwareRev and sc5002StoredFirmwareRev and begin executing If failed: replace active area with previous revision The switchNorm(1) enumeration will always be read. Setting switchActive(2) when the sc5002StoredStatus is not statOK(3) will result in an error. ')
sc5002DownloadingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disableAll", 1), ("enableAndWait", 2), ("enableAndSwitch", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002DownloadingMode.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002DownloadingMode.setDescription('This object is used to configure the download mode: disableAll(1) Prevents any firmware downloading to SC5002 enableAndWait(2) Allows downloading zipped code to be stored only! enableAndSwitch(3) Allows downloading and then unzips and begins executing the new code ')
sc5002FirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 1, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FirmwareRev.setDescription('The version number of the firmware. Released versions are sequenced from --, A-, ... AA, ... ZZ. Test versions are from 01 to 99.')
sc5002NetworkCfgTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 2, 1), )
if mibBuilder.loadTexts: sc5002NetworkCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NetworkCfgTable.setDescription('This table contains objects that support the specific management requirements for configuring the SC5002 Network Interface level objects.')
sc5002NetworkCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 2, 1, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002NetworkCfgIndex"))
if mibBuilder.loadTexts: sc5002NetworkCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NetworkCfgEntry.setDescription('The sc5002 Network Configuration Table Entry.')
sc5002NetworkCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NetworkCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NetworkCfgIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002E1SignalingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("assocChanSigWithCRC4", 1), ("assocChanSigNoCRC4", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002E1SignalingMode.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002E1SignalingMode.setDescription('Specifies the channel signaling scheme for the E1 network interface.')
sc5002AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1))
sc5002NoResponse = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 1))
sc5002DiagRxErr = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 2))
sc5002PowerUp = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 3))
sc5002NvRamCorrupt = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 4))
sc5002UnitFailure = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 5))
sc5002TimingLoss = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 6))
sc5002LossOfSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 7))
sc5002LossOfFrame = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 8))
sc5002AlarmIndSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 9))
sc5002FallbackTimingActive = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 10))
sc5002NearEndLnCodeViol = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 11))
sc5002NearEndErrSec = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 12))
sc5002NearEndBkdBlkErr = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 13))
sc5002NearEndSevErrSec = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 14))
sc5002NearEndUnavlSec = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 15))
sc5002FarEndErrSec = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 16))
sc5002FarEndBkdBlkErr = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 17))
sc5002FarEndSevErrSec = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 18))
sc5002FarEndUnavlSec = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 1, 19))
sc5002NearEndAlarmCfgTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 2), )
if mibBuilder.loadTexts: sc5002NearEndAlarmCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndAlarmCfgTable.setDescription('This table contains entries that configure Near End Alarm reporting.')
sc5002NearEndAlarmCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 2, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002NearEndAlarmCfgIndex"), (0, "SC5002-MIB", "sc5002NearEndAlarmCfgIdentifier"))
if mibBuilder.loadTexts: sc5002NearEndAlarmCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndAlarmCfgEntry.setDescription('An entry in the Near End Alarm Configuration table.')
sc5002NearEndAlarmCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndAlarmCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndAlarmCfgIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002NearEndAlarmCfgIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndAlarmCfgIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndAlarmCfgIdentifier.setDescription('format: iso.org.dod.internet.private.enterprises.gdc. dsx1.sc5002.sc5002Alarms.sc5002AlarmData.ALM example: 1.3.6.1.4.1.498.6.8.4.1.ALM where ALM = 1 for sc5002NoResponse alarm, 2 for sc5002DiagRxErr alarm, etc., as specified in the Alarm Definitions above.')
sc5002NearEndAlarmWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("win30sec", 1), ("win1min", 2), ("win15min", 3), ("win1hr", 4), ("win24hr", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002NearEndAlarmWindow.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndAlarmWindow.setDescription("The time period in which a specified number of events must occur, (specified by the alarm's threshold), before declaring an alarm condition. After reporting an Alarm condition and upon expiration of the window time period, the event count is reset to zero and another time period is begun. If the specified number of events is not exceeded within the next time period, an Alarm Cleared condition is reported.")
sc5002NearEndAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("thr1", 1), ("thr3", 2), ("thr10", 3), ("thr100", 4), ("thr1000", 5), ("thr10000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002NearEndAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndAlarmThreshold.setDescription("The number of events which must be exceed, within the time period specified by the alarm's window, before declaring an alarm")
sc5002FarEndAlarmCfgTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 3), )
if mibBuilder.loadTexts: sc5002FarEndAlarmCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndAlarmCfgTable.setDescription('This table contains entries that configure Far End Alarm reporting.')
sc5002FarEndAlarmCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 3, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002FarEndAlarmCfgIndex"), (0, "SC5002-MIB", "sc5002FarEndAlarmCfgIdentifier"))
if mibBuilder.loadTexts: sc5002FarEndAlarmCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndAlarmCfgEntry.setDescription('An entry in the Far End Alarm Configuration table.')
sc5002FarEndAlarmCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndAlarmCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndAlarmCfgIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002FarEndAlarmCfgIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndAlarmCfgIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndAlarmCfgIdentifier.setDescription('format: iso.org.dod.internet.private.enterprises.gdc. dsx1.sc5002.sc5002Alarms.sc5002AlarmData.ALM example: 1.3.6.1.4.1.498.6.8.4.1.ALM where ALM = 1 for sc5002NoResponse alarm, 2 for sc5002DiagRxErr alarm, etc., as specified in the Alarm Definitions above.')
sc5002FarEndAlarmWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("win30sec", 1), ("win1min", 2), ("win15min", 3), ("win1hr", 4), ("win24hr", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002FarEndAlarmWindow.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndAlarmWindow.setDescription("The time period in which a specified number of events must occur, (specified by the alarm's threshold), before declaring an alarm condition. After reporting an Alarm condition and upon expiration of the window time period, the event count is reset to zero and another time period is begun. If the specified number of events is not exceeded within the next time period, an Alarm Cleared condition is reported.")
sc5002FarEndAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("thr1", 1), ("thr3", 2), ("thr10", 3), ("thr100", 4), ("thr1000", 5), ("thr10000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002FarEndAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndAlarmThreshold.setDescription("The number of events which must be exceed, within the time period specified by the alarm's window, before declaring an alarm")
sc5002MaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1), )
if mibBuilder.loadTexts: sc5002MaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002MaintenanceTable.setDescription('The table describes the maintenance objects for the unit and references the unit interface (cc = 00).')
sc5002MaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002MaintenanceLineIndex"))
if mibBuilder.loadTexts: sc5002MaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002MaintenanceEntry.setDescription('An entry in the GDC E1 Maintenance Table.')
sc5002MaintenanceLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002MaintenanceLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002MaintenanceLineIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002SoftReset.setDescription('Supports the action of soft resetting the unit. When this object is set to reset(1), then the unit performs a soft reset, whose meaning is specific to the type of unit being managed. The value of norm(2) will be returned when the reset is complete. The value of norm(2) can not be set by management.')
sc5002DefaultInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("factoryDefault", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002DefaultInit.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002DefaultInit.setDescription('This is used to allow the NonVolatile Configuration to be set to a factory default state. When this value is set to factoryDefault(1) the unit will perform a reset to make the default configuration take effect. The value of normal(2) will be returned when the initialization is complete. The value of normal(2) can not be set by management.')
sc5002NearEndResetStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002NearEndResetStats.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndResetStats.setDescription('Supports the action of soft resetting the sc5002NearEndValidIntervals object. When this object is set to reset(2), then the unit will reset the sc5002ValidIntervals object to zero. The value of norm(1) can not be set by management.')
sc5002NearEndStatLastInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndStatLastInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndStatLastInitialized.setDescription('Number of seconds from midnight Dec 31, 1969 up until sc5002NearEndValidIntervals was last initialized to zero')
sc5002FarEndResetStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002FarEndResetStats.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndResetStats.setDescription('Supports the action of soft resetting the sc5002FarEndValidIntervals object. When this object is set to reset(2), then the unit will reset the sc5002ValidIntervals object to zero. The value of norm(1) can not be set by management.')
sc5002FarEndStatLastInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndStatLastInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndStatLastInitialized.setDescription('Number of seconds from midnight Dec 31, 1969 up until sc5002FarEndValidIntervals was last initialized to zero')
sc5002LedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002LedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002LedStatus.setDescription('Returns a bitwise snapshot of the front panel LED state. Octet 1 bit 7 - not used bit 6 - ON bit 5 - INSV bit 4 - RSP bit 3 - TMG bit 2 - NIU bit 1 - D_I bit 0 - future use Octet 2 bit 7 - not used bit 6 - future use bit 5 - NTWK AIS bit 4 - NTWK LCV bit 3 - NTWK LOS bit 2 - NTWK OOF bit 1 - ALM bit 0 - TM Octet 3 bit 7 - not used bit 6 - ST- future use bit 5 - LT- future use bit 4 - RL- future use bit 3 - TM transitions/flashing bit 2 - future use bit 1 - future use bit 0 - future use')
sc5002NearEndValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 16 unless the interface was brought on-line within the last 4 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online.')
sc5002FarEndValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 16 unless the interface was brought on-line within the last 4 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online.')
sc5002SysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002SysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002SysUpTime.setDescription('This variable is used to report the elapsed system tick time for conversion to real time at the controller and is not related to the sysUpTime referenced in MIB-II. Upon power-up of the unit, the elapsed time is cleared. The elapsed time counter rolls over upon reaching the maximum count.')
sc5002NearEndCurrent15MinTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 1), )
if mibBuilder.loadTexts: sc5002NearEndCurrent15MinTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndCurrent15MinTable.setDescription('The sc5002 Current table.')
sc5002NearEndCurrent15MinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 1, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002NearEndCurrent15MinIndex"))
if mibBuilder.loadTexts: sc5002NearEndCurrent15MinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndCurrent15MinEntry.setDescription('An entry in the sc5002 NearEnd Current table.')
sc5002NearEndCurrent15MinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndCurrent15MinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndCurrent15MinIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002NearEndCurrent15MinStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndCurrent15MinStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndCurrent15MinStat.setDescription('Returns a bitwise snapshot of the current 15Min statistics. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 2^9 ES . 1.0 2^7 2.7 f/u 2.6 2^6 . 2.0 2^0 3.7 f/u 3.6 f/u 3.5 f/u 3.4 f/u 3.3 f/u 3.2 2^9 SES . 3.0 2^7 4.7 f/u 4.6 2^6 SES . 4.0 2^0 5.7 f/u 5.6 f/u 5.5 f/u 5.4 f/u 5.3 f/u 5.2 Counter Overflow (>65535) BBE 5.1 2^15 5.0 2^14 6.7 f/u 6.6 2^13 BBE . 6.0 2^7 7.7 f/u 7.6 2^6 BBE . 7.0 2^0 -- 8.7 f/u 8.6 f/u 8.5 f/u 8.4 f/u 8.3 f/u 8.2 2^9 UAS . 8.0 2^7 9.7 f/u 9.6 2^6 UAS . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 Counter Overflow (>65535) LCV 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 LCV . 11.0 2^7 12.7 f/u 12.6 2^6 LCV . 12.0 2^0 ')
sc5002NearEndIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 2), )
if mibBuilder.loadTexts: sc5002NearEndIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndIntervalTable.setDescription('The sc5002 Interval table.')
sc5002NearEndIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 2, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002NearEndIntervalIndex"), (0, "SC5002-MIB", "sc5002NearEndIntervalNumber"))
if mibBuilder.loadTexts: sc5002NearEndIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndIntervalEntry.setDescription('An entry in the E1 Interval table.')
sc5002NearEndIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndIntervalIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002NearEndIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndIntervalNumber.setDescription('The number of Errored Seconds encountered by an E1 interface in one of the previous 16, individual 15 minute, intervals.')
sc5002NearEndIntervalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndIntervalStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndIntervalStat.setDescription('Returns a bitwise map of the interface in one of the previous 16, individual 15 minute, intervals. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 2^9 ES . 1.0 2^7 2.7 f/u 2.6 2^6 . 2.0 2^0 3.7 f/u 3.6 f/u 3.5 f/u 3.4 f/u 3.3 f/u 3.2 2^9 SES . 3.0 2^7 4.7 f/u 4.6 2^6 SES . 4.0 2^0 5.7 f/u 5.6 f/u 5.5 f/u 5.4 f/u 5.3 f/u 5.2 Counter Overflow (>65535) BBE 5.1 2^15 5.0 2^14 6.7 f/u 6.6 2^13 BBE . 6.0 2^7 7.7 f/u 7.6 2^6 BBE . 7.0 2^0 -- 8.7 f/u 8.6 f/u 8.5 f/u 8.4 f/u 8.3 f/u 8.2 2^9 UAS . 8.0 2^7 9.7 f/u 9.6 2^6 UAS . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 Counter Overflow (>65535) LCV 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 LCV . 11.0 2^7 12.7 f/u 12.6 2^6 LCV . 12.0 2^0 ')
sc5002NearEndCurrent24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 3), )
if mibBuilder.loadTexts: sc5002NearEndCurrent24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndCurrent24HrTable.setDescription('The E1 Current24Hr table. 4 hour interval.')
sc5002NearEndCurrent24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 3, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002NearEndCurrent24HrIndex"))
if mibBuilder.loadTexts: sc5002NearEndCurrent24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndCurrent24HrEntry.setDescription('An entry in the E1 Total table.')
sc5002NearEndCurrent24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndCurrent24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndCurrent24HrIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002NearEndCurrent24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndCurrent24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndCurrent24HrStat.setDescription('Returns a bitwise map of the current 24 hour table 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 1: Counter Overflow (>65535) ES 1.1 2^15 1.0 2^14 2.7 f/u 2.6 2^13 ES . 2.0 2^7 3.7 f/u 3.6 2^6 ES . 3.0 2^0 4.7 f/u 4.6 f/u 4.5 f/u 4.4 f/u 4.3 f/u 4.2 1: Counter Overflow (>65535) SES 4.1 2^15 4.0 2^14 5.7 f/u 5.6 2^13 SES . 5.0 2^7 6.7 f/u 6.6 2^6 SES . 6.0 2^0 7.7 f/u 7.6 f/u 7.5 f/u 7.4 f/u 7.3 f/u 7.2 1: Counter Overflow (>65535) BBE 7.1 2^15 7.0 2^14 -- 8.7 f/u 8.6 2^13 BBE . 8.0 2^7 9.7 f/u 9.6 2^6 BBE . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 1: Counter Overflow (>65535) UAS 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 UAS . 11.0 2^7 12.7 f/u 12.6 2^6 UAS . 12.0 2^0 13.7 f/u 13.6 f/u 13.5 f/u 13.4 f/u 13.3 f/u 13.2 1: Counter Overflow (>65535) LCV 13.1 2^15 13.0 2^14 14.7 f/u 14.6 2^13 LCV . 14.0 2^7 15.7 f/u 15.6 2^6 LCV . 15.0 2^0 ')
sc5002NearEndRecent24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 4), )
if mibBuilder.loadTexts: sc5002NearEndRecent24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndRecent24HrTable.setDescription('The E1 Recent24Hr table. 4 hour interval.')
sc5002NearEndRecent24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 4, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002NearEndRecent24HrIndex"))
if mibBuilder.loadTexts: sc5002NearEndRecent24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndRecent24HrEntry.setDescription('An entry in the E1 Total table.')
sc5002NearEndRecent24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndRecent24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndRecent24HrIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002NearEndRecent24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndRecent24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndRecent24HrStat.setDescription('Returns a bitwise map of the current 24 hour table 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 1: Counter Overflow (>65535) ES 1.1 2^15 1.0 2^14 2.7 f/u 2.6 2^13 ES . 2.0 2^7 3.7 f/u 3.6 2^6 ES . 3.0 2^0 4.7 f/u 4.6 f/u 4.5 f/u 4.4 f/u 4.3 f/u 4.2 1: Counter Overflow (>65535) SES 4.1 2^15 4.0 2^14 5.7 f/u 5.6 2^13 SES . 5.0 2^7 6.7 f/u 6.6 2^6 SES . 6.0 2^0 7.7 f/u 7.6 f/u 7.5 f/u 7.4 f/u 7.3 f/u 7.2 1: Counter Overflow (>65535) BBE 7.1 2^15 7.0 2^14 -- 8.7 f/u 8.6 2^13 BBE . 8.0 2^7 9.7 f/u 9.6 2^6 BBE . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 1: Counter Overflow (>65535) UAS 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 UAS . 11.0 2^7 12.7 f/u 12.6 2^6 UAS . 12.0 2^0 13.7 f/u 13.6 f/u 13.5 f/u 13.4 f/u 13.3 f/u 13.2 1: Counter Overflow (>65535) LCV 13.1 2^15 13.0 2^14 14.7 f/u 14.6 2^13 LCV . 14.0 2^7 15.7 f/u 15.6 2^6 LCV . 15.0 2^0 ')
sc5002FarEndCurrent15MinTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 5), )
if mibBuilder.loadTexts: sc5002FarEndCurrent15MinTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndCurrent15MinTable.setDescription('The sc5002FarEnd Current 15 minute table.')
sc5002FarEndCurrent15MinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 5, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002FarEndCurrent15MinIndex"))
if mibBuilder.loadTexts: sc5002FarEndCurrent15MinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndCurrent15MinEntry.setDescription('An entry in the sc5002FarEnd Current 15 Minute table.')
sc5002FarEndCurrent15MinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndCurrent15MinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndCurrent15MinIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002FarEndCurrent15MinStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndCurrent15MinStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndCurrent15MinStat.setDescription('Returns a bitwise map of the far end interface in one of the previous 16, individual 15 minute, intervals. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 2^9 ES . 1.0 2^7 2.7 f/u 2.6 2^6 . 2.0 2^0 3.7 f/u 3.6 f/u 3.5 f/u 3.4 f/u 3.3 f/u 3.2 2^9 SES . 3.0 2^7 4.7 f/u 4.6 2^6 SES . 4.0 2^0 5.7 f/u 5.6 f/u 5.5 f/u 5.4 f/u 5.3 f/u 5.2 Counter Overflow (>65535) BBE 5.1 2^15 5.0 2^14 6.7 f/u 6.6 2^13 BBE . 6.0 2^7 7.7 f/u 7.6 2^6 BBE . 7.0 2^0 -- 8.7 f/u 8.6 f/u 8.5 f/u 8.4 f/u 8.3 f/u 8.2 2^9 UAS . 8.0 2^7 9.7 f/u 9.6 2^6 UAS . 9.0 2^0 ')
sc5002FarEndIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 6), )
if mibBuilder.loadTexts: sc5002FarEndIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndIntervalTable.setDescription('The sc5002FarEnd Interval table.')
sc5002FarEndIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 6, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002FarEndIntervalIndex"), (0, "SC5002-MIB", "sc5002FarEndIntervalNumber"))
if mibBuilder.loadTexts: sc5002FarEndIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndIntervalEntry.setDescription('An entry in the Interval table.')
sc5002FarEndIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndIntervalIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002FarEndIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndIntervalNumber.setDescription('A number between 1 and 16, where 1 is the most recently completed 15 minute interval and 16 is the least recently completed 15 minutes interval (assuming that all 16 intervals are valid).')
sc5002FarEndIntervalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndIntervalStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndIntervalStat.setDescription('Returns a bitwise map of statistics for the far end interface in the current 15 minute interval. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 2^9 ES . 1.0 2^7 2.7 f/u 2.6 2^6 . 2.0 2^0 3.7 f/u 3.6 f/u 3.5 f/u 3.4 f/u 3.3 f/u 3.2 2^9 SES . 3.0 2^7 4.7 f/u 4.6 2^6 SES . 4.0 2^0 5.7 f/u 5.6 f/u 5.5 f/u 5.4 f/u 5.3 f/u 5.2 Counter Overflow (>65535) BBE 5.1 2^15 5.0 2^14 6.7 f/u 6.6 2^13 BBE . 6.0 2^7 7.7 f/u 7.6 2^6 BBE . 7.0 2^0 8.7 f/u 8.6 f/u 8.5 f/u 8.4 f/u 8.3 f/u 8.2 2^9 UAS . 8.0 2^7 9.7 f/u 9.6 2^6 UAS . 9.0 2^0 ')
sc5002CurrentFarEnd24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 7), )
if mibBuilder.loadTexts: sc5002CurrentFarEnd24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002CurrentFarEnd24HrTable.setDescription('The Current 24 Hour table.')
sc5002CurrentFarEnd24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 7, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002CurrentFarEnd24HrIndex"))
if mibBuilder.loadTexts: sc5002CurrentFarEnd24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002CurrentFarEnd24HrEntry.setDescription('An entry in the Current 24 Hr table.')
sc5002CurrentFarEnd24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 7, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002CurrentFarEnd24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002CurrentFarEnd24HrIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002CurrentFarEnd24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002CurrentFarEnd24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002CurrentFarEnd24HrStat.setDescription('Returns a bitwise map of statistics for the interface in the current 24 hour interval. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 1: Counter Overflow (>65535) ES 1.1 2^15 1.0 2^14 2.7 f/u 2.6 2^13 ES . 2.0 2^7 3.7 f/u 3.6 2^6 ES . 3.0 2^0 4.7 f/u 4.6 f/u 4.5 f/u 4.4 f/u 4.3 f/u 4.2 1: Counter Overflow (>65535) SES 4.1 2^15 4.0 2^14 5.7 f/u 5.6 2^13 SES . 5.0 2^7 6.7 f/u 6.6 2^6 SES . 6.0 2^0 -- 7.7 f/u 7.6 f/u 7.5 f/u 7.4 f/u 7.3 f/u 7.2 1: Counter Overflow (>65535) BBE 7.1 2^15 7.0 2^14 8.7 f/u 8.6 2^13 BBE . 8.0 2^7 9.7 f/u 9.6 2^6 BBE . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 1: Counter Overflow (>65535) UAS 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 UAS . 11.0 2^7 12.7 f/u 12.6 2^6 UAS . 12.0 2^0 ')
sc5002RecentFarEnd24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 8), )
if mibBuilder.loadTexts: sc5002RecentFarEnd24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002RecentFarEnd24HrTable.setDescription('The Recent 24 Hour table.')
sc5002RecentFarEnd24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 8, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002RecentFarEnd24HrIndex"))
if mibBuilder.loadTexts: sc5002RecentFarEnd24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002RecentFarEnd24HrEntry.setDescription('An entry in the Recent 24 Hr table.')
sc5002RecentFarEnd24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002RecentFarEnd24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002RecentFarEnd24HrIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002RecentFarEnd24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002RecentFarEnd24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002RecentFarEnd24HrStat.setDescription('Returns a bitwise map of statistics for the interface in the Recent 24 hour interval. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 1: Counter Overflow (>65535) ES 1.1 2^15 1.0 2^14 2.7 f/u 2.6 2^13 ES . 2.0 2^7 3.7 f/u 3.6 2^6 ES . 3.0 2^0 4.7 f/u 4.6 f/u 4.5 f/u 4.4 f/u 4.3 f/u 4.2 1: Counter Overflow (>65535) SES 4.1 2^15 4.0 2^14 5.7 f/u 5.6 2^13 SES . 5.0 2^7 6.7 f/u 6.6 2^6 SES . 6.0 2^0 7.7 f/u 7.6 f/u 7.5 f/u 7.4 f/u 7.3 f/u 7.2 1: Counter Overflow (>65535) BBE 7.1 2^15 7.0 2^14 8.7 f/u 8.6 2^13 BBE . 8.0 2^7 9.7 f/u 9.6 2^6 BBE . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 1: Counter Overflow (>65535) UAS 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 UAS . 11.0 2^7 12.7 f/u 12.6 2^6 UAS . 12.0 2^0 ')
sc5002NearEndUnavailableTimeRegTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 9), )
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegTable.setDescription('The sc5002 Unavailable Time Register table.')
sc5002NearEndUnavailableTimeRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 9, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002NearEndUnavailableTimeRegIndex"), (0, "SC5002-MIB", "sc5002NearEndUnavailableTimeRegNumber"))
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegEntry.setDescription('An entry in the Unavailable Time Register table.')
sc5002NearEndUnavailableTimeRegIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 9, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002NearEndUnavailableTimeRegNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegNumber.setDescription('A number between 1 and 6, where the number is the number of the Unavailable Time Register.')
sc5002NearEndUnavailableTimeRegStart = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegStart.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegStart.setDescription('Start time of one of the Unavailable Time Registers.')
sc5002NearEndUnavailableTimeRegStop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegStop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002NearEndUnavailableTimeRegStop.setDescription('Stop time of one of the Unavailable Time Registers.')
sc5002FarEndUnavailableTimeRegTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 10), )
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegTable.setDescription('The sc5002 Unavailable Time Register table.')
sc5002FarEndUnavailableTimeRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 10, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002FarEndUnavailableTimeRegIndex"), (0, "SC5002-MIB", "sc5002FarEndUnavailableTimeRegNumber"))
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegEntry.setDescription('An entry in the Unavailable Time Register table.')
sc5002FarEndUnavailableTimeRegIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 10, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002FarEndUnavailableTimeRegNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegNumber.setDescription('A number between 1 and 6, where the number is the number of the Unavailable Time Register.')
sc5002FarEndUnavailableTimeRegStart = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegStart.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegStart.setDescription('Start time of one of the Unavailable Time Registers.')
sc5002FarEndUnavailableTimeRegStop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 6, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegStop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002FarEndUnavailableTimeRegStop.setDescription('Stop time of one of the Unavailable Time Registers.')
sc5002DiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 8, 4, 1), )
if mibBuilder.loadTexts: sc5002DiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002DiagTable.setDescription('The GDC 5002 Diagnostics table. Information in the entries of this table support diagnostics testing, both active testing via patterns, and passive testing via loopbacks.')
sc5002DiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 8, 4, 1, 1), ).setIndexNames((0, "SC5002-MIB", "sc5002DiagIndex"))
if mibBuilder.loadTexts: sc5002DiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002DiagEntry.setDescription('The GDC 5002 Diagnostics table entry.')
sc5002DiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 4, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002DiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002DiagIndex.setDescription('Integer value which uniquely identifies the SC5002 to which this entry is applicable. SCinstance is defined to be ssllddcc where: ss (byte value) - physical shelf slot location (01-32) ll (byte value) - line number (01-128) dd (byte value) - drop number (00-31) cc (byte value) - channel or interface number (always 00)')
sc5002LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noLoopBack", 1), ("lineLoopBack", 2), ("unitTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5002LoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002LoopbackConfig.setDescription('Selects the test to run. A get of this object returns the test that is currently running. A set of noLoopBack(1) ends the test that is currently running. A set of lineLoopBack(2) starts a line loop back test. The line loop back test runs until a set of noLoopBack(1) is sent. A set of unitTest(3) starts a unit test. The unit test runs for 15 seconds.')
sc5002TestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 8, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pass", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5002TestResult.setStatus('mandatory')
if mibBuilder.loadTexts: sc5002TestResult.setDescription('The results of the last diagnostic test completed. The value returned is only valid if a get of sc5002LoopbackConfig returns noLoopBack(1).')
mibBuilder.exportSymbols("SC5002-MIB", sc5002NearEndSevErrSec=sc5002NearEndSevErrSec, sc5002CurrentFarEnd24HrIndex=sc5002CurrentFarEnd24HrIndex, sc5002PowerUp=sc5002PowerUp, sc5002LossOfFrame=sc5002LossOfFrame, sc5002RecentFarEnd24HrStat=sc5002RecentFarEnd24HrStat, sc5002ActiveFirmwareRev=sc5002ActiveFirmwareRev, sc5002RecentFarEnd24HrIndex=sc5002RecentFarEnd24HrIndex, sc5002NearEndAlarmCfgIdentifier=sc5002NearEndAlarmCfgIdentifier, sc5002MaintenanceLineIndex=sc5002MaintenanceLineIndex, sc5002FarEndAlarmCfgEntry=sc5002FarEndAlarmCfgEntry, sc5002NearEndCurrent15MinIndex=sc5002NearEndCurrent15MinIndex, sc5002FarEndCurrent15MinIndex=sc5002FarEndCurrent15MinIndex, sc5002NearEndResetStats=sc5002NearEndResetStats, sc5002DiagIndex=sc5002DiagIndex, sc5002NearEndLnCodeViol=sc5002NearEndLnCodeViol, sc5002VersionIndex=sc5002VersionIndex, sc5002FarEndResetStats=sc5002FarEndResetStats, gdc=gdc, sc5002FarEndCurrent15MinTable=sc5002FarEndCurrent15MinTable, sc5002FarEndUnavailableTimeRegTable=sc5002FarEndUnavailableTimeRegTable, sc5002DiagTable=sc5002DiagTable, sc5002FarEndUnavailableTimeRegIndex=sc5002FarEndUnavailableTimeRegIndex, sc5002DiagEntry=sc5002DiagEntry, sc5002FarEndUnavailableTimeRegStart=sc5002FarEndUnavailableTimeRegStart, sc5002StoredFirmwareStatus=sc5002StoredFirmwareStatus, sc5002FarEndBkdBlkErr=sc5002FarEndBkdBlkErr, sc5002TestResult=sc5002TestResult, sc5002NearEndAlarmWindow=sc5002NearEndAlarmWindow, sc5002MaintenanceEntry=sc5002MaintenanceEntry, sc5002NearEndCurrent24HrEntry=sc5002NearEndCurrent24HrEntry, sc5002FarEndErrSec=sc5002FarEndErrSec, sc5002DiagRxErr=sc5002DiagRxErr, sc5002SwitchActiveFirmware=sc5002SwitchActiveFirmware, sc5002NoResponse=sc5002NoResponse, sc5002NearEndStatLastInitialized=sc5002NearEndStatLastInitialized, sc5002Alarms=sc5002Alarms, sc5002VersionTable=sc5002VersionTable, sc5002NearEndCurrent24HrStat=sc5002NearEndCurrent24HrStat, sc5002NearEndAlarmCfgIndex=sc5002NearEndAlarmCfgIndex, sc5002RecentFarEnd24HrTable=sc5002RecentFarEnd24HrTable, sc5002Performance=sc5002Performance, sc5002NearEndRecent24HrStat=sc5002NearEndRecent24HrStat, sc5002FarEndIntervalIndex=sc5002FarEndIntervalIndex, sc5002NearEndAlarmCfgTable=sc5002NearEndAlarmCfgTable, sc5002CurrentFarEnd24HrStat=sc5002CurrentFarEnd24HrStat, sc5002AlarmData=sc5002AlarmData, sc5002FarEndIntervalNumber=sc5002FarEndIntervalNumber, sc5002FarEndIntervalTable=sc5002FarEndIntervalTable, sc5002CurrentFarEnd24HrTable=sc5002CurrentFarEnd24HrTable, sc5002NearEndCurrent15MinStat=sc5002NearEndCurrent15MinStat, sc5002FarEndValidIntervals=sc5002FarEndValidIntervals, sc5002AlarmIndSignal=sc5002AlarmIndSignal, sc5002FarEndUnavlSec=sc5002FarEndUnavlSec, sc5002NearEndErrSec=sc5002NearEndErrSec, sc5002E1SignalingMode=sc5002E1SignalingMode, sc5002NearEndCurrent24HrTable=sc5002NearEndCurrent24HrTable, dsx1=dsx1, sc5002NearEndValidIntervals=sc5002NearEndValidIntervals, sc5002LoopbackConfig=sc5002LoopbackConfig, sc5002NetworkCfgTable=sc5002NetworkCfgTable, sc5002NearEndRecent24HrEntry=sc5002NearEndRecent24HrEntry, sc5002FarEndIntervalStat=sc5002FarEndIntervalStat, sc5002FarEndIntervalEntry=sc5002FarEndIntervalEntry, sc5002NearEndCurrent24HrIndex=sc5002NearEndCurrent24HrIndex, sc5002NetworkCfg=sc5002NetworkCfg, sc5002FarEndSevErrSec=sc5002FarEndSevErrSec, sc5002FarEndCurrent15MinStat=sc5002FarEndCurrent15MinStat, sc5002CurrentFarEnd24HrEntry=sc5002CurrentFarEnd24HrEntry, sc5002NvRamCorrupt=sc5002NvRamCorrupt, sc5002NearEndUnavailableTimeRegTable=sc5002NearEndUnavailableTimeRegTable, sc5002NetworkCfgIndex=sc5002NetworkCfgIndex, sc5002FarEndStatLastInitialized=sc5002FarEndStatLastInitialized, sc5002NearEndUnavailableTimeRegStart=sc5002NearEndUnavailableTimeRegStart, sc5002NearEndCurrent15MinTable=sc5002NearEndCurrent15MinTable, sc5002FarEndAlarmCfgIdentifier=sc5002FarEndAlarmCfgIdentifier, sc5002NearEndAlarmCfgEntry=sc5002NearEndAlarmCfgEntry, sc5002DownloadingMode=sc5002DownloadingMode, sc5002FirmwareRev=sc5002FirmwareRev, sc5002NearEndUnavailableTimeRegStop=sc5002NearEndUnavailableTimeRegStop, sc5002Version=sc5002Version, sc5002NearEndIntervalNumber=sc5002NearEndIntervalNumber, sc5002LedStatus=sc5002LedStatus, sc5002NearEndRecent24HrTable=sc5002NearEndRecent24HrTable, sc5002RecentFarEnd24HrEntry=sc5002RecentFarEnd24HrEntry, sc5002VersionEntry=sc5002VersionEntry, sc5002FarEndCurrent15MinEntry=sc5002FarEndCurrent15MinEntry, sc5002NetworkCfgEntry=sc5002NetworkCfgEntry, sc5002FarEndAlarmCfgIndex=sc5002FarEndAlarmCfgIndex, sc5002UnitFailure=sc5002UnitFailure, sc5002NearEndUnavailableTimeRegEntry=sc5002NearEndUnavailableTimeRegEntry, sc5002DefaultInit=sc5002DefaultInit, sc5002NearEndAlarmThreshold=sc5002NearEndAlarmThreshold, sc5002NearEndBkdBlkErr=sc5002NearEndBkdBlkErr, sc5002Maintenance=sc5002Maintenance, sc5002SoftReset=sc5002SoftReset, sc5002NearEndUnavailableTimeRegIndex=sc5002NearEndUnavailableTimeRegIndex, sc5002NearEndCurrent15MinEntry=sc5002NearEndCurrent15MinEntry, sc5002MIBversion=sc5002MIBversion, sc5002BootRev=sc5002BootRev, sc5002NearEndIntervalEntry=sc5002NearEndIntervalEntry, sc5002FarEndAlarmCfgTable=sc5002FarEndAlarmCfgTable, sc5002NearEndUnavailableTimeRegNumber=sc5002NearEndUnavailableTimeRegNumber, sc5002TimingLoss=sc5002TimingLoss, sc5002FarEndAlarmThreshold=sc5002FarEndAlarmThreshold, sc5002NearEndIntervalIndex=sc5002NearEndIntervalIndex, sc5002NearEndIntervalStat=sc5002NearEndIntervalStat, sc5002NearEndIntervalTable=sc5002NearEndIntervalTable, sc5002FarEndUnavailableTimeRegStop=sc5002FarEndUnavailableTimeRegStop, sc5002FarEndUnavailableTimeRegNumber=sc5002FarEndUnavailableTimeRegNumber, sc5002=sc5002, sc5002FarEndUnavailableTimeRegEntry=sc5002FarEndUnavailableTimeRegEntry, sc5002FallbackTimingActive=sc5002FallbackTimingActive, sc5002NearEndUnavlSec=sc5002NearEndUnavlSec, sc5002FarEndAlarmWindow=sc5002FarEndAlarmWindow, sc5002MaintenanceTable=sc5002MaintenanceTable, sc5002SysUpTime=sc5002SysUpTime, sc5002NearEndRecent24HrIndex=sc5002NearEndRecent24HrIndex, sc5002LossOfSignal=sc5002LossOfSignal, sc5002StoredFirmwareRev=sc5002StoredFirmwareRev, sc5002Diagnostics=sc5002Diagnostics)

#
# PySNMP MIB module CPQCR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CPQCR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
cpqHoTrapFlags, compaq = mibBuilder.importSymbols("CPQHOST-MIB", "cpqHoTrapFlags", "compaq")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter32, iso, IpAddress, ModuleIdentity, NotificationType, TimeTicks, MibIdentifier, Unsigned32, ObjectIdentity, Counter64, enterprises, Gauge32, Integer32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter32", "iso", "IpAddress", "ModuleIdentity", "NotificationType", "TimeTicks", "MibIdentifier", "Unsigned32", "ObjectIdentity", "Counter64", "enterprises", "Gauge32", "Integer32", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
cpqClusteredRAID = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141))
cpqCrMibRev = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 1))
cpqCrComponent = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2))
cpqCrTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 3))
cpqCrInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 1))
cpqCrCntlr = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 2))
cpqCrLogDrv = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 3))
cpqCrSpareDrv = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 4))
cpqCrPhyDrv = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 5))
cpqCrEMU = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 7))
cpqCrExpCab = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 8))
cpqCrPartition = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 9))
cpqCrOsCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 2, 1, 4))
cpqCrInterfaceTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 3, 1))
cpqCrCntlrTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 3, 2))
cpqCrLogDrvTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 3, 3))
cpqCrSpareDrvTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 3, 4))
cpqCrPhyDrvTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 3, 5))
cpqCrEMUTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 3, 7))
cpqCrExpCabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 141, 3, 8))
cpqCrMibRevMajor = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrMibRevMajor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrMibRevMajor.setDescription('The Major Revision level. A change in the major revision level represents a major change in the architecture of the MIB. A change in the major revision level may indicate a significant change in the information supported and/or the meaning of the supported information, correct interpretation of data may require a MIB document with the same major revision level.')
cpqCrMibRevMinor = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrMibRevMinor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrMibRevMinor.setDescription('The Minor Revision level. A change in the minor revision level may represent some minor additional support, no changes to any pre-existing information has occurred.')
cpqCrMibCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrMibCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrMibCondition.setDescription('The overall condition (status) of the system represented by this MIB.')
cpqCrOsCommonPollFreq = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqCrOsCommonPollFreq.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrOsCommonPollFreq.setDescription("The Insight Agent's polling frequency. The frequency, in seconds, at which the Insight Agent requests information from the device driver. A frequency of zero (0) indicates that the Insight Agent retrieves the information upon request of a management station, it does not poll the device driver at a specific interval. The polling frequency is set in a configuration file used by the agent.")
cpqCrCntlrTable = MibTable((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1), )
if mibBuilder.loadTexts: cpqCrCntlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrTable.setDescription('Clustered RAID Array Controller Table.')
cpqCrCntlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1), ).setIndexNames((0, "CPQCR-MIB", "cpqCrCntlrIndex"))
if mibBuilder.loadTexts: cpqCrCntlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrEntry.setDescription('Clustered RAID Array Controller Entry.')
cpqCrCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrIndex.setDescription('Clustered RAID Array Controller Index. This value is a logical number whose meaning is OS dependent. Each physical controller has one unique controller number associated with it.')
cpqCrCntlrSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrSerialNumber.setDescription('CR3500 Controller Serial Number.')
cpqCrCntlrFWRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrFWRev.setDescription('Clustered RAID Array Controller Firmware Revision. The firmware revision of the Clustered RAID Controller. This value can be used to help identify a particular revision of the controller.')
cpqCrCntlrCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrCondition.setDescription('The condition of the device. This value represents the overall condition of this controller, and any associated logical drives, physical drives, and array accelerators.')
cpqCrCntlrCurrentRole = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("notDuplexed", 2), ("active", 3), ("backup", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrCurrentRole.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrCurrentRole.setDescription('Clustered RAID Array Controller Current Role. For duplexed array controllers, this is the controllers current role. The following values are valid: other (1) Indicates that the instrument agent does not recognize the role of the controller. You may need to upgrade the instrument agent. notDuplexed (2) This array controller is not duplexed. active (3) This duplexed array controller is the active controller. backup (4) This duplexed array controller is the backup controller.')
cpqCrCntlrDriveOwnership = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("owner", 2), ("notOwner", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrDriveOwnership.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrDriveOwnership.setDescription('Clustered RAID Array Controller Drive Ownership. For duplexed controllers, indicates to which controller slot the shared devices are associated. The following values are valid: other (1) Indicates that the instrument agent does not recognize the status of the controller. You may need to upgrade the instrument agent. owner (2) All the logical, physical and spare drives are associated with this controller. notOwner (3) The logical, physical and spare drives are not associated with this controller.')
cpqCrCntlrRebuildRate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrRebuildRate.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrRebuildRate.setDescription('Clustered RAID Array Controller Rebuild Rate. Determines the rate at which disks are to be rebuilt if there is I/O activity. 1 = Minimum rate 100 = Maximum rate')
cpqCrCntlrCreateRate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrCreateRate.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrCreateRate.setDescription('Clustered RAID Array Controller Create Rate. Determines the rate at which RAIDsets are to be created if there is I/O activity. 1 = Minimum rate 100 = maximum rate')
cpqCrCntlrCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrCacheSize.setDescription("Clustered RAID Array Controller Cache Size. Size of the controller's cache in MB.")
cpqCrCntlrSimmSizeA = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrSimmSizeA.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrSimmSizeA.setDescription('Clustered RAID Array Controller Memory Module Size. Size of the memory module in slot A in MB.')
cpqCrCntlrSimmSizeB = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrCntlrSimmSizeB.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrCntlrSimmSizeB.setDescription('Clustered RAID Array Controller Memory Module Size. Size of the memory module in slot B in MB.')
cpqCrLogDrvTable = MibTable((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1), )
if mibBuilder.loadTexts: cpqCrLogDrvTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvTable.setDescription('Clustered RAID RAIDset Table. A table of RAIDset entries.')
cpqCrLogDrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1), ).setIndexNames((0, "CPQCR-MIB", "cpqCrLogDrvCntlrIndex"), (0, "CPQCR-MIB", "cpqCrLogDrvIndex"))
if mibBuilder.loadTexts: cpqCrLogDrvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvEntry.setDescription('Clustered RAID RAIDset Entry. A RAIDset entry.')
cpqCrLogDrvCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvCntlrIndex.setDescription("Clustered RAID RAIDset Controller Index. This maps the RAIDsets into their respective controllers. Controller index 'i' under the controller group owns the associated drives in the RAIDset which use that index.")
cpqCrLogDrvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvIndex.setDescription('Clustered RAID RAIDset Index. This logical drive number keeps track of multiple instances of logical drives which are on the same controller. For each controller index value, the logical drive index starts at 1 and increments for each logical drive.')
cpqCrLogDrvRAIDLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("jbod", 2), ("raid0", 3), ("raid1", 4), ("raid0plus1", 5), ("raid4", 6), ("raid5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvRAIDLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvRAIDLevel.setDescription('RAID Level. This shows the RAID level of the RAIDset. To change the RAID level, run the CL1850 Array Configuration Utility. The following values are valid for the RAIDset RAID Level: JBOD (2) Just a Bunch of Drives. Fault tolerance is not enabled. This RAIDset is made up of one device. Does not provide extended data redundancy, availability or protection, and does not use striping for performance enhancements. Good for applications requiring high device capacity. Requires one and only one device. RAID0 (3) A RAIDset using device striping and write-back caching. Data is spread across many devices, offering faster read/write performance than a single device. Does not provide extended data redundancy, availability or protection. Good for applications with large files needing high I/O performance. Requires a minimum of two devices. RAID1 (4) A RAIDset using device mirroring. Any time data is written to a device, a duplicate write is also made to a second device. Reading from multiple devices is usually faster than reading from a single device. Provides extended data redundancy, availability and protection. Good for read-intensive applications needing high availability. Requires a minimum of two devices. RAID0PLUS1 (5) A RAIDset where data is striped across devices and duplicated on an equivalent number of devies. Provides extended data redundancy, availability and protection. Good for applications requiring high availability, high performance and capacity. Requires an even number of devices, and a minimum of four devices. RAID4 (6) A RAIDset using device striping, with one device assigned for parity. Provides extended data redundancy, availability and protection. Good for applications such as graphics and imaging that call for writing huge, sequential blocks of data. Requires a minimum of three devices. RAID5(7) A RAIDset using device striping, with parity distributed across devices. Provides extended data redundancy, availability and protection. Good for transaction processing, applications requiring many, small I/O operations scattered randomly and widely across the devices. Requires a minimum of three devices.')
cpqCrLogDrvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("good", 2), ("reduced", 3), ("failed", 4), ("reconstructing", 5), ("initializing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvStatus.setDescription("RAIDset Status. The RAIDset can be in one of the following states: Good (2) Indicates that the RAIDset is fully operational. Reduced (3) Indicates that the RAIDset is operating in a degraded or reduced state. One or more of the physical disks which make up the RAIDset are either missing or failed, but the RAIDset can continue to operate without data loss. Failed (4) Indicates that the RAIDset is not operational. Reconstructing (5) Indicates that the RAIDset is regenerating a failed physical drive's data onto a replacement drive that is part of the RAIDset. All user data remains available during the reconstruction process, but some performance reduction may occur when a request requires access to the device being reconstructed. Initializing (6) Indicates that the controller is writing its file structure onto the RAIDset's member devices.")
cpqCrLogDrvRebuildPercentage = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvRebuildPercentage.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvRebuildPercentage.setDescription('RAIDset Rebuild Percentage Complete. After a failed physical drive has been replaced, the physical drive must have its data rebuilt. This value shows how far the rebuild process has progressed as a percentage. When the value reaches 100, the rebuilding process is complete. The drive array continues to operate in reduced mode while a drive is rebuilding. This value is only valid if the RAIDset Status is reconstructing (6).')
cpqCrLogDrvAvailSpares = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvAvailSpares.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvAvailSpares.setDescription("RAIDset Available Spares. This indicates if this RAIDset has one or more spares designated for it that are not currently in use by another drive. Each octet present will be a physical drive ID that is an available spare for this logical drive. These are the same ID's which can be used as indexes into the physical drive table. An octet string of length zero indicates that there are no available spares for this logical drive.")
cpqCrLogDrvSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvSize.setDescription('RAIDset Size. This is the size of the RAIDset in megabytes. This value is calculated using the value 1,048,576 (2^20) as a megabyte. Drive manufacturers sometimes use the number 1,000,000 as a megabyte when giving drive capacities so this value may differ from the advertised size of a drive.')
cpqCrLogDrvPhyDrvIDs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvPhyDrvIDs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvPhyDrvIDs.setDescription('RAIDset Physical Drive IDs. This lists the physical drive IDs which are associated with this RAIDset. These are the same IDs which can be used as indices into the physical drive table. Each byte of the string is an index.')
cpqCrLogDrvCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvCondition.setDescription('RAIDset condition. This value represents the overall condition of this RAIDset and any associated physical drives.')
cpqCrLogDrvPartitionIDs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 3, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrLogDrvPartitionIDs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrLogDrvPartitionIDs.setDescription('RAIDset Logical Drive IDs. This lists the logical drive IDs which are associated with this RAIDset. These are the same IDs which can be used as indices into the logical drive table. Each byte of the string is an index.')
cpqCrSpareTable = MibTable((1, 3, 6, 1, 4, 1, 232, 141, 2, 4, 1), )
if mibBuilder.loadTexts: cpqCrSpareTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrSpareTable.setDescription('Clustered RAID Spare Table. A table of spare entries.')
cpqCrSpareEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 141, 2, 4, 1, 1), ).setIndexNames((0, "CPQCR-MIB", "cpqCrSpareCntlrIndex"), (0, "CPQCR-MIB", "cpqCrSparePhyDrvIndex"))
if mibBuilder.loadTexts: cpqCrSpareEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrSpareEntry.setDescription('Clustered RAID Spare Entry. An entry in the spare table.')
cpqCrSpareCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrSpareCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrSpareCntlrIndex.setDescription('Spare Controller Index. This index maps the spare drive back to the controller to which it is attached. The value of this index is the same as the one used under the controller group.')
cpqCrSparePhyDrvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrSparePhyDrvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrSparePhyDrvIndex.setDescription('Physical Drive Index. This index maps the spare to the physical drive it represents. The value of this index is the same as the one used with the physical drive table.')
cpqCrSpareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("empty", 2), ("offline", 3), ("online", 4), ("hotSpare", 5), ("warmSpare", 6), ("creating", 7), ("rebuilding", 8), ("addingSpare", 9), ("formatting", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrSpareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrSpareStatus.setDescription('Spare Status. This shows the status of the on-line spare drive. The following values are valid for the spare status: Hot Spare(5) The drive attached to this channel is kept spinning whenever the controller is powered up and it is to be automatically brought online to replace a failed drive. Warm Spare(6) The drive attached to this channel is not spun up until a disk in the array fails and it is automatically brought online to replace a failed drive. Adding Spare(9) The drive is in the process of becoming a spare drive.')
cpqCrSpareCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrSpareCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrSpareCondition.setDescription('Spare Drive condition. This value represents the overall condition of this spare drive and any associated physical drives.')
cpqCrSpareScsiID = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrSpareScsiID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrSpareScsiID.setDescription('SCSI ID. This value represents the SCSI identifier of this spare drive.')
cpqCrPhyDrvTable = MibTable((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1), )
if mibBuilder.loadTexts: cpqCrPhyDrvTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvTable.setDescription('Clustered RAID Physical Drive Table. A table of physical drive entries.')
cpqCrPhyDrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1), ).setIndexNames((0, "CPQCR-MIB", "cpqCrPhyDrvCntlrIndex"), (0, "CPQCR-MIB", "cpqCrPhyDrvIndex"))
if mibBuilder.loadTexts: cpqCrPhyDrvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvEntry.setDescription('Clustered RAID Physical Drive Entry. A physical drive entry.')
cpqCrPhyDrvCntlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvCntlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvCntlrIndex.setDescription('Clustered RAID Physical Drive Controller Index. This index maps the physical drive back to the controller to which it is attached. The value of this index is the same as the one used under the controller group.')
cpqCrPhyDrvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvIndex.setDescription('Clustered RAID Physical Drive Index. This index is used for selecting the physical drive table entry. This number, along with the cpqCrPhyDrvCntlrIndex uniquely identify a specific physical drive.')
cpqCrPhyDrvVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvVendor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvVendor.setDescription('Physical Drive Vendor. This is the name of the manufacturer of the physical drive. This value is based upon the vendor name as returned by the SCSI inquiry command but may have been modified due to space limitations. This can be used for identification purposes.')
cpqCrPhyDrvModel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvModel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvModel.setDescription('Physical Drive Model. This is a text description of the physical drive. The text that appears depends upon who manufactured the drive and the drive type. For example, you might see: CP3201. If a drive fails, note the model to identify the type of drive necessary for replacement.')
cpqCrPhyDrvRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvRevision.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvRevision.setDescription('Physical Drive Revision. This shows the physical drive revision number.')
cpqCrPhyDrvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("empty", 2), ("offline", 3), ("online", 4), ("hotSpare", 5), ("warmSpare", 6), ("creating", 7), ("rebuilding", 8), ("addingSpare", 9), ("formatting", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvStatus.setDescription('Physical Drive Status. This shows the status of the physical drive. The following values are valid for the physical drive status: Offline (3) The drive attached to this channel is not a member of the RAID set. Online (4) The drive attached to this channel is a fully functional member of this RAID set. Creating (5) The drive is currently being created as part of a RAID set. Rebuilding (6) The drive is currently being rebuilt. Formatting (8) The drive is currently being formatted')
cpqCrPhyDrvSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvSize.setDescription('Physical Drive Size in MB. This is the size of the physical drive in megabytes. This value is calculated using the value 1,048,576 (2^20) as a megabyte. Drive manufacturers sometimes use the number 1,000,000 as a megabyte when giving drive capacities so this value may differ from the advertised size of a drive. This field is only applicable for controllers which support SCSI drives, and therefore is not supported by the IDA or IDA-2 controllers. The field will contain 0xFFFFFFFF if the drive capacity cannot be calculated or if the controller does not support SCSI drives.')
cpqCrPhyDrvCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvCondition.setDescription('Physical Drive condition. This value represents the overall condition of this physical drive.')
cpqCrPhyDrvScsiID = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPhyDrvScsiID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPhyDrvScsiID.setDescription('SCSI ID. This value represents the SCSI identifier of this physical drive.')
cpqCrEMUBoardTemperatureStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("emuBoardTempNotInstalled", 2), ("emuBoardTempNormal", 3), ("emuBoardTempBelowNormal", 4), ("emuBoardTempAboveNormal", 5), ("emuBoardTempFarBelowNormal", 6), ("emuBoardTempFarAboveNormal", 7), ("emuBoardTempBackToNormal", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUBoardTemperatureStatus.setStatus('deprecated')
if mibBuilder.loadTexts: cpqCrEMUBoardTemperatureStatus.setDescription('Environmental Monitoring Unit (EMU) Board Temperature status. The System Board Temperature status as determined by the EMU is: Not Installed (2) The board temperature can not be detected in the unit. Normal (3) The board temperature detected by the EMU is normal. Below Normal (4) The board temperature detected by the EMU is below normal. Above Normal (5) The board temperature detected by the EMU is above normal. Far Below Normal (6) The board temperature detected by the EMU is far below normal. Far Above Normal (7) The board temperature detected by the EMU is far above normal. Back To Normal (8) The board temperature detected by the EMU has returned to normal.')
cpqCrEMUEnclosureTemperatureStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("emuEnclosureTempNotInstalled", 2), ("emuEnclosureTempNormal", 3), ("emuEnclosureTempBelowNormal", 4), ("emuEnclosureTempAboveNormal", 5), ("emuEnclosureTempFarBelowNormal", 6), ("emuEnclosureTempFarAboveNormal", 7), ("emuEnclosureTempBackToNormal", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUEnclosureTemperatureStatus.setStatus('deprecated')
if mibBuilder.loadTexts: cpqCrEMUEnclosureTemperatureStatus.setDescription('Environmental Monitoring Unit (EMU) Enclosure Temperature status. The Enclosure Housing Temperature status as determined by the EMU is: Not Installed (2) The enclosure temperature can not be detected in the unit. Normal (3) The enclosure temperature detected by the EMU is normal. Below Normal (4) The enclosure temperature detected by the EMU is below normal. Above Normal (5) The enclosure temperature detected by the EMU is above normal. Far Below Normal (6) The enclosure temperature detected by the EMU is far below normal. Far Above Normal (7) The enclosure temperature detected by the EMU is far above normal. Back To Normal (8) The enclosure temperature detected by the EMU has returned to normal.')
cpqCrEMUBoardTemperatureLevel = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUBoardTemperatureLevel.setStatus('deprecated')
if mibBuilder.loadTexts: cpqCrEMUBoardTemperatureLevel.setDescription('Environmental Monitoring Unit (EMU) Board Temperature. Indicates the System Board temperature in degrees Fahrenheit.')
cpqCrEMUEnclosureTemperatureLevel = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUEnclosureTemperatureLevel.setStatus('deprecated')
if mibBuilder.loadTexts: cpqCrEMUEnclosureTemperatureLevel.setDescription('Environmental Monitoring Unit (EMU) Enclosure Temperature. Indicates the Enclosure Housing temperature in degrees Fahrenheit.')
cpqCrEMUCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrEMUCondition.setDescription('Primary enclosure condition. This value represents the overall condition of the primary enclosure.')
cpqCrEMUFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("emuFanOK", 2), ("emuFanCritical", 3), ("emuFanUnknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrEMUFanStatus.setDescription('Primary enclosure fan status. The primary enclosure fan status is: OK (2) Status is normal. Critical (3) Fan has failed. Unknown (4) Information unavailable.')
cpqCrEMUFanCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUFanCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrEMUFanCondition.setDescription('Primary enclosure fan condition. This value represents the overall condition of the fan in the primary enclosure.')
cpqCrEMUPowerSupplyStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("emuPwrSupplyOK", 2), ("emuPwrSupplyCritical", 3), ("emuPwrSupplyNotInstalled", 4), ("emuPwrSupplyUnknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUPowerSupplyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrEMUPowerSupplyStatus.setDescription('Primary enclosure power supply status. The primary enclosure power supply status is: OK (2) Status is normal. Critical (3) Power supply is installed and marked as failed. Not Installed (4) One of the redundant power supplies has been removed. Unknown (5) Information unavailable.')
cpqCrEMUPowerSupplyCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUPowerSupplyCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrEMUPowerSupplyCondition.setDescription('Primary enclosure power supply condition. This value represents the overall condition of the power supply in the primary enclosure.')
cpqCrEMUTemperatureStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("emuTempOK", 2), ("emuTempCritical", 3), ("emuTempNonCritical", 4), ("emuTempUnknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrEMUTemperatureStatus.setDescription('Primary enclosure temperature status. The primary enclosure temperature status is: OK (2) Status is normal. Critical (3) Controller temperature sensor has detected a critical temperature condition in the primary enclosure. Non-critical (4) Controller temperature sensor has detected an abnormal temperature condition in the primary enclosure. Unknown (5) Information unavailable.')
cpqCrEMUTemperatureLevel = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUTemperatureLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrEMUTemperatureLevel.setDescription('Primary enclosure temperature. Indicates the temperature within the primary enclosure in degrees Celsius.')
cpqCrEMUTemperatureCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 7, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrEMUTemperatureCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrEMUTemperatureCondition.setDescription('Primary enclosure temperature condition. This value represents the overall condition of the temperature in the primary enclosure.')
cpqCrExpCabPowerSupplyStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("other", 1), ("expCabPwrSupplyOK", 2), ("expCabPwrSupplyNonCritical", 3), ("expCabPwrSupplyUnknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrExpCabPowerSupplyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrExpCabPowerSupplyStatus.setDescription('Expansion Cabinet power supply status. The expansion cabinet power supply status is: OK (2) Status is normal. Either redundant power supplies are installed and reporting no error or a single power supply is installed. Non-Critical (3) Redundant power supplies are installed and reporting a fault. Unknown (5) Information unavailable.')
cpqCrExpCabFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("expCabFanOK", 2), ("expCabFanNonCritical", 4), ("expCabFanNotInstalled", 5), ("expCabFanUnknown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrExpCabFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrExpCabFanStatus.setDescription('Expansion Cabinet fan status. The expansion cabinet fan status is: OK (2) Status is normal. One or more fans is installed and no error is reported. Non-Critical (4) Fan degraded condition. One or more fans are reporting an error or only one fan is installed. Not Installed (5) Fan valid bit not set. Unknown (6) Information unavailable.')
cpqCrExpCabTemperatureStatus = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("expCabTempOK", 2), ("expCabTempCritical", 3), ("expCabTempNonCritical", 4), ("expCabTempNotInstalled", 5), ("expCabTempUnknown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrExpCabTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrExpCabTemperatureStatus.setDescription('Expansion Cabinet temperature status. The expansion cabinet temperature status is: OK (2) Status is normal. Critical (3) Critical temperature condition reported. Non-Critical (4) Warning temperature condition reported. Not Installed (5) Temperature valid bit not set. Unknown (6) Information unavailable.')
cpqCrExpCabCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 8, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrExpCabCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrExpCabCondition.setDescription('Expansion Cabinet condition. This value represents the overall condition of the expansion cabinet.')
cpqCrExpCabPowerSupplyCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrExpCabPowerSupplyCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrExpCabPowerSupplyCondition.setDescription('Expansion Cabinet power supply condition. This value represents the overall condition of the power supply in the expansion cabinet.')
cpqCrExpCabFanCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 8, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrExpCabFanCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrExpCabFanCondition.setDescription('Expansion Cabinet fan condition. This value represents the overall condition of the fan in the expansion cabinet.')
cpqCrExpCabTemperatureCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 141, 2, 8, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrExpCabTemperatureCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrExpCabTemperatureCondition.setDescription('Expansion Cabinet temperature condition. This value represents the overall condition of the temperature in the expansion cabinet.')
cpqCrPartitionTable = MibTable((1, 3, 6, 1, 4, 1, 232, 141, 2, 9, 1), )
if mibBuilder.loadTexts: cpqCrPartitionTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPartitionTable.setDescription('Clustered RAID Logical Drive Table. A table of logical drive entries.')
cpqCrPartitionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 141, 2, 9, 1, 1), ).setIndexNames((0, "CPQCR-MIB", "cpqCrPartitionLogDrvIndex"), (0, "CPQCR-MIB", "cpqCrPartitionIndex"))
if mibBuilder.loadTexts: cpqCrPartitionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPartitionEntry.setDescription('Clustered RAID Logical Drive Entry. A Logical Drive entry.')
cpqCrPartitionLogDrvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPartitionLogDrvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPartitionLogDrvIndex.setDescription("Clustered RAID Logical Drive Index. This maps the logical drives into their respective RAIDsets. RAIDset index 'i' under the RAIDset group owns the associated drives in the logical drives which use that index.")
cpqCrPartitionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPartitionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPartitionIndex.setDescription('Clustered RAID Logical Drive Index. This logical drive number keeps track of multiple instances of logical drives which are part of the same RAIDset. For each RAIDset index value, the logical drive index starts at 1 and increments for each logical drive.')
cpqCrPartitionRAIDLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("jbod", 2), ("raid0", 3), ("raid1", 4), ("raid0plus1", 5), ("raid4", 6), ("raid5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPartitionRAIDLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPartitionRAIDLevel.setDescription('Logical Drive RAID Level. This shows the RAID level of the logical drive. To change the RAID level, run the CR3500 Array Configuration Utility. The following values are valid for the logical drive RAID Level: JBOD (2) Just a Bunch of Drives. Fault tolerance is not enabled. This logicl drive is made up of one device. Does not provide extended data redundancy, availability or protection, and does not use striping for performance enhancements. Good for applications requiring high device capacity. Requires one and only one device. RAID0 (3) A logical drive using device striping and write-back caching. Data is spread across many devices, offering faster read/write performance than a single device. Does not provide extended data redundancy, availability or protection. Good for applications with large files needing high I/O performance. Requires a minimum of two devices. RAID1 (4) A logical drive using device mirroring. Any time data is written to a device, a duplicate write is also made to a second device. Reading from multiple devices is usually faster than reading from a single device. Provides extended data redundancy, availability and protection. Good for read-intensive applications needing high availability. Requires a minimum of two devices. RAID0PLUS1 (5) A logical drive where data is striped across devices and duplicated on an equivalent number of devies. Provides extended data redundancy, availability and protection. Good for applications requiring high availability, high performance and capacity. Requires an even number of devices, and a minimum of four devices. RAID4 (6) A logical drive using device striping, with one device assigned for parity. Provides extended data redundancy, availability and protection. Good for applications such as graphics and imaging that call for writing huge, sequential blocks of data. Requires a minimum of three devices. RAID5(7) A logical drive using device striping, with parity distributed across devices. Provides extended data redundancy, availability and protection. Good for transaction processing, applications requiring many, small I/O operations scattered randomly and widely across the devices. Requires a minimum of three devices.')
cpqCrPartitionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("good", 2), ("reduced", 3), ("failed", 4), ("reconstructing", 5), ("initializing", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPartitionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPartitionStatus.setDescription("Logical Drive Status. The logical drive can be in one of the following states: Good (2) Indicates that the logical drive is fully operational. Reduced (3) Indicates that the logical drive is operating in a degraded or reduced state. One or more of the physical disks which make up the logical drive are either missing or failed, but the logical drive can continue to operate without data loss. Failed (4) Indicates that the logical drive is not operational. Reconstructing (5) Indicates that the logical drive is regenerating a failed physical drive's data onto a replacement drive that is part of the logical drive. All user data remains available during the reconstruction process, but some performance reduction may occur when a request requires access to the device being reconstructed. Initializing (6) Indicates that the controller is writing its file structure onto the logical drive's member devices.")
cpqCrPartitionSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPartitionSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPartitionSize.setDescription('Logical Drive Size. This is the size of the logical drive in megabytes. This value is calculated using the value 1,048,576 (2^20) as a megabyte. Drive manufacturers sometimes use the number 1,000,000 as a megabyte when giving drive capacities so this value may differ from the advertised size of a drive.')
cpqCrPartitionCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 141, 2, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqCrPartitionCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqCrPartitionCondition.setDescription('Logical drive condition. This value represents the overall condition of this logical drive and any associated physical drives.')
cpqCrController1FailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 2) + (0,1)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrController1FailureTrap.setDescription('The primary controller in the subsytem has failed. Details: The primary Controller has failed. User Action: Replace controller. Possible causes are controller physically removed, actual hardware failure.')
cpqCrController1InformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 2) + (0,2)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrController1InformationTrap.setDescription('The primary controller in the subsytem has recovered. Details: The primary controller has recovered. User Action: None.')
cpqCrController2FailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 2) + (0,3)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrController2FailureTrap.setDescription('The secondary controller in the subsytem has failed. Details: The secondary controller has failed. User Action: Replace controller. Possible causes are controller physically removed, actual hardware failure.')
cpqCrController2InformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 2) + (0,4)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrController2InformationTrap.setDescription('The secondary controller in the subsytem has recovered. Details: The secondary controller has recovered. User Action: None.')
cpqCrLogDriveInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 3) + (0,5)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrLogDrvIndex"))
if mibBuilder.loadTexts: cpqCrLogDriveInformationTrap.setDescription('A RAIDset has become optimal. Details: A RAIDset has become optimal due to a successful completion of the reconstruction process. User Action: None.')
cpqCrLogDriveFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 3) + (0,6)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrLogDrvIndex"))
if mibBuilder.loadTexts: cpqCrLogDriveFailureTrap.setDescription('A RAIDset has failed. Details: The RAIDset has failed and is off-line. User Action: Possible cause is too many failed disk drives that make up the RAIDset, the OS can no longer communicate with the RAIDset for other reasons.')
cpqCrLogDriveReconstructTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 3) + (0,7)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrLogDrvIndex"))
if mibBuilder.loadTexts: cpqCrLogDriveReconstructTrap.setDescription('A RAIDset has started the reconstruction process. Details: The RAIDset has started the reconstruction process but is available for normal use. Possible causes are an available disk drive was created as a spare to be inserted into the set, an existing spare was automatically added to the set for reconstruction upon failure of a member disk device. User Action: None.')
cpqCrLogDriveReducedTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 3) + (0,8)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrLogDrvIndex"))
if mibBuilder.loadTexts: cpqCrLogDriveReducedTrap.setDescription('A RAIDset has become degraded. Details: A RAIDset has become degraded due to a member disk device failure. User Action: Replace the failed disk device; add a spare to the system to cause a reconstruct.')
cpqCrLogDriveInitializingTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 3) + (0,9)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrLogDrvIndex"))
if mibBuilder.loadTexts: cpqCrLogDriveInitializingTrap.setDescription('A RAIDset is initializing. Details: A RAIDset is in the process of being intialized. User Action: None.')
cpqCrDiskInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,10)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvCntlrIndex"), ("CPQCR-MIB", "cpqCrPhyDrvIndex"))
if mibBuilder.loadTexts: cpqCrDiskInformationTrap.setDescription('A disk drive has recovered. Details: A disk device has recovered. User Action: None.')
cpqCrDiskFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,11)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvCntlrIndex"), ("CPQCR-MIB", "cpqCrPhyDrvIndex"))
if mibBuilder.loadTexts: cpqCrDiskFailureTrap.setDescription('A disk drive has failed. Details: A disk device has failed. User Action: Replace the disk device.')
cpqCrDiskReconstructTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,12)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvIndex"))
if mibBuilder.loadTexts: cpqCrDiskReconstructTrap.setDescription('A disk drive has started the reconstruction process. Details: A disk member of a logical drive has begun the reconstruction process and will be available for use when reconstruction is complete. User Action: Wait for the reconstruction to complete.')
cpqCrDiskAvailableTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,13)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvIndex"))
if mibBuilder.loadTexts: cpqCrDiskAvailableTrap.setDescription('A disk drive has been made available for use. Details: A disk drive has been physically added or set to the Available state. It can be used as a RAIDset member or as a Spare. User Action: None.')
cpqCrDiskSpareTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,14)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvIndex"))
if mibBuilder.loadTexts: cpqCrDiskSpareTrap.setDescription('A disk drive has been made a Spare. Details: A disk drive has been set to Spare status from Available and may be used in a RAID 1, RAID 0+1 or RAID 5 logical disk should a member device fail in one of those RAIDsets. User Action: None.')
cpqCrPhyDiskInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,30)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvScsiID"))
if mibBuilder.loadTexts: cpqCrPhyDiskInformationTrap.setDescription('A disk drive has recovered. Details: A disk device has recovered. User Action: None.')
cpqCrPhyDiskFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,31)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvScsiID"))
if mibBuilder.loadTexts: cpqCrPhyDiskFailureTrap.setDescription('A disk drive has failed. Details: A disk device has failed. User Action: Replace the disk device.')
cpqCrPhyDiskReconstructTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,32)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvScsiID"))
if mibBuilder.loadTexts: cpqCrPhyDiskReconstructTrap.setDescription('A disk drive has started the reconstruction process. Details: A disk member of a logical drive has begun the reconstruction process and will be available for use when reconstruction is complete. User Action: Wait for the reconstruction to complete.')
cpqCrPhyDiskAvailableTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,33)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrPhyDrvScsiID"))
if mibBuilder.loadTexts: cpqCrPhyDiskAvailableTrap.setDescription('A disk drive has been made available for use. Details: A disk drive has been physically added or set to the Available state. It can be used as a RAIDset member or as a Spare. User Action: None.')
cpqCrPhyDiskSpareTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 5) + (0,34)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQCR-MIB", "cpqCrSpareScsiID"))
if mibBuilder.loadTexts: cpqCrPhyDiskSpareTrap.setDescription('A disk drive has been made a Spare. Details: A disk drive has been set to Spare status from Available and may be used in a RAID 1, RAID 0+1 or RAID 5 logical disk should a member device fail in one of those RAIDsets. User Action: None.')
cpqCrEMUNormalTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 7) + (0,15)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrEMUNormalTrap.setDescription('Primary enclosure state is normal. Details: The overall condition of the primary enclosure has returned to normal. User Action: None.')
cpqCrEMUFanFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 7) + (0,16)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrEMUFanFailureTrap.setDescription('Fan has failed. Details: One of the cooling fans in the primary enclosure has failed. User Action: Replace the cooling fan. Possible causes are fan physically removed, actual hardware failure.')
cpqCrEMUFanInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 7) + (0,17)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrEMUFanInformationTrap.setDescription('The fan has recovered. Details: The cooling fan in the primary enclosure has recovered. User Action: None.')
cpqCrEMUPowerSupplyFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 7) + (0,18)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrEMUPowerSupplyFailureTrap.setDescription('Power supply has failed. Details: One of the power supplies in the primary enclosure has failed. User Action: Replace the power supply. Possible causes are power supply physically removed, power cord unplugged, actual hardware failure.')
cpqCrEMUPowerSupplyInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 7) + (0,19)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrEMUPowerSupplyInformationTrap.setDescription('The power supply has recovered. Details: The power supply in the primary enclosure has recovered. User Action: None.')
cpqCrEMUTemperatureWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 7) + (0,23)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrEMUTemperatureWarningTrap.setDescription('Primary enclosure temperature warning. Details: The temperature in the primary enclosure has triggered a warning condition detected by the controller. User Action: Check the cooling fans in the primary enclosure.')
cpqCrEMUTemperatureCriticalTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 7) + (0,24)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrEMUTemperatureCriticalTrap.setDescription('Primary enclosure temperature critical!. Details: The temperature in the primary enclosure has triggered a critical condition detected by the controller. User Action: Check the cooling fans in the primary enclosure.')
cpqCrEMUTemperatureInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 7) + (0,25)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrEMUTemperatureInformationTrap.setDescription('Primary enclosure temperature normal. Details: The temperature in the primary enclosure has returned to normal. User Action: None.')
cpqCrExpCabFanFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 8) + (0,20)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrExpCabFanFailureTrap.setDescription('Fan has failed in expansion cabinet. Details: One of the cooling fans in the expansion cabinet has failed. User Action: Replace the cooling fan. Possible causes are fan physically removed, actual hardware failure.')
cpqCrExpCabFanInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 8) + (0,21)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrExpCabFanInformationTrap.setDescription('Fan has recovered. Details: A cooling fan in the expansion cabinet has returned to a normal state. User Action: None.')
cpqCrExpCabPowerSupplyFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 8) + (0,22)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrExpCabPowerSupplyFailureTrap.setDescription('Power supply has failed. Details: One of the power supplies in the expansion cabinet has failed. User Action: Replace the power supply. Possible causes are power supply physically removed, power cord unplugged, actual hardware failure.')
cpqCrExpCabPowerSupplyInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 8) + (0,29)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrExpCabPowerSupplyInformationTrap.setDescription('The power supply has recovered. Details: The power supply in the expansion cabinet has recovered. User Action: None.')
cpqCrExpCabTemperatureWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 8) + (0,26)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrExpCabTemperatureWarningTrap.setDescription('Expansion cabinet temperature warning. Details: The temperature in the expansion cabinet has triggered a warning condition detected by the controller. User Action: Check the cooling fans in the expansion cabinet.')
cpqCrExpCabTemperatureCriticalTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 8) + (0,27)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrExpCabTemperatureCriticalTrap.setDescription('Expansion cabinet temperature critical! Details: The temperature in the expansion cabinet has triggered a critical condition detected by the controller. User Action: Check the cooling fans in the expansion cabinet.')
cpqCrExpCabTemperatureInformationTrap = NotificationType((1, 3, 6, 1, 4, 1, 232, 141, 3, 8) + (0,28)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: cpqCrExpCabTemperatureInformationTrap.setDescription('Expansion cabinet temperature normal. Details: The temperature in the expansion cabinet has returned to normal. User Action: None.')
mibBuilder.exportSymbols("CPQCR-MIB", cpqCrEMUTemperatureInformationTrap=cpqCrEMUTemperatureInformationTrap, cpqCrTrap=cpqCrTrap, cpqCrExpCabPowerSupplyInformationTrap=cpqCrExpCabPowerSupplyInformationTrap, cpqCrOsCommon=cpqCrOsCommon, cpqCrLogDrv=cpqCrLogDrv, cpqCrCntlrFWRev=cpqCrCntlrFWRev, cpqCrEMUTemperatureCondition=cpqCrEMUTemperatureCondition, cpqCrOsCommonPollFreq=cpqCrOsCommonPollFreq, cpqCrLogDrvPartitionIDs=cpqCrLogDrvPartitionIDs, cpqCrInterfaceTrap=cpqCrInterfaceTrap, cpqCrExpCabPowerSupplyStatus=cpqCrExpCabPowerSupplyStatus, cpqCrSpareStatus=cpqCrSpareStatus, cpqCrLogDrvRAIDLevel=cpqCrLogDrvRAIDLevel, cpqCrPhyDrvCondition=cpqCrPhyDrvCondition, cpqCrLogDriveReducedTrap=cpqCrLogDriveReducedTrap, cpqCrSpareEntry=cpqCrSpareEntry, cpqCrPartitionRAIDLevel=cpqCrPartitionRAIDLevel, cpqCrEMUFanCondition=cpqCrEMUFanCondition, cpqCrDiskInformationTrap=cpqCrDiskInformationTrap, cpqCrController1InformationTrap=cpqCrController1InformationTrap, cpqCrEMUPowerSupplyInformationTrap=cpqCrEMUPowerSupplyInformationTrap, cpqCrInterface=cpqCrInterface, cpqCrEMUFanStatus=cpqCrEMUFanStatus, cpqCrSpareDrv=cpqCrSpareDrv, cpqCrEMUBoardTemperatureLevel=cpqCrEMUBoardTemperatureLevel, cpqCrPartitionTable=cpqCrPartitionTable, cpqCrPhyDiskFailureTrap=cpqCrPhyDiskFailureTrap, cpqCrLogDriveInitializingTrap=cpqCrLogDriveInitializingTrap, cpqCrPhyDrvModel=cpqCrPhyDrvModel, cpqCrEMUCondition=cpqCrEMUCondition, cpqCrPartitionEntry=cpqCrPartitionEntry, cpqCrEMUFanInformationTrap=cpqCrEMUFanInformationTrap, cpqCrPhyDrv=cpqCrPhyDrv, cpqCrSparePhyDrvIndex=cpqCrSparePhyDrvIndex, cpqCrPhyDrvScsiID=cpqCrPhyDrvScsiID, cpqCrEMUTrap=cpqCrEMUTrap, cpqCrLogDrvCondition=cpqCrLogDrvCondition, cpqCrController2FailureTrap=cpqCrController2FailureTrap, cpqCrMibRev=cpqCrMibRev, cpqCrEMUTemperatureCriticalTrap=cpqCrEMUTemperatureCriticalTrap, cpqCrPhyDrvCntlrIndex=cpqCrPhyDrvCntlrIndex, cpqCrEMUBoardTemperatureStatus=cpqCrEMUBoardTemperatureStatus, cpqCrDiskAvailableTrap=cpqCrDiskAvailableTrap, cpqCrPhyDiskAvailableTrap=cpqCrPhyDiskAvailableTrap, cpqCrLogDrvRebuildPercentage=cpqCrLogDrvRebuildPercentage, cpqCrLogDriveReconstructTrap=cpqCrLogDriveReconstructTrap, cpqCrExpCabCondition=cpqCrExpCabCondition, cpqCrDiskReconstructTrap=cpqCrDiskReconstructTrap, cpqCrExpCabTemperatureCriticalTrap=cpqCrExpCabTemperatureCriticalTrap, cpqCrLogDriveFailureTrap=cpqCrLogDriveFailureTrap, cpqCrEMUNormalTrap=cpqCrEMUNormalTrap, cpqCrExpCabFanInformationTrap=cpqCrExpCabFanInformationTrap, cpqCrPartitionCondition=cpqCrPartitionCondition, cpqCrExpCabFanStatus=cpqCrExpCabFanStatus, cpqCrCntlrEntry=cpqCrCntlrEntry, cpqCrComponent=cpqCrComponent, cpqClusteredRAID=cpqClusteredRAID, cpqCrPhyDrvTrap=cpqCrPhyDrvTrap, cpqCrEMUTemperatureLevel=cpqCrEMUTemperatureLevel, cpqCrDiskSpareTrap=cpqCrDiskSpareTrap, cpqCrEMUPowerSupplyFailureTrap=cpqCrEMUPowerSupplyFailureTrap, cpqCrSpareCntlrIndex=cpqCrSpareCntlrIndex, cpqCrLogDrvTrap=cpqCrLogDrvTrap, cpqCrController2InformationTrap=cpqCrController2InformationTrap, cpqCrCntlrCreateRate=cpqCrCntlrCreateRate, cpqCrExpCabPowerSupplyCondition=cpqCrExpCabPowerSupplyCondition, cpqCrPhyDrvVendor=cpqCrPhyDrvVendor, cpqCrExpCabFanFailureTrap=cpqCrExpCabFanFailureTrap, cpqCrPartitionSize=cpqCrPartitionSize, cpqCrSpareCondition=cpqCrSpareCondition, cpqCrEMUFanFailureTrap=cpqCrEMUFanFailureTrap, cpqCrSpareDrvTrap=cpqCrSpareDrvTrap, cpqCrLogDrvIndex=cpqCrLogDrvIndex, cpqCrCntlrCondition=cpqCrCntlrCondition, cpqCrEMUTemperatureStatus=cpqCrEMUTemperatureStatus, cpqCrPartitionIndex=cpqCrPartitionIndex, cpqCrEMU=cpqCrEMU, cpqCrLogDrvAvailSpares=cpqCrLogDrvAvailSpares, cpqCrSpareTable=cpqCrSpareTable, cpqCrCntlrTrap=cpqCrCntlrTrap, cpqCrPartitionStatus=cpqCrPartitionStatus, cpqCrPhyDrvRevision=cpqCrPhyDrvRevision, cpqCrDiskFailureTrap=cpqCrDiskFailureTrap, cpqCrPhyDiskReconstructTrap=cpqCrPhyDiskReconstructTrap, cpqCrLogDrvEntry=cpqCrLogDrvEntry, cpqCrPhyDrvTable=cpqCrPhyDrvTable, cpqCrCntlrCacheSize=cpqCrCntlrCacheSize, cpqCrPhyDiskSpareTrap=cpqCrPhyDiskSpareTrap, cpqCrPhyDrvEntry=cpqCrPhyDrvEntry, cpqCrExpCab=cpqCrExpCab, cpqCrExpCabTemperatureStatus=cpqCrExpCabTemperatureStatus, cpqCrPhyDrvStatus=cpqCrPhyDrvStatus, cpqCrCntlrCurrentRole=cpqCrCntlrCurrentRole, cpqCrLogDrvCntlrIndex=cpqCrLogDrvCntlrIndex, cpqCrExpCabTemperatureCondition=cpqCrExpCabTemperatureCondition, cpqCrLogDrvStatus=cpqCrLogDrvStatus, cpqCrExpCabTemperatureInformationTrap=cpqCrExpCabTemperatureInformationTrap, cpqCrCntlrSerialNumber=cpqCrCntlrSerialNumber, cpqCrMibCondition=cpqCrMibCondition, cpqCrLogDrvTable=cpqCrLogDrvTable, cpqCrController1FailureTrap=cpqCrController1FailureTrap, cpqCrCntlrSimmSizeA=cpqCrCntlrSimmSizeA, cpqCrExpCabTrap=cpqCrExpCabTrap, cpqCrEMUEnclosureTemperatureStatus=cpqCrEMUEnclosureTemperatureStatus, cpqCrPhyDiskInformationTrap=cpqCrPhyDiskInformationTrap, cpqCrExpCabPowerSupplyFailureTrap=cpqCrExpCabPowerSupplyFailureTrap, cpqCrLogDriveInformationTrap=cpqCrLogDriveInformationTrap, cpqCrPhyDrvIndex=cpqCrPhyDrvIndex, cpqCrPhyDrvSize=cpqCrPhyDrvSize, cpqCrCntlrIndex=cpqCrCntlrIndex, cpqCrCntlrTable=cpqCrCntlrTable, cpqCrExpCabTemperatureWarningTrap=cpqCrExpCabTemperatureWarningTrap, cpqCrPartitionLogDrvIndex=cpqCrPartitionLogDrvIndex, cpqCrCntlrDriveOwnership=cpqCrCntlrDriveOwnership, cpqCrEMUPowerSupplyStatus=cpqCrEMUPowerSupplyStatus, cpqCrEMUEnclosureTemperatureLevel=cpqCrEMUEnclosureTemperatureLevel, cpqCrCntlrRebuildRate=cpqCrCntlrRebuildRate, cpqCrCntlrSimmSizeB=cpqCrCntlrSimmSizeB, cpqCrLogDrvPhyDrvIDs=cpqCrLogDrvPhyDrvIDs, cpqCrLogDrvSize=cpqCrLogDrvSize, cpqCrEMUTemperatureWarningTrap=cpqCrEMUTemperatureWarningTrap, cpqCrSpareScsiID=cpqCrSpareScsiID, cpqCrPartition=cpqCrPartition, cpqCrCntlr=cpqCrCntlr, cpqCrExpCabFanCondition=cpqCrExpCabFanCondition, cpqCrMibRevMajor=cpqCrMibRevMajor, cpqCrMibRevMinor=cpqCrMibRevMinor, cpqCrEMUPowerSupplyCondition=cpqCrEMUPowerSupplyCondition)

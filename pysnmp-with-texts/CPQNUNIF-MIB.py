#
# PySNMP MIB module CPQNUNIF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CPQNUNIF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, NotificationType, enterprises, ObjectIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Counter64, Unsigned32, Gauge32, IpAddress, Counter32, MibIdentifier, ModuleIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "NotificationType", "enterprises", "ObjectIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Counter64", "Unsigned32", "Gauge32", "IpAddress", "Counter32", "MibIdentifier", "ModuleIdentity", "TimeTicks")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
compaq = MibIdentifier((1, 3, 6, 1, 4, 1, 232))
cpqnCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 121))
cpqnMibModules = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 121, 1))
cpqnUnitControl = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 121, 2))
cpqnVersionInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 121, 3))
cpqnAccessControl = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 121, 4))
cpqnTrapDestinations = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 121, 5))
cpqnNetworkInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 121, 6))
cpqnBootpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 121, 7))
class CpqnRowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("row-valid", 1), ("row-invalid", 2))

class IpxAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(10, 10)
    fixedLength = 10

cpqnMibModuleTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 1, 1), )
if mibBuilder.loadTexts: cpqnMibModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnMibModuleTable.setDescription("This table contains a list of all the MIB modules actively supported by a unit's agent. This includes any standard RFC and Compaq enterprise MIBs.")
cpqnMibModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 1, 1, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnMibModuleIndex"))
if mibBuilder.loadTexts: cpqnMibModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnMibModuleEntry.setDescription('There is one entry defined for each separate MIB module the agent supports.')
cpqnMibModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnMibModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnMibModuleIndex.setDescription('The index for this entry.')
cpqnMibModuleDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 1, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnMibModuleDescr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnMibModuleDescr.setDescription('This is a short textual description of the MIB module for this entry. Examples could be RFC 1213 MIB-II or Compaq Unified MIB.')
cpqnMibModuleOid = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 1, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnMibModuleOid.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnMibModuleOid.setDescription('This is the OID representing the base node of the MIB for this entry. The base node of a MIB is defined here as the first MIB node that is not defined in another MIB. For example, the base node OID for RMON is MIB-II.RMON or 1.3.6.1.2.1.16.')
cpqnUnitReset = MibScalar((1, 3, 6, 1, 4, 1, 232, 121, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("running", 1), ("reset", 2), ("warm-start", 3), ("reset-to-factory-values", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnUnitReset.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnUnitReset.setDescription("Setting this object to reset(2) causes the unit to reset in the most complete manner possible. Any hardware units that can be reset, will be. If possible, this will be done using a hardware reset; if not, then the unit will perform a software re-initialization. All non-durable information, including counter values, will be lost. All durable information is retained. The value returned for this object will ALWAYS be running(1). After receiving a request to set this variable to reset(2), the unit may delay the reset for a short period. This is done to respond to the SNMP set request. The warm-start(3) setting has the same behavior. Note that not all units support warm-start(3). If not supported, a unit will return a BAD VALUE error. For more information on the meaning and semantics of 'reset' and 'warm-start', see the User's Guide for the unit. Setting this object to reset-to-factory-values(4) will cause all configurable parameters to be reset to the factory settings. Note that all user-configured information will be lost: this includes the system description, passwords, community names, the contents of the access control table (cpqnCommunityAccessTable), and default routes. See the unit's documentation for information on factory settings.")
cpqnPrimarySerialPort = MibScalar((1, 3, 6, 1, 4, 1, 232, 121, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnPrimarySerialPort.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnPrimarySerialPort.setDescription("This object indicates which entry in the cpqnSerialPortTable is the primary serial port. For a list of the functions and features provided on a unit's primary serial port, see the unit's documentation.")
cpqnSerialPortTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 2, 3), )
if mibBuilder.loadTexts: cpqnSerialPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSerialPortTable.setDescription('There is one entry in this table for each serial port on the unit.')
cpqnSerialPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 2, 3, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnSPortIndex"))
if mibBuilder.loadTexts: cpqnSerialPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSerialPortEntry.setDescription('This entry provides information and objects to control a serial port.')
cpqnSPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnSPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSPortIndex.setDescription('The index of this row.')
cpqnSPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnSPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSPortIfIndex.setDescription('This object indicates which entry in the MIB-II interface table this serial port corresponds to. If this value is zero (0), then this serial port DOES NOT have an associated MIB-II interface. This object will only be non-zero for serial ports which support SLIP, PPP or a similar protocol.')
cpqnSPortModemInitStringEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnSPortModemInitStringEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSPortModemInitStringEnable.setDescription("DURABLE: If this object is enabled(1) then after a power up or reset the unit will transmit the modem init string out the primary serial port in order to initialize the modem. This will occur at the baud rate value of cpqnSPortBaudRate. Note that some units have more sophisticated modem support features. For more information on how a unit supports modems, see the unit's documentation.")
cpqnSPortModemInitString = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnSPortModemInitString.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSPortModemInitString.setDescription('DURABLE: This object contains a Modem Initialization String which is used to configure a modem on this port to the desired mode. Refer to the unit-specific documentation for information on the factory setting for this object and for other information on how the unit supports modems.')
cpqnSPortModemAutoNegotiateState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnSPortModemAutoNegotiateState.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSPortModemAutoNegotiateState.setDescription("DURABLE: If enabled(1), the unit automatically detects the baud rate of incoming calls and will adjust the baud rate on this port to match. This is accomplished by watching for the connect indication strings from a modem attached to the port. For more information on how a unit supports modems, see the unit's documentation.")
cpqnSPortBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnSPortBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSPortBaudRate.setDescription('DURABLE: This is the current baud rate for the port. Its value must match a cpqnBaudRate entry in cpqnSupportBaudRateTable. Note that this value can automatically change if cpqnSPortModemAutoNegotiateState is set to enabled(1).')
cpqnSupportedBaudRateTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 2, 4), )
if mibBuilder.loadTexts: cpqnSupportedBaudRateTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSupportedBaudRateTable.setDescription('A table of supported baud rates for this unit.')
cpqnSupportedBaudRateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 2, 4, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnBaudRatePortIndex"), (0, "CPQNUNIF-MIB", "cpqnBaudRateIndex"))
if mibBuilder.loadTexts: cpqnSupportedBaudRateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnSupportedBaudRateEntry.setDescription('There is one entry defined for each supported baud rate for each serial port.')
cpqnBaudRatePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnBaudRatePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBaudRatePortIndex.setDescription('The index into the cpqnSerialPortTable table identifying the port this entry applies to.')
cpqnBaudRateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnBaudRateIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBaudRateIndex.setDescription('The index of this row.')
cpqnBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBaudRate.setDescription('The supported baud rate for the port indexed by cpqnBaudRatePortIndex.')
class CpqnVersionType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("other", 1), ("hardware", 2), ("software", 3))

class CpqnVersionStep(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("other", 1), ("engineering", 2), ("alpha", 3), ("beta", 4), ("prototype", 5), ("pilot", 6), ("pre-production", 7), ("production", 8), ("post-production", 9), ("simple-revision", 10))

cpqnVersionTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 3, 1), )
if mibBuilder.loadTexts: cpqnVersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionTable.setDescription('This table contains a list of hardware and/or software components resident in the unit.')
cpqnVersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnVersionIndex"))
if mibBuilder.loadTexts: cpqnVersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionEntry.setDescription('There is one entry defined for each hardware and/or software component.')
cpqnVersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionIndex.setDescription('The index into the version table.')
cpqnVersionType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 2), CpqnVersionType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionType.setDescription("The component's type.")
cpqnVersionDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionDesc.setDescription('A brief description of the component. This object may be empty.')
cpqnVersionMajor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionMajor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionMajor.setDescription('The MAJOR version number of the component. This is always a value between 0 and 255 and should be interpreted as a decimal number. An example is version 2.14 where 2 is the major version number.')
cpqnVersionMinor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionMinor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionMinor.setDescription('The MINOR version number of the component. This is always a value between 0 and 99 and should be interpreted as a two-digit decimal number. An example is version 2.01 where 1 is the minor version number. Another example is version 2.1 where 10 is the minor version number.')
cpqnVersionStep = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 6), CpqnVersionStep()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionStep.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionStep.setDescription('The STEP identifier for the associated component. This value indicates the level or class of the component, such as prototype, production, or beta.')
cpqnVersionRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionRev.setDescription('The REVISION of the step for the associated component. An example is version 1.00B3 where 3 is the revision number.')
cpqnVersionSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionSerialNumber.setDescription('The serial number of this component. The format of this object is dependent on the unit type. Refer to the unit-specific documentation for more information. This object is empty for components which do not have a serial number.')
cpqnVersionUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionUnitId.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionUnitId.setDescription('This is a number that uniquely identifies which unit in a collection of one or more units that this entry applies to. For example, this unit may be part of a stack, or a plug-in card in a chassis. For units that are not part of a collection (standalone) this value is always a 1.')
cpqnVersionParentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnVersionParentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnVersionParentIndex.setDescription("A component represented by an entry in this table may be a sub-component of another entity or unit. In this case, the value of this object indicates this entry's parent entry in this table. For example, a plug-in uplink card may be plugged into unit #3 of a stack of repeaters. In this case, this value would contain the index into this table which has a cpqnVersionUnitId of 3. If this entry has no parent, then this object contains the value zero.")
cpqnAclTelnetControl = MibScalar((1, 3, 6, 1, 4, 1, 232, 121, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclTelnetControl.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclTelnetControl.setDescription('DURABLE: This object controls the Telnet feature of the unit. If this object is set to disabled(2), then Telnet is disabled and no Telnet session can be initiated, regardless of the settings of other access control mechanisms. If this object is enabled(1), then Telnet sessions can be initiated and are subject to the other access control mechanisms.')
cpqnCommunityAccessIPTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 4, 2), )
if mibBuilder.loadTexts: cpqnCommunityAccessIPTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnCommunityAccessIPTable.setDescription("This table contains objects which control access to the agent over IP. Access is restricted to only the hosts listed in this table. If a station does not have read-write-allow-telnet(4) access to a unit, then this table is not accessible, e.g. GET or SET messages accessing this table from stations will have an authentication error returned. GET NEXTs on this MIB from such stations will simply skip over this table. Care must be taken when modifying this table. A network management station can inadvertently modify this table so that it no longer has read-write-allow-telnet(4) access. If this occurs, then this table can only be modified from another network management station with write access, via telnet, or via a direct connection to the unit's primary serial port. Access to this unit via SNMP and Telnet can also be blocked if all the entries in this table and the cpqnCommunityAccessIPXTable are deleted. In this case, this table can only be modified via a direct connection via the primary serial port using the unit's user interface. This table can be set to factory values using the user interface accessed by Telnet or a direct connection to the unit's primary serial port. This table will also be set to factory values when cpqnUnitReset is set to reset-to-factory-values(4).")
cpqnCommAccessIPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 4, 2, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnAclIPIndex"))
if mibBuilder.loadTexts: cpqnCommAccessIPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnCommAccessIPEntry.setDescription('There is one entry defined for each host-community pair.')
cpqnAclIPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnAclIPIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPIndex.setDescription('The index to this entry.')
cpqnAclIPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 2, 1, 2), CpqnRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPRowStatus.setDescription("DURABLE: The status of this row entry. Rows are added to this table using 'row sets'. When a row is added, this object must be set to row-valid(1). To delete a row from this table, set this object for the row to row-invalid(2). Row sets for new rows with a row status set to row-invalid(2) return a BAD VALUE error. This object will always read as row-valid(1). If no more rows can be added to the end of the table, then a row set to create a new row will return BAD VALUE. When rows are deleted from this table, the indexes of the other rows do not change. In other words, this table can be 'sparse' or have 'holes'. Deleted entries can be re-created using a row set with a row status of row-valid(1).")
cpqnAclIPAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPAddrMask.setDescription("DURABLE: This mask is applied to the source address of received SNMP/IP messages. If the masked address matches cpqnAclIPAddrMatch and the community in the SNMP packet matches the community name in cpqnAclIPCommunity for the row, then the SNMP request will be serviced by the unit's agent. The transmitting node's access to this unit's MIB tables is determined by the cpqnAclIPRights. For example, assuming cpqnAclIPAddrMask = 255.255.255.000, cpqnAclIPAddrMatch = 198.085.034.000, and cpqnAclCommunity = compaq, then a SNMP request coming from 198.85.34.72 with community compaq will pass whereas a request from 120.1.2.4 with community compaq will fail.")
cpqnAclIPAddrMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPAddrMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPAddrMatch.setDescription('DURABLE: The Masked address must match this value.')
cpqnAclIPCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPCommunity.setDescription("DURABLE: The community string that is required for any requests coming from this host. The default value for this object is 'public'.")
cpqnAclIPRights = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no-access", 1), ("read-only-prevent-telnet", 2), ("read-only-allow-telnet", 3), ("read-write-allow-telnet", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPRights.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPRights.setDescription("DURABLE: This object controls the access granted to SNMP requests which match a mask/match and community name string. no-access(1) means that that address/community name pair has neither SNMP/IP nor Telnet access. read-only-prevent-telnet(2) allows only read access to MIB objects and disallows Telnet access. read-only-allow-telnet(3) also allows only read access, but the station can initiate a Telnet session. read-write-allow-telnet(4) allows full access to the device's MIB and allows the station to initiate a Telnet session. NOTE: Telnet access is either allowed or disallowed. Generally, devices do not have read-only telnet sessions. This mechanism does not preclude the use of a password for Telnet access.")
cpqnCommunityAccessIPXTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 4, 3), )
if mibBuilder.loadTexts: cpqnCommunityAccessIPXTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnCommunityAccessIPXTable.setDescription("This table contains objects which control SNMP/IPX access to the agent. Access is restricted to only the hosts listed in this table. If a station does not have read-write(3) access to a unit, then this table is not accessible,e.g. GET or SET messages accessing this table from stations will have an authentication error returned. GET NEXTs on this MIB from such stations will simply skip over this table. Care must be taken when modifying this table. A network management station can inadvertently modify this table so that it no longer has read-write(3) access. If this occurs, then this table can only be modified from another network management station with write access, via telnet, or via a direct connection to the unit's primary serial port. Access to this unit via SNMP and Telnet can also be blocked if all the entries in this table and the cpqnCommunityAccessIPTable are deleted. In this case, this table can only be modified via a direct connection via the primary serial port using the unit's user interface. This table can be set to factory values using the user interface accessed by Telnet or a direct connection to the unit's primary serial port. This table will also be set to factory values when cpqnUnitReset is set to reset-to-factory-values(4).")
cpqnCommAccessIPXEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 4, 3, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnAclIPXIndex"))
if mibBuilder.loadTexts: cpqnCommAccessIPXEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnCommAccessIPXEntry.setDescription('There is one entry defined for each host-community pair.')
cpqnAclIPXIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnAclIPXIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPXIndex.setDescription('The index to this entry.')
cpqnAclIPXRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 3, 1, 2), CpqnRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPXRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPXRowStatus.setDescription("DURABLE: The status of this row entry. Rows are added to this table using 'row sets'. When a row is added, this object must be set to row-valid(1). To delete a row from this table, set this object for the row to row-invalid(2). Row sets for new rows with a row status set to row-invalid(2) return a BAD VALUE error. This object will always read as row-valid(1). If no more rows can be added to the end of the table, then a row set to create a new row will return BAD VALUE. When rows are deleted from this table, the indexes of the other rows do not change. In other words, this table can be 'sparse' or have 'holes'. Deleted entries can be re-created using a row set with a row status of row-valid(1).")
cpqnAclIPXAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 3, 1, 3), IpxAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPXAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPXAddrMask.setDescription("DURABLE: This mask is applied to the source address of received SNMP messages. If the masked address matches cpqnAclIPXAddrMask and the community in the SNMP packet matches the community name in cpqnAclIPXCommunity for the row, then the SNMP request will be serviced by the unit's agent. The transmitting node's access to this unit's MIB tables is determined by the cpqnAclIPXRights. For example, 0081CCAB:00805FEAE01D is an IPX address which could be matched with a mask of 00FFFFFF:000000000000. Due to the nature of IPX address, the node address of an IPX address mask are simply 0's. This controls SNMP access by IPX network number only.")
cpqnAclIPXAddrMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 3, 1, 4), IpxAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPXAddrMatch.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPXAddrMatch.setDescription('DURABLE: The Masked address must match this value.')
cpqnAclIPXCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPXCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPXCommunity.setDescription("DURABLE: The community string that is required for any requests coming from this host. The default value for this object is 'public'.")
cpqnAclIPXRights = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-access", 1), ("read-only-access", 2), ("read-write-access", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnAclIPXRights.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnAclIPXRights.setDescription("DURABLE: This object controls the access granted to SNMP/IPX requests which match a mask/match and community name string. no-access(1) means that that address/community name pair has no SNMP/IPX access. read-only(2) allows only read access to MIB objects. read-write(3) allows full access to the device's MIB.")
cpqnIPTrapDestTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 5, 1), )
if mibBuilder.loadTexts: cpqnIPTrapDestTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPTrapDestTable.setDescription('A list of IP trap destination entries.')
cpqnIPTrapDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 5, 1, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnIPTrapDestIndex"))
if mibBuilder.loadTexts: cpqnIPTrapDestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPTrapDestEntry.setDescription('A destination entry which defines the IP address to which traps are sent for a community.')
cpqnIPTrapDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnIPTrapDestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPTrapDestIndex.setDescription('A value that uniquely identifies this IPTrapDestEntry.')
cpqnIPTrapDestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 5, 1, 1, 2), CpqnRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIPTrapDestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPTrapDestRowStatus.setDescription("DURABLE: The status of this row entry. Rows are added to this table using 'row sets'. When a row is added, this object must be set to row-valid(1). To delete a row from this table, set this object for the row to row-invalid(2). Row sets for new rows with a row status set to row-invalid(2) return a BAD VALUE error. This object will always read as row-valid(1). If no more rows can be added to the end of the table, then a row set to create a new row will return BAD VALUE. When rows are deleted from this table, the indexes of the other rows do not change. In other words, this table can be 'sparse' or have 'holes'. Deleted entries can be re-created using a row set with a row status of row-valid(1).")
cpqnIPTrapDestCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 5, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIPTrapDestCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPTrapDestCommunity.setDescription('DURABLE: A community name to which this destination IP address belongs.')
cpqnIPTrapDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 5, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIPTrapDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPTrapDestAddress.setDescription('DURABLE: The IP address to send traps to on behalf of this entry.')
cpqnIPXTrapDestTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 5, 2), )
if mibBuilder.loadTexts: cpqnIPXTrapDestTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPXTrapDestTable.setDescription('A list of IPX trap destination entries.')
cpqnIPXTrapDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 5, 2, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnIPXTrapDestIndex"))
if mibBuilder.loadTexts: cpqnIPXTrapDestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPXTrapDestEntry.setDescription('A destination entry which defines the IPX address to which traps are sent for a community.')
cpqnIPXTrapDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnIPXTrapDestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPXTrapDestIndex.setDescription('A value that uniquely identifies this IPXTrapDestEntry.')
cpqnIPXTrapDestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 5, 2, 1, 2), CpqnRowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIPXTrapDestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPXTrapDestRowStatus.setDescription("DURABLE: The status of this row entry. Rows are added to this table using 'row sets'. When a row is added, this object must be set to row-valid(1). To delete a row from this table, set this object for the row to row-invalid(2). Row sets for new rows with a row status set to row-invalid(2) return a BAD VALUE error. This object will always read as row-valid(1). If no more rows can be added to the end of the table, then a row set to create a new row will return BAD VALUE. When rows are deleted from this table, the indexes of the other rows do not change. In other words, this table can be 'sparse' or have 'holes'. Deleted entries can be re-created using a row set with a row status of row-valid(1).")
cpqnIPXTrapDestCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIPXTrapDestCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPXTrapDestCommunity.setDescription('DURABLE: A community name to which this destination IPX address belongs.')
cpqnIPXTrapDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 5, 2, 1, 4), IpxAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIPXTrapDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIPXTrapDestAddress.setDescription('DURABLE: The IPX address to send traps to on behalf of this entry. IPX traps are sent to the standard IPX SNMP socket number.')
cpqnIpNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 6, 1), )
if mibBuilder.loadTexts: cpqnIpNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpNetworkTable.setDescription('This table describes IP network information for each management agent interface. This could include all possible bridge groups and the SLIP interface')
cpqnIpNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnIpIfIndex"))
if mibBuilder.loadTexts: cpqnIpNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpNetworkEntry.setDescription('There is one entry for each agent interface which describes the IP protocol information on that interface.')
cpqnIpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnIpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpIfIndex.setDescription('This is the ifIndex value of an interface in the MIB-II interface table for which this table entry applies.')
cpqnIpPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnIpPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpPhysAddr.setDescription('The physical address of the management agent interface. This is usually an interfaces IEEE MAC Address. For IEEE MAC address, the value will be 6 bytes in network byte order. For interfaces which do not have such physical address (e.g., SLIP interfaces), this object will one zero byte.')
cpqnIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpAddr.setDescription('DURABLE: The IP Address of this Agent interface.')
cpqnIpNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpNetMask.setDescription('DURABLE: The IP Subnet Mask of this Agent interface.')
cpqnIpRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpRouter.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpRouter.setDescription('DURABLE: The IP Address of the next hop Router (default Gateway) used by this interface.')
cpqnIpFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-applicable", 1), ("ethernet-ii", 2), ("ieee-802-2-snap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpFrameType.setDescription('DURABLE: Except when booting up, an agent communicates over IP using a single frame type defining the type of network that the IP traffic is running on: Ethernet_II or IEEE 802.2_SNAP. When the agent is performing BOOTP, it may not assume any frame type and can attempt to BOOTP over both types. (see cpqnBootpEnable) It will use the frame type that the first BOOTP response uses for the rest of its communication. The frame type of the BOOTP response will be stored by this object. For interfaces that do not have an Ethernet frame type, e.g., the serial port, the frame type is always not-applicable(1).')
cpqnIpAutoDiscoveryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discover", 1), ("do-not-discover", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpAutoDiscoveryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpAutoDiscoveryStatus.setDescription("DURABLE: This object allows a user to enable the unit to send out periodic ICMP Pings to ensure that the unit's IP Address is contained in the ARP cache of its default gateway (cpqnIpRouter, if any!). If the user sets the state to discover(1), then the unit will issue ICMP Pings at a rate defined by cpqnIpPingPacketRate. If the user selects do-not-discover(2) then the unit does not send any ICMP Pings and may not be autodiscovered by IP based management applications.")
cpqnIpPingPktRate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(55, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpPingPktRate.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpPingPktRate.setDescription("DURABLE: This object determines the rate (in seconds) at which ICMP Pings are sent out by the unit to ensure that its IP Address remains in the ARP cache of the unit's default gateway (cpqnIpRouter). This object is useful only if cpqnIPAutoDiscoveryStatus is set to discover(1).")
cpqnIpInfoSave = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ignore-changes", 1), ("write-changes-to-nvram", 2), ("values-changed", 3), ("values-valid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpInfoSave.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpInfoSave.setDescription('Setting this object allows the changes made to any of the settable objects in this table to be written into non-volatile memory. The changes will not take effect nor be written into non-volatile memory until this object is set; therefore, until that time, the changes are stored but not used. This object will return values-valid(4) unless some object has been changed but the changes were not written to non-volatile memory. In this case it will return values-changed(3) until the changes are written to non-volatile memory.')
cpqnIpxNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 6, 2), )
if mibBuilder.loadTexts: cpqnIpxNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpxNetworkTable.setDescription('This table describes IPX network information for each agent interface.')
cpqnIpxNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 6, 2, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnIpxIfIndex"))
if mibBuilder.loadTexts: cpqnIpxNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpxNetworkEntry.setDescription('There is one entry for each agent interface which describes the IPX protocol information on that interface.')
cpqnIpxIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnIpxIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpxIfIndex.setDescription('This is the ifIndex value of an interface in the MIB-II interface table for which this table entry applies.')
cpqnIpxPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 2, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnIpxPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpxPhysAddr.setDescription('The physical address of the management agent interface. This is usually an interfaces IEEE MAC Address. For IEEE MAC address, the value will be 6 bytes in network byte order. For interfaces which do not have such physical address (e.g., SLIP interfaces), this object will one zero byte.')
cpqnIpxFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("not-applicable", 1), ("ethernet-ii", 2), ("ethernet-802-3-raw", 3), ("ieee-802-2", 4), ("ieee-802-2-snap", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpxFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpxFrameType.setDescription('DURABLE: The frame type with which IPX communication originating from the unit will take place. The unit will respond to a packet using the same frame type as was used in the request. This frame type comes into effect on any packet that is generated by the unit not in response to another external packet. An example is a SNMP Trap.')
cpqnIpxNetworkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnIpxNetworkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpxNetworkNumber.setDescription('DURABLE: The IPX Network number for this interface. If this object is 00000000, then the unit has not yet determined the network number.')
cpqnIpxSAPBcastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("do-ipx-SAPs", 1), ("no-ipx-SAPs", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnIpxSAPBcastStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnIpxSAPBcastStatus.setDescription('DURABLE: The unit may generate IPX SAP broadcasts. This allows the unit to be auto-discovered. By setting this object to do-ipx-SAPs(1), the unit will generate SAP broadcasts at a rate of one every 60 seconds. By setting this object to no-ipx-SAPs(2), the hub will not generate SAP broadcasts.')
cpqnBootpTable = MibTable((1, 3, 6, 1, 4, 1, 232, 121, 7, 1), )
if mibBuilder.loadTexts: cpqnBootpTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBootpTable.setDescription('A table of BOOTP configuration information for each management agent interface. This table controls the BOOTP behavior of the basic booting system. Other software components installed in a unit may also do BOOTP. This table does not control those components.')
cpqnBootpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 121, 7, 1, 1), ).setIndexNames((0, "CPQNUNIF-MIB", "cpqnBootpIfIndex"))
if mibBuilder.loadTexts: cpqnBootpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBootpEntry.setDescription('A list of BOOTP configuration information for each management agent interface.')
cpqnBootpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnBootpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBootpIfIndex.setDescription('This is the ifIndex value of an interface in the MIB-II interface table for which this table entry applies.')
cpqnBootpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable-bootp", 1), ("enable-bootp-ethernet-ii", 2), ("enable-bootp-ieee-802-2-snap", 3), ("enable-bootp-both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnBootpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBootpEnable.setDescription('DURABLE: This object allows the user to enable/disable generation of BOOTP requests on the interface specified by cpqnBootpIfIndex. BOOTP requests can be generated over the SNAP frame type, Ethernet-II frame type, or both.')
cpqnBootpRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnBootpRetries.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBootpRetries.setDescription('DURABLE: This determines the number of BOOTP requests that will be transmitted from the interface indicated by cpqnBootpIfIndex. This object is used in conjunction with the cpqnBootpRetryInterval object. If both frame types are enabled, then for each try, two BOOTP frames will be generated, one for each frame type. WARNING: Remember that while the unit is booting up, management may not be available, so be careful in selecting the number of retries and the interval for BOOTP. If these values are large, then the SNMP agent could be delayed in starting up by a significant time.')
cpqnBootpRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqnBootpRetryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBootpRetryInterval.setDescription('DURABLE: This object allows the user to set the time period (in seconds) between the transmission of BOOTP requests on the interface specified by cpqnBootpIfIndex. This object is used in conjunction with the cpqnBootpRetries object. WARNING: Remember that while the unit is booting up, management may not be available, so be careful in selecting the number of retries and the interval for BOOTP. If these values are large, then the SNMP agent could be delayed in starting up by a significant time.')
cpqnBootpServerIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 121, 7, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqnBootpServerIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqnBootpServerIpAddr.setDescription("The IP address of the BOOTP Server that last responded on the interface indicated by cpqnBootpIfIndex. If no BOOTP server has responded, then this object will be '0.0.0.0'.")
mibBuilder.exportSymbols("CPQNUNIF-MIB", cpqnIpxNetworkEntry=cpqnIpxNetworkEntry, cpqnVersionDesc=cpqnVersionDesc, cpqnCommAccessIPXEntry=cpqnCommAccessIPXEntry, CpqnVersionStep=CpqnVersionStep, cpqnVersionInformation=cpqnVersionInformation, cpqnIpxIfIndex=cpqnIpxIfIndex, cpqnVersionMinor=cpqnVersionMinor, cpqnMibModuleEntry=cpqnMibModuleEntry, cpqnMibModuleIndex=cpqnMibModuleIndex, cpqnIpFrameType=cpqnIpFrameType, cpqnAclIPCommunity=cpqnAclIPCommunity, cpqnCommunityAccessIPTable=cpqnCommunityAccessIPTable, cpqnAclIPAddrMask=cpqnAclIPAddrMask, cpqnSPortModemAutoNegotiateState=cpqnSPortModemAutoNegotiateState, cpqnBaudRatePortIndex=cpqnBaudRatePortIndex, cpqnVersionIndex=cpqnVersionIndex, cpqnCommon=cpqnCommon, cpqnVersionType=cpqnVersionType, cpqnIPTrapDestRowStatus=cpqnIPTrapDestRowStatus, cpqnIPTrapDestEntry=cpqnIPTrapDestEntry, cpqnIpIfIndex=cpqnIpIfIndex, cpqnMibModuleTable=cpqnMibModuleTable, cpqnIPXTrapDestIndex=cpqnIPXTrapDestIndex, cpqnCommAccessIPEntry=cpqnCommAccessIPEntry, cpqnCommunityAccessIPXTable=cpqnCommunityAccessIPXTable, cpqnBootpIfIndex=cpqnBootpIfIndex, cpqnBootpEnable=cpqnBootpEnable, cpqnIPTrapDestIndex=cpqnIPTrapDestIndex, cpqnIpAutoDiscoveryStatus=cpqnIpAutoDiscoveryStatus, cpqnIPTrapDestTable=cpqnIPTrapDestTable, cpqnVersionStep=cpqnVersionStep, cpqnAclIPXRights=cpqnAclIPXRights, cpqnIpxPhysAddr=cpqnIpxPhysAddr, cpqnSerialPortEntry=cpqnSerialPortEntry, cpqnSPortIfIndex=cpqnSPortIfIndex, cpqnAccessControl=cpqnAccessControl, cpqnAclIPRowStatus=cpqnAclIPRowStatus, cpqnIpxNetworkNumber=cpqnIpxNetworkNumber, cpqnAclIPXRowStatus=cpqnAclIPXRowStatus, cpqnIpAddr=cpqnIpAddr, cpqnTrapDestinations=cpqnTrapDestinations, cpqnIPTrapDestAddress=cpqnIPTrapDestAddress, cpqnIpPhysAddr=cpqnIpPhysAddr, cpqnVersionSerialNumber=cpqnVersionSerialNumber, cpqnAclIPXCommunity=cpqnAclIPXCommunity, cpqnSPortModemInitString=cpqnSPortModemInitString, cpqnSPortModemInitStringEnable=cpqnSPortModemInitStringEnable, cpqnIpxSAPBcastStatus=cpqnIpxSAPBcastStatus, cpqnSPortBaudRate=cpqnSPortBaudRate, CpqnRowStatus=CpqnRowStatus, cpqnAclIPXIndex=cpqnAclIPXIndex, cpqnSupportedBaudRateTable=cpqnSupportedBaudRateTable, cpqnAclIPXAddrMask=cpqnAclIPXAddrMask, cpqnIpInfoSave=cpqnIpInfoSave, cpqnMibModuleOid=cpqnMibModuleOid, cpqnIpRouter=cpqnIpRouter, cpqnAclIPXAddrMatch=cpqnAclIPXAddrMatch, cpqnIPTrapDestCommunity=cpqnIPTrapDestCommunity, CpqnVersionType=CpqnVersionType, cpqnUnitReset=cpqnUnitReset, cpqnBootpRetries=cpqnBootpRetries, cpqnNetworkInfo=cpqnNetworkInfo, cpqnVersionRev=cpqnVersionRev, cpqnMibModules=cpqnMibModules, cpqnIpPingPktRate=cpqnIpPingPktRate, cpqnAclIPIndex=cpqnAclIPIndex, cpqnIPXTrapDestTable=cpqnIPXTrapDestTable, cpqnVersionMajor=cpqnVersionMajor, cpqnBootpRetryInterval=cpqnBootpRetryInterval, cpqnBootpTable=cpqnBootpTable, cpqnIpNetworkTable=cpqnIpNetworkTable, cpqnMibModuleDescr=cpqnMibModuleDescr, cpqnIPXTrapDestEntry=cpqnIPXTrapDestEntry, cpqnIpxFrameType=cpqnIpxFrameType, cpqnIPXTrapDestRowStatus=cpqnIPXTrapDestRowStatus, cpqnVersionUnitId=cpqnVersionUnitId, cpqnAclIPAddrMatch=cpqnAclIPAddrMatch, IpxAddress=IpxAddress, cpqnSPortIndex=cpqnSPortIndex, cpqnBaudRateIndex=cpqnBaudRateIndex, cpqnVersionParentIndex=cpqnVersionParentIndex, cpqnBaudRate=cpqnBaudRate, cpqnSupportedBaudRateEntry=cpqnSupportedBaudRateEntry, cpqnUnitControl=cpqnUnitControl, cpqnPrimarySerialPort=cpqnPrimarySerialPort, cpqnIPXTrapDestAddress=cpqnIPXTrapDestAddress, cpqnBootpEntry=cpqnBootpEntry, cpqnAclIPRights=cpqnAclIPRights, cpqnBootpServerIpAddr=cpqnBootpServerIpAddr, cpqnSerialPortTable=cpqnSerialPortTable, cpqnVersionEntry=cpqnVersionEntry, cpqnIpNetworkEntry=cpqnIpNetworkEntry, cpqnAclTelnetControl=cpqnAclTelnetControl, compaq=compaq, cpqnIpxNetworkTable=cpqnIpxNetworkTable, cpqnIpNetMask=cpqnIpNetMask, cpqnVersionTable=cpqnVersionTable, cpqnIPXTrapDestCommunity=cpqnIPXTrapDestCommunity, cpqnBootpConfig=cpqnBootpConfig)

#
# PySNMP MIB module SMON2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SMON2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:07:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
smon, = mibBuilder.importSymbols("APPLIC-MIB", "smon")
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
OwnerString, = mibBuilder.importSymbols("RMON-MIB", "OwnerString")
LastCreateTime, ZeroBasedCounter32, TimeFilter, protocolDirLocalIndex, DataSource, hlMatrixControlIndex = mibBuilder.importSymbols("RMON2-MIB", "LastCreateTime", "ZeroBasedCounter32", "TimeFilter", "protocolDirLocalIndex", "DataSource", "hlMatrixControlIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Counter64, Unsigned32, iso, MibIdentifier, Gauge32, ObjectIdentity, Integer32, Bits, ModuleIdentity, Counter32, TimeTicks, Bits, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Counter64", "Unsigned32", "iso", "MibIdentifier", "Gauge32", "ObjectIdentity", "Integer32", "Bits", "ModuleIdentity", "Counter32", "TimeTicks", "Bits", "NotificationType")
TextualConvention, RowStatus, DisplayString, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString", "TimeStamp")
xsSmon = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 2))
xsSmonResourceAllocation = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSmonResourceAllocation.setStatus('current')
if mibBuilder.loadTexts: xsSmonResourceAllocation.setDescription('This item is used to define which SMON applications are using resources at the agent. When the console performs smon application it should read this item in order to know which of the SMON applications are available in this agent. When there is a value of 0 (zero) in the relevant bit it means that the associated application is not running on the agent, When there is a value of 1 (one) in the relevant bit it means that the associated application is suported. D0 - statistics D1 - history D2 - alarm D3 - host D4 - hostTopN D5 - matrix D6 - filter D7 - capture D8 - event D9 - tokenRing D10 - protocolDir D11 -protocolDist D12 -addressMap D13 -nlHost D14 - nlMatrix D15 -alHost D16 -alMatrix D17 -usrHistory D18 - probeConfig D19 -port D20 - portTopN D21 - subnet D22 - subnetMatrix D23 - vlan D24 - vlanMatrix D25 - nlHostTopN D26 - portHistory')
xsHostTopN = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 2, 2))
xsHostTopNControlTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1), )
if mibBuilder.loadTexts: xsHostTopNControlTable.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlTable.setDescription('A set of parameters that control the creation of a report of the top N network layer host entries according to a selected metric.')
xsHostTopNControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1), ).setIndexNames((0, "SMON2-MIB", "xsHostTopNControlIndex"))
if mibBuilder.loadTexts: xsHostTopNControlEntry.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlEntry.setDescription('A conceptual row in the xsHostTopNControlTable. An example of the indexing of this table is xsHostTopNControlDuration.3')
xsHostTopNControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: xsHostTopNControlIndex.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlIndex.setDescription('An index that uniquely identifies an entry in the xsHostTopNControlTable. Each such entry defines one top N report prepared for one interface.')
xsHostTopNControlHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsHostTopNControlHostIndex.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlHostIndex.setDescription('The nlHost table for which a top N report will be prepared on behalf of this entry. The nlHost table is identified by the value of the hlHostControlIndex for that table - that value is used here to identify the particular table. This object may not be modified if the associated xsHostTopNControlStatus object is equal to active(1).')
xsHostTopNControlRateBase = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("xsHostTopNInPkts", 1), ("xsHostTopNOutPkts", 2), ("xsHostTopNInOctets", 3), ("xsHostTopNOutOctets", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsHostTopNControlRateBase.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlRateBase.setDescription('The variable for each nlHost entry that the xsHostTopNEntries are sorted by. This object may not be modified if the associated xsHostTopNControlStatus object is equal to active(1).')
xsHostTopNControlTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsHostTopNControlTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlTimeRemaining.setDescription('The number of seconds left in the report currently being collected. When this object is modified by the management station, a new collection is started, possibly aborting a currently running report. The new value is used as the requested duration of this report, which is loaded into the associated xsHostTopNControlDuration object. When this object is set to a non-zero value, any associated xsHostTopNEntries shall be made inaccessible by the monitor. While the value of this object is non-zero, it decrements by one per second until it reaches zero. During this time, all associated xsHostTopNEntries shall remain inaccessible. At the time that this object decrements to zero, the report is made accessible in the xsHostTopNTable. Thus, the xsHostTopN table needs to be created only at the end of the collection interval.')
xsHostTopNControlDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsHostTopNControlDuration.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlDuration.setDescription('The number of seconds that this report has collected during the last sampling interval. When the associated HostTopNControlTimeRemaining object is set, this object shall be set by the probe to the same value and shall not be modified until the next time the xsHostTopNControlTimeRemaining is set. This value shall be zero if no reports have been requested for this xsHostTopNControlEntry.')
xsHostTopNControlRequestedSize = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(150)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsHostTopNControlRequestedSize.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlRequestedSize.setDescription('The maximum number of host entries requested for this report. When this object is created or modified, the probe should set xsHostTopNControlGrantedSize as closely to this object as is possible for the particular probe implementation and available resources.')
xsHostTopNControlGrantedSize = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsHostTopNControlGrantedSize.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlGrantedSize.setDescription('The maximum number of host entries in this report. When the associated xsHostTopNControlRequestedSize object is created or modified, the probe should set this object as closely to the requested value as is possible for the particular implementation and available resources. The probe must not lower this value except as a result of a set to the associated xsHostTopNControlRequestedSize object. If the value of xsHostTopNControlRateBase is equal to xsHostTopNPkts, when the next topN report is generated, matrix entries with the highest value of xsHostTopNPktRate shall be placed in this table in decreasing order of this rate until there is no more room or until there are no more matrix entries. If the value of xsHostTopNControlRateBase is equal to xsHostTopNOctets, when the next topN report is generated, matrix entries with the highest value of xsHostTopNOctetRate shall be placed in this table in decreasing order of this rate until there is no more room or until there are no more matrix entries. It is an implementation-specific matter how entries with the same value of xsHostTopNPktRate or xsHostTopNOctetRate are sorted. It is also an implementation-specific matter as to whether or not zero-valued entries are available.')
xsHostTopNControlStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsHostTopNControlStartTime.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlStartTime.setDescription('The value of sysUpTime when this top N report was last started. In other words, this is the time that the associated xsHostTopNControlTimeRemaining object was modified to start the requested report or the time the report was last automatically (re)started. This object may be used by the management station to determine if a report was missed or not.')
xsHostTopNControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 9), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsHostTopNControlOwner.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
xsHostTopNControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsHostTopNControlStatus.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNControlStatus.setDescription('The status of this xsHostTopNControlEntry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. If this object is not equal to active(1), all associated entries in the xsHostTopNTable shall be deleted by the agent.')
xsHostTopNTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 2), )
if mibBuilder.loadTexts: xsHostTopNTable.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNTable.setDescription('A set of statistics for those network layer hosts that have counted the highest number of octets or packets.')
xsHostTopNEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 2, 1), ).setIndexNames((0, "SMON2-MIB", "xsHostTopNControlIndex"), (0, "SMON2-MIB", "xsHostTopNIndex"))
if mibBuilder.loadTexts: xsHostTopNEntry.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNEntry.setDescription('A conceptual row in the xsHostTopNTable. The xsHostTopNControlIndex value in the index identifies the xsHostTopNControlEntry on whose behalf this entry was created. An example of the indexing of this table is xsHostTopNPktRate.3.10')
xsHostTopNIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: xsHostTopNIndex.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNIndex.setDescription('An index that uniquely identifies an entry in the xsHostTopNTable among those in the same report. This index is between 1 and N, where N is the number of entries in this report. If the value of xsHostTopNControlRateBase is equal to xsHostTopNInPkts, increasing values of xsHostTopNIndex shall be assigned to entries with decreasing values of xsHostTopNRate until index N is assigned or there are no more xsHostTopNEntries. ')
xsHostTopNProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsHostTopNProtocolDirLocalIndex.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNProtocolDirLocalIndex.setDescription("The protocolDirLocalIndex of the network layer protocol of this entry's network address.")
xsHostTopNNlAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsHostTopNNlAddress.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNNlAddress.setDescription('The network layer address of the host in this collection. This is represented as an octet string with specific semantics and length as identified by the associated xsHostTopN ProtocolDirLocalIndex. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsHostTopNRate = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 2, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsHostTopNRate.setStatus('current')
if mibBuilder.loadTexts: xsHostTopNRate.setDescription('The number of packets seen from the source host to the destination host during this sampling interval, counted using the rules for counting the xsHostPkts object. If the value of xsHostTopNControlRateBase is xsHostTopNPkts, this variable will be used to sort this report.')
xsFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 2, 3))
xsHostFilterTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 1), )
if mibBuilder.loadTexts: xsHostFilterTable.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterTable.setDescription("A list of network layer addresses hosts to be monitored through an interface by the RMON II MIB hosts group. The OID of this table is a legitimate value for the hlMatrixControlDataSource, and for LANNET's Groups xsSubnetControlDataSource, xsSubnetMatrixControlDataSource,")
xsHostFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 1, 1), ).setIndexNames((0, "SMON2-MIB", "xsHostFilterIpAddress"))
if mibBuilder.loadTexts: xsHostFilterEntry.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterEntry.setDescription('An entry in the filter table.')
xsHostFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipHost", 1), ("ipSubnet", 2), ("ipxNet", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xsHostFilterType.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterType.setDescription('Indicates the type of the filter defined by this entry.')
xsHostFilterIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xsHostFilterIpAddress.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterIpAddress.setDescription('The IP address of a host monitored via the Interface. In case the filter type is not ipHost(1), the value of this entry is not relevant and should return the null string.')
xsHostFilterIpSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xsHostFilterIpSubnet.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterIpSubnet.setDescription('The address of a IP subnet monitored via the Interface. In case the filter type is not ipSubnet(2), the value of this entry is not relevant and should return the null string.')
xsHostFilterIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xsHostFilterIpMask.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterIpMask.setDescription('The mask of a IP subnet monitored via the Interface. In case the filter type is not ipSubnet(2), the value of this entry is not relevant and should return the null string.')
xsHostFilterIpxAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 1, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xsHostFilterIpxAddress.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterIpxAddress.setDescription('The address of a IPX monitored via the Interface. In case the filter type is not ipxNet(3), the value of this entry is not relevant and should return the null string.')
xsHostFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xsHostFilterStatus.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterStatus.setDescription('The status of this xsHostFilter entry.')
xsHostFilterTableClear = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xsHostFilterTableClear.setStatus('current')
if mibBuilder.loadTexts: xsHostFilterTableClear.setDescription('Setting the value of this item to clear(2) causes the agent to clear all entries in the HostFilterTable.')
xsSubnet = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 2, 4))
xsSubnetControlTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1), )
if mibBuilder.loadTexts: xsSubnetControlTable.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlTable.setDescription('A list of higher layer (i.e. non-MAC) Subnets\\Networks table control entries. These entries will enable the collection of the network and application level subnets tables indexed by subnetwork addresses. Entries in the xsSubnetTable will be created on behalf of each entry in this table. Implementations are encouraged to add an entry per monitored interface upon initialization so that a default collection of subnet statistics is available.')
xsSubnetControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1, 1), ).setIndexNames((0, "SMON2-MIB", "xsSubnetControlIndex"))
if mibBuilder.loadTexts: xsSubnetControlEntry.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlEntry.setDescription('A conceptual row in the sSubnetControlTable. An example of the indexing of this entry is xsSubnetControlDataSource.1')
xsSubnetControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: xsSubnetControlIndex.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlIndex.setDescription('An index that uniquely identifies an entry in the xsSubnetControlTable. Each such entry defines a function that collects statistics on a particular interface and places statistics about them in the xsSubnetTable, on behalf of this xsSubnetControlEntry.')
xsSubnetControlDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsSubnetControlDataSource.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlDataSource.setDescription('The source of data for the associated Subnet tables. The statistics in this group reflect all packets on the local network segment attached to the identified interface.Mostly this instance will be the xsHostFilterTable. This object may not be modified if the associated xsSubnetControlStatus object is equal to active(1).')
xsSubnetControlInserts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetControlInserts.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlInserts.setDescription('The number of times an xsSubnet entry has been inserted into the xsSubnet table. If an entry is inserted, then deleted, and then inserted, this counter will be incremented by 2. To allow for efficient implementation strategies, agents may delay updating this object for short periods of time. For example, an implementation strategy may allow internal data structures to differ from those visible via SNMP for short periods of time. This counter may reflect the internal data structures for those short periods of time. Note that the table size can be determined by subtracting xsSubnetControlDeletes from xsSubnetControlInserts.')
xsSubnetControlDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetControlDeletes.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlDeletes.setDescription('The number of times an xsSubnet entry has been deleted from the xsSubnet table (for any reason). If an entry is deleted, then inserted, and then deleted, this counter will be incremented by 2. To allow for efficient implementation strategies, agents may delay updating this object for short periods of time. For example, an implementation strategy may allow internal data structures to differ from those visible via SNMP for short periods of time. This counter may reflect the internal data structures for those short periods of time. Note that the table size can be determined by subtracting xsSubnetControlDeletes from xsSubnetControlInserts.')
xsSubnetControlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsSubnetControlMaxDesiredEntries.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlMaxDesiredEntries.setDescription("The maximum number of entries that are desired in the xsSubnetable on behalf of this control entry. The probe will not create more than this number of associated entries in the table, but may choose to create fewer entries in this table for any reason including the lack of resources. If this object is set to a value less than the current number of entries, enough entries are chosen in an implementation - dependent manner and deleted so that the number of entries in the table equals the value of this object. If this value is set to -1, the probe may create any number of entries in this table. If the associated xsSubnetControlStatus object is equal to `active', this object may not be modified. This object may be used to control how resources are allocated on the probe for the various RMON functions.")
xsSubnetControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1, 1, 6), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsSubnetControlOwner.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
xsSubnetControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsSubnetControlStatus.setStatus('current')
if mibBuilder.loadTexts: xsSubnetControlStatus.setDescription('The status of this xsSubnetControlEntry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. If this object is not equal to active(1), all associated entries in the nlHostTable and alHostTable shall be deleted.')
xsSubnetTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 2), )
if mibBuilder.loadTexts: xsSubnetTable.setStatus('current')
if mibBuilder.loadTexts: xsSubnetTable.setDescription('A collection of statistics for a particular subnetwork layer address that has been discovered on an interface of this device. The probe will populate this table for all network layer protocols in the protocol directory table whose value of protocolDirHostConfig is equal to supportedOn(3), and will delete any entries whose protocolDirEntry is deleted or has a protocolDirHostConfig value of supportedOff(2). The probe will add to this table all subnetwork addresses that exist in the xsHostFilter.')
xsSubnetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 2, 1), ).setIndexNames((0, "SMON2-MIB", "xsSubnetControlIndex"), (0, "SMON2-MIB", "xsSubnetTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "SMON2-MIB", "xsSubnetAddress"), (0, "SMON2-MIB", "xsSubnetMask"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: xsSubnetEntry.setStatus('current')
if mibBuilder.loadTexts: xsSubnetEntry.setDescription('A conceptual row in the xsSubnetTable. The xsSubnetControlIndex value in the index identifies the xsSubnetControlEntry on whose behalf this entry was created. The first protocolDirLocalIndex value in the index identifies the network layer protocol the second protocolLocalDirIndex identifies the protocol (network or application layer protocol) to be monitored on that of the xsSubnetAddress. An example of the indexing of this entry is xsSubnetOutPkts.1.783495.18.4.128.2.6.6.4.255.255.255.0.18.This Index indexes The total out IP packets of an Ip Subnet')
xsSubnetTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 2, 1, 1), TimeFilter())
if mibBuilder.loadTexts: xsSubnetTimeMark.setStatus('current')
if mibBuilder.loadTexts: xsSubnetTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention to see how this works.')
xsSubnetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 2, 1, 2), OctetString())
if mibBuilder.loadTexts: xsSubnetAddress.setStatus('current')
if mibBuilder.loadTexts: xsSubnetAddress.setDescription('The subnetwork address for this xsSubnetEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 2, 1, 3), OctetString())
if mibBuilder.loadTexts: xsSubnetMask.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMask.setDescription('The subnetwork mask for this xsSubnetEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 2, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetInPkts.setStatus('current')
if mibBuilder.loadTexts: xsSubnetInPkts.setDescription('The number of packets without errors transmitted to this subnetwork address since it was added to the xsSubnetTable. Note that this is the number of link-layer packets, so if a single network-layer packet is fragmented into several link-layer frames, this counter is incremented several times.')
xsSubnetOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetOutPkts.setStatus('current')
if mibBuilder.loadTexts: xsSubnetOutPkts.setDescription('The number of packets without errors transmitted by this subnetwork address since it was added to the xsSubnetTable. Note that this is the number of link-layer packets, so if a single network-layer packet is fragmented into several link-layer frames, this counter is incremented several times.')
xsSubnetCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 2, 1, 6), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetCreateTime.setStatus('current')
if mibBuilder.loadTexts: xsSubnetCreateTime.setDescription('The value of sysUpTime when this entry was last activated. This can be used by the management station to ensure that the entry has not been deleted and recreated between polls.')
xsSubnetMatrixControlTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3), )
if mibBuilder.loadTexts: xsSubnetMatrixControlTable.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlTable.setDescription('A list of higher layer (i.e. non-MAC) matrix control entries. These entries will enable the collection of the network and application level matrix tables containing conversation statistics indexed by pairs of subnetwork addresses. Entries in the xsSubnetMatrixSDTable and xsSubnetMatrixDSTable will be created on behalf of each entry in this table.')
xsSubnetMatrixControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3, 1), ).setIndexNames((0, "SMON2-MIB", "xsSubnetMatrixControlIndex"))
if mibBuilder.loadTexts: xsSubnetMatrixControlEntry.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlEntry.setDescription('A conceptual row in the xsSubnetMatrixControlTable. An example of indexing of this entry is xsSubnetMatrixControDataSource.1')
xsSubnetMatrixControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: xsSubnetMatrixControlIndex.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlIndex.setDescription('An index that uniquely identifies an entry in the xsSubnetMatrixControlTable. Each such entry defines a function that discovers conversations on a particular interface and places statistics about them in the xsSubnetMatrixSDTable and the xsSubnetMatrixDSTable, on behalf of this xsSubnetMatrixControlEntry.')
xsSubnetMatrixControlDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsSubnetMatrixControlDataSource.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlDataSource.setDescription('The source of the data for the associated matrix tables. The statistics in this group reflect all packets on the local network segment attached to the identified interface.Mostly this instance will be the xsHostFilterTable. This object may not be modified if the associated xsSubnetControlStatus object is equal to active(1).')
xsSubnetMatrixControlInserts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetMatrixControlInserts.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlInserts.setDescription('The number of times an subnetMatrix entry has been inserted into the subnetMatrix tables. If an entry is inserted, then deleted, and then inserted, this counter will be incremented by 2. The addition of a conversation into both the xsSubnetMatrixSDTable and xsSubnetMatrixDSTable shall be counted as two insertions (even though every addition into one table must be accompanied by an insertion into the other).To allow for efficient implementation strategies, agents may delay updating this object for short periods of time. For example, an implementation strategy may allow internal data structures to differ from those visible via SNMP for short periods of time. This counter may reflect the internal data structures for those short periods of time. Note that the sum of then xsSubnetMatrixSDTable and xsSubnetMatrixDSTable sizes can be determined by subtracting xsSubnetMatrixControlNlDeletes from xsSubnetMatrixControlNlInserts.')
xsSubnetMatrixControlDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetMatrixControlDeletes.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlDeletes.setDescription('The number of times an subnetMatrix entry has been deleted from the subnetMatrix tables (for any reason). If an entry is deleted, then inserted, and then deleted, this counter will be incremented by 2. The deletion of a conversation from both the xsSubnetMatrixSDTable and xsSubnetMatrixDSTable shall be counted as two deletions (even though every deletion from one table must be accompanied by a deletion from the other). To allow for efficient implementation strategies, agents may delay updating this object for short periods of time. For example, an implementation strategy may allow internal data structures to differ from those visible via SNMP for short periods of time. This counter may reflect the internal data structures for those short periods of time. Note that the table size can be determined by subtracting xsSubnetMatrixControlNlDeletes from xsSubnetMatrixControlNlInserts.')
xsSubnetMatrixControlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsSubnetMatrixControlMaxDesiredEntries.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlMaxDesiredEntries.setDescription("The maximum number of entries that are desired in the subnetMatrix tables on behalf of this control entry. The probe will not create more than this number of associated entries in the table, but may choose to create fewer entries in this table for any reason including the lack of resources. If this object is set to a value less than the current number of entries, enough entries are chosen in an implementation-dependent manner and deleted so that the number of entries in the table equals the value of this object. If this value is set to -1, the probe may create any number of entries in this table. If the associated xsSubnetMatrixControlStatus object is equal to `active', this object may not be modified. This object may be used to control how resources are allocated on the probe for the various RMON functions.")
xsSubnetMatrixControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3, 1, 7), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsSubnetMatrixControlOwner.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
xsSubnetMatrixControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: xsSubnetMatrixControlStatus.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixControlStatus.setDescription('The status of this xsSubnetMatrixControlEntry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. If this object is not equal to active(1), all associated entries in the xsSubnetMatrixSDTable, xsSubnetMatrixDSTable shall be deleted by the agent.')
xsSubnetMatrixSDTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4), )
if mibBuilder.loadTexts: xsSubnetMatrixSDTable.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDTable.setDescription('A list of traffic matrix entries which collect statistics for conversations between two network-level addresses. This table is indexed first by the source address and then by the destination address to make it convenient to collect all conversations from a particular address. The probe will populate this table for all network layer protocols in the protocol directory table whose value of protocolDirMatrixConfig is equal to supportedOn(3), and will delete any entries whose protocolDirEntry is deleted or has a protocolDirMatrixConfig value of supportedOff(2). The probe will add to this table all pairs of addresses seen in all packets with no MAC errors, and will increment octet and packet counts in the table for all packets with no MAC errors. Further, this table will only contain entries that have a corresponding entry in the xsSubnetMatrixDSTable with the same source address and destination address.')
xsSubnetMatrixSDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4, 1), ).setIndexNames((0, "SMON2-MIB", "xsSubnetMatrixControlIndex"), (0, "SMON2-MIB", "xsSubnetMatrixSDTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "SMON2-MIB", "xsSubnetMatrixSDSourceAddress"), (0, "SMON2-MIB", "xsSubnetMatrixSDSourceMask"), (0, "SMON2-MIB", "xsSubnetMatrixSDDestAddress"), (0, "SMON2-MIB", "xsSubnetMatrixSDDestMask"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: xsSubnetMatrixSDEntry.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDEntry.setDescription('A conceptual row in the xsSubnetMatrixSDTable. The xsSubnetMatrixControlIndex value in the index identifies the xsSubnetMatrixControlEntry on whose behalf this entry was created. The first protocolDirLocalIndex value in the index identifies the protocol of the xsSubnetMatrixSDSourceAddress and xsSubnetMatrixSDDestAddress (network layer protocol), the second protocolDirLocalIndex. identifies the protocol to be monitored on that subnet (network or application layer) An example of the indexing of this table is xsSubnetMatrixSDPkts.1.783495.18.4.128.2.6.6.4.255.255.255.0.4.128.3.6.7..4.255.255.255.0.18')
xsSubnetMatrixSDTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4, 1, 1), TimeFilter())
if mibBuilder.loadTexts: xsSubnetMatrixSDTimeMark.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention to see how this works.')
xsSubnetMatrixSDSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4, 1, 2), OctetString())
if mibBuilder.loadTexts: xsSubnetMatrixSDSourceAddress.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDSourceAddress.setDescription('The subnetwork source address for this xsSubnetMatrixSDEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMatrixSDSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4, 1, 3), OctetString())
if mibBuilder.loadTexts: xsSubnetMatrixSDSourceMask.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDSourceMask.setDescription('The subnetwork source mask for this xsSubnetMatrixSDEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMatrixSDDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4, 1, 4), OctetString())
if mibBuilder.loadTexts: xsSubnetMatrixSDDestAddress.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDDestAddress.setDescription('The subnetwork destination address for this xsSubnetMatrixSDEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMatrixSDDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4, 1, 5), OctetString())
if mibBuilder.loadTexts: xsSubnetMatrixSDDestMask.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDDestMask.setDescription('The subnetwork destination mask for this xsSubnetMatrixSDEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMatrixSDPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetMatrixSDPkts.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDPkts.setDescription('The number of packets without errors transmitted from the source address to the destination address since this entry was added to the xsSubnetMatrixSDTable. Note that this is the number of link-layer packets, so if a single network-layer packet is fragmented into several link-layer frames, this counter is incremented several times.')
xsSubnetMatrixSDCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 4, 1, 7), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetMatrixSDCreateTime.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixSDCreateTime.setDescription('The value of sysUpTime when this entry was last activated. This can be used by the management station to ensure that the entry has not been deleted and recreated between polls.')
xsSubnetMatrixDSTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5), )
if mibBuilder.loadTexts: xsSubnetMatrixDSTable.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSTable.setDescription('A list of traffic matrix entries which collect statistics for conversations between two subnetwork-level addresses. This table is indexed first by the destination address and then by the source address to make it convenient to collect all conversations to a particular address. The probe will populate this table for all network layer and application layer protocols in the protocol directory table whose value of protocolDirMatrixConfig is equal to supportedOn(3), and will delete any entries whose protocolDirEntry is deleted or has a protocolDirMatrixConfig value of supportedOff(2). The probe will add to this table all pairs of addresses that fits the xsHostFilter. Further, this table will only contain entries that have a corresponding entry in the xsSubnetMatrixSDTable with the same source address and destination address.')
xsSubnetMatrixDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5, 1), ).setIndexNames((0, "RMON2-MIB", "hlMatrixControlIndex"), (0, "SMON2-MIB", "xsSubnetMatrixDSTimeMark"), (0, "RMON2-MIB", "protocolDirLocalIndex"), (0, "SMON2-MIB", "xsSubnetMatrixDSDestAddress"), (0, "SMON2-MIB", "xsSubnetMatrixDSDestMask"), (0, "SMON2-MIB", "xsSubnetMatrixDSSourceAddress"), (0, "SMON2-MIB", "xsSubnetMatrixDSSourceMask"), (0, "RMON2-MIB", "protocolDirLocalIndex"))
if mibBuilder.loadTexts: xsSubnetMatrixDSEntry.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSEntry.setDescription('A conceptual row in the xsSubnetMatrixDSTable. The hlMatrixControlIndex value in the index identifies the hlMatrixControlEntry on whose behalf this entry was created. The protocolDirLocalIndex value in the index identifies the network layer protocol of the xsSubnetMatrixDSSourceAddress and xsSubnetMatrixDSDestAddress. An example of the indexing of this table is xsSubnetMatrixDSPkts.1.783495.18.4.128.2.6.7.4.255.255.255.0.4.128.3.6.6.4.255.255.255.0.18')
xsSubnetMatrixDSTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5, 1, 1), TimeFilter())
if mibBuilder.loadTexts: xsSubnetMatrixDSTimeMark.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention to see how this works.')
xsSubnetMatrixDSSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5, 1, 2), OctetString())
if mibBuilder.loadTexts: xsSubnetMatrixDSSourceAddress.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSSourceAddress.setDescription('The subnetwork source address for this xsSubnetMatrixDSEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMatrixDSSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5, 1, 3), OctetString())
if mibBuilder.loadTexts: xsSubnetMatrixDSSourceMask.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSSourceMask.setDescription('The subnetwork source mask for this xsSubnetMatrixDSEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMatrixDSDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5, 1, 4), OctetString())
if mibBuilder.loadTexts: xsSubnetMatrixDSDestAddress.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSDestAddress.setDescription('The subnetwork destination address for this xsSubnetMatrixDSEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMatrixDSDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5, 1, 5), OctetString())
if mibBuilder.loadTexts: xsSubnetMatrixDSDestMask.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSDestMask.setDescription('The subnetwork destination mask for this xsSubnetMatrixDSEntry. This is represented as an octet string with specific semantics and length as identified by the protocolDirLocalIndex component of the index. For example, if the protocolDirLocalIndex indicates an encapsulation of ip, this object is encoded as a length octet of 4, followed by the 4 octets of the ip address, in network byte order.')
xsSubnetMatrixDSPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetMatrixDSPkts.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSPkts.setDescription('The number of packets without errors transmitted from the source address to the destination address since this entry was added to the xsSubnetMatrixDSTable. Note that this is the number of link-layer packets, so if a single network-layer packet is fragmented into several link-layer frames, this counter is incremented several times.')
xsSubnetMatrixDSCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 4, 5, 1, 7), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetMatrixDSCreateTime.setStatus('current')
if mibBuilder.loadTexts: xsSubnetMatrixDSCreateTime.setDescription('The value of sysUpTime when this entry was last activated. This can be used by the management station to ensure that the entry has not been deleted and recreated between polls.')
xsNumberOfProtocols = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsNumberOfProtocols.setStatus('current')
if mibBuilder.loadTexts: xsNumberOfProtocols.setDescription('This attribute contains the number of protocols in the protocolDirTable.')
xsProtocolDistStatsTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 2, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsProtocolDistStatsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: xsProtocolDistStatsTimeStamp.setDescription('This attribute contains the value of sysUpTime at the time protocolDistStats counters were calculated.')
xsNlHostTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 2, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsNlHostTimeStamp.setStatus('current')
if mibBuilder.loadTexts: xsNlHostTimeStamp.setDescription('This attribute contains the value of sysUpTime at the time nlHost counters were calculated.')
xsSubnetStatsTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 2, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsSubnetStatsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: xsSubnetStatsTimeStamp.setDescription('This attribute contains the value of sysUpTime at the time xsSubnetStats counters were calculated.')
xsActiveApplications = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 2, 9))
xsActiveApplicationsBitMask = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 2, 9, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(128, 128)).setFixedLength(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsActiveApplicationsBitMask.setStatus('current')
if mibBuilder.loadTexts: xsActiveApplicationsBitMask.setDescription("The Active Applications bit mask is representing every active application from the first 1024 'well defined' applications. Each application is represented by a single bit in the string. Application number 1 is represented by the first bit in the string. Bit value '1' means, the protocol is active. Bit value '0' means, the protocol is inactive. For example the FTP data application, assigned as number 20. If the FTP application is active, then the bit number 20 will be set to '1'.")
xsActiveApplicationsTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 2, 9, 2), )
if mibBuilder.loadTexts: xsActiveApplicationsTable.setStatus('current')
if mibBuilder.loadTexts: xsActiveApplicationsTable.setDescription("This table contain the 'active applications' from the 1024 'well defined' applications. For each active application, there is a global counter indicates the number of packets in the specific application monitored by the probe.")
xsActiveApplicationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 2, 9, 2, 1), ).setIndexNames((0, "SMON2-MIB", "xsActiveApplicationsIndex"))
if mibBuilder.loadTexts: xsActiveApplicationsEntry.setStatus('current')
if mibBuilder.loadTexts: xsActiveApplicationsEntry.setDescription('The entry for the xsActiveApplicationsTable. For each active application, there is a global counter indicates the number of packets in the specific application monitored by the probe.')
xsActiveApplicationsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 9, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: xsActiveApplicationsIndex.setStatus('current')
if mibBuilder.loadTexts: xsActiveApplicationsIndex.setDescription('The number of the application.')
xsActiveApplicationsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 2, 9, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xsActiveApplicationsPkts.setStatus('current')
if mibBuilder.loadTexts: xsActiveApplicationsPkts.setDescription('The number of packets of the specified application, monitored by the probe.')
xsSmonStatus = MibScalar((1, 3, 6, 1, 4, 1, 81, 30, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operate", 1), ("paused", 2))).clone('paused')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xsSmonStatus.setStatus('current')
if mibBuilder.loadTexts: xsSmonStatus.setDescription('This item is set to value operate(1) when SMON is running on the probe and paused(2) when SMON is paused. The status is in operate(1) value whenever there is a valid control or when a Console set this item to operate(1). The status is in paused(2) value when there is no valid control and the Console didnot set this item to operate(1).')
drSmon = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 4))
drSmonConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 4, 1))
drSmonControlTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 1), )
if mibBuilder.loadTexts: drSmonControlTable.setStatus('current')
if mibBuilder.loadTexts: drSmonControlTable.setDescription('A table configuring SMON-2 operation for each router module in a device.')
drSmonControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 1, 1), ).setIndexNames((0, "SMON2-MIB", "drSmonControlModuleID"))
if mibBuilder.loadTexts: drSmonControlEntry.setStatus('current')
if mibBuilder.loadTexts: drSmonControlEntry.setDescription('A conceptual row in the drSmonControlTable. Configures the SMON-2 operation for a particular module in the device. The row is statically created by the agent if the module is inserted.')
drSmonControlModuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: drSmonControlModuleID.setStatus('current')
if mibBuilder.loadTexts: drSmonControlModuleID.setDescription('The module group number (=slot number). Used as index.')
drSmonControlRowAddressAutoLearnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notSupported", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: drSmonControlRowAddressAutoLearnMode.setStatus('current')
if mibBuilder.loadTexts: drSmonControlRowAddressAutoLearnMode.setDescription('Controls whether the embedded SMON application populates the matrix Rows with automatically-learned addresses in addition to those specified in the filter table. enable(1) - turns auto-learn on disable(2) - turns auto-learn off This toggle is meaningless in modes other than nl/al matrix.')
drSmonControlRoutedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonControlRoutedPackets.setStatus('current')
if mibBuilder.loadTexts: drSmonControlRoutedPackets.setDescription('The number of packets routed by the 3rd-layer forwarding hardware of this module.')
drSmonControlProtocolDistStatsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonControlProtocolDistStatsTimeStamp.setStatus('current')
if mibBuilder.loadTexts: drSmonControlProtocolDistStatsTimeStamp.setDescription('This attribute contains the value of sysUpTime at the time protocolDistStats counters were determined by the agent.')
drSmonControlMatrixRows = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonControlMatrixRows.setStatus('current')
if mibBuilder.loadTexts: drSmonControlMatrixRows.setDescription('The number of rows in the device entity matrix/table for the current counting mode. Applicable to counting mode capable of supporting one or more of the following statistics: nlHost, nlMatrix, alHost and alMatrix. For modes not supporting entity (host, subnet, or RNR group) tables/ matrices, this counter will be 0')
drSmonControlMatrixCols = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonControlMatrixCols.setStatus('current')
if mibBuilder.loadTexts: drSmonControlMatrixCols.setDescription('The number of columns in the device entity matrix/table for the current counting mode. Applicable to counting mode capable of supporting one or more of the following statistics: nlHost, nlMatrix, alHost and alMatrix. For modes not supporting entity (host, subnet, or RNR group) tables/ matrices, this counter will be 0')
drSmonEntityPlacementTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 2), )
if mibBuilder.loadTexts: drSmonEntityPlacementTable.setStatus('current')
if mibBuilder.loadTexts: drSmonEntityPlacementTable.setDescription('A table containging a set of tables. Each table reports the placment of entities in the counter matrix/table of a particular module. Entities could be IP hosts, IP subnets, or other 3rd layer groups specified in IP-address/SubnetMask format, for which the device is capable of assigning an entry in its counter matrix/table.')
drSmonEntityPlacementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 2, 1), ).setIndexNames((0, "SMON2-MIB", "drSmonEntityPlacementModuleID"), (0, "SMON2-MIB", "drSmonEntityPlacementIndex"))
if mibBuilder.loadTexts: drSmonEntityPlacementEntry.setStatus('current')
if mibBuilder.loadTexts: drSmonEntityPlacementEntry.setDescription("A conceptual row in the drSmonEntityPlacementTable. Reports the index of a entity in the device's counter marix/table. Reports the creator of this entity - filter table or device's internal auto-learn process.")
drSmonEntityPlacementModuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: drSmonEntityPlacementModuleID.setStatus('current')
if mibBuilder.loadTexts: drSmonEntityPlacementModuleID.setDescription('The module group number (=slot number). Used as index.')
drSmonEntityPlacementIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: drSmonEntityPlacementIndex.setStatus('current')
if mibBuilder.loadTexts: drSmonEntityPlacementIndex.setDescription("The placment index of the particular entity. The index determines the position of the entity in the counter matrix/table. Example: For a matrix of A rows x B columns and index i: If i<A then host is both on row i and column i else host is on column i. The agent must provide entries in this table for all the index values in the range of 1..(drSmonControlMatrixRows-1) Row 0 of a matrix/table is reserved for 'Others' entity, and is not reported in this MIB table.")
drSmonEntityPlacementAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonEntityPlacementAddress.setStatus('current')
if mibBuilder.loadTexts: drSmonEntityPlacementAddress.setDescription('The IP address of an entity to explicitly monitor')
drSmonEntityPlacementMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonEntityPlacementMask.setStatus('current')
if mibBuilder.loadTexts: drSmonEntityPlacementMask.setDescription('The subnet mask of an entity. The value 255.255.255.255 signifies that this entity is a host.')
drSmonEntityPlacementType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("empty", 1), ("autoLearn", 2), ("filter", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonEntityPlacementType.setStatus('current')
if mibBuilder.loadTexts: drSmonEntityPlacementType.setDescription('The Type of this entity: empty(1) - Contains no relevant information. Not yet allocated to a specific entity. autoLearn(2) - The entity was learned by the auto-learn process of the device. filter(3) - The entity was created by a relevant filter entry in the filter table. ')
drSmonProtocolDir = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 4, 2))
drSmonProtocolDirLCTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 1), )
if mibBuilder.loadTexts: drSmonProtocolDirLCTable.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirLCTable.setDescription('A table with protocolDirLastChange per module.')
drSmonProtocolDirLCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 1, 1), ).setIndexNames((0, "SMON2-MIB", "drSmonProtocolDirLCModuleID"))
if mibBuilder.loadTexts: drSmonProtocolDirLCEntry.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirLCEntry.setDescription('A conceptual row in the drSmonProtocolDirLastChangeTable. Contains information for a particular module.')
drSmonProtocolDirLCModuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: drSmonProtocolDirLCModuleID.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirLCModuleID.setDescription('The module group number (=slot number). Used as index.')
drSmonProtocolDirLCLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 1, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonProtocolDirLCLastChange.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirLCLastChange.setDescription('Same function as RFC 2021 protocolDirLastChange, but for a particular module.')
drSmonProtocolDirTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2), )
if mibBuilder.loadTexts: drSmonProtocolDirTable.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirTable.setDescription('This table contain a set of protocolDirTables. Each protocolDirTable lists the protocols that a particular module has the capability to decode and count. There is one entry in the per-module table for each such protocol. These protocols represent different network layer, transport layer, and higher-layer protocols.')
drSmonProtocolDirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1), ).setIndexNames((0, "SMON2-MIB", "drSmonProtocolDirModuleID"), (0, "SMON2-MIB", "drSmonProtocolDirID"), (0, "SMON2-MIB", "drSmonProtocolDirParameters"))
if mibBuilder.loadTexts: drSmonProtocolDirEntry.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirEntry.setDescription('A conceptual row in the drSmonProtocolDirTable. Represent a protocol to monitor on a particulat module. All fields except for drSmonProtocolDirModuleID have the same function as in RFC 2021 protocolDirTable. An example of the indexing of this entry is drSmonProtocolDirLocalIndex.3.8.0.0.0.1.0.0.8.0.2.0.0, which is a protocol for module 3 with the encoding of a length of 8, followed by 8 subids encoding the drSmonProtocolDirID of 1.2048, followed by a length of 2 and the 2 subids encoding zero-valued parameters.')
drSmonProtocolDirModuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: drSmonProtocolDirModuleID.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirModuleID.setDescription('The module group number (=slot number). Used as index.')
drSmonProtocolDirID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 2), OctetString())
if mibBuilder.loadTexts: drSmonProtocolDirID.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirID.setDescription('A unique identifier for a particular protocol. same as RFC 2021, but for a particular module.')
drSmonProtocolDirParameters = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 3), OctetString())
if mibBuilder.loadTexts: drSmonProtocolDirParameters.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirParameters.setDescription('A set of parameters for the associated drSmonProtocolDirID. Same as RFC 2021, but for a particular module.')
drSmonProtocolDirLocalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonProtocolDirLocalIndex.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirLocalIndex.setDescription('The locally arbitrary, but unique identifier associated with this drSmonProtocolDir entry. Same as RFC 2021, but for a particular module.')
drSmonProtocolDirDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonProtocolDirDescr.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirDescr.setDescription('A textual description of the protocol encapsulation. Same as RFC 2021, but for a particular module.')
drSmonProtocolDirType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 6), Bits().clone(namedValues=NamedValues(("extensible", 0), ("addressRecognitionCapable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonProtocolDirType.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirType.setDescription('This object describes 2 attributes of this protocol directory entry. Same as RFC 2021, but for a particular module.')
drSmonProtocolDirAddressMapConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("supportedOff", 2), ("supportedOn", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonProtocolDirAddressMapConfig.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirAddressMapConfig.setDescription("This object describes and configures the probe's support for address mapping for this protocol. Same as RFC 2021, but for a particular module.")
drSmonProtocolDirHostConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("supportedOff", 2), ("supportedOn", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonProtocolDirHostConfig.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirHostConfig.setDescription("This object describes and configures the probe's support for the network layer and application layer host tables for this protocol. Same as RFC 2021, but for a particular module.")
drSmonProtocolDirMatrixConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("supportedOff", 2), ("supportedOn", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonProtocolDirMatrixConfig.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirMatrixConfig.setDescription("This object describes and configures the probe's support for the network layer and application layer matrix tables for this protocol. Same as RFC 2021, but for a particular module.")
drSmonProtocolDirOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 10), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonProtocolDirOwner.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
drSmonProtocolDirStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 2, 2, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonProtocolDirStatus.setStatus('current')
if mibBuilder.loadTexts: drSmonProtocolDirStatus.setDescription('The status of this protocol directory entry. Same as RFC 2021, but for a particular module.')
drSmonFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 4, 3))
drSmonFilterTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 4, 3, 1), )
if mibBuilder.loadTexts: drSmonFilterTable.setStatus('current')
if mibBuilder.loadTexts: drSmonFilterTable.setDescription('A table containging a set of tables. Each table configure hosts and subnets to explicitly monitor in a particular module. ')
drSmonFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 4, 3, 1, 1), ).setIndexNames((0, "SMON2-MIB", "drSmonFilterModuleID"), (0, "SMON2-MIB", "drSmonFilterIndex"))
if mibBuilder.loadTexts: drSmonFilterEntry.setStatus('current')
if mibBuilder.loadTexts: drSmonFilterEntry.setDescription('A conceptual row in the drSmonFilterTable. Configures a host or subnet to monitor in a particular module, at a particular row or column. Typically, the NMS application conifgures these entries. ')
drSmonFilterModuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: drSmonFilterModuleID.setStatus('current')
if mibBuilder.loadTexts: drSmonFilterModuleID.setDescription('The module group number (=slot number). Used as index.')
drSmonFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: drSmonFilterIndex.setStatus('current')
if mibBuilder.loadTexts: drSmonFilterIndex.setDescription('The index of the particular host/subnet. The index determines the position of the host/subnet in the counter matrix. Example: For a matrix of A rows x B columns and index i: If i<A then host is both on row i and column i else host is on column i.')
drSmonFilterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 3, 1, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonFilterAddress.setStatus('current')
if mibBuilder.loadTexts: drSmonFilterAddress.setDescription('The IP address of a host or subnet to explicitly monitor')
drSmonFilterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 3, 1, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonFilterMask.setStatus('current')
if mibBuilder.loadTexts: drSmonFilterMask.setDescription('The Mask of a host or subnet to explicitly monitor. The value 255.255.255.255 signifies that this entry is a host entry.')
drSmonFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 3, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: drSmonFilterStatus.setStatus('current')
if mibBuilder.loadTexts: drSmonFilterStatus.setDescription('The status of the row, as per SMIv2 (RFC1903). The row is in read-only mode when the status is set to active(1). Only active rows are used as filters.')
drSmonActiveApplications = MibIdentifier((1, 3, 6, 1, 4, 1, 81, 30, 4, 4))
drSmonActiveApplicationsTable = MibTable((1, 3, 6, 1, 4, 1, 81, 30, 4, 4, 1), )
if mibBuilder.loadTexts: drSmonActiveApplicationsTable.setStatus('current')
if mibBuilder.loadTexts: drSmonActiveApplicationsTable.setDescription("This table contain the 'active applications' or protocols from all the protocols the modules can detect. 'Activity' is determined and reported by each module, in a sub-table of this table. The table contain entries only for 'Active' protocols. For each active application, there is a global counter indicates the number of packets in the specific application monitored by a module.")
drSmonActiveApplicationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 81, 30, 4, 4, 1, 1), ).setIndexNames((0, "SMON2-MIB", "drSmonActiveApplicationsModuleID"), (0, "SMON2-MIB", "drSmonActiveApplicationsType"), (0, "SMON2-MIB", "drSmonActiveApplicationsSubType"))
if mibBuilder.loadTexts: drSmonActiveApplicationsEntry.setStatus('current')
if mibBuilder.loadTexts: drSmonActiveApplicationsEntry.setDescription("The entry for the drSmonActiveApplicationsTable. A set of entries exist for each module. For each active application, a global counter indicates the number of packets in the specific application monitored by the module. Entries exist only for 'active' applications.")
drSmonActiveApplicationsModuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: drSmonActiveApplicationsModuleID.setStatus('current')
if mibBuilder.loadTexts: drSmonActiveApplicationsModuleID.setDescription('The module group number (=slot number). Used as index.')
drSmonActiveApplicationsType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethertype", 1), ("ipProtocol", 2), ("udpProtocol", 3), ("tcpProtocol", 4))))
if mibBuilder.loadTexts: drSmonActiveApplicationsType.setStatus('current')
if mibBuilder.loadTexts: drSmonActiveApplicationsType.setDescription('The major type of the application. Note that TCP and UDP are assumed to be over IP. ')
drSmonActiveApplicationsSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 4, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: drSmonActiveApplicationsSubType.setStatus('current')
if mibBuilder.loadTexts: drSmonActiveApplicationsSubType.setDescription("The application's sub-type value depends on the value of the type: Type sub-type value =========== ============== ethertype(1) 1 - Sum of all IP traffic 2 - ARP traffic ipProtocol(2) 1 - ICMP traffic 2 - OSPF traffic 3 - Sum of all UDP traffic 4 - Sum of all TCP traffic 5 - VRRP traffic udpProtocol(3) - The SubType is the UDP port number tcpProtocol(4) - The SubType is the TCP port number ")
drSmonActiveApplicationsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 81, 30, 4, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: drSmonActiveApplicationsPkts.setStatus('current')
if mibBuilder.loadTexts: drSmonActiveApplicationsPkts.setDescription('The number of packets of the specified application monitored by the probe.')
mibBuilder.exportSymbols("SMON2-MIB", xsSubnetMatrixControlOwner=xsSubnetMatrixControlOwner, xsHostTopNProtocolDirLocalIndex=xsHostTopNProtocolDirLocalIndex, xsHostFilterStatus=xsHostFilterStatus, xsSubnetCreateTime=xsSubnetCreateTime, xsSubnetEntry=xsSubnetEntry, xsSubnetMatrixControlTable=xsSubnetMatrixControlTable, xsHostTopNControlDuration=xsHostTopNControlDuration, xsSubnetMatrixControlEntry=xsSubnetMatrixControlEntry, drSmonActiveApplicationsTable=drSmonActiveApplicationsTable, xsSubnetMatrixDSDestAddress=xsSubnetMatrixDSDestAddress, xsSubnetMatrixSDSourceMask=xsSubnetMatrixSDSourceMask, drSmonProtocolDirLocalIndex=drSmonProtocolDirLocalIndex, xsSubnetMatrixDSTimeMark=xsSubnetMatrixDSTimeMark, xsSubnetMatrixSDPkts=xsSubnetMatrixSDPkts, xsHostTopNControlOwner=xsHostTopNControlOwner, xsSubnetMatrixControlDataSource=xsSubnetMatrixControlDataSource, drSmonFilterModuleID=drSmonFilterModuleID, xsSubnetMatrixDSCreateTime=xsSubnetMatrixDSCreateTime, xsSubnetControlInserts=xsSubnetControlInserts, xsSubnetControlEntry=xsSubnetControlEntry, drSmonActiveApplications=drSmonActiveApplications, drSmonEntityPlacementType=drSmonEntityPlacementType, drSmonProtocolDirType=drSmonProtocolDirType, drSmonControlMatrixRows=drSmonControlMatrixRows, xsHostFilterType=xsHostFilterType, drSmonActiveApplicationsType=drSmonActiveApplicationsType, drSmonActiveApplicationsModuleID=drSmonActiveApplicationsModuleID, drSmonProtocolDir=drSmonProtocolDir, xsHostTopNControlRateBase=xsHostTopNControlRateBase, drSmonProtocolDirParameters=drSmonProtocolDirParameters, xsSubnetControlOwner=xsSubnetControlOwner, xsHostTopNIndex=xsHostTopNIndex, drSmonConfiguration=drSmonConfiguration, xsHostTopNControlStatus=xsHostTopNControlStatus, drSmonControlEntry=drSmonControlEntry, xsSubnetControlIndex=xsSubnetControlIndex, xsHostTopNControlTimeRemaining=xsHostTopNControlTimeRemaining, drSmonControlMatrixCols=drSmonControlMatrixCols, xsSubnetMatrixControlStatus=xsSubnetMatrixControlStatus, xsNlHostTimeStamp=xsNlHostTimeStamp, xsSubnetMatrixSDDestAddress=xsSubnetMatrixSDDestAddress, xsSubnetControlStatus=xsSubnetControlStatus, xsActiveApplicationsPkts=xsActiveApplicationsPkts, drSmonProtocolDirHostConfig=drSmonProtocolDirHostConfig, xsSubnetMatrixSDTable=xsSubnetMatrixSDTable, xsSubnetMatrixSDDestMask=xsSubnetMatrixSDDestMask, drSmonProtocolDirAddressMapConfig=drSmonProtocolDirAddressMapConfig, drSmonProtocolDirDescr=drSmonProtocolDirDescr, drSmonControlProtocolDistStatsTimeStamp=drSmonControlProtocolDistStatsTimeStamp, xsActiveApplicationsIndex=xsActiveApplicationsIndex, xsSubnetMatrixDSDestMask=xsSubnetMatrixDSDestMask, drSmonFilterTable=drSmonFilterTable, xsSubnet=xsSubnet, drSmonEntityPlacementModuleID=drSmonEntityPlacementModuleID, drSmonControlTable=drSmonControlTable, drSmonProtocolDirStatus=drSmonProtocolDirStatus, drSmonFilter=drSmonFilter, drSmonFilterStatus=drSmonFilterStatus, xsHostTopNControlGrantedSize=xsHostTopNControlGrantedSize, drSmonEntityPlacementAddress=drSmonEntityPlacementAddress, xsHostTopNControlTable=xsHostTopNControlTable, xsActiveApplications=xsActiveApplications, xsSmonStatus=xsSmonStatus, drSmonEntityPlacementMask=drSmonEntityPlacementMask, drSmonActiveApplicationsSubType=drSmonActiveApplicationsSubType, drSmonEntityPlacementIndex=drSmonEntityPlacementIndex, xsSubnetInPkts=xsSubnetInPkts, drSmonFilterAddress=drSmonFilterAddress, drSmonActiveApplicationsEntry=drSmonActiveApplicationsEntry, drSmonFilterEntry=drSmonFilterEntry, xsHostFilterTableClear=xsHostFilterTableClear, xsHostFilterIpSubnet=xsHostFilterIpSubnet, drSmonProtocolDirModuleID=drSmonProtocolDirModuleID, xsSubnetMatrixControlIndex=xsSubnetMatrixControlIndex, xsSmon=xsSmon, xsFilter=xsFilter, drSmonProtocolDirLCEntry=drSmonProtocolDirLCEntry, xsSubnetMatrixControlMaxDesiredEntries=xsSubnetMatrixControlMaxDesiredEntries, xsSubnetMatrixControlDeletes=xsSubnetMatrixControlDeletes, drSmon=drSmon, drSmonProtocolDirLCTable=drSmonProtocolDirLCTable, drSmonProtocolDirLCModuleID=drSmonProtocolDirLCModuleID, drSmonProtocolDirEntry=drSmonProtocolDirEntry, xsHostTopNControlHostIndex=xsHostTopNControlHostIndex, xsSubnetControlDataSource=xsSubnetControlDataSource, xsSubnetMatrixDSSourceAddress=xsSubnetMatrixDSSourceAddress, drSmonFilterMask=drSmonFilterMask, xsHostTopNControlStartTime=xsHostTopNControlStartTime, xsActiveApplicationsBitMask=xsActiveApplicationsBitMask, xsSubnetStatsTimeStamp=xsSubnetStatsTimeStamp, xsHostTopNRate=xsHostTopNRate, xsSubnetMatrixDSTable=xsSubnetMatrixDSTable, xsHostFilterIpMask=xsHostFilterIpMask, xsHostTopNEntry=xsHostTopNEntry, xsHostFilterEntry=xsHostFilterEntry, drSmonProtocolDirOwner=drSmonProtocolDirOwner, xsSubnetOutPkts=xsSubnetOutPkts, drSmonProtocolDirMatrixConfig=drSmonProtocolDirMatrixConfig, xsHostTopNNlAddress=xsHostTopNNlAddress, xsHostFilterIpxAddress=xsHostFilterIpxAddress, xsSubnetMatrixSDSourceAddress=xsSubnetMatrixSDSourceAddress, xsSubnetControlDeletes=xsSubnetControlDeletes, drSmonControlRoutedPackets=drSmonControlRoutedPackets, drSmonEntityPlacementTable=drSmonEntityPlacementTable, xsActiveApplicationsEntry=xsActiveApplicationsEntry, xsSubnetAddress=xsSubnetAddress, xsHostFilterIpAddress=xsHostFilterIpAddress, xsSmonResourceAllocation=xsSmonResourceAllocation, xsSubnetMatrixSDCreateTime=xsSubnetMatrixSDCreateTime, xsSubnetControlMaxDesiredEntries=xsSubnetControlMaxDesiredEntries, xsHostTopN=xsHostTopN, xsHostFilterTable=xsHostFilterTable, xsSubnetMatrixSDEntry=xsSubnetMatrixSDEntry, xsHostTopNControlIndex=xsHostTopNControlIndex, drSmonProtocolDirTable=drSmonProtocolDirTable, xsSubnetMatrixDSPkts=xsSubnetMatrixDSPkts, drSmonControlModuleID=drSmonControlModuleID, xsSubnetControlTable=xsSubnetControlTable, drSmonFilterIndex=drSmonFilterIndex, xsProtocolDistStatsTimeStamp=xsProtocolDistStatsTimeStamp, xsHostTopNControlEntry=xsHostTopNControlEntry, xsSubnetTable=xsSubnetTable, drSmonControlRowAddressAutoLearnMode=drSmonControlRowAddressAutoLearnMode, xsNumberOfProtocols=xsNumberOfProtocols, xsSubnetMask=xsSubnetMask, drSmonProtocolDirID=drSmonProtocolDirID, xsHostTopNControlRequestedSize=xsHostTopNControlRequestedSize, xsSubnetTimeMark=xsSubnetTimeMark, xsSubnetMatrixDSEntry=xsSubnetMatrixDSEntry, drSmonEntityPlacementEntry=drSmonEntityPlacementEntry, drSmonProtocolDirLCLastChange=drSmonProtocolDirLCLastChange, drSmonActiveApplicationsPkts=drSmonActiveApplicationsPkts, xsSubnetMatrixControlInserts=xsSubnetMatrixControlInserts, xsSubnetMatrixSDTimeMark=xsSubnetMatrixSDTimeMark, xsHostTopNTable=xsHostTopNTable, xsActiveApplicationsTable=xsActiveApplicationsTable, xsSubnetMatrixDSSourceMask=xsSubnetMatrixDSSourceMask)

#
# PySNMP MIB module ZHONE-COM-PPP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZHONE-COM-PPP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:47:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
AtmVpIdentifier, AtmVcIdentifier = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier", "AtmVcIdentifier")
InterfaceIndexOrZero, InterfaceIndex, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, iso, ObjectIdentity, MibIdentifier, Unsigned32, Bits, IpAddress, TimeTicks, Counter32, Counter64, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "iso", "ObjectIdentity", "MibIdentifier", "Unsigned32", "Bits", "IpAddress", "TimeTicks", "Counter32", "Counter64", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
zhoneModules, zhonePpp = mibBuilder.importSymbols("Zhone", "zhoneModules", "zhonePpp")
ZhoneRowStatus, = mibBuilder.importSymbols("Zhone-TC", "ZhoneRowStatus")
comPpp = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 6, 69))
comPpp.setRevisions(('2001-06-06 16:00', '2001-04-19 15:00', '2001-03-20 09:30', '2001-03-12 11:00', '2001-03-01 11:00', '2001-02-08 10:02',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: comPpp.setRevisionsDescriptions(('V01.03.00 - Replaced pppIfLgId with pppIfLowerIfIndex Removed pppIfLinkType. Removed ncpExtRowStatus from pppNCPExtenstionsTable. Modified description of pppAuthPAPPassword and pppAuthCHAPSecret to indicate that empty string will be returned on a GET.', 'V01.02.00 - Added pppAuthenticationTable and added authentication fields to the pppLCPExtensionsTable.', 'V01.01.01 - Fix defaults, change AFFC to ACFC, add isdn link-type.', 'V01.01.00 - Removed ncpExtServProv from pppNCPExtensionsTable. Changed default for ncpExtMaxConfigRetries and ncpExtMaxFailureRetries to 10.', 'V01.00.01 - Changed pppIfVci from Integer32 to AtmVcIdentifier. Changed pppIfRowStatus from Integer32 to zhoneRowStatus.', 'V01.00.00 - Initial Release',))
if mibBuilder.loadTexts: comPpp.setLastUpdated('200106061600Z')
if mibBuilder.loadTexts: comPpp.setOrganization('Zhone Technologies, Inc.')
if mibBuilder.loadTexts: comPpp.setContactInfo(' Postal: Zhone Technologies, Inc. @ Zhone Way 7001 Oakport Street Oakland, CA 94621 USA Toll-Free: +1 877-ZHONE20 (+1 877-946-6320) Tel: +1-510-777-7000 Fax: +1-510-777-7001 E-mail: support@zhone.com')
if mibBuilder.loadTexts: comPpp.setDescription('Point-to-Point Protocol (PPP) MIB IP Software Minneapolis, MN')
class ZhoneAuthenticationProtocol(TextualConvention, Integer32):
    description = 'The protocol used for authentication: PAP - Password Authentication Protocol CHAP - Challenge Handshake Authentication Protocol'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("pap", 1), ("chap", 2))

class EnableFlag(TextualConvention, Integer32):
    description = 'A boolean type used to indicate if a feature is enabled or disabled.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

pppInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1), )
if mibBuilder.loadTexts: pppInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: pppInterfaceTable.setDescription('This table is used to configure attributes of a PPP interface that are not currently covered by the standard MIBs. This table is indexed by the ifIndex of the PPP interface. IANA iftype ppp is #23.')
pppInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pppInterfaceEntry.setReference('See pppLCPExtensionsEntry in this MIB module and pppLinkConfigTable and pppLqrConfigTable in rfc1471.mib.')
if mibBuilder.loadTexts: pppInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: pppInterfaceEntry.setDescription('There is an entry in this table for every provisioned PPP interface. Rows are created by setting pppIfRowStatus to createAndGo(4). Rows are removed by setting pppIfRowStatus to destroy(6). When a row is created or deleted in this table, a row is also created or deleted in the pppLCPExtensionsTable in this MIB module and the pppLinkConfigTable and pppLqrConfigTable in RFC 1471. An entry will also be created/destroyed in the ifTable (RFC2233). The pppIfLowerIfIndex is required for row creation.')
pppIfLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1, 1, 1), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppIfLowerIfIndex.setReference('see rfc2233.mib: ifStackTable')
if mibBuilder.loadTexts: pppIfLowerIfIndex.setStatus('current')
if mibBuilder.loadTexts: pppIfLowerIfIndex.setDescription('The ifIndex of the lower layer interface to which this PPP interface should be bound. Since PPP interfaces are always statically bound, this value can never be zero. Upon setting this field, the ifStack will be modified to reflect the appropriate binding. This object is required for row creation. ')
pppIfVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1, 1, 2), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppIfVpi.setReference('See rfc2515.mib: atmInterfaceMaxActiveVpiBits')
if mibBuilder.loadTexts: pppIfVpi.setStatus('current')
if mibBuilder.loadTexts: pppIfVpi.setDescription('If this IP interface is on an ATM VC, the ATM VPI is specified here. If the IP interface is not an ATM VC, this field is ignored. The VPI value for a VPL or VCL. The value VPI=0 is only allowed for a VCL. For ATM UNIs supporting VPCs the VPI value ranges from 0 to 255. The VPI value 0 is supported for ATM UNIs conforming to the ATM Forum UNI 4.0 Annex 8 (Virtual UNIs) specification. For ATM UNIs supporting VCCs the VPI value ranges from 0 to 255. For ATM NNIs the VPI value ranges from 0 to 4095. The maximum VPI value cannot exceed the value allowable by atmInterfaceMaxActiveVpiBits defined in ATM-MIB.')
pppIfVci = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1, 1, 3), AtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppIfVci.setReference('See rfc2515.mib: atmInterfaceMaxActiveVciBits')
if mibBuilder.loadTexts: pppIfVci.setStatus('current')
if mibBuilder.loadTexts: pppIfVci.setDescription('If this PPP interface is on an ATM VC, the ATM VCI is specified here. If the PPP interface is not an ATM VC, this field is ignored. The maximum VCI value cannot exceed the value allowable by atmInterfaceMaxActiveVciBits defined in ATM-MIB.')
pppIfCallMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noCall", 1), ("inCall", 2), ("outCall", 3))).clone('noCall')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppIfCallMode.setStatus('current')
if mibBuilder.loadTexts: pppIfCallMode.setDescription('Indicates where the PPP call is initiated. noCall: No call is initiated inCall: Call is intiated remotely. outCall: Call is intiated locally.')
pppIfFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("frameRelay", 2), ("atmLLC", 3), ("atmVc", 4))).clone('atmLLC')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppIfFrameType.setStatus('current')
if mibBuilder.loadTexts: pppIfFrameType.setDescription('The type of framing used if the link type is ATM or Frame Relay. If link type is atm, pppIfFrameType must be atmLLC or atmVc. If link type is frameRelay, pppIfFrameType must be frameRelay. If link type is any other value, pppIfFrameType must be none. Currently, only atmLLC and atmVC are supported.')
pppIfNumChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppIfNumChannels.setStatus('current')
if mibBuilder.loadTexts: pppIfNumChannels.setDescription('The maximum number of channels allowed on this interface. Currently, only one channel is supported.')
pppIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 1, 1, 7), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: pppIfRowStatus.setDescription('Zhone convention to support row creation and deletion. pppIfLgId is required to create or destroy a row in this table.')
pppLCPExtensionsTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2), )
if mibBuilder.loadTexts: pppLCPExtensionsTable.setStatus('current')
if mibBuilder.loadTexts: pppLCPExtensionsTable.setDescription('This table is used to configure attributes not found in the pppLinkConfigTable defined in RFC 1471. This table is indexed by the ifIndex of the PPP interface to which these LCP attributes apply.')
pppLCPExtensionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1), )
if mibBuilder.loadTexts: pppLCPExtensionsEntry.setReference('See pppInterfaceTable in this MIB module.')
pppInterfaceEntry.registerAugmentions(("ZHONE-COM-PPP-MIB", "pppLCPExtensionsEntry"))
pppLCPExtensionsEntry.setIndexNames(*pppInterfaceEntry.getIndexNames())
if mibBuilder.loadTexts: pppLCPExtensionsEntry.setStatus('current')
if mibBuilder.loadTexts: pppLCPExtensionsEntry.setDescription('There is an entry in this table for every provisioned PPP interface. Rows in this table are created or deleted when a row in the pppInterfaceTable is created or deleted using pppIfRowStatus. Therefore, objects in this table cannot be set in the same SNMP PDU as the objects used to create a row in the pppInterfaceTable.')
lcpExtReceiveAuthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 1), EnableFlag().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtReceiveAuthEnable.setReference("From RFC 1661: 'This Configuration Option provides a method to negotiate the use of a specific protocol for authentication.'")
if mibBuilder.loadTexts: lcpExtReceiveAuthEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtReceiveAuthEnable.setDescription('Enable or disable incoming authentication.')
lcpExtReceiveAuthProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 2), ZhoneAuthenticationProtocol().clone('pap')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtReceiveAuthProtocol.setStatus('current')
if mibBuilder.loadTexts: lcpExtReceiveAuthProtocol.setDescription('The preferred protocol used for incoming authentication. If lcpExtReceiveAuthEnable is enabled, the authentication protocol will be negotiated with the peer.')
lcpExtSendAuthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 3), EnableFlag().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtSendAuthEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtSendAuthEnable.setDescription('Enable or disable outgoing authentication.')
lcpExtSendAuthProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 4), ZhoneAuthenticationProtocol().clone('pap')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtSendAuthProtocol.setStatus('current')
if mibBuilder.loadTexts: lcpExtSendAuthProtocol.setDescription('The protocol used with lcpExtSendAuthIdentity to look up the outgoing authentication information.')
lcpExtSendAuthIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtSendAuthIdentity.setStatus('current')
if mibBuilder.loadTexts: lcpExtSendAuthIdentity.setDescription('The identity (PAP peer ID or CHAP name) used with lcpExtSendAuthProtocol to look up the outgoing authentication information. Default value is the empty string.')
lcpExtQualityProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("lqr", 1))).clone('lqr')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtQualityProtocol.setReference("See rfc1471.mib: pppLqrConfigStatus From RFC 1661: 'This Configuration Option provides a method to negotiate the use of a specific protocol for link quality monitoring.'")
if mibBuilder.loadTexts: lcpExtQualityProtocol.setStatus('current')
if mibBuilder.loadTexts: lcpExtQualityProtocol.setDescription('The Quality Protocol used. Currently, the only valid quality protocl is LQR. Quality protocol must be enabled using pppLqrConfigStatus in RFC1471.')
lcpExtMagicNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtMagicNumber.setReference("See rfc1471.mib: pppLinkConfigMagicNumber From RFC 1661: 'This Configuration Option provides a method to detect looped-back links and other Data Link Layer anomalies. This Configuration Option MAY be required by some other Configuration Options such as the Quality-Protocol Configuration Option. By default, the Magic-Number is not negotiated, and zero is inserted where a Magic-Number might otherwise be used.'")
if mibBuilder.loadTexts: lcpExtMagicNumber.setStatus('current')
if mibBuilder.loadTexts: lcpExtMagicNumber.setDescription('The number used in Magic Number negotiation. Magic number negotiation must be enabled using pppLinkConfigMagicNumber in RFC1471. When set to zero, a random number will be used for the magic number. This allows us to better prevent having two devices with the same magic number.')
lcpExtMaxPad = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtMaxPad.setReference('See Self-Describing Padding in RFC 1570.')
if mibBuilder.loadTexts: lcpExtMaxPad.setStatus('current')
if mibBuilder.loadTexts: lcpExtMaxPad.setDescription('The number of padded bytes at the end of data. This is used for Self-Describing Padding, a method for placing unambiguous padding octets at the end of the PPP Information field in order to cause messages to fall on a natural boundary.')
lcpExtCallbackEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 9), EnableFlag().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtCallbackEnable.setReference("From RFC 1570: 'This Configuration Option provides a method for an implementation to request a dial-up peer to call back.'")
if mibBuilder.loadTexts: lcpExtCallbackEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtCallbackEnable.setDescription('Enable or disable Callback negotiation. ')
lcpExtCallbackType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("byAuth", 1), ("byDialStr", 2), ("byIdentifier", 3), ("byE164", 4), ("byName", 5))).clone('byAuth')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtCallbackType.setStatus('current')
if mibBuilder.loadTexts: lcpExtCallbackType.setDescription('The method of determining the location to callback. byAuth: Location is determined by authorization information. byDialString: Location is determined by a dialing string. byIdentifier: Location is determined by a location ID. byE164: Location is determined by an E.164 number. byName: Location is determined by a distinguished name. These objects only apply when callback negotiation is enabled using lcpExtCallbackEnable.')
lcpExtCallbackDialString = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtCallbackDialString.setStatus('current')
if mibBuilder.loadTexts: lcpExtCallbackDialString.setDescription('The dialing string used for a callback. The format of this string is determined by lcpExtCallbackType. This object only applies when callback negotiation is enabled using lcpExtCallbackEnable. Default value is the empty string.')
lcpExtRestartTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtRestartTimer.setStatus('current')
if mibBuilder.loadTexts: lcpExtRestartTimer.setDescription('Number of seconds before retransmission of an LCP packet.')
lcpExtMaxConfigRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtMaxConfigRetries.setStatus('current')
if mibBuilder.loadTexts: lcpExtMaxConfigRetries.setDescription('Number of LCP configuration retries without response before the link is brought down.')
lcpExtMaxTerminateRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtMaxTerminateRetries.setStatus('current')
if mibBuilder.loadTexts: lcpExtMaxTerminateRetries.setDescription('Number of LCP termination retries without response before the link is brought down.')
lcpExtMaxFailureRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtMaxFailureRetries.setStatus('current')
if mibBuilder.loadTexts: lcpExtMaxFailureRetries.setDescription('Number of times a Configuration Nak is sent before a Configuration Rej is sent.')
lcpExtMRUEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 16), EnableFlag().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtMRUEnable.setReference("From RFC 1661: 'This Configuration Option may be sent to inform the peer that the implementation can receive larger packets, or to request that the peer send smaller packets.'")
if mibBuilder.loadTexts: lcpExtMRUEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtMRUEnable.setDescription('Enable or disable MRU negotiation.')
lcpExtACCMEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 17), EnableFlag().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtACCMEnable.setReference("From RFC 1548: 'This Configuration Option provides a method to negotiate the use of control character transparency on asynchronous links.'")
if mibBuilder.loadTexts: lcpExtACCMEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtACCMEnable.setDescription('Enable or disable Asynchronous Control Character Map negotiation.')
lcpExtPFCEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 18), EnableFlag().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtPFCEnable.setReference("From RFC 1661: 'This Configuration Option provides a method to negotiate the compression of the PPP Protocol field.'")
if mibBuilder.loadTexts: lcpExtPFCEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtPFCEnable.setDescription('Enable or disable Protocol Field Compression negotiation.')
lcpExtACFCEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 19), EnableFlag().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtACFCEnable.setReference("From RFC 1661: 'This Configuration Option provides a method to negotiate the compression of the Data Link Layer Address and Control fields.'")
if mibBuilder.loadTexts: lcpExtACFCEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtACFCEnable.setDescription('Enable or disable Address and Control Field Compression negotiation.')
lcpExtFCSAltEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 20), EnableFlag().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtFCSAltEnable.setReference("From RFC 1570: 'This Configuration Option provides a method for an implementation to specify another FCS format to be sent by the peer, or to negotiate away the FCS altogether.'")
if mibBuilder.loadTexts: lcpExtFCSAltEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtFCSAltEnable.setDescription('Enable or disable FCS Alternative negotiation. The negotiated FCS values take effect only during Authentication and Network-Layer Protocol phases.')
lcpExtSDPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 21), EnableFlag().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtSDPEnable.setReference("From RFC 1570: 'This Configuration Option provides a method for an implementation to indicate to the peer that it understands self-describing pads when padding is added at the end of the PPP Information field.'")
if mibBuilder.loadTexts: lcpExtSDPEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtSDPEnable.setDescription('Enable or disable Self-Describing Padding negotiation.')
lcpExtNumModeEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 2, 1, 22), EnableFlag().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: lcpExtNumModeEnable.setReference("From RFC 1663: 'The LCP Numbered-Mode Configuration Option negotiates the use of Numbered-Mode on the link. By default or ultimate disagreement, Unnumbered-Mode is used.'")
if mibBuilder.loadTexts: lcpExtNumModeEnable.setStatus('current')
if mibBuilder.loadTexts: lcpExtNumModeEnable.setDescription('Enable or disable Numbered Mode negotiation.')
pppNCPExtensionsTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3), )
if mibBuilder.loadTexts: pppNCPExtensionsTable.setStatus('current')
if mibBuilder.loadTexts: pppNCPExtensionsTable.setDescription('This table is used to configure attributes not found in the pppIpConfigTable defined in RFC 1473. This table is indexed by the ifIndex of the network (IP) interface to which these NCP attributes apply.')
pppNCPExtensionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pppNCPExtensionsEntry.setReference('See rfc1473.mib: pppIpConfigTable See comIpRec.mib: ipInterfaceTable ')
if mibBuilder.loadTexts: pppNCPExtensionsEntry.setStatus('current')
if mibBuilder.loadTexts: pppNCPExtensionsEntry.setDescription("A row must be created in this table when an IP over PPP interface is provisioned. Rows are created by setting ipIfPppEnabled in the ipInterfaceTable to 'true'. Rows are deleted by setting ipIfPppEnabled in the ipInterfaceTable to 'false'. Creating or deleting a row in this table will do the same in the pppIpConfigTable in rfc1473.mib.")
ncpExtVJCompMaxSlotID = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 16)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ncpExtVJCompMaxSlotID.setStatus('current')
if mibBuilder.loadTexts: ncpExtVJCompMaxSlotID.setDescription('The maximum slot ID for Van Jacobson Header Compression.')
ncpExtVJCompSlotID = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3, 1, 2), EnableFlag().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ncpExtVJCompSlotID.setStatus('current')
if mibBuilder.loadTexts: ncpExtVJCompSlotID.setDescription('Indicates whether the slot identifier field may be compressed: disabled: The slot identifier must not be compressed. All compressed TCP packets must set the C bit in every change mask, and must include the slot identifier. enabled: The slot identifier may be compressed.')
ncpExtIpAddrOptionEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3, 1, 3), EnableFlag().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ncpExtIpAddrOptionEnable.setStatus('current')
if mibBuilder.loadTexts: ncpExtIpAddrOptionEnable.setDescription('Enable or disable IP Address Negotiation.')
ncpExtRestartTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(3)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ncpExtRestartTimer.setStatus('current')
if mibBuilder.loadTexts: ncpExtRestartTimer.setDescription('Number of seconds before retransmission of an IP packet.')
ncpExtMaxConfigRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ncpExtMaxConfigRetries.setStatus('current')
if mibBuilder.loadTexts: ncpExtMaxConfigRetries.setDescription('Number of IP configuration retries without response before the session is brought down.')
ncpExtMaxTerminateRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ncpExtMaxTerminateRetries.setStatus('current')
if mibBuilder.loadTexts: ncpExtMaxTerminateRetries.setDescription('Number of IP termination retries without response before the session is brought down.')
ncpExtFailureRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ncpExtFailureRetries.setStatus('current')
if mibBuilder.loadTexts: ncpExtFailureRetries.setDescription('Number of times a Configuration Nak is sent before a Configuration Rej is sent')
pppNextAuthId = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppNextAuthId.setStatus('current')
if mibBuilder.loadTexts: pppNextAuthId.setDescription('A GET of this object will return the next available pppAuthId to be used when creating an entry in the pppAuthenticationTable. A GET-NEXT of this object will return the last number given out.')
pppAuthenticationTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5), )
if mibBuilder.loadTexts: pppAuthenticationTable.setStatus('current')
if mibBuilder.loadTexts: pppAuthenticationTable.setDescription('This table contains provisioning for incoming and/or outgoing PPP authentication.')
pppAuthenticationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1), ).setIndexNames((0, "ZHONE-COM-PPP-MIB", "pppAuthSubId"), (0, "ZHONE-COM-PPP-MIB", "pppAuthId"))
if mibBuilder.loadTexts: pppAuthenticationEntry.setStatus('current')
if mibBuilder.loadTexts: pppAuthenticationEntry.setDescription('An entry exists in the pppAuthenticationTable for each set of data used for PPP authentication. A set of PPP authentication data can be used for incoming authentication, outgoing authentication or both. A row can be created/deleted using pppAuthRowStatus. The next available pppAuthId value can be obtained using pppNextAuthId.')
pppAuthSubId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: pppAuthSubId.setStatus('current')
if mibBuilder.loadTexts: pppAuthSubId.setDescription('The unique identifier of the subscriber associated with this authentication entry. A single subscriber may have multiple authenticated users. If this entry is only used for outgoing authentication, there may not be an associated subscriber. Therefore, the subId may be zero.')
pppAuthId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pppAuthId.setStatus('current')
if mibBuilder.loadTexts: pppAuthId.setDescription('A unique number used to identify this authentication entry.')
pppAuthIpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthIpIfIndex.setStatus('current')
if mibBuilder.loadTexts: pppAuthIpIfIndex.setDescription('The ifIndex of the IP record associated with this set of PPP authentication data. If this entry is to be used for incoming authentication, this object must be set to a non-zero value.')
pppAuthLgId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 4), InterfaceIndexOrZero().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthLgId.setStatus('current')
if mibBuilder.loadTexts: pppAuthLgId.setDescription('The unique identifier of the line group on which this authentication data is allowed to be used. If the value is zero, this authentication data can be used on any line group.')
pppAuthProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 5), Bits().clone(namedValues=NamedValues(("pap", 0), ("chap", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthProtocol.setStatus('current')
if mibBuilder.loadTexts: pppAuthProtocol.setDescription('The protocol used for authentication: PAP - Password Authentication Protocol CHAP - Challenge Handshake Authentication Protocol A bit is set for each authentication protocol that is enabled. All protocols are disabled by default.')
pppAuthPAPPeerID = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthPAPPeerID.setStatus('current')
if mibBuilder.loadTexts: pppAuthPAPPeerID.setDescription('The username used if we are authenticating with the PAP protocol. Default value is the empty string.')
pppAuthPAPPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthPAPPassword.setStatus('current')
if mibBuilder.loadTexts: pppAuthPAPPassword.setDescription('The password used if we are authenticating with the PAP protocol. Default value is the empty string. For security, an empty string will be returned on a GET.')
pppAuthCHAPName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthCHAPName.setStatus('current')
if mibBuilder.loadTexts: pppAuthCHAPName.setDescription('The username used if we are authenticating with the CHAP protocol. Default value is the empty string.')
pppAuthCHAPSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthCHAPSecret.setStatus('current')
if mibBuilder.loadTexts: pppAuthCHAPSecret.setDescription('The password used if we are authenticating with the CHAP protocol. Default value is the empty string. For security, an empty string will be returned on a GET.')
pppAuthStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2))).clone('valid')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthStatus.setStatus('current')
if mibBuilder.loadTexts: pppAuthStatus.setDescription("Setting this object to 'invalid' causes the information for that entry to become invalidated. Calls using the authentication information from an invalidated entry will not be accepted or initiated. This allows an entry to be temporarily disabled without deleting it from the table.")
pppAuthRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 5, 5, 1, 12), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pppAuthRowStatus.setStatus('current')
if mibBuilder.loadTexts: pppAuthRowStatus.setDescription("This object is used to create or delete an entry in the table. Setting this object to 'createAndGo' will cause an entry to be created. Setting this object to 'destroy' will cause an entry to be deleted. Objects required for creating an entry are specified in the pppAuthenticationEntry description.")
mibBuilder.exportSymbols("ZHONE-COM-PPP-MIB", pppIfCallMode=pppIfCallMode, lcpExtMaxPad=lcpExtMaxPad, lcpExtACCMEnable=lcpExtACCMEnable, lcpExtMagicNumber=lcpExtMagicNumber, lcpExtCallbackType=lcpExtCallbackType, lcpExtSDPEnable=lcpExtSDPEnable, pppAuthRowStatus=pppAuthRowStatus, lcpExtCallbackDialString=lcpExtCallbackDialString, ncpExtMaxTerminateRetries=ncpExtMaxTerminateRetries, lcpExtMaxTerminateRetries=lcpExtMaxTerminateRetries, lcpExtReceiveAuthEnable=lcpExtReceiveAuthEnable, pppIfVpi=pppIfVpi, pppAuthenticationEntry=pppAuthenticationEntry, pppAuthSubId=pppAuthSubId, pppAuthenticationTable=pppAuthenticationTable, ncpExtMaxConfigRetries=ncpExtMaxConfigRetries, pppAuthId=pppAuthId, ZhoneAuthenticationProtocol=ZhoneAuthenticationProtocol, pppAuthCHAPName=pppAuthCHAPName, pppIfNumChannels=pppIfNumChannels, ncpExtVJCompMaxSlotID=ncpExtVJCompMaxSlotID, ncpExtFailureRetries=ncpExtFailureRetries, comPpp=comPpp, lcpExtRestartTimer=lcpExtRestartTimer, pppAuthPAPPeerID=pppAuthPAPPeerID, pppAuthStatus=pppAuthStatus, lcpExtReceiveAuthProtocol=lcpExtReceiveAuthProtocol, pppIfLowerIfIndex=pppIfLowerIfIndex, PYSNMP_MODULE_ID=comPpp, lcpExtNumModeEnable=lcpExtNumModeEnable, pppIfRowStatus=pppIfRowStatus, lcpExtCallbackEnable=lcpExtCallbackEnable, pppAuthIpIfIndex=pppAuthIpIfIndex, pppAuthProtocol=pppAuthProtocol, lcpExtACFCEnable=lcpExtACFCEnable, lcpExtMRUEnable=lcpExtMRUEnable, lcpExtSendAuthProtocol=lcpExtSendAuthProtocol, pppAuthLgId=pppAuthLgId, pppInterfaceTable=pppInterfaceTable, pppLCPExtensionsTable=pppLCPExtensionsTable, ncpExtVJCompSlotID=ncpExtVJCompSlotID, EnableFlag=EnableFlag, lcpExtFCSAltEnable=lcpExtFCSAltEnable, ncpExtIpAddrOptionEnable=ncpExtIpAddrOptionEnable, ncpExtRestartTimer=ncpExtRestartTimer, lcpExtQualityProtocol=lcpExtQualityProtocol, pppIfVci=pppIfVci, lcpExtMaxFailureRetries=lcpExtMaxFailureRetries, lcpExtSendAuthIdentity=lcpExtSendAuthIdentity, pppNCPExtensionsTable=pppNCPExtensionsTable, pppNCPExtensionsEntry=pppNCPExtensionsEntry, lcpExtPFCEnable=lcpExtPFCEnable, pppAuthPAPPassword=pppAuthPAPPassword, pppInterfaceEntry=pppInterfaceEntry, pppAuthCHAPSecret=pppAuthCHAPSecret, pppIfFrameType=pppIfFrameType, lcpExtSendAuthEnable=lcpExtSendAuthEnable, lcpExtMaxConfigRetries=lcpExtMaxConfigRetries, pppLCPExtensionsEntry=pppLCPExtensionsEntry, pppNextAuthId=pppNextAuthId)

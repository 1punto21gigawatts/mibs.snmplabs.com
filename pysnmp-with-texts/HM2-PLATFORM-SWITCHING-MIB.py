#
# PySNMP MIB module HM2-PLATFORM-SWITCHING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-PLATFORM-SWITCHING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:32:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
dot1dBasePortEntry, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePortEntry")
hm2PlatformMibs, HmEnabledStatus = mibBuilder.importSymbols("HM2-TC-MIB", "hm2PlatformMibs", "HmEnabledStatus")
ifIndex, InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero", "InterfaceIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
dot1dPortGmrpEntry, = mibBuilder.importSymbols("P-BRIDGE-MIB", "dot1dPortGmrpEntry")
VlanIndex, dot1qFdbId, VlanId, PortList, dot1qVlanIndex, dot1qPortVlanEntry = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanIndex", "dot1qFdbId", "VlanId", "PortList", "dot1qVlanIndex", "dot1qPortVlanEntry")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, Counter32, NotificationType, iso, ModuleIdentity, Integer32, Counter64, Bits, MibIdentifier, TimeTicks, Unsigned32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Counter32", "NotificationType", "iso", "ModuleIdentity", "Integer32", "Counter64", "Bits", "MibIdentifier", "TimeTicks", "Unsigned32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress")
TruthValue, TextualConvention, DisplayString, RowStatus, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString", "RowStatus", "MacAddress")
hm2PlatformSwitching = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1))
hm2PlatformSwitching.setRevisions(('2011-04-12 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2PlatformSwitching.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hm2PlatformSwitching.setLastUpdated('201104120000Z')
if mibBuilder.loadTexts: hm2PlatformSwitching.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2PlatformSwitching.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2PlatformSwitching.setDescription('The Hirschmann Private Platform2 MIB for Layer2 Switching. Copyright (C) 2011. All Rights Reserved.')
class Hm2AgentPortMask(TextualConvention, OctetString):
    description = "Each octet within this value specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports, the port is not included if its bit has a value of '0'. When setting this value, the system will ignore configuration for ports not between the first and last valid ports. Configuration of any port numbers between this range that are not valid ports return a failure message, but will still apply configuration for valid ports."
    status = 'current'

class LagList(TextualConvention, OctetString):
    description = "Each octet within this value specifies a set of eight LAGs, with the first octet specifying LAG 1 through 8, the second octet specifying LAG 9 through 16, etc. Within each octet, the most significant bit represents LAG1, and the least significant bit represents LAGn. Thus, each LAG of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that LAG is configured; the LAG is not configured if its bit has a value of '0'."
    status = 'current'

class VlanList(TextualConvention, OctetString):
    description = "Each octet within this value specifies a set of eight vlans, with the first octet specifying vlans 1 through 8, the second octet specifying vlans 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered vlan, and the least significant bit represents the highest numbered vlan. Thus, each vlan supported is represented by a single bit within the value of this object. If that bit has a value of '1' then the associated port is in that VLAN, the port is not included if the vlans bit has a value of '0'."
    status = 'current'

class Ipv6Address(TextualConvention, OctetString):
    description = 'This data type is used to model IPv6 addresses. This is a binary string of 16 octets in network byte order.'
    status = 'current'
    displayHint = '2x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(16, 16)
    fixedLength = 16

class Ipv6AddressPrefix(TextualConvention, OctetString):
    description = 'This data type is used to model IPv6 address prefixes. This is a binary string of up to 16 octets in network byte order.'
    status = 'current'
    displayHint = '2x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 16)

class Ipv6AddressIfIdentifier(TextualConvention, OctetString):
    description = 'This data type is used to model IPv6 address interface identifiers. This is a binary string of up to 8 octets in network byte order.'
    status = 'current'
    displayHint = '2x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 8)

class Ipv6IfIndex(TextualConvention, Integer32):
    description = "A unique value, greater than zero for each internetwork layer interface in the managed system. It is recommended that values are assigned contiguously starting from 1. The value for each internetwork layer interface must remain constant at least from one reinitialization of the entity's network management system to the next reinitialization."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class Ipv6IfIndexOrZero(TextualConvention, Integer32):
    description = 'This textual convention is an extension of the Ipv6IfIndex convention. The latter defines a greater than zero value used to identify an IPv6 interface in the managed system. This extension permits the additional value of zero. The value zero is object specific and must therefore be defined as part of the description of any object which uses this syntax. Examples of the usage of zero might include situations where the interface was unknown, or when none or all interfaces need to be referenced.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

hm2AgentConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2))
hm2AgentLagConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2))
hm2AgentLagConfigCreate = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 1), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(1, 15), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentLagConfigCreate.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagConfigCreate.setDescription('Agent LAG Create. When this object is set with a non-empty string with the format lag/<port>, a new LAG will be created if possible, with the entered string as its index. Get operation on this MIB object returns a null-value, as for the purpose of viewing the LAG index and details, the user should perform the traversal of hm2AgentLagSummaryConfigTable. For this reason the get operation on this object hm2AgentLagConfigCreate becomes insignificant. ')
hm2AgentLagSummaryConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2), )
if mibBuilder.loadTexts: hm2AgentLagSummaryConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryConfigTable.setDescription("A summary table of the switch's LAG config entries")
hm2AgentLagSummaryConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentLagSummaryLagIndex"))
if mibBuilder.loadTexts: hm2AgentLagSummaryConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryConfigEntry.setDescription("Switch's LAG config entry")
hm2AgentLagSummaryLagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagSummaryLagIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryLagIndex.setDescription('Agent LAG IfIndex. This value corresponds with the LAG interface in the ifTable.')
hm2AgentLagSummaryName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryName.setDescription('Agent LAG Name. The associated name of the LAG used during creation.')
hm2AgentLagSummaryFlushTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryFlushTimer.setStatus('obsolete')
if mibBuilder.loadTexts: hm2AgentLagSummaryFlushTimer.setDescription('Agent LAG FlushTimer.')
hm2AgentLagSummaryLinkTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 4), HmEnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryLinkTrap.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryLinkTrap.setDescription('Agent LAG LinkTrap. Configures sending Link Up/Down traps when the LAG interface goes Up or Down.')
hm2AgentLagSummaryAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 5), HmEnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryAdminMode.setDescription('Agent LAG AdminMode. Administratively enables or disables this LAG interface.')
hm2AgentLagSummaryStpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 6), HmEnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryStpMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryStpMode.setDescription('Agent LAG StpMode Administratively enables or disables STP on this interface.')
hm2AgentLagSummaryAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryAddPort.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryAddPort.setDescription('Agent LAG AddPort. Set to a non 0 value to add a port to the LAG. Values correspond to ifIndex values in the ifTable. Note: agentPortType for the port to be added must be full duplex and the same speed as previously added port(s), if any.')
hm2AgentLagSummaryDeletePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryDeletePort.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryDeletePort.setDescription('Agent LAG DeletePort. Set to a non 0 value to remove a port from the LAG. Values correspond to ifIndex values in the ifTable.')
hm2AgentLagSummaryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryStatus.setDescription('Agent LAG Status. active(1) - This LAG is enabled. destroy(6) - Set to this value to remove the LAG.')
hm2AgentLagSummaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagSummaryType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryType.setDescription('Agent LAG Type. static(1) - This LAG is staticly maintained. dynamic(2) - This LAG is dynamicly maintained.')
hm2AgentLagSummaryStaticCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 11), HmEnabledStatus().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryStaticCapability.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryStaticCapability.setDescription('Agent LAG Static Capability enable(1) - Static capability is enabled for this LAG interface disable(2) - Static capability is disabled for this LAG interface')
hm2AgentLagSummaryHashOption = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("sourceMacVlan", 1), ("destMacVlan", 2), ("sourceDestMacVlan", 3), ("sourceIPsourcePort", 4), ("destIPdestPort", 5), ("sourceDestIPPort", 6), ("enhanced", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryHashOption.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryHashOption.setDescription('LAG Hashing Option. Valid values correspond to 1 (=Source MAC, VLAN, EtherType, and incoming port associated with the packet) 2 (=Destination MAC, VLAN, EtherType, and incoming port associated with the packet) 3 (=Source/Destination MAC, VLAN, EtherType, and incoming port associated with the packet) 4 (=Source IP and Source TCP/UDP fields of the packet) 5 (=Destination IP and Destination TCP/UDP Port fields of the packet) 6 (=Source/Destination IP and source/destination TCP/UDP Port fields of the packet) 7 (=Enhanced hashing mode) Support for particular options may vary by device.')
hm2AgentLagSummaryMinimumActiveLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryMinimumActiveLinks.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryMinimumActiveLinks.setDescription(' Agent LAG Threshold. This configures the threshold(i.e minimum number of active ports) value for trunk port .')
hm2AgentLagSummaryMaxFrameSizeLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 248), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagSummaryMaxFrameSizeLimit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryMaxFrameSizeLimit.setDescription('This object identifies the largest value that can be configured for hm2AgentLagSummaryMaxFrameSize.')
hm2AgentLagSummaryMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 2, 1, 249), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentLagSummaryMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagSummaryMaxFrameSize.setDescription('This object identifies the currently configured maximum frame size value for this port. The maximum value that this object can be set to is the value of hm2AgentLagSummaryMaxFrameSizeLimit. For Ethernet ports which support 802.1Q vlan tagging, the minimum value that this object can be set to is 1522')
hm2AgentLagDetailedConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 3), )
if mibBuilder.loadTexts: hm2AgentLagDetailedConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagDetailedConfigTable.setDescription("A detailed table of the switch's LAG config entries")
hm2AgentLagDetailedConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 3, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentLagDetailedLagIndex"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentLagDetailedIfIndex"))
if mibBuilder.loadTexts: hm2AgentLagDetailedConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagDetailedConfigEntry.setDescription("Switch's LAG config entry")
hm2AgentLagDetailedLagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagDetailedLagIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagDetailedLagIndex.setDescription('LAG index')
hm2AgentLagDetailedIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagDetailedIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagDetailedIfIndex.setDescription('LAG port index')
hm2AgentLagDetailedPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagDetailedPortSpeed.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagDetailedPortSpeed.setDescription('LAG port speed. See agentPortType for a description and list of valid values.')
hm2AgentLagDetailedPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagDetailedPortStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagDetailedPortStatus.setDescription('LAG port status. active(1) - Actively participating in the LAG. inactive(2) - Not participating in the LAG.')
hm2AgentLagConfigStaticCapability = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 4), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentLagConfigStaticCapability.setStatus('obsolete')
if mibBuilder.loadTexts: hm2AgentLagConfigStaticCapability.setDescription('Agent LAG Static Capability. Configures whether Static LAGs are supported on this device.')
hm2AgentLagConfigGroupHashOption = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("sourceMacVlan", 1), ("destMacVlan", 2), ("sourceDestMacVlan", 3), ("sourceIPsourcePort", 4), ("destIPdestPort", 5), ("sourceDestIPPort", 6), ("enhanced", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentLagConfigGroupHashOption.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagConfigGroupHashOption.setDescription('LAG Hashing Option. Valid values correspond to 1 (=Source MAC, VLAN, EtherType, and incoming port associated with the packet) 2 (=Destination MAC, VLAN, EtherType, and incoming port associated with the packet) 3 (=Source/Destination MAC, VLAN, EtherType, and incoming port associated with the packet) 4 (=Source IP and Source TCP/UDP fields of the packet) 5 (=Destination IP and Destination TCP/UDP Port fields of the packet) 6 (=Source/Destination IP and source/destination TCP/UDP Port fields of the packet) 7 (=Enhanced hashing mode) Support for particular options may vary by device.')
hm2AgentLagConfigGroupMaxNumPortsPerLag = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 248), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagConfigGroupMaxNumPortsPerLag.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagConfigGroupMaxNumPortsPerLag.setDescription('The maximum number of ports per LAG supported on this device.')
hm2AgentLagConfigGroupMaxNumOfLags = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 249), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagConfigGroupMaxNumOfLags.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagConfigGroupMaxNumOfLags.setDescription('The maximum number of LAGs this device supports.')
hm2AgentLagConfigGroupNumOfLagsConfigured = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 250), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagConfigGroupNumOfLagsConfigured.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagConfigGroupNumOfLagsConfigured.setDescription('The number of LAGs currently configured on this device.')
hm2AgentLagConfigGroupLagsConfigured = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 251), LagList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentLagConfigGroupLagsConfigured.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagConfigGroupLagsConfigured.setDescription('The LAGs currently configured on the device.')
hm2AgentLagConfigSNMPExtensionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 260))
hm2AgentLagConfigGroupPortIsLagMemberErrorReturn = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 260, 1))
if mibBuilder.loadTexts: hm2AgentLagConfigGroupPortIsLagMemberErrorReturn.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagConfigGroupPortIsLagMemberErrorReturn.setDescription('Indicates that the port is unavailable for current setting because it is a LAG member.')
hm2AgentLagMirrorProbePortLagMemberErrorReturn = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 2, 260, 2))
if mibBuilder.loadTexts: hm2AgentLagMirrorProbePortLagMemberErrorReturn.setStatus('current')
if mibBuilder.loadTexts: hm2AgentLagMirrorProbePortLagMemberErrorReturn.setDescription('The port cannot be added because it is already a probe port.')
hm2AgentSwitchConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8))
hm2AgentSwitchAddressAgingTimeoutTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 4), )
if mibBuilder.loadTexts: hm2AgentSwitchAddressAgingTimeoutTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchAddressAgingTimeoutTable.setDescription("The switch's address aging timeout table")
hm2AgentSwitchAddressAgingTimeoutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 4, 1), ).setIndexNames((0, "Q-BRIDGE-MIB", "dot1qFdbId"))
if mibBuilder.loadTexts: hm2AgentSwitchAddressAgingTimeoutEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchAddressAgingTimeoutEntry.setDescription('Aging information about a specific Filtering Database.')
hm2AgentSwitchAddressAgingTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 500000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchAddressAgingTimeout.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchAddressAgingTimeout.setDescription("The FDB entry's address aging timeout (in seconds)")
hm2AgentSwitchStaticMacFilteringTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 5), )
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringTable.setDescription("The switch's static Mac filtering table")
hm2AgentSwitchStaticMacFilteringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 5, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchStaticMacFilteringVlanId"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchStaticMacFilteringAddress"))
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringEntry.setDescription('Per port ingress/egress filter configuration based on VLAN Id and MAC address.')
hm2AgentSwitchStaticMacFilteringVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringVlanId.setDescription('The Static MAC Filter Vlan Id')
hm2AgentSwitchStaticMacFilteringAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 5, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringAddress.setDescription('The Static MAC Filter MAC address')
hm2AgentSwitchStaticMacFilteringSourcePortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 5, 1, 3), Hm2AgentPortMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringSourcePortMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringSourcePortMask.setDescription('The Static MAC Filter source port mask. When setting this value, the system will ignore configuration for ports not between the first and last valid ports. Configuration of any port numbers between this range that are not valid ports return a failure message, but will still apply configuration for valid ports. To obtain port numbers from interface numbers, use the objects hm2AgentPortDot1dBasePort and hm2AgentPortIfIndex in the hm2AgentPortConfigTable table.')
hm2AgentSwitchStaticMacFilteringDestPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 5, 1, 4), Hm2AgentPortMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringDestPortMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringDestPortMask.setDescription('The Static MAC Filter destination port mask. When setting this value, the system will ignore configuration for ports not between the first and last valid ports. Configuration of any port numbers between this range that are not valid ports return a failure message, but will still apply configuration for valid ports. To obtain port numbers from interface numbers, use the objects hm2AgentPortDot1dBasePort and hm2AgentPortIfIndex in the hm2AgentPortConfigTable table. Configuring destination port mask for a unicast MAC filter is not supported on some platforms.')
hm2AgentSwitchStaticMacFilteringStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacFilteringStatus.setDescription('The Static MAC Filter status. Supported values: active(1) - valid entry createAndGo(4) - used to create a new entry destroy(6) - removes the entry')
hm2AgentSwitchSnoopingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 6))
hm2AgentSwitchSnoopingCfgTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 6, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingCfgTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingCfgTable.setDescription('A table of the IGMP/MLD Snooping Global configuration entries.')
hm2AgentSwitchSnoopingCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 6, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchSnoopingProtocol"))
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingCfgEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingCfgEntry.setDescription('Represents entry for Snooping switch Configuration.')
hm2AgentSwitchSnoopingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 6, 1, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingProtocol.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingProtocol.setDescription('The protocol type of network protocol in use.')
hm2AgentSwitchSnoopingAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 6, 1, 1, 2), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingAdminMode.setDescription('This enables or disables Snooping on the system. ')
hm2AgentSwitchSnoopingPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 6, 1, 1, 3), Hm2AgentPortMask().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingPortMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingPortMask.setDescription('IGMP/MLD Snooping Port Mask. This allows configuration of IGMP/MLD Snooping on selected ports. IGMP/MLD Snooping cannot be enabled on an interface that has routing enabled, or is a member of a LAG. If a port which has IGMP/MLD Snooping enabled becomes enabled for routing, or is enlisted as a member of a LAG, IGMP/MLD Snooping functionality will be disabled on that port. IGMP/MLD Snooping functionality will be subsequently be reenabled if routing is disabled or LAG membership is removed from an interface that had previously had IGMP/MLD Snooping enabled. To obtain port numbers from interface numbers, use the objects hm2AgentPortDot1dBasePort and hm2AgentPortIfIndex in the hm2AgentPortConfigTable table.')
hm2AgentSwitchSnoopingMulticastControlFramesProcessed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingMulticastControlFramesProcessed.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingMulticastControlFramesProcessed.setDescription('Multicast Control Frames Processed by CPU. The number of multicast control frames that have been processed by the CPU.')
hm2AgentSwitchSnoopingIntfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7))
hm2AgentSwitchSnoopingIntfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfTable.setDescription('A table of the IGMP/MLD Snooping Interface configuration entries.')
hm2AgentSwitchSnoopingIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchSnoopingProtocol"))
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfEntry.setDescription('Represents entry for a IGMP/MLD Snooping Interface.')
hm2AgentSwitchSnoopingIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfIndex.setDescription('The port number to be selected. Each port maps to an interface.')
hm2AgentSwitchSnoopingIntfAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1, 2), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfAdminMode.setDescription('This enables or disables IGMP/MLD Snooping on a selected interface.')
hm2AgentSwitchSnoopingIntfGroupMembershipInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 3600)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfGroupMembershipInterval.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfGroupMembershipInterval.setDescription('The amount of time in seconds that a switch will wait for a report from a particular group on the selected interface before deleting the interface from the entry. This value must be greater than hm2AgentSwitchSnoopingIntfMaxResponseTime.')
hm2AgentSwitchSnoopingIntfMaxResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1, 4), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfMaxResponseTime.setDescription('The amount of time in seconds a switch will wait after sending a query on the selected interface because it did not receive a report for a particular group in that interface. This value must be less than hm2AgentSwitchSnoopingIntfGroupMembershipInterval. For IGMP Snooping, this value ranges from 1 to 25 and for MLD Snooping, this value ranges from 1 to 65.')
hm2AgentSwitchSnoopingIntfMRPExpirationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfMRPExpirationTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfMRPExpirationTime.setDescription("The amount of time in seconds that a switch will wait for a query to be received on the selected interface before the interface is removed from the list of interfaces with multicast routers attached. A value of 0 represents an 'infinite' interval.")
hm2AgentSwitchSnoopingIntfFastLeaveAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1, 6), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfFastLeaveAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfFastLeaveAdminMode.setDescription('This enables or disables IGMP/MLD Snooping on the selected interface.')
hm2AgentSwitchSnoopingIntfMulticastRouterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1, 7), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfMulticastRouterMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfMulticastRouterMode.setDescription('The port explicitly configured by management to be IGMP query port for all VLANs.')
hm2AgentSwitchSnoopingIntfVlanIDs = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 7, 1, 1, 8), VlanList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfVlanIDs.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingIntfVlanIDs.setDescription('This field lists all the VlanIDs which include the selected interface.')
hm2AgentSwitchSnoopingVlanGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8))
hm2AgentSwitchSnoopingVlanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanTable.setDescription('A table of the IGMP/MLD Snooping Vlan configuration entries.')
hm2AgentSwitchSnoopingVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8, 1, 1), ).setIndexNames((0, "Q-BRIDGE-MIB", "dot1qVlanIndex"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchSnoopingProtocol"))
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanEntry.setDescription('Represents entry for a IGMP/MLD Snooping Vlan.')
hm2AgentSwitchSnoopingVlanAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8, 1, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanAdminMode.setDescription('This enables or disables IGMP/MLD Snooping on a selected Vlan interface.')
hm2AgentSwitchSnoopingVlanGroupMembershipInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 3600)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanGroupMembershipInterval.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanGroupMembershipInterval.setDescription('The amount of time in seconds that a switch will wait for a report from a particular group on the selected vlan before deleting the interface participating in the vlan from the entry. This value must be greater than hm2AgentSwitchSnoopingIntfMaxResponseTime.')
hm2AgentSwitchSnoopingVlanMaxResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8, 1, 1, 3), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanMaxResponseTime.setDescription('The amount of time in seconds a switch will wait after sending a query on the selected vlan because it did not receive a report for a particular group in the interface participating in the vlan. This value must be less than hm2AgentSwitchSnoopingIntfGroupMembershipInterval. For IGMP Snooping, this value ranges from 1 to 25 and for MLD Snooping, this value ranges from 1 to 65.')
hm2AgentSwitchSnoopingVlanFastLeaveAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8, 1, 1, 4), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanFastLeaveAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanFastLeaveAdminMode.setDescription('This enables or disables IGMP/MLD Snooping on the selected vlan.')
hm2AgentSwitchSnoopingVlanMRPExpirationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanMRPExpirationTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanMRPExpirationTime.setDescription("The amount of time in seconds that a switch will wait for a query to be received on the selected interface participating in the vlan before the interface is removed from the list of interfaces with multicast routers attached. This parameter is configurable only for existing VLANs. A value of 0 represents an 'infinite' interval.")
hm2AgentSwitchSnoopingVlanReportSuppMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 8, 1, 1, 6), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanReportSuppMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingVlanReportSuppMode.setDescription('This enables or disables IGMP/MLD Snooping Report Suppression feature on the selected vlan.')
hm2AgentSwitchVlanStaticMrouterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 9))
hm2AgentSwitchVlanStaticMrouterTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 9, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchVlanStaticMrouterTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanStaticMrouterTable.setDescription('A table of the IGMP/MLD Static Mrouter Configuration parameters.')
hm2AgentSwitchVlanStaticMrouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 9, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "Q-BRIDGE-MIB", "dot1qVlanIndex"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchSnoopingProtocol"))
if mibBuilder.loadTexts: hm2AgentSwitchVlanStaticMrouterEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanStaticMrouterEntry.setDescription('Represents entry for a IGMP/MLD Static Mrouter.')
hm2AgentSwitchVlanStaticMrouterAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 9, 1, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchVlanStaticMrouterAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanStaticMrouterAdminMode.setDescription('This enables or disables IGMP/MLD mrouter on a per interface per VLAN basis.')
hm2AgentSwitchMFDBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10))
hm2AgentSwitchMFDBTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchMFDBTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBTable.setDescription('The Multicast Forwarding Database table')
hm2AgentSwitchMFDBEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchMFDBVlanId"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchMFDBMacAddress"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchMFDBProtocolType"))
if mibBuilder.loadTexts: hm2AgentSwitchMFDBEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBEntry.setDescription('Contains Forwarding and Filtering information per Vlan Index, MAC Address, and Component User.')
hm2AgentSwitchMFDBVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBVlanId.setDescription('Vlan Index for which this entry is associated with.')
hm2AgentSwitchMFDBMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBMacAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBMacAddress.setDescription('A multicast MAC address for which the switch has forwarding and or filtering information.')
hm2AgentSwitchMFDBProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 248))).clone(namedValues=NamedValues(("static", 1), ("gmrp", 2), ("igmp", 3), ("mld", 4), ("mrp-mmrp", 248)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBProtocolType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBProtocolType.setDescription('The component that is responsible for this entry in the Multicast Forwarding Database.')
hm2AgentSwitchMFDBType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBType.setDescription('This displays the type of the entry. static(1) - Entries configured by the end user dynamic(2) - Entries added as a result of a learning process or protocol')
hm2AgentSwitchMFDBDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBDescription.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBDescription.setDescription('Text description of this multicast table entry.')
hm2AgentSwitchMFDBForwardingPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1, 1, 6), Hm2AgentPortMask()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBForwardingPortMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBForwardingPortMask.setDescription('BitMask indicating which ports this entry indicates should be forwarded. To obtain port numbers from interface numbers, use the objects hm2AgentPortDot1dBasePort and hm2AgentPortIfIndex in the hm2AgentPortConfigTable table.')
hm2AgentSwitchMFDBFilteringPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 1, 1, 7), Hm2AgentPortMask()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBFilteringPortMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBFilteringPortMask.setDescription('BitMask indicating which ports this entry indicates should be filtered. To obtain port numbers from interface numbers, use the objects hm2AgentPortDot1dBasePort and hm2AgentPortIfIndex in the hm2AgentPortConfigTable table.')
hm2AgentSwitchMFDBSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 2), )
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryTable.setDescription('The multicast forwarding database summary table.')
hm2AgentSwitchMFDBSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 2, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchMFDBSummaryVlanId"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchMFDBSummaryMacAddress"))
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryEntry.setDescription('Summarizes the forwarding ports for all components registered for all MFDB table entries with the same Vlan Index and MAC Address.')
hm2AgentSwitchMFDBSummaryVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 2, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryVlanId.setDescription('Vlan Index for which this entry is associated with.')
hm2AgentSwitchMFDBSummaryMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryMacAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryMacAddress.setDescription('A multicast MAC address for which the switch has forwarding and or filtering information.')
hm2AgentSwitchMFDBSummaryForwardingPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 2, 1, 3), Hm2AgentPortMask()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryForwardingPortMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBSummaryForwardingPortMask.setDescription('Port Mask indicating which ports this entry indicates should be forwarded. To obtain port numbers from interface numbers, use the objects hm2AgentPortDot1dBasePort and hm2AgentPortIfIndex in the hm2AgentPortConfigTable table.')
hm2AgentSwitchMFDBMaxTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBMaxTableEntries.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBMaxTableEntries.setDescription('This displays the maximum number of entries that can possibly be in the Multicast Forwarding Database table.')
hm2AgentSwitchMFDBMostEntriesUsed = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBMostEntriesUsed.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBMostEntriesUsed.setDescription('This displays the largest number of entries that have been present in the Multicast Forwarding Database table. This value is also known as the MFDB high water mark.')
hm2AgentSwitchMFDBCurrentEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 10, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchMFDBCurrentEntries.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchMFDBCurrentEntries.setDescription('This displays the current number of entries in the Multicast Forwarding Database table.')
hm2AgentSwitchStaticMacStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 248))
hm2AgentSwitchStaticMacEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 248, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacEntries.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchStaticMacEntries.setDescription('Total number of MAC addresses configured statically in mac-filter-table.')
hm2AgentSwitchGARPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249))
hm2AgentSwitchGmrpUnknownMulticastFilterMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flood", 1), ("discard", 2))).clone('flood')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchGmrpUnknownMulticastFilterMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGmrpUnknownMulticastFilterMode.setDescription('This configures whether traffic from unknown multicast addresses must be flooded or be discarded.')
hm2AgentSwitchGmrpPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 10), )
if mibBuilder.loadTexts: hm2AgentSwitchGmrpPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGmrpPortTable.setDescription('GMRP control and status information for a bridge port. Augments dot1dPortGmrpEntry in P-BRIDGE-MIB.')
hm2AgentSwitchGmrpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 10, 1), )
dot1dBasePortEntry.registerAugmentions(("HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchGmrpPortEntry"))
hm2AgentSwitchGmrpPortEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
if mibBuilder.loadTexts: hm2AgentSwitchGmrpPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGmrpPortEntry.setDescription('GMRP control and status information for a bridge port. Augments dot1dPortGmrpEntry in P-BRIDGE-MIB.')
hm2AgentSwitchGmrpPortPktRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchGmrpPortPktRx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGmrpPortPktRx.setDescription('The total number of GMRP packets received, in all VLANs, on this port.')
hm2AgentSwitchGmrpPortPktTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchGmrpPortPktTx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGmrpPortPktTx.setDescription('The total number of GMRP packets transmitted, in all VLANs, on this port.')
hm2AgentSwitchGvrpPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 15), )
if mibBuilder.loadTexts: hm2AgentSwitchGvrpPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGvrpPortTable.setDescription('GVRP control and status information for a bridge port. Augments dot1qPortVlanEntry in Q-BRIDGE-MIB.')
hm2AgentSwitchGvrpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 15, 1), )
dot1dBasePortEntry.registerAugmentions(("HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchGvrpPortEntry"))
hm2AgentSwitchGvrpPortEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
if mibBuilder.loadTexts: hm2AgentSwitchGvrpPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGvrpPortEntry.setDescription('GVRP control and status information for a bridge port. Augments dot1qPortVlanEntry in Q-BRIDGE-MIB.')
hm2AgentSwitchGvrpPortPktRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 15, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchGvrpPortPktRx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGvrpPortPktRx.setDescription('The total number of GVRP packets received on this port.')
hm2AgentSwitchGvrpPortPktTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 249, 15, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchGvrpPortPktTx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchGvrpPortPktTx.setDescription('The total number of GVRP packets transmitted on this port.')
hm2AgentSwitchVlanMacAssociationGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 17))
hm2AgentSwitchVlanMacAssociationTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 17, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationTable.setDescription("The switch's MAC To VLAN association table")
hm2AgentSwitchVlanMacAssociationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 17, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchVlanMacAssociationMacAddress"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchVlanMacAssociationVlanId"))
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationEntry.setDescription('VLAN to be assigned to untagged or priority tagged packets based on MAC address.')
hm2AgentSwitchVlanMacAssociationMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 17, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationMacAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationMacAddress.setDescription('The Mac address')
hm2AgentSwitchVlanMacAssociationVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 17, 1, 1, 2), VlanIndex())
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationVlanId.setDescription('The VLAN the Mac address assigned to')
hm2AgentSwitchVlanMacAssociationRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 17, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanMacAssociationRowStatus.setDescription('The Mac to VLAN association row status. Supported values: active(1) - valid entry createAndGo(4) - used to create a new entry destroy(6) - removes the entry')
hm2AgentSwitchProtectedPortConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 18))
hm2AgentSwitchProtectedPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 18, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortTable.setDescription("The switch's protected port mapping table")
hm2AgentSwitchProtectedPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 18, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchProtectedPortGroupId"))
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortEntry.setDescription('Protected ports assigned to groups.')
hm2AgentSwitchProtectedPortGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortGroupId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortGroupId.setDescription('The group that this port belongs to')
hm2AgentSwitchProtectedPortGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 18, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortGroupName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortGroupName.setDescription('The name of the group')
hm2AgentSwitchProtectedPortPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 18, 1, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortPortList.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchProtectedPortPortList.setDescription('The set of ports that are protected in this group')
hm2AgentSwitchVlanSubnetAssociationGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 19))
hm2AgentSwitchVlanSubnetAssociationTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 19, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationTable.setDescription("The switch's Subnet To VLAN association table")
hm2AgentSwitchVlanSubnetAssociationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 19, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchVlanSubnetAssociationIPAddress"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchVlanSubnetAssociationSubnetMask"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchVlanSubnetAssociationVlanId"))
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationEntry.setDescription('VLAN to be assigned to untagged or priority tagged packets based on IP address and Subnet Mask.')
hm2AgentSwitchVlanSubnetAssociationIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 19, 1, 1, 1), IpAddress())
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationIPAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationIPAddress.setDescription('The ip address')
hm2AgentSwitchVlanSubnetAssociationSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 19, 1, 1, 2), IpAddress())
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationSubnetMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationSubnetMask.setDescription('The subnet mask')
hm2AgentSwitchVlanSubnetAssociationVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 19, 1, 1, 3), VlanIndex())
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationVlanId.setDescription('The VLAN that the IP address and subnet mask assigned to')
hm2AgentSwitchVlanSubnetAssociationRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 19, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVlanSubnetAssociationRowStatus.setDescription('The Subnet to VLAN association row status. Supported values: active(1) - valid entry createAndGo(4) - used to create a new entry destroy(6) - removes the entry')
hm2AgentSwitchSnoopingQuerierGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20))
hm2AgentSwitchSnoopingQuerierCfgTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 1), )
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierCfgTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierCfgTable.setDescription('A table of the IGMP/MLD Snooping Querier Global configuration entries.')
hm2AgentSwitchSnoopingQuerierCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchSnoopingProtocol"))
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierCfgEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierCfgEntry.setDescription('Represents entry for Snooping Querier Configuration.')
hm2AgentSwitchSnoopingQuerierAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 1, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierAdminMode.setDescription('This enables or disables Snooping Querier on the system. ')
hm2AgentSwitchSnoopingQuerierVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 1, 1, 2), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVersion.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVersion.setDescription('This specifies the multicast protocol versions that are supported by the system.')
hm2AgentSwitchSnoopingQuerierQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1800)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierQueryInterval.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierQueryInterval.setDescription('This specified the timer interval after which the system generates general queries.')
hm2AgentSwitchSnoopingQuerierExpiryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 300)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierExpiryInterval.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierExpiryInterval.setDescription('This specified the timer interval after which the detected other querier information is no longer valid.')
hm2AgentSwitchSnoopingQuerierVlanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2), )
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanTable.setDescription('A table of the Snooping Querier Vlan configuration entries.')
hm2AgentSwitchSnoopingQuerierVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1), ).setIndexNames((0, "Q-BRIDGE-MIB", "dot1qVlanIndex"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchSnoopingProtocol"))
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanEntry.setDescription('Represents entry for a Snooping Querier configurable Vlan.')
hm2AgentSwitchSnoopingQuerierVlanAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanAdminMode.setDescription('This enables or disables Snooping Querier on a selected Vlan interface.')
hm2AgentSwitchSnoopingQuerierVlanOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("querier", 1), ("non-querier", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanOperMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanOperMode.setDescription('This specifies the current state of the Snooping Querier on a selected vlan interface')
hm2AgentSwitchSnoopingQuerierElectionParticipateMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1, 3), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierElectionParticipateMode.setStatus('deprecated')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierElectionParticipateMode.setDescription('This object is deprecated. This enables or disables the Snooping Querier Election Participation mode. When enabled snooping querier switch will participate in querier election up on discovering another querier in the specified vlan. When disabled, up on discovering another querier, snooping querier moves to non-querier state. The state of the querier is solely set by hm2AgentSwitchSnoopingQuerierVlanAdminMode. If hm2AgentSwitchSnoopingQuerierVlanAdminMode is set to enable(1) hm2AgentSwitchSnoopingQuerierElectionParticipateMode will be set internally to enable(1). If hm2AgentSwitchSnoopingQuerierVlanAdminMode is set to disable(2) hm2AgentSwitchSnoopingQuerierElectionParticipateMode will be set internally to disable(2).')
hm2AgentSwitchSnoopingQuerierVlanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1, 4), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierVlanAddress.setDescription('This specifies the default source ip address to be used while generating general queries on the specified vlan.')
hm2AgentSwitchSnoopingQuerierOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierOperVersion.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierOperVersion.setDescription('This specifies the multicast protocol version that is currently being used by the snooping switch for the specified vlan while generating query messages.')
hm2AgentSwitchSnoopingQuerierOperMaxResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierOperMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierOperMaxResponseTime.setDescription('The amount of time in seconds a switch will wait after sending a query on the selected vlan because it did not receive a report for a particular group in the interface participating in the vlan. This object is valid only when hm2AgentSwitchSnoopingQuerierOperVersion object is valid. (-1) - indicates that parameter is not available; ( 0) - indicates that response time is less then 1 second.')
hm2AgentSwitchSnoopingQuerierLastQuerierAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierLastQuerierAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierLastQuerierAddress.setDescription("This specifies the last querier's ip address for the specified vlan. It represents the detected other multicast querier in the vlan. ")
hm2AgentSwitchSnoopingQuerierLastQuerierVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 20, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierLastQuerierVersion.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchSnoopingQuerierLastQuerierVersion.setDescription('This specifies the multicast protocol version that is currently being used by the detected other multicast querier for the specified vlan. (-1) - indicates that parameter is not available.')
hm2AgentPortMirroringGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10))
hm2AgentPortMirrorTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4), )
if mibBuilder.loadTexts: hm2AgentPortMirrorTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorTable.setDescription('This table includes entries for each Port Mirroring session.')
hm2AgentPortMirrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentPortMirrorSessionNum"))
if mibBuilder.loadTexts: hm2AgentPortMirrorEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorEntry.setDescription('Provides configuration of a Port Mirroring session specifying the destination port, and the source Port Mask, providing a many-to-one mapping.')
hm2AgentPortMirrorSessionNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hm2AgentPortMirrorSessionNum.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorSessionNum.setDescription('The Session number of this mirroring entry. The number of sessions is fixed and platform dependant.')
hm2AgentPortMirrorDestinationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorDestinationPort.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorDestinationPort.setDescription('The port which traffic from the mirrored ports will be sent to.')
hm2AgentPortMirrorSourcePortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 3), Hm2AgentPortMask()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorSourcePortMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorSourcePortMask.setDescription('The ports from which traffic will be sent to the destination port. The destination port can not be included in this list of ports.')
hm2AgentPortMirrorAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorAdminMode.setDescription('The status of this port mirroring session. enable(1) - This session is active and all traffic from the source ports will be mirrored to the destination port. disable(2) - This session is not active.')
hm2AgentPortMirrorSourceVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4042))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorSourceVlan.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorSourceVlan.setDescription('The vlan from which traffic will be sent to the destination port.')
hm2AgentPortMirrorRemoteSourceVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 4042), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorRemoteSourceVlan.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorRemoteSourceVlan.setDescription('The remote vlan from which traffic will be sent to the destination port.')
hm2AgentPortMirrorRemoteDestinationVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 4042), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorRemoteDestinationVlan.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorRemoteDestinationVlan.setDescription('The VLAN that forwards the network traffic to the destination switch.')
hm2AgentPortMirrorReflectorPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorReflectorPort.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorReflectorPort.setDescription('The port which traffic from the mirrored ports will be sent to in case of destination being remote VLAN.')
hm2AgentPortMirrorAllowMgmtMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 9), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorAllowMgmtMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorAllowMgmtMode.setDescription('The status of the management access possibility for this session. enable(1) - Management is allowed - The device is accessible via this port and is responsive to protocols while mirroring the probe port. disable(2) - Management not is allowed - the device is not accessible via this port and is not responsive to protocols. It only mirrors the probe port.')
hm2AgentPortMirrorReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 4, 1, 248), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorReset.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorReset.setDescription('Removes, reset(2) the configuration for this session. Returns always other(1) when read.')
hm2AgentPortMirrorTypeTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 5), )
if mibBuilder.loadTexts: hm2AgentPortMirrorTypeTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorTypeTable.setDescription('This table includes entries for each source ports direction of port mirroring.')
hm2AgentPortMirrorTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 5, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentPortMirrorSessionNum"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentPortMirrorTypeSourcePort"))
if mibBuilder.loadTexts: hm2AgentPortMirrorTypeEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorTypeEntry.setDescription('Provides configuration of a Port Mirroring direction specifying the session of the port mirroring and source port.')
hm2AgentPortMirrorTypeSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hm2AgentPortMirrorTypeSourcePort.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorTypeSourcePort.setDescription('The port from which traffic will be sent to the destination port. This port should be a source port in the corresponding session.')
hm2AgentPortMirrorTypeType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("tx", 1), ("rx", 2), ("txrx", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorTypeType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorTypeType.setDescription('The direction of the data to be mirrored on this source port. none(0) - No configuration is set. tx(1) - The data that is transmitted from the source port. rx(2) - The data that is received on the source port. txrx(3) - The data that is transmitted/received from/on the source port')
hm2AgentPortMirrorRemoteVlan = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMirrorRemoteVlan.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorRemoteVlan.setDescription('The VLAN configured as RSPAN VLAN.')
hm2AgentPortMirrorSNMPExtensionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248))
hm2AgentPortMirrorVlanMirrorPortConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 1))
if mibBuilder.loadTexts: hm2AgentPortMirrorVlanMirrorPortConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorVlanMirrorPortConflict.setDescription('VLAN has been already configured as a source interface. At the same time physical interface and VLAN interface cannot be configured as source interfaces for a session.')
hm2AgentPortMirrorPortVlanMirrorConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 2))
if mibBuilder.loadTexts: hm2AgentPortMirrorPortVlanMirrorConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorPortVlanMirrorConflict.setDescription('A physical interface has been already configured as a source interface. At the same time physical interface and VLAN interface cannot be configured as source interfaces for a session.')
hm2AgentPortMirrorProbePortAlreadySet = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 3))
if mibBuilder.loadTexts: hm2AgentPortMirrorProbePortAlreadySet.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorProbePortAlreadySet.setDescription('Selected interface is already used.')
hm2AgentPortMirrorProbePortVlanConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 4))
if mibBuilder.loadTexts: hm2AgentPortMirrorProbePortVlanConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorProbePortVlanConflict.setDescription('Destination interface cannot participate in source VLAN.')
hm2AgentPortMirrorVlanNotCreated = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 5))
if mibBuilder.loadTexts: hm2AgentPortMirrorVlanNotCreated.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorVlanNotCreated.setDescription('Not existing VLAN cannot be configured as source interface for a session.')
hm2AgentPortMirrorInvalidSourcePort = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 6))
if mibBuilder.loadTexts: hm2AgentPortMirrorInvalidSourcePort.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorInvalidSourcePort.setDescription('Selected interface () cannot be configured as source interface.')
hm2AgentPortMirrorSourcePortDestinationPortConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 7))
if mibBuilder.loadTexts: hm2AgentPortMirrorSourcePortDestinationPortConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorSourcePortDestinationPortConflict.setDescription('Destination interface () cannot be configured as source interface.')
hm2AgentPortMirrorDestinationPortInvalid = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 8))
if mibBuilder.loadTexts: hm2AgentPortMirrorDestinationPortInvalid.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorDestinationPortInvalid.setDescription('Conflict with another feature: Selected interface () is already used by () and cannot be configured as a destination interface.')
hm2AgentPortMirrorVlanRspanVlanConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 9))
if mibBuilder.loadTexts: hm2AgentPortMirrorVlanRspanVlanConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorVlanRspanVlanConflict.setDescription('RSPAN vlan () cannot be configured as source vlan.')
hm2AgentPortMirrorRemoteSourceRemoteDestinationConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 10))
if mibBuilder.loadTexts: hm2AgentPortMirrorRemoteSourceRemoteDestinationConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorRemoteSourceRemoteDestinationConflict.setDescription('Source and destination cannot be set to remote VLAN at the same time.')
hm2AgentPortMirrorReflectorPortInvalid = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 11))
if mibBuilder.loadTexts: hm2AgentPortMirrorReflectorPortInvalid.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorReflectorPortInvalid.setDescription('Selected interface () cannot be configured as a reflector interface. Only physical interface can be configured as a reflector interface.')
hm2AgentPortMirrorSourcePortReflectorPortConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 12))
if mibBuilder.loadTexts: hm2AgentPortMirrorSourcePortReflectorPortConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorSourcePortReflectorPortConflict.setDescription('Source interface () cannot be configured as reflector interface.')
hm2AgentPortMirrorReflectorPortVlanConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 13))
if mibBuilder.loadTexts: hm2AgentPortMirrorReflectorPortVlanConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorReflectorPortVlanConflict.setDescription('Reflector interface () cannot participate in source vlan ().')
hm2AgentPortMirrorPrivateVlanConfigured = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 14))
if mibBuilder.loadTexts: hm2AgentPortMirrorPrivateVlanConfigured.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorPrivateVlanConfigured.setDescription('Selected VLAN is already configured as private VLAN and cannot be configured as RSPAN VLAN.')
hm2AgentPortMirrorDestinationRemotePortNotSet = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 15))
if mibBuilder.loadTexts: hm2AgentPortMirrorDestinationRemotePortNotSet.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorDestinationRemotePortNotSet.setDescription('A destination/reflector port must first be set before mirroring/remote-mirroring can be enabled.')
hm2AgentPortMirrorRspanVlanInconsistent = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 16))
if mibBuilder.loadTexts: hm2AgentPortMirrorRspanVlanInconsistent.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorRspanVlanInconsistent.setDescription('The RSPAN VLAN ID is inconsistent with the RSPAN source/destination VLAN ID.')
hm2AgentPortMirrorRspanVlanIdInvalid = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 10, 248, 17))
if mibBuilder.loadTexts: hm2AgentPortMirrorRspanVlanIdInvalid.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMirrorRspanVlanIdInvalid.setDescription('VLAN 1 cannot be used as the RSPAN VLAN.')
hm2AgentDot3adAggPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 12), )
if mibBuilder.loadTexts: hm2AgentDot3adAggPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDot3adAggPortTable.setDescription('This table provides 802.3ad link aggregation information for each physical port that is not available through the standard MIB.')
hm2AgentDot3adAggPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 12, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDot3adAggPort"))
if mibBuilder.loadTexts: hm2AgentDot3adAggPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDot3adAggPortEntry.setDescription('Information about a table entry. The hm2AgentDot3adAggPort identifies the external interface number of the port.')
hm2AgentDot3adAggPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDot3adAggPort.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDot3adAggPort.setDescription('ifIndex of this physical port')
hm2AgentDot3adAggPortLACPMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 12, 1, 2), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDot3adAggPortLACPMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDot3adAggPortLACPMode.setDescription('Enable/disable 802.3ad LACP on this port')
hm2AgentPortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13), )
if mibBuilder.loadTexts: hm2AgentPortConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortConfigTable.setDescription("A table of the switch's physical port config entries")
hm2AgentPortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentPortDot1dBasePort"))
if mibBuilder.loadTexts: hm2AgentPortConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortConfigEntry.setDescription("Switch's physical port config entry")
hm2AgentPortDot1dBasePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentPortDot1dBasePort.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortDot1dBasePort.setDescription('The number of this port.')
hm2AgentPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortIfIndex.setDescription('The switchs Port IfIndex.')
hm2AgentPortClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 10), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortClearStats.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortClearStats.setDescription('Clear stats for this port only.')
hm2AgentPortDot3FlowControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("symmetric", 1), ("asymmetric", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortDot3FlowControlMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortDot3FlowControlMode.setDescription('Config flowcontrol allows you to enable or disable 802.3x flow control for this port. This value applies to only full-duplex mode ports. Enabling symmetric flow control allows the port to send and receive pause frames. Enabling asymmetric flow control allows the port to receive pause frames but it will not transmit pause frames.')
hm2AgentPortMaxFrameSizeLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentPortMaxFrameSizeLimit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMaxFrameSizeLimit.setDescription('This object identifies the largest value that can be configured for hm2AgentPortMaxFrameSize.')
hm2AgentPortMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMaxFrameSize.setDescription('This object identifies the currently configured maximum frame size value for this port. The maximum value that this object can be set to is the value of hm2AgentPortMaxFrameSizeLimit. For Ethernet ports which support 802.1Q vlan tagging, the minimum value that this object can be set to is 1522')
hm2AgentPortBroadcastControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 20), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortBroadcastControlMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortBroadcastControlMode.setDescription('If enabled, broadcast storm recovery will function on this port. When you specify Enable for Broadcast Storm Recovery and the broadcast traffic on this Ethernet port exceeds the configured threshold, the switch blocks (discards) the broadcast traffic.')
hm2AgentPortBroadcastControlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14880000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortBroadcastControlThreshold.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortBroadcastControlThreshold.setDescription('Configures the broadcast storm recovery threshold for this port as a percentage of port speed or as an absolute pps rate.')
hm2AgentPortMulticastControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 22), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMulticastControlMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMulticastControlMode.setDescription('If enabled, multicast storm recovery will function on this port. When you specify Enable for Multicast Storm Recovery and the multicast traffic on this Ethernet port exceeds the configured threshold, the switch blocks (discards) the multicast traffic.')
hm2AgentPortMulticastControlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14880000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMulticastControlThreshold.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMulticastControlThreshold.setDescription('Configures the multicast storm recovery threshold for this port as a percentage of port speed or as an absolute pps rate.')
hm2AgentPortUnicastControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 24), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortUnicastControlMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortUnicastControlMode.setDescription('If enabled, unicast storm recovery will function on this port. When you specify Enable for Unicast Storm Recovery and the unknown unicast traffic on this Ethernet port exceeds the configured threshold, the switch blocks (discards) the unknown unicast traffic.')
hm2AgentPortUnicastControlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14880000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortUnicastControlThreshold.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortUnicastControlThreshold.setDescription('Configures the unicast storm recovery threshold for this port as a percentage of port speed or as an absolute pps rate.')
hm2AgentPortBroadcastControlThresholdUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("percent", 1), ("pps", 2))).clone('percent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortBroadcastControlThresholdUnit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortBroadcastControlThresholdUnit.setDescription('Configures the units of the threshold value to percentage of port speed or absolute packets per second.')
hm2AgentPortMulticastControlThresholdUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("percent", 1), ("pps", 2))).clone('percent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortMulticastControlThresholdUnit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortMulticastControlThresholdUnit.setDescription('Configures the units of the threshold value to percentage of port speed or absolute packets per second.')
hm2AgentPortUnicastControlThresholdUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("percent", 1), ("pps", 2))).clone('percent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortUnicastControlThresholdUnit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortUnicastControlThresholdUnit.setDescription('Configures the units of the threshold value to percentage of port speed or absolute packets per second.')
hm2AgentPortVoiceVlanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("vlanid", 2), ("dot1p", 3), ("vlanidanddot1p", 4), ("untagged", 5), ("disable", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanMode.setDescription('Describes and Configures the Port Voice VLAN Mode. This object can only be set to disable(5).')
hm2AgentPortVoiceVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4093))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanID.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanID.setDescription('Describes and Configures the Port Voice VLAN ID if the Voice Vlan Mode is Vlan ID.')
hm2AgentPortVoiceVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(255, 255), )).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanPriority.setDescription('Describes and Configures the Port Voice VLAN Priority if the Voice Vlan Mode is dot1p. A value of 255 indicates that the priority is not configured.')
hm2AgentPortVoiceVlanDataPriorityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trust", 1), ("untrust", 2))).clone('trust')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanDataPriorityMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanDataPriorityMode.setDescription('Describes and Configures the Port Voice VLAN Data Priority Mode.')
hm2AgentPortVoiceVlanOperationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanOperationalStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanOperationalStatus.setDescription('Describes the Port Voice VLAN Operational Status.')
hm2AgentPortVoiceVlanUntagged = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanUntagged.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanUntagged.setDescription('Describes and Configures the Port Voice VLAN tagging mode.')
hm2AgentPortVoiceVlanNoneMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanNoneMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanNoneMode.setDescription('Describes and Configures the Port Voice VLAN None mode.')
hm2AgentPortVoiceVlanDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanDSCP.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanDSCP.setDescription('Describes and Configures the Port Voice VLAN DSCP value.')
hm2AgentPortVoiceVlanAuthMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 37), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanAuthMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortVoiceVlanAuthMode.setDescription('Describes and Configures the Port Voice VLAN Authentication mode. Disable means authentication not required for voice devices when dot1x is enabled.')
hm2AgentPortDot3FlowControlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentPortDot3FlowControlOperStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortDot3FlowControlOperStatus.setDescription('This object identifies operational status of the flow control per port.')
hm2AgentPortSfpLinkLossAlert = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 13, 1, 248), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentPortSfpLinkLossAlert.setStatus('current')
if mibBuilder.loadTexts: hm2AgentPortSfpLinkLossAlert.setDescription('If enabled, this object helps in the detecting the loss of a SFP link by deactivating its light.')
hm2AgentProtocolConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14))
hm2AgentProtocolGroupTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 2), )
if mibBuilder.loadTexts: hm2AgentProtocolGroupTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupTable.setDescription("A table of the switch's Protocol-based VLAN entries")
hm2AgentProtocolGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 2, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentProtocolGroupId"))
if mibBuilder.loadTexts: hm2AgentProtocolGroupEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupEntry.setDescription("Switch's Protocol-based VLAN entry")
hm2AgentProtocolGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentProtocolGroupId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupId.setDescription('Group identifier of the Protocol-based VLAN entry.')
hm2AgentProtocolGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 2, 1, 2), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(1, 16), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentProtocolGroupName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupName.setDescription('Group name of the Protocol-based VLAN entry.')
hm2AgentProtocolGroupVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4093))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentProtocolGroupVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupVlanId.setDescription('VLAN associated with the Protocol-based VLAN entry. Set to 0 to remove.')
hm2AgentProtocolGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentProtocolGroupStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupStatus.setDescription('The status of the Protocol-based VLAN entry. active(1) - this entry is active createAndGo(4) - used to create a new entry destroy(6) - remove this entry')
hm2AgentProtocolGroupPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 3), )
if mibBuilder.loadTexts: hm2AgentProtocolGroupPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupPortTable.setDescription("A table of the switch's physical port config entries")
hm2AgentProtocolGroupPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 3, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentProtocolGroupId"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentProtocolGroupPortIfIndex"))
if mibBuilder.loadTexts: hm2AgentProtocolGroupPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupPortEntry.setDescription("Switch's physical port config entry")
hm2AgentProtocolGroupPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentProtocolGroupPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupPortIfIndex.setDescription('The interface number of this instance.')
hm2AgentProtocolGroupPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentProtocolGroupPortStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupPortStatus.setDescription('The status of this entry. active(1) - the port is associated with this group createAndGo(4) - add the port to this group createAndWait(5) - add the port to this group destroy(6) - remove the port from this group')
hm2AgentProtocolGroupProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 4), )
if mibBuilder.loadTexts: hm2AgentProtocolGroupProtocolTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupProtocolTable.setDescription("A table of the switch's physical port config entries")
hm2AgentProtocolGroupProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 4, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentProtocolGroupId"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentProtocolGroupProtocolID"))
if mibBuilder.loadTexts: hm2AgentProtocolGroupProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupProtocolEntry.setDescription("Switch's physical port config entry")
hm2AgentProtocolGroupProtocolID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535)))
if mibBuilder.loadTexts: hm2AgentProtocolGroupProtocolID.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupProtocolID.setDescription('The protocol ID of this instance. The value for IP is 2048 (0x0800), ARP is 2054 (0x0806) and IPX is 33079 (0x8137). Other protocol Ids in the range 1536 to 65535 can also be configured.')
hm2AgentProtocolGroupProtocolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 14, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentProtocolGroupProtocolStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentProtocolGroupProtocolStatus.setDescription('The status of this entry. active(1) - the port is associated with this group createAndGo(4) - add the port to this group createAndWait(5) - add the port to this group destroy(6) - remove the port from this group')
hm2AgentStpSwitchConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15))
hm2AgentStpConfigDigestKey = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpConfigDigestKey.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpConfigDigestKey.setDescription('The MST configuration digest key.')
hm2AgentStpConfigFormatSelector = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpConfigFormatSelector.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpConfigFormatSelector.setDescription('The MST configuration format selector. A value other than 0 (zero) indicates non-support for the IEEE 802.1s standard.')
hm2AgentStpConfigName = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpConfigName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpConfigName.setDescription('The MST configuration name of at most 32 characters.')
hm2AgentStpConfigRevision = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpConfigRevision.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpConfigRevision.setDescription('The MST configuration revision. The default value is 1.')
hm2AgentStpForceVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stp", 1), ("rstp", 2), ("mstp", 3))).clone('rstp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpForceVersion.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpForceVersion.setDescription('The MST configuration force protocol version. The default version is RSTP.')
hm2AgentStpAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 6), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpAdminMode.setDescription('The spanning tree operational status. enable(1) - enables spanning tree operational status on the switch. disable(2) - disables spanning tree operational status on the switch. The default status is enabled.')
hm2AgentStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7), )
if mibBuilder.loadTexts: hm2AgentStpPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortTable.setDescription('STP port table.')
hm2AgentStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentStpPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortEntry.setDescription('STP port entry.')
hm2AgentStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 1), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpPortState.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortState.setDescription('The administrative STP state for the port. enable(1) - enables STP on the port. disable(2) - disables STP on the port. The default port STP state is enabled for the first 4095 ports and disabled for any ports beyond.')
hm2AgentStpPortStatsMstpBpduRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpPortStatsMstpBpduRx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortStatsMstpBpduRx.setDescription('The MSTP BPDUs received on a specific port.')
hm2AgentStpPortStatsMstpBpduTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpPortStatsMstpBpduTx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortStatsMstpBpduTx.setDescription('The MSTP BPDUs sent from a specific port.')
hm2AgentStpPortStatsRstpBpduRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpPortStatsRstpBpduRx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortStatsRstpBpduRx.setDescription('The RSTP BPDUs received on a specific port.')
hm2AgentStpPortStatsRstpBpduTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpPortStatsRstpBpduTx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortStatsRstpBpduTx.setDescription('The RSTP BPDUs sent from a specific port.')
hm2AgentStpPortStatsStpBpduRx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpPortStatsStpBpduRx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortStatsStpBpduRx.setDescription('The STP BPDUs received on a specific port.')
hm2AgentStpPortStatsStpBpduTx = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpPortStatsStpBpduTx.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortStatsStpBpduTx.setDescription('The STP BPDUs sent from a specific port.')
hm2AgentStpPortUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpPortUpTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortUpTime.setDescription('Time since port was reset. It is displayed in days, hours, minutes, and seconds.')
hm2AgentStpPortMigrationCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpPortMigrationCheck.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpPortMigrationCheck.setDescription('Force the specified port to transmit RSTP or MSTP BPDUs. Supported values: false(0) - BPDUs are not to be transmitted. true(1) - BPDUs are to be transmitted A non-zero value indicates that BPDUs are to be sent on the specified port.')
hm2AgentStpCstConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8))
hm2AgentStpCstHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstHelloTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstHelloTime.setDescription('The MSTP root port hello time for the CIST.')
hm2AgentStpCstMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstMaxAge.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstMaxAge.setDescription('The MSTP root port max age for the CIST.')
hm2AgentStpCstRegionalRootId = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstRegionalRootId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstRegionalRootId.setDescription('The MSTP regional root identifier for the CIST.')
hm2AgentStpCstRegionalRootPathCost = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstRegionalRootPathCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstRegionalRootPathCost.setDescription('The MSTP regional root path cost for the CIST.')
hm2AgentStpCstRootFwdDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstRootFwdDelay.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstRootFwdDelay.setDescription('The MSTP root port forward delay for the CIST.')
hm2AgentStpCstBridgeFwdDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstBridgeFwdDelay.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstBridgeFwdDelay.setDescription('The MSTP bridge forward delay for the CIST. The default value is 15.')
hm2AgentStpCstBridgeHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstBridgeHelloTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstBridgeHelloTime.setDescription('The MSTP bridge hello time for the CIST. The default value is 2.')
hm2AgentStpCstBridgeHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstBridgeHoldTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstBridgeHoldTime.setDescription('The MSTP bridge hold time for the CIST.')
hm2AgentStpCstBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 40)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstBridgeMaxAge.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstBridgeMaxAge.setDescription('The MSTP bridge max age for the CIST. The default value is 20.')
hm2AgentStpCstBridgeMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(6, 40)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstBridgeMaxHops.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstBridgeMaxHops.setDescription('The MSTP bridge max hops for the CIST. The default value is 20.')
hm2AgentStpCstBridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstBridgePriority.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstBridgePriority.setDescription('The MSTP bridge priority for the CIST. The default value is 32768.')
hm2AgentStpCstBridgeHoldCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 8, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 40)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstBridgeHoldCount.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstBridgeHoldCount.setDescription('The MSTP bridge hold count for the CIST. This command sets the value of maximum bpdus that a bridge is allowed to send within a hello time window. The default value is 10.')
hm2AgentStpCstPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9), )
if mibBuilder.loadTexts: hm2AgentStpCstPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortTable.setDescription('CIST port table.')
hm2AgentStpCstPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentStpCstPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortEntry.setDescription('CIST port entry.')
hm2AgentStpCstPortOperEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 1), HmEnabledStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstPortOperEdge.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortOperEdge.setDescription('The MSTP operational status of a specific port for the CIST.')
hm2AgentStpCstPortOperPointToPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstPortOperPointToPoint.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortOperPointToPoint.setDescription('The MSTP operational point to point mac of a specific port for the CIST.')
hm2AgentStpCstPortTopologyChangeAck = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstPortTopologyChangeAck.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortTopologyChangeAck.setDescription('The MSTP topology change acknowledge for a specific port in the CIST.')
hm2AgentStpCstPortEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 4), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortEdge.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortEdge.setDescription('The administrative state of a specific port in CIST. enable(1) - enables the port. disable(2) - disables the port. The default port state is disabled.')
hm2AgentStpCstPortForwardingState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("discarding", 1), ("learning", 2), ("forwarding", 3), ("disabled", 4), ("manualFwd", 5), ("notParticipate", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstPortForwardingState.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortForwardingState.setDescription('The MSTP forwarding state of a specific port in CIST.')
hm2AgentStpCstPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstPortId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortId.setDescription('The MSTP port identifier of a specific port in CIST.')
hm2AgentStpCstPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortPathCost.setDescription('The MSTP port path cost in CIST. The default value will correspond to the recommendation specified in IEEE 802.1s Table 13-2 which varies depending upon link speed.')
hm2AgentStpCstPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortPriority.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortPriority.setDescription('The MSTP port priority in CIST. The priority is in the increments of 16. The default value is 128.')
hm2AgentStpCstDesignatedBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstDesignatedBridgeId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstDesignatedBridgeId.setDescription('The MSTP designated bridge ID of a specific port in CIST.')
hm2AgentStpCstDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstDesignatedCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstDesignatedCost.setDescription('The MSTP designated cost of a specific port in CIST.')
hm2AgentStpCstDesignatedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstDesignatedPortId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstDesignatedPortId.setDescription('The MSTP designated port ID of a specific port in CIST.')
hm2AgentStpCstExtPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstExtPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstExtPortPathCost.setDescription('The MSTP external port path cost in CIST. The default value varies depending upon the link speed.')
hm2AgentStpCstPortBpduGuardEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 13), HmEnabledStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstPortBpduGuardEffect.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortBpduGuardEffect.setDescription('BPDU Guard Mode effect on the port. enable(1) - BPDU Guard Mode is enabled on the port. disable(2) - BPDU Guard Mode is disabled on the port.')
hm2AgentStpCstPortBpduFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 14), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortBpduFilter.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortBpduFilter.setDescription('This command sets BPDU Filter mode on the port. enable(1) - BPDU Filter Mode is enabled on the port. disable(2) - BPDU Filter Mode is disabled on the port.')
hm2AgentStpCstPortBpduFlood = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 15), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortBpduFlood.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortBpduFlood.setDescription('This command sets BPDU Flood mode on the port. enable(1) - BPDU Flood Mode is enabled on the port. disable(2) - BPDU Flood Mode is disabled on the port.')
hm2AgentStpCstPortAutoEdge = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 16), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortAutoEdge.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortAutoEdge.setDescription('This command sets the auto-edge mode of the port which enables it to become an edge port if it does not see BPDUs for some duration. enable(1) - enables the auto-edge mode for the port. disable(2) - disables the auto-edge mode for the port. The default auto-edge mode is enabled.')
hm2AgentStpCstPortRootGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 17), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortRootGuard.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortRootGuard.setDescription('This command sets a port to discard any superior information received by the port and thus protect against root of the device from changing.The port gets put into discarding state and does not forward any packets. enable(1) - enables the root guard mode for the port. disable(2) - disables the root guard mode for the port. The default root guard mode is disabled.')
hm2AgentStpCstPortTCNGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 18), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortTCNGuard.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortTCNGuard.setDescription('This command restricts the port from propagating any topology change information received through that port. enable(1) - enables the TCN guard mode for the port. disable(2) - disables the TCN guard mode for the port. The default TCN guard mode is disabled.')
hm2AgentStpCstPortLoopGuard = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 9, 1, 19), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpCstPortLoopGuard.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstPortLoopGuard.setDescription('This command enables loop guard on this port. This setting applies to all Spanning Tree instances of which this port is a member. enable(1) - enables the loop guard mode for the port. disable(2) - disables the loop guard mode for the port. The default loop guard mode is disabled.')
hm2AgentStpMstTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10), )
if mibBuilder.loadTexts: hm2AgentStpMstTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstTable.setDescription('MST table.')
hm2AgentStpMstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpMstId"))
if mibBuilder.loadTexts: hm2AgentStpMstEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstEntry.setDescription('MST entry.')
hm2AgentStpMstId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstId.setDescription('The MSTP instance ID.')
hm2AgentStpMstBridgePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpMstBridgePriority.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstBridgePriority.setDescription('The MSTP bridge priority in a specific instance. The priority is in the increments of 4096. The recommended default value is 32768.')
hm2AgentStpMstBridgeIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstBridgeIdentifier.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstBridgeIdentifier.setDescription('The MSTP bridge identifier in a specific instance.')
hm2AgentStpMstDesignatedRootId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstDesignatedRootId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstDesignatedRootId.setDescription('The MSTP designated root bridge identifier in a specific instance.')
hm2AgentStpMstRootPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstRootPathCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstRootPathCost.setDescription('The MSTP root path cost in a specific instance.')
hm2AgentStpMstRootPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstRootPortId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstRootPortId.setDescription('The MSTP root port ID in a specific instance.')
hm2AgentStpMstTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstTimeSinceTopologyChange.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstTimeSinceTopologyChange.setDescription('The MSTP time since the last topology change in a specific instance.')
hm2AgentStpMstTopologyChangeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstTopologyChangeCount.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstTopologyChangeCount.setDescription('The MSTP count of topology changes in a specific instance.')
hm2AgentStpMstTopologyChangeParm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstTopologyChangeParm.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstTopologyChangeParm.setDescription('The MSTP topology change parameter in a specific instance.')
hm2AgentStpMstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 10, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStpMstRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstRowStatus.setDescription('The MSTP instance status. Supported values: active(1) - valid instance. notReady(3) - row has incomplete values. createAndGo(4) - used to create a new instance. destroy(6) - removes an instance.')
hm2AgentStpMstPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11), )
if mibBuilder.loadTexts: hm2AgentStpMstPortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortTable.setDescription('MST port table.')
hm2AgentStpMstPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpMstId"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentStpMstPortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortEntry.setDescription('MST port entry.')
hm2AgentStpMstPortForwardingState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("discarding", 1), ("learning", 2), ("forwarding", 3), ("disabled", 4), ("manualFwd", 5), ("notParticipate", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortForwardingState.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortForwardingState.setDescription('The MSTP forwarding state of a specific port in a specific instance.')
hm2AgentStpMstPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortId.setDescription('The MSTP port identifier of a specific port in a specific instance.')
hm2AgentStpMstPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpMstPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortPathCost.setDescription('The MSTP port path cost in a specific instance. The default value will correspond to the recommendation specified in IEEE 802.1s Table 13-2 which varies depending upon link speed.')
hm2AgentStpMstPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpMstPortPriority.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortPriority.setDescription('The MSTP port priority in a specific instance. The priority is in the increments of 16. The default value is 128.')
hm2AgentStpMstDesignatedBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstDesignatedBridgeId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstDesignatedBridgeId.setDescription('The MSTP designated bridge ID of a specific port in a specific instance.')
hm2AgentStpMstDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstDesignatedCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstDesignatedCost.setDescription('The MSTP designated cost of a specific port in a specific instance.')
hm2AgentStpMstDesignatedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstDesignatedPortId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstDesignatedPortId.setDescription('The MSTP designated port ID of a specific port in a specific instance.')
hm2AgentStpMstPortLoopInconsistentState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortLoopInconsistentState.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortLoopInconsistentState.setDescription('The loop inconsistent state of a specific port in a specific instance. This value can only report as true(1) when loop guard is enabled on the port and the port has transitioned from blocking state in this MST instance.')
hm2AgentStpMstPortTransitionsIntoLoopInconsistentState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortTransitionsIntoLoopInconsistentState.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortTransitionsIntoLoopInconsistentState.setDescription('The number of times this interface has transitioned into loop inconsistent state.')
hm2AgentStpMstPortTransitionsOutOfLoopInconsistentState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortTransitionsOutOfLoopInconsistentState.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortTransitionsOutOfLoopInconsistentState.setDescription('The number of times this interface has transitioned out of loop inconsistent state.')
hm2AgentStpMstPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 248), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("root", 1), ("alternate", 2), ("designated", 3), ("backup", 4), ("master", 5), ("disabled", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortRole.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortRole.setDescription('The current port pole for a specific port (i.e., root, alternate, designated or backup) in a specific instance.')
hm2AgentStpCstAutoPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 249), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpCstAutoPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstAutoPortPathCost.setDescription('The Spanning Tree auto port path cost. If the value is true, the port path cost will be calculated depending on link speed corresponding to the recommendation specified in IEEE 802.1s Table 13-2 which varies depending upon link speed.')
hm2AgentStpMstPortReceivedBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 250), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortReceivedBridgeId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortReceivedBridgeId.setDescription('The received bridge ID on a specific port in a specific instance.')
hm2AgentStpMstPortReceivedRPC = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 251), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortReceivedRPC.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortReceivedRPC.setDescription('The received root path cost of a specific port in a specific instance.')
hm2AgentStpMstPortReceivedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 252), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortReceivedPortId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortReceivedPortId.setDescription('The received port ID on a specific port in a specific instance.')
hm2AgentStpMstAutoPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 253), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstAutoPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstAutoPortPathCost.setDescription('The Spanning Tree auto port path cost of a given instance. If the value is true, the port path cost will be calculated depending on link speed corresponding to the recommendation specified in IEEE 802.1s Table 13-2 which varies depending upon link speed.')
hm2AgentStpMstPortReceivedRegionalRPC = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 11, 1, 254), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStpMstPortReceivedRegionalRPC.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstPortReceivedRegionalRPC.setDescription('The received regional (internal) root path cost of a specific port in a specific instance.')
hm2AgentStpMstVlanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 12), )
if mibBuilder.loadTexts: hm2AgentStpMstVlanTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstVlanTable.setDescription('MST VLAN table.')
hm2AgentStpMstVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 12, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpMstId"), (0, "Q-BRIDGE-MIB", "dot1qVlanIndex"))
if mibBuilder.loadTexts: hm2AgentStpMstVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstVlanEntry.setDescription('MST VLAN entry.')
hm2AgentStpMstVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 12, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStpMstVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstVlanRowStatus.setDescription("The association status of an MSTP instance and a VLAN. Supported values: active(1) - valid association between an MSTP instance and a VLAN. notReady(3) - inconsistent values for the the association between an MSTP instance and a VLAN (VLAN it's not created or version is not MSTP). createAndGo(4) - used to create a new association between an MSTP instance and a VLAN. destroy(6) - removes the association between an MSTP instance and a VLAN.")
hm2AgentStpBpduGuardMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 13), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpBpduGuardMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpBpduGuardMode.setDescription('The spanning tree BPDU Guard Mode. enable(1) - enables BPDU Guard Mode on the switch. disable(2) - disables BPDU Guard Mode on the switch. The default status is disabled.')
hm2AgentStpBpduFilterDefault = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 14), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpBpduFilterDefault.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpBpduFilterDefault.setDescription('The spanning tree BPDU Filter Mode, it enables BPDU Filter on all edge ports. enable(1) - enables BPDU Filter Mode on the switch. disable(2) - disables BPDU Filter Mode on the switch. The default status is disabled.')
hm2AgentStpRingOnlyMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 248), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpRingOnlyMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpRingOnlyMode.setDescription('When RSTP Ring Only Mode is enabled the switch ignores the BPDUs age on Ring Only Mode ports. The topology change BPDUs sent on Ring Only Mode ports will have a message age of 1. enable(1) - enables RSTP Ring Only Mode globally. disable(2) - disables RSTP Ring Only Mode globally. The default status is disabled.')
hm2AgentStpRingOnlyModeIntfOne = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 249), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpRingOnlyModeIntfOne.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpRingOnlyModeIntfOne.setDescription('Interface index of the first interface.')
hm2AgentStpRingOnlyModeIntfTwo = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 250), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentStpRingOnlyModeIntfTwo.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpRingOnlyModeIntfTwo.setDescription('Interface index of the second interface.')
hm2AgentStpMstSNMPExtensionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 260))
hm2AgentStpMstInstanceVlanErrorReturn = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 260, 1))
if mibBuilder.loadTexts: hm2AgentStpMstInstanceVlanErrorReturn.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstInstanceVlanErrorReturn.setDescription('Invalid value for instance. Instance 0 is a system managed instance and the user should not modify it.')
hm2AgentStpCstFwdDelayErrorReturn = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 260, 2))
if mibBuilder.loadTexts: hm2AgentStpCstFwdDelayErrorReturn.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpCstFwdDelayErrorReturn.setDescription('Invalid value combination for Max Age/Forward Delay.')
hm2AgentStpMstSwitchVersionConflict = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 15, 260, 3))
if mibBuilder.loadTexts: hm2AgentStpMstSwitchVersionConflict.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStpMstSwitchVersionConflict.setDescription('Cannot switch version while spanning-tree is disabled.')
hm2AgentClassOfServiceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 17))
hm2AgentClassOfServicePortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 17, 1), )
if mibBuilder.loadTexts: hm2AgentClassOfServicePortTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentClassOfServicePortTable.setDescription('A table that contains information about the 802.1p priority mapping to traffic class priority queue for every physical port.')
hm2AgentClassOfServicePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 17, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentClassOfServicePortPriority"))
if mibBuilder.loadTexts: hm2AgentClassOfServicePortEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentClassOfServicePortEntry.setDescription('A 802.1p priority mapped to a traffic class priority queue.')
hm2AgentClassOfServicePortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: hm2AgentClassOfServicePortPriority.setStatus('current')
if mibBuilder.loadTexts: hm2AgentClassOfServicePortPriority.setDescription('The Priority value determined for the received frame. This value is equivalent to the priority indicated in the tagged frame received, or one of the evaluated priorities, determined according to the media type. For untagged frames received from Ethernet media, this value is equal to the dot1dPortDefaultUserPriority value for the ingress port.')
hm2AgentClassOfServicePortClass = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentClassOfServicePortClass.setStatus('current')
if mibBuilder.loadTexts: hm2AgentClassOfServicePortClass.setDescription('Traffic class priority queue the received frame is mapped to.')
hm2AgentSystemGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 3))
hm2AgentClearVlan = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 3, 9), HmEnabledStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentClearVlan.setStatus('current')
if mibBuilder.loadTexts: hm2AgentClearVlan.setDescription('clear vlan entries')
hm2AgentDaiConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21))
hm2AgentDaiSrcMacValidate = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiSrcMacValidate.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiSrcMacValidate.setDescription("This object indicates whether Sender MAC validation in the ARP packets is enabled. If this object is set to 'true', validation is enabled. If this object is set to 'false', validation is disabled.")
hm2AgentDaiDstMacValidate = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiDstMacValidate.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiDstMacValidate.setDescription("This object indicates whether Target MAC validation in the ARP Response packets is enabled. If this object is set to 'true', validation is enabled. If this object is set to 'false', validation is disabled.")
hm2AgentDaiIPValidate = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiIPValidate.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiIPValidate.setDescription("This object indicates whether IP address validation in the ARP packets is enabled. If this object is set to 'true', validation is enabled. If this object is set to 'false', validation is disabled.")
hm2AgentDaiVlanConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 4), )
if mibBuilder.loadTexts: hm2AgentDaiVlanConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanConfigTable.setDescription('A table provides the mechanism to control Dynamic ARP Inspection per VLAN. When a VLAN is created in a device supporting this table, a corresponding entry of this table will be added.')
hm2AgentDaiVlanConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 4, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDaiVlanIndex"))
if mibBuilder.loadTexts: hm2AgentDaiVlanConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanConfigEntry.setDescription('A row instance contains the configuration for Dynamic ARP Inspection at each existing VLAN.')
hm2AgentDaiVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 4, 1, 1), VlanIndex())
if mibBuilder.loadTexts: hm2AgentDaiVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanIndex.setDescription('This object indicates the VLAN number on which Dynamic ARP Inspection feature is configured.')
hm2AgentDaiVlanDynArpInspEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 4, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiVlanDynArpInspEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanDynArpInspEnable.setDescription("This object indicates whether Dynamic ARP Inspection is enabled in this VLAN. If this object is set to 'true', Dynamic ARP Inspection is enabled. If this object is set to 'false', Dynamic ARP Inspection is disabled.")
hm2AgentDaiVlanLoggingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 4, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiVlanLoggingEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanLoggingEnable.setDescription("This object indicates whether the Dynamic ARP Inspection logging is enabled on this VlAN. If this object is set to 'true', Dynamic ARP Inspection logging is enabled. If this object is set to 'false', Dynamic ARP Inspection loging is disabled.")
hm2AgentDaiVlanArpAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiVlanArpAclName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanArpAclName.setDescription("This object indicates the ARP ACL name set for this VLAN. Notice that the ACL is regarded only if the corresponding row in 'agentArpAclTable' is active.")
hm2AgentDaiVlanArpAclStaticFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 4, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiVlanArpAclStaticFlag.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanArpAclStaticFlag.setDescription("If an ARP ACL is defined for the VLAN and there is no match for the received ARP packet, the further proceeding depends on this MIB object. If it is 'true', then the packet is dropped, otherwise the packet is checked against the DHCP snooping bindings database (optional, see 'hm2AgentDaiVlanBindingCheckEnable'). If there is no match in the bindings database too, the packet is dropped.")
hm2AgentDaiVlanBindingCheckEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 4, 1, 248), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiVlanBindingCheckEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanBindingCheckEnable.setDescription('If enabled, the ARP frame received on an untrusted port (in a DAI enabled VLAN) is checked against the ARP ACL and the DHCP Snooping bindings database. If disabled it is only checked against the ARP ACL.')
hm2AgentDaiStatsReset = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiStatsReset.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiStatsReset.setDescription('Clear the DAI statistics on all vlans. A value of reset(1) is used to reset the statistics. A read on this object will always return the value none(0). The value none(0) cannot be forcibly set by the administrator.')
hm2AgentDaiVlanStatsTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6), )
if mibBuilder.loadTexts: hm2AgentDaiVlanStatsTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanStatsTable.setDescription('A table provides the mechanism to control Dynamic ARP Inspection per VLAN. When a VLAN is created in a device supporting this table, a corresponding entry of this table will be added.')
hm2AgentDaiVlanStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDaiVlanStatsIndex"))
if mibBuilder.loadTexts: hm2AgentDaiVlanStatsEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanStatsEntry.setDescription('A row instance contains the Dynamic ARP Inspection statistics per VLAN.')
hm2AgentDaiVlanStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 1), VlanIndex())
if mibBuilder.loadTexts: hm2AgentDaiVlanStatsIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanStatsIndex.setDescription('This object indicates the VLAN number on which Dynamic ARP Inspection statistics are retrieved.')
hm2AgentDaiVlanPktsForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanPktsForwarded.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanPktsForwarded.setDescription('Number of valid ARP packets forwarded by DAI.')
hm2AgentDaiVlanPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanPktsDropped.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanPktsDropped.setDescription('Number of invalid ARP packets dropped by DAI.')
hm2AgentDaiVlanDhcpDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanDhcpDrops.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanDhcpDrops.setDescription('Number of ARP packets that were dropped by DAI as there is no matching DHCP Snooping binding entry found.')
hm2AgentDaiVlanDhcpPermits = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanDhcpPermits.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanDhcpPermits.setDescription('Number of ARP packets that were forwarded by DAI as there is a matching DHCP Snooping binding entry found.')
hm2AgentDaiVlanAclDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanAclDrops.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanAclDrops.setDescription('Number of ARP packets that were dropped by DAI as there is no matching ARP ACL rule found for this Vlan and the static flag is set on this vlan.')
hm2AgentDaiVlanAclPermits = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanAclPermits.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanAclPermits.setDescription('Number of ARP packets that were permitted by DAI as there is a matching ARP ACL rule found for this Vlan.')
hm2AgentDaiVlanSrcMacFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanSrcMacFailures.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanSrcMacFailures.setDescription("Number of ARP packets that were dropped by DAI as the sender mac address in ARP packet didn't match the source mac in ethernet header.")
hm2AgentDaiVlanDstMacFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanDstMacFailures.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanDstMacFailures.setDescription("Number of ARP packets that were dropped by DAI as the target mac address in ARP reply packet didn't match the destination mac in ethernet header.")
hm2AgentDaiVlanIpValidFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDaiVlanIpValidFailures.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiVlanIpValidFailures.setDescription('Number of ARP packets that were dropped by DAI as the sender IP address in ARP packet or target IP address in ARP reply packet is invalid. Invalid addresses include 0.0.0.0, 255.255.255.255, IP multicast addresses, class E addresses (240.0.0.0/4), loopback addresses (127.0.0.0/8).')
hm2AgentDaiIfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 7), )
if mibBuilder.loadTexts: hm2AgentDaiIfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiIfConfigTable.setDescription('A table provides the mechanism to configure the trust state for Dynamic ARP Inspection purpose at each physical interface capable of this feature.')
hm2AgentDaiIfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentDaiIfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiIfConfigEntry.setDescription('A row instance contains the configuration for Dynamic ARP Inspection at each physical interface capable of this feature.')
hm2AgentDaiIfTrustEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 7, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiIfTrustEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiIfTrustEnable.setDescription("This object indicates whether the interface is trusted for Dynamic ARP Inspection purpose. If this object is set to 'true', the interface is trusted. ARP packets coming to this interface will be forwarded without checking. If this object is set to 'false', the interface is not trusted. ARP packets coming to this interface will be subjected to ARP inspection.")
hm2AgentDaiIfRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 300), )).clone(-1)).setUnits('packets per second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiIfRateLimit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiIfRateLimit.setDescription('This object indicates rate limit value for Dynamic ARP Inspection purpose. If the incoming rate of ARP packets exceeds the value of this object for consecutively burst interval seconds, ARP packets will be dropped. Value of -1 indicates that there is no rate limit.')
hm2AgentDaiIfBurstInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 7, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiIfBurstInterval.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiIfBurstInterval.setDescription('This object indicates the burst interval value for rate limiting purpose on this interface.')
hm2AgentDaiIfAutoDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 21, 7, 1, 248), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDaiIfAutoDisable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDaiIfAutoDisable.setDescription('This object indicates whether a port is auto-disabled when the configured ARP threshold is exceeded.')
hm2AgentArpAclGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22))
hm2AgentArpAclTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 1), )
if mibBuilder.loadTexts: hm2AgentArpAclTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclTable.setDescription('A table of the ARP ACL entries')
hm2AgentArpAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentArpAclName"))
if mibBuilder.loadTexts: hm2AgentArpAclEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclEntry.setDescription('Represents entry for an ARP ACL')
hm2AgentArpAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentArpAclName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclName.setDescription('Name of the ARP ACL, which must consist of 1 to 31 alphanumeric characters and uniquely identify this ARP ACL. This object must be set to complete a new ARP ACL row instance.')
hm2AgentArpAclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentArpAclRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclRowStatus.setDescription('The status of this conceptual row. Entries can not be deleted until all rows in arpAclRuleTable with corresponding values of arpAclIndex have been deleted. active(1) - This ACL instance is active. notInService(2) - Row has been suspended. notReady(3) - Row has incomplete values. createAndGo(4) - Accept row values and activate. createAndWait(5) - Accept row values and wait. destroy(6) - Set to this value to delete this instance.')
hm2AgentArpAclRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 2), )
if mibBuilder.loadTexts: hm2AgentArpAclRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclRuleTable.setDescription('A table of the ARP ACL Rule entries')
hm2AgentArpAclRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 2, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentArpAclName"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentArpAclRuleMatchSenderIpAddr"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentArpAclRuleMatchSenderMacAddr"))
if mibBuilder.loadTexts: hm2AgentArpAclRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclRuleEntry.setDescription('Represents entry for a set of ARP ACL-match rules')
hm2AgentArpAclRuleMatchSenderIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 2, 1, 1), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentArpAclRuleMatchSenderIpAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclRuleMatchSenderIpAddr.setDescription('Sender IP address match value for the ARP ACL. This address must be a unicast address unequal to 0.0.0.0.')
hm2AgentArpAclRuleMatchSenderMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 2, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentArpAclRuleMatchSenderMacAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclRuleMatchSenderMacAddr.setDescription('Sender MAC address match value for the ARP ACL. This address must be a unicast address unequal to 00:0:00:00:00:00.')
hm2AgentArpAclRuleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 22, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentArpAclRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpAclRuleRowStatus.setDescription('The status of this conceptual row. active(1) - This ACL Rule is active. notInService(2) - Row has been suspended. notReady(3) - Row has incomplete values. createAndGo(4) - Accept row values and activate. createAndWait(5) - Accept row values and wait. destroy(6) - Set to this value to delete an instance.')
hm2AgentDhcpSnoopingConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23))
hm2AgentDhcpSnoopingAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingAdminMode.setDescription("This object indicates whether DHCP Snooping is enabled globally. If this object is set to 'true',admin mode is enabled globally. If this object is set to 'false',admin mode is disabled globally.")
hm2AgentDhcpSnoopingVerifyMac = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVerifyMac.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVerifyMac.setDescription("This object indicates whether source Mac address in the received DHCP Message needs to be verified or not. If this object is set to 'true',verifyMac is enabled globally. If this object is set to 'false',verifyMac is disabled globally.")
hm2AgentDhcpSnoopingVlanConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 3), )
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVlanConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVlanConfigTable.setDescription('A table provides the mechanism to control DHCP SNOOPING per VLAN. When a VLAN is created in a device supporting this table, a corresponding entry of this table will be added.')
hm2AgentDhcpSnoopingVlanConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 3, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDhcpSnoopingVlanIndex"))
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVlanConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVlanConfigEntry.setDescription('A row instance contains the configuration for DHCP SNOOPING at each existing VLAN.')
hm2AgentDhcpSnoopingVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 3, 1, 1), VlanIndex())
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVlanIndex.setDescription('This object indicates the VLAN number on which DHCP SNOOPING Inspection feature is configured.')
hm2AgentDhcpSnoopingVlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 3, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVlanEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingVlanEnable.setDescription("This object indicates whether DHCP SNOOPING is enabled in this VLAN. If this object is set to 'true', DHCP SNOOPING is enabled. If this object is set to 'false', DHCP SNOOPING is disabled.")
hm2AgentDhcpSnoopingIfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 4), )
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfConfigTable.setDescription('A table provides the mechanism to configure the trust state for DHCP snooping purpose at each physical interface capable of this feature.')
hm2AgentDhcpSnoopingIfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfConfigEntry.setDescription('A row instance contains the configuration for DHCP snooping at each physical interface capable of this feature.')
hm2AgentDhcpSnoopingIfTrustEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 4, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfTrustEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfTrustEnable.setDescription('This object indicates whether the interface is trusted for DHCP snooping purpose.')
hm2AgentDhcpSnoopingIfLogEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 4, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfLogEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfLogEnable.setDescription('This object indicates whether the Logging needs on DHCP snooping validations or not')
hm2AgentDhcpSnoopingIfRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 150), )).clone(-1)).setUnits('packets per second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfRateLimit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfRateLimit.setDescription('This object indicates rate limit value for DHCP Snooping purpose. If the incoming rate of DHCP packets exceeds the value of this object for consecutively burst interval seconds, DHCP packets will be dropped. Value of -1 indicates that there is no rate limit.')
hm2AgentDhcpSnoopingIfBurstInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfBurstInterval.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfBurstInterval.setDescription('This object indicates the burst interval value for rate limiting purpose on this interface.')
hm2AgentDhcpSnoopingIfAutoDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 4, 1, 248), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfAutoDisable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingIfAutoDisable.setDescription('This object indicates whether a port is auto-disabled when the configured threshold is reached.')
hm2AgentIpsgIfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 5), )
if mibBuilder.loadTexts: hm2AgentIpsgIfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIpsgIfConfigTable.setDescription('A table provides the mechanism to configure the IPSG at each physical interface capable of this feature.')
hm2AgentIpsgIfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentIpsgIfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIpsgIfConfigEntry.setDescription('A row instance contains the configuration for IPSG at each physical interface capable of this feature.')
hm2AgentIpsgIfVerifySource = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 5, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentIpsgIfVerifySource.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIpsgIfVerifySource.setDescription('This object indicates whether IP packets received on this interface are filtered based on whether IP Source Guard considers the source IP address to be a valid client address. Setting this variable to false automatically sets hm2AgentIpsgIfPortSecurity to false.')
hm2AgentIpsgIfPortSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 5, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentIpsgIfPortSecurity.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIpsgIfPortSecurity.setDescription('This object indicates whether IP packets received on this interface are filtered based on whether IP Source Guard considers the source MAC address to be a valid client address. The port security option cannot be enabled unless hm2AgentIpsgIfVerifySource is also enabled. That is, MAC address filtering cannot be done without also doing IP address filtering. But IP address filtering can be done without MAC address filtering. Once the port security option is enabled, it can only be disabled by disabling hm2AgentIpsgIfVerifySource.')
hm2AgentDhcpSnoopingStatsReset = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingStatsReset.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingStatsReset.setDescription('Clear the DHCP snooping statistics on all ports. A value of reset(1) is used to reset the statistics. A read on this object will always return the value none(0). The value none(0) cannot be forcibly set by the administrator.')
hm2AgentDhcpSnoopingStatsTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 7), )
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingStatsTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingStatsTable.setDescription('A table provides the mechanism for statics of DHCP snooping.')
hm2AgentDhcpSnoopingStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingStatsEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingStatsEntry.setDescription('A row instance contains the DHCP snooping statistics per VLAN.')
hm2AgentDhcpSnoopingMacVerifyFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingMacVerifyFailures.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingMacVerifyFailures.setDescription('This object indicates the number of failure verifications of client mac address with source mac address')
hm2AgentDhcpSnoopingInvalidClientMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingInvalidClientMessages.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingInvalidClientMessages.setDescription('This object indicates the number of invalid DHCP releases and deny messages')
hm2AgentDhcpSnoopingInvalidServerMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingInvalidServerMessages.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingInvalidServerMessages.setDescription('This object indicates the number of invalid DHCP server mesaages')
hm2AgentStaticIpsgBindingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 8), )
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingTable.setDescription('A table of the IPSG static entries')
hm2AgentStaticIpsgBindingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 8, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStaticIpsgBindingIfIndex"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStaticIpsgBindingVlanId"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStaticIpsgBindingMacAddr"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStaticIpsgBindingIpAddr"))
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingEntry.setDescription('Represents a binding in IPSG table')
hm2AgentStaticIpsgBindingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 8, 1, 1), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingIfIndex.setDescription('Interface on which this IPSG binding is going to be added.')
hm2AgentStaticIpsgBindingVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 8, 1, 2), VlanIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingVlanId.setDescription(' VLAN to which this IPSG binding is going to be added.')
hm2AgentStaticIpsgBindingMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 8, 1, 3), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingMacAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingMacAddr.setDescription('MAC address match value for the IPSG Binding. This address must be a unicast address unequal to 00:0:00:00:00:00.')
hm2AgentStaticIpsgBindingIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 8, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingIpAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingIpAddr.setDescription('IP address match value for the IPSG Binding. This address must be a unicast address unequal to 0.0.0.0.')
hm2AgentStaticIpsgBindingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 8, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingRowStatus.setDescription('The status of this conceptual row. active(1) - This DHCP Snooping binding is active. notInService(2) - Row has been suspended. notReady(3) - Row has incomplete values. createAndGo(4) - Accept row values and activate. createAndWait(5) - Accept row values and wait. destroy(6) - Set to this value to remove this binding.')
hm2AgentStaticIpsgBindingHwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 8, 1, 248), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingHwStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticIpsgBindingHwStatus.setDescription('Set to true when Binding is applied to the Hardware')
hm2AgentDynamicIpsgBindingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 9), )
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingTable.setDescription('A table of the IPSG dynamic entries')
hm2AgentDynamicIpsgBindingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 9, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDynamicIpsgBindingIfIndex"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDynamicIpsgBindingVlanId"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDynamicIpsgBindingMacAddr"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDynamicIpsgBindingIpAddr"))
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingEntry.setDescription('Represents a binding in IPSG table')
hm2AgentDynamicIpsgBindingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 9, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingIfIndex.setDescription('Interface on which this IPSG binding is added.')
hm2AgentDynamicIpsgBindingVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 9, 1, 2), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingVlanId.setDescription(' VLAN to which this IPSG binding is going to be added.')
hm2AgentDynamicIpsgBindingMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 9, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingMacAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingMacAddr.setDescription('MAC address match value for the IPSG Binding.')
hm2AgentDynamicIpsgBindingIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 9, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingIpAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingIpAddr.setDescription('Sender IP address match value for the IPSG Binding.')
hm2AgentDynamicIpsgBindingHwStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 9, 1, 248), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingHwStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicIpsgBindingHwStatus.setDescription('Set to true when Binding is applied to the Hardware')
hm2AgentStaticDsBindingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 10), )
if mibBuilder.loadTexts: hm2AgentStaticDsBindingTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticDsBindingTable.setDescription('A table of the DHCP SNOOPING static entries')
hm2AgentStaticDsBindingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 10, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStaticDsBindingMacAddr"))
if mibBuilder.loadTexts: hm2AgentStaticDsBindingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticDsBindingEntry.setDescription('Represents a binding in DHCP SNOOPING table')
hm2AgentStaticDsBindingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 10, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticDsBindingIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticDsBindingIfIndex.setDescription('Interface on which this DHCP SNOOPING binding is going to be added.')
hm2AgentStaticDsBindingVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 10, 1, 2), VlanId().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticDsBindingVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticDsBindingVlanId.setDescription('VLAN to which this DHCP SNOOPING binding is going to be added.')
hm2AgentStaticDsBindingMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 10, 1, 3), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticDsBindingMacAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticDsBindingMacAddr.setDescription('MAC address match value for the DHCP SNOOPING Binding. This address must be a unicast address unequal to 00:0:00:00:00:00.')
hm2AgentStaticDsBindingIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticDsBindingIpAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticDsBindingIpAddr.setDescription('IP address match value for the DHCP SNOOPING Binding. This address must be a unicast address unequal to 0.0.0.0.')
hm2AgentStaticDsBindingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 10, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentStaticDsBindingRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentStaticDsBindingRowStatus.setDescription('The status of this conceptual row. active(1) - This DHCP Snooping binding is active. notInService(2) - Row has been suspended. notReady(3) - Row has incomplete values. createAndGo(4) - Accept row values and activate. createAndWait(5) - Accept row values and wait. destroy(6) - Set to this value to remove this binding.')
hm2AgentDynamicDsBindingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 11), )
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingTable.setDescription('A table of the DHCP SNOOPING Dynamic entries')
hm2AgentDynamicDsBindingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 11, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDynamicDsBindingMacAddr"))
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingEntry.setDescription('Represents a binding in DHCP SNOOPING table')
hm2AgentDynamicDsBindingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 11, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingIfIndex.setDescription('Interface on which this DHCP SNOOPING binding is going to be added.')
hm2AgentDynamicDsBindingVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 11, 1, 2), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingVlanId.setDescription(' VLAN to which this DHCP SNOOPING binding is going to be added.')
hm2AgentDynamicDsBindingMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 11, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingMacAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingMacAddr.setDescription('MAC address match value for the DHCP SNOOPING Binding.')
hm2AgentDynamicDsBindingIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 11, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingIpAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingIpAddr.setDescription('IP address match value for the DHCP SNOOPING Binding.')
hm2AgentDynamicDsBindingLeaseRemainingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 11, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingLeaseRemainingTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDynamicDsBindingLeaseRemainingTime.setDescription('This specifies the period for which the DHCP SNOOPING Binding is valid.')
hm2AgentDhcpSnoopingRemoteFileName = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingRemoteFileName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingRemoteFileName.setDescription('This object indicates the file name on the remote machine to save the DHCP Snooping bindings.')
hm2AgentDhcpSnoopingRemoteIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 13), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingRemoteIpAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingRemoteIpAddr.setDescription('This object indicates the IP address of the remote machine to save the DHCP Snooping bindings. This will be set only when we have a valid file name.')
hm2AgentDhcpSnoopingStoreInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 23, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 86400)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingStoreInterval.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpSnoopingStoreInterval.setDescription('This object indicates the perodic time interval to save the (changed) DHCP Snooping bindings database.')
hm2AgentDhcpL2RelayConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24))
hm2AgentDhcpL2RelayAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayAdminMode.setDescription("This object indicates whether DHCP L2 Relay is enabled globally. If this object is set to 'true',admin mode is enabled globally. If this object is set to 'false',admin mode is disabled globally.")
hm2AgentDhcpL2RelayIfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 2), )
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayIfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayIfConfigTable.setDescription('A table provides the mechanism to enable/disable and configure the trust state for DHCP L2Relay purpose at each physical interface capable of this feature.')
hm2AgentDhcpL2RelayIfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayIfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayIfConfigEntry.setDescription('A row instance contains the configuration for DHCP L2 Relay at each physical interface capable of this feature.')
hm2AgentDhcpL2RelayIfEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 2, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayIfEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayIfEnable.setDescription('This object indicates whether the DHCP L2Relay is enabled or not')
hm2AgentDhcpL2RelayIfTrustEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 2, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayIfTrustEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayIfTrustEnable.setDescription('This object indicates whether the interface is trusted for DHCP L2 Relay purpose.')
hm2AgentDhcpL2RelayVlanConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 3), )
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanConfigTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanConfigTable.setDescription('A table provides the mechanism to control DHCP L2 Relay per VLAN. When a VLAN is created in a device supporting this table, a corresponding entry of this table will be added.')
hm2AgentDhcpL2RelayVlanConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 3, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentDhcpL2RelayVlanIndex"))
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanConfigEntry.setDescription('A row instance contains the configuration for DHCP L2 Relay at each existing VLAN.')
hm2AgentDhcpL2RelayVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 3, 1, 1), VlanIndex())
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanIndex.setDescription('This object indicates the VLAN number on which DHCP L2 Relay feature is configured.')
hm2AgentDhcpL2RelayVlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 3, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanEnable.setDescription("This object indicates whether DHCP L2 Relay is enabled in this VLAN. If this object is set to 'true', DHCP L2 Relay is enabled. If this object is set to 'false', DHCP L2 Relay is disabled.")
hm2AgentDhcpL2RelayCircuitIdVlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 3, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayCircuitIdVlanEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayCircuitIdVlanEnable.setDescription("This object indicates whether DHCP CircuitId is enabled for L2 relaying in this VLAN. If this object is set to 'true', DHCP CircuitId is enabled. If this object is set to 'false', DHCP CircuitId is disabled.")
hm2AgentDhcpL2RelayRemoteIdVlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayRemoteIdVlanEnable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayRemoteIdVlanEnable.setDescription("When this object is set with a non-empty string, DHCP RemoteId is enabled for L2 relaying in this VLAN. Notice that you can set this object only if hm2AgentDhcpL2RelayVlanRemoteIdType is 'other'.")
hm2AgentDhcpL2RelayVlanRemoteIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 3, 1, 248), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ip", 1), ("mac", 2), ("client-id", 3), ("other", 4))).clone('mac')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanRemoteIdType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayVlanRemoteIdType.setDescription('This option determines the content of the option 82 Remote ID. ip(1) - inserts the IP address mac(2) - inserts the MAC adress client-id(3) - inserts the client identifier (sysName) other(4) - inserts the value in hm2AgentDhcpL2RelayRemoteIdVlanEnable')
hm2AgentDhcpL2RelayStatsReset = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayStatsReset.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayStatsReset.setDescription('Clear the DHCP L2Relay statistics on all ports. A value of reset(1) is used to reset the statistics. A read on this object will always return the value none(0). The value none(0) cannot be forcibly set by the administrator.')
hm2AgentDhcpL2RelayStatsTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 7), )
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayStatsTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayStatsTable.setDescription('A table provides the mechanism for statics of DHCP L2 Relay.')
hm2AgentDhcpL2RelayStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayStatsEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayStatsEntry.setDescription('A row instance contains the DHCP L2Relay statistics per interface.')
hm2AgentDhcpL2RelayUntrustedSrvrMsgsWithOptn82 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayUntrustedSrvrMsgsWithOptn82.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayUntrustedSrvrMsgsWithOptn82.setDescription('This object indicates the number of DHCP server messages received with Option-82 field on the untrusted interface.')
hm2AgentDhcpL2RelayUntrustedClntMsgsWithOptn82 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayUntrustedClntMsgsWithOptn82.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayUntrustedClntMsgsWithOptn82.setDescription('This object indicates the number of DHCP client messages received with Option-82 field on the untrusted interface.')
hm2AgentDhcpL2RelayTrustedSrvrMsgsWithoutOptn82 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayTrustedSrvrMsgsWithoutOptn82.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayTrustedSrvrMsgsWithoutOptn82.setDescription('This object indicates the number of DHCP server messages received without Option-82 field on the trusted interface.')
hm2AgentDhcpL2RelayTrustedClntMsgsWithoutOptn82 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 24, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayTrustedClntMsgsWithoutOptn82.setStatus('current')
if mibBuilder.loadTexts: hm2AgentDhcpL2RelayTrustedClntMsgsWithoutOptn82.setDescription('This object indicates the number of DHCP client messages received without Option-82 field on the trusted interface.')
hm2AgentSwitchVoiceVLANGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 25))
hm2AgentSwitchVoiceVLANAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 25, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVLANAdminMode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVLANAdminMode.setDescription('This enables or disables Voice VLAN on the system.')
hm2AgentSwitchVoiceVlanDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 25, 2), )
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVlanDeviceTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVlanDeviceTable.setDescription('A table of the Voice Vlan device entries.')
hm2AgentSwitchVoiceVlanDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 25, 2, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchVoiceVlanInterfaceNum"), (0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSwitchVoiceVlanDeviceMacAddress"))
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVlanDeviceEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVlanDeviceEntry.setDescription('Represents entry for a Voice Device on the interface.')
hm2AgentSwitchVoiceVlanInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 25, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVlanInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVlanInterfaceNum.setDescription('The interface number of this interface.')
hm2AgentSwitchVoiceVlanDeviceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 25, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVlanDeviceMacAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSwitchVoiceVlanDeviceMacAddress.setDescription('The Voice Device Mac address')
hm2AgentSdmPreferConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 27))
hm2AgentSdmPreferCurrentTemplate = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 27, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 10, 11))).clone(namedValues=NamedValues(("ipv4RoutingDefault", 2), ("ipv4DataCenter", 3), ("ipv4RoutingUnicast", 10), ("ipv4RoutingMulticast", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentSdmPreferCurrentTemplate.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSdmPreferCurrentTemplate.setDescription(' Displays the current active SDM Template.')
hm2AgentSdmPreferNextTemplate = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 27, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 10, 11))).clone(namedValues=NamedValues(("default", 0), ("ipv4RoutingDefault", 2), ("ipv4DataCenter", 3), ("ipv4RoutingUnicast", 10), ("ipv4RoutingMulticast", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentSdmPreferNextTemplate.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSdmPreferNextTemplate.setDescription(' Configures the next active template. It will be active only after the next reboot. To revert to the default template after the next reboot, use the option default(0).')
hm2AgentSdmTemplateSummaryTable = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28))
hm2AgentSdmTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1), )
if mibBuilder.loadTexts: hm2AgentSdmTemplateTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSdmTemplateTable.setDescription('Displays Switch Database Management Template Information.')
hm2AgentSdmTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-SWITCHING-MIB", "hm2AgentSdmTemplateId"))
if mibBuilder.loadTexts: hm2AgentSdmTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSdmTemplateEntry.setDescription('Information about a SDM Template table entry.')
hm2AgentSdmTemplateId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 10, 11))).clone(namedValues=NamedValues(("ipv4RoutingDefault", 2), ("ipv4DataCenter", 3), ("ipv4RoutingUnicast", 10), ("ipv4RoutingMulticast", 11))))
if mibBuilder.loadTexts: hm2AgentSdmTemplateId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentSdmTemplateId.setDescription('The SDM Template type this instance is associated with.')
hm2AgentArpEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentArpEntries.setStatus('current')
if mibBuilder.loadTexts: hm2AgentArpEntries.setDescription('The maximum number of entries in the IPv4 Address Resolution Protocol (ARP) cache for routing interfaces.')
hm2AgentIPv4UnicastRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentIPv4UnicastRoutes.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIPv4UnicastRoutes.setDescription('The maximum number of IPv4 unicast forwarding table entries.')
hm2AgentIPv6NdpEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentIPv6NdpEntries.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIPv6NdpEntries.setDescription('The maximum number of IPv6 Neighbor Discovery Protocol (NDP) cache entries.')
hm2AgentIPv6UnicastRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentIPv6UnicastRoutes.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIPv6UnicastRoutes.setDescription('The maximum number of IPv6 unicast forwarding table entries.')
hm2AgentEcmpNextHops = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentEcmpNextHops.setStatus('current')
if mibBuilder.loadTexts: hm2AgentEcmpNextHops.setDescription('The maximum number of Equal cost next hops that can be installed in the IPv4 and IPv6 unicast forwarding tables.')
hm2AgentIPv4MulticastRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentIPv4MulticastRoutes.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIPv4MulticastRoutes.setDescription('The maximum number of IPv4 multicast forwarding table entries.')
hm2AgentIPv6MulticastRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 1, 2, 8, 28, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentIPv6MulticastRoutes.setStatus('current')
if mibBuilder.loadTexts: hm2AgentIPv6MulticastRoutes.setDescription('The maximum number of IPv6 multicast forwarding table entries.')
hm2PlatformSwitchingTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 1, 0))
hm2PlatformStpInstanceNewRootTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 1, 0, 10)).setObjects(("HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpMstId"))
if mibBuilder.loadTexts: hm2PlatformStpInstanceNewRootTrap.setStatus('current')
if mibBuilder.loadTexts: hm2PlatformStpInstanceNewRootTrap.setDescription('Trap is sent when this machine is a new STP Root when there is more than one STP instance.')
hm2PlatformStpInstanceTopologyChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 1, 0, 11)).setObjects(("HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpMstId"))
if mibBuilder.loadTexts: hm2PlatformStpInstanceTopologyChangeTrap.setStatus('current')
if mibBuilder.loadTexts: hm2PlatformStpInstanceTopologyChangeTrap.setDescription('Trap is sent when there is a STP topology change when there is more than one STP instance.')
hm2PlatformDaiIntfErrorDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 1, 0, 15)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2PlatformDaiIntfErrorDisabledTrap.setStatus('current')
if mibBuilder.loadTexts: hm2PlatformDaiIntfErrorDisabledTrap.setDescription('Trap is sent once an interface is error disabled by DAI when the incoming packet rate exceeded configured rate limit during a burst-interval.')
hm2PlatformStpInstanceLoopInconsistentStartTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 1, 0, 16)).setObjects(("HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpMstId"), ("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2PlatformStpInstanceLoopInconsistentStartTrap.setStatus('current')
if mibBuilder.loadTexts: hm2PlatformStpInstanceLoopInconsistentStartTrap.setDescription('Trap is sent when this port in this STP instance enters loop inconsistent state upon failure to receive a BPDU.')
hm2PlatformStpInstanceLoopInconsistentEndTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 1, 0, 17)).setObjects(("HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpMstId"), ("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2PlatformStpInstanceLoopInconsistentEndTrap.setStatus('current')
if mibBuilder.loadTexts: hm2PlatformStpInstanceLoopInconsistentEndTrap.setDescription('Trap is sent when this port in this STP instance exits loop inconsistent state upon reception of a BPDU.')
hm2PlatformDhcpSnoopingIntfErrorDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 1, 0, 18)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2PlatformDhcpSnoopingIntfErrorDisabledTrap.setStatus('current')
if mibBuilder.loadTexts: hm2PlatformDhcpSnoopingIntfErrorDisabledTrap.setDescription('Trap is sent once an interface is error disabled by DHCP Snooping when the incoming packet rate exceeded configured rate limit during a burst-interval.')
hm2PlatformStpCstBpduGuardTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 1, 0, 248)).setObjects(("IF-MIB", "ifIndex"), ("HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpCstPortEdge"), ("HM2-PLATFORM-SWITCHING-MIB", "hm2AgentStpCstPortBpduGuardEffect"))
if mibBuilder.loadTexts: hm2PlatformStpCstBpduGuardTrap.setStatus('current')
if mibBuilder.loadTexts: hm2PlatformStpCstBpduGuardTrap.setDescription('This trap is sent if on this port when the BPDU guard functionality is enabled (globally and for this port) and a (R)STP BPDU is received on this port. That means when hm2AgentStpCstPortBpduGuardEffect is set to enable(1) for this port. Then ifAdminStatus for this port is set to down(2).')
mibBuilder.exportSymbols("HM2-PLATFORM-SWITCHING-MIB", hm2AgentDhcpSnoopingInvalidServerMessages=hm2AgentDhcpSnoopingInvalidServerMessages, hm2AgentIPv4MulticastRoutes=hm2AgentIPv4MulticastRoutes, hm2AgentStpMstPortReceivedPortId=hm2AgentStpMstPortReceivedPortId, hm2AgentStpCstDesignatedPortId=hm2AgentStpCstDesignatedPortId, hm2AgentDhcpSnoopingIfConfigEntry=hm2AgentDhcpSnoopingIfConfigEntry, hm2PlatformStpInstanceLoopInconsistentEndTrap=hm2PlatformStpInstanceLoopInconsistentEndTrap, hm2AgentPortMirrorReset=hm2AgentPortMirrorReset, hm2AgentSwitchSnoopingIntfGroup=hm2AgentSwitchSnoopingIntfGroup, hm2AgentStpCstPortForwardingState=hm2AgentStpCstPortForwardingState, hm2AgentDaiVlanArpAclStaticFlag=hm2AgentDaiVlanArpAclStaticFlag, hm2AgentStpRingOnlyModeIntfTwo=hm2AgentStpRingOnlyModeIntfTwo, hm2AgentSwitchMFDBDescription=hm2AgentSwitchMFDBDescription, hm2AgentStpAdminMode=hm2AgentStpAdminMode, hm2AgentStpCstRootFwdDelay=hm2AgentStpCstRootFwdDelay, hm2AgentSwitchMFDBType=hm2AgentSwitchMFDBType, hm2AgentPortMirrorVlanRspanVlanConflict=hm2AgentPortMirrorVlanRspanVlanConflict, hm2AgentStpMstPortPathCost=hm2AgentStpMstPortPathCost, hm2AgentLagSummaryLinkTrap=hm2AgentLagSummaryLinkTrap, hm2AgentDhcpSnoopingVlanConfigEntry=hm2AgentDhcpSnoopingVlanConfigEntry, hm2AgentSwitchSnoopingQuerierAdminMode=hm2AgentSwitchSnoopingQuerierAdminMode, hm2AgentDaiVlanArpAclName=hm2AgentDaiVlanArpAclName, hm2PlatformStpInstanceLoopInconsistentStartTrap=hm2PlatformStpInstanceLoopInconsistentStartTrap, hm2AgentPortMirrorReflectorPortVlanConflict=hm2AgentPortMirrorReflectorPortVlanConflict, hm2AgentDhcpL2RelayIfConfigTable=hm2AgentDhcpL2RelayIfConfigTable, hm2AgentDaiVlanConfigEntry=hm2AgentDaiVlanConfigEntry, hm2AgentDaiConfigGroup=hm2AgentDaiConfigGroup, hm2AgentStpCstConfigGroup=hm2AgentStpCstConfigGroup, hm2AgentStpCstBridgePriority=hm2AgentStpCstBridgePriority, hm2AgentLagSummaryAdminMode=hm2AgentLagSummaryAdminMode, hm2AgentConfigGroup=hm2AgentConfigGroup, hm2AgentDaiDstMacValidate=hm2AgentDaiDstMacValidate, hm2AgentDynamicIpsgBindingIpAddr=hm2AgentDynamicIpsgBindingIpAddr, hm2AgentSwitchVoiceVLANGroup=hm2AgentSwitchVoiceVLANGroup, hm2AgentLagSummaryStatus=hm2AgentLagSummaryStatus, hm2AgentLagSummaryConfigEntry=hm2AgentLagSummaryConfigEntry, hm2AgentStpCstPortOperEdge=hm2AgentStpCstPortOperEdge, hm2AgentSwitchConfigGroup=hm2AgentSwitchConfigGroup, hm2AgentDaiSrcMacValidate=hm2AgentDaiSrcMacValidate, hm2AgentDhcpL2RelayIfConfigEntry=hm2AgentDhcpL2RelayIfConfigEntry, hm2AgentStpCstPortBpduGuardEffect=hm2AgentStpCstPortBpduGuardEffect, hm2AgentSwitchStaticMacFilteringStatus=hm2AgentSwitchStaticMacFilteringStatus, hm2AgentLagSummaryType=hm2AgentLagSummaryType, hm2AgentStpMstPortTransitionsIntoLoopInconsistentState=hm2AgentStpMstPortTransitionsIntoLoopInconsistentState, hm2AgentStaticDsBindingIfIndex=hm2AgentStaticDsBindingIfIndex, hm2AgentStpCstBridgeMaxAge=hm2AgentStpCstBridgeMaxAge, hm2AgentStaticIpsgBindingRowStatus=hm2AgentStaticIpsgBindingRowStatus, hm2AgentSwitchMFDBSummaryTable=hm2AgentSwitchMFDBSummaryTable, hm2AgentSwitchSnoopingVlanMRPExpirationTime=hm2AgentSwitchSnoopingVlanMRPExpirationTime, hm2AgentDaiVlanBindingCheckEnable=hm2AgentDaiVlanBindingCheckEnable, hm2AgentDhcpL2RelayAdminMode=hm2AgentDhcpL2RelayAdminMode, hm2AgentProtocolGroupPortIfIndex=hm2AgentProtocolGroupPortIfIndex, hm2AgentPortDot1dBasePort=hm2AgentPortDot1dBasePort, hm2AgentPortMaxFrameSize=hm2AgentPortMaxFrameSize, hm2AgentStpMstPortId=hm2AgentStpMstPortId, hm2AgentLagConfigCreate=hm2AgentLagConfigCreate, hm2AgentPortDot3FlowControlOperStatus=hm2AgentPortDot3FlowControlOperStatus, hm2AgentStpCstPortEdge=hm2AgentStpCstPortEdge, hm2AgentSwitchSnoopingVlanEntry=hm2AgentSwitchSnoopingVlanEntry, hm2AgentProtocolConfigGroup=hm2AgentProtocolConfigGroup, hm2AgentDynamicIpsgBindingTable=hm2AgentDynamicIpsgBindingTable, hm2AgentStaticDsBindingVlanId=hm2AgentStaticDsBindingVlanId, hm2AgentIPv6MulticastRoutes=hm2AgentIPv6MulticastRoutes, hm2AgentStpCstBridgeMaxHops=hm2AgentStpCstBridgeMaxHops, hm2AgentDhcpSnoopingAdminMode=hm2AgentDhcpSnoopingAdminMode, hm2AgentIpsgIfVerifySource=hm2AgentIpsgIfVerifySource, hm2AgentDhcpL2RelayConfigGroup=hm2AgentDhcpL2RelayConfigGroup, hm2AgentPortMirrorRspanVlanInconsistent=hm2AgentPortMirrorRspanVlanInconsistent, hm2AgentPortMirrorAllowMgmtMode=hm2AgentPortMirrorAllowMgmtMode, hm2AgentSwitchSnoopingIntfIndex=hm2AgentSwitchSnoopingIntfIndex, hm2AgentSwitchSnoopingPortMask=hm2AgentSwitchSnoopingPortMask, hm2AgentStpCstBridgeHoldTime=hm2AgentStpCstBridgeHoldTime, hm2AgentDaiVlanAclPermits=hm2AgentDaiVlanAclPermits, hm2AgentStpCstFwdDelayErrorReturn=hm2AgentStpCstFwdDelayErrorReturn, hm2AgentLagConfigGroupHashOption=hm2AgentLagConfigGroupHashOption, hm2AgentSdmTemplateId=hm2AgentSdmTemplateId, Ipv6IfIndexOrZero=Ipv6IfIndexOrZero, hm2AgentProtocolGroupProtocolEntry=hm2AgentProtocolGroupProtocolEntry, hm2AgentStpPortStatsStpBpduRx=hm2AgentStpPortStatsStpBpduRx, Ipv6AddressPrefix=Ipv6AddressPrefix, hm2AgentSwitchVlanStaticMrouterEntry=hm2AgentSwitchVlanStaticMrouterEntry, hm2AgentPortMirrorSourceVlan=hm2AgentPortMirrorSourceVlan, hm2AgentDot3adAggPortLACPMode=hm2AgentDot3adAggPortLACPMode, hm2AgentDhcpL2RelayStatsReset=hm2AgentDhcpL2RelayStatsReset, hm2AgentStpPortState=hm2AgentStpPortState, hm2AgentSwitchMFDBVlanId=hm2AgentSwitchMFDBVlanId, hm2AgentSwitchVlanStaticMrouterGroup=hm2AgentSwitchVlanStaticMrouterGroup, hm2AgentSwitchMFDBGroup=hm2AgentSwitchMFDBGroup, hm2AgentClassOfServiceGroup=hm2AgentClassOfServiceGroup, hm2AgentLagSummaryStpMode=hm2AgentLagSummaryStpMode, hm2AgentSwitchVlanMacAssociationEntry=hm2AgentSwitchVlanMacAssociationEntry, hm2AgentSwitchSnoopingQuerierVlanAdminMode=hm2AgentSwitchSnoopingQuerierVlanAdminMode, hm2AgentDaiVlanIndex=hm2AgentDaiVlanIndex, hm2AgentStpMstInstanceVlanErrorReturn=hm2AgentStpMstInstanceVlanErrorReturn, hm2AgentDaiVlanStatsEntry=hm2AgentDaiVlanStatsEntry, hm2AgentSwitchGmrpPortEntry=hm2AgentSwitchGmrpPortEntry, hm2AgentStpRingOnlyMode=hm2AgentStpRingOnlyMode, hm2AgentStpCstPortPriority=hm2AgentStpCstPortPriority, hm2AgentPortMulticastControlMode=hm2AgentPortMulticastControlMode, hm2AgentDhcpL2RelayRemoteIdVlanEnable=hm2AgentDhcpL2RelayRemoteIdVlanEnable, hm2AgentPortMirrorTypeType=hm2AgentPortMirrorTypeType, hm2AgentLagConfigGroupNumOfLagsConfigured=hm2AgentLagConfigGroupNumOfLagsConfigured, hm2AgentSwitchProtectedPortEntry=hm2AgentSwitchProtectedPortEntry, hm2AgentPortIfIndex=hm2AgentPortIfIndex, hm2AgentArpAclRuleTable=hm2AgentArpAclRuleTable, hm2AgentDhcpSnoopingVlanIndex=hm2AgentDhcpSnoopingVlanIndex, hm2AgentArpAclRuleEntry=hm2AgentArpAclRuleEntry, hm2AgentPortMirrorSourcePortDestinationPortConflict=hm2AgentPortMirrorSourcePortDestinationPortConflict, hm2AgentStpCstPortTopologyChangeAck=hm2AgentStpCstPortTopologyChangeAck, hm2AgentSwitchSnoopingQuerierVlanTable=hm2AgentSwitchSnoopingQuerierVlanTable, hm2AgentDynamicDsBindingIpAddr=hm2AgentDynamicDsBindingIpAddr, hm2AgentStpCstPortAutoEdge=hm2AgentStpCstPortAutoEdge, hm2AgentDaiVlanStatsIndex=hm2AgentDaiVlanStatsIndex, hm2AgentStpCstHelloTime=hm2AgentStpCstHelloTime, hm2AgentDaiIfConfigTable=hm2AgentDaiIfConfigTable, hm2AgentLagDetailedPortStatus=hm2AgentLagDetailedPortStatus, hm2AgentSwitchVlanSubnetAssociationRowStatus=hm2AgentSwitchVlanSubnetAssociationRowStatus, hm2AgentDhcpSnoopingIfConfigTable=hm2AgentDhcpSnoopingIfConfigTable, hm2AgentIpsgIfConfigEntry=hm2AgentIpsgIfConfigEntry, hm2AgentLagConfigGroup=hm2AgentLagConfigGroup, hm2AgentSwitchAddressAgingTimeoutTable=hm2AgentSwitchAddressAgingTimeoutTable, hm2AgentSwitchProtectedPortGroupId=hm2AgentSwitchProtectedPortGroupId, hm2AgentStpCstPortRootGuard=hm2AgentStpCstPortRootGuard, hm2AgentPortMirrorReflectorPort=hm2AgentPortMirrorReflectorPort, hm2AgentDaiVlanDhcpPermits=hm2AgentDaiVlanDhcpPermits, hm2AgentLagDetailedConfigTable=hm2AgentLagDetailedConfigTable, hm2AgentLagConfigGroupMaxNumPortsPerLag=hm2AgentLagConfigGroupMaxNumPortsPerLag, hm2AgentSwitchVlanMacAssociationTable=hm2AgentSwitchVlanMacAssociationTable, hm2AgentDhcpL2RelayUntrustedSrvrMsgsWithOptn82=hm2AgentDhcpL2RelayUntrustedSrvrMsgsWithOptn82, hm2AgentSwitchVlanMacAssociationVlanId=hm2AgentSwitchVlanMacAssociationVlanId, hm2AgentProtocolGroupPortTable=hm2AgentProtocolGroupPortTable, hm2AgentStpMstBridgePriority=hm2AgentStpMstBridgePriority, hm2AgentStpMstDesignatedBridgeId=hm2AgentStpMstDesignatedBridgeId, hm2AgentSwitchSnoopingQuerierCfgTable=hm2AgentSwitchSnoopingQuerierCfgTable, hm2AgentDhcpSnoopingIfLogEnable=hm2AgentDhcpSnoopingIfLogEnable, hm2AgentPortVoiceVlanDSCP=hm2AgentPortVoiceVlanDSCP, hm2PlatformSwitchingTraps=hm2PlatformSwitchingTraps, hm2AgentDhcpSnoopingVlanEnable=hm2AgentDhcpSnoopingVlanEnable, hm2AgentStpPortUpTime=hm2AgentStpPortUpTime, hm2AgentArpAclTable=hm2AgentArpAclTable, hm2AgentDhcpL2RelayIfEnable=hm2AgentDhcpL2RelayIfEnable, hm2AgentDaiVlanDstMacFailures=hm2AgentDaiVlanDstMacFailures, hm2AgentStpPortEntry=hm2AgentStpPortEntry, hm2AgentStaticDsBindingIpAddr=hm2AgentStaticDsBindingIpAddr, hm2AgentStpBpduGuardMode=hm2AgentStpBpduGuardMode, hm2AgentDhcpSnoopingIfAutoDisable=hm2AgentDhcpSnoopingIfAutoDisable, hm2AgentSwitchVlanSubnetAssociationIPAddress=hm2AgentSwitchVlanSubnetAssociationIPAddress, hm2AgentLagSummaryMaxFrameSizeLimit=hm2AgentLagSummaryMaxFrameSizeLimit, hm2AgentDhcpSnoopingIfBurstInterval=hm2AgentDhcpSnoopingIfBurstInterval, hm2AgentDhcpL2RelayIfTrustEnable=hm2AgentDhcpL2RelayIfTrustEnable, hm2AgentSwitchProtectedPortGroupName=hm2AgentSwitchProtectedPortGroupName, hm2AgentStpCstPortBpduFilter=hm2AgentStpCstPortBpduFilter, hm2AgentSwitchSnoopingIntfEntry=hm2AgentSwitchSnoopingIntfEntry, hm2AgentDynamicIpsgBindingMacAddr=hm2AgentDynamicIpsgBindingMacAddr, hm2AgentPortMirrorSessionNum=hm2AgentPortMirrorSessionNum, hm2AgentStpMstBridgeIdentifier=hm2AgentStpMstBridgeIdentifier, hm2AgentProtocolGroupEntry=hm2AgentProtocolGroupEntry, hm2AgentStpCstBridgeFwdDelay=hm2AgentStpCstBridgeFwdDelay, hm2AgentPortConfigTable=hm2AgentPortConfigTable, hm2AgentSwitchMFDBCurrentEntries=hm2AgentSwitchMFDBCurrentEntries, hm2AgentSwitchMFDBSummaryForwardingPortMask=hm2AgentSwitchMFDBSummaryForwardingPortMask, hm2AgentStpForceVersion=hm2AgentStpForceVersion, hm2AgentStaticDsBindingMacAddr=hm2AgentStaticDsBindingMacAddr, hm2AgentDhcpL2RelayCircuitIdVlanEnable=hm2AgentDhcpL2RelayCircuitIdVlanEnable, hm2AgentLagSummaryAddPort=hm2AgentLagSummaryAddPort, hm2AgentPortMirrorProbePortAlreadySet=hm2AgentPortMirrorProbePortAlreadySet, hm2AgentDot3adAggPort=hm2AgentDot3adAggPort, hm2AgentClassOfServicePortClass=hm2AgentClassOfServicePortClass, hm2AgentDaiIfConfigEntry=hm2AgentDaiIfConfigEntry, hm2AgentSwitchMFDBForwardingPortMask=hm2AgentSwitchMFDBForwardingPortMask, hm2AgentSwitchMFDBFilteringPortMask=hm2AgentSwitchMFDBFilteringPortMask, hm2AgentPortMirrorDestinationPort=hm2AgentPortMirrorDestinationPort, hm2AgentStpMstVlanTable=hm2AgentStpMstVlanTable, hm2AgentPortMirrorTable=hm2AgentPortMirrorTable, hm2AgentStpMstPortLoopInconsistentState=hm2AgentStpMstPortLoopInconsistentState, hm2AgentPortDot3FlowControlMode=hm2AgentPortDot3FlowControlMode, hm2PlatformDhcpSnoopingIntfErrorDisabledTrap=hm2PlatformDhcpSnoopingIntfErrorDisabledTrap, hm2AgentDynamicDsBindingIfIndex=hm2AgentDynamicDsBindingIfIndex, hm2AgentPortMulticastControlThresholdUnit=hm2AgentPortMulticastControlThresholdUnit, hm2AgentStpPortStatsRstpBpduTx=hm2AgentStpPortStatsRstpBpduTx, hm2AgentStaticIpsgBindingMacAddr=hm2AgentStaticIpsgBindingMacAddr, hm2AgentStpMstId=hm2AgentStpMstId, hm2AgentSwitchVlanSubnetAssociationSubnetMask=hm2AgentSwitchVlanSubnetAssociationSubnetMask, hm2AgentLagDetailedLagIndex=hm2AgentLagDetailedLagIndex, hm2AgentSwitchMFDBSummaryVlanId=hm2AgentSwitchMFDBSummaryVlanId, hm2AgentLagConfigGroupMaxNumOfLags=hm2AgentLagConfigGroupMaxNumOfLags, hm2AgentPortVoiceVlanOperationalStatus=hm2AgentPortVoiceVlanOperationalStatus, hm2AgentDynamicDsBindingEntry=hm2AgentDynamicDsBindingEntry, hm2AgentStpMstPortPriority=hm2AgentStpMstPortPriority, Ipv6AddressIfIdentifier=Ipv6AddressIfIdentifier, hm2AgentProtocolGroupProtocolID=hm2AgentProtocolGroupProtocolID, hm2PlatformSwitching=hm2PlatformSwitching, hm2AgentDaiVlanLoggingEnable=hm2AgentDaiVlanLoggingEnable, hm2AgentLagDetailedPortSpeed=hm2AgentLagDetailedPortSpeed, hm2AgentProtocolGroupTable=hm2AgentProtocolGroupTable, hm2AgentPortMirrorPrivateVlanConfigured=hm2AgentPortMirrorPrivateVlanConfigured, hm2AgentStpCstPortTCNGuard=hm2AgentStpCstPortTCNGuard, hm2AgentStpMstRootPortId=hm2AgentStpMstRootPortId, hm2AgentStpMstVlanEntry=hm2AgentStpMstVlanEntry, hm2AgentStaticIpsgBindingVlanId=hm2AgentStaticIpsgBindingVlanId, hm2AgentDaiVlanConfigTable=hm2AgentDaiVlanConfigTable, hm2AgentDynamicDsBindingMacAddr=hm2AgentDynamicDsBindingMacAddr, hm2AgentPortVoiceVlanUntagged=hm2AgentPortVoiceVlanUntagged, hm2AgentStpMstSNMPExtensionGroup=hm2AgentStpMstSNMPExtensionGroup, hm2AgentSwitchGvrpPortTable=hm2AgentSwitchGvrpPortTable, hm2AgentPortMirrorSourcePortReflectorPortConflict=hm2AgentPortMirrorSourcePortReflectorPortConflict, hm2AgentSwitchVoiceVlanDeviceEntry=hm2AgentSwitchVoiceVlanDeviceEntry, hm2AgentSwitchVoiceVlanDeviceMacAddress=hm2AgentSwitchVoiceVlanDeviceMacAddress, hm2AgentStpCstExtPortPathCost=hm2AgentStpCstExtPortPathCost, hm2AgentPortConfigEntry=hm2AgentPortConfigEntry, hm2AgentDynamicIpsgBindingHwStatus=hm2AgentDynamicIpsgBindingHwStatus, hm2AgentDhcpL2RelayStatsTable=hm2AgentDhcpL2RelayStatsTable, hm2AgentPortMirrorAdminMode=hm2AgentPortMirrorAdminMode, hm2AgentDaiVlanDynArpInspEnable=hm2AgentDaiVlanDynArpInspEnable, hm2AgentStaticIpsgBindingHwStatus=hm2AgentStaticIpsgBindingHwStatus, hm2AgentProtocolGroupPortStatus=hm2AgentProtocolGroupPortStatus, hm2AgentLagSummaryConfigTable=hm2AgentLagSummaryConfigTable, hm2AgentSwitchSnoopingQuerierOperVersion=hm2AgentSwitchSnoopingQuerierOperVersion, hm2AgentDynamicIpsgBindingVlanId=hm2AgentDynamicIpsgBindingVlanId, hm2AgentSwitchVlanSubnetAssociationVlanId=hm2AgentSwitchVlanSubnetAssociationVlanId, hm2AgentStaticDsBindingTable=hm2AgentStaticDsBindingTable, hm2AgentSwitchSnoopingIntfMaxResponseTime=hm2AgentSwitchSnoopingIntfMaxResponseTime, hm2AgentPortBroadcastControlMode=hm2AgentPortBroadcastControlMode, hm2AgentSwitchVoiceVLANAdminMode=hm2AgentSwitchVoiceVLANAdminMode, hm2AgentStaticIpsgBindingEntry=hm2AgentStaticIpsgBindingEntry, hm2AgentSwitchSnoopingQuerierQueryInterval=hm2AgentSwitchSnoopingQuerierQueryInterval, hm2AgentPortVoiceVlanMode=hm2AgentPortVoiceVlanMode, hm2AgentDot3adAggPortTable=hm2AgentDot3adAggPortTable, hm2AgentProtocolGroupProtocolStatus=hm2AgentProtocolGroupProtocolStatus, hm2AgentStpCstPortBpduFlood=hm2AgentStpCstPortBpduFlood, hm2AgentPortMirrorRspanVlanIdInvalid=hm2AgentPortMirrorRspanVlanIdInvalid, hm2AgentSwitchProtectedPortConfigGroup=hm2AgentSwitchProtectedPortConfigGroup, hm2AgentSdmTemplateSummaryTable=hm2AgentSdmTemplateSummaryTable, hm2AgentDhcpSnoopingStoreInterval=hm2AgentDhcpSnoopingStoreInterval, hm2AgentIPv6UnicastRoutes=hm2AgentIPv6UnicastRoutes, hm2AgentIpsgIfPortSecurity=hm2AgentIpsgIfPortSecurity, hm2AgentSwitchSnoopingIntfGroupMembershipInterval=hm2AgentSwitchSnoopingIntfGroupMembershipInterval, hm2AgentSwitchSnoopingCfgTable=hm2AgentSwitchSnoopingCfgTable, hm2AgentSwitchSnoopingQuerierOperMaxResponseTime=hm2AgentSwitchSnoopingQuerierOperMaxResponseTime, hm2AgentSwitchSnoopingVlanTable=hm2AgentSwitchSnoopingVlanTable, hm2AgentSwitchSnoopingAdminMode=hm2AgentSwitchSnoopingAdminMode, hm2AgentStpMstEntry=hm2AgentStpMstEntry, hm2AgentDhcpSnoopingConfigGroup=hm2AgentDhcpSnoopingConfigGroup, hm2AgentIpsgIfConfigTable=hm2AgentIpsgIfConfigTable, hm2AgentStpCstPortEntry=hm2AgentStpCstPortEntry, hm2AgentSwitchGmrpPortPktTx=hm2AgentSwitchGmrpPortPktTx, hm2AgentProtocolGroupPortEntry=hm2AgentProtocolGroupPortEntry, hm2AgentSwitchVlanSubnetAssociationGroup=hm2AgentSwitchVlanSubnetAssociationGroup, hm2AgentSwitchSnoopingQuerierVlanOperMode=hm2AgentSwitchSnoopingQuerierVlanOperMode, hm2AgentClassOfServicePortTable=hm2AgentClassOfServicePortTable, hm2AgentProtocolGroupId=hm2AgentProtocolGroupId, hm2AgentDhcpL2RelayUntrustedClntMsgsWithOptn82=hm2AgentDhcpL2RelayUntrustedClntMsgsWithOptn82, hm2AgentSwitchSnoopingIntfTable=hm2AgentSwitchSnoopingIntfTable, hm2AgentSwitchVlanMacAssociationMacAddress=hm2AgentSwitchVlanMacAssociationMacAddress, hm2AgentPortUnicastControlThreshold=hm2AgentPortUnicastControlThreshold)
mibBuilder.exportSymbols("HM2-PLATFORM-SWITCHING-MIB", hm2AgentDaiVlanPktsDropped=hm2AgentDaiVlanPktsDropped, hm2AgentPortMaxFrameSizeLimit=hm2AgentPortMaxFrameSizeLimit, hm2AgentPortMirrorSNMPExtensionGroup=hm2AgentPortMirrorSNMPExtensionGroup, hm2AgentDaiIfBurstInterval=hm2AgentDaiIfBurstInterval, hm2AgentSwitchMFDBSummaryMacAddress=hm2AgentSwitchMFDBSummaryMacAddress, hm2AgentPortMirroringGroup=hm2AgentPortMirroringGroup, hm2AgentPortMirrorReflectorPortInvalid=hm2AgentPortMirrorReflectorPortInvalid, hm2AgentPortVoiceVlanAuthMode=hm2AgentPortVoiceVlanAuthMode, hm2AgentSwitchMFDBMacAddress=hm2AgentSwitchMFDBMacAddress, hm2AgentSwitchGvrpPortPktTx=hm2AgentSwitchGvrpPortPktTx, hm2AgentStpCstPortPathCost=hm2AgentStpCstPortPathCost, hm2AgentDhcpSnoopingStatsEntry=hm2AgentDhcpSnoopingStatsEntry, hm2AgentDhcpSnoopingInvalidClientMessages=hm2AgentDhcpSnoopingInvalidClientMessages, hm2AgentStpConfigDigestKey=hm2AgentStpConfigDigestKey, hm2AgentStpMstTable=hm2AgentStpMstTable, hm2AgentSdmTemplateTable=hm2AgentSdmTemplateTable, hm2AgentPortMirrorPortVlanMirrorConflict=hm2AgentPortMirrorPortVlanMirrorConflict, hm2AgentSwitchProtectedPortPortList=hm2AgentSwitchProtectedPortPortList, PYSNMP_MODULE_ID=hm2PlatformSwitching, hm2AgentDynamicDsBindingTable=hm2AgentDynamicDsBindingTable, hm2AgentStpCstPortOperPointToPoint=hm2AgentStpCstPortOperPointToPoint, hm2AgentStpMstTopologyChangeParm=hm2AgentStpMstTopologyChangeParm, hm2AgentStaticDsBindingEntry=hm2AgentStaticDsBindingEntry, hm2AgentLagConfigGroupLagsConfigured=hm2AgentLagConfigGroupLagsConfigured, hm2AgentLagDetailedIfIndex=hm2AgentLagDetailedIfIndex, hm2AgentStpBpduFilterDefault=hm2AgentStpBpduFilterDefault, hm2AgentStpConfigFormatSelector=hm2AgentStpConfigFormatSelector, hm2AgentSwitchGARPGroup=hm2AgentSwitchGARPGroup, hm2AgentSwitchSnoopingQuerierCfgEntry=hm2AgentSwitchSnoopingQuerierCfgEntry, hm2AgentDaiVlanStatsTable=hm2AgentDaiVlanStatsTable, hm2AgentLagSummaryDeletePort=hm2AgentLagSummaryDeletePort, hm2AgentDhcpSnoopingIfRateLimit=hm2AgentDhcpSnoopingIfRateLimit, hm2AgentClearVlan=hm2AgentClearVlan, hm2AgentSwitchSnoopingIntfAdminMode=hm2AgentSwitchSnoopingIntfAdminMode, hm2AgentArpAclRuleMatchSenderMacAddr=hm2AgentArpAclRuleMatchSenderMacAddr, hm2AgentStpMstPortEntry=hm2AgentStpMstPortEntry, hm2AgentStpCstPortId=hm2AgentStpCstPortId, hm2AgentDaiVlanPktsForwarded=hm2AgentDaiVlanPktsForwarded, hm2AgentDhcpSnoopingVerifyMac=hm2AgentDhcpSnoopingVerifyMac, hm2AgentSwitchSnoopingQuerierLastQuerierVersion=hm2AgentSwitchSnoopingQuerierLastQuerierVersion, hm2AgentPortMirrorVlanNotCreated=hm2AgentPortMirrorVlanNotCreated, hm2AgentArpEntries=hm2AgentArpEntries, hm2AgentSwitchMFDBMostEntriesUsed=hm2AgentSwitchMFDBMostEntriesUsed, hm2AgentPortUnicastControlMode=hm2AgentPortUnicastControlMode, hm2AgentSwitchGmrpPortTable=hm2AgentSwitchGmrpPortTable, hm2AgentStaticIpsgBindingTable=hm2AgentStaticIpsgBindingTable, hm2AgentSwitchVlanMacAssociationRowStatus=hm2AgentSwitchVlanMacAssociationRowStatus, hm2AgentSwitchSnoopingQuerierLastQuerierAddress=hm2AgentSwitchSnoopingQuerierLastQuerierAddress, hm2AgentSwitchSnoopingVlanGroup=hm2AgentSwitchSnoopingVlanGroup, hm2AgentDaiVlanAclDrops=hm2AgentDaiVlanAclDrops, hm2AgentPortMirrorRemoteSourceVlan=hm2AgentPortMirrorRemoteSourceVlan, hm2AgentPortVoiceVlanPriority=hm2AgentPortVoiceVlanPriority, hm2AgentSwitchGmrpPortPktRx=hm2AgentSwitchGmrpPortPktRx, hm2AgentSwitchSnoopingQuerierVlanEntry=hm2AgentSwitchSnoopingQuerierVlanEntry, hm2AgentSwitchSnoopingCfgEntry=hm2AgentSwitchSnoopingCfgEntry, hm2AgentLagConfigStaticCapability=hm2AgentLagConfigStaticCapability, hm2AgentClassOfServicePortPriority=hm2AgentClassOfServicePortPriority, hm2AgentStaticIpsgBindingIfIndex=hm2AgentStaticIpsgBindingIfIndex, hm2AgentStpCstAutoPortPathCost=hm2AgentStpCstAutoPortPathCost, hm2PlatformStpInstanceTopologyChangeTrap=hm2PlatformStpInstanceTopologyChangeTrap, hm2AgentProtocolGroupVlanId=hm2AgentProtocolGroupVlanId, hm2AgentSwitchGvrpPortPktRx=hm2AgentSwitchGvrpPortPktRx, hm2AgentStpCstRegionalRootPathCost=hm2AgentStpCstRegionalRootPathCost, hm2AgentSwitchVlanSubnetAssociationEntry=hm2AgentSwitchVlanSubnetAssociationEntry, hm2AgentSwitchVlanSubnetAssociationTable=hm2AgentSwitchVlanSubnetAssociationTable, hm2AgentPortMirrorDestinationPortInvalid=hm2AgentPortMirrorDestinationPortInvalid, hm2AgentStpPortStatsRstpBpduRx=hm2AgentStpPortStatsRstpBpduRx, hm2AgentSwitchSnoopingIntfMRPExpirationTime=hm2AgentSwitchSnoopingIntfMRPExpirationTime, hm2AgentPortMirrorEntry=hm2AgentPortMirrorEntry, hm2AgentStpMstDesignatedPortId=hm2AgentStpMstDesignatedPortId, hm2AgentIPv4UnicastRoutes=hm2AgentIPv4UnicastRoutes, hm2AgentSwitchVoiceVlanInterfaceNum=hm2AgentSwitchVoiceVlanInterfaceNum, hm2PlatformDaiIntfErrorDisabledTrap=hm2PlatformDaiIntfErrorDisabledTrap, hm2AgentPortVoiceVlanNoneMode=hm2AgentPortVoiceVlanNoneMode, hm2AgentSwitchSnoopingProtocol=hm2AgentSwitchSnoopingProtocol, hm2AgentStpCstBridgeHoldCount=hm2AgentStpCstBridgeHoldCount, hm2AgentDhcpSnoopingRemoteIpAddr=hm2AgentDhcpSnoopingRemoteIpAddr, hm2AgentStpPortStatsStpBpduTx=hm2AgentStpPortStatsStpBpduTx, hm2AgentStpMstPortReceivedBridgeId=hm2AgentStpMstPortReceivedBridgeId, hm2AgentLagDetailedConfigEntry=hm2AgentLagDetailedConfigEntry, hm2AgentSwitchVlanStaticMrouterAdminMode=hm2AgentSwitchVlanStaticMrouterAdminMode, hm2AgentDhcpSnoopingRemoteFileName=hm2AgentDhcpSnoopingRemoteFileName, hm2AgentPortVoiceVlanDataPriorityMode=hm2AgentPortVoiceVlanDataPriorityMode, hm2AgentDhcpSnoopingVlanConfigTable=hm2AgentDhcpSnoopingVlanConfigTable, hm2AgentSwitchSnoopingQuerierGroup=hm2AgentSwitchSnoopingQuerierGroup, hm2AgentArpAclRuleMatchSenderIpAddr=hm2AgentArpAclRuleMatchSenderIpAddr, hm2AgentSwitchMFDBTable=hm2AgentSwitchMFDBTable, hm2AgentDot3adAggPortEntry=hm2AgentDot3adAggPortEntry, hm2AgentSwitchStaticMacFilteringVlanId=hm2AgentSwitchStaticMacFilteringVlanId, hm2AgentSwitchGmrpUnknownMulticastFilterMode=hm2AgentSwitchGmrpUnknownMulticastFilterMode, hm2AgentSwitchStaticMacFilteringAddress=hm2AgentSwitchStaticMacFilteringAddress, hm2AgentSwitchAddressAgingTimeout=hm2AgentSwitchAddressAgingTimeout, hm2AgentSwitchSnoopingQuerierElectionParticipateMode=hm2AgentSwitchSnoopingQuerierElectionParticipateMode, hm2AgentStpRingOnlyModeIntfOne=hm2AgentStpRingOnlyModeIntfOne, hm2AgentStpMstDesignatedRootId=hm2AgentStpMstDesignatedRootId, hm2AgentPortMirrorProbePortVlanConflict=hm2AgentPortMirrorProbePortVlanConflict, hm2AgentStpMstTimeSinceTopologyChange=hm2AgentStpMstTimeSinceTopologyChange, hm2AgentProtocolGroupName=hm2AgentProtocolGroupName, hm2AgentDhcpL2RelayStatsEntry=hm2AgentDhcpL2RelayStatsEntry, hm2AgentSwitchVoiceVlanDeviceTable=hm2AgentSwitchVoiceVlanDeviceTable, Ipv6IfIndex=Ipv6IfIndex, Hm2AgentPortMask=Hm2AgentPortMask, hm2AgentSwitchStaticMacEntries=hm2AgentSwitchStaticMacEntries, hm2AgentSwitchSnoopingVlanFastLeaveAdminMode=hm2AgentSwitchSnoopingVlanFastLeaveAdminMode, hm2AgentStpConfigName=hm2AgentStpConfigName, hm2AgentSwitchMFDBProtocolType=hm2AgentSwitchMFDBProtocolType, hm2AgentSwitchProtectedPortTable=hm2AgentSwitchProtectedPortTable, hm2AgentDynamicIpsgBindingIfIndex=hm2AgentDynamicIpsgBindingIfIndex, hm2AgentDaiIPValidate=hm2AgentDaiIPValidate, hm2AgentDhcpSnoopingMacVerifyFailures=hm2AgentDhcpSnoopingMacVerifyFailures, hm2AgentDhcpL2RelayTrustedSrvrMsgsWithoutOptn82=hm2AgentDhcpL2RelayTrustedSrvrMsgsWithoutOptn82, hm2AgentDynamicDsBindingVlanId=hm2AgentDynamicDsBindingVlanId, hm2AgentStpMstSwitchVersionConflict=hm2AgentStpMstSwitchVersionConflict, hm2AgentSystemGroup=hm2AgentSystemGroup, hm2AgentDaiIfAutoDisable=hm2AgentDaiIfAutoDisable, hm2AgentDhcpL2RelayTrustedClntMsgsWithoutOptn82=hm2AgentDhcpL2RelayTrustedClntMsgsWithoutOptn82, hm2AgentLagSummaryFlushTimer=hm2AgentLagSummaryFlushTimer, hm2AgentPortMirrorRemoteVlan=hm2AgentPortMirrorRemoteVlan, hm2AgentDhcpSnoopingIfTrustEnable=hm2AgentDhcpSnoopingIfTrustEnable, hm2AgentDaiVlanDhcpDrops=hm2AgentDaiVlanDhcpDrops, hm2AgentSwitchSnoopingQuerierVersion=hm2AgentSwitchSnoopingQuerierVersion, hm2AgentPortMirrorTypeEntry=hm2AgentPortMirrorTypeEntry, hm2AgentSwitchGvrpPortEntry=hm2AgentSwitchGvrpPortEntry, hm2AgentSwitchSnoopingQuerierExpiryInterval=hm2AgentSwitchSnoopingQuerierExpiryInterval, hm2AgentStpMstRowStatus=hm2AgentStpMstRowStatus, hm2AgentPortSfpLinkLossAlert=hm2AgentPortSfpLinkLossAlert, hm2AgentSwitchMFDBMaxTableEntries=hm2AgentSwitchMFDBMaxTableEntries, hm2AgentStpPortMigrationCheck=hm2AgentStpPortMigrationCheck, hm2AgentArpAclRowStatus=hm2AgentArpAclRowStatus, hm2AgentSwitchSnoopingIntfMulticastRouterMode=hm2AgentSwitchSnoopingIntfMulticastRouterMode, hm2PlatformStpInstanceNewRootTrap=hm2PlatformStpInstanceNewRootTrap, hm2AgentStpMstPortReceivedRegionalRPC=hm2AgentStpMstPortReceivedRegionalRPC, hm2AgentSwitchSnoopingVlanGroupMembershipInterval=hm2AgentSwitchSnoopingVlanGroupMembershipInterval, hm2AgentStpPortStatsMstpBpduTx=hm2AgentStpPortStatsMstpBpduTx, hm2AgentProtocolGroupProtocolTable=hm2AgentProtocolGroupProtocolTable, hm2AgentStpMstPortTransitionsOutOfLoopInconsistentState=hm2AgentStpMstPortTransitionsOutOfLoopInconsistentState, hm2AgentDhcpL2RelayVlanConfigTable=hm2AgentDhcpL2RelayVlanConfigTable, hm2AgentSwitchMFDBEntry=hm2AgentSwitchMFDBEntry, hm2AgentStpMstPortReceivedRPC=hm2AgentStpMstPortReceivedRPC, hm2AgentPortMirrorVlanMirrorPortConflict=hm2AgentPortMirrorVlanMirrorPortConflict, hm2AgentStpMstVlanRowStatus=hm2AgentStpMstVlanRowStatus, hm2AgentStpMstRootPathCost=hm2AgentStpMstRootPathCost, hm2AgentArpAclName=hm2AgentArpAclName, hm2AgentIPv6NdpEntries=hm2AgentIPv6NdpEntries, hm2AgentStpPortStatsMstpBpduRx=hm2AgentStpPortStatsMstpBpduRx, hm2AgentLagSummaryHashOption=hm2AgentLagSummaryHashOption, hm2AgentSdmTemplateEntry=hm2AgentSdmTemplateEntry, hm2AgentStpPortTable=hm2AgentStpPortTable, hm2AgentSdmPreferConfigGroup=hm2AgentSdmPreferConfigGroup, hm2AgentStpCstDesignatedCost=hm2AgentStpCstDesignatedCost, hm2AgentSwitchStaticMacFilteringEntry=hm2AgentSwitchStaticMacFilteringEntry, hm2AgentSwitchStaticMacFilteringSourcePortMask=hm2AgentSwitchStaticMacFilteringSourcePortMask, hm2PlatformStpCstBpduGuardTrap=hm2PlatformStpCstBpduGuardTrap, hm2AgentPortMirrorRemoteDestinationVlan=hm2AgentPortMirrorRemoteDestinationVlan, hm2AgentStpMstPortTable=hm2AgentStpMstPortTable, hm2AgentDynamicIpsgBindingEntry=hm2AgentDynamicIpsgBindingEntry, hm2AgentLagConfigGroupPortIsLagMemberErrorReturn=hm2AgentLagConfigGroupPortIsLagMemberErrorReturn, hm2AgentSwitchSnoopingIntfVlanIDs=hm2AgentSwitchSnoopingIntfVlanIDs, hm2AgentDhcpL2RelayVlanConfigEntry=hm2AgentDhcpL2RelayVlanConfigEntry, hm2AgentDaiIfRateLimit=hm2AgentDaiIfRateLimit, hm2AgentStpMstDesignatedCost=hm2AgentStpMstDesignatedCost, hm2AgentPortUnicastControlThresholdUnit=hm2AgentPortUnicastControlThresholdUnit, hm2AgentArpAclEntry=hm2AgentArpAclEntry, hm2AgentSdmPreferCurrentTemplate=hm2AgentSdmPreferCurrentTemplate, hm2AgentPortMirrorTypeTable=hm2AgentPortMirrorTypeTable, hm2AgentLagSummaryLagIndex=hm2AgentLagSummaryLagIndex, hm2AgentPortMirrorRemoteSourceRemoteDestinationConflict=hm2AgentPortMirrorRemoteSourceRemoteDestinationConflict, Ipv6Address=Ipv6Address, hm2AgentSwitchStaticMacFilteringTable=hm2AgentSwitchStaticMacFilteringTable, hm2AgentDaiStatsReset=hm2AgentDaiStatsReset, hm2AgentStpCstDesignatedBridgeId=hm2AgentStpCstDesignatedBridgeId, hm2AgentPortMirrorSourcePortMask=hm2AgentPortMirrorSourcePortMask, hm2AgentLagSummaryStaticCapability=hm2AgentLagSummaryStaticCapability, hm2AgentStaticIpsgBindingIpAddr=hm2AgentStaticIpsgBindingIpAddr, hm2AgentDynamicDsBindingLeaseRemainingTime=hm2AgentDynamicDsBindingLeaseRemainingTime, hm2AgentLagMirrorProbePortLagMemberErrorReturn=hm2AgentLagMirrorProbePortLagMemberErrorReturn, hm2AgentDhcpSnoopingStatsTable=hm2AgentDhcpSnoopingStatsTable, hm2AgentLagSummaryMinimumActiveLinks=hm2AgentLagSummaryMinimumActiveLinks, hm2AgentLagSummaryMaxFrameSize=hm2AgentLagSummaryMaxFrameSize, hm2AgentSwitchStaticMacStatsGroup=hm2AgentSwitchStaticMacStatsGroup, hm2AgentStpMstPortForwardingState=hm2AgentStpMstPortForwardingState, hm2AgentSwitchSnoopingVlanAdminMode=hm2AgentSwitchSnoopingVlanAdminMode, hm2AgentSwitchSnoopingVlanReportSuppMode=hm2AgentSwitchSnoopingVlanReportSuppMode, hm2AgentPortVoiceVlanID=hm2AgentPortVoiceVlanID, hm2AgentClassOfServicePortEntry=hm2AgentClassOfServicePortEntry, hm2AgentStpCstPortLoopGuard=hm2AgentStpCstPortLoopGuard, hm2AgentSdmPreferNextTemplate=hm2AgentSdmPreferNextTemplate, hm2AgentSwitchMFDBSummaryEntry=hm2AgentSwitchMFDBSummaryEntry, hm2AgentStpCstBridgeHelloTime=hm2AgentStpCstBridgeHelloTime, hm2AgentDhcpSnoopingStatsReset=hm2AgentDhcpSnoopingStatsReset, hm2AgentStpCstRegionalRootId=hm2AgentStpCstRegionalRootId, hm2AgentSwitchVlanMacAssociationGroup=hm2AgentSwitchVlanMacAssociationGroup, hm2AgentSwitchSnoopingMulticastControlFramesProcessed=hm2AgentSwitchSnoopingMulticastControlFramesProcessed, hm2AgentSwitchSnoopingVlanMaxResponseTime=hm2AgentSwitchSnoopingVlanMaxResponseTime, hm2AgentSwitchSnoopingQuerierVlanAddress=hm2AgentSwitchSnoopingQuerierVlanAddress, hm2AgentPortMirrorInvalidSourcePort=hm2AgentPortMirrorInvalidSourcePort, hm2AgentPortBroadcastControlThresholdUnit=hm2AgentPortBroadcastControlThresholdUnit, hm2AgentSwitchSnoopingGroup=hm2AgentSwitchSnoopingGroup, hm2AgentStpSwitchConfigGroup=hm2AgentStpSwitchConfigGroup, hm2AgentPortMirrorDestinationRemotePortNotSet=hm2AgentPortMirrorDestinationRemotePortNotSet, hm2AgentPortMirrorTypeSourcePort=hm2AgentPortMirrorTypeSourcePort, hm2AgentDhcpL2RelayVlanRemoteIdType=hm2AgentDhcpL2RelayVlanRemoteIdType, hm2AgentPortBroadcastControlThreshold=hm2AgentPortBroadcastControlThreshold, hm2AgentSwitchAddressAgingTimeoutEntry=hm2AgentSwitchAddressAgingTimeoutEntry, hm2AgentStaticDsBindingRowStatus=hm2AgentStaticDsBindingRowStatus, hm2AgentProtocolGroupStatus=hm2AgentProtocolGroupStatus, hm2AgentArpAclRuleRowStatus=hm2AgentArpAclRuleRowStatus, hm2AgentStpCstMaxAge=hm2AgentStpCstMaxAge, hm2AgentPortClearStats=hm2AgentPortClearStats, hm2AgentDaiIfTrustEnable=hm2AgentDaiIfTrustEnable, hm2AgentDhcpL2RelayVlanIndex=hm2AgentDhcpL2RelayVlanIndex, hm2AgentStpCstPortTable=hm2AgentStpCstPortTable, hm2AgentStpMstTopologyChangeCount=hm2AgentStpMstTopologyChangeCount, hm2AgentDaiVlanSrcMacFailures=hm2AgentDaiVlanSrcMacFailures, hm2AgentDhcpL2RelayVlanEnable=hm2AgentDhcpL2RelayVlanEnable, hm2AgentArpAclGroup=hm2AgentArpAclGroup, hm2AgentPortMulticastControlThreshold=hm2AgentPortMulticastControlThreshold, hm2AgentSwitchSnoopingIntfFastLeaveAdminMode=hm2AgentSwitchSnoopingIntfFastLeaveAdminMode, hm2AgentLagSummaryName=hm2AgentLagSummaryName, hm2AgentStpConfigRevision=hm2AgentStpConfigRevision, hm2AgentStpMstPortRole=hm2AgentStpMstPortRole, hm2AgentLagConfigSNMPExtensionGroup=hm2AgentLagConfigSNMPExtensionGroup, hm2AgentStpMstAutoPortPathCost=hm2AgentStpMstAutoPortPathCost, LagList=LagList, hm2AgentSwitchStaticMacFilteringDestPortMask=hm2AgentSwitchStaticMacFilteringDestPortMask, VlanList=VlanList, hm2AgentSwitchVlanStaticMrouterTable=hm2AgentSwitchVlanStaticMrouterTable, hm2AgentEcmpNextHops=hm2AgentEcmpNextHops, hm2AgentDaiVlanIpValidFailures=hm2AgentDaiVlanIpValidFailures)

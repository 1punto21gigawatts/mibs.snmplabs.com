#
# PySNMP MIB module HH3C-TRAP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-TRAP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:30:03 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
hh3cCommon, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cCommon")
ifIndex, ifDescr, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "ifDescr", "InterfaceIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Unsigned32, ObjectIdentity, Counter32, Bits, Gauge32, MibIdentifier, Counter64, Integer32, ModuleIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Unsigned32", "ObjectIdentity", "Counter32", "Bits", "Gauge32", "MibIdentifier", "Counter64", "Integer32", "ModuleIdentity", "iso")
TAddress, TruthValue, RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TAddress", "TruthValue", "RowStatus", "DisplayString", "TextualConvention")
hh3cTrap = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 38))
hh3cTrap.setRevisions(('2010-06-05 10:50',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cTrap.setRevisionsDescriptions(('The initial revision of this MIB module.',))
if mibBuilder.loadTexts: hh3cTrap.setLastUpdated('201006051050Z')
if mibBuilder.loadTexts: hh3cTrap.setOrganization('Hangzhou H3C Technologies Co., Ltd.')
if mibBuilder.loadTexts: hh3cTrap.setContactInfo('Platform Team H3C Technologies Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip: 100085')
if mibBuilder.loadTexts: hh3cTrap.setDescription('This MIB is applicable to routers, switches and other products. Some objects in this may be used only for some specific products, so users should refer to the related documents to acquire more detail information. ')
hh3cTableGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1))
hh3cMacTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 1))
hh3cMacTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMacTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cMacTabTrapEnable.setDescription('Indicates whether hh3cMacTabFullTrap and hh3cMacTabAlmostFullTrap traps should be generated when the MAC table is filled.')
hh3cMacTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMacTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cMacTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the MAC table is full or two traps which occur when the MAC table is almost full.')
hh3cMacTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 1, 3))
hh3cMacTabLen = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 1, 3, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cMacTabLen.setStatus('current')
if mibBuilder.loadTexts: hh3cMacTabLen.setDescription('The length of the MAC table.')
hh3cMacTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 1, 4))
hh3cMacTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 1, 4, 1)).setObjects(("HH3C-TRAP-MIB", "hh3cMacTabLen"))
if mibBuilder.loadTexts: hh3cMacTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cMacTabFullTrap.setDescription('Send this trap when the MAC table is filled. The interval between two traps generated should be longer than hh3cMacTabTrapInterval.')
hh3cMacTabAlmostFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 1, 4, 2))
if mibBuilder.loadTexts: hh3cMacTabAlmostFullTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cMacTabAlmostFullTrap.setDescription('Send this trap when the MAC table is almost full. The interval between two traps generated should be longer than hh3cMacTabTrapInterval.')
hh3cArpTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 2))
hh3cArpTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cArpTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cArpTabTrapEnable.setDescription('Indicates whether hh3cArpTabFullTrap traps should be generated when the ARP table is filled.')
hh3cArpTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cArpTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cArpTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the ARP table is filled.')
hh3cArpTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 2, 3))
hh3cArpTabLen = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 2, 3, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cArpTabLen.setStatus('current')
if mibBuilder.loadTexts: hh3cArpTabLen.setDescription('The length of the ARP table.')
hh3cArpTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 2, 4))
hh3cArpTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 2, 4, 1)).setObjects(("HH3C-TRAP-MIB", "hh3cArpTabLen"))
if mibBuilder.loadTexts: hh3cArpTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cArpTabFullTrap.setDescription('Send this trap when the ARP table is filled. The interval between two traps generated should be longer than hh3cArpTabTrapInterval.')
hh3cArpPortDynamicEntryFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 2, 4, 2)).setObjects(("HH3C-TRAP-MIB", "hh3cArpTabLen"), ("IF-MIB", "ifIndex"), ("IF-MIB", "ifDescr"))
if mibBuilder.loadTexts: hh3cArpPortDynamicEntryFullTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cArpPortDynamicEntryFullTrap.setDescription('Send this trap when the dynamic ARP number of the port exceeds the limitation. The object hh3cArpTabLen describes the limitation of the max dynamic ARP number of this port. The interval between two traps should be longer than hh3cArpTabTrapInterval.')
hh3cRtTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3))
hh3cDetailRtTrapTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 1), )
if mibBuilder.loadTexts: hh3cDetailRtTrapTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDetailRtTrapTable.setDescription('This table contains objects to decide what kind of trap should be sent.')
hh3cDetailRtTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 1, 1), ).setIndexNames((0, "HH3C-TRAP-MIB", "hh3cDetailRtProType"))
if mibBuilder.loadTexts: hh3cDetailRtTrapEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDetailRtTrapEntry.setDescription('Entry items')
hh3cDetailRtProType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("rip", 3), ("isis", 4), ("ospf", 5), ("bgp", 6)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDetailRtProType.setStatus('current')
if mibBuilder.loadTexts: hh3cDetailRtProType.setDescription('The index value which uniquely identifies an entry in the hh3cDetailRtTrapTable.')
hh3cDetailRtEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDetailRtEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDetailRtEnable.setDescription('Indicates whether hh3cDetailRtTabFullTrap traps should be generated when a specific routing table is filled.')
hh3cRtTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cRtTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cRtTabTrapEnable.setDescription('Indicates whether hh3cRtTabFullTrap traps should be generated when the routing table is filled.')
hh3cRtTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cRtTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cRtTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the routing table is filled.')
hh3cRtTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 4))
hh3cRtTabLen = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 4, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cRtTabLen.setStatus('current')
if mibBuilder.loadTexts: hh3cRtTabLen.setDescription('The length of the routing table. The detail routing tables also use the same object.')
hh3cDefaultRtNextHopType = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 4, 2), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDefaultRtNextHopType.setStatus('current')
if mibBuilder.loadTexts: hh3cDefaultRtNextHopType.setDescription('The IP address type of the next hop of the default route. The value must be ipv4 or ipv6')
hh3cDefaultRtNextHop = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 4, 3), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDefaultRtNextHop.setStatus('current')
if mibBuilder.loadTexts: hh3cDefaultRtNextHop.setDescription('The IP address of the next hop of the default route.')
hh3cDefaultRtOutIf = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 4, 4), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cDefaultRtOutIf.setStatus('current')
if mibBuilder.loadTexts: hh3cDefaultRtOutIf.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
hh3cRtTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 5))
hh3cRtTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 5, 1)).setObjects(("HH3C-TRAP-MIB", "hh3cRtTabLen"))
if mibBuilder.loadTexts: hh3cRtTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cRtTabFullTrap.setDescription('Send this trap when the routing table is filled. The interval between two traps generated should be longer than hh3cRtTabTrapInterval.')
hh3cDetailRtTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 5, 2)).setObjects(("HH3C-TRAP-MIB", "hh3cDetailRtProType"), ("HH3C-TRAP-MIB", "hh3cRtTabLen"))
if mibBuilder.loadTexts: hh3cDetailRtTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cDetailRtTabFullTrap.setDescription('Send this trap when the detail routing table is filled. The interval between two traps generated should be longer than hh3cRtTabTrapInterval.')
hh3cDefaultRtDelTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 5, 3)).setObjects(("HH3C-TRAP-MIB", "hh3cDetailRtProType"), ("HH3C-TRAP-MIB", "hh3cDefaultRtNextHopType"), ("HH3C-TRAP-MIB", "hh3cDefaultRtNextHop"), ("HH3C-TRAP-MIB", "hh3cDefaultRtOutIf"))
if mibBuilder.loadTexts: hh3cDefaultRtDelTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cDefaultRtDelTrap.setDescription('Send this trap when the default route is deleted.')
hh3cDefaultRtDelTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 3, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDefaultRtDelTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cDefaultRtDelTrapEnable.setDescription('Indicates whether hh3cDefaultRtDelTrap traps should be generated when the default route is deleted.')
hh3cMulticastTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 4))
hh3cMulticastTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMulticastTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cMulticastTabTrapEnable.setDescription('Indicates whether hh3cMulticastTabFullTrap traps should be generated when the multicast table is filled.')
hh3cMulticastTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cMulticastTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cMulticastTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the multicast table is filled.')
hh3cMulticastTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 4, 3))
hh3cMulticastTabType = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lay2", 1), ("lay3", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cMulticastTabType.setStatus('current')
if mibBuilder.loadTexts: hh3cMulticastTabType.setDescription('Defining the type of the multicast table, layer2 or layer3.')
hh3cMulticastTabLen = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 4, 3, 2), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cMulticastTabLen.setStatus('current')
if mibBuilder.loadTexts: hh3cMulticastTabLen.setDescription('The length of the multicast table.')
hh3cMulticastTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 4, 4))
hh3cMulticastTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 4, 4, 1)).setObjects(("HH3C-TRAP-MIB", "hh3cMulticastTabType"), ("HH3C-TRAP-MIB", "hh3cMulticastTabLen"))
if mibBuilder.loadTexts: hh3cMulticastTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cMulticastTabFullTrap.setDescription('Send this trap when the multicast table is filled. The interval between two traps generated should be longer than hh3cMulticastTabTrapInterval.')
hh3cNdTabStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 5))
hh3cNdTabTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cNdTabTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cNdTabTrapEnable.setDescription('Indicates whether hh3cNdTabFullTrap traps should be generated when the ND table is filled.')
hh3cNdTabTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cNdTabTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cNdTabTrapInterval.setDescription('Definition of the minimum interval between two traps which occur when the ND table is filled.')
hh3cNdTabTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 5, 3))
hh3cNdTabLen = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 5, 3, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hh3cNdTabLen.setStatus('current')
if mibBuilder.loadTexts: hh3cNdTabLen.setDescription('The length of the ND table.')
hh3cNdTabTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 5, 4))
hh3cNdTabFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 5, 4, 1)).setObjects(("HH3C-TRAP-MIB", "hh3cNdTabLen"))
if mibBuilder.loadTexts: hh3cNdTabFullTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cNdTabFullTrap.setDescription('Send this trap when the ND table is filled. The interval between two traps generated should be longer than hh3cNdTabTrapInterval.')
hh3cPeriodicalTrapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 6))
hh3cPeriodicalTrapObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 6, 1))
hh3cPeriodicalTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(10, 3600), )).clone(60)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cPeriodicalTrapInterval.setStatus('current')
if mibBuilder.loadTexts: hh3cPeriodicalTrapInterval.setDescription('Definition of the periodical interval. If no trap occurs during the certain interval, an hh3cPeriodicalTrap will be generated. If the interval is set to 0, no hh3cPeriodicalTrap will be generated.')
hh3cPeriodicalTrapSwitch = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cPeriodicalTrapSwitch.setStatus('current')
if mibBuilder.loadTexts: hh3cPeriodicalTrapSwitch.setDescription('Definition of the periodical switch. If the value is off,the hh3cPeriodicalTrap will not be generated. the hh3cPeriodicalTrapInterval will be set to 0.')
hh3cPeriodicalTrapInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 6, 2))
hh3cPeriodicalNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 6, 3))
hh3cPeriodicalNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 6, 3, 0))
hh3cPeriodicalTrap = NotificationType((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 6, 3, 0, 1))
if mibBuilder.loadTexts: hh3cPeriodicalTrap.setStatus('current')
if mibBuilder.loadTexts: hh3cPeriodicalTrap.setDescription('If no trap occurs during the interval spicified by hh3cPeriodicalTrapInterval, an hh3cPeriodicalTrap will be generated. If the interval is set to 0, no hh3cPeriodicalTrap will be generated.')
hh3cTrapDesInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 7))
hh3cTrapDesInfoTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 7, 1), )
if mibBuilder.loadTexts: hh3cTrapDesInfoTable.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapDesInfoTable.setDescription('A table of trap destination host address and port .')
hh3cTrapDesInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 7, 1, 1), ).setIndexNames((0, "HH3C-TRAP-MIB", "hh3cTrapDesInfoIndex"))
if mibBuilder.loadTexts: hh3cTrapDesInfoEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapDesInfoEntry.setDescription('The entry of trap destination host address and port.')
hh3cTrapDesInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: hh3cTrapDesInfoIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapDesInfoIndex.setDescription('The index of this table.')
hh3cTrapDesIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 7, 1, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cTrapDesIPAddress.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapDesIPAddress.setDescription('The host IP address of the trap destination.')
hh3cTrapDesPort = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cTrapDesPort.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapDesPort.setDescription('The port of the trap destination.')
hh3cTrapDesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 7, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cTrapDesRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapDesRowStatus.setDescription('The status of this table entry.')
hh3cTrapDesAddrTAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 7, 1, 1, 5), TAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cTrapDesAddrTAddress.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapDesAddrTAddress.setDescription('This object contains a transport address.')
hh3cTrapConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 8))
hh3cTrapConfigTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 8, 1), )
if mibBuilder.loadTexts: hh3cTrapConfigTable.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapConfigTable.setDescription('A table of trap configuration.')
hh3cTrapConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 8, 1, 1), ).setIndexNames((0, "HH3C-TRAP-MIB", "hh3cTrapConfigIndex"))
if mibBuilder.loadTexts: hh3cTrapConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapConfigEntry.setDescription('The entry of trap configuration.')
hh3cTrapConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hh3cTrapConfigIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapConfigIndex.setDescription('The index of this table.')
hh3cTrapConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 8, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cTrapConfigName.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapConfigName.setDescription('The name of the appointed traps.')
hh3cTrapConfigDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 8, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cTrapConfigDescr.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapConfigDescr.setDescription('The description of the appointed traps.')
hh3cTrapConfigSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 38, 1, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cTrapConfigSwitch.setStatus('current')
if mibBuilder.loadTexts: hh3cTrapConfigSwitch.setDescription('Indicates whether the appointed traps should be generated.')
mibBuilder.exportSymbols("HH3C-TRAP-MIB", hh3cNdTabStatGroup=hh3cNdTabStatGroup, PYSNMP_MODULE_ID=hh3cTrap, hh3cMacTabFullTrap=hh3cMacTabFullTrap, hh3cArpTabFullTrap=hh3cArpTabFullTrap, hh3cArpPortDynamicEntryFullTrap=hh3cArpPortDynamicEntryFullTrap, hh3cRtTabTrapInfo=hh3cRtTabTrapInfo, hh3cDefaultRtNextHopType=hh3cDefaultRtNextHopType, hh3cNdTabTrapInterval=hh3cNdTabTrapInterval, hh3cRtTabStatGroup=hh3cRtTabStatGroup, hh3cArpTabTrap=hh3cArpTabTrap, hh3cMulticastTabStatGroup=hh3cMulticastTabStatGroup, hh3cNdTabTrapInfo=hh3cNdTabTrapInfo, hh3cTrapDesIPAddress=hh3cTrapDesIPAddress, hh3cArpTabTrapInfo=hh3cArpTabTrapInfo, hh3cNdTabFullTrap=hh3cNdTabFullTrap, hh3cNdTabLen=hh3cNdTabLen, hh3cTrapDesInfoEntry=hh3cTrapDesInfoEntry, hh3cDefaultRtDelTrap=hh3cDefaultRtDelTrap, hh3cDefaultRtOutIf=hh3cDefaultRtOutIf, hh3cTrap=hh3cTrap, hh3cPeriodicalTrapSwitch=hh3cPeriodicalTrapSwitch, hh3cMacTabStatGroup=hh3cMacTabStatGroup, hh3cPeriodicalNotification=hh3cPeriodicalNotification, hh3cDetailRtTabFullTrap=hh3cDetailRtTabFullTrap, hh3cPeriodicalTrapGroup=hh3cPeriodicalTrapGroup, hh3cTrapDesRowStatus=hh3cTrapDesRowStatus, hh3cTrapConfigEntry=hh3cTrapConfigEntry, hh3cMacTabTrapInfo=hh3cMacTabTrapInfo, hh3cMulticastTabTrapInterval=hh3cMulticastTabTrapInterval, hh3cArpTabStatGroup=hh3cArpTabStatGroup, hh3cArpTabTrapEnable=hh3cArpTabTrapEnable, hh3cDetailRtProType=hh3cDetailRtProType, hh3cRtTabLen=hh3cRtTabLen, hh3cPeriodicalTrapInterval=hh3cPeriodicalTrapInterval, hh3cTrapDesInfoIndex=hh3cTrapDesInfoIndex, hh3cTrapConfigTable=hh3cTrapConfigTable, hh3cTrapConfigDescr=hh3cTrapConfigDescr, hh3cTrapDesPort=hh3cTrapDesPort, hh3cMacTabAlmostFullTrap=hh3cMacTabAlmostFullTrap, hh3cTrapDesInfoTable=hh3cTrapDesInfoTable, hh3cMacTabTrap=hh3cMacTabTrap, hh3cArpTabLen=hh3cArpTabLen, hh3cPeriodicalTrapInfo=hh3cPeriodicalTrapInfo, hh3cMulticastTabFullTrap=hh3cMulticastTabFullTrap, hh3cMacTabTrapInterval=hh3cMacTabTrapInterval, hh3cTrapConfigSwitch=hh3cTrapConfigSwitch, hh3cRtTabTrapInterval=hh3cRtTabTrapInterval, hh3cMulticastTabLen=hh3cMulticastTabLen, hh3cMulticastTabType=hh3cMulticastTabType, hh3cPeriodicalNotificationPrefix=hh3cPeriodicalNotificationPrefix, hh3cTrapDesInfo=hh3cTrapDesInfo, hh3cRtTabTrap=hh3cRtTabTrap, hh3cDetailRtTrapTable=hh3cDetailRtTrapTable, hh3cMulticastTabTrapEnable=hh3cMulticastTabTrapEnable, hh3cNdTabTrap=hh3cNdTabTrap, hh3cTableGroup=hh3cTableGroup, hh3cRtTabTrapEnable=hh3cRtTabTrapEnable, hh3cNdTabTrapEnable=hh3cNdTabTrapEnable, hh3cTrapConfigName=hh3cTrapConfigName, hh3cMulticastTabTrap=hh3cMulticastTabTrap, hh3cPeriodicalTrap=hh3cPeriodicalTrap, hh3cPeriodicalTrapObjects=hh3cPeriodicalTrapObjects, hh3cMacTabLen=hh3cMacTabLen, hh3cRtTabFullTrap=hh3cRtTabFullTrap, hh3cTrapConfigIndex=hh3cTrapConfigIndex, hh3cTrapDesAddrTAddress=hh3cTrapDesAddrTAddress, hh3cDefaultRtDelTrapEnable=hh3cDefaultRtDelTrapEnable, hh3cArpTabTrapInterval=hh3cArpTabTrapInterval, hh3cMulticastTabTrapInfo=hh3cMulticastTabTrapInfo, hh3cTrapConfig=hh3cTrapConfig, hh3cDefaultRtNextHop=hh3cDefaultRtNextHop, hh3cMacTabTrapEnable=hh3cMacTabTrapEnable, hh3cDetailRtTrapEntry=hh3cDetailRtTrapEntry, hh3cDetailRtEnable=hh3cDetailRtEnable)

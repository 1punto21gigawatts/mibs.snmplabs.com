#
# PySNMP MIB module CISCO-ATM-IF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-ATM-IF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:50:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
atmInterfaceConfEntry, = mibBuilder.importSymbols("ATM-MIB", "atmInterfaceConfEntry")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
IpAddress, Counter32, iso, ObjectIdentity, Bits, Integer32, Unsigned32, MibIdentifier, Gauge32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, TimeTicks, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter32", "iso", "ObjectIdentity", "Bits", "Integer32", "Unsigned32", "MibIdentifier", "Gauge32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "TimeTicks", "NotificationType")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
ciscoAtmIfMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 14))
ciscoAtmIfMIB.setRevisions(('2002-02-13 00:00', '2001-08-08 00:00', '2001-05-21 00:00', '2000-04-11 00:00', '1999-03-11 00:00', '1997-11-30 00:00', '1997-09-10 00:00', '1996-11-01 00:00', '1996-10-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoAtmIfMIB.setRevisionsDescriptions(('Deprecated ciscoAtmIfSvcMinVci in favor of object ciscoatmInterfaceConfMinSvccVcc with greater capability in the CISCO-ATM2-MIB. Added a notification object to send out a trap when ILMI or SSCOP changes state. Also adding an object to enable or disable this notification.', 'Added enum aini for the object ciscoAtmIfType.', 'Add new per-service category SVC UPC Intent objects ciscoAtmIfSvcUpcIntentCbr, ciscoAtmIfSvcUpcIntentVbrRt, ciscoAtmIfSvcUpcIntentVbrNrt, ciscoAtmIfSvcUpcIntentAbr, ciscoAtmIfSvcUpcIntentUbr. Deprecate the old per-interface SVC UPC intent object ciscoAtmIfSvcUpcIntent.', 'Added o A collection of objects that count UPC violations and number of cells discarded due to various conditions on ATM interfaces. o Added ILMI state and SSCOP state monitoring variables. o Fixed the lines in DESCRIPTION section for various objects that failed the line length check by mib-police. o Introduced a new Group object to obsolete ciscoAtmIfMIBGroup3 as it contained objects with incompatible status.', 'Clarified the description of SVC UPC Intent object that it is defined for logical ATM interfaces too.', 'Added ciscoAtmIfConfigAESA ciscoAtmIfDerivedAESA ciscoAtmIfE164Address ciscoAtmIfE164AutoConversionOnly objects.', 'Updated description of ciscoAtmIfSignallingAdminStatus object. Restriction that the object value be modified only when the ifAdminStatus is down has been removed.', 'Added Nsap Address and Well Known VC configuration variables.', 'Added SVC UPC intent configuration variable.',))
if mibBuilder.loadTexts: ciscoAtmIfMIB.setLastUpdated('200202130000Z')
if mibBuilder.loadTexts: ciscoAtmIfMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoAtmIfMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-atm@cisco.com')
if mibBuilder.loadTexts: ciscoAtmIfMIB.setDescription('A MIB module for an ATM interface configuration.')
ciscoAtmIfMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 14, 1))
class NsapAtmAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity. The address types are NSAP (20 octets).'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

class AtmAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity. The address types are: no address (0 octets), E.164 (8 octets), network prefix (13 octets), and NSAP (20 octets). Note: The E.164 address is encoded in BCD format.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ValueSizeConstraint(13, 13), ValueSizeConstraint(20, 20), )
class UpcMethod(TextualConvention, Integer32):
    description = 'A textual convention defining options for Usage Parameter Control: passing : take no action on cells considered to violate the traffic contract. tagging : set the CLP bit in the header of cells considered to violate the traffic contract. dropping: discard cells considered to violate the traffic contract.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("passing", 1), ("tagging", 2), ("dropping", 3))

ciscoAtmIfIlmiAccessGlobalDefaultFilter = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("permitAll", 1), ("permitPrefix", 2), ("permitPrefixAndWellknownGroups", 3), ("permitPrefixAndAllGroups", 4))).clone('permitAll')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfIlmiAccessGlobalDefaultFilter.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfIlmiAccessGlobalDefaultFilter.setDescription("The global default access filter which set the per-switch default access filter for ILMI address registration on all interfaces. permitAll - This permits all ILMI registered addresses. permitPrefix - The address being registered by ILMI should have their prefix portion of the address match the ILMI prefixes used on this interface. If there are any per-interface ILMI address prefixes configured, then the prefixes derived from the switch addresses are not considered ILMI prefixes for this interface. permitPrefixAndWellknownGroups - This is same as 'permitPrefix' but in addition it also allows the well-known group addresses. The well-known group addresses will be the old LECS address and any address matching the ATM Forum address prefix for well known addresses. (i.e.,C5.0079.0000.0000.0000.0000.0000.00A03E) permitPrefixAndAllGroups - This is same as 'permitPrefix' but in addition it allows all group addresses.")
ciscoAtmIfNotifsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfNotifsEnabled.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfNotifsEnabled.setDescription('Allows enabling/disabling of notifications for ATM Interface events')
ciscoAtmIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1), )
if mibBuilder.loadTexts: ciscoAtmIfTable.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfTable.setDescription('This table contains ATM local interface configuration parameters, one entry per ATM interface port.')
ciscoAtmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1), )
atmInterfaceConfEntry.registerAugmentions(("CISCO-ATM-IF-MIB", "ciscoAtmIfEntry"))
ciscoAtmIfEntry.setIndexNames(*atmInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: ciscoAtmIfEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfEntry.setDescription(' This list conatins additonal ATM interface configuration parameters and state variables.')
ciscoAtmIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("uni", 2), ("pnni", 3), ("iisp", 4), ("nniPvcOnly", 5), ("aini", 6))).clone('uni')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfType.setDescription('The type of ATM interface which is either a UNI (User to Network), PNNI, IISP or NNI PVC only. To modify the ciscoAtmIftype, ifAdminStatus has to be down and atmIfIlmiAutoConfiguration disabled.')
ciscoAtmIfSide = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("user", 1), ("network", 2), ("notApplicable", 3))).clone('network')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfSide.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSide.setDescription('The side of ATM interface which is either a user or network side.NotApplicable value implies that ciscoAtmIftype is other than uni or iisp.')
ciscoAtmIfUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2))).clone('private')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfUniType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfUniType.setDescription('The type of User to Network interface is either private or public. If ciscoAtmIfType is not uni then ciscoAtmIfUniType value should be ignored.')
ciscoAtmIfPVPs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfPVPs.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfPVPs.setDescription('The number of permanent virtual paths at this interface.')
ciscoAtmIfPVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfPVCs.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfPVCs.setDescription('The number of permanent virtual channels at this interface.')
ciscoAtmIfActiveSVPs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfActiveSVPs.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfActiveSVPs.setDescription('The number of active switched virtual paths at this interface.')
ciscoAtmIfActiveSVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfActiveSVCs.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfActiveSVCs.setDescription('The number of active switched virtual channels at this interface.')
ciscoAtmIfTotalConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfTotalConnections.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfTotalConnections.setDescription('The total number of existing connections at this interface.')
ciscoAtmIfConfVplIf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfConfVplIf.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfConfVplIf.setDescription('The number of configured VP interfaces at this physical interface.')
ciscoAtmIfPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))).clone(namedValues=NamedValues(("other", 1), ("cpu", 2), ("ethernet", 3), ("oc3Utp", 4), ("oc3SingleModeFiber", 5), ("oc3MultiModeFiber", 6), ("oc12SingleModeFiber", 7), ("ds3", 8), ("e3", 9), ("ds1", 10), ("e1", 11), ("oc3Utp3", 12), ("oc3Utp5", 13), ("oc3SmIr", 14), ("oc3SmIrPlus", 15), ("oc3SmLr", 16), ("oc3Pof", 17), ("oc12MultiModeFiber", 18), ("oc12SmIr", 19), ("oc12SmIrPlus", 20), ("oc12SmLr", 21), ("oc12Pof", 22), ("oc12SmLr2", 23), ("oc12SmLr3", 24), ("atm25", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfPortType.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfPortType.setDescription('The type of physical layer medium on the port.')
ciscoAtmIfXmitLed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 1), ("steadyGreen", 2), ("steadyYellow", 3), ("steadyRed", 4), ("flashGreen", 5), ("flashYellow", 6), ("flashRed", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfXmitLed.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfXmitLed.setDescription('The transmit LED color of this port.')
ciscoAtmIfRecvLed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 1), ("steadyGreen", 2), ("steadyYellow", 3), ("steadyRed", 4), ("flashGreen", 5), ("flashYellow", 6), ("flashRed", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfRecvLed.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfRecvLed.setDescription('The receive LED color of this port.')
ciscoAtmIfXmitCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfXmitCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfXmitCells.setDescription('The number of cells transmitted of this interface, including p2p and p2mp cells.')
ciscoAtmIfRecvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfRecvCells.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfRecvCells.setDescription('The number of cells received of this interface, including p2p and p2mp cells.')
ciscoAtmIfSvcMinVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfSvcMinVci.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmIfSvcMinVci.setDescription("The minimum of the range of values from which VCI's are assigned to new SVC connections. By this value being larger, more VCI's are reserved for setting up PVCs. This applies to every VPI of the physical interface and every logical port. The object is deprecated because it is recommended to use ciscoAtmInterfaceConfMinSvccVci of the CISCO-ATM2-MIB which is meant for the same purpose.")
ciscoAtmIfIlmiConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfIlmiConfiguration.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfIlmiConfiguration.setDescription('Enable/Disable ILMI configuration on this interface. The configuration takes effect only on the next interface restart. Disabling this object will also disable atmIfIlmiAddressRegistration and atmIfIlmiAutoConfiguration and atmIfIlmiKeepAlive')
ciscoAtmIfIlmiAddressRegistration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfIlmiAddressRegistration.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfIlmiAddressRegistration.setDescription('Enable/Disable ILMI Address Registration on on this interface. The configuration takes effect only on the next interface restart.')
ciscoAtmIfIlmiAutoConfiguration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfIlmiAutoConfiguration.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfIlmiAutoConfiguration.setDescription('Enable/Disable ILMI link and interface type determination. The configuration takes effect only on the next interface restart.')
ciscoAtmIfIlmiKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfIlmiKeepAlive.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfIlmiKeepAlive.setDescription('The amount of time that should elapse between successive ILMI keepalive messages sent on this interface. A value of 0 disables ILMI keepalive messages on this interface.')
ciscoAtmIfSoftVcDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 20), NsapAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfSoftVcDestAddress.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSoftVcDestAddress.setDescription('The 20 byte ATM address of the destination ATM interface for soft ATM PVC/PVP')
ciscoAtmIfUniSignallingVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("atmfUni3Dot0", 2), ("atmfUni3Dot1", 3), ("atmfUni4Dot0", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfUniSignallingVersion.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfUniSignallingVersion.setDescription("The version of UNI signalling that is currently being used on the interface. The appropriate value, either atmfUni3Dot0, atmfUni3Dot1 or atmfUni4Dot0, is used when the interface is an UNI or IISP interface. The value notApplicable is used when the interface is a PNNI interface or when signalling is disabled. This may reflect a manually configured value for the signalling version, or may be determined by other means such as auto-configuration.Setting this variable to a value of 'notApplicable' is not allowed. To modify the ciscoAtmIfUniSignallingVersion, ifAdminStatus has to be down and atmIfIlmiAutoConfiguration disabled.")
ciscoAtmIfSvcUpcIntent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("passing", 1), ("tagging", 2), ("dropping", 3))).clone('passing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntent.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntent.setDescription('Determines the policing (Usage Parameter Control or UPC) action to take for SVCs established through this interface. Values other than passing are allowed only if policing is supported on the interface. Also serves to determine UPC to use on the terminating (destination) half-leg of Soft PVCs. This object has been deprecated in favor of the per-service category objects ciscoAtmIfSvcUpcIntentCbr, ciscoAtmIfSvcUpcIntentVbrRt, ciscoAtmIfSvcUpcIntentVbrNrt, ciscoAtmIfSvcUpcIntentAbr, ciscoAtmIfSvcUpcIntentUbr. Note that if those objects are set to different values, the return value for this object cannot be correct.')
ciscoAtmIfAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nsap", 1), ("esi", 2), ("e164", 3), ("null", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfAddressType.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfAddressType.setDescription('An indication of the type of the ATM addresses on this interface. To configure a new atm address, set ciscoAtmIfAddress to the address, then set this object to ether nsap(1), or esi(2), or e164(3), depending on the type of address of ciscoAtmIfAddress. To delete the address, set this object to null(4). Adding nsap address type to this interface has the effect of canceling the existing esi address, if there is one. Similarly, adding the esi address on this interface also has the effect of removing the existing nsap address. The value of ciscoAtmIfAddress has no effect when this object is set to null(4). For the switch, the nsap/esi address can only exist on the cpu port for signalling applications.')
ciscoAtmIfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 24), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(6, 6), ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfAddress.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfAddress.setDescription('The ATM address of this interface, which can be either nsap, esi or e164. For the switch, the nsap/esi address can only exist on the cpu port.')
ciscoAtmIfWellKnownVcMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2), ("manualDeleteUponEntry", 3))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfWellKnownVcMode.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfWellKnownVcMode.setDescription("Indicates whether well-known VCs should be automatically or manually created for the interface. In automatic(1) mode, well-known VCs will be created with default VPI/VCI values upon startup or upon entry to the automatic mode. While in this mode, well-known VCs will not be allowed to be deleted or modified by user commands. This is the default mode at startup for equipment which supports automatic well-known VC creation. In manual(2) mode, well-known VCs won't be automatically created. Instead, the user will be allowed to delete and create PVCs with the reserved encapsulation types aalQsAal, aal5Ilmi, and aal5Pnni as applicable. And these PVCs will be allowed to have VCI values in the range <5-16383>, instead of <32-16383>. The manualDeleteUponEntry(3) action causes any existing VCs with reserved encapsulation types (aalQsAal, aal5Ilmi or aal5Pnni) to be deleted for this interface as it enters the manual state.")
ciscoAtmIfSignallingAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfSignallingAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSignallingAdminStatus.setDescription('Enable/Disable signalling/sscop on this interface.The disabled(2) action causes all the active SVCs on this interface to be cleared.')
ciscoAtmIfCdLed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("steadyGreen", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfCdLed.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfCdLed.setDescription('The Cd LED color of this port.')
ciscoAtmIfIlmiAccessFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("permitAll", 1), ("permitPrefix", 2), ("permitPrefixAndWellknownGroups", 3), ("permitPrefixAndAllGroups", 4), ("useGlobalDefaultFilter", 5))).clone('useGlobalDefaultFilter')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfIlmiAccessFilter.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfIlmiAccessFilter.setDescription("The access filter which allows or denies certain ILMI registered addresses on this interface when ciscoAtmIfIlmiAddressRegistration is set to enable(1). permitAll - This permits all ILMI registered addresses. permitPrefix - The address being registered by ILMI should have their prefix portion of the address match the ILMI prefixes used on this interface. If there are any per-interface ILMI address prefixes configured, then the prefixes derived from the switch addresses are not considered ILMI prefixes for this interface. permitPrefixAndWellknownGroups - This is same as 'permitPrefix' but in addition it also allows the well-known group addresses. The well-known group addresses will be the old LECS address and any address matching the ATM Forum address prefix for well known addresses. (i.e.,C5.0079.0000.0000.0000.0000.0000.00A03E) permitPrefixAndAllGroups - This is same as 'permitPrefix' but in addition it allows all group addresses. useGlobalDefaultFilter - It indicates that this interface uses the per-switch global default filter")
ciscoAtmIfConfigAESA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 35), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(7, 7), ValueSizeConstraint(20, 20), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfConfigAESA.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfConfigAESA.setDescription('The ATM End System Address (AESA) of this interface can be configured by entering the full 20 octet AESA, or the 6 octet ESI and 1 octet Selector Byte. If the ESI and Selector Byte are entered, the full AESA will be formed using a 13 octet prefix from ILMI. The full AESA can be read using ciscoAtmIfDerivedAESA. A length of zero indicates that no AESA is configured. For the switch, the AESA address can only exist on the cpu port.')
ciscoAtmIfDerivedAESA = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 36), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfDerivedAESA.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfDerivedAESA.setDescription('The ATM End System Address (AESA) of this interface. The AESA is configured using ciscoAtmIfConfigAESA or can be automatically generated. A length of zero indicates that no AESA is specified. For the switch, the AESA address can only exist on the cpu port.')
ciscoAtmIfE164Address = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 37), AtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfE164Address.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfE164Address.setDescription('The ATM E164 address of this interface. When a native E.164 number is configured for this inteface, only native E.164 numbers are transmitted/received as the called/calling party numbers. The presence of an ATM E164 address allows both an algorithmic translation between the native E164 number and E164 AESA address formats (see ciscoAtmIfE164AutoConversionOnly) and use of the ATM E164 Address for the calling/called party number of transmitted/received calls. Entering an address will disable ciscoAtmIfE164AutoConversionOnly. An address of length zero indicates that no address is specified. For the switch, the E164 address cannot exist on the cpu port.')
ciscoAtmIfE164AutoConversionOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 38), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfE164AutoConversionOnly.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfE164AutoConversionOnly.setDescription('Enable/Disable E164 auto conversion only on this interface. The E164 auto-conversion allows for algorithmic translation between the native E164 number and E164 AESA address formats. This object is used when there is no native E.164 number specified for this interface (see ciscoAtmIfE164Address), to specify that only native E.164 numbers are transmitted/received as the called/calling party numbers and to enable/disable E164 auto-conversion. For the switch, E164 auto-conversion cannot exist on the cpu port.')
ciscoAtmIfRxCellUpcViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfRxCellUpcViolations.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfRxCellUpcViolations.setDescription('The total number of nonconforming cells detected by Usage Parameter Control (UPC) for cells received on this interface. This object is not instantiated on systems that do not have support for collecting such statistics.')
ciscoAtmIfRxCellDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfRxCellDiscards.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfRxCellDiscards.setDescription('The total number of cells that were discarded within the switch. The cells can be discarded due to non conformance detected by Usage Parameter Control (UPC) or queue overflows within the switch. This object is not instantiated on systems that do not have support for collecting such statistics.')
ciscoAtmIfIlmiFSMState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("restarting", 2), ("waitDevType", 3), ("deviceAndPortTypeComplete", 4), ("awaitPnniConfig", 5), ("pnniConfigComplete", 6), ("awaitRestartAck", 7), ("upAndNormal", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfIlmiFSMState.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfIlmiFSMState.setDescription('The ILMI states meaningful when the value of ciscoAtmIfIlmiConfiguration indicates that the ILMI is enabled for an ATM interface: down -- Stopped or just booted or interface down restarting -- Establishing link connectivity waitDevType -- Awaiting device type from peer deviceAndPortTypeComplete -- Determined device and/or port type awaitPnniConfig -- Awaiting PNNI configuration from peer pnniConfigComplete -- Completed interface PNNI configuration awaitRestartAck -- Awaiting peer range values after restart upAndNormal -- Up and normal.')
ciscoAtmIfIlmiUpDownChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfIlmiUpDownChanges.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfIlmiUpDownChanges.setDescription('The number of times ILMI enters and leaves the state of upAndNormal.')
ciscoAtmIfSscopFSMState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("idle", 1), ("outgoingConnectionPending", 2), ("incomingConnectionPending", 3), ("dataTransferReady", 4), ("outgoingDisconnectionPending", 5), ("outgoingResyncPending", 6), ("incomingResyncPending", 7), ("outgoingRecoveryPending", 8), ("incomingRecoveryPending", 9), ("concurrentResyncPending", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfSscopFSMState.setReference('ITU-T Recommendation Q.2110 (07/94)')
if mibBuilder.loadTexts: ciscoAtmIfSscopFSMState.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSscopFSMState.setDescription('The SSCOP state for an ATM interface as defined by the ITU-T. The state is idle when the interface is down or SSCOP is not enabled on the ATM interface')
ciscoAtmIfSscopUpDownChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciscoAtmIfSscopUpDownChanges.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSscopUpDownChanges.setDescription('The number of times SSCOP enters and leaves the state of DataTransferReady.')
ciscoAtmIfSvcUpcIntentCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 45), UpcMethod().clone('passing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentCbr.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentCbr.setDescription('Determines the policing (Usage Parameter Control or UPC) action to take for Constant Bit Rate SVCs established through this interface. Values other than passing are allowed only if policing is supported on the interface. Also serves to determine UPC to use on the terminating (destination) half-leg of Soft PVCs.')
ciscoAtmIfSvcUpcIntentVbrRt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 46), UpcMethod().clone('passing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentVbrRt.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentVbrRt.setDescription('Determines the policing (Usage Parameter Control or UPC) action to take for Variable Bit Rate - Real Time SVCs established through this interface. Values other than passing are allowed only if policing is supported on the interface. Also serves to determine UPC to use on the terminating (destination) half-leg of Soft PVCs.')
ciscoAtmIfSvcUpcIntentVbrNrt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 47), UpcMethod().clone('passing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentVbrNrt.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentVbrNrt.setDescription('Determines the policing (Usage Parameter Control or UPC) action to take for Variable Bit Rate - Non Real Time SVCs established through this interface. Values other than passing are allowed only if policing is supported on the interface. Also serves to determine UPC to use on the terminating (destination) half-leg of Soft PVCs.')
ciscoAtmIfSvcUpcIntentAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 48), UpcMethod().clone('passing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentAbr.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentAbr.setDescription('Determines the policing (Usage Parameter Control or UPC) action to take for Available Bit Rate SVCs established through this interface. Values other than passing are allowed only if policing is supported on the interface. Also serves to determine UPC to use on the terminating (destination) half-leg of Soft PVCs.')
ciscoAtmIfSvcUpcIntentUbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 14, 1, 1, 1, 49), UpcMethod().clone('passing')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentUbr.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfSvcUpcIntentUbr.setDescription('Determines the policing (Usage Parameter Control or UPC) action to take for Unspecified Bit Rate SVCs established through this interface. Values other than passing are allowed only if policing is supported on the interface. Also serves to determine UPC to use on the terminating (destination) half-leg of Soft PVCs.')
ciscoAtmIfMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 14, 0))
ciscoAtmIfEvent = NotificationType((1, 3, 6, 1, 4, 1, 9, 10, 14, 0, 1)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiFSMState"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSscopFSMState"))
if mibBuilder.loadTexts: ciscoAtmIfEvent.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfEvent.setDescription('This notification is generated when ever ILMI or SSCOP FSM state changes')
ciscoAtmIfMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 14, 3))
ciscoAtmIfMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1))
ciscoAtmIfMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2))
ciscoAtmIfMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1, 1)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBCompliance = ciscoAtmIfMIBCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfMIBCompliance.setDescription('The compliance statement for the Cisco ATM interface group.')
ciscoAtmIfMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1, 2)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBCompliance2 = ciscoAtmIfMIBCompliance2.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfMIBCompliance2.setDescription('The compliance statement for the Cisco ATM interface group.')
ciscoAtmIfMIBCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1, 3)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup2"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup3"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBCompliance3 = ciscoAtmIfMIBCompliance3.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfMIBCompliance3.setDescription('The compliance statement for the Cisco ATM interface group.')
ciscoAtmIfMIBCompliance4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1, 4)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup2"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup3"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup4"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBCompliance4 = ciscoAtmIfMIBCompliance4.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfMIBCompliance4.setDescription('The compliance statement for the Cisco ATM interface group.')
ciscoAtmIfMIBCompliance5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1, 5)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup2"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup3"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup4"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup5"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBCompliance5 = ciscoAtmIfMIBCompliance5.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfMIBCompliance5.setDescription('The compliance statement for the Cisco ATM interface group.')
ciscoAtmIfMIBCompliance6 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1, 6)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup2"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup4"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup5"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup6"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup7"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBCompliance6 = ciscoAtmIfMIBCompliance6.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfMIBCompliance6.setDescription('The compliance statement for the Cisco ATM interface group.')
ciscoAtmIfMIBCompliance7 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1, 7)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup4"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup5"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup6"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup7"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup8"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBCompliance7 = ciscoAtmIfMIBCompliance7.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmIfMIBCompliance7.setDescription('The compliance statement for the Cisco ATM interface group.')
ciscoAtmIfMIBCompliance8 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 1, 8)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup4"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup5"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup6"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup7"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup8"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup9"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfMIBGroup10"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBCompliance8 = ciscoAtmIfMIBCompliance8.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfMIBCompliance8.setDescription('The compliance statement for the Cisco ATM interface group.')
ciscoAtmIfMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 1)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfType"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSide"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfUniType"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfPVPs"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfPVCs"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfActiveSVPs"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfActiveSVCs"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfTotalConnections"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfConfVplIf"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfPortType"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfXmitLed"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfRecvLed"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfXmitCells"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfRecvCells"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSvcMinVci"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiConfiguration"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiAddressRegistration"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiAutoConfiguration"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiKeepAlive"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSoftVcDestAddress"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfCdLed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup = ciscoAtmIfMIBGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup.setDescription('A collection of objects providing the information about ATM interface related information also an ability to configure certain parameters of ATM interface.')
ciscoAtmIfMIBGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 2)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfUniSignallingVersion"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSvcUpcIntent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup2 = ciscoAtmIfMIBGroup2.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup2.setDescription('Additional collection of objects providing ATM interface related information.')
ciscoAtmIfMIBGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 3)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfAddressType"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfAddress"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfWellKnownVcMode"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSignallingAdminStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup3 = ciscoAtmIfMIBGroup3.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup3.setDescription('Additional collection of objects providing ATM interface related information.')
ciscoAtmIfMIBGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 4)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiAccessGlobalDefaultFilter"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiAccessFilter"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup4 = ciscoAtmIfMIBGroup4.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup4.setDescription('Additional collection of objects providing ATM switch and interface related information on Access Filter for ILMI Address Registration.')
ciscoAtmIfMIBGroup5 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 5)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfConfigAESA"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfDerivedAESA"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfE164Address"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfE164AutoConversionOnly"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup5 = ciscoAtmIfMIBGroup5.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup5.setDescription('Additional collection of objects providing ATM switch and interface related information for ATM Addresses.')
ciscoAtmIfMIBGroup6 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 6)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfWellKnownVcMode"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSignallingAdminStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup6 = ciscoAtmIfMIBGroup6.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup6.setDescription('Additional collection of objects providing ATM interface related information.')
ciscoAtmIfMIBGroup7 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 7)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfRxCellUpcViolations"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfRxCellDiscards"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiFSMState"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiUpDownChanges"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSscopFSMState"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSscopUpDownChanges"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup7 = ciscoAtmIfMIBGroup7.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup7.setDescription('Additional collection of objects providing ATM switch interface Resource Manager, ILMI and Signalling related information.')
ciscoAtmIfMIBGroup8 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 8)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfUniSignallingVersion"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSvcUpcIntentCbr"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSvcUpcIntentVbrRt"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSvcUpcIntentVbrNrt"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSvcUpcIntentAbr"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSvcUpcIntentUbr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup8 = ciscoAtmIfMIBGroup8.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup8.setDescription('Additional collection of objects providing ATM interface related information.')
ciscoAtmIfMIBGroup9 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 9)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfType"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSide"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfUniType"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfPVPs"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfPVCs"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfActiveSVPs"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfActiveSVCs"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfTotalConnections"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfConfVplIf"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfPortType"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfXmitLed"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfRecvLed"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfXmitCells"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfRecvCells"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiConfiguration"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiAddressRegistration"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiAutoConfiguration"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfIlmiKeepAlive"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfSoftVcDestAddress"), ("CISCO-ATM-IF-MIB", "ciscoAtmIfCdLed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup9 = ciscoAtmIfMIBGroup9.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup9.setDescription('A collection of objects providing the information about ATM interface related information also an ability to configure certain parameters of ATM interface.')
ciscoAtmIfMIBGroup10 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 10)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfNotifsEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfMIBGroup10 = ciscoAtmIfMIBGroup10.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfMIBGroup10.setDescription('Additional objects providing means to enable/disable notifications related to the interface ILMI and SSCOP state')
ciscoAtmIfNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 10, 14, 3, 2, 11)).setObjects(("CISCO-ATM-IF-MIB", "ciscoAtmIfEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmIfNotifyGroup = ciscoAtmIfNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmIfNotifyGroup.setDescription('Interface ILMI and SSCOP FSM notifications')
mibBuilder.exportSymbols("CISCO-ATM-IF-MIB", ciscoAtmIfMIBGroup2=ciscoAtmIfMIBGroup2, ciscoAtmIfPVCs=ciscoAtmIfPVCs, ciscoAtmIfSvcUpcIntentUbr=ciscoAtmIfSvcUpcIntentUbr, ciscoAtmIfE164AutoConversionOnly=ciscoAtmIfE164AutoConversionOnly, ciscoAtmIfSvcUpcIntentVbrNrt=ciscoAtmIfSvcUpcIntentVbrNrt, ciscoAtmIfMIBNotifications=ciscoAtmIfMIBNotifications, ciscoAtmIfIlmiKeepAlive=ciscoAtmIfIlmiKeepAlive, NsapAtmAddr=NsapAtmAddr, ciscoAtmIfConfigAESA=ciscoAtmIfConfigAESA, ciscoAtmIfSvcUpcIntentCbr=ciscoAtmIfSvcUpcIntentCbr, ciscoAtmIfSvcUpcIntentVbrRt=ciscoAtmIfSvcUpcIntentVbrRt, ciscoAtmIfRecvLed=ciscoAtmIfRecvLed, ciscoAtmIfUniSignallingVersion=ciscoAtmIfUniSignallingVersion, ciscoAtmIfIlmiFSMState=ciscoAtmIfIlmiFSMState, ciscoAtmIfRxCellDiscards=ciscoAtmIfRxCellDiscards, ciscoAtmIfWellKnownVcMode=ciscoAtmIfWellKnownVcMode, ciscoAtmIfSignallingAdminStatus=ciscoAtmIfSignallingAdminStatus, ciscoAtmIfUniType=ciscoAtmIfUniType, ciscoAtmIfDerivedAESA=ciscoAtmIfDerivedAESA, ciscoAtmIfMIBCompliance5=ciscoAtmIfMIBCompliance5, ciscoAtmIfMIBGroup8=ciscoAtmIfMIBGroup8, ciscoAtmIfEntry=ciscoAtmIfEntry, ciscoAtmIfMIBCompliance=ciscoAtmIfMIBCompliance, ciscoAtmIfType=ciscoAtmIfType, ciscoAtmIfAddress=ciscoAtmIfAddress, ciscoAtmIfIlmiAccessFilter=ciscoAtmIfIlmiAccessFilter, ciscoAtmIfMIB=ciscoAtmIfMIB, ciscoAtmIfXmitLed=ciscoAtmIfXmitLed, ciscoAtmIfTable=ciscoAtmIfTable, ciscoAtmIfMIBCompliance3=ciscoAtmIfMIBCompliance3, ciscoAtmIfMIBGroups=ciscoAtmIfMIBGroups, ciscoAtmIfIlmiConfiguration=ciscoAtmIfIlmiConfiguration, ciscoAtmIfXmitCells=ciscoAtmIfXmitCells, ciscoAtmIfMIBGroup=ciscoAtmIfMIBGroup, ciscoAtmIfNotifyGroup=ciscoAtmIfNotifyGroup, ciscoAtmIfMIBCompliance2=ciscoAtmIfMIBCompliance2, ciscoAtmIfEvent=ciscoAtmIfEvent, ciscoAtmIfRxCellUpcViolations=ciscoAtmIfRxCellUpcViolations, ciscoAtmIfMIBGroup7=ciscoAtmIfMIBGroup7, ciscoAtmIfMIBGroup5=ciscoAtmIfMIBGroup5, ciscoAtmIfActiveSVPs=ciscoAtmIfActiveSVPs, ciscoAtmIfRecvCells=ciscoAtmIfRecvCells, ciscoAtmIfMIBGroup6=ciscoAtmIfMIBGroup6, ciscoAtmIfMIBCompliance6=ciscoAtmIfMIBCompliance6, PYSNMP_MODULE_ID=ciscoAtmIfMIB, ciscoAtmIfMIBCompliance4=ciscoAtmIfMIBCompliance4, ciscoAtmIfIlmiUpDownChanges=ciscoAtmIfIlmiUpDownChanges, ciscoAtmIfTotalConnections=ciscoAtmIfTotalConnections, ciscoAtmIfSvcMinVci=ciscoAtmIfSvcMinVci, ciscoAtmIfPVPs=ciscoAtmIfPVPs, ciscoAtmIfConfVplIf=ciscoAtmIfConfVplIf, AtmAddr=AtmAddr, ciscoAtmIfE164Address=ciscoAtmIfE164Address, ciscoAtmIfCdLed=ciscoAtmIfCdLed, ciscoAtmIfSscopFSMState=ciscoAtmIfSscopFSMState, ciscoAtmIfSvcUpcIntent=ciscoAtmIfSvcUpcIntent, ciscoAtmIfIlmiAccessGlobalDefaultFilter=ciscoAtmIfIlmiAccessGlobalDefaultFilter, ciscoAtmIfMIBGroup9=ciscoAtmIfMIBGroup9, ciscoAtmIfSoftVcDestAddress=ciscoAtmIfSoftVcDestAddress, ciscoAtmIfMIBGroup10=ciscoAtmIfMIBGroup10, ciscoAtmIfAddressType=ciscoAtmIfAddressType, ciscoAtmIfSvcUpcIntentAbr=ciscoAtmIfSvcUpcIntentAbr, ciscoAtmIfMIBCompliances=ciscoAtmIfMIBCompliances, ciscoAtmIfMIBConformance=ciscoAtmIfMIBConformance, ciscoAtmIfMIBObjects=ciscoAtmIfMIBObjects, ciscoAtmIfIlmiAutoConfiguration=ciscoAtmIfIlmiAutoConfiguration, ciscoAtmIfSscopUpDownChanges=ciscoAtmIfSscopUpDownChanges, ciscoAtmIfMIBGroup3=ciscoAtmIfMIBGroup3, ciscoAtmIfPortType=ciscoAtmIfPortType, ciscoAtmIfIlmiAddressRegistration=ciscoAtmIfIlmiAddressRegistration, ciscoAtmIfMIBGroup4=ciscoAtmIfMIBGroup4, ciscoAtmIfSide=ciscoAtmIfSide, ciscoAtmIfMIBCompliance7=ciscoAtmIfMIBCompliance7, UpcMethod=UpcMethod, ciscoAtmIfActiveSVCs=ciscoAtmIfActiveSVCs, ciscoAtmIfMIBCompliance8=ciscoAtmIfMIBCompliance8, ciscoAtmIfNotifsEnabled=ciscoAtmIfNotifsEnabled)

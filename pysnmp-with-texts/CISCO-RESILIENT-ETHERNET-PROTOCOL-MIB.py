#
# PySNMP MIB module CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:10:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoVlanList, = mibBuilder.importSymbols("CISCO-TC", "CiscoVlanList")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
VlanId, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Unsigned32, Counter32, NotificationType, ModuleIdentity, Integer32, iso, TimeTicks, Counter64, Gauge32, ObjectIdentity, IpAddress, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Unsigned32", "Counter32", "NotificationType", "ModuleIdentity", "Integer32", "iso", "TimeTicks", "Counter64", "Gauge32", "ObjectIdentity", "IpAddress", "MibIdentifier")
TruthValue, TimeStamp, DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TimeStamp", "DisplayString", "RowStatus", "TextualConvention")
ciscoResilientEthernetProtocolMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 601))
ciscoResilientEthernetProtocolMIB.setRevisions(('2011-01-11 00:00', '2010-10-27 00:00', '2007-05-22 00:00', '2007-02-19 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoResilientEthernetProtocolMIB.setRevisionsDescriptions(('Modified crepIfPortRole object to include failedPortNoNeighbor and failedPortLogicalOpen states.', "Extended 'RepPortType' to allow 'edgeNoNeighbor' and 'edgeNoNeighborPrimary'. This was done to support REP Edge No Neighbor feature.", "Modified 'crepSegmentPreemptStatus' and 'crepIfOperStatus' objects.", 'Initial Version of the MIB.',))
if mibBuilder.loadTexts: ciscoResilientEthernetProtocolMIB.setLastUpdated('201101110000Z')
if mibBuilder.loadTexts: ciscoResilientEthernetProtocolMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoResilientEthernetProtocolMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-lan-switch-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoResilientEthernetProtocolMIB.setDescription('This MIB module defines objects required for managing Resilient Ethernet Protocol (REP). Resilient Ethernet Protocol (REP) is a Cisco proprietary protocol that provides an alternative to Spanning Tree Protocol (STP) to control network loops, handle link failures and improve convergence time. REP controls a group of ports connected in a segment; ensures that the segment does not create any bridging loops, and responds to link failures within the segment. The following diagram depicts a REP segment: [Sw E1]E---NE[Sw 1]NE---NE[Sw 2]NE......... . . [Sw E2]E---NE[Sw N]NE---NE[Sw N-1]NE....... Sw : Switch. E : Edge port. NE : Non-Edge port. E1/E2: Edge switches. E1 and E2 can either be same or different switches. A REP segment is a chain of ports connected to each other and configured with a segment identifier. Each segment consists of standard (non-edge) segment ports and up to two edge ports. A device can have only two ports that belong to the same segment, and each segment port can have only one external neighbor. One edge port in a REP segment acts as the primary edge port; the other as the secondary edge port. It is the primary edge port that always participates in VLAN load balancing in a REP segment. REP VLAN load balancing is achieved by blocking some VLANs at a configured alternate port and all other VLANs at an edge port. The execution (preemption) of VLAN load balancing is triggered by manually enforcing it or after a pre-defined delay, after the REP segment is complete. When segment is completed, all ports will be in open state except one port that can be in alternate state that is used for VLAN load balancing as explained above.')
class RepPortType(TextualConvention, Integer32):
    description = "This TC describes the port type of the REP port. 'notEdge' - non-edge Port. 'edge' - edge port for the segment. 'edgePrimary' - primary edge port for the segment. 'edgeNoNeighbor' - no neighbor edge port for the segment. 'edgeNoNeighborPrimary' - primary no neighbor edge port for the segment."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("notEdge", 1), ("edge", 2), ("edgePrimary", 3), ("edgeNoNeighbor", 4), ("edgeNoNeighborPrimary", 5))

class RepSegmentId(TextualConvention, Unsigned32):
    description = 'This TC describes an object to provide the unique identifier for the REP segment.'
    status = 'current'

class RepSegmentList(TextualConvention, OctetString):
    description = "This TC describes an object that indicates the list of REP segments. Each octet within this value specifies a set of eight segments. The first octet represents the first 8 segments of the range of segments specified by the object, the second octet represents the next 8 segments etc. Within each octet, the most significant bit represents the lowest numbered segment, and the least significant bit represents the highest numbered segment. If that bit has a value of '1' then that segment is included in the set of segments; the segment is not included if its bit has a value of '0'. NMS may omit any zero-valued octets from the end of this string in order to reduce SetPDU size, and the agent may also omit zero-valued trailing octets, to reduce the size of GetResponse PDUs. The maximum length of the object that uses this TC is calculated to be the ceiling whole number of ((crepMaxSegmentId - crepMinSegmentId + 1) / 8). Any octets beyond this length in the SetPDU should be ignored."
    status = 'current'

ciscoRepMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 601, 0))
ciscoRepMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 601, 1))
ciscoRepMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 601, 2))
crepGlobalInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 1))
crepInterfaceConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2))
crepSegmentConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3))
crepSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3, 1), )
if mibBuilder.loadTexts: crepSegmentTable.setStatus('current')
if mibBuilder.loadTexts: crepSegmentTable.setDescription('This table specifies REP segments configured on the device.')
crepSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepSegmentId"))
if mibBuilder.loadTexts: crepSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: crepSegmentEntry.setDescription('A list of REP segment entries. The number of segments configured on the device determines the number of entries. An entry is created when a segment identifier value is configured on an interface and no matching entry exists already. The entry is deleted once the segment ceases to exist on the device.')
crepSegmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3, 1, 1, 1), RepSegmentId())
if mibBuilder.loadTexts: crepSegmentId.setStatus('current')
if mibBuilder.loadTexts: crepSegmentId.setDescription('This object identifies the segment identifier.')
crepSegmentInterface1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3, 1, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepSegmentInterface1.setReference("K. McCloghrie and F. Kastenholz, 'The Interfaces Group MIB', RFC-2863, June 2000.")
if mibBuilder.loadTexts: crepSegmentInterface1.setStatus('current')
if mibBuilder.loadTexts: crepSegmentInterface1.setDescription('This object indicates the ifIndex-value assigned to the first interface that is part of the segment.')
crepSegmentInterface2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3, 1, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepSegmentInterface2.setReference("K. McCloghrie and F. Kastenholz, 'The Interfaces Group MIB', RFC-2863, June 2000.")
if mibBuilder.loadTexts: crepSegmentInterface2.setStatus('current')
if mibBuilder.loadTexts: crepSegmentInterface2.setDescription('This object indicates the ifIndex-value assigned to the second interface that is part of the segment. The value of zero means that the InterfaceIndex is not known. The reasons for value being zero might include the second interface might not yet been configured for this segment and the device may be the edge of the segment.')
crepSegmentComplete = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepSegmentComplete.setStatus('current')
if mibBuilder.loadTexts: crepSegmentComplete.setDescription('This object indicates if the segment is complete such that no port in the segment is in failed state.')
crepSegmentPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crepSegmentPreempt.setStatus('current')
if mibBuilder.loadTexts: crepSegmentPreempt.setDescription('This object should be set to true by NMS for triggering manual preemption. This may cause a momentary traffic disruption. Though this can be done for any node in the segment, it is only effective on the device acting as the REP primary edge. Setting this object false has no effect. This object always returns false when read.')
crepSegmentPreemptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("preemptSuccessful", 2), ("preemptFailure", 3), ("preemptTrigger", 4), ("preemptTriggerFailure", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepSegmentPreemptStatus.setStatus('current')
if mibBuilder.loadTexts: crepSegmentPreemptStatus.setDescription("This object indicates the status of the last preemption trigger. 'none' - preemption trigger is not executed. 'preemptSuccessful' - preemption action for the previous trigger is successful. 'preemptFailure' - preemption trigger was successful. However, preemption failed due to some problem on the segment. 'preemptTrigger' - preemption is triggered successfully and the result is awaited. 'preemptTriggerFailure'- preemption on the segment is not performed as the preemption trigger failed. The failure could be due to invalid port ID or neighbor number specified in 'crepBlockPortNumInfo' or 'crepBlockPortIdInfo' respectively, when the value of 'crepLoadBalanceBlockPortType' is 'offset' or 'portId' respectively. In addition, reason for failure can be that crepLoadBalanceBlockPortType = 'prefFlag' and there is no REP port in the segment configured as preferred port. The value should be 'none' on all agents other than the one serving as the primary edge for the segment. The value will be 'none' on the agent serving as the primary edge for the segment if preemption trigger is not executed yet. If the device is not capable of assessing the final outcome of preemption trigger, then the state should remain in 'preemptTrigger' state.")
crepInterfaceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1), )
if mibBuilder.loadTexts: crepInterfaceConfigTable.setStatus('current')
if mibBuilder.loadTexts: crepInterfaceConfigTable.setDescription('This table provides REP configuration for interfaces in the device. This table contains one entry for each interface running REP.')
crepInterfaceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfIndex"))
if mibBuilder.loadTexts: crepInterfaceConfigEntry.setStatus('current')
if mibBuilder.loadTexts: crepInterfaceConfigEntry.setDescription("An entry exists for each interface, if REP is configured on it. On a system that supports REP, all ports with ifType = 'ethernetCsmacd' and those ethernet based virtual ports with ifType = 'propVirtual' also support REP. REP can be configured or unconfigured or modified directly on the agent as well. Dynamically created rows are expected to be non-volatile such that they persist after an agent restarts.")
crepIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: crepIfIndex.setReference("K. McCloghrie and F. Kastenholz, 'The Interfaces Group MIB', RFC-2863, June 2000.")
if mibBuilder.loadTexts: crepIfIndex.setStatus('current')
if mibBuilder.loadTexts: crepIfIndex.setDescription('This object identifies the ifIndex-value assigned to the interface.')
crepIfSegmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 2), RepSegmentId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepIfSegmentId.setStatus('current')
if mibBuilder.loadTexts: crepIfSegmentId.setDescription("This object specifies the segment that the interface is part. This object can be modified when crepIfConfigRowStatus is 'active'. The valid range is from crepMinSegmentId to crepMaxSegmentId.")
crepIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("initDown", 2), ("noNeighbour", 3), ("oneWay", 4), ("twoWay", 5), ("flapping", 6), ("wait", 7), ("unknown", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepIfOperStatus.setStatus('current')
if mibBuilder.loadTexts: crepIfOperStatus.setDescription("This object indicates the current operational link state of the REP port. If a REP configured interface is down, it will be in 'initDown' state. 'none' - REP is not operational on the interface. This value is used when sending the crepLinkStatus notification when REP configuration is removed from the interface. 'initDown' - initial REP link state. 'noNeighbor' - state in which REP is yet to discover its neighbor. 'oneWay' - the state in which messages have been received from the neighbor but the link has not been declared to be twoWay yet. 'twoWay' - the fully operational state for REP. 'flapping' - the state in which there is a mismatch in the received port information (either local or remote) for the neighbor. 'wait' - the forced transient state before REP starts discovering its neighbor. 'unknown' - the link state cannot be determined.")
crepIfPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("failedPort", 1), ("alternatePort", 2), ("openPort", 3), ("failedPortNoNeighbor", 4), ("failedPortLogicalOpen", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepIfPortRole.setStatus('current')
if mibBuilder.loadTexts: crepIfPortRole.setDescription("This object indicates the role or state of a REP port depending on its link status and whether it is forwarding or blocking traffic. 'failedPort' - a port with a non-operational link status, such that no traffic is forwarded on it. 'alternatePort' - a port forwarding traffic only for a subset of VLANs, for the purpose of VLAN load balancing. 'openPort' - a port forwarding traffic for all VLANs. 'failedPortNoNeighbor' - a port with a non-operational link status and does not have a external neighbor. 'failedPortLogicalOpen' - a port with a non-operational link status and does not have a external neighbor but is in forwarding state for traffic.")
crepIfPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepIfPortID.setStatus('current')
if mibBuilder.loadTexts: crepIfPortID.setDescription('This object indicates the REP port identifier automatically assigned by REP when enabled.')
crepIfAdminEdgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 6), RepPortType().clone('notEdge')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepIfAdminEdgePortType.setStatus('current')
if mibBuilder.loadTexts: crepIfAdminEdgePortType.setDescription('This object specifies the configured edge port type for the interface.')
crepIfOperEdgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 7), RepPortType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepIfOperEdgePortType.setStatus('current')
if mibBuilder.loadTexts: crepIfOperEdgePortType.setDescription("This object indicates the actual edge port type for the interface. Value 'edge' indicates that the port is secondary edge port.")
crepIfPreferredConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepIfPreferredConfig.setStatus('current')
if mibBuilder.loadTexts: crepIfPreferredConfig.setDescription("This object specifies if port should get preference to become the alternate port among other equal ports in the segment. Setting this value to true does not guaranty that the port will become the alternate port. 'crepIfPortRole' should be checked for the actual status.")
crepifBlockedVlans1k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 9), CiscoVlanList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepifBlockedVlans1k.setStatus('current')
if mibBuilder.loadTexts: crepifBlockedVlans1k.setDescription("This object specifies the list of VLANs configured to be blocked at the alternate port for VLANs with values of 0 through 1023. If the bit is set to '1', then the VLAN is marked for blocking. This value is only effective on the device acting as the REP primary edge. In addition, this value is effective only if 'crepLoadBalanceBlockPortType' is not 'none'.")
crepifBlockedVlans2k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 10), CiscoVlanList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepifBlockedVlans2k.setStatus('current')
if mibBuilder.loadTexts: crepifBlockedVlans2k.setDescription("This object specifies the list of VLANs configured to be blocked at the alternate port for VLANs with values of 1024 through 2047. If the bit is set to '1', then the VLAN is marked for blocking. This value is only effective on the device acting as the REP primary edge. In addition, this value is effective only if 'crepLoadBalanceBlockPortType' is not 'none'. This object is only instantiated on devices that support the extended VLANs.")
crepifBlockedVlans3k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 11), CiscoVlanList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepifBlockedVlans3k.setStatus('current')
if mibBuilder.loadTexts: crepifBlockedVlans3k.setDescription("This object specifies the list of VLANs configured to be blocked at the alternate port for VLANs with values of 2048 through 3071. If the bit is set to '1', then the VLAN is marked for blocking. This value is only effective on the device acting as the REP primary edge. In addition, this value is effective only if 'crepLoadBalanceBlockPortType' is not 'none'. This object is only instantiated on devices that support the extended VLANs.")
crepifBlockedVlans4k = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 12), CiscoVlanList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepifBlockedVlans4k.setStatus('current')
if mibBuilder.loadTexts: crepifBlockedVlans4k.setDescription("This object specifies the list of VLANs configured to be blocked at the alternate port for VLANs with values of 3072 through 4095. If the bit is set to '1', then the VLAN is marked for blocking. This value is only effective on the device acting as the REP primary edge. In addition, this value is effective only if 'crepLoadBalanceBlockPortType' is not 'none'. This object is only instantiated on devices that support the extended VLANs.")
crepLoadBalanceBlockPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("offset", 2), ("portId", 3), ("prefFlag", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepLoadBalanceBlockPortType.setStatus('current')
if mibBuilder.loadTexts: crepLoadBalanceBlockPortType.setDescription("This object specifies the method defined to identify the alternate port in the segment that takes part in VLAN load balancing by blocking a subset of VLANs after preemption. 'none' - no method is specified to identify the alternate port. In this case, the primary edge blocks all VLANs after preemption. 'offset' - identification is done by a number which indicates the offset of the port from an edge port. 'crepBlockPortNumInfo' defines the value. 'portId' - identification is done by the port identifier of the port. 'crepBlockPortIdInfo' defines the value. 'prefFlag' - to select the port in the segment that is configured as the preferred alternate port for VLAN load balancing. While setting the value to 'offset' or 'portId', corresponding values for the value defining objects (mentioned along with the corresponding descriptions above) should also be provided, along with. Additionally, at least one of objects that define the VLANs to be blocked (crepifBlockedVlans1k, crepifBlockedVlans2k, crepifBlockedVlans3k, crepifBlockedVlans4k) should be provided with a non-empty value, when setting the value to anything other than 'none'. This value is only effective on the device acting as the REP primary edge.")
crepBlockPortNumInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-256, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepBlockPortNumInfo.setStatus('current')
if mibBuilder.loadTexts: crepBlockPortNumInfo.setDescription("This object specifies the offset of the port in the segment to be blocked for VLAN load balancing. Positive numbers indicate the offset from the primary edge port and negative numbers indicates the downstream neighbor from the secondary edge port. [Sw E1]E1---NE1[Sw 1]NE2---NE1[Sw 2]NE2......... . . [Sw E2]E2---NE2[Sw N]NE1---NE2[Sw N-1]NE1....... Sw : Switch. E : Edge port. NE : Non-Edge port. E1/E2: Edge switches. E1 and E2 can either be same or different switches. In the segment depicted above, consider port E1 on 'Sw E1' is the primary edge and E2 on 'Sw E2' is the secondary edge. Value 1 for this object indicates primary edge port, 2 indicates NE1 on 'Sw 1', 3 indicates NE2 on 'Sw 1' and so on. Value -1 indicates secondary edge port, -2 indicates NE2 on 'Sw N', -3 indicates NE1 on 'Sw N' and so on. Usage of value 0 is invalid. This value is only effective on the device acting as the REP primary edge and has relevance only if crepLoadBalanceBlockPortType = 'offset'.")
crepBlockPortIdInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepBlockPortIdInfo.setStatus('current')
if mibBuilder.loadTexts: crepBlockPortIdInfo.setDescription("This object specifies the port identifier of the port in the segment to be blocked for VLAN load balancing. 'crepIfPortID' object of the corresponding port provides the port identifier. This value is only effective on the device acting as the REP primary edge and has relevance only if crepLoadBalanceBlockPortType = 'portId'.")
crepIfPreemptDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 300)).clone(-1)).setUnits('delay in seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepIfPreemptDelayTimer.setStatus('current')
if mibBuilder.loadTexts: crepIfPreemptDelayTimer.setDescription('This object specifies the interval of time that REP waits before triggering preemption after the segment is complete. The value -1 is used to indicate that no time delay is configured and the preemption will happen manually. This value is only effective on the device acting as the REP primary edge.')
crepIfStcnPropagateToSTP = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepIfStcnPropagateToSTP.setStatus('current')
if mibBuilder.loadTexts: crepIfStcnPropagateToSTP.setDescription('This object specifies if the REP edge propagates the segment topology change notifications to the spanning tree network. This value is only effective on the device acting as the REP primary edge.')
crepIfStcnPropagateToOtherSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 18), RepSegmentList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepIfStcnPropagateToOtherSegs.setStatus('current')
if mibBuilder.loadTexts: crepIfStcnPropagateToOtherSegs.setDescription('This object specifies the list of segments to which the REP edge propagates the segment topology change notifications. This value is only effective on the device acting as the REP primary edge.')
crepIfStcnPropagateToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 19), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepIfStcnPropagateToIf.setStatus('current')
if mibBuilder.loadTexts: crepIfStcnPropagateToIf.setDescription("This object specifies the interface to which the REP edge should propagate the segment topology change notifications. The interface should be of type ifType = 'ethernetCsmacd' or an ethernet based virtual port with ifType = 'propVirtual'. '0' specifies that the device should not propagate STCNs to any interface. This value is only effective on the device acting as the REP primary edge.")
crepIfConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 1, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crepIfConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: crepIfConfigRowStatus.setDescription("This object is used to manage the creation, deletion, and modification of rows in this table. A row may be created using the 'CreateAndGo' option. When the row is successfully created, the agent would set the RowStatus to 'active'. 'crepIfSegmentId' should be specified for the successful creation of the row. A row may be deleted by setting this object to 'destroy'. All writeable columns in this row can be modified when the value of this object is 'active'.")
crepInterfaceStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2), )
if mibBuilder.loadTexts: crepInterfaceStatsTable.setStatus('current')
if mibBuilder.loadTexts: crepInterfaceStatsTable.setDescription('A table for REP interfaces statistics. This table augments the crepInterfaceConfigTable.')
crepInterfaceStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1), )
crepInterfaceConfigEntry.registerAugmentions(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepInterfaceStatsEntry"))
crepInterfaceStatsEntry.setIndexNames(*crepInterfaceConfigEntry.getIndexNames())
if mibBuilder.loadTexts: crepInterfaceStatsEntry.setStatus('current')
if mibBuilder.loadTexts: crepInterfaceStatsEntry.setDescription("The counter entries are not persistent. This is because once REP is un-configured on the interface the row would be deleted and hence they will restart if REP is configured once again on the interface. NMS need to check for 'crepCounterDiscontinuityTime' to see if the counters have restarted.")
crepCounterDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepCounterDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: crepCounterDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which REP counters suffered a discontinuity on this interface. If no such discontinuities have occurred since the first initialization of REP, then this object contains the sysUpTime value of first initialization.')
crepLslRxPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepLslRxPdus.setStatus('current')
if mibBuilder.loadTexts: crepLslRxPdus.setDescription('This object indicates the number of link status layer PDUs received on the port.')
crepLslTxPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepLslTxPdus.setStatus('current')
if mibBuilder.loadTexts: crepLslTxPdus.setDescription('This object indicates the number of link status layer PDUs transmitted on the port.')
crepHflRxPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepHflRxPdus.setStatus('current')
if mibBuilder.loadTexts: crepHflRxPdus.setDescription('This object indicates the number of hardware flood layer PDUs received on the port.')
crepHflTxPdus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepHflTxPdus.setStatus('current')
if mibBuilder.loadTexts: crepHflTxPdus.setDescription('This object indicates the number of hardware flood layer PDUs transmitted on the port.')
crepBpaTlvRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepBpaTlvRxPackets.setStatus('current')
if mibBuilder.loadTexts: crepBpaTlvRxPackets.setDescription('This object indicates the number of blocked port advertisement TLVs received on the port.')
crepBpaTlvTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepBpaTlvTxPackets.setStatus('current')
if mibBuilder.loadTexts: crepBpaTlvTxPackets.setDescription('This object indicates the number of blocked port advertisement TLVs transmitted on the port.')
crepBpaStcnLslRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepBpaStcnLslRxPackets.setStatus('current')
if mibBuilder.loadTexts: crepBpaStcnLslRxPackets.setDescription('This object indicates the number of segment topology change notifications received as blocked port advertisement through link status layer.')
crepBpaStcnLslTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepBpaStcnLslTxPackets.setStatus('current')
if mibBuilder.loadTexts: crepBpaStcnLslTxPackets.setDescription('This object indicates the number of segment topology change notifications transmitted as blocked port advertisement through link status layer.')
crepBpaStcnHflRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepBpaStcnHflRxPackets.setStatus('current')
if mibBuilder.loadTexts: crepBpaStcnHflRxPackets.setDescription('This object indicates the number of segment topology change notifications received as blocked port advertisement through hardware flood layer.')
crepBpaStcnHflTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepBpaStcnHflTxPackets.setStatus('current')
if mibBuilder.loadTexts: crepBpaStcnHflTxPackets.setDescription('This object indicates the number of segment topology change notifications transmitted as blocked port advertisement through hardware flood layer.')
crepEpaElectionTlvRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepEpaElectionTlvRxPackets.setStatus('current')
if mibBuilder.loadTexts: crepEpaElectionTlvRxPackets.setDescription('This object indicates the number of end port advertisement election TLVs received that are used for determining the role, namely primary edge or secondary edge.')
crepEpaElectionTlvTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepEpaElectionTlvTxPackets.setStatus('current')
if mibBuilder.loadTexts: crepEpaElectionTlvTxPackets.setDescription('This object indicates the number of end port advertisement election TLVs transmitted that are used for determining the role, namely primary edge or secondary edge.')
crepEpaCommandTlvRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepEpaCommandTlvRxPackets.setStatus('current')
if mibBuilder.loadTexts: crepEpaCommandTlvRxPackets.setDescription('This object indicates the number of end port advertisement command TLVs received that are used to authorize a port to takeover the segment for the purpose of VLAN load balancing.')
crepEpaCommandTlvTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepEpaCommandTlvTxPackets.setStatus('current')
if mibBuilder.loadTexts: crepEpaCommandTlvTxPackets.setDescription('This object indicates the number of end port advertisement command TLVs transmitted that are used to authorize a port to takeover the segment for the purpose of VLAN load balancing.')
crepEpaInfoTlvRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepEpaInfoTlvRxPackets.setStatus('current')
if mibBuilder.loadTexts: crepEpaInfoTlvRxPackets.setDescription('This object indicates the number of end port advertisement information TLVs received on the port. These messages are sent by the end ports (configured edge port, or port which is down or port which does not have internal peer) to discover the segment information.')
crepEpaInfoTlvTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepEpaInfoTlvTxPackets.setStatus('current')
if mibBuilder.loadTexts: crepEpaInfoTlvTxPackets.setDescription('This object indicates the number of end port advertisement information TLVs transmitted on the port. These messages are sent by the end ports (configured edge port, or port which is down or port which does not have internal peer) to discover the segment information.')
crepVersion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepVersion.setStatus('current')
if mibBuilder.loadTexts: crepVersion.setDescription('This object indicates the version of REP being used.')
crepAdminVlan = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 1, 2), VlanId().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crepAdminVlan.setStatus('current')
if mibBuilder.loadTexts: crepAdminVlan.setDescription('The administrative VLAN used by REP to transmit its hardware flooding layer messages. If the VLAN does not already exist, set operation does not create the VLAN. The administrative VLAN cannot be the RSPAN VLAN.')
crepNotifsEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crepNotifsEnable.setStatus('current')
if mibBuilder.loadTexts: crepNotifsEnable.setDescription('This object specifies whether the system will generate REP notifications. This object affects the generation of all REP notifications defined in this MIB module.')
crepGlobalRepNotifsRate = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setUnits('notifications per second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: crepGlobalRepNotifsRate.setStatus('current')
if mibBuilder.loadTexts: crepGlobalRepNotifsRate.setDescription('This object specifies the maximum rate at which the system will generate notifications defined by this MIB module. If this object value is 0, then the system will not impose a limit on the rate at which it will generate notification defined by this MIB module.')
crepMinSegmentId = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 1, 5), RepSegmentId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepMinSegmentId.setStatus('current')
if mibBuilder.loadTexts: crepMinSegmentId.setDescription('This object indicates the minimum segment identifier that can be configured on the device.')
crepMaxSegmentId = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 601, 1, 1, 6), RepSegmentId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crepMaxSegmentId.setStatus('current')
if mibBuilder.loadTexts: crepMaxSegmentId.setDescription('This object indicates the maximum segment identifier that can be configured on the device.')
crepLinkStatus = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 601, 0, 1)).setObjects(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfSegmentId"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfOperStatus"))
if mibBuilder.loadTexts: crepLinkStatus.setStatus('current')
if mibBuilder.loadTexts: crepLinkStatus.setDescription("This notification is sent when a REP interface has entered or left REP link operational status. The link is considered operational when 'crepIfOperStatus' is 'twoWay'. 'crepIfOperStatus' would be 'none' if the crepInterfaceConfigEntry entry has been removed.")
crepPreemptionStatus = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 601, 0, 2)).setObjects(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepSegmentPreemptStatus"))
if mibBuilder.loadTexts: crepPreemptionStatus.setStatus('current')
if mibBuilder.loadTexts: crepPreemptionStatus.setDescription('This notification indicates the status of the preemption triggered on REP primary edge.')
crepPortRoleChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 601, 0, 3)).setObjects(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfSegmentId"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfPortRole"))
if mibBuilder.loadTexts: crepPortRoleChange.setStatus('current')
if mibBuilder.loadTexts: crepPortRoleChange.setDescription("This notification is sent when the role of a Port changes that are indicated by 'crepIfPortRole'.")
ciscoRepMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 601, 2, 1))
ciscoRepMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 601, 2, 2))
ciscoRepMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 601, 2, 1, 1)).setObjects(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "ciscoRepGlobalGroup"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "ciscoRepNotificationGroup"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "ciscoRepInterfaceGroup"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "ciscoRepSegmentGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRepMIBCompliance = ciscoRepMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoRepMIBCompliance.setDescription('The compliance statement for CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB.')
ciscoRepGlobalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 601, 2, 2, 1)).setObjects(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepVersion"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepAdminVlan"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepNotifsEnable"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepGlobalRepNotifsRate"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepMinSegmentId"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepMaxSegmentId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRepGlobalGroup = ciscoRepGlobalGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRepGlobalGroup.setDescription('A collection of global objects for use with the REP feature.')
ciscoRepInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 601, 2, 2, 2)).setObjects(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfSegmentId"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfOperStatus"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfPortRole"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfPortID"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfAdminEdgePortType"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfOperEdgePortType"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfPreferredConfig"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepifBlockedVlans1k"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepifBlockedVlans2k"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepifBlockedVlans3k"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepifBlockedVlans4k"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepLoadBalanceBlockPortType"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepBlockPortNumInfo"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepBlockPortIdInfo"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfPreemptDelayTimer"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfStcnPropagateToSTP"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfStcnPropagateToOtherSegs"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfStcnPropagateToIf"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepIfConfigRowStatus"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepCounterDiscontinuityTime"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepLslRxPdus"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepLslTxPdus"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepHflRxPdus"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepHflTxPdus"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepBpaTlvRxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepBpaTlvTxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepBpaStcnLslRxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepBpaStcnLslTxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepBpaStcnHflRxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepBpaStcnHflTxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepEpaElectionTlvRxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepEpaElectionTlvTxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepEpaCommandTlvRxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepEpaCommandTlvTxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepEpaInfoTlvRxPackets"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepEpaInfoTlvTxPackets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRepInterfaceGroup = ciscoRepInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRepInterfaceGroup.setDescription('A collection of interface specific objects for use with the REP feature.')
ciscoRepNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 601, 2, 2, 3)).setObjects(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepLinkStatus"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepPreemptionStatus"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepPortRoleChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRepNotificationGroup = ciscoRepNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRepNotificationGroup.setDescription('A collection of notifications for use with the REP feature.')
ciscoRepSegmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 601, 2, 2, 4)).setObjects(("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepSegmentInterface1"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepSegmentInterface2"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepSegmentComplete"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepSegmentPreempt"), ("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", "crepSegmentPreemptStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoRepSegmentGroup = ciscoRepSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoRepSegmentGroup.setDescription('A collection of segment specific objects for use with the REP feature.')
mibBuilder.exportSymbols("CISCO-RESILIENT-ETHERNET-PROTOCOL-MIB", crepifBlockedVlans2k=crepifBlockedVlans2k, RepSegmentId=RepSegmentId, crepBpaStcnLslRxPackets=crepBpaStcnLslRxPackets, crepAdminVlan=crepAdminVlan, crepIfPortRole=crepIfPortRole, PYSNMP_MODULE_ID=ciscoResilientEthernetProtocolMIB, crepInterfaceStatsTable=crepInterfaceStatsTable, crepBlockPortNumInfo=crepBlockPortNumInfo, ciscoRepMIBConform=ciscoRepMIBConform, crepEpaElectionTlvTxPackets=crepEpaElectionTlvTxPackets, crepPortRoleChange=crepPortRoleChange, crepSegmentInterface2=crepSegmentInterface2, ciscoRepInterfaceGroup=ciscoRepInterfaceGroup, crepSegmentId=crepSegmentId, crepIfStcnPropagateToSTP=crepIfStcnPropagateToSTP, crepBpaTlvRxPackets=crepBpaTlvRxPackets, ciscoRepMIBGroups=ciscoRepMIBGroups, crepLslTxPdus=crepLslTxPdus, crepHflTxPdus=crepHflTxPdus, crepEpaCommandTlvRxPackets=crepEpaCommandTlvRxPackets, crepIfConfigRowStatus=crepIfConfigRowStatus, crepSegmentConfig=crepSegmentConfig, crepPreemptionStatus=crepPreemptionStatus, crepIfAdminEdgePortType=crepIfAdminEdgePortType, crepifBlockedVlans1k=crepifBlockedVlans1k, crepGlobalInfo=crepGlobalInfo, ciscoRepMIBObjects=ciscoRepMIBObjects, crepEpaInfoTlvTxPackets=crepEpaInfoTlvTxPackets, crepSegmentEntry=crepSegmentEntry, crepHflRxPdus=crepHflRxPdus, crepInterfaceStatsEntry=crepInterfaceStatsEntry, crepIfSegmentId=crepIfSegmentId, ciscoRepGlobalGroup=ciscoRepGlobalGroup, crepGlobalRepNotifsRate=crepGlobalRepNotifsRate, crepEpaInfoTlvRxPackets=crepEpaInfoTlvRxPackets, crepBpaStcnHflRxPackets=crepBpaStcnHflRxPackets, ciscoRepMIBNotifs=ciscoRepMIBNotifs, crepLoadBalanceBlockPortType=crepLoadBalanceBlockPortType, crepInterfaceConfigTable=crepInterfaceConfigTable, crepIfStcnPropagateToIf=crepIfStcnPropagateToIf, crepIfPreferredConfig=crepIfPreferredConfig, ciscoRepNotificationGroup=ciscoRepNotificationGroup, ciscoRepSegmentGroup=ciscoRepSegmentGroup, crepSegmentPreemptStatus=crepSegmentPreemptStatus, crepVersion=crepVersion, crepCounterDiscontinuityTime=crepCounterDiscontinuityTime, RepPortType=RepPortType, crepSegmentInterface1=crepSegmentInterface1, crepIfIndex=crepIfIndex, crepSegmentComplete=crepSegmentComplete, crepSegmentPreempt=crepSegmentPreempt, crepBpaStcnLslTxPackets=crepBpaStcnLslTxPackets, crepIfOperEdgePortType=crepIfOperEdgePortType, ciscoResilientEthernetProtocolMIB=ciscoResilientEthernetProtocolMIB, crepifBlockedVlans4k=crepifBlockedVlans4k, crepEpaElectionTlvRxPackets=crepEpaElectionTlvRxPackets, crepNotifsEnable=crepNotifsEnable, crepMaxSegmentId=crepMaxSegmentId, crepMinSegmentId=crepMinSegmentId, crepInterfaceConfigEntry=crepInterfaceConfigEntry, crepBpaTlvTxPackets=crepBpaTlvTxPackets, crepLinkStatus=crepLinkStatus, ciscoRepMIBCompliances=ciscoRepMIBCompliances, ciscoRepMIBCompliance=ciscoRepMIBCompliance, RepSegmentList=RepSegmentList, crepSegmentTable=crepSegmentTable, crepLslRxPdus=crepLslRxPdus, crepIfPortID=crepIfPortID, crepifBlockedVlans3k=crepifBlockedVlans3k, crepBpaStcnHflTxPackets=crepBpaStcnHflTxPackets, crepIfPreemptDelayTimer=crepIfPreemptDelayTimer, crepBlockPortIdInfo=crepBlockPortIdInfo, crepEpaCommandTlvTxPackets=crepEpaCommandTlvTxPackets, crepIfStcnPropagateToOtherSegs=crepIfStcnPropagateToOtherSegs, crepIfOperStatus=crepIfOperStatus, crepInterfaceConfig=crepInterfaceConfig)

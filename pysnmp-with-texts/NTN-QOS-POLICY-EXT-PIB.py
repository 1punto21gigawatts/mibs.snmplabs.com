#
# PySNMP MIB module NTN-QOS-POLICY-EXT-PIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NTN-QOS-POLICY-EXT-PIB
# Produced by pysmi-0.3.4 at Wed May  1 14:25:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
PolicyInstanceId, RoleCombination = mibBuilder.importSymbols("POLICY-FRAMEWORK-PIB", "PolicyInstanceId", "RoleCombination")
qos802DscpMappingEntry, QosIeee802Cos, qos802AceEntry = mibBuilder.importSymbols("QOS-POLICY-802-PIB", "qos802DscpMappingEntry", "QosIeee802Cos", "qos802AceEntry")
qosInterfaceTypeEntry, QosInterfaceQueueCount, qosActionEntry = mibBuilder.importSymbols("QOS-POLICY-IP-PIB", "qosInterfaceTypeEntry", "QosInterfaceQueueCount", "qosActionEntry")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Unsigned32, IpAddress, Gauge32, iso, NotificationType, MibIdentifier, Bits, ModuleIdentity, Counter64, ObjectIdentity, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Unsigned32", "IpAddress", "Gauge32", "iso", "NotificationType", "MibIdentifier", "Bits", "ModuleIdentity", "Counter64", "ObjectIdentity", "Integer32")
RowStatus, StorageType, TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TruthValue", "DisplayString", "TextualConvention")
policy, = mibBuilder.importSymbols("SYNOPTICS-ROOT-MIB", "policy")
ntnQosPolicyExtPib = ModuleIdentity((1, 3, 6, 1, 4, 1, 45, 4, 4))
ntnQosPolicyExtPib.setRevisions(('2004-07-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ntnQosPolicyExtPib.setRevisionsDescriptions(('Version 3: Added version info',))
if mibBuilder.loadTexts: ntnQosPolicyExtPib.setLastUpdated('200407200000Z')
if mibBuilder.loadTexts: ntnQosPolicyExtPib.setOrganization('Nortel Networks, Inc.')
if mibBuilder.loadTexts: ntnQosPolicyExtPib.setContactInfo(' John Seligson Nortel Networks, Inc. 4401 Great America Parkway Santa Clara, CA 95054 USA Phone: +1 408 495 2992 Email: jseligso@nortelnetworks.com')
if mibBuilder.loadTexts: ntnQosPolicyExtPib.setDescription("The Nortel Network's PIB module containing extensions to the base PIB modules (Framework, IP QoS, 802 QoS) produced by the IETF.")
ntnQosPolicyExtPibClasses = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 4, 1))
class DropPrecedence(TextualConvention, Integer32):
    description = 'An integer that indicates the drop precedence value. Traffic associated with a lower drop precedence is generally given priority over traffic with a higher drop precedence during resource allocation.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 8)

ntnQosIfParametersExt = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1))
ntnQosIfPriAssignmentTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 1), )
if mibBuilder.loadTexts: ntnQosIfPriAssignmentTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentTable.setDescription('Supports the assignment of 802.1D user priority values to a queue for each interface with a specific role combination. There will be 8 instances of this class for each supported role combination.')
ntnQosIfPriAssignmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 1, 1), ).setIndexNames((0, "NTN-QOS-POLICY-EXT-PIB", "ntnQosIfPriAssignmentId"))
if mibBuilder.loadTexts: ntnQosIfPriAssignmentEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentEntry.setDescription('An instance of the ntnQosIfPriAssignment class.')
ntnQosIfPriAssignmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 1, 1, 1), PolicyInstanceId())
if mibBuilder.loadTexts: ntnQosIfPriAssignmentId.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentId.setDescription('An index that is used to uniquely identify the instance of the ntnQosIfPriAssignment class.')
ntnQosIfPriAssignmentRoles = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 1, 1, 2), RoleCombination()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfPriAssignmentRoles.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentRoles.setDescription("The role combination with which an interface must be configured to support the Pri-to-queue assignment described by this instance. The specified role combination must be defined in the qosInterfaceType table prior to being referenced by this entry. Otherwise a 'priAssociationUnknown(3)' error code will be returned.")
ntnQosIfPriAssignmentPri = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 1, 1, 3), QosIeee802Cos()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfPriAssignmentPri.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentPri.setDescription('The 802.1D user priority to which this class instance applies.')
ntnQosIfPriAssignmentQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 1, 1, 4), QosInterfaceQueueCount()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfPriAssignmentQueue.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentQueue.setDescription("The specific queue, within the queue set that is associated with the interface set identified by the ntnQosIfPriAssignmentRoles tag, on which traffic with the specified user priority, dictated by the ntnQosIfPriAssignmentPri value, is placed. Failure to specify an appropriate queue results in a 'priAssociationConflict(4)' error indication being returned.")
ntnQosIfPriAssignmentStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 1, 1, 5), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfPriAssignmentStorageType.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentStorageType.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosIfPriAssignmentStatus object is equal to active(1).')
ntnQosIfPriAssignmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfPriAssignmentStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosInterfaceTypeExtTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 2), )
if mibBuilder.loadTexts: ntnQosInterfaceTypeExtTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeExtTable.setDescription('Supports augmenting the information regarding the interface roles and queue set assignments.')
ntnQosInterfaceTypeExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 2, 1), )
qosInterfaceTypeEntry.registerAugmentions(("NTN-QOS-POLICY-EXT-PIB", "ntnQosInterfaceTypeExtEntry"))
ntnQosInterfaceTypeExtEntry.setIndexNames(*qosInterfaceTypeEntry.getIndexNames())
if mibBuilder.loadTexts: ntnQosInterfaceTypeExtEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeExtEntry.setDescription('An instance of the ntnQosInterfaceTypeExt class.')
ntnQosInterfaceTypeExtIfClass = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("core", 1), ("access", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceTypeExtIfClass.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeExtIfClass.setDescription('A value describing the overall classification of traffic received on interfaces with the given role combination. Traffic received on core (i.e., trusted) interfaces may be processed differently and be subject to different restrictions that traffic received on access (i.e., non-trusted) interfaces. The treatment of traffic based on interface class is implementation dependent.')
ntnQosIfDscpMappingExtTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 3), )
if mibBuilder.loadTexts: ntnQosIfDscpMappingExtTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfDscpMappingExtTable.setDescription('Supports augmenting the information regarding the mapping of DSCP values to 802.1p user priority and drop precedence values.')
ntnQosIfDscpMappingExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 3, 1), )
qos802DscpMappingEntry.registerAugmentions(("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfDscpMappingExtEntry"))
ntnQosIfDscpMappingExtEntry.setIndexNames(*qos802DscpMappingEntry.getIndexNames())
if mibBuilder.loadTexts: ntnQosIfDscpMappingExtEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfDscpMappingExtEntry.setDescription('An instance of the ntnQosIfDscpMappingExt class.')
ntnQosIfDscpMappingExtDropPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 3, 1, 1), DropPrecedence()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosIfDscpMappingExtDropPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfDscpMappingExtDropPrec.setDescription('The drop precedence value to use for traffic with the associated DSCP value.')
ntnQosActionExt = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2))
ntnQosActionExtTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2, 1), )
if mibBuilder.loadTexts: ntnQosActionExtTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtTable.setDescription('Contains the current set of configured general action extensions. The actions are associated with all types ACLs during operation.')
ntnQosActionExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2, 1, 1), )
qosActionEntry.registerAugmentions(("NTN-QOS-POLICY-EXT-PIB", "ntnQosActionExtEntry"))
ntnQosActionExtEntry.setIndexNames(*qosActionEntry.getIndexNames())
if mibBuilder.loadTexts: ntnQosActionExtEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtEntry.setDescription('General action extensions. Each entry specifies an instance of the ntnQosActionExt class which describes (potentially) several distinct action attributes. Each action is taken individually regarding the data in question. Several actions can be taken for a single frame. An instance of this class can not be deleted while the correspond qosActionTable instance exists.')
ntnQosActionExtAssignFlowId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 65535), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosActionExtAssignFlowId.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtAssignFlowId.setDescription('This action attribute, when specified, will cause the packet being evaluated to be associated with the specified flow identifier. Flow identifiers may be used to facilitate traffic shaping and other implementation specific operations at the egress interface. Setting this attribute to -1 indicates that flow identification is not in use at the present time.')
ntnQosActionExtCopyToCpu = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2, 1, 1, 2), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosActionExtCopyToCpu.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtCopyToCpu.setDescription("This action attribute, when specified, will cause the packet being evaluated to be sent to the CPU for further processing. Extreme care should be taken when setting this object to 'true(1)' since this action may adversely affect resource availability in the system impacting overall system operation. A value of 'false(2)' indicates that this action will not be initiated.")
ntnQosActionExtMirrorFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2, 1, 1, 3), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosActionExtMirrorFrame.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtMirrorFrame.setDescription("This action attribute, when specified, will cause the packet being evaluated to be sent to a predefined egress port for transmission in addition to the normal processing associated with the packet. Specification of the egress port or ports that will serve as the destination for mirrored data is beyond the scope of this document. Furthermore, note that data mirroring can potentially consume substantial resources at the egress. Oversubscription issues should be considered prior to specifying this action. Also note that the mirroring direction attribute in this same ntnQosActionExt entry determines the data that is mirrored. The packet that was 'received' by the device will be mirrored (i.e., packet modifications that may occur during processing will not appear in the mirrored data) when the mirroring direction attribute has the value 'ingress(1)'. The packet that is to be 'transmitted' by the device will be mirrored (i.e., packet modifications that may occur during processing will appear in the mirrored data) when the mirroring direction attribute has the value 'egress(2)'. A value of 'false(2)' indicates that this action will not be initiated.")
ntnQosActionExtSetDropPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("dropPrec1", 1), ("dropPrec2", 2), ("dropPrec3", 3), ("dropPrec4", 4), ("dropPrec5", 5), ("dropPrec6", 6), ("dropPrec7", 7), ("dropPrec8", 8), ("useDefault", 9), ("ignore", 10), ("useEgressMap", 11)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosActionExtSetDropPrec.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtSetDropPrec.setDescription("This action attribute, when specified, will cause the packet being evaluated to be associated with the specified relative drop precedence. The relative drop precedence may be used to determine traffic precedence relative to other traffic being processed by the device and other implementation specific operations at the egress interface. A low value for drop precedence equates to the traffic receiving a higher priority in terms of processing. In other words, traffic with a drop precedence of 1 is treated with the highest processing priority while traffic with a drop precedence of 8 receives the lowest processing priority. Specifying a value equal to useDefault(9) means that the value for this attribute will be assigned based on default information maintained in the system. The value specified in the 'UpdateDSCP' attribute will be used to determine the default drop precedence. Note that specifying useDefault(9) means that assignment of a value for this attribute is implementation dependent. Specifying a value equal to ignore(10) means that no action will be taken related to this attribute. Note that the results of classification where actions specifying ignore(10) are applied are implementation dependent. Specifying a value equal to useEgressMap(11) means that the value for this attribute will be assigned based on DSCP-to-drop precedence egress map information maintained in the system. The DSCP value in received traffic will be used to determine the drop precedence. Note that specifying useEgressMap(11) means that assignment of a value for this attribute is implementation dependent.")
ntnQosActionExtUpdatePri = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("markAsPriority0", 1), ("markAsPriority1", 2), ("markAsPriority2", 3), ("markAsPriority3", 4), ("markAsPriority4", 5), ("markAsPriority5", 6), ("markAsPriority6", 7), ("markAsPriority7", 8), ("useDefault", 9), ("ignore", 10), ("useEgressMap", 11)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosActionExtUpdatePri.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtUpdatePri.setDescription("This action attribute, when specified, will cause the value contained in the user priority field of the 802.1Q frame to be updated based on the value of this object. No action is taken if the frame is untagged. Specifying a value equal to useDefault(9) means that the value for this attribute will be assigned based on default information maintained in the system. The value specified in the 'UpdateDSCP' attribute will be used to determine the default drop precedence. Note that specifying useDefault(9) means that assignment of a value for this attribute is implementation dependent. Specifying a value equal to ignore(10) means that no action will be taken related to this attribute. Note that the results of classification where actions specifying ignore(10) are applied are implementation dependent. Specifying a value equal to useEgressMap(11) means that the value for this attribute will be assigned based on DSCP-to-drop precedence egress map information maintained in the system. The DSCP value in received traffic will be used to determine the drop precedence. Note that specifying useEgressMap(11) means that assignment of a value for this attribute is implementation dependent.")
ntnQosActionExtMirrorDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2))).clone('ingress')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosActionExtMirrorDirection.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtMirrorDirection.setDescription("This action attribute, when specified, will determine where a snapshot of a packet being mirrored will be taken for mirroring purposes. The packet that was 'received' by the device will be mirrored (i.e., packet modifications that may occur during processing will not appear in the mirrored data) when the direction attribute has the value 'ingress(1)'. The packet that is to be 'transmitted' by the device will be mirrored (i.e., packet modifications that may occur during processing will appear in the mirrored data) when the direction attribute has the value 'egress(2)'. Note that the value of this attribute is only considered if the ntnQosActionExtMirrorFrame attribute is 'true'.")
ntnQos802FilterExt = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3))
ntnQos802FilterExtTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1), )
if mibBuilder.loadTexts: ntnQos802FilterExtTable.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterExtTable.setDescription('Contains the current set of configured 802 filter extensions.')
ntnQos802FilterExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1, 1), )
qos802AceEntry.registerAugmentions(("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterExtEntry"))
ntnQos802FilterExtEntry.setIndexNames(*qos802AceEntry.getIndexNames())
if mibBuilder.loadTexts: ntnQos802FilterExtEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterExtEntry.setDescription('Global (802) filter extensions. Each entry specifies an instance of the ntnQos802FilterExt class which describes (potentially) several distinct filter attributes. An instance of this class can not be deleted while the correspond qos802AceTable instance exists.')
ntnQos802FilterDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 63), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQos802FilterDscp.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterDscp.setDescription('The value that the DSCP in the packet can have and match this filter. A value of -1 indicates that a specific DSCP value has not been defined and thus all DSCP values are considered a match.')
ntnQos802FilterProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQos802FilterProtocol.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterProtocol.setDescription("The IP protocol to match against the packet's protocol. Valid only when applied against IP traffic. A value of zero means match all.")
ntnQos802FilterDstL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQos802FilterDstL4PortMin.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterDstL4PortMin.setDescription("The minimum value that the packet's layer 4 destination port number can have and match this filter. Valid only when applied against IP traffic flows. The value of this attribute must be less-than-or-equal-to the value of the corresponding ntnQos802FilterDstL4PortMax attribute.")
ntnQos802FilterDstL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQos802FilterDstL4PortMax.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterDstL4PortMax.setDescription("The maximum value that the packet's layer 4 destination port number can have and match this filter. Valid only when applied against IP traffic flows. The value of this attribute must be greater-than-or-equal-to the value of the corresponding ntnQos802FilterDstL4PortMin attribute.")
ntnQos802FilterSrcL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQos802FilterSrcL4PortMin.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterSrcL4PortMin.setDescription("The minimum value that the packet's layer 4 source port number can have and match this filter. Valid only when applied against IP traffic flows. The value of this attribute must be less-than-or-equal-to the value of the corresponding ntnQos802FilterSrcL4PortMax attribute.")
ntnQos802FilterSrcL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQos802FilterSrcL4PortMax.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterSrcL4PortMax.setDescription("The maximum value that the packet's layer 4 source port number can have and match this filter. Valid only when applied against IP traffic flows. The value of this attribute must be greater-than-or-equal-to the value of the corresponding ntnQos802FilterSrcL4PortMin attribute.")
ntnQos802FilterVlanIdSet = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 3, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQos802FilterVlanIdSet.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterVlanIdSet.setDescription("This attribute is used to specify a set of VLAN IDs against which the traffic being classified is compared. Packets that contain a VLAN ID equal to one of the VLAN IDs in this set match this component of an 802 filter. The format of this octet string is a series of two-byte (16 bit) values with each octet tuple identifying a single VLAN ID in the set. Therefore, the length of the octet string value of this object is always either zero or an even number of octets (e.g., 2, 4, 6, 20). As with most sets, ordering within the set (octet string) is unimportant. For example, a set specifying three VLAN IDs (8, 35 and 4012) might be specified as follows: Octets: 1 | 2 | 3 | 4 | 5 | 6 ------------------------------------------------ Values: 0x00 | 0x23 | 0x00 | 0x08 | 0x0F | 0xAC ------------------------------------------------ VLAN ID: 35 | 8 | 4012 The supported maximum length of this attribute depends on the maximum number of VLANs that may be included in a set for filtering purposes. This length is thus implementation dependent. Note that this attribute and the qos802AceVlanId attribute are mutually exclusive. The value of the qos802AceVlanId component of the augmented filter entry must be set to 'ignore' (i.e., -1) if the length of this set is non-zero. Otherwise entry creation will fail.")
ntnQosPolicyExtPibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 4, 2))
ntnQosPolicyExtPibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 4, 2, 1))
ntnQosPolicyExtPibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 4, 2, 2))
ntnQosPolicyExtPibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 45, 4, 4, 2, 1, 1)).setObjects(("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfPriAssignmentGroup"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosInterfaceTypeExtGroup"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfDscpMappingExtGroup"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosActionExtGroup"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterExtGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosPolicyExtPibCompliance = ntnQosPolicyExtPibCompliance.setStatus('current')
if mibBuilder.loadTexts: ntnQosPolicyExtPibCompliance.setDescription('Describes the requirements for conformance to the Nortel Networks QoS Policy Extension PIB.')
ntnQosIfPriAssignmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 4, 2, 2, 1)).setObjects(("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfPriAssignmentRoles"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfPriAssignmentPri"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfPriAssignmentQueue"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfPriAssignmentStorageType"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfPriAssignmentStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosIfPriAssignmentGroup = ntnQosIfPriAssignmentGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfPriAssignmentGroup.setDescription('Objects from the ntnQosIfPriAssignmentTable.')
ntnQosInterfaceTypeExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 4, 2, 2, 2)).setObjects(("NTN-QOS-POLICY-EXT-PIB", "ntnQosInterfaceTypeExtIfClass"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosInterfaceTypeExtGroup = ntnQosInterfaceTypeExtGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceTypeExtGroup.setDescription('Objects from the ntnQosInterfaceTypeExtTable.')
ntnQosIfDscpMappingExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 4, 2, 2, 3)).setObjects(("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfDscpMappingExtDropPrec"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosIfDscpMappingExtGroup = ntnQosIfDscpMappingExtGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosIfDscpMappingExtGroup.setDescription('Objects from the ntnQosIfDscpMappingExtTable.')
ntnQosActionExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 4, 2, 2, 4)).setObjects(("NTN-QOS-POLICY-EXT-PIB", "ntnQosActionExtAssignFlowId"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosActionExtCopyToCpu"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosActionExtMirrorFrame"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosActionExtSetDropPrec"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosActionExtUpdatePri"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQosActionExtMirrorDirection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosActionExtGroup = ntnQosActionExtGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosActionExtGroup.setDescription('Objects from the ntnQosActionExtTable.')
ntnQos802FilterExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 4, 2, 2, 5)).setObjects(("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterDscp"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterProtocol"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterDstL4PortMin"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterDstL4PortMax"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterSrcL4PortMin"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterSrcL4PortMax"), ("NTN-QOS-POLICY-EXT-PIB", "ntnQos802FilterVlanIdSet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQos802FilterExtGroup = ntnQos802FilterExtGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQos802FilterExtGroup.setDescription('Objects from the ntnQos802FilterExtTable.')
mibBuilder.exportSymbols("NTN-QOS-POLICY-EXT-PIB", ntnQosIfPriAssignmentPri=ntnQosIfPriAssignmentPri, ntnQosIfPriAssignmentStorageType=ntnQosIfPriAssignmentStorageType, ntnQos802FilterDscp=ntnQos802FilterDscp, ntnQosPolicyExtPib=ntnQosPolicyExtPib, ntnQosActionExtMirrorDirection=ntnQosActionExtMirrorDirection, ntnQosActionExtMirrorFrame=ntnQosActionExtMirrorFrame, ntnQos802FilterDstL4PortMin=ntnQos802FilterDstL4PortMin, ntnQosInterfaceTypeExtGroup=ntnQosInterfaceTypeExtGroup, ntnQos802FilterVlanIdSet=ntnQos802FilterVlanIdSet, ntnQos802FilterSrcL4PortMin=ntnQos802FilterSrcL4PortMin, ntnQosIfPriAssignmentStatus=ntnQosIfPriAssignmentStatus, ntnQosPolicyExtPibCompliances=ntnQosPolicyExtPibCompliances, ntnQosInterfaceTypeExtTable=ntnQosInterfaceTypeExtTable, ntnQosIfPriAssignmentId=ntnQosIfPriAssignmentId, ntnQosIfPriAssignmentGroup=ntnQosIfPriAssignmentGroup, ntnQosPolicyExtPibCompliance=ntnQosPolicyExtPibCompliance, ntnQos802FilterExt=ntnQos802FilterExt, DropPrecedence=DropPrecedence, ntnQosPolicyExtPibConformance=ntnQosPolicyExtPibConformance, ntnQosIfPriAssignmentEntry=ntnQosIfPriAssignmentEntry, ntnQosIfDscpMappingExtGroup=ntnQosIfDscpMappingExtGroup, ntnQosActionExtEntry=ntnQosActionExtEntry, ntnQosIfDscpMappingExtTable=ntnQosIfDscpMappingExtTable, ntnQosPolicyExtPibClasses=ntnQosPolicyExtPibClasses, ntnQos802FilterExtTable=ntnQos802FilterExtTable, ntnQosActionExt=ntnQosActionExt, PYSNMP_MODULE_ID=ntnQosPolicyExtPib, ntnQos802FilterSrcL4PortMax=ntnQos802FilterSrcL4PortMax, ntnQosIfParametersExt=ntnQosIfParametersExt, ntnQosInterfaceTypeExtEntry=ntnQosInterfaceTypeExtEntry, ntnQosActionExtCopyToCpu=ntnQosActionExtCopyToCpu, ntnQosActionExtTable=ntnQosActionExtTable, ntnQosIfDscpMappingExtDropPrec=ntnQosIfDscpMappingExtDropPrec, ntnQosActionExtUpdatePri=ntnQosActionExtUpdatePri, ntnQosIfPriAssignmentTable=ntnQosIfPriAssignmentTable, ntnQosIfDscpMappingExtEntry=ntnQosIfDscpMappingExtEntry, ntnQosActionExtSetDropPrec=ntnQosActionExtSetDropPrec, ntnQos802FilterProtocol=ntnQos802FilterProtocol, ntnQos802FilterExtEntry=ntnQos802FilterExtEntry, ntnQos802FilterExtGroup=ntnQos802FilterExtGroup, ntnQosPolicyExtPibGroups=ntnQosPolicyExtPibGroups, ntnQosActionExtGroup=ntnQosActionExtGroup, ntnQosIfPriAssignmentQueue=ntnQosIfPriAssignmentQueue, ntnQosIfPriAssignmentRoles=ntnQosIfPriAssignmentRoles, ntnQos802FilterDstL4PortMax=ntnQos802FilterDstL4PortMax, ntnQosActionExtAssignFlowId=ntnQosActionExtAssignFlowId, ntnQosInterfaceTypeExtIfClass=ntnQosInterfaceTypeExtIfClass)

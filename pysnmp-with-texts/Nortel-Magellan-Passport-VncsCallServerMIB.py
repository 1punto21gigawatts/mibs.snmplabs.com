#
# PySNMP MIB module Nortel-Magellan-Passport-VncsCallServerMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-VncsCallServerMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:28:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
Counter32, DisplayString, RowStatus, StorageType, Unsigned32, Integer32, RowPointer = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "Counter32", "DisplayString", "RowStatus", "StorageType", "Unsigned32", "Integer32", "RowPointer")
WildcardedDigitString, Link, AsciiString, DigitString, FixedPoint1 = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "WildcardedDigitString", "Link", "AsciiString", "DigitString", "FixedPoint1")
passportMIBs, components = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs", "components")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, ObjectIdentity, TimeTicks, Unsigned32, ModuleIdentity, Integer32, Gauge32, iso, NotificationType, Bits, IpAddress, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "ObjectIdentity", "TimeTicks", "Unsigned32", "ModuleIdentity", "Integer32", "Gauge32", "iso", "NotificationType", "Bits", "IpAddress", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
vncsCallServerMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66))
vncs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44))
vncsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 1), )
if mibBuilder.loadTexts: vncsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsRowStatusTable.setDescription('This entry controls the addition and deletion of vncs components.')
vncsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"))
if mibBuilder.loadTexts: vncsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsRowStatusEntry.setDescription('A single entry in the table represents a single vncs component.')
vncsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vncsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vncs components. These components can be added and deleted.')
vncsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vncsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vncsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vncsStorageType.setDescription('This variable represents the storage type value for the vncs tables.')
vncsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: vncsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsIndex.setDescription('This variable represents the index for the vncs tables.')
vncsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 10), )
if mibBuilder.loadTexts: vncsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsProvTable.setDescription('This group represents the provisionable attributes of the VNCS server.')
vncsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"))
if mibBuilder.loadTexts: vncsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsProvEntry.setDescription('An entry in the vncsProvTable.')
vncsCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: vncsCommentText.setDescription('This attribute specifies the name of the customer that is using this VNCS server. Typical use of this attribute is to store customer name.')
vncsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 11), )
if mibBuilder.loadTexts: vncsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsStatsTable.setDescription('This group provides data for the Vncs component.')
vncsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"))
if mibBuilder.loadTexts: vncsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsStatsEntry.setDescription('An entry in the vncsStatsTable.')
vncsTotalTranslations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsTotalTranslations.setStatus('mandatory')
if mibBuilder.loadTexts: vncsTotalTranslations.setDescription('This attribute counts the total number of translation requests received by VNCS. This counter wraps to zero when it reaches its maximum value.')
vncsVRoutesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 305), )
if mibBuilder.loadTexts: vncsVRoutesTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVRoutesTable.setDescription('This attribute indicates which VoiceRoute components are using this Vncs.')
vncsVRoutesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 305, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVRoutesValue"))
if mibBuilder.loadTexts: vncsVRoutesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVRoutesEntry.setDescription('An entry in the vncsVRoutesTable.')
vncsVRoutesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 305, 1, 1), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsVRoutesValue.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVRoutesValue.setDescription('This variable represents both the value and the index for the vncsVRoutesTable.')
vncsDP = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2))
vncsDPRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 1), )
if mibBuilder.loadTexts: vncsDPRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPRowStatusTable.setDescription('This entry controls the addition and deletion of vncsDP components.')
vncsDPRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsDPIndex"))
if mibBuilder.loadTexts: vncsDPRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPRowStatusEntry.setDescription('A single entry in the table represents a single vncsDP component.')
vncsDPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsDPRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPRowStatus.setDescription('This variable is used as the basis for SNMP naming of vncsDP components. These components can be added.')
vncsDPComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsDPComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vncsDPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsDPStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPStorageType.setDescription('This variable represents the storage type value for the vncsDP tables.')
vncsDPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: vncsDPIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPIndex.setDescription('This variable represents the index for the vncsDP tables.')
vncsDPStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 10), )
if mibBuilder.loadTexts: vncsDPStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPStatsTable.setDescription('This group provides the operational components for the AccessCode component. It displays total DirectoryNumber components under this access code, total translation requests received and total requests failed under this access code.')
vncsDPStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsDPIndex"))
if mibBuilder.loadTexts: vncsDPStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPStatsEntry.setDescription('An entry in the vncsDPStatsTable.')
vncsDPCompleteTranslations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsDPCompleteTranslations.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPCompleteTranslations.setDescription('This attribute counts the total number of complete translations handled under this AccessCode component. The complete translations are the one that resulted in the return by VNCS server of the reply message with the routing information and voice profile parameters associated with the directory number prefix supplied in the translation request message. This counter wraps to zero when it reaches its maximum value.')
vncsDPIncompleteTranslations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsDPIncompleteTranslations.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPIncompleteTranslations.setDescription('This attribute counts the total number of incomplete translations handled under this AccessCode component. The incomplete translations are the one that require more digits in the directory number prefix to uniquely identify routing attributes. This counter wraps to zero when it reaches its maximum value.')
vncsDPFailedTranslations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsDPFailedTranslations.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPFailedTranslations.setDescription('This attribute counts the total number of failed translations handled under this AccessCode component. The failed translations are the one for which the directory number prefix could not be found in the database. the value wraps up when it reaches maximum.')
vncsDPDn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2))
vncsDPDnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 1), )
if mibBuilder.loadTexts: vncsDPDnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnRowStatusTable.setDescription('This entry controls the addition and deletion of vncsDPDn components.')
vncsDPDnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsDPIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsDPDnIndex"))
if mibBuilder.loadTexts: vncsDPDnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnRowStatusEntry.setDescription('A single entry in the table represents a single vncsDPDn component.')
vncsDPDnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsDPDnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnRowStatus.setDescription('This variable is used as the basis for SNMP naming of vncsDPDn components. These components can be added and deleted.')
vncsDPDnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsDPDnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vncsDPDnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsDPDnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnStorageType.setDescription('This variable represents the storage type value for the vncsDPDn tables.')
vncsDPDnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 1, 1, 10), WildcardedDigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 40)))
if mibBuilder.loadTexts: vncsDPDnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnIndex.setDescription('This variable represents the index for the vncsDPDn tables.')
vncsDPDnProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 10), )
if mibBuilder.loadTexts: vncsDPDnProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnProvTable.setDescription('This group represents attributes that the prefix directory number maps to.')
vncsDPDnProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsDPIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsDPDnIndex"))
if mibBuilder.loadTexts: vncsDPDnProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnProvEntry.setDescription('An entry in the vncsDPDnProvTable.')
vncsDPDnDestinationNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsDPDnDestinationNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnDestinationNodeId.setDescription("This attribute in conjunction with the destinationComponentId attribute identifies the destination of a voice connection. The destinationNodeId and the destinationComponentId attributes are being replaced by the DataNetworkAddress (Dna) attribute. For the migration procedure consult NTP 241-7001-410 'Passport Voice Networking User Guide'. If the destinationComponentId, the destinationNodeId and the Dna attributes are all set, the call routing is based on the destinationNodeId and the destinationComponentId, unless the call is initiated from the Magellan Passport Access (MPA) module, which will use the Dna attribute. The valid destination call identifier settings are: 1. destinationNodeId and destinationNodeId attributes set 2. destinationNodeId, destinationNodeId and Dna attributes set 3. Dna attribute set For calls initiated from the MPA, only options 2 and 3 are valid.")
vncsDPDnDestinationComponentId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 10, 1, 2), RowPointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsDPDnDestinationComponentId.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnDestinationComponentId.setDescription("This attribute in conjunction with the destinationNodeId attribute identifies the destination of a voice connection. The only valid component name for this attribute value is vroute. The destinationNodeId and the destinationComponentId attributes are being replaced by the DataNetworkAddress (Dna) attribute. For the migration procedure consult NTP 241-7001-410 'Passport Voice Networking User Guide'. If the destinationComponentId, the destinationNodeId and the Dna attributes are all set, the call routing is based on the destinationNodeId and the destinationComponentId, unless the call is initiated from the Magellan Passport Access (MPA) module, which will use the Dna attribute. The valid destination call identifier settings are: 1. destinationNodeId and destinationNodeId attributes set 2. destinationNodeId, destinationNodeId and Dna attributes set 3. Dna attribute set For calls initiated from the MPA, only options 2 and 3 are valid.")
vncsDPDnVoiceProfileNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsDPDnVoiceProfileNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnVoiceProfileNumber.setDescription('This attribute identifies the voice profile number.')
vncsDPDnNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('e164')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsDPDnNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna of the destination component. An address may belong to the X.121 or E.164 numbering plans. X.121 is used in packet switched data networks.')
vncsDPDnDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 2, 2, 10, 1, 5), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsDPDnDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vncsDPDnDataNetworkAddress.setDescription('The Dna attribute contains digits which form a unique identifier of the destination of a voice connection. This attribute is used instead of the destinationNodeId and destinationComponentId attributes to identify the destination of the voice connection. This attribute is only used if the destinationNodeId and the destinationComponentId attributes are not set or if the call is initiated from the Magellan Passport Access (MPA) module.')
vncsVp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3))
vncsVpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 1), )
if mibBuilder.loadTexts: vncsVpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpRowStatusTable.setDescription('This entry controls the addition and deletion of vncsVp components.')
vncsVpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"))
if mibBuilder.loadTexts: vncsVpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpRowStatusEntry.setDescription('A single entry in the table represents a single vncsVp component.')
vncsVpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vncsVp components. These components can be added and deleted.')
vncsVpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsVpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vncsVpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsVpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpStorageType.setDescription('This variable represents the storage type value for the vncsVp tables.')
vncsVpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: vncsVpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpIndex.setDescription('This variable represents the index for the vncsVp tables.')
vncsVpLCOpsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2), )
if mibBuilder.loadTexts: vncsVpLCOpsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpLCOpsTable.setDescription('The attributes of this group collectively form part of a template used to describe and set up a switched logical connection. The attributes of a switched logical connection are similar to the attributes of a permanent logical connection.')
vncsVpLCOpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"))
if mibBuilder.loadTexts: vncsVpLCOpsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpLCOpsEntry.setDescription('An entry in the vncsVpLCOpsTable.')
vncsVpSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpSetupPriority.setDescription("This attribute specifies the priority at which a path is established. Zero is the highest priority and four is the lowest. When PORS establishes a path through the network, it uses the setupPriority attribute to determine its potential for bumping established paths to acquire their bandwidth. The holdingPriority, a complementary attribute of this attribute, indicates the priority a path maintains once it is established. A new path can bump an existing path if the new path's setupPriority is higher (numerically less) than the existing path's holdingPriority.")
vncsVpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpHoldingPriority.setDescription("This attribute specifies the priority that a path holds once it is established. Zero is the highest priority and four is the lowest. A path's holdingPriority determines its likelihood of being bumped by a new path to acquire its bandwidth. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time. A new path can bump an existing path if the new path's setupPriority is higher (numerically less) than the existing path's holdingPriority.")
vncsVpBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1))).clone('bumpWhenNecessary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpBumpPreference.setDescription('This attribute specifies when bumping occurs in the route selection process. A connection with higher (numerically less) setupPriority may bump a connection with lower (numerically higher) setupPriority in order to acquire its bandwidth and be established. By default, bumping occurs only when it is necessary. That is, a connection will bump another connection only if there is no other way for the connection to be established. A connection may be set to bump in order to use the best available route it may have.')
vncsVpRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7))).clone('voice')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpRequiredTrafficType.setDescription('This attribute specifies the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1, then only trunks that include trafficType1 in supportedTrafficType will be candidates for this connection.')
vncsVpPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpPermittedTrunkTypes.setDescription("This attribute specifies up to eight types of trunks that can be used on the route. The terrestrial and satellite trunk types have been defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS chooses only trunks whose trunkTypes are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
vncsVpRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpRequiredSecurity.setDescription("This attribute specifies the required minimum level of security of the trunks on the route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
vncsVpRequiredCustomerParm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpRequiredCustomerParm.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpRequiredCustomerParm.setDescription('This attribute specifies the allowed customer defined parameter of the trunks on the route. Its value, a number from zero to seven, is chosen by network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
vncsVpPathAttributeToMinimize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("cost", 0), ("delay", 1))).clone('cost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpPathAttributeToMinimize.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpPathAttributeToMinimize.setDescription('This attribute specifies whether a route is selected on the basis of minimizing the cost or the delay. Each trunk has a cost and a delay metric associated with it. The cost of a selected route is the sum of the trunk cost metrics for all trunks included in the route. The delay of a selected route is the sum of the trunk delay metric for all trunks included in the route.')
vncsVpMaximumAcceptableCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1280)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpMaximumAcceptableCost.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpMaximumAcceptableCost.setDescription('This attribute specifies an upper bound on the cost metric of a route, which is the sum of the cost metrics of all trunks on the route. The cost metric is the trunkCost attribute of the Trunk component. If for any trunk the trunkCost is larger than the maximumAcceptableCost, then that trunk is not considered during the route selection. While a shortest route is being selected, the route cost is being compared with the maximumAcceptableCost attribute, and this is done for any minimization criterion. No route is selected if the cost metric of the shortest route is larger than the maximumAcceptableCost.')
vncsVpMaximumAcceptableDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000)).clone(100000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpMaximumAcceptableDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpMaximumAcceptableDelay.setDescription("This attribute specifies an upper bound on the delay of a route, which is the sum of the delays of all trunks on the route. It should be provisioned with a reasonable maximum acceptable delay for the end to end one way delay of a 512-byte packet. Remember, that the trunk during its staging measures a measuredRoundTripDelay. This delay is divided by two and truncated to an integer number of milliseconds to provide a one way delay which is used to populate the delay in this trunk object in the topological database. The value includes emission, propagation, and queuing delays. A 512-byte packet is used to perform the measurement. If for any trunk the half of the trunk's measuredRoundTripDelay is larger than the maximumAcceptableDelay, then that trunk is not considered during the route selection. While a shortest route is being selected, the route delay is being compared with the maximumAcceptableDelay attribute, and this is done for any minimization criterion. No route is selected if the delay metric of the shortest route is larger than the maximumAcceptableDelay.")
vncsVpEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpEmissionPriority.setDescription('This attribute specifies the urgency with which packets on the path are emitted by the trunks on the route. EmissionPriority of zero indicates the highest emission priority, while two indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher).')
vncsVpDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpDiscardPriority.setDescription('This attribute specifies the importance of the packets on the path. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
vncsVpPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1))).clone('reRoutePath')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpPathFailureAction.setDescription('This attribute specifies whether the application can tolerate momentary interruption of a path while a new path is selected. If disconnectConnection is chosen, the application is informed as soon as possible about a failure by disconnection. If the attribute is set to reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails, the application is informed of the failure. With this option set to reRoutePath, the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect. All pathTypes respect this attribute. Also on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option will have the desired effect that the path is rerouted without complete disconnection at both ends.')
vncsVpOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpOptimization.setDescription('This attribute specifies whether this connection should attempt to optimize its path when requested by the Rtg Pors component. Every path is optimal when it is established, but as network traffic patterns and configurations change this path may no longer be optimal. The PORS connection manager on a module requests circuits to optimize at the optimizationInterval.')
vncsVpFrOpsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3), )
if mibBuilder.loadTexts: vncsVpFrOpsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpFrOpsTable.setDescription('This group contains attributes which define how audio data is carried across the Passport network.')
vncsVpFrOpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"))
if mibBuilder.loadTexts: vncsVpFrOpsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpFrOpsEntry.setDescription('An entry in the vncsVpFrOpsTable.')
vncsVpMaxVoiceBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3))).clone('n64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpMaxVoiceBitRate.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpMaxVoiceBitRate.setDescription('This attribute specifies the maximum encoding bit rate (minimum compression rate) that will be used for voice data. This attribute was migrated to the max element of the g711G726 row of the voiceRates attribute.')
vncsVpMinVoiceBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3))).clone('n16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpMinVoiceBitRate.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpMinVoiceBitRate.setDescription('This attribute specifies the minimum encoding bit rate (maximum compression rate) that will be used for voice data. Migration information: If minVoiceBitRate is 64 kbit/s, it means that the user did not accept any compression. To get the same effect with the current provisioning, we set Vncs/m Vp/n voiceEncodingChoice first = g711Only, second = none and third = none. If minVoiceBitRate is 16, 24 or 32 kbit/s, it means that the user did accept compression. To get the same effect with the current provisioning, we set the minimum g711G726 rate in Vncs/m VoiceProfile/n voiceRates to minVoiceBitRate and leave voiceEncodingChoice with its default values.')
vncsVpMaxModemBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3))).clone('n64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpMaxModemBitRate.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpMaxModemBitRate.setDescription('This attribute was migrated to the max element of the g711G726 row of the modemFaxRates attribute. DESCRIPTION')
vncsVpMinModemBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("n64", 0), ("n32", 1), ("n24", 2), ("n16", 3))).clone('n32')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpMinModemBitRate.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpMinModemBitRate.setDescription('This attribute has been obsoleted. Migration information is as follows: If minModemBitRate is 64 kbit/s, it means that the user did not accept any compression. To get the same effect with the current provisioning, we set Vncs/m Vp/n modemFaxEncodingChoice first = g711Only, second = none and third = none. If minModemBitRate is 16, 24 or 32 kbit/s, it means that the user did accept compression. To get the same effect with the current provisioning, we set the minimum g711G726 rate in Vncs/m VoiceProfile/n modemFaxRates to minModemBitRate and leave modemFaxEncodingChoice with its default values. DESCRIPTION')
vncsVpAudioGain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("minus6", 0), ("minus4", 1), ("minus2", 2), ("n0", 3), ("n2", 4), ("n4", 5), ("n6", 6))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpAudioGain.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpAudioGain.setDescription('This attribute has been migrated to VRoute Interface egressAudioGain.')
vncsVpSilenceSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("congested", 2), ("slow", 3), ("slowAndCongested", 4))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpSilenceSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpSilenceSuppression.setDescription('This attribute specifies when silence suppression is desired during voice traffic on an audio call. If silenceSuppression is off, silence suppression is never desired. If silenceSuppression is on, silence suppression is always desired. If silenceSuppression is congested, silence suppression is desired only when the network is congested. If silenceSuppression is slow, silence suppression is desired only after 20 seconds without audio. If silenceSuppression is slowAndCongested, both the slow and congested options are desired. The negotiated silence suppression is available in Vsr Svs Framer negotiatedSilenceSuppression.')
vncsVpEchoCancellation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpEchoCancellation.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpEchoCancellation.setDescription('This attribute has been migrated to VRoute Interface echoCancellation.')
vncsVpSilenceSuppressionFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpSilenceSuppressionFactor.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpSilenceSuppressionFactor.setDescription('This attribute specifies the expected savings (percent reduction) in required bandwidth if silence suppression is used. If silence suppression is used, the bandwidth required for the connection will be lower than if silence suppression is not used. However, the routing system will not be aware of the unused bandwidth unless that bandwidth is specified by this attribute. If the value specified for the expected savings is too low, then some bandwidth made available by the use of silence suppression will be wasted. If the value specified for the expected savings is too high, then some connections may fail to set up because the routing system will over-calculate the amount of bandwidth available. The effectiveness of silence suppression can be influenced by language related speech patterns.')
vncsVpDataCallsAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpDataCallsAccepted.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpDataCallsAccepted.setDescription('This attribute specifies whether data calls are allowed if this profile is used.')
vncsVpFaxIdleSuppressionG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpFaxIdleSuppressionG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpFaxIdleSuppressionG711G726.setDescription('This attribute specifies the fax idle suppression parameter used during negotiation with the remote end across the subnet. It applies only to fax traffic, not voice or modem traffic. The negotiated G.711/G.726 fax idle suppression is available in Vsr Svs Framer negotiatedFisG711G726.')
vncsVpInsertedOutputDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 15, 22, 30, 35, 40, 45, 50, 75, 100, 125, 150))).clone(namedValues=NamedValues(("n5", 5), ("n15", 15), ("n22", 22), ("n30", 30), ("n35", 35), ("n40", 40), ("n45", 45), ("n50", 50), ("n75", 75), ("n100", 100), ("n125", 125), ("n150", 150))).clone('n22')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpInsertedOutputDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpInsertedOutputDelay.setDescription('This attribute specifies the amount of added output delay used to compensate for cross network delay variations. It applies to voice, modem and fax traffic. It is required to add output delay so that the statistical variation in the transit time of cells crossing the network does not cause gaps in speech. Backbone networks where high priority traffic consumes a high percentage of trunk bandwidth will require a higher insertedOutputDelay to compensate for the greater cell delay variation (CDV). This attribute is ignored if this call runs on a 1pDS1V or 1pE1V card.')
vncsVpVoiceTrafficOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bandwidth", 0), ("delay", 1))).clone('bandwidth')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpVoiceTrafficOptimization.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceTrafficOptimization.setDescription('This attribute is not supported now. This attribute specifies how to optimize voice traffic. Setting voiceTrafficOptimization to bandwidth specifies that voice traffic should be optimized to preserve bandwidth. Setting voiceTrafficOptimization to delay specifies that voice traffic should be optimized to minimize delay.')
vncsVpDtmfRegeneration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpDtmfRegeneration.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpDtmfRegeneration.setDescription('This attribute specifies the DTMF regeneration parameter used during negotiation with the remote end across the subnet. If dtmfRegeneration is on, it is desired that DTMF tones received from the link are first converted to digits before being sent to the subnet. When a digit is received from the subnet, its respective DTMF tone is desired to be generated before being sent to the link. If dtmfRegeneration is off, it is desired that DTMF tones are transported transparently as audio. DTMF regeneration is not supported on 1pDS1V, 1pE1V, and J2MV cards. On these cards, the value of dtmfRegeneration is ignored. The negotiated DTMF regeneration is available in Vsr Svs Framer negotiatedDtmfRegeneration.')
vncsVpV17EncodedAsG711G726 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpV17EncodedAsG711G726.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpV17EncodedAsG711G726.setDescription('This attribute specifies how services using this VoiceProfile negotiate with V.17 fax machines. This attribute is not used unless the negotiated fax encoding, available in Vsr Svs Framer negotiatedEncoding, is v29V27Relay and the negotiated modemFax encoding, available in Vsr Svs Framer negotiatedEncoding, is g711, g726 or g711G726. If v17EncodedAsG711G726 is no, it is desired that V.17 fax machines be instructed to use V.29 so that V.29 fax traffic sent by fax machines can be demodulated and encoded using fax relay. If v17EncodedAsG711G726 is yes, it is desired that V.17 fax machines be permitted to use V.17 so that V.17 fax traffic sent by fax machines can be encoded using G.711 or G.726. The actual encoding performed depends on the negotiated minimum and maximum modemFax rates, available in Vsr Svs Framer negotiatedRates. The actual negotiation between services using this VoiceProfile and V.17 fax machines is available in Vsr Svs Framer negotiatedV17AsG711G726.')
vncsVpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 4), )
if mibBuilder.loadTexts: vncsVpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpStatsTable.setDescription('This group contains the operational statistics data for a Voice Networking profile component.')
vncsVpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 4, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"))
if mibBuilder.loadTexts: vncsVpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpStatsEntry.setDescription('An entry in the vncsVpStatsTable.')
vncsVpUsageCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vncsVpUsageCount.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpUsageCount.setDescription('This attribute counts the number of times this VoiceProfile is accessed to set up a connection. This counter wraps to 0 when it reaches its maximum value.')
vncsVpVoiceRatesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 322), )
if mibBuilder.loadTexts: vncsVpVoiceRatesTable.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceRatesTable.setDescription('This attribute has been migrated to voiceRates.')
vncsVpVoiceRatesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 322, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpVoiceRatesEncodingIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpVoiceRatesRateIndex"))
if mibBuilder.loadTexts: vncsVpVoiceRatesEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceRatesEntry.setDescription('An entry in the vncsVpVoiceRatesTable.')
vncsVpVoiceRatesEncodingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 322, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("g711Only", 0), ("g711G726", 1), ("g728Only", 2), ("g729Only", 3))))
if mibBuilder.loadTexts: vncsVpVoiceRatesEncodingIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceRatesEncodingIndex.setDescription('This variable represents the next to last index for the vncsVpVoiceRatesTable.')
vncsVpVoiceRatesRateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 322, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("min", 0), ("max", 1))))
if mibBuilder.loadTexts: vncsVpVoiceRatesRateIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceRatesRateIndex.setDescription('This variable represents the final index for the vncsVpVoiceRatesTable.')
vncsVpVoiceRatesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 322, 1, 3), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(80, 80), ValueRangeConstraint(160, 160), ValueRangeConstraint(240, 240), ValueRangeConstraint(320, 320), ValueRangeConstraint(640, 640), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpVoiceRatesValue.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceRatesValue.setDescription('This variable represents an individual value for the vncsVpVoiceRatesTable.')
vncsVpVoiceEncodingChoiceTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 323), )
if mibBuilder.loadTexts: vncsVpVoiceEncodingChoiceTable.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceEncodingChoiceTable.setDescription('This attribute has been migrated to voiceEncodingChoice.')
vncsVpVoiceEncodingChoiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 323, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpVoiceEncodingChoiceIndex"))
if mibBuilder.loadTexts: vncsVpVoiceEncodingChoiceEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceEncodingChoiceEntry.setDescription('An entry in the vncsVpVoiceEncodingChoiceTable.')
vncsVpVoiceEncodingChoiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 323, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("first", 0), ("second", 1), ("third", 2))))
if mibBuilder.loadTexts: vncsVpVoiceEncodingChoiceIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceEncodingChoiceIndex.setDescription('This variable represents the vncsVpVoiceEncodingChoiceTable specific index for the vncsVpVoiceEncodingChoiceTable.')
vncsVpVoiceEncodingChoiceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 323, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("g711Only", 0), ("g711G726", 1), ("g728Only", 2), ("g729Only", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpVoiceEncodingChoiceValue.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpVoiceEncodingChoiceValue.setDescription('This variable represents an individual value for the vncsVpVoiceEncodingChoiceTable.')
vncsVpModemFaxRatesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 324), )
if mibBuilder.loadTexts: vncsVpModemFaxRatesTable.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxRatesTable.setDescription('This attribute has been migrated to modemFaxRates.')
vncsVpModemFaxRatesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 324, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpModemFaxRatesEncodingIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpModemFaxRatesRateIndex"))
if mibBuilder.loadTexts: vncsVpModemFaxRatesEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxRatesEntry.setDescription('An entry in the vncsVpModemFaxRatesTable.')
vncsVpModemFaxRatesEncodingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 324, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("g711Only", 0), ("g711G726", 1), ("relay", 2))))
if mibBuilder.loadTexts: vncsVpModemFaxRatesEncodingIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxRatesEncodingIndex.setDescription('This variable represents the next to last index for the vncsVpModemFaxRatesTable.')
vncsVpModemFaxRatesRateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 324, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("min", 0), ("max", 1))))
if mibBuilder.loadTexts: vncsVpModemFaxRatesRateIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxRatesRateIndex.setDescription('This variable represents the final index for the vncsVpModemFaxRatesTable.')
vncsVpModemFaxRatesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 324, 1, 3), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(3, 3), ValueRangeConstraint(12, 12), ValueRangeConstraint(24, 24), ValueRangeConstraint(48, 48), ValueRangeConstraint(72, 72), ValueRangeConstraint(96, 96), ValueRangeConstraint(120, 120), ValueRangeConstraint(144, 144), ValueRangeConstraint(160, 160), ValueRangeConstraint(240, 240), ValueRangeConstraint(320, 320), ValueRangeConstraint(640, 640), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpModemFaxRatesValue.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxRatesValue.setDescription('This variable represents an individual value for the vncsVpModemFaxRatesTable.')
vncsVpModemFaxEncodingChoiceTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 325), )
if mibBuilder.loadTexts: vncsVpModemFaxEncodingChoiceTable.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxEncodingChoiceTable.setDescription('This attribute has been migrated to modemFaxEncodingChoice. The faxRelay feature must be present to include a setting of relay.')
vncsVpModemFaxEncodingChoiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 325, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpModemFaxEncodingChoiceIndex"))
if mibBuilder.loadTexts: vncsVpModemFaxEncodingChoiceEntry.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxEncodingChoiceEntry.setDescription('An entry in the vncsVpModemFaxEncodingChoiceTable.')
vncsVpModemFaxEncodingChoiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 325, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("first", 0), ("second", 1), ("third", 2))))
if mibBuilder.loadTexts: vncsVpModemFaxEncodingChoiceIndex.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxEncodingChoiceIndex.setDescription('This variable represents the vncsVpModemFaxEncodingChoiceTable specific index for the vncsVpModemFaxEncodingChoiceTable.')
vncsVpModemFaxEncodingChoiceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 325, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("g711Only", 0), ("g711G726", 1), ("relay", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpModemFaxEncodingChoiceValue.setStatus('obsolete')
if mibBuilder.loadTexts: vncsVpModemFaxEncodingChoiceValue.setDescription('This variable represents an individual value for the vncsVpModemFaxEncodingChoiceTable.')
vncsVpNewVoiceRatesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 381), )
if mibBuilder.loadTexts: vncsVpNewVoiceRatesTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceRatesTable.setDescription('This attribute specifies the minimum and maximum voice rate parameters used during negotiation with the remote end across the subnet. For g711G726 encoding, rates can change during voice traffic due to congestion in the network. Therefore, you can have differing minimum and maximum rates for g711G726 encoding. All other encodings have a fixed rate for the duration of voice traffic and so their minimum and maximum rates can not be modified. The negotiated minimum and maximum voice rates are available in Vsr Svs Framer negotiatedRates.')
vncsVpNewVoiceRatesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 381, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpNewVoiceRatesEncodingIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpNewVoiceRatesRateIndex"))
if mibBuilder.loadTexts: vncsVpNewVoiceRatesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceRatesEntry.setDescription('An entry in the vncsVpNewVoiceRatesTable.')
vncsVpNewVoiceRatesEncodingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 381, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("g711Only", 0), ("g711G726", 1), ("g728Only", 2), ("g729Only", 3))))
if mibBuilder.loadTexts: vncsVpNewVoiceRatesEncodingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceRatesEncodingIndex.setDescription('This variable represents the next to last index for the vncsVpNewVoiceRatesTable.')
vncsVpNewVoiceRatesRateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 381, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("min", 0), ("max", 1))))
if mibBuilder.loadTexts: vncsVpNewVoiceRatesRateIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceRatesRateIndex.setDescription('This variable represents the final index for the vncsVpNewVoiceRatesTable.')
vncsVpNewVoiceRatesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 381, 1, 3), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(80, 80), ValueRangeConstraint(160, 160), ValueRangeConstraint(240, 240), ValueRangeConstraint(320, 320), ValueRangeConstraint(640, 640), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpNewVoiceRatesValue.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceRatesValue.setDescription('This variable represents an individual value for the vncsVpNewVoiceRatesTable.')
vncsVpNewVoiceEncodingChoiceTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 382), )
if mibBuilder.loadTexts: vncsVpNewVoiceEncodingChoiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceEncodingChoiceTable.setDescription("This attribute specifies preferences regarding the encoding of voice traffic. During the setup of an audio call, the local and remote ends negotiate a common encoding to use. The local end's ordered list of preferred encodings is given by all voiceEncodingChoice elements that are not set to none. Prior to negotiation, the local end removes encodings from its list that it cannot use for a particular call. For example, the card for a particular call may not support certain encodings. After this local check, the local end sends its voice encoding preferences to the remote end. The remote end chooses the most preferred encoding that it can support from the list and this encoding is the one used during voice traffic. If the remote end cannot support any encodings on the local end's list, a call does not proceed and an alarm is issued. The current encoding and encoding rate are available in Vsr Svs currentEncoding and Vsr Svs currentRate. The encoding choice g711Only specifies that pulse code modulation (PCM) defined by ITU-T G.711 should be performed to encode voice traffic for calls using this profile. In this case, all voice traffic is carried uncompressed at 64 kbit/s. The encoding choice g711G726 specifies that either pulse code modulation (PCM) defined by ITU-T G.711 or adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726 should be performed to encode voice traffic for calls using this profile. The actual encoding performed depends on congestion in the network and the settings of the g711G726 row of the voiceRates attribute. The encoding choice of g728Only specifies that the Low Delay Coded Excited Linear Predictive Coder (LD-CELP) algorithm defined by ITU-T G.728 should be performed to encode voice traffic for calls using this profile. In this case, all voice traffic is carried at 16 kbit/s. The encoding choice of g729Only specifies that the Conjugated Structure Algebraic Code Excited Linear Predictive Coder (CS-ACELP) algorithm defined by ITU-T G.729 should be performed to encode voice traffic for calls using this profile. In this case, all voice traffic is carried at 8 kbit/s. The encoding choice of none specifies the end of the encoding choice list. No other encoding choice can appear after none, and none cannot appear as the first choice. The only encoding choice that can appear more than once in voiceEncodingChoice is none. G.728 and G.729 encoding cannot be performed on a 1pDS1V, 1pE1V or J2MV card. The negotiated voice encoding is available in Vsr Svs Framer negotiatedEncoding.")
vncsVpNewVoiceEncodingChoiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 382, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpNewVoiceEncodingChoiceIndex"))
if mibBuilder.loadTexts: vncsVpNewVoiceEncodingChoiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceEncodingChoiceEntry.setDescription('An entry in the vncsVpNewVoiceEncodingChoiceTable.')
vncsVpNewVoiceEncodingChoiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 382, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("first", 0), ("second", 1), ("third", 2))))
if mibBuilder.loadTexts: vncsVpNewVoiceEncodingChoiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceEncodingChoiceIndex.setDescription('This variable represents the vncsVpNewVoiceEncodingChoiceTable specific index for the vncsVpNewVoiceEncodingChoiceTable.')
vncsVpNewVoiceEncodingChoiceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 382, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("g711Only", 0), ("g711G726", 1), ("g728Only", 2), ("g729Only", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpNewVoiceEncodingChoiceValue.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewVoiceEncodingChoiceValue.setDescription('This variable represents an individual value for the vncsVpNewVoiceEncodingChoiceTable.')
vncsVpNewModemFaxRatesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 383), )
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesTable.setDescription('This attribute specifies the minimum and maximum modemFax and fax rate parameters used during negotiation with the remote end across the subnet. For g711Only encoding, all modem/fax traffic is carried uncompressed at 64 kbit/s, so this row of modemFaxRates cannot be changed. For g711G726 encoding, rates can change during modemFax and fax traffic due to congestion in the network. The minimum and maximum rates that can occur during the modemFax traffic are specified by the g711G726 row of modemFaxRates. The relay row of modemFaxRates specifies the minimum and maximum rates of sending fax machines that are allowed for fax relay. relay does not apply to modem calls. The negotiated minimum and maximum modemFax and fax rates are available in Vsr Svs Framer negotiatedRates.')
vncsVpNewModemFaxRatesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 383, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpNewModemFaxRatesEncodingIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpNewModemFaxRatesRateIndex"))
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesEntry.setDescription('An entry in the vncsVpNewModemFaxRatesTable.')
vncsVpNewModemFaxRatesEncodingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 383, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("g711Only", 0), ("g711G726", 1), ("relay", 2))))
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesEncodingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesEncodingIndex.setDescription('This variable represents the next to last index for the vncsVpNewModemFaxRatesTable.')
vncsVpNewModemFaxRatesRateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 383, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("min", 0), ("max", 1))))
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesRateIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesRateIndex.setDescription('This variable represents the final index for the vncsVpNewModemFaxRatesTable.')
vncsVpNewModemFaxRatesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 383, 1, 3), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(3, 3), ValueRangeConstraint(12, 12), ValueRangeConstraint(24, 24), ValueRangeConstraint(48, 48), ValueRangeConstraint(72, 72), ValueRangeConstraint(96, 96), ValueRangeConstraint(120, 120), ValueRangeConstraint(144, 144), ValueRangeConstraint(160, 160), ValueRangeConstraint(240, 240), ValueRangeConstraint(320, 320), ValueRangeConstraint(640, 640), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesValue.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxRatesValue.setDescription('This variable represents an individual value for the vncsVpNewModemFaxRatesTable.')
vncsVpNewModemFaxEncodingChoiceTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 384), )
if mibBuilder.loadTexts: vncsVpNewModemFaxEncodingChoiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxEncodingChoiceTable.setDescription("This attribute specifies preferences regarding the encoding of modemFax and fax traffic. During the setup of an audio call, the local and remote ends negotiate one common encoding to use during modemFax traffic and one common encoding to use during fax traffic. The local end's ordered list of preferred encodings is given by all modemFaxEncodingChoice elements that are not set to none. Prior to negotiation, the local end removes encodings from its list that it cannot use for a particular call. For example, the card for a particular call may not be able to support certain encodings, or in the case of relay, the rate of the sending machine may not be supported. After this local check, the local end sends its modem/fax encoding preferences to the remote end. The remote end uses the two most preferred encodings that it can support from the list to determine the encoding used during modemFax traffic and the encoding used during fax traffic. If the remote end cannot support any encodings on the local end's list, a call does not proceed and an alarm is issued. The current encoding and encoding rate are available in Vsr Svs currentEncoding and Vsr Svs currentRate. The encoding choice g711Only specifies that pulse code modulation (PCM) defined by ITU-T G.711 should be performed to encode modem/fax traffic for calls using this profile. In this case, all modem/fax traffic is carried uncompressed at 64 kbit/s. The encoding choice g711G726 specifies that either pulse code modulation (PCM) defined by ITU-T G.711 or adaptive differential pulse code modulation (ADPCM) defined by ITU-T G.726 should be performed to encode modem/fax traffic for calls using this profile. The actual encoding performed depends on congestion in the network and the settings of the g711G726 row of the modemFaxRates attribute. The encoding choice of relay specifies that modulated modem/fax traffic is demodulated and sent through the network as Passport cells at the base rate of the sending machine. The types of modulation/demodulation supported are V.29 up to 9.6 kbit/s and V.27 up to 4.8 kbit/s. Only fax traffic can use relay. If modemFaxEncodingChoice is relay, none, none, modem traffic is not supported. If modemFaxEncodingChoice is none, none, none, all traffic is treated like voice traffic. Fax relay cannot be performed on 1pDS1V, 1pE1V or J2MV cards. The negotiated modemFax and fax encodings are available in Vsr Svs Framer negotiatedEncoding.")
vncsVpNewModemFaxEncodingChoiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 384, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpIndex"), (0, "Nortel-Magellan-Passport-VncsCallServerMIB", "vncsVpNewModemFaxEncodingChoiceIndex"))
if mibBuilder.loadTexts: vncsVpNewModemFaxEncodingChoiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxEncodingChoiceEntry.setDescription('An entry in the vncsVpNewModemFaxEncodingChoiceTable.')
vncsVpNewModemFaxEncodingChoiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 384, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("first", 0), ("second", 1), ("third", 2))))
if mibBuilder.loadTexts: vncsVpNewModemFaxEncodingChoiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxEncodingChoiceIndex.setDescription('This variable represents the vncsVpNewModemFaxEncodingChoiceTable specific index for the vncsVpNewModemFaxEncodingChoiceTable.')
vncsVpNewModemFaxEncodingChoiceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 44, 3, 384, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("g711Only", 0), ("g711G726", 1), ("relay", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vncsVpNewModemFaxEncodingChoiceValue.setStatus('mandatory')
if mibBuilder.loadTexts: vncsVpNewModemFaxEncodingChoiceValue.setDescription('This variable represents an individual value for the vncsVpNewModemFaxEncodingChoiceTable.')
vncsCallServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66, 1))
vncsCallServerGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66, 1, 5))
vncsCallServerGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66, 1, 5, 2))
vncsCallServerGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66, 1, 5, 2, 2))
vncsCallServerCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66, 3))
vncsCallServerCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66, 3, 5))
vncsCallServerCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66, 3, 5, 2))
vncsCallServerCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 66, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-VncsCallServerMIB", vncsVpRowStatusTable=vncsVpRowStatusTable, vncsVpUsageCount=vncsVpUsageCount, vncsDPDnVoiceProfileNumber=vncsDPDnVoiceProfileNumber, vncsVpNewModemFaxEncodingChoiceIndex=vncsVpNewModemFaxEncodingChoiceIndex, vncsVRoutesTable=vncsVRoutesTable, vncsVRoutesValue=vncsVRoutesValue, vncsVpModemFaxRatesTable=vncsVpModemFaxRatesTable, vncsVpModemFaxRatesEncodingIndex=vncsVpModemFaxRatesEncodingIndex, vncsRowStatusTable=vncsRowStatusTable, vncsVpDtmfRegeneration=vncsVpDtmfRegeneration, vncsDPDnDataNetworkAddress=vncsDPDnDataNetworkAddress, vncsCommentText=vncsCommentText, vncsVpModemFaxEncodingChoiceValue=vncsVpModemFaxEncodingChoiceValue, vncsVpEchoCancellation=vncsVpEchoCancellation, vncsVpMaximumAcceptableCost=vncsVpMaximumAcceptableCost, vncsProvEntry=vncsProvEntry, vncsDPStorageType=vncsDPStorageType, vncsVpVoiceEncodingChoiceIndex=vncsVpVoiceEncodingChoiceIndex, vncsVpVoiceRatesEntry=vncsVpVoiceRatesEntry, vncsVpModemFaxRatesEntry=vncsVpModemFaxRatesEntry, vncsDPRowStatusEntry=vncsDPRowStatusEntry, vncsCallServerCapabilitiesBE=vncsCallServerCapabilitiesBE, vncsRowStatusEntry=vncsRowStatusEntry, vncsStorageType=vncsStorageType, vncsVpMaximumAcceptableDelay=vncsVpMaximumAcceptableDelay, vncsVpVoiceRatesRateIndex=vncsVpVoiceRatesRateIndex, vncsVpNewModemFaxRatesRateIndex=vncsVpNewModemFaxRatesRateIndex, vncsVpIndex=vncsVpIndex, vncsVpSilenceSuppressionFactor=vncsVpSilenceSuppressionFactor, vncsVpNewModemFaxRatesEntry=vncsVpNewModemFaxRatesEntry, vncsVpVoiceEncodingChoiceValue=vncsVpVoiceEncodingChoiceValue, vncsVpPathAttributeToMinimize=vncsVpPathAttributeToMinimize, vncsCallServerMIB=vncsCallServerMIB, vncsVpNewModemFaxEncodingChoiceTable=vncsVpNewModemFaxEncodingChoiceTable, vncsDPDnDestinationComponentId=vncsDPDnDestinationComponentId, vncsStatsTable=vncsStatsTable, vncsDPRowStatus=vncsDPRowStatus, vncsVRoutesEntry=vncsVRoutesEntry, vncsVpVoiceEncodingChoiceEntry=vncsVpVoiceEncodingChoiceEntry, vncsVpModemFaxRatesValue=vncsVpModemFaxRatesValue, vncsDPIncompleteTranslations=vncsDPIncompleteTranslations, vncsIndex=vncsIndex, vncsVpNewModemFaxEncodingChoiceValue=vncsVpNewModemFaxEncodingChoiceValue, vncsVpStatsEntry=vncsVpStatsEntry, vncsVpInsertedOutputDelay=vncsVpInsertedOutputDelay, vncsDPDn=vncsDPDn, vncsVpBumpPreference=vncsVpBumpPreference, vncsVpVoiceRatesTable=vncsVpVoiceRatesTable, vncsDPDnStorageType=vncsDPDnStorageType, vncsVpV17EncodedAsG711G726=vncsVpV17EncodedAsG711G726, vncsVpNewModemFaxRatesEncodingIndex=vncsVpNewModemFaxRatesEncodingIndex, vncsRowStatus=vncsRowStatus, vncsDPDnRowStatus=vncsDPDnRowStatus, vncsCallServerCapabilities=vncsCallServerCapabilities, vncsDPDnProvTable=vncsDPDnProvTable, vncsDPCompleteTranslations=vncsDPCompleteTranslations, vncsVpSilenceSuppression=vncsVpSilenceSuppression, vncsVpModemFaxRatesRateIndex=vncsVpModemFaxRatesRateIndex, vncsVpVoiceTrafficOptimization=vncsVpVoiceTrafficOptimization, vncsDPDnProvEntry=vncsDPDnProvEntry, vncsVpRowStatusEntry=vncsVpRowStatusEntry, vncsVpFaxIdleSuppressionG711G726=vncsVpFaxIdleSuppressionG711G726, vncsVpModemFaxEncodingChoiceEntry=vncsVpModemFaxEncodingChoiceEntry, vncsVpMaxModemBitRate=vncsVpMaxModemBitRate, vncsDPDnIndex=vncsDPDnIndex, vncsVpHoldingPriority=vncsVpHoldingPriority, vncsProvTable=vncsProvTable, vncsDPFailedTranslations=vncsDPFailedTranslations, vncsComponentName=vncsComponentName, vncsVpMinVoiceBitRate=vncsVpMinVoiceBitRate, vncsDPComponentName=vncsDPComponentName, vncsVpStorageType=vncsVpStorageType, vncsVpRowStatus=vncsVpRowStatus, vncsVpFrOpsTable=vncsVpFrOpsTable, vncsDPRowStatusTable=vncsDPRowStatusTable, vncsVpFrOpsEntry=vncsVpFrOpsEntry, vncsVpVoiceEncodingChoiceTable=vncsVpVoiceEncodingChoiceTable, vncsStatsEntry=vncsStatsEntry, vncsCallServerGroup=vncsCallServerGroup, vncsVpOptimization=vncsVpOptimization, vncsCallServerCapabilitiesBE01A=vncsCallServerCapabilitiesBE01A, vncsVpDataCallsAccepted=vncsVpDataCallsAccepted, vncsVpStatsTable=vncsVpStatsTable, vncs=vncs, vncsDPDnComponentName=vncsDPDnComponentName, vncsVpNewModemFaxRatesValue=vncsVpNewModemFaxRatesValue, vncsVpNewVoiceRatesValue=vncsVpNewVoiceRatesValue, vncsVpLCOpsEntry=vncsVpLCOpsEntry, vncsVpNewVoiceEncodingChoiceValue=vncsVpNewVoiceEncodingChoiceValue, vncsVpEmissionPriority=vncsVpEmissionPriority, vncsVpNewModemFaxEncodingChoiceEntry=vncsVpNewModemFaxEncodingChoiceEntry, vncsVpNewVoiceEncodingChoiceEntry=vncsVpNewVoiceEncodingChoiceEntry, vncsVpVoiceRatesEncodingIndex=vncsVpVoiceRatesEncodingIndex, vncsVpAudioGain=vncsVpAudioGain, vncsVpVoiceRatesValue=vncsVpVoiceRatesValue, vncsVpMaxVoiceBitRate=vncsVpMaxVoiceBitRate, vncsVpMinModemBitRate=vncsVpMinModemBitRate, vncsVpNewVoiceEncodingChoiceIndex=vncsVpNewVoiceEncodingChoiceIndex, vncsVpPermittedTrunkTypes=vncsVpPermittedTrunkTypes, vncsVpLCOpsTable=vncsVpLCOpsTable, vncsVp=vncsVp, vncsVpNewVoiceRatesEntry=vncsVpNewVoiceRatesEntry, vncsDPDnRowStatusTable=vncsDPDnRowStatusTable, vncsVpModemFaxEncodingChoiceIndex=vncsVpModemFaxEncodingChoiceIndex, vncsDPIndex=vncsDPIndex, vncsDPDnDestinationNodeId=vncsDPDnDestinationNodeId, vncsVpDiscardPriority=vncsVpDiscardPriority, vncsVpRequiredCustomerParm=vncsVpRequiredCustomerParm, vncsVpPathFailureAction=vncsVpPathFailureAction, vncsVpNewVoiceRatesRateIndex=vncsVpNewVoiceRatesRateIndex, vncsDPDnNumberingPlanIndicator=vncsDPDnNumberingPlanIndicator, vncsVpNewVoiceRatesTable=vncsVpNewVoiceRatesTable, vncsDP=vncsDP, vncsVpModemFaxEncodingChoiceTable=vncsVpModemFaxEncodingChoiceTable, vncsVpRequiredSecurity=vncsVpRequiredSecurity, vncsDPStatsTable=vncsDPStatsTable, vncsVpComponentName=vncsVpComponentName, vncsVpRequiredTrafficType=vncsVpRequiredTrafficType, vncsDPDnRowStatusEntry=vncsDPDnRowStatusEntry, vncsCallServerGroupBE=vncsCallServerGroupBE, vncsCallServerGroupBE01=vncsCallServerGroupBE01, vncsVpNewVoiceRatesEncodingIndex=vncsVpNewVoiceRatesEncodingIndex, vncsVpSetupPriority=vncsVpSetupPriority, vncsVpNewVoiceEncodingChoiceTable=vncsVpNewVoiceEncodingChoiceTable, vncsDPStatsEntry=vncsDPStatsEntry, vncsVpNewModemFaxRatesTable=vncsVpNewModemFaxRatesTable, vncsCallServerCapabilitiesBE01=vncsCallServerCapabilitiesBE01, vncsCallServerGroupBE01A=vncsCallServerGroupBE01A, vncsTotalTranslations=vncsTotalTranslations)

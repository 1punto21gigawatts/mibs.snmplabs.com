#
# PySNMP MIB module HP700RX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP700RX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:37:06 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, enterprises, Gauge32, Bits, Counter64, ModuleIdentity, ObjectIdentity, TimeTicks, IpAddress, Integer32, MibIdentifier, NotificationType, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "enterprises", "Gauge32", "Bits", "Counter64", "ModuleIdentity", "ObjectIdentity", "TimeTicks", "IpAddress", "Integer32", "MibIdentifier", "NotificationType", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
hp = MibIdentifier((1, 3, 6, 1, 4, 1, 11))
nm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3))
interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 4))
icmp = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 7))
snmp = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13))
trap = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 1))
snmpdConf = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 2))
netPeripherals = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9))
hpXStation = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3))
config = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1))
terminal = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1))
network = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2))
startup = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3))
statistics = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4))
preferences = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 5))
reset = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 6))
monitor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("a1097", 1), ("hp98754", 2), ("hp98789", 3), ("hpd1187", 4), ("hpa1497", 5), ("hp98753", 6), ("hp98785", 7), ("hpd1188", 8), ("hpd1195", 9), ("hpd1182", 10), ("hp98774", 11), ("hpd1195x1224", 12), ("hpd1195x640", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: monitor.setStatus('mandatory')
if mibBuilder.loadTexts: monitor.setDescription('The type of monitor the terminal is configured to drive. Each monitor type varies in resolution, refresh rate, color capability, dots per inch, and synchronization. Some monitors (especially multi-sync types) may produce usable displays at several settings. ')
monitorDescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: monitorDescription.setStatus('mandatory')
if mibBuilder.loadTexts: monitorDescription.setDescription('The resolution, refresh rate, color capability, dots per inch, and synchronization the terminal is sending to its monitor and the part number of the monitor that works best at these settings. ')
at2kbLEDControl = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("client", 1), ("local", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: at2kbLEDControl.setStatus('mandatory')
if mibBuilder.loadTexts: at2kbLEDControl.setDescription('Indicates whether the CAPS-LOCK LED on the keyboard (if present) is controlled by the X terminal or the clients (as X LED 3). ')
at2kbLanguage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("usascii", 1), ("danish", 2), ("french", 3), ("norwegian", 4), ("swissgerman", 5), ("candianfrench", 6), ("english", 7), ("finnish", 8), ("belgian", 9), ("spanish", 10), ("german", 11), ("swedish", 12), ("dutch", 13), ("italian", 14), ("candianenglish", 15), ("swissfrench", 16), ("hangul", 17), ("simplifiedchinese", 18), ("traditionalchinese", 19), ("kanji", 20), ("decLK401english", 21), ("reserved", 22)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: at2kbLanguage.setStatus('mandatory')
if mibBuilder.loadTexts: at2kbLanguage.setDescription('The language setting for an AT/2 keyboard attached to this terminal. ')
serialSpeed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("bps75", 1), ("bps150", 2), ("bps300", 3), ("bps600", 4), ("bps1200", 5), ("bps2400", 6), ("bps4800", 7), ("bps9600", 8), ("bps19200", 9), ("bps38400", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: serialSpeed.setDescription('The baud rate of the serial port.')
serialDataBits = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bits7", 1), ("bits8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: serialDataBits.setDescription('The number of data bits in each character sent and received over the serial port.')
serialStopBits = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bits1", 1), ("bits2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: serialStopBits.setDescription('The number of stop bits sent at the end of each character sent through the serial port.')
serialParity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("even", 2), ("odd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialParity.setStatus('mandatory')
if mibBuilder.loadTexts: serialParity.setDescription('The parity generated and checked on each character sent and received through the serial port.')
serialPacing = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("xonxoff", 2), ("rtscts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialPacing.setStatus('mandatory')
if mibBuilder.loadTexts: serialPacing.setDescription('The type of flow control used on the serial port.')
serialUse = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("primary", 2), ("auxiliary", 3), ("diagnostics", 4), ("serialsession", 5), ("slip", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialUse.setStatus('mandatory')
if mibBuilder.loadTexts: serialUse.setDescription("What the serial port is being used for. Note that primary and auxiliary use indicate that the serial port is 'connected' to TCP ports 9100 and 9101 respectively.")
parallelUse = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("primary", 2), ("auxiliary", 3), ("diagnostics", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: parallelUse.setStatus('mandatory')
if mibBuilder.loadTexts: parallelUse.setDescription("What the parallel port is being used for. Note that primary and auxiliary use indicate that the serial port is 'connected' to TCP ports 9100 and 9101 respectively.")
portuseEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portuseEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portuseEnable.setDescription('This variable indicates whether remote (through SNMP) serial port use changes are allowed.')
networkParamsFrom = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bootp", 1), ("eeprom", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: networkParamsFrom.setStatus('mandatory')
if mibBuilder.loadTexts: networkParamsFrom.setDescription('Indicates whether the X terminal will use bootp to get its network parameters (IP address, default gateway, boot file, terminal name, domain name, name server addresses, subnet mask, and remote configuration file) at power up or use those stored in EEPROM.')
configedAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configedAddress.setDescription('The IP address configured for the Ethernet interface on this terminal. The active value for this field is set at startup. After startup a different value can be saved to terminal memory without being used, therefore the value returned via SNMP is not necessarily the value currently in use. ')
configedSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configedSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: configedSubnetMask.setDescription('The subnet mask configured for the Ethernet interface on this terminal. The active value for this field is set at startup. After startup a different value can be saved to terminal memory without being used, therefore the value returned via SNMP is not necessarily the value currently in use. ')
configedRouteTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 4), )
if mibBuilder.loadTexts: configedRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: configedRouteTable.setDescription("The routes configured for this terminal. At startup the terminal tests the routes in its routing table. If any route fails, it will be discarded, therefore the configured routes may not be the routes in use. There are a number of ways a route can fail the startup tests, including: terminal can't ping the gateway, terminal can't resolve one of the names into an IP address, or a specified gateway is not on a connected subnet.")
routeTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 4, 1), ).setIndexNames((0, "HP700RX-MIB", "routeIndex"))
if mibBuilder.loadTexts: routeTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: routeTableEntry.setDescription('Each entry reflects one route.')
routeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: routeIndex.setDescription('The number of a row in the gateway table on the Network config screen.')
routeGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 4, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: routeGateway.setStatus('mandatory')
if mibBuilder.loadTexts: routeGateway.setDescription('The address of an intermediate machine to send packets to. Note that this is a string and may be either a dotted decimal IP address or a domain name.')
routeDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 4, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: routeDestination.setStatus('mandatory')
if mibBuilder.loadTexts: routeDestination.setDescription('The final destination address for this route. This may be a machine or a network. Note that this is a string and may be either a dotted decimal IP address or a domain name.')
primaryFileServer = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryFileServer.setStatus('mandatory')
if mibBuilder.loadTexts: primaryFileServer.setDescription('The address of the first file server the terminal attempts to contact at startup. This may be either a node name (in which case it will be resolved to an address using Domain Name Resolution) or it may be an IP address in dotted decimal form. ')
primaryAccessMethod = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tftp", 1), ("nfs", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryAccessMethod.setStatus('mandatory')
if mibBuilder.loadTexts: primaryAccessMethod.setDescription('The method used to read files from the primary file server. This method may be overridden for individual paths.')
alternateFileServer = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alternateFileServer.setStatus('mandatory')
if mibBuilder.loadTexts: alternateFileServer.setDescription('The address of the file server the terminal will attempt to contact at startup if the primary file server cannot be reached. This address may be the node name (in which case it will be resolved to an address before use using the Domain Name Resolution) or it may be the address in dotted decimal form. ')
alternateAccessMethod = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tftp", 1), ("nfs", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alternateAccessMethod.setStatus('mandatory')
if mibBuilder.loadTexts: alternateAccessMethod.setDescription('The method used to read files from the alternative file server. This method may be overridden for individual pathes.')
fileTimeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: fileTimeout.setDescription('The maximum time (in seconds) that the terminal will wait for a response to a request to the file server before giving up. The name resolver timeout is six times the file timeout. ')
primaryNameServer = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryNameServer.setStatus('mandatory')
if mibBuilder.loadTexts: primaryNameServer.setDescription("The primary name server's IP address in dotted decimal format.")
alternateNameServer = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alternateNameServer.setStatus('mandatory')
if mibBuilder.loadTexts: alternateNameServer.setDescription("The alternative name server's IP address in dotted decimal format. If no answer is received from the primary name server, the terminal attempts to contact this name server.")
domain = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: domain.setStatus('mandatory')
if mibBuilder.loadTexts: domain.setDescription("The fully qualified domain of the network to which the terminal is connected. This includes all parts following the first '.' (dot) in the fully qualified host name of the terminal. Typical examples are hp.com or waterloo.edu")
terminalName = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: terminalName.setStatus('mandatory')
if mibBuilder.loadTexts: terminalName.setDescription('The name assigned to this terminal. This name should correspond to the name assigned using the Domain Name service, Network Information Services, and other host address lookup mechanisms.')
slipLocalAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slipLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slipLocalAddress.setDescription('The address used for the terminal end of the SLIP connection.')
slipRemoteAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slipRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slipRemoteAddress.setDescription('The address used for the remote (host) end end of the SLIP connection.')
slipMask = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 2, 16), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slipMask.setStatus('mandatory')
if mibBuilder.loadTexts: slipMask.setDescription('The subnet mask configured for the SLIP interface on this terminal. ')
romFonts = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: romFonts.setStatus('mandatory')
if mibBuilder.loadTexts: romFonts.setDescription('Controls whether or not fonts are read from the ROM card (if present). ')
rgbFileFrom = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("rom", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rgbFileFrom.setStatus('mandatory')
if mibBuilder.loadTexts: rgbFileFrom.setDescription('Controls whether or not the rgb.txt file is read from the ROM card (if present). ')
bootFileFrom = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("rom", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootFileFrom.setStatus('mandatory')
if mibBuilder.loadTexts: bootFileFrom.setDescription('Controls whether or not the X server file is read from the ROM card (if present). ')
bootFileName = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootFileName.setStatus('mandatory')
if mibBuilder.loadTexts: bootFileName.setDescription('The name of the X server file to load. This may be a complete path (starting with /) and may include host and access method overrides.')
remoteConfigEnabled = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remoteConfigEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: remoteConfigEnabled.setDescription('Controls whether or not the remote config file is read from the file server at startup.')
remoteConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remoteConfigFile.setStatus('mandatory')
if mibBuilder.loadTexts: remoteConfigFile.setDescription('The name of the remote config file to load at startup. This may be a complete path (starting with /) and include host and access method overrides.')
xdmcpEnabled = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xdmcpEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: xdmcpEnabled.setDescription('Controls whether or not XDMCP is used to start user sessions on this terminal.')
xdmcpType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("broadcast", 1), ("direct", 2), ("indirect", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xdmcpType.setStatus('mandatory')
if mibBuilder.loadTexts: xdmcpType.setDescription('Controls the type of XDMCP request sent from the terminal at startup.')
xdmcpHost = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xdmcpHost.setStatus('mandatory')
if mibBuilder.loadTexts: xdmcpHost.setDescription('The address of the host to which the terminal sends XDMCP requests at startup. This field is ignored if XDMCP type is BROADCAST.')
telnetAutoStart = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetAutoStart.setStatus('mandatory')
if mibBuilder.loadTexts: telnetAutoStart.setDescription('Determines whether a TELNET session is auto- started at boot time. TELNET can be used to start a user session, but TELNET cannot be used if XDMCP is enabled.')
telnetCharSet = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("usascii", 1), ("isoLatin1", 2), ("hpRoman8", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetCharSet.setStatus('mandatory')
if mibBuilder.loadTexts: telnetCharSet.setDescription('Controls the character set used to display characters in the TELNET and serial terminal sessions. ')
telnetHost = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetHost.setStatus('mandatory')
if mibBuilder.loadTexts: telnetHost.setDescription('The address of the host to attempt to connect to when TELNET is (auto)started. This may be a name or IP address in dotted decimal format.')
fontPathTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 13), )
if mibBuilder.loadTexts: fontPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: fontPathTable.setDescription('A list of directory paths used when by the X server when searching for fonts')
fontEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 13, 1), ).setIndexNames((0, "HP700RX-MIB", "fontIndex"))
if mibBuilder.loadTexts: fontEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fontEntry.setDescription('An single path to a set of font files.')
fontIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fontIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fontIndex.setDescription('The index into the list of font paths.')
fontPath = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 3, 13, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fontPath.setStatus('mandatory')
if mibBuilder.loadTexts: fontPath.setDescription('The actual font path in the format appropriate to the operating system in use.')
memInstalled = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: memInstalled.setDescription('The amount of memory installed in the terminal (excluding video memory) in Kbytes.')
memFree = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memFree.setStatus('mandatory')
if mibBuilder.loadTexts: memFree.setDescription('The amount of memory in the free pool (including free video memory). This is the total amount of memory that is not currently in use in the terminal.')
memLowMark = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memLowMark.setStatus('mandatory')
if mibBuilder.loadTexts: memLowMark.setDescription('The size of the free pool at its smallest since the last time this counter was reset.')
memFrags = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memFrags.setStatus('mandatory')
if mibBuilder.loadTexts: memFrags.setDescription('The number of fragments (of all sizes) in the memory free pool.')
memLargestFrag = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memLargestFrag.setStatus('mandatory')
if mibBuilder.loadTexts: memLargestFrag.setDescription('The size of the largest fragment in the free pool in Kbytes. This represents the largest request for memory that can be fulfilled by the terminal.')
memBackingstore = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memBackingstore.setStatus('mandatory')
if mibBuilder.loadTexts: memBackingstore.setDescription('The amount of memory used for backingstore in Kbytes.')
memReclaims = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memReclaims.setStatus('mandatory')
if mibBuilder.loadTexts: memReclaims.setDescription('The number of times memory has been reclaimed from backing store for other uses.')
serialInOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: serialInOctets.setDescription('The number of octets received through the serial port since the last time this counter was reset.')
serialOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: serialOutOctets.setDescription('The number of octets sent out the serial port since The last time this counter was reset.')
serialInErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: serialInErrors.setDescription('The number of errors detected on data received in the serial port.')
parallelOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parallelOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: parallelOutOctets.setDescription('The number of octets sent out the parallel port since the last time this counter was reset.')
parallelErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: parallelErrors.setStatus('mandatory')
if mibBuilder.loadTexts: parallelErrors.setDescription('The number of errors detected in sending data out the parallel port since the last time this counter was reset.')
etherInPackets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherInPackets.setStatus('mandatory')
if mibBuilder.loadTexts: etherInPackets.setDescription('The number of packets received over Ethernet.')
etherInCRCErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherInCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: etherInCRCErrors.setDescription('The number of CRC errors detected in Ethernet packets.')
etherInNoBuffers = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherInNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: etherInNoBuffers.setDescription('The number of time the Ethernet interface hardware could not receive packets because no buffers were available.')
etherInRunts = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherInRunts.setStatus('mandatory')
if mibBuilder.loadTexts: etherInRunts.setDescription('The number of packets received on the Ethernet interface that were shorter then the shortest permitted packet.')
etherInOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: etherInOctets.setDescription('The number of octets received on the Ethernet interface.')
etherOutPackets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherOutPackets.setStatus('mandatory')
if mibBuilder.loadTexts: etherOutPackets.setDescription('The number of packets sent out the Ethernet interface.')
etherOutOneCollisions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherOutOneCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: etherOutOneCollisions.setDescription('The number of times the Ethernet interface had to back off once due to a collision.')
etherOutTwoCollisions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherOutTwoCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: etherOutTwoCollisions.setDescription('The number of times the Ethernet interface had to back off twice due to collisions.')
etherOutMoreCollisions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherOutMoreCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: etherOutMoreCollisions.setDescription('The number of messages for which the Ethernet interface had to back off more then twice (but less then the maximum number of times) due to collisions.')
etherOutMaxCollisions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherOutMaxCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: etherOutMaxCollisions.setDescription('The number of times that the Ethernet interface was unable to transmit a packet due to too many collisions.')
etherOutNoBuffers = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherOutNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: etherOutNoBuffers.setDescription('The number of times that the Ethernet interface software had to drop an outbound packet because there were no more interface transmit buffers.')
etherOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: etherOutOctets.setDescription('The number of octets sent out the Ethernet interface.')
tftpTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: tftpTimeouts.setDescription('The number of times that the tftp driver has not gotten a response within the file timeout period. This is not the number of retransmits performed by the tftp driver but is the number of completely failed requests.')
statsTime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 26), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsTime.setStatus('mandatory')
if mibBuilder.loadTexts: statsTime.setDescription('The statistics information can be cleared (to zero) by depressing a button on the statistics screen. This variable indicates the time since this was last done. It is the amount of time over which statistics have been collected.')
slipInPackets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipInPackets.setStatus('mandatory')
if mibBuilder.loadTexts: slipInPackets.setDescription('The number of packets received over the serial interface while running SLIP.')
slipInOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: slipInOctets.setDescription('The number of octets received over the serial interface while running SLIP.')
slipInErrs = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: slipInErrs.setDescription('The number of errors encountered on received octets on the serial interface while running SLIP.')
slipOutPackets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipOutPackets.setStatus('mandatory')
if mibBuilder.loadTexts: slipOutPackets.setDescription('The number of packets transmitted over the serial interface while running SLIP.')
slipOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: slipOutOctets.setDescription('The number of octets transmitted over the serial interface while running SLIP.')
slipOutErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slipOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: slipOutErrors.setDescription('The number of errors encountered while transmitting over the serial interface while running SLIP.')
etherInAlignErrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherInAlignErrors.setStatus('mandatory')
if mibBuilder.loadTexts: etherInAlignErrors.setDescription('The number of packets received on the Ethernet interface that were not an integral number of octets in length.')
etherInCollisions = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 4, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherInCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: etherInCollisions.setDescription('The number of collisions detected on the Ethernet interface that were after the start of the normal packet.')
clientAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: clientAuthentication.setDescription('Controls whether MIT-MAGIC-COOKIE authentication is used by the server during client connection. If enabled, the client must pass a valid MAGIC_COOKIE to the server during the connection sequence. This feature can only be used with XDMCP enabled.')
accessControls = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessControls.setStatus('mandatory')
if mibBuilder.loadTexts: accessControls.setDescription("This determines whether host access controls are used by the server during client connection. If enabled, only those clients running on hosts listed in the terminal's access control file will be allowed to connect to the X server. This file is read from the host using the path /usr/tftpdir/usr/lib/X11/700X/etc/ipaddress.hosts.")
r3BugCompatability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: r3BugCompatability.setStatus('mandatory')
if mibBuilder.loadTexts: r3BugCompatability.setDescription('This determines whether the server behaves like an X11R3 server for certain specific operations.')
resetEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resetEnable.setStatus('mandatory')
if mibBuilder.loadTexts: resetEnable.setDescription('This variable indicates whether remote (through SNMP) resets are allowed.')
reboot = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 3, 1, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("dont", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reboot.setStatus('mandatory')
if mibBuilder.loadTexts: reboot.setDescription('Setting this variable to zero will cause the X terminal to reset.')
mibBuilder.exportSymbols("HP700RX-MIB", etherOutNoBuffers=etherOutNoBuffers, fontPath=fontPath, memFree=memFree, serialInOctets=serialInOctets, fontIndex=fontIndex, telnetHost=telnetHost, terminalName=terminalName, etherOutMoreCollisions=etherOutMoreCollisions, alternateFileServer=alternateFileServer, alternateNameServer=alternateNameServer, parallelUse=parallelUse, networkParamsFrom=networkParamsFrom, serialParity=serialParity, serialPacing=serialPacing, romFonts=romFonts, interface=interface, parallelErrors=parallelErrors, r3BugCompatability=r3BugCompatability, slipMask=slipMask, terminal=terminal, memBackingstore=memBackingstore, slipOutOctets=slipOutOctets, monitor=monitor, serialOutOctets=serialOutOctets, memLargestFrag=memLargestFrag, serialSpeed=serialSpeed, fileTimeout=fileTimeout, remoteConfigFile=remoteConfigFile, etherInPackets=etherInPackets, slipInOctets=slipInOctets, hpXStation=hpXStation, etherOutOneCollisions=etherOutOneCollisions, etherInNoBuffers=etherInNoBuffers, statistics=statistics, clientAuthentication=clientAuthentication, xdmcpType=xdmcpType, network=network, telnetCharSet=telnetCharSet, system=system, etherOutMaxCollisions=etherOutMaxCollisions, primaryAccessMethod=primaryAccessMethod, tftpTimeouts=tftpTimeouts, memInstalled=memInstalled, slipInErrs=slipInErrs, at2kbLanguage=at2kbLanguage, bootFileName=bootFileName, alternateAccessMethod=alternateAccessMethod, config=config, slipLocalAddress=slipLocalAddress, etherOutTwoCollisions=etherOutTwoCollisions, domain=domain, configedSubnetMask=configedSubnetMask, routeGateway=routeGateway, slipOutPackets=slipOutPackets, fontPathTable=fontPathTable, portuseEnable=portuseEnable, primaryFileServer=primaryFileServer, etherInAlignErrors=etherInAlignErrors, routeDestination=routeDestination, at2kbLEDControl=at2kbLEDControl, etherInOctets=etherInOctets, nm=nm, statsTime=statsTime, parallelOutOctets=parallelOutOctets, trap=trap, hp=hp, etherInCRCErrors=etherInCRCErrors, resetEnable=resetEnable, accessControls=accessControls, preferences=preferences, slipRemoteAddress=slipRemoteAddress, serialStopBits=serialStopBits, primaryNameServer=primaryNameServer, etherOutPackets=etherOutPackets, netPeripherals=netPeripherals, configedAddress=configedAddress, etherOutOctets=etherOutOctets, remoteConfigEnabled=remoteConfigEnabled, monitorDescription=monitorDescription, slipOutErrors=slipOutErrors, routeIndex=routeIndex, xdmcpHost=xdmcpHost, icmp=icmp, rgbFileFrom=rgbFileFrom, fontEntry=fontEntry, configedRouteTable=configedRouteTable, memReclaims=memReclaims, reboot=reboot, reset=reset, snmpdConf=snmpdConf, etherInRunts=etherInRunts, bootFileFrom=bootFileFrom, startup=startup, serialDataBits=serialDataBits, memFrags=memFrags, serialInErrors=serialInErrors, xdmcpEnabled=xdmcpEnabled, serialUse=serialUse, snmp=snmp, etherInCollisions=etherInCollisions, memLowMark=memLowMark, telnetAutoStart=telnetAutoStart, slipInPackets=slipInPackets, routeTableEntry=routeTableEntry)

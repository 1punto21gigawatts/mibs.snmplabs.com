#
# PySNMP MIB module STAND-ALONE-ETHERNET-SWITCH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/STAND-ALONE-ETHERNET-SWITCH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:10:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
Timeout, = mibBuilder.importSymbols("BRIDGE-MIB", "Timeout")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Counter64, ObjectIdentity, TimeTicks, iso, NotificationType, enterprises, Counter32, MibIdentifier, Integer32, Unsigned32, Gauge32, Bits, NotificationType, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Counter64", "ObjectIdentity", "TimeTicks", "iso", "NotificationType", "enterprises", "Counter32", "MibIdentifier", "Integer32", "Unsigned32", "Gauge32", "Bits", "NotificationType", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
grandjunction = MibIdentifier((1, 3, 6, 1, 4, 1, 437))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1))
fastLink = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1))
seriesG2xx = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 2))
series2000 = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3))
sysInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1))
sysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2))
port = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3))
netMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4))
upgrade = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5))
vlan = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6))
bandwidthUsage = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7))
bridgeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8))
esModuleBasic = MibIdentifier((1, 3, 6, 1, 4, 1, 437, 1, 1, 2, 1))
sysInfoFwdEngineRevision = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoFwdEngineRevision.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoFwdEngineRevision.setDescription('Returns the revision number of the forwarding engine ASIC.')
sysInfoBoardRevision = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoBoardRevision.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoBoardRevision.setDescription('Returns the revision number of the switch main board on which the system firmware resides.')
sysInfoTotalNumberOfPorts = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoTotalNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoTotalNumberOfPorts.setDescription('The total number of physical network ports. fixed configuration - 27, 15 or 14 ports modular configuration - 25 - 41 ports This object does NOT represent the upper bound of indices into port tables. See sysInfoNumberOfSwitchPorts and sysInfoNumberOfSharedPorts for that purpose.')
sysInfoNumberOfSwitchPorts = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoNumberOfSwitchPorts.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoNumberOfSwitchPorts.setDescription('The number of ports that are individually switched. - 27, 15 or 14 switched ports. Each of these ports has hardware support for a full range of statistics and management controls. This object represents the upper bound of indices into the various port tables in the port group.')
sysInfoNumberOfSharedPorts = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoNumberOfSharedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoNumberOfSharedPorts.setDescription('The number of ports that are collectively switched. fixed configuration - 0 ports modular configuration - 0 to 16 ports Hardware supported statistics are available for these ports as a whole. Management controls are limited to enabling and disabling of the port.')
sysInfoNumberOfInstalledModules = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoNumberOfInstalledModules.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoNumberOfInstalledModules.setDescription('The number of high speed switched ports with installed and recognized modules. Hardware supported statistics are available for installed modules. For repeater group modules, statistics are supported for the group as a whole, relative to the interface between the group and the switching engine. Management controls for an individual repeater port on a module are limited to enabling and disabling the port.')
sysInfoBuffersUsed = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoBuffersUsed.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoBuffersUsed.setDescription('The high-water mark of frame buffer usage in this switch. The initial value upon system reset is zero.')
sysInfoMaxBuffers = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoMaxBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoMaxBuffers.setDescription('Number of times sysBuffersUsed has reached its maximum value and been reset to zero by the switch. The initial value is zero.')
sysInfoUtilDisplay = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoUtilDisplay.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoUtilDisplay.setDescription('The number of utilization meter LEDs currently lit on the front panel.')
sysInfoAddrCapacity = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoAddrCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoAddrCapacity.setDescription('The system-wide maximum number of addresses supported. This address capacity includes both dynamic and static address types.')
sysInfoRestrictedStaticAddrCapacity = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoRestrictedStaticAddrCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoRestrictedStaticAddrCapacity.setDescription('The system-wide maximum number of restricted static addresses supported. This object is a subset of sysInfoAddrCapacity.')
sysInfoPOSTResult = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoPOSTResult.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoPOSTResult.setDescription('A value which indicates the failures of some particular Power On Self Test (POST). The value is a sum. This sum initially takes the value zero, Then, for each POST test, T, in the range 1 through 16, that fails, 2 raised to (T - 1) is added to the sum. The defined POST tests are: T POST Test --- --------- 1 ports 2 station address PROM 3 CAM 4 RS-232 port 5 real time clock 6 CAM SRAM 7 system timer interrupt 8 port control/status 9 Flag DRAM or ISLT ASIC 10 Packet DRAM 11 forwarding engine 12 forwarding engine 13 non-volatile RAM 14 SRAM 15 EPROM 16 ECU DRAM')
sysInfoPortFailedPOSTMap = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoPortFailedPOSTMap.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoPortFailedPOSTMap.setDescription("A bit array where the presence of a particular bit indicates a failure of a particular port, as determined by the POST 'individual ports' test. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the switch is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'.")
sysInfoPortLinkDisplayMap = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoPortLinkDisplayMap.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoPortLinkDisplayMap.setDescription("A bit array where the presence of a particular bit indicates a lit link LED for a port. Each octet within the value of this object specifies a set of eight link LEDs, with the first octet specifying link LEDs for ports 1 through 8, the second octet specifying link LEDs 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered LED, and the least significant bit represents the highest numbered LED. Thus, each LED is represented by a single bit within the value of this object. If that bit has a value of '1' then that LED is currently lit; the LED is not lit if its bit has a value of '0'.")
sysInfoPortDisabledDisplayMap = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoPortDisabledDisplayMap.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoPortDisabledDisplayMap.setDescription("A bit array where the presence of a particular bit indicates a lit disabled LED for a port. Each octet within the value of this object specifies a set of eight disabled LEDs, with the first octet specifying disabled LEDs for ports 1 through 8, the second octet specifying disabled LEDs 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered LED, and the least significant bit represents the highest numbered LED. Thus, each LED is represented by a single bit within the value of this object. If that bit has a value of '1' then that LED is currently lit; the LED is not lit if its bit has a value of '0'.")
sysInfoBroadcastStormLastTime = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 16), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoBroadcastStormLastTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoBroadcastStormLastTime.setDescription('The last time a port exceeded broadcast threshold. This object is only valid if broadcast storm control is enabled at least once since system start up. The port where the event occurred is identified by sysInfoPortExceedBroadcastStorm.')
sysInfoPortExceedBroadcastStorm = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 27))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoPortExceedBroadcastStorm.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoPortExceedBroadcastStorm.setDescription('The port where the broadcast threshold was last exceeded, if Broadcast Storm Control was enabled. The time when the event occurred is identified by sysInfoBroadcastStormLastTime. The default value is 0.')
sysInfoRedundantPowerState = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("healthy", 2), ("faulty", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoRedundantPowerState.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoRedundantPowerState.setDescription('Indicates the state of the redundant power supply. off : the switch is not connected to a redundant power source. healthy : a redundant power source is connected to the switch and the power source is operating correctly. faulty : a redundant power source is connected to the switch but a failure exists in the power system.')
sysInfoInternalPowerState = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoInternalPowerState.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoInternalPowerState.setDescription('Indicates the state of the internal power supply. off : the internal power supply is off. on : the internal power supply is on.')
sysInfoConfigFileStatus = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoConfigFileStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoConfigFileStatus.setDescription('The status of current or last succesful configuration download since the switch was initialized. The status contains the file name and host the last successful configuration download was executed. Note that a successful download does not mean all commands in the configuration files were executed successfully.')
sysInfoImageCapability = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("enterprise", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysInfoImageCapability.setStatus('mandatory')
if mibBuilder.loadTexts: sysInfoImageCapability.setDescription('The software image capability supported.')
sysConfigReset = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigReset.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigReset.setDescription('Setting this object to reset(2) causes a complete reset of both hardware and software, but does not run the POST (Power On Self Test). All parameters including all static addresses will be retained. Setting this object to noReset(1) has no effect. The switch always returns the value noReset(1) when this object is read.')
sysConfigDefaultReset = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigDefaultReset.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigDefaultReset.setDescription('Setting this object to reset(2) causes a complete reset of both hardware and software, but does not run the POST (Power On Self Test). All configuration parameters will revert to their factory default settings, and all addresses assigned will be removed. Setting this object to noReset(1) has no effect. The switch always returns the value noReset(1) when this object is read.')
sysConfigClearPortStats = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noClear", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigClearPortStats.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigClearPortStats.setDescription('Setting this object to noClear(1) results in no action. When set to clear(2), the switch will reset all port statistics to zero. Port statistics are kept in the switchPortTable, the switchPortTxStatTable, the switchPortRxStatTable, and the switchPortTxCollTable. This object always returns noClear(1) when read.')
sysConfigAddressViolationAction = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("suspend", 1), ("disable", 2), ("ignore", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigAddressViolationAction.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigAddressViolationAction.setDescription('Indicates what action to take when an address violation (an address mismatch or duplication) occurs on a secured port. The default action is to suspend(1) the port. suspend : port is suspended until the correct address is again received. While suspended, port will not forward frames it receives, nor will it accept frames to be forwarded. disable : port is disabled and will not forward any frames as in the case of suspension above. Port can only be reenabled by an explicit management action on the part of the user. ignore : do nothing to the port (simply discard the offending address).')
sysConfigAddressViolationAlert = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigAddressViolationAlert.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigAddressViolationAlert.setDescription('When set to enabled(1), the switch will generate an addressViolation trap upon detecting an address violation on a secured port. When set to disabled(2), no such trap will be issued for address violation on secure ports. The default is enabled(1).')
sysConfigSwitchingMode = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("store-and-forward", 1), ("fragmentFree", 2), ("fastForward", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigSwitchingMode.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigSwitchingMode.setDescription('The switch can operate as a high speed cut-through switch, or as a traditional store-and-forward switch. Cut-through switching of frames is enabled when this object is set to fastForward(3) or fragmentFree(2). This works to reduce buffering latency by attempting to forward a frame before reception is completed. Switches operating with firmware versions greater than or equal to 6.00 support only fragmentFree(2) and sotre-and-forward(1). Broadcast frames are always switched using the store-and-forward(1) method. Multicast frame switching may be forced to the store-and-forward(1) mode using the object sysConfigMulticastStoreAndForward. The switching of any types of frame automatically reverts to the store-and-forward(1) method whenever the switch is configured to monitor frames internally (see the object sysConfigMonitorPort). The default value for this object for firmware version greater than or equal to 6.00 is fragmentFree(2). The default value for this object for firmware version less than 6.00 is fastForward(3). store-and-forward: entire frame is buffered before it is forwarded to the appropriate destination. fragmentFree : forward the frame to the appropriate destination after 64 bytes plus preamble have been received. fastForward : minimize latency by making the forwarding decision as soon as possible during frame reception (after 6 bytes plus preamble).')
sysConfigMulticastStoreAndForward = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigMulticastStoreAndForward.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigMulticastStoreAndForward.setDescription('When set to enabled(1), the switching of multicast frames will use the store-and-forward method, regardless of the setting of sysConfigSwitchingMode. When set to disabled(2), multicast frames will be switched according to the current setting of sysConfigSwitchingMode. The switching of any types of frame automatically reverts to the store-and-forward method whenever the switch is configured to monitor frames internally (see the object sysConfigMonitorPort). The default value for this object is disabled(1).')
sysConfigMonitor = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigMonitor.setDescription('Selects whether frames to/from certain ports are sent to sysConfigMonitorPort. A port is selected for monitoring purpose when its portMonitoring object is set to enabled. The default value is disabled(2).')
sysConfigMonitorPort = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigMonitorPort.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigMonitorPort.setDescription('Port number to which all frames to/from monitored ports are sent. Frames are only monitored if the sysConfigMonitor object is set to enabled(1). A number from 1 to 27 selects a switch port. The number 26 selects fast Ethernet port F1 (called port A on the modular switches), 27 selects fast Ethernet port F2 (port B on the modular switches). The number 31 selects no monitor port. The default value is 31.')
sysConfigHigherProtocolMonitor = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigHigherProtocolMonitor.setStatus('obsolete')
if mibBuilder.loadTexts: sysConfigHigherProtocolMonitor.setDescription('Selects whether frames addressed to and from the higher- layer protocol processor of the switch are to be monitored. The higher-layer protocol processor is the entity that responds to all SNMP/TFTP/XNSEcho management requests. The default value is disabled(2).')
sysConfigPort25Connector = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("self-sensing", 1), ("rj45", 2), ("aui", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigPort25Connector.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigPort25Connector.setDescription('Specify which of the two connector types is providing active connection on port 25. Setting the connector to self-sensing allows the switch to learn the active connector for port 25 on its own. The other two possible values force the switch to use the chosen type. The default value is self-sensing(1). rj45: 10BaseT RJ45 connector aui : 10Base5 thick-wire connector.')
sysConfigHeuristics = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigHeuristics.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigHeuristics.setDescription('A value which enables special heuristic functions. The value is a sum. This sum initially takes the value zero, Then, for each heuristic function, H, in the range 1 through 32, that is enabled, 2 raised to (H - 1) is added to the sum. The heuristic functions are: H Heuristic Function --- ------------------ 1 system reset when an invalid buffer is detected 2 system reset when free and transmit lists are mixed 3 system reset when the buffer counter overflows 4 system reset when the frame status overflows 5 system reset when queue head passes tail 6 system reset when the self-monitor loopback fails 7 system reset when the port status interface hangs 8 system reset when the LED interface hangs 9 system reset when the buffer interface hangs 10 system reset when the frame DRAM interface hangs 11 system reset when invalid hardware activities are detected 12 reserved (must be zero) 13 reserved (must be zero) 14 reserved (must be zero) 15 reserved (must be zero) 16 reserved (must be zero) 17 reserved (must be zero) 18 reserved (must be zero) 19 size of transmit queue is 1.5K. 20 reserved (must be zero) 21 reserved (must be zero) 22 reserved (must be zero) 23 unfreeze LEDs upon a POST failure 24 reserved (must be zero) 25 reserved (must be zero) 26 reserved (must be zero) 27 reserved (must be zero) 28 reserved (must be zero) 29 reserved (must be zero) 30 reserved (must be zero) 31 reserved (must be zero) 32 reserved (must be zero)')
sysConfigEnableSTP = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigEnableSTP.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigEnableSTP.setDescription('The switch implements the 802.1d Spanning Tree Algorithm & Protocol (STP) on all its port to detect loops in the bridge topology. The user may, for any reason, elect to disable the execution of STP, by setting this object to disabled(2). When STP is disabled(2), all ports currently in suspended-stp status will immediately transition to enabled status, and frame forwarding will resume. When STP is enabled(1), Suspended-stp ports will transition to enabled according to the STP. This object is not supported by firmware versions greater than or equal to 6.00. The default value is enabled(1).')
sysConfigStrictSTPTransition = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigStrictSTPTransition.setStatus('deprecated')
if mibBuilder.loadTexts: sysConfigStrictSTPTransition.setDescription('The 802.1d Spanning Tree Protocol dictates that a port must start out in the blocking state and transition through two other intermediate states (listening and learning), before it can begin forwarding frames. These state transitions help prevent temporary loops in the bridge topology. The switch implements a special algorithm where a singly-addressed port may move to the forwarding state as soon as it regains a previously lost linkbeat, or when it is enabled after having been suspended for address violation. This does not comply with the 802.1d STP in the strictest sense. To force compliance, this object may be set to enabled(1). The default value is disabled(2).')
sysConfigBroadcastStormAction = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("block", 1), ("ignore", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigBroadcastStormAction.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigBroadcastStormAction.setDescription('Indicates what action to take when broadcast threshold is exceeded at a port. block : broadcast packets received from the port are discarded until the broadcast rate drops below the re-enable threshold. ignore : do nothing to the port. The default value is ignore(2).')
sysConfigBroadcastStormAlert = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigBroadcastStormAlert.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigBroadcastStormAlert.setDescription('When set to enabled(1), the switch will generate a broadcastStormTrap upon detecting that a port is receiving broadcast packets at a rate higher than the specified broadcast threshold, if sysConfigBroadcastStormControl is enabled. Note: after the initial trap, additional traps will not be generated for a blocked port while the blocked port received broadcast packets greater than the specified sysConfigBroadcastLowerThreshold value. When set to disabled(2), no such trap will be issued. The default value is disabled(2).')
sysConfigBroadcastThreshold = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 14400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigBroadcastThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigBroadcastThreshold.setDescription('This object allows user to set the upper limit for Broadcast storm control function. The broadcast rate is the number of broadcast packets received from a port in a second. If sysConfigBroadcastStormControl is set to enabled and sysConfigBroadcastStormAction is set to block, the switch stops forwarding broadcast packets received from a port when the number of broadcast packets received from the port in a second exceeds the threshold. The default value is 500.')
sysConfigBroadcastReEnableThreshold = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 14400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigBroadcastReEnableThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigBroadcastReEnableThreshold.setDescription('This object allows user to set the re-enable threshold for Broadcast Storm Control function. Once a port has been blocked, the number of broadcast packets received per second from the port must drop below this threshold before broadcast packet forwarding for the port is automatically re-enabled. This threshold is relevant only if the user has chosen to block broadcast packet forwarding to control broadcast storms. The default value is 250.')
sysConfig10MbpsEnhancedCongestionControl = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("adaptive", 1), ("disabled", 2), ("moderate-aggressive", 3), ("aggressive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfig10MbpsEnhancedCongestionControl.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfig10MbpsEnhancedCongestionControl.setDescription('Enhanced Congestion Control (ECC) reduces the transmit back-off period to allow the port to transmit more quickly, thereby reducing the transmit queue congestion on the port. When set to disabled(2), ECC is disabled. When set to adaptive(1), ECC is enabled when the ports transmit queue is full. Set to moderate-aggressive(3) to enable ECC with a back-off period that is divided by a factor of 32. Set to aggressive(4) to enable ECC with a back-off period that is divided by a factor of 1024. This object controls the setting on all 10Mbps ports of the switch. The default value is disabled(1).')
sysConfigNetworkPort = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 27))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigNetworkPort.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigNetworkPort.setDescription('If a network port is configured, all unknown unicast packets are sent only to the network port. Only one port in the switch can be selected as the network port. The number 0 selects no network port. The default value is 0.')
sysConfigHalfDuplexBackPressure = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigHalfDuplexBackPressure.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigHalfDuplexBackPressure.setDescription('Back-pressure allows a port to force a collision when there are no buffers to receive frames. Because collision is only meaningful on a port operating in half-duplex, back-pressure enhancement does not apply to full-duplex ports. When set to enabled(1), buffer starvation causes the switch to force collisions when receiving frames on (half-duplex) ports. This, in turn, signals network nodes that are connected to these ports to retransmit their frames. It is expected that this transit delay enables the switch to free up buffers to successfully receive the frames. When set to disabled(2), the switch does not apply back- pressure when there is buffer starvation. The default value is disabled(2).')
sysConfigFastEthcParmsPort = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(26, 27))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigFastEthcParmsPort.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigFastEthcParmsPort.setDescription('The parameters of port to use for Fast EtherChannel. Defaults to 26. When Fast EtherChannel is enabled, the following object values parameters are configured to the same values for ports 26, 27, and the Fast EtherChannel: Non-trunks: swPortFloodUnregisteredMulticasts swPortFloodUnknownUnicasts swPortEnhancedCongestionControl vmVlan in CISCO-VLAN-MEMBERSHIP-MIB dot1dStpPortPathCost in BRIDGE-MIB dot1dStpPortPriority in BRIDGE-MIB Trunks: swPortFloodUnregisteredMulticasts swPortFloodUnknownUnicasts swPortEnhancedCongestionControl swPortBridgePriority swPortBridgePriorityAlternate swPortBridgePathCost swPortBridgePathCostAlternate vlanTrunkPortDynamicState in CISCO-VTP-MIB vmTrunkPortVlansEnabled in CISCO-VTP-MIB vmTrunkPortVlansPruningEligible in CISCO-VTP-MIB dot1dStpPortPathCost value of a vlan in CISCO-VLAN-MEMBERSHIP-MIB dot1dStpPortPriority value of a vlan in CISCO-VLAN-MEMBERSHIP-MIB')
sysConfigTftpServerName = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigTftpServerName.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigTftpServerName.setDescription('The TFTP server host name or IP address. The value of this object is the same as upgradeTFTPServerName object.')
sysConfigConfigFileAuto = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigConfigFileAuto.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigConfigFileAuto.setDescription('Selects whether the system should attempt to retrieve the configuration file on system power-up. When enabled, the system will attempt to retrieve <sysName value>-confg, <sysName value>.cfg, switch-confg, or ciscosw.cfg files in the order listed using TFTP. The TFTP requests will be sent to the host specified by sysConfigTFTPServerName if configured. Otherwise, the request is sent IP broadcast address 255.255.255.255. The first file successfully retrieved will be used. If disabled, the configuration file can still be retrieved if specified to do so in the DHCP response. The default value is disabled(2).')
sysConfigPortGroupingMode = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 2, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bridge-group", 1), ("vlan", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysConfigPortGroupingMode.setStatus('mandatory')
if mibBuilder.loadTexts: sysConfigPortGroupingMode.setDescription('When set to bridge-groups (1), the switch allows ports to be assigned to bridge groups. Bridge Group configuration is local to the switch; virtual LANs span across the network. In the bridge-group mode, virtual LAN configuration is disabled. When set to vlan(2), the switch allows ports to be assigned to one or more virtual LANs. Bridge group configuration is disabled. The switch is reset when the value of this object is modified. The default value is vlan(2)')
switchPortTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1), )
if mibBuilder.loadTexts: switchPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortTable.setDescription('A list of configuration entries for individually switched ports.')
swPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "swPortIndex"))
if mibBuilder.loadTexts: swPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swPortEntry.setDescription('Configuration parameters for an individually switched port.')
swPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortIndex.setDescription('Number greater than zero identifying an individually switched port. The same value of a port index variable for any of the port tables in this MIB group selects the same port.')
swPortControllerRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortControllerRevision.setStatus('mandatory')
if mibBuilder.loadTexts: swPortControllerRevision.setDescription('Returns the revision number of the port controller.')
swPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortName.setStatus('mandatory')
if mibBuilder.loadTexts: swPortName.setDescription('A descriptive string of up to 60 characters used by the network administrator to name a port.')
swPortMediaCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("private-ethernet", 2), ("general-ethernet", 3), ("general-fast-ethernet", 4), ("private-fast-ethernet", 5), ("repeated-fast-ethernet", 6), ("fddi", 7), ("atm", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortMediaCapability.setStatus('mandatory')
if mibBuilder.loadTexts: swPortMediaCapability.setDescription('The port media capability is one of: other : none of the following private-ethernet : dedicated 10 Mbps Ethernet port general-ethernet : non-dedicated 10 Mbps Ethernet port general-fast-ethernet: non-dedicated 100 Mbps Ethernet port private-fast-ethernet: dedicated 100 Mbps Ethernet port repeated-fast-ethernet: repeated 100 Mbps Ethernet port fddi : FDDI module atm : ATM module')
swPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("network", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortType.setStatus('mandatory')
if mibBuilder.loadTexts: swPortType.setDescription('Identifies whether the port is other : none of the following network : port does not have address number restriction while it is unsecured. A secured Network port has an imposed limit on the maximum number of addresses it can have. See the object object swPortAddressTableSize for this upper maximum value.')
swPortConnectorType = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("rj45", 2), ("bnc", 3), ("aui", 4), ("fiber-sc", 5), ("fiber-st", 6), ("empty", 7), ("group", 8), ("fddi-mic", 10), ("fiber-mtrj", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: swPortConnectorType.setDescription('The type of connector the port is currently using. It is one of other : none of the following (unknown) rj45 : common unshielded twisted pair connector bnc : thin-coax (BNC) aui : thick-coax (AUI) fiber-sc : fiber SC connector fiber-st : fiber ST connector empty : the port is not installed group : the switch port contains a group of connectors fddi-mic : FDDI fiber optic connector fiber-mtrj : fiber MT-RJ connector.')
swPortACR = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortACR.setStatus('deprecated')
if mibBuilder.loadTexts: swPortACR.setDescription('Selects whether Accelerated Congestion Resolution (ACR) should be used on the port. When enabled(1), ACR allows for early frame discard when congestion is experienced on a port, thus limiting the number of frames which may at any time be queued for a single port. The default value is disabled(2).')
swPortFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto-negotiate", 3), ("enabled-flow-control", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortFullDuplex.setDescription('Set to enabled(1) to operate in full duplex mode: port will allow simultaneous transmit and receive which can double its bandwidth. Set to disabled(2) to operate in normal mode. Set to auto-negotiate(3) to allow the switch to negotiate with the other end of the connection. Auto-negotiate(3) may not be set on a 10Mbps port, or a port whose connector type is not rj45. Doing so will result in badValue. Set to enabled_flow_control(4) to allow a port to operate in full duplex and to allow a port to throttle packet transmission according to flow control messages sent by the other end of the link.')
swPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("enabled", 1), ("disabled-mgmt", 2), ("suspended-linkbeat", 3), ("suspended-jabber", 4), ("suspended-violation", 5), ("disabled-violation", 7), ("suspended-not-present", 9), ("suspended-not-recognized", 10), ("reset", 11), ("suspended-ringdown", 12), ("suspended-stp", 13), ("disabled-self-test", 14), ("enable-degraded", 15), ("suspended-atm-lane-down", 16), ("suspended-no-vlan", 17), ("disabled-no-vlan", 18), ("suspended-atm-network-down", 19), ("suspended-disl", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStatus.setDescription('Current operational status of the port. Possible values are: enabled : normal operation (transmit and receive) disabled-mgmt : disabled by explicit management action suspended-linkbeat : suspended due to absence of linkbeat suspended-jabber : suspended because port is jabbering suspended-violation : suspended due to a secured address violation disabled-violation : disabled due to a secured address violation suspended-not-present: there is no module inserted in the expansion slot. suspended-not-recognized: there is an unrecognized module inserted in the expansion slot. reset : the port is currently in the reset state. suspended-ringdown : suspended due to a ring-down condition suspended-stp : Spanning Tree Protocol non forwarding state disabled-self-test : disabled because port fails self-test enable-degraded : connectivity still present but performance is lowered due to errors. suspended-atm-lane-down: Non-trunk ATM module using LANE suspended because there is no active LANE client. suspended-no-vlan : the port is not assigned to a VLAN or the assigned VLAN does not exist. disabled-no-vlan : vlan of the port is suspended or does not exist. suspended-atm-network-down: ATM module suspended due to ATM network down, or ATM physical layer down. suspended-disl : suspended while port is negotiating trunking mode using the Dynamic Inter Switch Link protocol. The default value is enabled(1), unless POST has detected a failure on the port, in which case, it is disabled-self-test(9). Any swPortStatus of type disabled-xxxx (except disabled-self-test) is saved across a system reset so a port may also come up with such a status.')
swPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled-mgmt", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortAdminStatus.setDescription('By explicit management action, change the port status to either enabled : normal status (transmit and receive enabled) disabled-mgmt: transmit and receive disabled.')
swPortLastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("enabled", 1), ("disabled-mgmt", 2), ("suspended-linkbeat", 3), ("suspended-jabber", 4), ("suspended-violation", 5), ("disabled-violation", 7), ("suspended-not-present", 9), ("suspended-not-recognized", 10), ("reset", 11), ("suspended-ringdown", 12), ("suspended-stp", 13), ("disabled-self-test", 14), ("enable-degraded", 15), ("suspended-atm-lane-down", 16), ("suspended-no-vlan", 17), ("disabled-no-vlan", 18), ("suspended-atm-network-down", 19), ("suspended-disl", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortLastStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortLastStatus.setDescription('The value of swPortStatus prior to its current value.')
swPortStatusChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStatusChanges.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStatusChanges.setDescription('Number of times swPortStatus has changed.')
swPortAddressingSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortAddressingSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: swPortAddressingSecurity.setDescription('Set to enabled(1) to effect addressing security. Set to disabled(2) to leave the port unsecure Addressing security cannot be enabled on a port whose type is Network and doing so will result in badValue.')
swPortAddressTableSize = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 132))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortAddressTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: swPortAddressTableSize.setDescription('For secured Network port, the address table size can range from 1 to 132. For unsecured Network port, the size is unrestricted (shown as the value zero) and is, therefore, not settable. Any attempt to violate these rules will result in badValue.')
swPortNumberOfLearnedAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortNumberOfLearnedAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: swPortNumberOfLearnedAddresses.setDescription('The current number of dynamically learned addresses on the port. The initial value is zero.')
swPortNumberOfStaticAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortNumberOfStaticAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: swPortNumberOfStaticAddresses.setDescription('The current number of statically assigned unicast addresses on the port. The initial value is zero.')
swPortEraseAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noErase", 1), ("erase", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortEraseAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: swPortEraseAddresses.setDescription('Set to erase(2) to delete all learned and assigned static unicast addresses the port currently has. Setting the object to noErase(1) has no effect. This object always returns noErase(1) when read.')
swPortFloodUnregisteredMulticasts = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortFloodUnregisteredMulticasts.setStatus('mandatory')
if mibBuilder.loadTexts: swPortFloodUnregisteredMulticasts.setDescription('Set to enabled(1) to allow the forwarding to this port frames addressed to multicast addresses that have not been registered for the port. Set to disabled(2) to filter and discard such frames. The default value is enabled(1).')
swPortFloodUnknownUnicasts = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortFloodUnknownUnicasts.setStatus('mandatory')
if mibBuilder.loadTexts: swPortFloodUnknownUnicasts.setDescription('This object controls the forwarding of unknown unicast frames to this port. When set to enabled(1) the switch, upon receiving a frame with an unknown unicast destination address on another port, will transmit the frame to this port. When set to disabled(2), The switch will filter and not transmit unknown unicast frames to this port. The default value for this object is enabled(1).')
swPortMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: swPortMonitoring.setDescription('Set to enabled(1) to forward receive and transmit frames on this port to the port identified by sysConfigMonitorPort. Set to disabled(2) to not monitor frame traffic on this port.')
swPortSecuredAddressViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortSecuredAddressViolations.setStatus('mandatory')
if mibBuilder.loadTexts: swPortSecuredAddressViolations.setDescription('Number of times a source address was seen on this port which duplicates a secured address configured on another port, plus the number of times a source address was seen on this port which does not match any addresses secured for the port.')
swPortLinkbeatStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkbeat", 1), ("noLinkbeat", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortLinkbeatStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortLinkbeatStatus.setDescription('The current port linkbeat status.')
swPortLinkbeatLosses = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortLinkbeatLosses.setStatus('mandatory')
if mibBuilder.loadTexts: swPortLinkbeatLosses.setDescription('Number of times that the value of swPortLinkbeatStatus has changed from linkbeat to noLinkbeat.')
swPortJabberStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notJabbering", 1), ("jabbering", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortJabberStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortJabberStatus.setDescription('The current jabber function result.')
swPortJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: swPortJabbers.setDescription('Number of times that the jabber function has to be invoked because a frame transmitted from this port exceeded a certain time duration.')
swPortClearStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noClear", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortClearStatistics.setStatus('mandatory')
if mibBuilder.loadTexts: swPortClearStatistics.setDescription('Set to clear(2) to zero out all statistics associated with the port. Per-port statistics are kept in this swPortTable as well as in the swPortRxStatTable, swPortTxStatTable, swPortTxCollTable, dot1dBasePortTable, and dot1dTpPortTable. Setting this object to noClear(1) has no effect. This object always returns noClear(1) when read.')
swPortBroadcastStormBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notBlocked", 1), ("blocked", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortBroadcastStormBlocked.setStatus('mandatory')
if mibBuilder.loadTexts: swPortBroadcastStormBlocked.setDescription('The current broadcast forwarding status of this port. If this port is blocked by broadcast storm control, the switch drops all broadcasts received from the port.')
swPortSTPPortFastMode = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortSTPPortFastMode.setStatus('mandatory')
if mibBuilder.loadTexts: swPortSTPPortFastMode.setDescription("This object configures the port into the Spanning Tree port-fast mode. When enabled(1), the STP can transition the port's state directly from blocking to forwarding, and vice versa, without going through the intermediate listening and learning states. This object should only be enabled for a port that is connected to a single workstation. A port that is attached to a network segment with multiple network nodes or bridges should have this object set to disabled(2) since a temporary loop may occur when port changes state. If this object is enabled on a trunk port, or a port becomes a trunk port while this object has the enabled(1) value, the switch will ignore the configured value and operate the port as though its port-fast mode is disabled. If the port subsequently loses its trunking status, the configured fast-mode value will then take effect. The default value is enabled(1) for 10Mbps ports and disabled(2) for 100Mbps ports.")
swPortHalfDuplexBackPressure = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortHalfDuplexBackPressure.setStatus('obsolete')
if mibBuilder.loadTexts: swPortHalfDuplexBackPressure.setDescription('Back pressure allows a port to force a collision when there is no buffer to receive frames. The port must be in half duplex to benefit from this enhancement. If the port is operating to be in full duplex, back pressure will not be applicable. This object has been obsoleted and replaced with sysConfigHalfDuplexBackPressure.')
swPortDuplexStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("full-duplex", 1), ("half-duplex", 2), ("full-duplex-flow-control", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortDuplexStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortDuplexStatus.setDescription('The status of duplex mode on this port. This shows the result of full duplex auto-negotiation when swPortFullDuplex is set to auto-negotiate.')
swPortFullDuplexFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortFullDuplexFlowControl.setStatus('obsolete')
if mibBuilder.loadTexts: swPortFullDuplexFlowControl.setDescription('The configuration of flow control on this port. Flow control allows the port to throttle packet transmission according to flow control messages sent by the other end of the link. For ports that do not support the feature, this object is always set to disabled and is read-only.')
swPortEnhancedCongestionControl = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("adaptive", 1), ("disabled", 2), ("moderate-aggressive", 3), ("aggressive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortEnhancedCongestionControl.setStatus('mandatory')
if mibBuilder.loadTexts: swPortEnhancedCongestionControl.setDescription('Enhanced Congestion Control (ECC) reduces the transmit back-off period to allow the port to transmit more quickly, thereby reducing the transmit queue congestion on the port. When set to disabled(2), ECC is disabled. When set to adaptive(1), ECC is enabled when the ports transmit queue is full. Set to moderate-aggressive(3) to enable ECC with a back-off period that is divided by a factor of 32. Set to aggressive(4) to enable ECC with a back-off period that is divided by a factor of 1024. The object is only applicable to 100Mbps ports of the switch. The default value is disabled(1).')
swPortBridgePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortBridgePriority.setStatus('mandatory')
if mibBuilder.loadTexts: swPortBridgePriority.setDescription('This is the bridge port priority. When a port is a non-trunk, the value of this object is the same as dot1dStpPortPriority in RFC 1493 for the port. When a port is operating as a VLAN trunk, the port may participate in multiple spanning trees, one for each VLAN. This port may use one of two priorities in each instance of spanning tree operating on the port. This object specifies one of two possible values that can be used by as a bridge port priority for each instance of spanning tree operating on a trunk port. The alternate bridge port priority value is specified by swPortBridgePriorityAlternate. The value of dot1dStpPortPriority must be one of these two values.')
swPortBridgePriorityAlternate = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortBridgePriorityAlternate.setStatus('mandatory')
if mibBuilder.loadTexts: swPortBridgePriorityAlternate.setDescription('This object specifies the other priority that can be used as the port priority for each instance of spanning tree operating on a trunk port. See the definition for swPortBridgePriority.')
swPortBridgePathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 35), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortBridgePathCost.setStatus('mandatory')
if mibBuilder.loadTexts: swPortBridgePathCost.setDescription("This is the bridge port path cost. When a port is a non-trunk, the object's value is the same as dot1dStpPortPathCost in RFC 1493 for the port. When a port is operating as a VLAN trunk, the port may participate in multiple spanning trees, one for each VLAN. This port may use one of two path cost in each instance of spanning tree operating on the port. This object specifies one of two possible values that can be used by as a bridge port path cost for each instance of spanning tree operating on a trunk port. The alternate bridge port priority value is specified by swPortBridgePathCostAlternate. The value of this object must be greater or equal to the value of swPortBridgePathCostAlternate. The value of dot1dStpPortPathCost must be one of these two values.")
swPortBridgePathCostAlternate = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortBridgePathCostAlternate.setStatus('mandatory')
if mibBuilder.loadTexts: swPortBridgePathCostAlternate.setDescription('This object specifies the other path cost that can be used as the port path cost for each instance of spanning tree operating on a trunk port. The value of this object must be less than or equal to the value of swPortBridgePriority. See the definition for swPortBridgePriority.')
swPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortIfIndex.setDescription('This is the value of MIB-II ifIndex object corresponding to this port.')
swPortInternal = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortInternal.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInternal.setDescription('This indicates if the port is an internal port. An internal port is one that does not allow a direct physical connection to another device. An example of an internal port is a switched port of a slot with a repeater module.')
switchPortRxStatTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2), )
if mibBuilder.loadTexts: switchPortRxStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortRxStatTable.setDescription('A list of switch port Receive statistics entries.')
swPortRxStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "swPortRxStatIndex"))
if mibBuilder.loadTexts: swPortRxStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxStatEntry.setDescription('Receive statistics for an individually switched port.')
swPortRxStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxStatIndex.setDescription('A number greater than zero identifying an individually switched port. The same value of a port index variable for any of the port tables in this MIB group selects the same port.')
swPortRxTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxTotalFrames.setDescription('A count of all frames that are successfully received. This does not include frames received with frame-too-long, FCS, length or alignment errors, or frames lost due to internal MAC sublayer error.')
swPortRxTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxTotalOctets.setDescription('A count of data and padding octets in all octets that are successfully received. This does not include octets in frames received with frame-too-long, FCS, length or alignment errors, or frames lost due to internal MAC sublayer error.')
swPortRxTotalOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxTotalOctetsWraps.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxTotalOctetsWraps.setDescription('The number of times the value in swPortRxTotalOctets has rolled to zero.')
swPortRxUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxUnicastFrames.setDescription('A count of frames that are successfully received and are directed to a unicast address. This does not include frames received with frame-too-long, FCS, length or alignment errors, or frames lost due to internal MAC sublayer error.')
swPortRxUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxUnicastOctets.setDescription('A count of data and padding octets in unicast frames that are successfully received. This does not include octets in frames received with frame-too-long, FCS, length or alignment errors, or frames lost due to internal MAC sublayer error.')
swPortRxUnicastOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxUnicastOctetsWraps.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxUnicastOctetsWraps.setDescription('The number of times the value in swPortRxUnicastOctets has rolled to zero.')
swPortRxBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxBroadcastFrames.setDescription('A count of frames that are successfully received and are directed to the broadcast address. This does not include frames received with frame-too-long, FCS, length or alignment errors, or frames lost due to internal MAC sublayer error.')
swPortRxBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxBroadcastOctets.setDescription('A count of data and padding octets in broadcast frames that are successfully received. This does not include octets in frames received with frame-too-long, FCS, length or alignment errors, or frames lost due to internal MAC sublayer error.')
swPortRxBroadcastOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxBroadcastOctetsWraps.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxBroadcastOctetsWraps.setDescription('The number of times the value in swPortRxBroadcastOctets has rolled to zero.')
swPortRxMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxMulticastFrames.setDescription('A count of frames that are successfully received and are directed to a multicast address. This does not include frames received with frame-too-long, FCS, length or alignment errors, or frames lost due to internal MAC sublayer error.')
swPortRxMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxMulticastOctets.setDescription('A count of data and padding octets in multicast frames that are successfully received. This does not include octets in frames received with frame-too-long, FCS, length or alignment errors, or frames lost due to internal MAC sublayer error.')
swPortRxMulticastOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxMulticastOctetsWraps.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxMulticastOctetsWraps.setDescription('The number of times the value in swPortRxMulticastOctets has rolled to zero.')
swPortRxForwardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxForwardedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxForwardedFrames.setDescription('Count of frames received and forwarded to some other port(s) for transmission.')
swPortRxFilteredFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxFilteredFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxFilteredFrames.setDescription('A count of frames received that were discarded because 1) the frames were local to the segment, 2) no destination address matches could be found and no ports were set up to accept such frames, 3) the destination addresses matched but source port explicit information prevented their forwarding, 4) the destination addresses matched but no destination ports have been specified for them, 5) the destinations were non-registered multicasts and no ports were configured to accept them.')
swPortRxNoBufferDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxNoBufferDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxNoBufferDiscards.setDescription("A count of frames received that were discarded due to a lack of frame buffer resources in the switch's forwarding engine.")
swPortRxFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxFCSErrors.setDescription('A count of frames received that are an integral number of octets in length but do not pass the Frame Check Sequence test.')
swPortRxAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxAlignmentErrors.setDescription('A count of frames received that are not an integral number of octets in length and do not pass the Frame Check Sequence test.')
swPortRxFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxFrameTooLongs.setDescription('A count of frames received that exceed the maximum permitted frame size as defined by the corresponding portMtu object.')
swPortRxRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortRxRunts.setStatus('mandatory')
if mibBuilder.loadTexts: swPortRxRunts.setDescription('A count of frames received that are shorter than the minimum permitted frame size. Runts usually indicate collision fragments, a normal network event.')
switchPortTxStatTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3), )
if mibBuilder.loadTexts: switchPortTxStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortTxStatTable.setDescription('A list of switch port Transmit statistics entries.')
swPortTxStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "swPortTxStatIndex"))
if mibBuilder.loadTexts: swPortTxStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxStatEntry.setDescription('Transmit statistics for an individually switched port.')
swPortTxStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxStatIndex.setDescription('A number greater than zero identifying an individually switched port. The same value of a port index variable for any of the port table in this MIB group selects the same port.')
swPortTxTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxTotalFrames.setDescription('A count of all frames that are successfully transmitted.')
swPortTxTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxTotalOctets.setDescription('A count of data and padding octets in all frames that are successfully transmitted.')
swPortTxTotalOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxTotalOctetsWraps.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxTotalOctetsWraps.setDescription('The number of times the value in swPortTxTotalOctets has rolled to zero.')
swPortTxUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxUnicastFrames.setDescription('A count of frames that are successfully transmitted and are directed to a unicast address.')
swPortTxUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxUnicastOctets.setDescription('A count of data and padding octets in unicast frames that are successfully transmitted.')
swPortTxUnicastOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxUnicastOctetsWraps.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxUnicastOctetsWraps.setDescription('The number of times the value in swPortTxUnicastOctets has rolled to zero.')
swPortTxBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxBroadcastFrames.setDescription('A count of frames that are successfully transmitted and are directed to the broadcast address.')
swPortTxBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxBroadcastOctets.setDescription('A count of data and padding octets in broadcast frames that are successfully transmitted.')
swPortTxBroadcastOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxBroadcastOctetsWraps.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxBroadcastOctetsWraps.setDescription('The number of times the value in swPortTxBroadcastOctets has rolled to zero.')
swPortTxMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxMulticastFrames.setDescription('A count of frames that are successfully transmitted and are directed to a multicast address.')
swPortTxMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxMulticastOctets.setDescription('A count of data and padding octets in multicast frames that are successfully transmitted.')
swPortTxMulticastOctetsWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxMulticastOctetsWraps.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxMulticastOctetsWraps.setDescription('The number of times the value in swPortTxMulticastOctets has rolled to zero.')
swPortTxDeferrals = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxDeferrals.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxDeferrals.setDescription('A count of frames for which the first transmission attempt is delayed because the medium is busy.')
swPortTxSingleCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxSingleCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxSingleCollisions.setDescription('A count of successfully transmitted frames for which transmission is inhibited by exactly one collision.')
swPortTxMultipleCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxMultipleCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxMultipleCollisions.setDescription('A count of successfully transmitted frames for which transmission is inhibited by more than one collision.')
swPortTxLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxLateCollisions.setDescription('The number of times that a collision is detected later than 512 bit-times into the transmission of a frame. A late collision is also considered as a (generic) collision for purposes of other collision-related statistics.')
swPortTxExcessiveCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxExcessiveCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxExcessiveCollisions.setDescription('A count of frames for which transmission fails due to excessive collisions. The threshold is either 16 in the normal mode of operation, or 4 in the Enhanced Congestion Control (ECC) mode. Thus, this count is the sum of the corresponding instances of the swPortTxExcessiveCollision16s object, and the swPortTxExcessiveCollision4s object.')
swPortTxExcessiveDeferrals = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxExcessiveDeferrals.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxExcessiveDeferrals.setDescription('A count of frames for which transmission is deferred for an excessive period of time.')
swPortTxExcessiveCollision16s = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxExcessiveCollision16s.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxExcessiveCollision16s.setDescription('A count of frames that due to excessive collisions are not transmitted successfully. Here, the normal threshold of 16 collisions is used to determine the status of the transmission. A swPortTxExcessiveCollision16s is counted twice, i.e., both as a swPortTxExcessiveCollision16s and as a swPortTxExcessiveCollisions.')
swPortTxExcessiveCollision4s = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxExcessiveCollision4s.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxExcessiveCollision4s.setDescription('A count of frames that due to excessive collisions are not transmitted successfully. Here, the Enhanced Congestion Control threshold of 4 collisions is used to determine the status of the transmission. A swPortTxExcessiveCollision4s is counted twice, i.e., both as a swPortTxExcessiveCollision4s and as a swPortTxExcessiveCollisions.')
swPortTxQueueFullDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxQueueFullDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxQueueFullDiscards.setDescription('A count of frames that cannot be transmitted because the transmit queue for the port is full.')
swPortTxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxErrors.setDescription('A count of frames for which transmission fails due to an internal MAC sublayer transmit error. A frame is only counted by an instance of this object if it is not counted by the corresponding instance of either the swPortTxLateCollisions object, the swPortTxExcessiveCollisions object, the swPortTxExcessiveCollision16s object, the swPortTxExcessiveCollision4s object, or the swPortTxExcessiveDeferrals object.')
switchPortTxCollTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 4), )
if mibBuilder.loadTexts: switchPortTxCollTable.setStatus('mandatory')
if mibBuilder.loadTexts: switchPortTxCollTable.setDescription('A collection of collision histograms for the switch ports.')
swPortTxCollEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 4, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "swPortTxCollIndex"), (0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "swPortTxCollCount"))
if mibBuilder.loadTexts: swPortTxCollEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxCollEntry.setDescription('This table provides a per port histogram of collision activity. The swPortTxCollIndex index (1 to sysInfoNumberOfSwitchPorts) identifies an individually switched port, and the swPortTxCollCount index (1 to 16) denotes the number of collisions experienced in transmitting a frame. Each table element, then, contains a counter that denotes the number of frames that have experienced a specific number of collisions.')
swPortTxCollIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxCollIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxCollIndex.setDescription('A number greater than zero identifying an individually switched port. The same value of a port index variable for any of the port tables in this MIB group selects the same port.')
swPortTxCollCount = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxCollCount.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxCollCount.setDescription('The number of per-frame media collisions for which a particular collision histogram cell represents the frequency on a particular port.')
swPortTxCollFrequencies = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortTxCollFrequencies.setStatus('mandatory')
if mibBuilder.loadTexts: swPortTxCollFrequencies.setDescription('A count of frames for which the transmission (successful or otherwise) on a particular port is accompanied by a particular number of media collisions.')
netMgmtIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtIpAddress.setDescription("The switch's administrative IP address. The switch may automatically discover a value for this object using the BootStrap protocol (BOOTP). The object value is also duplicated in the MIB-II ipAddrTable. The following applies to switches operating with firmware version smaller than 6.00: When VLANs are present, The switch may be configured with up to 4 administrative IP addresses, one per VLAN. This object, in this case, configures the IP address for the first VLAN. See the object vlanTable for how to configure the other IP addresses. Assigning multiple VLAN IP addresses is only necessary if the VLANs in use represent separate physical IP subnets. This allows a management station residing on a VLAN to directly manage the switch without the need for an intervening router/gateway. A write to this object will take effect immediately, replacing the previous address, if any.")
netMgmtIpSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtIpSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtIpSubnetMask.setDescription("The switch's administrative IP subnet mask. The switch may automatically discover a value for this object using the BootStrap protocol (BOOTP). The object value is also duplicated in the MIB-II ipAddrTable. The following applies to switches operating with firmware version smaller than 6.00: When VLANs are present, The switch may be configured with up to 4 administrative IP subnet masks, one per VLAN. This object, in this case, configures the subnet mask for the first VLAN. See the object vlanTable for how to configure the other subnet masks. Assigning multiple VLAN subnet masks is only necessary if the VLANs in use represent separate physical IP subnets. A write to this value will take effect immediately. The default value is 0.0.0.0, or no subnet mask.")
netMgmtDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtDefaultGateway.setDescription('The default gateway IP address is the address of the next hop router the switch uses to reach a non-local IP host when the switch does not know the return route. During a normal management protocol exchange with an IP client host, the switch simply sends its response onto the same route from which the request was received. The default gateway route is only used when the switch itself initiates an exchange, e.g., a TFTP upgrade, with the client. The default gateway IP address is global to all VLANs, which is unlike the unique per-VLAN management IP address and subnet mask. A write to this object will take effect immediately, replacing the previous address, if any. The default is 0.0.0.0, or no address.')
netMgmtEnableAuthenTraps = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtEnableAuthenTraps.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtEnableAuthenTraps.setDescription('Indicates whether the switch is permitted to generate authenticationFailure traps. The value of this object overrides any configuration information; as such, it provides a means whereby all authenticationFailure traps may be disabled. This object manipulates the same value for the snmpEnableAuthenTraps object instance. The object is respecified in this group for convenience. The default value is enabled(1).')
netMgmtEnableLinkTraps = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtEnableLinkTraps.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtEnableLinkTraps.setDescription('Indicates whether the switch is permitted to generate linkUp/linkDown traps. The value of this object overrides any configuration information; as such, it provides a means whereby all linkUp/linkDown traps may be disabled. The default value is enabled(1).')
netMgmtConsoleInactTime = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtConsoleInactTime.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtConsoleInactTime.setDescription('The number of seconds of Management Console session inactivity to wait before ending the session. Once a session has ended, the user must resupply the Console password to regain access. A value of 0 indicates no timeout, and is the default value.')
netMgmtConsolePasswordThresh = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtConsolePasswordThresh.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtConsolePasswordThresh.setDescription('The number of consecutive invalid password attempts allowed before the Management Console is shut down (kept silent) for a configured duration. A zero value permits unlimited attempts. The default value is 3.')
netMgmtConsoleSilentTime = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtConsoleSilentTime.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtConsoleSilentTime.setDescription('The number of minutes during which the Management Console will be unavailable after repeated failed attempts to logon. A zero value specifies no silent time, and is the default value.')
netMgmtModemInitString = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtModemInitString.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtModemInitString.setDescription('This is the initialization string used to configure an attached modem. Specify this string if the modem is not Hayes compatible. Only the initialization commands need to be specified (i.e., do NOT specify any modem prefix string such as the AT attention sequence, or any suffix such as the CR character). This string takes effect after every line hangup.')
netMgmtModemDialString = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtModemDialString.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtModemDialString.setDescription('This string contains a phone number which is used to establish a modem connection with a remote site. Only the phone number needs to be specified (i.e., do NOT specify any dial prefix string such as ATDT). Leave this string empty if this dial-out capability is not desired. This string takes effect after every line hangup.')
netMgmtModemDialDelay = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtModemDialDelay.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtModemDialDelay.setDescription('This object specifies a delay in seconds between every dial-out failure. The value zero indicates an infinite delay. Normally, the switch will attempt a dial-out if the netMgmtModemDialString object is non-empty. If the remote site then fails to answer, and auto-answer has been disabled on this system, the system will retry the dial-out attempt after this delay has passed. If auto-answer is enabled and the first dial-out attempt fails, the system will stop further dial-out attempts and immediately go into auto-answer mode. The default value is 300 seconds, or 5 minutes.')
netMgmtModemAutoAnswer = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtModemAutoAnswer.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtModemAutoAnswer.setDescription('This object specifies whether the system should be in auto-answer mode and only accepts incoming calls. Note that the system will always attempt a dial-out first if the netMgmtModemDialString object is non-empty. The default value is enabled(1).')
netMgmtSetClientTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 13), )
if mibBuilder.loadTexts: netMgmtSetClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtSetClientTable.setDescription('Table (4 entries) containing a list of IP addresses or DNS name of workstations permitted to issue SET requests. Such a workstation is called a Set client. If this table is empty then any SET request with a matching SET community string is allowed. If at least one Set client is specified, then an incoming SET request must have its source IP address or name matched against an entry in this table before the SET is allowed. An Set client entry whose IP address is 0.0.0.0 is considered invalid and will be ignored. This table is considered empty when all Set client addresses are zeroes (0.0.0.0). and DNS names are empty')
netMgmtSetClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 13, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "netMgmtSetClientIndex"))
if mibBuilder.loadTexts: netMgmtSetClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtSetClientEntry.setDescription('An IP address of a manager station allowed to issue SET requests to this management agent.')
netMgmtSetClientIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netMgmtSetClientIndex.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtSetClientIndex.setDescription('Identification of a SET client entry.')
netMgmtSetClientAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 13, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtSetClientAddr.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtSetClientAddr.setDescription("The SET client is assumed to be Internet UDP/IP based. And this is the client's IP address. Setting this object will cause the value in the corresponding netMgmtSetClientName object to cleared.")
netMgmtSetClientStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtSetClientStatus.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtSetClientStatus.setDescription('Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry. That is, it effectively disassociates the IP address identified with said entry from the table. It is an implementation specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use.')
netMgmtSetClientName = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 13, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtSetClientName.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtSetClientName.setDescription("The Set Client's DNS host name. The switch will resolve the host name to IP address via DNS and copy the resolved IP address into netMgmtSetClientAddr object. Therefore the value of this object overwrites any value in netMgmtSetClientAddr. If netMgmtSetClientAddr is set then value of this object will be cleared.")
netMgmtTrapClientTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 14), )
if mibBuilder.loadTexts: netMgmtTrapClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtTrapClientTable.setDescription('Table (4 entries) containing a list of Network Management Stations that are to receive traps generated by this Network Management Agent. Such an NMS is called a Trap client. An Trap client entry whose IP address is 0.0.0.0 and DNS name is empty is considered invalid and will be ignored.')
netMgmtTrapClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 14, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "netMgmtTrapClientIndex"))
if mibBuilder.loadTexts: netMgmtTrapClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtTrapClientEntry.setDescription('A destination address and community string to a particular trap client.')
netMgmtTrapClientIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netMgmtTrapClientIndex.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtTrapClientIndex.setDescription('Identification of a trap client entry.')
netMgmtTrapClientAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 14, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtTrapClientAddr.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtTrapClientAddr.setDescription("The trap client is assumed to be Internet UDP/IP based. And this is the client's IP address. Setting a value for this object will cause the value of netMgmtTrapClientName to be cleared (set to null string).")
netMgmtTrapClientComm = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 14, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtTrapClientComm.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtTrapClientComm.setDescription('Community string used for traps sent to this trap client.')
netMgmtTrapClientStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtTrapClientStatus.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtTrapClientStatus.setDescription('Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry. That is, it effectively disassociates the IP address/community string identified with said entry from the table. It is an implementation specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use.')
netMgmtTrapClientName = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 14, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtTrapClientName.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtTrapClientName.setDescription("The Trap Client's DNS host name. The switch will resolve the host name to an IP address via DNS and copy the resolved IP address into netMgmtTrapClientAddr object. If netMgmtTrapClientAddr is set the value of this object will be cleared (set to null string).")
netMgmtCdpHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtCdpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtCdpHoldTime.setDescription('The hold time is the amount of time that a neighboring device keeps the CDP neighbor information received from this switch. If the hold time expires before receiving a new CDP message from this switch then the neighbor device will remove this switch as a neighbor. The default value is 180 seconds.')
netMgmtCdpTransmissionTime = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtCdpTransmissionTime.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtCdpTransmissionTime.setDescription('The transmission time specifies the interval that the switch will trasnmit CDP messages from its ports. The default value is 60 seconds. ')
netMgmtCgmpEnable = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtCgmpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtCgmpEnable.setDescription('This variable allows user to enable or disable Cisco Group Management Protocol (CGMP). Enabling CGMP will result in the deletion of all multicast addresses of form 0x01-00-5E-XX-XX-XX, that may have been registered on the switch. The default value is enabled(1).')
netMgmtCgmpRouterHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtCgmpRouterHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtCgmpRouterHoldTime.setDescription('Multicast routers that support CGMP will send CGMP join message to advertise themselves to switches within a network. A switch that receives a CGMP message will save the information and set a timer equal to the router hold time. When the last router hold time expires, the switch will remove all IP multicast groups learned from CGMP. The default value is 600 seconds.')
netMgmtVlan = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtVlan.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtVlan.setDescription(' The current VLAN for network management. This defaults to 1.')
netMgmtEnableRIP = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtEnableRIP.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtEnableRIP.setDescription('This object enables and disables Routing Information Protocol (RIP) listener to automatically discover IP gateways. The default value is enabled(1).')
netMgmtDomainServer1IpAddress = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtDomainServer1IpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtDomainServer1IpAddress.setDescription('The IP address of a Domain Name Server (DNS) which the system uses to resolve domain names to IP addresses. A set on this object takes effect the next time the system has to resolve a domain name. A value of all zeroes (0.0.0.0) specifies no domain server.')
netMgmtDomainServer2IpAddress = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 22), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtDomainServer2IpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtDomainServer2IpAddress.setDescription('The IP address of a second Domain Name Server (DNS) which the system uses to resolve domain names to IP addresses. A set on this object takes effect the next time the system needs to resolve a domain name. A value of all zeroes (0.0.0.0) specifies no domain name server.')
netMgmtDefaultSearchDomain = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtDefaultSearchDomain.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtDefaultSearchDomain.setDescription('A string of up to 63 characters specifying a default domain search path. When switch needs to resolve a domain name that is not fully specified, it appends this default domain path to the name and continues the resolution attempt.')
netMgmtHttpServerAdminState = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtHttpServerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtHttpServerAdminState.setDescription('This variable enables or disables the HTTP server interface. The default value is enabled(1).')
netMgmtHttpPort = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 4, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netMgmtHttpPort.setStatus('mandatory')
if mibBuilder.loadTexts: netMgmtHttpPort.setDescription('This variable allows the user to configure a specific port on which the HTTP server will listen for TCP connections. By default, the server listens on TCP port 80.')
upgradeFirmwareSource = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eprom", 1), ("flash", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradeFirmwareSource.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeFirmwareSource.setDescription('Selects the source from which firmware is read. There are 2 possible values, eprom(1) and flash(2). A valid selection will cause a system reset, followed by the execution of the selected firmware. The default selection is eprom(1). A valid selection is defined as: o a selection which yields a firmware that is different from the one currently executing, or o selection of flash(2), for which flash memory is available and contains a checksum verified firmware.')
upgradeEPROMRevision = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradeEPROMRevision.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeEPROMRevision.setDescription("Returns the revision number of the switch system firmware residing in EPROM. The string has the following format 'V2.01'.")
upgradeFlashSize = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradeFlashSize.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeFlashSize.setDescription('The size of available FLASH memory in the system, in kilobytes. For example: 128 equals 131072 bytes (128 bytes times 1024).')
upgradeFlashBankStatus = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: upgradeFlashBankStatus.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeFlashBankStatus.setDescription('Text string indicating status and version of last upgrade to flash memory, including the source of the upgrade, version and the date and time of upgrade. The string is in net ASCII and conforms exactly to one of the following format, depending upon the source of the upgrade: V2.01 written on Mon Sep 21 07:02:01 1992 from serial terminal: valid or V2.01 written on Tue Dec 01 15:19:15 1992 from 192.009.200.200: invalid')
upgradeTFTPServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradeTFTPServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeTFTPServerAddress.setDescription('The IP address of a TFTP server from which a firmware image can be downloaded. The download may be initiated by setting the upgradeTFTPInitiate to upgrade(1), or via an out-of-band management action. The default value is 0.0.0.0, or no address. Setting this object also sets the value of upgradeTFTPServerName to a string of the same value as this object.')
upgradeTFTPLoadFilename = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradeTFTPLoadFilename.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeTFTPLoadFilename.setDescription('The name of the file containing a firmware upgrade image on the host whose address is given by upgradeTFTPServerAddress. The default value is an empty string, or no filename.')
upgradeTFTPInitiate = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("upgrade", 1), ("noUpgrade", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradeTFTPInitiate.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeTFTPInitiate.setDescription('Setting this object to noUpgrade(2) results in no action. When set to upgrade(1), the switch will attempt to download a firmware upgrade image from the server whose address is given by upgradeTFTPServerAddress. The image is found in the file whose name is given by upgradeTFTPLoadFilename. Both upgradeTFTPServerAddress and upgradeTFTPLoadFilename must be non-empty for the upgrade to proceed. This object always returns noUpgrade(2) when read.')
upgradeAutoExecute = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradeAutoExecute.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeAutoExecute.setDescription('Indicates whether a newly upgraded firmware version should immediately be selected for execution. When this object is disabled(2), the user must explicitly set the upgradeFirmwareSource object to select and run a particular firmware version after an upgrade. When this object is enabled(1), following a successful firmware upgrade the system will automatically switch to run the new firmware. The default value is enabled(1).')
upgradeTFTPAccept = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradeTFTPAccept.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeTFTPAccept.setDescription('This object controls the second method of firmware upgrade using TFTP. The switch has a UDP Listener on the well known TFTP server port, and can accept upgrade requests from any workstation with Internet Protocol TFTP software. This object enables or disables the TFTP Upgrade Listener. When disabled(2), no TFTP workstations can download a firmware upgrade image to the switch. The default value is enabled(1).')
upgradeTFTPServerName = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 5, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upgradeTFTPServerName.setStatus('mandatory')
if mibBuilder.loadTexts: upgradeTFTPServerName.setDescription('The name of a TFTP server DNS name from which a firmware image can be downloaded. The download may be initiated by setting the upgradeTFTPInitiate to upgrade(1), or via an out-of-band management action. The value of this object is the same as the value of sysConfigTftpServerName. The value of upgradeTFTPServerAddress object is set to zero when this object is set.')
vlanMaxSupported = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanMaxSupported.setStatus('mandatory')
if mibBuilder.loadTexts: vlanMaxSupported.setDescription('The maximum number of virtual LANs supported.')
vlanAllowMembershipOverlap = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanAllowMembershipOverlap.setStatus('deprecated')
if mibBuilder.loadTexts: vlanAllowMembershipOverlap.setDescription('When set to enabled(1), the switch will allow a port to be member of more than one VLAN. Note that overlapped VLANs may lead to loss of connectivity in the Spanning Tree topology, and should only be used with caution. When set to disabled(2), the switch will ensure that no one port can simultaneously be member of more than one VLAN. This object is not supported by switches operating with firmware version greater than or equal to 6.00. The default value is disabled(2).')
vlanTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3), )
if mibBuilder.loadTexts: vlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanTable.setDescription('A list of configuration entries for a VLAN.')
vlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "vlanIndex"))
if mibBuilder.loadTexts: vlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlanEntry.setDescription('Configuration parameters for a VLAN.')
vlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vlanIndex.setDescription('Number from 1 to vlanMaxSupported identifying a configurable VLAN.')
vlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanName.setStatus('mandatory')
if mibBuilder.loadTexts: vlanName.setDescription('A descriptive string of up to 60 characters used by the network administrator to name a VLAN. This object is not supported by switches operating with firmware version greater than or equal to 6.00')
vlanMemberPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanMemberPorts.setStatus('mandatory')
if mibBuilder.loadTexts: vlanMemberPorts.setDescription("The set of the switch's member ports for the VLAN. A port may reside within multiple VLANs only if the object vlanAllowMembershipOverlap has been set to enabled. This object cannot be used to configure VLAN membership. The table vlanMemberTable is used for that purpose. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the VLAN is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. Initially, a single VLAN with all ports as its members is defined. This object is not supported by switches operating with firmware version greater than or equal to 6.00")
vlanIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vlanIpAddress.setDescription("The switch's administrative IP address in this VLAN. Note that once a value has been set for this object, the next write will only take effect after a system reset. The default value is the same as the address contained in netMgmtIpAddress. This object is not supported by switches operating with firmware version greater than or equal to 5.35")
vlanIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanIpSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: vlanIpSubnetMask.setDescription("The switch's administrative IP subnet mask in this VLAN. A change in the subnet mask at any time will immediately take effect. The default value is the same as the mask contained in netMgmtIpSubnetMask. This object is not supported by switches operating with firmware version greater than or equal to 5.35")
vlanBridgeTemplate = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanBridgeTemplate.setStatus('mandatory')
if mibBuilder.loadTexts: vlanBridgeTemplate.setDescription('The bridge parameter template used by the VLAN. By default, a VLAN uses template 1. The value of this object must be one of the values of bridgeTemplateIndex. This object is supported only by switches operating with firmware version greater than or equal to 7.00')
vlanStpAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanStpAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: vlanStpAdmin.setDescription('This object indicates if STP is enabled or disabled for the VLAN. This object is supported only by switches operating with firmware version greater than or equal to 7.00')
vlanMemberTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 4), )
if mibBuilder.loadTexts: vlanMemberTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanMemberTable.setDescription('A list of port membership configuration entries for a VLAN.')
vlanMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 4, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "vlanMemberIndex"), (0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "vlanMemberPortIndex"))
if mibBuilder.loadTexts: vlanMemberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlanMemberEntry.setDescription('Port membership configuration parameters for a VLAN.')
vlanMemberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanMemberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vlanMemberIndex.setDescription('Number from 1 to vlanMaxSupported identifying a configurable VLAN. The same value of a VLAN index variable for any of the VLAN tables in this MIB group selects the same VLAN.')
vlanMemberPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanMemberPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vlanMemberPortIndex.setDescription('Number greater than zero identifying an individually switched port. The same value of a port index variable for any of the port tables selects the same port.')
vlanMemberPortOfVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanMemberPortOfVlan.setStatus('mandatory')
if mibBuilder.loadTexts: vlanMemberPortOfVlan.setDescription('The port identified by vlanMemberPortIndex becomes a member of the VLAN identified by vlanMemberIndex when this object is set to true(1). The same port ceases to be member of that VLAN when the object is set to false(2). All ports in the switch must belong to some VLAN. Consequently, the switch will return badValue if this object is used such to remove the port from all membership lists. Note that when vlanAllowMembershipOverlap is disabled, a port can only be member of exactly one VLAN. In this case, setting vlanMemberPortOfVlan to true(1) for a port adds the port to the membership list of the current VLAN and removes the same port from all other VLAN membership lists. When vlanAllowMembershipOverlap is enabled, a port may reside in multiple VLANs. Setting vlanMemberPortOfVlan to true(1) in this case adds the port to the membership list of the current VLAN and does not change other VLAN membership lists.')
bridgeTemplateMax = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeTemplateMax.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTemplateMax.setDescription('The maximum number of bridge templates supported.')
bridgeTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 6), )
if mibBuilder.loadTexts: bridgeTemplateTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTemplateTable.setDescription('A list of bridge configuration templates.')
bridgeTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 6, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "bridgeTemplateIndex"))
if mibBuilder.loadTexts: bridgeTemplateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTemplateEntry.setDescription('Configuration parameters for a bridge parameter template.')
bridgeTemplateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeTemplateIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTemplateIndex.setDescription('Number from 1 to bridgeTemplateMax identifying a configurable bridge parameters template.')
bridgeTemplatePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 6, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTemplatePriority.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTemplatePriority.setDescription('See dot1dStpPriority in RFC 1493. The value of dot1dStpPriority must match the value of an instance of this object.')
bridgeTemplateMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 6, 1, 3), Timeout()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTemplateMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTemplateMaxAge.setDescription('See dot1dStpBridgeMaxAge in RFC 1493. The value of dot1dStpBridgeMaxAge must match the value of an instance of this object.')
bridgeTemplateHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 6, 1, 4), Timeout()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTemplateHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTemplateHelloTime.setDescription('See dot1dStpBridgeHelloTime in RFC 1493. The value of dot1dStpBridgeHelloTime must match the value of an instance of this object.')
bridgeTemplateForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 6, 6, 1, 5), Timeout()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTemplateForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeTemplateForwardDelay.setDescription('See dot1dStpBridgeForwardDelay in RFC 1493. The value of dot1dStpBridgeForwardDelay must match the value of an instance of this object.')
bandwidthUsageCurrent = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthUsageCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsageCurrent.setDescription('The bandwidth currently consumed. The measurement unit is in megabits per second (1,000,000 bits/second).')
bandwidthUsageMaxPeakEntries = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthUsageMaxPeakEntries.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsageMaxPeakEntries.setDescription('The maximum number of entries bandwidthUsagePeakTable can have.')
bandwidthUsagePeakInterval = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 6, 12, 24, 48, 72, 96, 120, 144, 168))).clone(namedValues=NamedValues(("onehour", 1), ("threehours", 3), ("sixhours", 6), ("twelvehours", 12), ("oneday", 24), ("twodays", 48), ("threedays", 72), ("fourdays", 96), ("fivedays", 120), ("sixdays", 144), ("oneweek", 168)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bandwidthUsagePeakInterval.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsagePeakInterval.setDescription('This object specifies the length of time which forms a peak bandwidth capture interval. The default is oneday(24). A write to this object with any new value restarts the peak bandwidth capture at the first interval. In other word, the bandwidthUsagePeakTable will be cleared and entry number 1 will record the peak for a new first interval.')
bandwidthUsagePeakRestart = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noRestart", 1), ("restart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bandwidthUsagePeakRestart.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsagePeakRestart.setDescription('Set to restart(2) to clear the bandwidthUsagePeakTable and restart the peak bandwidth capturing at the current interval. No action will be taken if this object is set to noRestart(1). This object always returned noRestart(1) when read.')
bandwidthUsageCurrentPeakEntry = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthUsageCurrentPeakEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsageCurrentPeakEntry.setDescription('A value identifying an instance of the bandwidthUsagePeakIndex of the bandwidthUsagePeakTable where the peak bandwidth measurement is most current.')
bandwidthUsagePeakTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 6), )
if mibBuilder.loadTexts: bandwidthUsagePeakTable.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsagePeakTable.setDescription('A list of entries containing peak bandwidth usages in a number of time periods.')
bandwidthUsagePeakEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 6, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "bandwidthUsagePeakIndex"))
if mibBuilder.loadTexts: bandwidthUsagePeakEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsagePeakEntry.setDescription('Information about peak bandwidth usage in a time period.')
bandwidthUsagePeakIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthUsagePeakIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsagePeakIndex.setDescription('Number from 1 to bandwidthUsageMaxPeakEntries identifying a particular bandwithUsagePeakEntry.')
bandwidthUsageStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthUsageStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsageStartTime.setDescription('Up to 32 characters containing the date and time that marks the start of this capture interval. The string is in net ASCII and conforms exactly to the following format: Mon Sep 21 07:00:00 1992')
bandwidthUsagePeak = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthUsagePeak.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsagePeak.setDescription('The highest bandwidth utilized since the time given in bandwidthUsageStartTime or last cleared. The measurement unit is in megabits per second (1,000,000 bits/second).')
bandwidthUsagePeakTime = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 7, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthUsagePeakTime.setStatus('mandatory')
if mibBuilder.loadTexts: bandwidthUsagePeakTime.setDescription('Up to 32 characters containing the date and time the value in bandwidthUsagePeak is captured. The string is in net ASCII and conforms exactly to the following format: Mon Sep 21 07:02:01 1992')
logonIntruder = NotificationType((1, 3, 6, 1, 4, 1, 437, 1, 1, 3) + (0,0)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: logonIntruder.setDescription('A user is repeatedly trying to logon using an invalid password. The number of attempts exceeds the preset limit given in netMgmtConsolePasswordThresh. Depending on how the object netMgmtConsoleSilentTime is configured, the switch may shut down the Management Console following the generation of this trap.')
switchDiagnostic = NotificationType((1, 3, 6, 1, 4, 1, 437, 1, 1, 3) + (0,1)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: switchDiagnostic.setDescription("The switch issues this trap when its Power On Self Test (POST) code does not pass all tests. Some failures are catastrophic and may prevent the generation of this trap, as well as the system's operations.")
addressViolation = NotificationType((1, 3, 6, 1, 4, 1, 437, 1, 1, 3) + (0,3)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: addressViolation.setDescription('The addressViolation trap is issued when an address violation is detected on a secured port. The generation of the addressViolation trap can be enabled or suppressed using the object sysConfigAddressViolationAlert.')
broadcastStorm = NotificationType((1, 3, 6, 1, 4, 1, 437, 1, 1, 3) + (0,4)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: broadcastStorm.setDescription('The broadcastStorm trap is issued when broadcast storm control is enabled and the number of broadcast packets received in a second from a port is higher than the broadcast threshold. The generation of this trap can be enabled or suppressed using the object sysConfigBroadcastStormAlert.')
rpsFailed = NotificationType((1, 3, 6, 1, 4, 1, 437, 1, 1, 3) + (0,5)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: rpsFailed.setDescription('A redundant power source is connected to the switch but a failure exists in the power system.')
ipAddressChange = NotificationType((1, 3, 6, 1, 4, 1, 437, 1, 1, 3) + (0,6)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: ipAddressChange.setDescription('The ipAddressChange trap is issued when the switch is unable to complete its DHCPDISCOVER/ DHCPREQUEST process, or when it fails to extend the lease for the current address, or when it accepts an address change from the user.')
bridgeGroupMaxSupported = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeGroupMaxSupported.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupMaxSupported.setDescription('The maximum number of bridge groups supported. The switch currenlty supports up to 4 bridge groups. This object represents the upper bound of the index into the bridgeGroupTable.')
bridgeGroupAllowMembershipOverlap = MibScalar((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeGroupAllowMembershipOverlap.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupAllowMembershipOverlap.setDescription('When set to enabled(1), the switch will allow a port to be member of more than one bridge group. Note that overlapped bridge groups may lead to loss of connectivity in the Spanning Tree topology, and should only be used with caution. When set to disabled(2), the switch will ensure that a port can belong to one and only one bridge group. The default value is disabled(1).')
bridgeGroupTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 3), )
if mibBuilder.loadTexts: bridgeGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupTable.setDescription('A list of configuration entries for a bridge group.')
bridgeGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 3, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "bridgeGroupIndex"))
if mibBuilder.loadTexts: bridgeGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupEntry.setDescription('Configuration parameters for a bridge group.')
bridgeGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupIndex.setDescription('Number from 1 to bridgeGroupMaxSupported identifying a configurable bridge group.')
bridgeGroupMemberPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeGroupMemberPorts.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupMemberPorts.setDescription("The set of the switch's member ports for the bridge group. A port may reside within multiple bridge groups only if the object bridgeGroupAllowMembershipOverlap has been set to enabled(1). This object cannot be used to configure bridge group membership. The table bridgeGroupMemberTable is used for that purpose. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge group is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'. Initially, a single bridge group with all ports as its members is defined.")
bridgeGroupStpAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeGroupStpAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupStpAdmin.setDescription('This object indicates if STP is enabled or disabled for the bridge group. The default is enabled(1).')
bridgeGroupMemberTable = MibTable((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 4), )
if mibBuilder.loadTexts: bridgeGroupMemberTable.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupMemberTable.setDescription('A list of port membership configuration entries for a bridge group.')
bridgeGroupMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 4, 1), ).setIndexNames((0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "bridgeGroupMemberIndex"), (0, "STAND-ALONE-ETHERNET-SWITCH-MIB", "bridgeGroupMemberPortIndex"))
if mibBuilder.loadTexts: bridgeGroupMemberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupMemberEntry.setDescription('Port membership configuration parameters for a bridge group.')
bridgeGroupMemberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeGroupMemberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupMemberIndex.setDescription('The value of bridgeGroupIndex of a bridge group.')
bridgeGroupMemberPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeGroupMemberPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupMemberPortIndex.setDescription('The value of swPortIndex of a switched port.')
bridgeGroupMemberPortOfBridgeGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 437, 1, 1, 3, 8, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeGroupMemberPortOfBridgeGroup.setStatus('mandatory')
if mibBuilder.loadTexts: bridgeGroupMemberPortOfBridgeGroup.setDescription("The port identified by bridgeGroupMemberPortIndex becomes a member of the bridgeGroup identified by bridgeGroupMemberIndex when this object is set to true(1). The same port ceases to be member of that bridgeGroup when the object is set to false(2). All ports in the switch must belong to some bridge group. Consequently, the switch will return badValue if this object is used such to remove the port from all membership lists. Note that when bridgeGroupAllowMembershipOverlap is disabled, a port can only be member of exactly one bridge group. In this case, setting bridgeGroupMemberPortOfBridgeGroup to true(1) for a port adds the port to the membership list of the current bridge group and removes the same port from all other bridge group membership lists. When bridgeGroupAllowMembershipOverlap is enabled, a port may reside in multiple bridge groups. Setting bridgeGroupMemberPortOfBridgeGroup to true(1) in this case adds the port to the membership list of the current bridge group and does not change other bridge groups' membership list.")
mibBuilder.exportSymbols("STAND-ALONE-ETHERNET-SWITCH-MIB", netMgmtCgmpRouterHoldTime=netMgmtCgmpRouterHoldTime, switchPortTxStatTable=switchPortTxStatTable, vlanTable=vlanTable, sysConfigAddressViolationAction=sysConfigAddressViolationAction, swPortRxBroadcastOctets=swPortRxBroadcastOctets, upgradeFlashBankStatus=upgradeFlashBankStatus, bandwidthUsagePeakRestart=bandwidthUsagePeakRestart, netMgmtTrapClientTable=netMgmtTrapClientTable, netMgmtTrapClientName=netMgmtTrapClientName, upgrade=upgrade, swPortRxFrameTooLongs=swPortRxFrameTooLongs, swPortAdminStatus=swPortAdminStatus, netMgmtTrapClientStatus=netMgmtTrapClientStatus, swPortRxUnicastOctets=swPortRxUnicastOctets, bandwidthUsagePeakInterval=bandwidthUsagePeakInterval, bandwidthUsage=bandwidthUsage, swPortRxAlignmentErrors=swPortRxAlignmentErrors, sysConfigNetworkPort=sysConfigNetworkPort, netMgmtCdpTransmissionTime=netMgmtCdpTransmissionTime, broadcastStorm=broadcastStorm, sysConfigStrictSTPTransition=sysConfigStrictSTPTransition, sysConfigMonitorPort=sysConfigMonitorPort, sysConfigMonitor=sysConfigMonitor, swPortFullDuplex=swPortFullDuplex, netMgmtCdpHoldTime=netMgmtCdpHoldTime, netMgmtEnableLinkTraps=netMgmtEnableLinkTraps, swPortRxMulticastOctetsWraps=swPortRxMulticastOctetsWraps, bridgeTemplateHelloTime=bridgeTemplateHelloTime, netMgmtModemInitString=netMgmtModemInitString, bandwidthUsageMaxPeakEntries=bandwidthUsageMaxPeakEntries, sysConfigMulticastStoreAndForward=sysConfigMulticastStoreAndForward, swPortSTPPortFastMode=swPortSTPPortFastMode, swPortTxCollCount=swPortTxCollCount, swPortLinkbeatStatus=swPortLinkbeatStatus, swPortRxTotalFrames=swPortRxTotalFrames, swPortBridgePathCostAlternate=swPortBridgePathCostAlternate, sysConfigHeuristics=sysConfigHeuristics, upgradeFirmwareSource=upgradeFirmwareSource, swPortEntry=swPortEntry, sysInfoPortLinkDisplayMap=sysInfoPortLinkDisplayMap, sysInfoPOSTResult=sysInfoPOSTResult, swPortRxForwardedFrames=swPortRxForwardedFrames, swPortTxCollFrequencies=swPortTxCollFrequencies, bridgeGroupStpAdmin=bridgeGroupStpAdmin, upgradeTFTPLoadFilename=upgradeTFTPLoadFilename, swPortSecuredAddressViolations=swPortSecuredAddressViolations, sysConfigEnableSTP=sysConfigEnableSTP, netMgmtDefaultGateway=netMgmtDefaultGateway, bridgeTemplateIndex=bridgeTemplateIndex, sysInfoBuffersUsed=sysInfoBuffersUsed, upgradeTFTPServerAddress=upgradeTFTPServerAddress, sysConfig=sysConfig, swPortAddressTableSize=swPortAddressTableSize, swPortRxStatIndex=swPortRxStatIndex, netMgmtModemAutoAnswer=netMgmtModemAutoAnswer, netMgmtDefaultSearchDomain=netMgmtDefaultSearchDomain, swPortTxExcessiveCollision16s=swPortTxExcessiveCollision16s, sysInfoTotalNumberOfPorts=sysInfoTotalNumberOfPorts, swPortConnectorType=swPortConnectorType, sysInfoNumberOfSharedPorts=sysInfoNumberOfSharedPorts, sysConfigDefaultReset=sysConfigDefaultReset, swPortTxTotalOctets=swPortTxTotalOctets, fastLink=fastLink, netMgmtSetClientName=netMgmtSetClientName, sysInfoMaxBuffers=sysInfoMaxBuffers, swPortTxMultipleCollisions=swPortTxMultipleCollisions, swPortRxNoBufferDiscards=swPortRxNoBufferDiscards, netMgmt=netMgmt, vlanMemberPorts=vlanMemberPorts, vlanMemberTable=vlanMemberTable, swPortEnhancedCongestionControl=swPortEnhancedCongestionControl, switchPortTable=switchPortTable, bridgeTemplateForwardDelay=bridgeTemplateForwardDelay, swPortStatusChanges=swPortStatusChanges, logonIntruder=logonIntruder, sysInfoImageCapability=sysInfoImageCapability, swPortTxUnicastFrames=swPortTxUnicastFrames, swPortTxMulticastOctets=swPortTxMulticastOctets, bridgeTemplateTable=bridgeTemplateTable, swPortInternal=swPortInternal, sysInfoBroadcastStormLastTime=sysInfoBroadcastStormLastTime, netMgmtModemDialDelay=netMgmtModemDialDelay, vlanEntry=vlanEntry, vlan=vlan, netMgmtIpAddress=netMgmtIpAddress, bandwidthUsageStartTime=bandwidthUsageStartTime, swPortBridgePriorityAlternate=swPortBridgePriorityAlternate, vlanAllowMembershipOverlap=vlanAllowMembershipOverlap, swPortRxTotalOctets=swPortRxTotalOctets, sysInfoPortExceedBroadcastStorm=sysInfoPortExceedBroadcastStorm, sysConfigHalfDuplexBackPressure=sysConfigHalfDuplexBackPressure, swPortAddressingSecurity=swPortAddressingSecurity, netMgmtVlan=netMgmtVlan, netMgmtSetClientEntry=netMgmtSetClientEntry, sysConfigConfigFileAuto=sysConfigConfigFileAuto, swPortTxStatEntry=swPortTxStatEntry, bandwidthUsageCurrent=bandwidthUsageCurrent, swPortControllerRevision=swPortControllerRevision, vlanIpAddress=vlanIpAddress, sysInfoInternalPowerState=sysInfoInternalPowerState, swPortRxMulticastFrames=swPortRxMulticastFrames, swPortTxCollIndex=swPortTxCollIndex, vlanMemberIndex=vlanMemberIndex, swPortRxRunts=swPortRxRunts, swPortTxExcessiveDeferrals=swPortTxExcessiveDeferrals, swPortTxQueueFullDiscards=swPortTxQueueFullDiscards, swPortBroadcastStormBlocked=swPortBroadcastStormBlocked, bandwidthUsageCurrentPeakEntry=bandwidthUsageCurrentPeakEntry, netMgmtEnableAuthenTraps=netMgmtEnableAuthenTraps, swPortMediaCapability=swPortMediaCapability, netMgmtConsolePasswordThresh=netMgmtConsolePasswordThresh, switchDiagnostic=switchDiagnostic, swPortClearStatistics=swPortClearStatistics, sysInfoRedundantPowerState=sysInfoRedundantPowerState, sysInfoBoardRevision=sysInfoBoardRevision, swPortEraseAddresses=swPortEraseAddresses, netMgmtSetClientIndex=netMgmtSetClientIndex, sysConfigTftpServerName=sysConfigTftpServerName, netMgmtHttpServerAdminState=netMgmtHttpServerAdminState, bandwidthUsagePeakIndex=bandwidthUsagePeakIndex, swPortName=swPortName, vlanIpSubnetMask=vlanIpSubnetMask, switchPortRxStatTable=switchPortRxStatTable, netMgmtConsoleSilentTime=netMgmtConsoleSilentTime, swPortRxFCSErrors=swPortRxFCSErrors, bridgeGroupMemberPorts=bridgeGroupMemberPorts, sysConfigPort25Connector=sysConfigPort25Connector, swPortTxBroadcastOctetsWraps=swPortTxBroadcastOctetsWraps, vlanStpAdmin=vlanStpAdmin, swPortRxStatEntry=swPortRxStatEntry, sysConfig10MbpsEnhancedCongestionControl=sysConfig10MbpsEnhancedCongestionControl, bridgeGroupMemberPortOfBridgeGroup=bridgeGroupMemberPortOfBridgeGroup, swPortACR=swPortACR, bandwidthUsagePeak=bandwidthUsagePeak, netMgmtIpSubnetMask=netMgmtIpSubnetMask, vlanName=vlanName, upgradeTFTPServerName=upgradeTFTPServerName, netMgmtHttpPort=netMgmtHttpPort, netMgmtSetClientStatus=netMgmtSetClientStatus, sysConfigBroadcastReEnableThreshold=sysConfigBroadcastReEnableThreshold, swPortTxLateCollisions=swPortTxLateCollisions, swPortBridgePriority=swPortBridgePriority, bridgeGroupMemberIndex=bridgeGroupMemberIndex, swPortRxBroadcastOctetsWraps=swPortRxBroadcastOctetsWraps, swPortMonitoring=swPortMonitoring, sysConfigAddressViolationAlert=sysConfigAddressViolationAlert, swPortStatus=swPortStatus, netMgmtModemDialString=netMgmtModemDialString, netMgmtSetClientAddr=netMgmtSetClientAddr, swPortTxBroadcastFrames=swPortTxBroadcastFrames, netMgmtDomainServer2IpAddress=netMgmtDomainServer2IpAddress, bandwidthUsagePeakTime=bandwidthUsagePeakTime, bridgeGroupTable=bridgeGroupTable, ipAddressChange=ipAddressChange, sysConfigPortGroupingMode=sysConfigPortGroupingMode, swPortTxBroadcastOctets=swPortTxBroadcastOctets, bridgeGroupMemberEntry=bridgeGroupMemberEntry, upgradeEPROMRevision=upgradeEPROMRevision, swPortIfIndex=swPortIfIndex, bridgeGroupIndex=bridgeGroupIndex, swPortRxTotalOctetsWraps=swPortRxTotalOctetsWraps, products=products, grandjunction=grandjunction, sysInfoConfigFileStatus=sysInfoConfigFileStatus, swPortTxMulticastFrames=swPortTxMulticastFrames, netMgmtDomainServer1IpAddress=netMgmtDomainServer1IpAddress, sysConfigClearPortStats=sysConfigClearPortStats, esModuleBasic=esModuleBasic, sysInfoFwdEngineRevision=sysInfoFwdEngineRevision, swPortLastStatus=swPortLastStatus, swPortRxMulticastOctets=swPortRxMulticastOctets, swPortTxMulticastOctetsWraps=swPortTxMulticastOctetsWraps, sysConfigBroadcastStormAlert=sysConfigBroadcastStormAlert, swPortTxStatIndex=swPortTxStatIndex, swPortTxExcessiveCollision4s=swPortTxExcessiveCollision4s, bridgeTemplateEntry=bridgeTemplateEntry, addressViolation=addressViolation, switchPortTxCollTable=switchPortTxCollTable, seriesG2xx=seriesG2xx, sysInfo=sysInfo, swPortJabberStatus=swPortJabberStatus, swPortNumberOfStaticAddresses=swPortNumberOfStaticAddresses, swPortRxUnicastOctetsWraps=swPortRxUnicastOctetsWraps, swPortDuplexStatus=swPortDuplexStatus, upgradeTFTPInitiate=upgradeTFTPInitiate, bridgeGroupMaxSupported=bridgeGroupMaxSupported, swPortLinkbeatLosses=swPortLinkbeatLosses, netMgmtEnableRIP=netMgmtEnableRIP, bridgeTemplateMaxAge=bridgeTemplateMaxAge, sysInfoPortDisabledDisplayMap=sysInfoPortDisabledDisplayMap, sysInfoNumberOfInstalledModules=sysInfoNumberOfInstalledModules, vlanIndex=vlanIndex, netMgmtCgmpEnable=netMgmtCgmpEnable, port=port, upgradeTFTPAccept=upgradeTFTPAccept, swPortTxDeferrals=swPortTxDeferrals, swPortRxUnicastFrames=swPortRxUnicastFrames, netMgmtTrapClientEntry=netMgmtTrapClientEntry, swPortRxBroadcastFrames=swPortRxBroadcastFrames, swPortTxErrors=swPortTxErrors, vlanMemberPortOfVlan=vlanMemberPortOfVlan, swPortFullDuplexFlowControl=swPortFullDuplexFlowControl, swPortHalfDuplexBackPressure=swPortHalfDuplexBackPressure, bridgeGroup=bridgeGroup, bandwidthUsagePeakTable=bandwidthUsagePeakTable, swPortJabbers=swPortJabbers, netMgmtSetClientTable=netMgmtSetClientTable, bridgeGroupAllowMembershipOverlap=bridgeGroupAllowMembershipOverlap, bandwidthUsagePeakEntry=bandwidthUsagePeakEntry, swPortFloodUnregisteredMulticasts=swPortFloodUnregisteredMulticasts, sysConfigHigherProtocolMonitor=sysConfigHigherProtocolMonitor, netMgmtTrapClientIndex=netMgmtTrapClientIndex, swPortFloodUnknownUnicasts=swPortFloodUnknownUnicasts, swPortTxUnicastOctets=swPortTxUnicastOctets, vlanMemberPortIndex=vlanMemberPortIndex, bridgeGroupEntry=bridgeGroupEntry, series2000=series2000, swPortTxTotalOctetsWraps=swPortTxTotalOctetsWraps, bridgeGroupMemberTable=bridgeGroupMemberTable, rpsFailed=rpsFailed, netMgmtTrapClientComm=netMgmtTrapClientComm, sysInfoNumberOfSwitchPorts=sysInfoNumberOfSwitchPorts, upgradeFlashSize=upgradeFlashSize, swPortNumberOfLearnedAddresses=swPortNumberOfLearnedAddresses, sysInfoAddrCapacity=sysInfoAddrCapacity, upgradeAutoExecute=upgradeAutoExecute, vlanMaxSupported=vlanMaxSupported, sysConfigSwitchingMode=sysConfigSwitchingMode, swPortTxSingleCollisions=swPortTxSingleCollisions, vlanBridgeTemplate=vlanBridgeTemplate, sysInfoPortFailedPOSTMap=sysInfoPortFailedPOSTMap, bridgeTemplatePriority=bridgeTemplatePriority, swPortIndex=swPortIndex, sysConfigBroadcastThreshold=sysConfigBroadcastThreshold, swPortTxCollEntry=swPortTxCollEntry, netMgmtConsoleInactTime=netMgmtConsoleInactTime, sysInfoRestrictedStaticAddrCapacity=sysInfoRestrictedStaticAddrCapacity, swPortType=swPortType, swPortBridgePathCost=swPortBridgePathCost, netMgmtTrapClientAddr=netMgmtTrapClientAddr, vlanMemberEntry=vlanMemberEntry, swPortTxUnicastOctetsWraps=swPortTxUnicastOctetsWraps, bridgeGroupMemberPortIndex=bridgeGroupMemberPortIndex, bridgeTemplateMax=bridgeTemplateMax, sysConfigFastEthcParmsPort=sysConfigFastEthcParmsPort, sysConfigBroadcastStormAction=sysConfigBroadcastStormAction, swPortTxTotalFrames=swPortTxTotalFrames, sysConfigReset=sysConfigReset, swPortRxFilteredFrames=swPortRxFilteredFrames, sysInfoUtilDisplay=sysInfoUtilDisplay, swPortTxExcessiveCollisions=swPortTxExcessiveCollisions)

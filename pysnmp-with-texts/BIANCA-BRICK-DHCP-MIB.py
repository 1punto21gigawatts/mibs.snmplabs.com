#
# PySNMP MIB module BIANCA-BRICK-DHCP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BRICK-DHCP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:38:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, ModuleIdentity, Counter64, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, IpAddress, Bits, TimeTicks, iso, ObjectIdentity, Unsigned32, MibIdentifier, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "Counter64", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "IpAddress", "Bits", "TimeTicks", "iso", "ObjectIdentity", "Unsigned32", "MibIdentifier", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
biboip = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 5))
class PhysAddress(OctetString):
    pass

class Date(Integer32):
    pass

ipDhcpTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 5, 8), )
if mibBuilder.loadTexts: ipDhcpTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpTable.setDescription('')
ipDhcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1), ).setIndexNames((0, "BIANCA-BRICK-DHCP-MIB", "ipDhcpIfIndex"))
if mibBuilder.loadTexts: ipDhcpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpEntry.setDescription('')
ipDhcpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDhcpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpIfIndex.setDescription('Index of interface where this range of IP addresses will be assigned to DHCP clients')
ipDhcpState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDhcpState.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpState.setDescription('')
ipDhcpFirst = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDhcpFirst.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpFirst.setDescription('First address of this range. There must exist a route to this address via this interface')
ipDhcpRange = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDhcpRange.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpRange.setDescription('Number of IP addresses that will be assigned starting from DhcpFirst. A range of 0 will disable this entry')
ipDhcpLease = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDhcpLease.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpLease.setDescription('amount of time (in minutes) a DHCP client can use an IP address assigned from this address range')
ipDhcpPhys = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1, 6), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDhcpPhys.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpPhys.setDescription('MAC address of host this single address should be assigned to. If ipDhcpPhys is not empty or different from 0:0:0:0:0:0, ipDhcpRange must be 1')
ipDhcpNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("bnode", 2), ("pnode", 3), ("mnode", 4), ("hnode", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDhcpNodeType.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpNodeType.setDescription('The NetBIOS end-node type according RFC 1001')
ipDhcpGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 8, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipDhcpGateway.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpGateway.setDescription('The Gateway which is told the clients upon requests. If this object equals 0.0.0.0 and DHCP client and server share the same network, the DHCP servers own address is returned upon request. If DHCP client and server do not share the same network, the address of the dhcp relay agent forwarding the request is returned.')
ipDhcpInUseTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 5, 9), )
if mibBuilder.loadTexts: ipDhcpInUseTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpInUseTable.setDescription('')
ipDhcpInUseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 5, 9, 1), ).setIndexNames((0, "BIANCA-BRICK-DHCP-MIB", "ipDhcpInUseAddress"))
if mibBuilder.loadTexts: ipDhcpInUseEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpInUseEntry.setDescription('')
ipDhcpInUseAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 9, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDhcpInUseAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpInUseAddress.setDescription('assigned IP address')
ipDhcpInUsePhys = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 9, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDhcpInUsePhys.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpInUsePhys.setDescription('MAC address of host')
ipDhcpInUseExpires = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 5, 9, 1, 3), Date()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDhcpInUseExpires.setStatus('mandatory')
if mibBuilder.loadTexts: ipDhcpInUseExpires.setDescription('End of Lease time. From then on, the host is not allowed to use this IP address any longer')
mibBuilder.exportSymbols("BIANCA-BRICK-DHCP-MIB", ipDhcpRange=ipDhcpRange, ipDhcpLease=ipDhcpLease, biboip=biboip, ipDhcpTable=ipDhcpTable, ipDhcpNodeType=ipDhcpNodeType, ipDhcpInUseEntry=ipDhcpInUseEntry, bintec=bintec, ipDhcpInUsePhys=ipDhcpInUsePhys, ipDhcpInUseExpires=ipDhcpInUseExpires, private=private, ipDhcpPhys=ipDhcpPhys, ipDhcpGateway=ipDhcpGateway, org=org, ipDhcpState=ipDhcpState, ipDhcpIfIndex=ipDhcpIfIndex, ipDhcpInUseTable=ipDhcpInUseTable, ipDhcpFirst=ipDhcpFirst, internet=internet, Date=Date, enterprises=enterprises, ipDhcpInUseAddress=ipDhcpInUseAddress, bibo=bibo, dod=dod, ipDhcpEntry=ipDhcpEntry, PhysAddress=PhysAddress)

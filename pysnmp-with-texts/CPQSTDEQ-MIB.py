#
# PySNMP MIB module CPQSTDEQ-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CPQSTDEQ-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
cpqHoTrapFlags, compaq = mibBuilder.importSymbols("CPQHOST-MIB", "cpqHoTrapFlags", "compaq")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
Counter32, ModuleIdentity, iso, TimeTicks, Gauge32, Unsigned32, ObjectIdentity, Bits, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, IpAddress, MibIdentifier, NotificationType, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "iso", "TimeTicks", "Gauge32", "Unsigned32", "ObjectIdentity", "Bits", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "IpAddress", "MibIdentifier", "NotificationType", "Counter64")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
cpqStdEquipment = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1))
cpqSeMibRev = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 1))
cpqSeComponent = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2))
cpqSeInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 1))
cpqSeProcessor = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 2))
cpqSeMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 3))
cpqSeIsaCmos = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 4))
cpqSeEisaNvram = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 5))
cpqSeRom = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 6))
cpqSeKeyboard = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 7))
cpqSeVideo = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 8))
cpqSeSerialPort = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 9))
cpqSeParallelPort = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 10))
cpqSeFloppyDisk = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 11))
cpqSeFixedDisk = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 12))
cpqSePci = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 13))
cpqSePCCard = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 14))
cpqSeUSBPort = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 15))
cpqSeCell = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 16))
cpqSeIOC = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 17))
cpqSePartition = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 18))
cpqSeCabinet = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 19))
cpqSeComplex = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 20))
cpqSeLED = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 21))
cpqSeUSBDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 22))
cpqSeOsCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4))
class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("false", 1), ("true", 2))

cpqSeMibRevMajor = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeMibRevMajor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeMibRevMajor.setDescription('The Major Revision level of the MIB. A change in the major revision level represents a major change in the architecture of the MIB. A change in the major revision level may indicate a significant change in the information supported and/or the meaning of the supported information, correct interpretation of data may require a MIB document with the same major revision level.')
cpqSeMibRevMinor = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeMibRevMinor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeMibRevMinor.setDescription('The Minor Revision level of the MIB. A change in the minor revision level may represent some minor additional support, no changes to any pre-existing information has occurred.')
cpqSeMibCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeMibCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeMibCondition.setDescription('The overall condition. This object represents the overall status of the server represented by this MIB.')
cpqSeOsCommonPollFreq = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqSeOsCommonPollFreq.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeOsCommonPollFreq.setDescription("The Insight Agent's polling frequency. The frequency, in seconds, at which the Insight Agent requests information from the device driver. A frequency of zero (0) indicates that the Insight Agent retrieves the information upon request of a management station, it does not poll the device driver at a specific interval. If the poll frequency is zero (0) all attempts to write to this object will fail. If the poll frequency is non-zero, setting this value will change the polling frequency of the Insight Agent. Setting the poll frequency to zero (0) will always fail, an agent may also choose to fail any request to change the poll frequency to a value that would severely impact system performance.")
cpqSeOsCommonModuleTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4, 2), )
if mibBuilder.loadTexts: cpqSeOsCommonModuleTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSeOsCommonModuleTable.setDescription('A table of software modules that provide an interface to the device this MIB describes.')
cpqSeOsCommonModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4, 2, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeOsCommonModuleIndex"))
if mibBuilder.loadTexts: cpqSeOsCommonModuleEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSeOsCommonModuleEntry.setDescription('A description of a software module that provides an interface to the device this MIB describes.')
cpqSeOsCommonModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeOsCommonModuleIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSeOsCommonModuleIndex.setDescription('A unique index for this module description.')
cpqSeOsCommonModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeOsCommonModuleName.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSeOsCommonModuleName.setDescription('The module name.')
cpqSeOsCommonModuleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeOsCommonModuleVersion.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSeOsCommonModuleVersion.setDescription('The module version in XX.YY format. Where XX is the major version number and YY is the minor version number. This field will be a null (size 0) string if the agent cannot provide the module version.')
cpqSeOsCommonModuleDate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeOsCommonModuleDate.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSeOsCommonModuleDate.setDescription('The module date. field octets contents range ===== ====== ======= ===== 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minute 0..59 6 7 second 0..60 (use 60 for leap-second) This field will be set to year = 0 if the agent cannot provide the module date. The hour, minute, and second field will be set to zero (0) if they are not relevant. The year field is set with the most significant octet first.')
cpqSeOsCommonModulePurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 1, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeOsCommonModulePurpose.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSeOsCommonModulePurpose.setDescription('The purpose of the module described in this entry.')
cpqSeCpuTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1), )
if mibBuilder.loadTexts: cpqSeCpuTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuTable.setDescription('A list of the CPUs (processors) in the system. The main processor (if such a concept is valid for this machine) should be the first entry in the table.')
cpqSeCpuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeCpuUnitIndex"))
if mibBuilder.loadTexts: cpqSeCpuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuEntry.setDescription('A description of a CPU (processor) in the system.')
cpqSeCpuUnitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuUnitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuUnitIndex.setDescription('This is a number that uniquely specifies a processor unit. A processing unit may be a set of processing chips that are on the same board or for other reasons work together as a unit. The main processor unit (if such a concept is valid for this machine) will always have the lowest (first) index.')
cpqSeCpuSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuSlot.setDescription("This value represents this processor's slot. If the slot cannot be determined the value of zero (0) will be returned.")
cpqSeCpuName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuName.setDescription('The name of this processor. For example: 80386')
cpqSeCpuSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuSpeed.setDescription('The current internal speed of this processor in megahertz. This changes as per the processor performance state Zero will be returned if this value is not available.')
cpqSeCpuStep = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuStep.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuStep.setDescription('This step of the processor. This will be zero (0) if the step cannot be determined.')
cpqSeCpuStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("ok", 2), ("degraded", 3), ("failed", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuStatus.setDescription('The status of the processor. The following values are valid for CPU status: Unknown (1) The status of the CPU could not be determined. OK (2) The CPU is functioning normally. Degraded (3) The CPU is in a pre-failure warrantee state. Failed (4) The CPU is in a failed state. Disabled (5) The CPU has been disabled during power-on-self-test.')
cpqSeCpuExtSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuExtSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuExtSpeed.setDescription('This is the external frequency in megahertz of the processor bus. Zero will be returned if this value is not available.')
cpqSeCpuDesigner = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("unknown", 1), ("intel", 2), ("amd", 3), ("cyrix", 4), ("ti", 5), ("nexgen", 6), ("compaq", 7), ("samsung", 8), ("mitsubishi", 9), ("mips", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuDesigner.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuDesigner.setDescription('This attribute specifies the manufacturer which designs this CPU.')
cpqSeCpuSocketNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuSocketNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuSocketNumber.setDescription('The physical socket number of the CPU chip. This number helps to identify CPUs on processor boards that contain multiple CPU chips. In most cases the CPU Socket number should be specified on the board silkscreen or in product documentation.')
cpqSeCpuThreshPassed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unsupported", 1), ("false", 2), ("true", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuThreshPassed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuThreshPassed.setDescription('CPU threshold passed (Exceeded). When this attribute is set to true, it identifies a pre-failure error condition. Processors like the Intel Pentium Pro have the capability built into them to correct internal error conditions. Excessive corrected internal errors can predict future hard processor failures. Agent instrumentation will set this attribute to true if an internal processor error threshold is passed. It is recommended that the user replace the CPU in this case. If the processor does not support monitoring internal corrected errors, this value will be set to unsupported. ')
cpqSeCpuHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the CPU. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSeCpuCellTablePtr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCellTablePtr.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuCellTablePtr.setDescription('This is the index for the cell in cpqSeCellTable where this CPU is physically located.')
cpqSeCpuPowerpodStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notfailed", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuPowerpodStatus.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuPowerpodStatus.setDescription('This is the status of CPU power pod. Potential values in the future could be present/not present.')
cpqSeCpuArchitectureRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuArchitectureRevision.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuArchitectureRevision.setDescription('This is the CPU architecture revision.')
cpqSeCpuCore = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCore.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuCore.setDescription('The number of cores in this CPU module. Zero will be returned if can not be determined.')
cpqSeCPUSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUSerialNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUSerialNumber.setDescription('The OEM serial number of the CPU.')
cpqSeCPUPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUPartNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUPartNumber.setDescription('The OEM part number of the CPU.')
cpqSeCPUSerialNumberMfgr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUSerialNumberMfgr.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUSerialNumberMfgr.setDescription('The manufacturer serial number of the CPU.')
cpqSeCPUPartNumberMfgr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUPartNumberMfgr.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUPartNumberMfgr.setDescription('The manufacturer part number of the CPU.')
cpqSeCPUCoreIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUCoreIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUCoreIndex.setDescription('This is a number that uniquely identifies a core in a CPU unit.')
cpqSeCPUMaxSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUMaxSpeed.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUMaxSpeed.setDescription('This is the maximum internal speed in megahertz this processor can support. Zero will be returned if this value is not available.')
cpqSeCPUCoreThreadIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUCoreThreadIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUCoreThreadIndex.setDescription('This is an unique number to identify the running threads in a CPU core.')
cpqSeCPUChipGenerationName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUChipGenerationName.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUChipGenerationName.setDescription('CPU chip generation name e.g. Hondo, Montecito, Madison, Opteron.')
cpqSeCPUMultiThreadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUMultiThreadStatus.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUMultiThreadStatus.setDescription('This OID identifies whether the CPU threading is enabled or not.')
cpqSeCPUCoreMaxThreads = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCPUCoreMaxThreads.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCPUCoreMaxThreads.setDescription('This OID indicates the maximum number of threads that a cpu core is capable of.')
cpqSeCpuLowPowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("lowpowered", 2), ("normalpowered", 3), ("highpowered", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuLowPowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuLowPowerStatus.setDescription('Servers like Itanium has capability to lower power supply to CPU if it is idle for specified period of time. Proliant servers can set to high/low/Dynamic mode of power through ILO. The following values are valid for CPU Low Powered state: Unknown (1) The Low Powered status could not be determined. Low Powered (2) The CPU is Low Power state. Normal Powered (3) The CPU is normal Power state. High Powered (4) The CPU is High Power state.')
cpqSeCpuPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("false", 2), ("true", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuPrimary.setDescription('On SMP systems one of the CPU is set to Primary and the other CPUs as secondary. A value of true is set if the CPU is primary. The following values are valid for CPU availability status: Unknown (1) The CPU Primary/Secondary could not be determined. false (2) The CPU is not primary CPU. True (3) The CUR is primary CPU.')
cpqSeCpuCoreSteppingText = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 28), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCoreSteppingText.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuCoreSteppingText.setDescription('The processor stepping version string. A NULL string indicates that the stepping could not be determined.')
cpqSeCpuCurrentPerformanceState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCurrentPerformanceState.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuCurrentPerformanceState.setDescription('This OID returns the current performance state of this processor. Processor performance states are denoted as Pn states. The value of n is cpqSeCpuPerformanceState. The higher the value n is, the lower the performance state is being used. Value 0 describes the highest performance state, in which the processor uses its maximum performance capability and may consume maximum power. The performance state number should not exceed 16 on Itanium servers. (-1) will be returned if this value is not available.')
cpqSeCpuMinPerformanceState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuMinPerformanceState.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuMinPerformanceState.setDescription('This OID returns the minimum performance state set for this processor. (-1) will be returned if this value is not available.')
cpqSeCpuMaxPerformanceState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuMaxPerformanceState.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuMaxPerformanceState.setDescription('This OID returns the maximum performance state set for this processor. (-1) will be returned if this value is not available.')
cpqSeFpuTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2), )
if mibBuilder.loadTexts: cpqSeFpuTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFpuTable.setDescription('A list of the FPUs (floating point coprocessors) in the system.')
cpqSeFpuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeFpuUnitIndex"), (0, "CPQSTDEQ-MIB", "cpqSeFpuChipIndex"))
if mibBuilder.loadTexts: cpqSeFpuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFpuEntry.setDescription('A description of a FPU in the system. The fpuUnitIndex of any entry in this table will equal the cpuUnitIndex of the corresponding CPU in the cpqSeCpu table.')
cpqSeFpuUnitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFpuUnitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFpuUnitIndex.setDescription('This is a number that uniquely specifies a processor unit. A processing unit may be a set of processing chips that are on the same board or for other reasons work together as a unit. The main processor unit (if there is one) will always have the lowest (first) index. This field can be used to associate CPUs with their corresponding FPUs.')
cpqSeFpuChipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFpuChipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFpuChipIndex.setDescription("This is a number that uniquely specifies the FPU chip. This field is used to distinguish between multiple FPUs that are part of the same processor unit. For example, If a processor board contained a Intel 80386 processor with both a Intel 80387 and a Weitek 3167, both the 80387 and the 3167 would have the same fpuUnitIndex (which would match the 80386's cpuUnitIndex) but the 80387 and the 3167 would have different fpuChipIndex field values.")
cpqSeFpuSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFpuSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFpuSlot.setDescription("This is the FPU's slot. If the slot cannot be determined the value of zero (0) will be returned.")
cpqSeFpuName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFpuName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFpuName.setDescription('This is the name of the FPU. For example: 80387 Weitek 3167')
cpqSeFpuSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFpuSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFpuSpeed.setDescription('This is speed in megahertz of the FPU. Zero will be returned if this value is not available.')
cpqSeFpuType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("embedded", 2), ("external", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFpuType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFpuType.setDescription('This value indicates if the FPU this entry is describing is embedded in the CPU or external to the CPU chip.')
cpqSeFpuHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFpuHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeFpuHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the FPU. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSeCpuCacheTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3), )
if mibBuilder.loadTexts: cpqSeCpuCacheTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuCacheTable.setDescription('A list of the CPU caches in the system.')
cpqSeCpuCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeCpuCacheUnitIndex"), (0, "CPQSTDEQ-MIB", "cpqSeCpuCacheLevelIndex"))
if mibBuilder.loadTexts: cpqSeCpuCacheEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuCacheEntry.setDescription('A description of a CPU Caches in the system.')
cpqSeCpuCacheUnitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheUnitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuCacheUnitIndex.setDescription('This is a number that uniquely specifies a processor unit. A processing unit may be a set of processing chips that are on the same board or for other reasons work together as a unit. The main processor unit (if such a concept is valid for this machine) will always have the lowest (first) index.')
cpqSeCpuCacheLevelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheLevelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuCacheLevelIndex.setDescription('This is the processor cache level. The lower the processor cache level, the closer the cache is to the processor.')
cpqSeCpuCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuCacheSize.setDescription('The size of the cache in kilobytes.')
cpqSeCpuCacheSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuCacheSpeed.setDescription('This is speed in cache memory in nanoseconds (ns). A value of zero (0) means that the cache speed is unknown or unobtainable.')
cpqSeCpuCacheStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuCacheStatus.setDescription('The status of the cache unit. If the cache is optional and not installed, unknown(1) will be returned.')
cpqSeCpuCacheWritePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("write-through", 2), ("write-back", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheWritePolicy.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeCpuCacheWritePolicy.setDescription('Specifies write policy of this cache entry.')
cpqSeCpuCacheHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuCacheHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the CPU cache. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSeCpuCacheCpuSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheCpuSlot.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuCacheCpuSlot.setDescription('This is the CPU Slot associated with this CPU cache.')
cpqSeCpuCacheCpuCoreIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 2, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCpuCacheCpuCoreIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCpuCacheCpuCoreIndex.setDescription('This is a unique number that identifies the core in the CPU slot to which this cache is associated. If the cache is not associated with any core on a multi-core CPU, the value should be -1.')
cpqSeBaseMem = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeBaseMem.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeBaseMem.setDescription('The amount of base memory in kilobytes. A kilobyte is 1024 bytes.')
cpqSeTotalMem = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeTotalMem.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeTotalMem.setDescription('The total amount of memory in kilobytes. A kilobyte is 1024 bytes.')
cpqSeTotalMemMB = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeTotalMemMB.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeTotalMemMB.setDescription('The total amount of memory in megabytes. A megabyte is 1024 kilobytes.')
cpqSeIsaCmosRaw = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 4, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeIsaCmosRaw.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeIsaCmosRaw.setDescription('The contents of the ISA CMOS.')
cpqSeEisaSlotTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 1), )
if mibBuilder.loadTexts: cpqSeEisaSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaSlotTable.setDescription('A list of EISA slot information entries.')
cpqSeEisaSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeEisaSlotIndex"))
if mibBuilder.loadTexts: cpqSeEisaSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaSlotEntry.setDescription('A description of an EISA slot.')
cpqSeEisaSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaSlotIndex.setDescription('The EISA slot number for this entry describes.')
cpqSeEisaSlotRaw = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaSlotRaw.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaSlotRaw.setDescription('The EISA slot data for the board in this slot. This octet string contains the following EISA slot information: The first octet will be zero (0) if this slot contains a properly configured board. Any other value indicates that the EISA configuration information for this board is invalid or an error occurred when trying to retrieve the information. The second octet contains several bit flags about the product ID and slot type. Bit 7: 0 = No duplicate ID 1 = Duplicate IDs Bit 6: 0 = Product ID readable 1 = Product ID not readable Bit 5,4: 00 = Expansion slot 01 = Embedded device 10 = Virtual device 11 = Reserved Bit 3..0: This nibble indicates which CFG file is loaded when duplicate file names are present. 0000 = No duplicate ID 0001 = First duplicate ID 0010 = Second duplicate ID 0011 = Third duplicate ID . . . 1111 = Fifteenth duplicate ID NOTE: Bit 7 is the most significant bit, bit 0 is the least significant. The third octet contains the major revision level of the configuration utility. The fourth octet contains the minor revision level of the configuration utility. The fifth octet contains the most significant byte of the configuration file checksum. The sixth octet contains the least significant byte of the configuration file checksum. The seventh octet contains the number of device functions defined for the board in this slot. The eighth octet contains the combined function information. This is a set of flags. Each bit has the following meaning when set (1): Bit 7: reserved (0) Bit 6: slot has one or more free form data entries Bit 5: slot has one or more port initialization entries. Bit 4: slot has one or more port range entries. Bit 3: slot has one or more DMA entries. Bit 2: slot has one or more interrupt (IRQ) entries. Bit 1: slot has one or more memory entries. Bit 0: slot has one or more function type definitions. NOTE: bit 7 is the most significant bit, bit 0 is the least significant. The ninth, tenth, eleventh, and twelfth octets contain the four byte compressed EISA ID. For more information about the meaning of this information consult the EISA Technical Reference Guide.')
cpqSeEisaSlotBoardId = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaSlotBoardId.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaSlotBoardId.setDescription('A seven character board ID. The first three characters are the manufacturers ID followed by three character product ID followed by a one character revision level.')
cpqSeEisaSlotBoardName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaSlotBoardName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaSlotBoardName.setDescription('The product name (or other suitable description) of this board. This field may be empty if no descriptive information is known about the board.')
cpqSeEisaSlotCfRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaSlotCfRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaSlotCfRev.setDescription('The revision level of the EISA configuration utility that was used to configure the system. This should be the same version information displayed by the EISA configuration utility.')
cpqSeEisaSlotType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("isa8Bit", 2), ("isa16Bit", 3), ("eisa32Bit", 4), ("eisaBusMaster32Bit", 5), ("other", 6), ("reserved", 7), ("reserved2", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaSlotType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaSlotType.setDescription('The type of slot described by this entry.')
cpqSeEisaFunctTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2), )
if mibBuilder.loadTexts: cpqSeEisaFunctTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctTable.setDescription('A list EISA function information entries.')
cpqSeEisaFunctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeEisaFunctSlotIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaFunctIndex"))
if mibBuilder.loadTexts: cpqSeEisaFunctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctEntry.setDescription('A description of an EISA function.')
cpqSeEisaFunctSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFunctSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctSlotIndex.setDescription('The EISA slot of the board that registered this function')
cpqSeEisaFunctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFunctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctIndex.setDescription('The number of the function this entry describes.')
cpqSeEisaFunctStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFunctStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctStatus.setDescription('The status of the function described by this entry.')
cpqSeEisaFunctType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFunctType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctType.setDescription('The type of the function. The type may be followed by one or more subtype description fields. Some currently defined types are: Type Meaning ============== ================================================== COM Communication device COM,ASY ISA compatible 8250 based serial port COM,ASY,FIFO ISA compatible 16550 based serial port (with fifo) COM,SYN ISA compatible SDLC port CPU Microprocessor CPU,8086 8086 compatible microprocessor CPU,80286 80286 compatible microprocessor CPU,80386SX 80386SX compatible microprocessor CPU,80386 80386 compatible microprocessor CPU,80486 80486 compatible microprocessor JOY ISA compatible joystick adapter KEY Keyboard KEY,nnn,KBD=xx Standard keyboard with nnn keys for country xx MEM Memory board MFC Multifunction board MSD Mass storage device MSD,DSKCTL ISA compatible fixed disk controller MSD,FPYCTL ISA compatible floppy disk controller MSD,TAPCTL Primary tape controller NET Network board NPX Numeric coprocessor NPX,287 Intel 287 numeric coprocessor NPX,387 Intel 387 numeric coprocessor NPX,387SX Intel 387SX numeric coprocessor NPX,W1167 Weitek 1167 numeric coprocessor NPX,W3167 Weitek 3167 numeric coprocessor OSE Operating system/environment OTH Other PAR ISA compatible parallel port PAR,BID Bidirectional parallel port PTR Pointing device PTR,8042 8042 pointing device (mouse) interface SYS System board VID Video board VID,MDA ISA compatible monochrome adapter VID,MDA,MGA Hercules monochrome adapter VID,CGA CGA, no write sync during retrace required VID,CGA,RTR CGA, write sync during retrace required VID,EGA ISA compatible EGA adapter VID,VGA ISA compatible VGA adapter This list is not intended to be complete. Other types may be found in this field. This list describes some of the more common types found, other types should be similarly recognizable to someone sufficiently knowledgeable about computer hardware.')
cpqSeEisaFunctCfgRev = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFunctCfgRev.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctCfgRev.setDescription('The revision of the EISA configuration .OVL file used to configure this board.')
cpqSeEisaFunctSels = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 26))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFunctSels.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctSels.setDescription('The selections that were chosen with the EISA CONFIGURATION UTILITY to create this function.')
cpqSeEisaFunctInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFunctInfo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFunctInfo.setDescription('The EISA function information block. This is a set of flags indicating the resources that are configured in this EISA function. Each bit has the following meaning when it is set (1): Bit 7: Function is disabled Bit 6: This function contains free-form information. Bit 5: This function contains port initialization entries. Bit 4: This function contains port range entries. Bit 3: This function contains DMA entries. Bit 2: This function contains interrupt (IRQ) entries. Bit 1: This function contains memory entries. Bit 0: This function contains function type definitions. NOTE: bit 7 is the most significant bit, bit 0 is the least significant.')
cpqSeEisaMemTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3), )
if mibBuilder.loadTexts: cpqSeEisaMemTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemTable.setDescription('A list of EISA function memory configuration entries.')
cpqSeEisaMemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeEisaMemSlotIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaMemFunctIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaMemAllocIndex"))
if mibBuilder.loadTexts: cpqSeEisaMemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemEntry.setDescription('A description of an EISA function memory configuration.')
cpqSeEisaMemSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemSlotIndex.setDescription('The EISA slot number of the board that registered the memory configuration this entry describes.')
cpqSeEisaMemFunctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemFunctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemFunctIndex.setDescription('The function in which this memory configuration was registered.')
cpqSeEisaMemAllocIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemAllocIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemAllocIndex.setDescription('The index for this memory allocation entry in the EISA function block.')
cpqSeEisaMemStartAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemStartAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemStartAddr.setDescription('The starting address of the memory configuration.')
cpqSeEisaMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemSize.setDescription('The size in bytes of the memory configuration.')
cpqSeEisaMemShare = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonshareable", 1), ("shareable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemShare.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemShare.setDescription('This value indicates if the memory is shareable.')
cpqSeEisaMemType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("systemBaseOrExtended", 1), ("expanded", 2), ("virtual", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemType.setDescription('The type of memory.')
cpqSeEisaMemCache = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notCached", 1), ("writeThroughCached", 2), ("writeBackCached", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemCache.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemCache.setDescription('This value indicates if the memory is cached.')
cpqSeEisaMemAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemAccess.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemAccess.setDescription('The type of access permitted for this memory.')
cpqSeEisaMemDecode = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemDecode.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemDecode.setDescription('The memory decode size (the number of address lines supported).')
cpqSeEisaMemDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaMemDataSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaMemDataSize.setDescription('The data access size for the memory in bits.')
cpqSeEisaIntTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 4), )
if mibBuilder.loadTexts: cpqSeEisaIntTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaIntTable.setDescription('A list of EISA function interrupt configuration entries.')
cpqSeEisaIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 4, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeEisaIntSlotIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaIntFunctIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaIntAllocIndex"))
if mibBuilder.loadTexts: cpqSeEisaIntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaIntEntry.setDescription('A description of an EISA function interrupt configuration.')
cpqSeEisaIntSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaIntSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaIntSlotIndex.setDescription('The EISA slot number of the board that registered the interrupt configuration this entry describes.')
cpqSeEisaIntFunctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaIntFunctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaIntFunctIndex.setDescription('The function in which this interrupt configuration was registered.')
cpqSeEisaIntAllocIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaIntAllocIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaIntAllocIndex.setDescription('The index for this interrupt allocation entry in the EISA function block.')
cpqSeEisaIntNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaIntNum.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaIntNum.setDescription('The interrupt described in this entry.')
cpqSeEisaIntShare = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonshareable", 1), ("shareable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaIntShare.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaIntShare.setDescription('This value indicates if the interrupt is shareable.')
cpqSeEisaIntTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("edge", 1), ("level", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaIntTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaIntTrigger.setDescription('This value indicates if the interrupt is edge or level triggered.')
cpqSeEisaDmaTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5), )
if mibBuilder.loadTexts: cpqSeEisaDmaTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaTable.setDescription('A list of EISA function DMA configuration entries.')
cpqSeEisaDmaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeEisaDmaSlotIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaDmaFunctIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaDmaAllocIndex"))
if mibBuilder.loadTexts: cpqSeEisaDmaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaEntry.setDescription('A description of an EISA function DMA configuration.')
cpqSeEisaDmaSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaDmaSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaSlotIndex.setDescription('The EISA slot number of the board that registered the DMA configuration this entry describes.')
cpqSeEisaDmaFunctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaDmaFunctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaFunctIndex.setDescription('The function in which this DMA configuration was registered.')
cpqSeEisaDmaAllocIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaDmaAllocIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaAllocIndex.setDescription('The index for this DMA channel allocation entry in the EISA function block.')
cpqSeEisaDmaChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaDmaChannel.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaChannel.setDescription('The DMA channel described in this entry.')
cpqSeEisaDmaShare = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonshareable", 1), ("shareable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaDmaShare.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaShare.setDescription('This value indicates if the DMA channel is shareable.')
cpqSeEisaDmaTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("isaTiming", 1), ("typeA", 2), ("typeB", 3), ("burstTypeC", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaDmaTiming.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaTiming.setDescription('This value indicates the timing (transfer rate) associated with this configuration of the DMA channel.')
cpqSeEisaDmaXfer = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaDmaXfer.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaXfer.setDescription('This value indicates the transfer size in bits used over this DMA channel.')
cpqSeEisaDmaXferCount = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("byte", 1), ("word", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaDmaXferCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaDmaXferCount.setDescription('This value indicates the addressing scheme for the DMA channel.')
cpqSeEisaPortTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 6), )
if mibBuilder.loadTexts: cpqSeEisaPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaPortTable.setDescription('A list of EISA function port I/O configuration entries.')
cpqSeEisaPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 6, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeEisaPortSlotIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaPortFunctIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaPortAllocIndex"))
if mibBuilder.loadTexts: cpqSeEisaPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaPortEntry.setDescription('A description of an EISA function port I/O configuration.')
cpqSeEisaPortSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaPortSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaPortSlotIndex.setDescription('The EISA slot number of the board that registered the I/O port configuration this entry describes.')
cpqSeEisaPortFunctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaPortFunctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaPortFunctIndex.setDescription('The function in which this port I/O configuration was registered.')
cpqSeEisaPortAllocIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaPortAllocIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaPortAllocIndex.setDescription('The index for this I/O port range allocation entry in the EISA function block.')
cpqSeEisaPortAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaPortAddr.setDescription('The I/O port address being described in this entry.')
cpqSeEisaPortShare = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonshareable", 1), ("shareable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaPortShare.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaPortShare.setDescription('This value indicates if the port is shareable.')
cpqSeEisaPortSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaPortSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaPortSize.setDescription('The number of sequential ports starting at the eisaPortAddrIndex that are be configured.')
cpqSeEisaFreeFormTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 7), )
if mibBuilder.loadTexts: cpqSeEisaFreeFormTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFreeFormTable.setDescription('A list of EISA function free form entries.')
cpqSeEisaFreeFormEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 7, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeEisaFreeFormSlotIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaFreeFormFunctIndex"))
if mibBuilder.loadTexts: cpqSeEisaFreeFormEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFreeFormEntry.setDescription('A description of an EISA function free form.')
cpqSeEisaFreeFormSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFreeFormSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFreeFormSlotIndex.setDescription('The EISA slot number of the board that registered the free form information this entry describes.')
cpqSeEisaFreeFormFunctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFreeFormFunctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFreeFormFunctIndex.setDescription('The function in which this free form was registered.')
cpqSeEisaFreeFormValue = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 7, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 205))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaFreeFormValue.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaFreeFormValue.setDescription('The free form value.')
cpqSeEisaInitTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8), )
if mibBuilder.loadTexts: cpqSeEisaInitTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitTable.setDescription('A list of EISA function port initialization entries.')
cpqSeEisaInitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeEisaInitSlotIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaInitFunctIndex"), (0, "CPQSTDEQ-MIB", "cpqSeEisaInitAllocIndex"))
if mibBuilder.loadTexts: cpqSeEisaInitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitEntry.setDescription('A description of an EISA function port initialization.')
cpqSeEisaInitSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaInitSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitSlotIndex.setDescription('The EISA slot number of the board that registered the port initialization this entry describes.')
cpqSeEisaInitFunctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaInitFunctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitFunctIndex.setDescription('The function in which this port initialization was registered.')
cpqSeEisaInitAllocIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaInitAllocIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitAllocIndex.setDescription('The index for this port initialization entry in the EISA function block.')
cpqSeEisaInitUseMask = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("useValueOnly", 1), ("useValueAndMask", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaInitUseMask.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitUseMask.setDescription('This indicates if a mask will be used when performing initialization.')
cpqSeEisaInitAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("eightBitAddress", 2), ("sixteenBitAddress", 3), ("thirtyTwoBitAddress", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaInitAccess.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitAccess.setDescription('This value indicates the number of bits this entry initializes.')
cpqSeEisaInitAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaInitAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitAddr.setDescription('This value indicates the port address this entry initializes.')
cpqSeEisaInitValue = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaInitValue.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitValue.setDescription('This indicates the value to which this port is initialized.')
cpqSeEisaInitMask = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 5, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeEisaInitMask.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeEisaInitMask.setDescription('This value indicates the mask to use when performing initialization.')
cpqSeSysRomVer = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeSysRomVer.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeSysRomVer.setDescription('System ROM version information.')
cpqSeOptRomTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 2), )
if mibBuilder.loadTexts: cpqSeOptRomTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeOptRomTable.setDescription('A table of option ROM descriptions.')
cpqSeOptRomEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 2, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeOptRomAddrIndex"))
if mibBuilder.loadTexts: cpqSeOptRomEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeOptRomEntry.setDescription('An option ROM description.')
cpqSeOptRomAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeOptRomAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeOptRomAddrIndex.setDescription('The starting address of the option ROM. This value indicates the number of bytes from the start of physical memory to the beginning of this option ROM.')
cpqSeOptRomSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeOptRomSize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeOptRomSize.setDescription('The size in bytes of the option ROM.')
cpqSeBiosRomDataRaw = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeBiosRomDataRaw.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeBiosRomDataRaw.setDescription('The BIOS ROM data area. This may be the current contents or a copy of the BIOS ROM data area from when the Insight Agent was initialized.')
cpqSeRedundantSysRomVer = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeRedundantSysRomVer.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeRedundantSysRomVer.setDescription('System ROM version information for the redundant ROM image. This will be left blank if the system does not support a redundant ROM.')
cpqSeSmbiosVer = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeSmbiosVer.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeSmbiosVer.setDescription('SMBIOS version information.')
cpqSeMPFwVer = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeMPFwVer.setStatus('optional')
if mibBuilder.loadTexts: cpqSeMPFwVer.setDescription('The version of Management Processor Firmware.')
cpqSeBMCFwVer = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeBMCFwVer.setStatus('optional')
if mibBuilder.loadTexts: cpqSeBMCFwVer.setDescription('The version of the manageability firmware.')
cpqSeHPVMFwVer = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 6, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeHPVMFwVer.setStatus('optional')
if mibBuilder.loadTexts: cpqSeHPVMFwVer.setDescription('The version of the virtual machine firmware.')
cpqSeKeyboardDesc = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 7, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeKeyboardDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeKeyboardDesc.setDescription('A description of the keyboard.')
cpqSeVideoDesc = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 8, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeVideoDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeVideoDesc.setDescription('A description of the video system in the computer. This may include the manufacturer, board name, modes supported, etc..')
cpqSeSerialPortTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 9, 1), )
if mibBuilder.loadTexts: cpqSeSerialPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeSerialPortTable.setDescription('A table of serial port descriptions.')
cpqSeSerialPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 9, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeSerialPortIndex"))
if mibBuilder.loadTexts: cpqSeSerialPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeSerialPortEntry.setDescription('A description of a serial port.')
cpqSeSerialPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeSerialPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeSerialPortIndex.setDescription('An index that uniquely specifies this entry.')
cpqSeSerialPortAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 9, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeSerialPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeSerialPortAddr.setDescription('The I/O port address used by this serial port.')
cpqSeSerialPortDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 9, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeSerialPortDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeSerialPortDesc.setDescription('A text description of further information known about the serial port. This may be an empty string if no further information is known.')
cpqSeSerialPortHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 9, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeSerialPortHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeSerialPortHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the serial port. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSeParallelPortTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 10, 1), )
if mibBuilder.loadTexts: cpqSeParallelPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeParallelPortTable.setDescription('A table of parallel port descriptions.')
cpqSeParallelPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 10, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeParallelPortIndex"))
if mibBuilder.loadTexts: cpqSeParallelPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeParallelPortEntry.setDescription('A description of a parallel port.')
cpqSeParallelPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeParallelPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeParallelPortIndex.setDescription('An index that uniquely specifies this entry.')
cpqSeParallelPortAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 10, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeParallelPortAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeParallelPortAddr.setDescription('The I/O port address used by this parallel port.')
cpqSeParallelPortDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 10, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeParallelPortDesc.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeParallelPortDesc.setDescription('A text description of further information known about the parallel port. This may be an empty string if no further information is known.')
cpqSeParrallelPortHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 10, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeParrallelPortHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeParrallelPortHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the parallel port. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSeFloppyDiskTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 11, 1), )
if mibBuilder.loadTexts: cpqSeFloppyDiskTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFloppyDiskTable.setDescription('A table of floppy drive descriptions.')
cpqSeFloppyDiskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 11, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeFloppyDiskIndex"))
if mibBuilder.loadTexts: cpqSeFloppyDiskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFloppyDiskEntry.setDescription('A floppy drive description.')
cpqSeFloppyDiskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFloppyDiskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFloppyDiskIndex.setDescription('An index that uniquely specifies this entry. If possible, this field will map directly to the drive letter (0 for A:, 1 for B:).')
cpqSeFloppyDiskType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("drive360k", 2), ("drive1200k", 3), ("drive720k", 4), ("drive1440k", 5), ("drive120mb", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFloppyDiskType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFloppyDiskType.setDescription('The type (capacity) of the floppy drive. The following values are valid: other (1) This floppy drive could not be identified. drive360k (2) This is a 360 kilobyte, 5.25 inch floppy drive. drive1200k (3) This is a 1.2 megabyte, 5.25 inch floppy drive. drive720k (4) This is a 720 kilobyte, 3.5 inch floppy drive. drive1440k (5) This is a 1.44 megabyte, 3.5 inch floppy drive. drive120mb(6) This is a 120 megabyte, 3.5 inch floptical drive.')
cpqSeFloppyDiskHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 11, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFloppyDiskHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeFloppyDiskHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the floppy disk. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSeFixedDiskTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1), )
if mibBuilder.loadTexts: cpqSeFixedDiskTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFixedDiskTable.setDescription('A table of ST-506 interface accessible fixed disk descriptions.')
cpqSeFixedDiskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeFixedDiskIndex"))
if mibBuilder.loadTexts: cpqSeFixedDiskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFixedDiskEntry.setDescription('A fixed disk description.')
cpqSeFixedDiskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFixedDiskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFixedDiskIndex.setDescription('An index that uniquely specifies this entry. Each possible index value indicates a specific drive as shown in the table below: fixedDiskIndex IDE/ESDI Controller Drive Unit ============= =================== ========== 0 Primary 1 1 Primary 2 2 Secondary 1 3 Secondary 2 Any other index value would be implementation specific.')
cpqSeFixedDiskType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFixedDiskType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFixedDiskType.setDescription('The drive type.')
cpqSeFixedDiskCyls = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFixedDiskCyls.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFixedDiskCyls.setDescription('The number of cylinders on the drive.')
cpqSeFixedDiskHeads = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFixedDiskHeads.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFixedDiskHeads.setDescription('The number of heads on the drive.')
cpqSeFixedDiskSectors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFixedDiskSectors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFixedDiskSectors.setDescription('The number of sectors per track on the drive.')
cpqSeFixedDiskCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFixedDiskCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeFixedDiskCapacity.setDescription('The capacity of the drive in megabytes.')
cpqSeFixedDiskHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 12, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeFixedDiskHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeFixedDiskHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the fixed disk. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSePciSlotTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1), )
if mibBuilder.loadTexts: cpqSePciSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotTable.setDescription('A list of PCI slot information entries.')
cpqSePciSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSePciSlotBusNumberIndex"), (0, "CPQSTDEQ-MIB", "cpqSePciSlotDeviceNumberIndex"))
if mibBuilder.loadTexts: cpqSePciSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotEntry.setDescription('A description of a PCI slot.')
cpqSePciSlotBusNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotBusNumberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotBusNumberIndex.setDescription('A number that uniquely identifies this device on its PCI bus. Values greater than 255 are considered dummy bus numbers for empty PCI slots. For systems supporting multiple PCI segments, the segment number will be encoded into the middle word of this value (Bit8 to Bit23). If PCI segment is not supported, Bit8 to Bit23 will be 0.')
cpqSePciSlotDeviceNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotDeviceNumberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotDeviceNumberIndex.setDescription('A number that uniquely identifies this device on its PCI bus.')
cpqSePciPhysSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciPhysSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciPhysSlot.setDescription('The physical PCI slot number of this device. Embedded devices will return 0 for this variable.')
cpqSePciSlotSubSystemID = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotSubSystemID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotSubSystemID.setDescription('Uniquely identifies the board configured in this slot. A zero length ID indicates the Subsystem ID is not supported and the (Device ID/Vendor ID) should be used for identification purposes. An ID of all 0xFFh indicates an empty slot.')
cpqSePciSlotBoardName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotBoardName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotBoardName.setDescription('The product name (or other suitable description) of this PCI board. This field may be empty if no descriptive information is known about the board.')
cpqSePciSlotWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("thirtyTwoBit", 3), ("sixtyFourBit", 4), ("oneTwentyEightBit", 5), ("x1", 6), ("x2", 7), ("x4", 8), ("x8", 9), ("x12", 10), ("x16", 11), ("x32", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotWidth.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotWidth.setDescription('The maximum data width supported by this PCI slot.')
cpqSePciSlotSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("thirtyThreeMHz", 3), ("sixtySixMHz", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotSpeed.setStatus('deprecated')
if mibBuilder.loadTexts: cpqSePciSlotSpeed.setDescription('The maximum speed supported by this PCI slot.')
cpqSePciSlotExtendedInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotExtendedInfo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotExtendedInfo.setDescription('The PCI Extended Slot Information. This is a set of flags indicating extended features for the PCI slot. Each bit has the following meaning when it is set (1): Bit 0: Extended SCSI PCI Slot Bit 1: PCI-X capable Bits 2-31: reserved (set to 0) NOTE: bit 31 is the most significant bit, bit 0 is the least significant.')
cpqSePciSlotType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("pci", 3), ("pci66", 4), ("pcix", 5), ("pciexpress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotType.setDescription('The type of PCI the slot. This indicates the capability of the slot, not the currently operating mode.')
cpqSePciSlotCurrentMode = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("pci", 3), ("pci66", 4), ("pcix", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotCurrentMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotCurrentMode.setDescription('The current operating mode of PCI/PCI-X slot. This indicates the current operating mode of the device in the slot. If the slot is empty, this value would be unknown.')
cpqSePciMaxSlotSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMaxSlotSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMaxSlotSpeed.setDescription('The maximum speed in megahertz supported by this PCI slot. If the slot also supports PCI-X, this value indicates the maximum speed of the slot when a non-PCI-X adapter is used. An entry of 0 indicates the speed is unknown.')
cpqSePciXMaxSlotSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciXMaxSlotSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciXMaxSlotSpeed.setDescription('The maximum speed in megahertz supported by this PCI-X slot. An entry of 0 indicates the speed is unknown. An entry of -1 indicates the slot does not support PCI-X.')
cpqSePciCurrentSlotSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciCurrentSlotSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciCurrentSlotSpeed.setDescription('The current speed in megahertz of the adapter in this PCI or PCI-X slot. An entry of 0 indicates the speed is could not be determined or the slot is empty.')
cpqSePciHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSePciHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the Peripheral Component Interconnect (PCI) bus. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSePciSlotIOCTablePtr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotIOCTablePtr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotIOCTablePtr.setDescription('Index for the I/O Chassis in cpqSePCISlotIOCTablePtr where this PCI slot is physically located.')
cpqSePciSlotHeaderType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSlotHeaderType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciSlotHeaderType.setDescription('This represents header type byte of a PCI device')
cpqSePciIsSlot0Embedded = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciIsSlot0Embedded.setStatus('optional')
if mibBuilder.loadTexts: cpqSePciIsSlot0Embedded.setDescription('This OID indicates whether PCI slot 0 is embedded in the machine or not.')
cpqSePcieSlotMaxLinkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePcieSlotMaxLinkSpeed.setStatus('optional')
if mibBuilder.loadTexts: cpqSePcieSlotMaxLinkSpeed.setDescription('This is the maximum link speed for the PCIe slot. An entry of 0 indicates the maximum link speed could not be determined or the slot is not PCIe. The unit is Mb/s.')
cpqSePcieSlotMaxLinkWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePcieSlotMaxLinkWidth.setStatus('optional')
if mibBuilder.loadTexts: cpqSePcieSlotMaxLinkWidth.setDescription('This is the maximum link for the PCIe slot. Value N means N lanes. An entry of 0 indicates the maximum link width could not be determined or the slot is not PCIe.')
cpqSePciFunctTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2), )
if mibBuilder.loadTexts: cpqSePciFunctTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctTable.setDescription('A list of PCI function information entries.')
cpqSePciFunctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSePciFunctBusNumberIndex"), (0, "CPQSTDEQ-MIB", "cpqSePciFunctDeviceNumberIndex"), (0, "CPQSTDEQ-MIB", "cpqSePciFunctIndex"))
if mibBuilder.loadTexts: cpqSePciFunctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctEntry.setDescription('A description of the functions in each PCI slot.')
cpqSePciFunctBusNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctBusNumberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctBusNumberIndex.setDescription('The PCI bus number for this device function. For systems supporting multiple PCI segments, the segment number will be encoded into the middle word of this value (Bit8 to Bit23). If PCI segment is not supported, Bit8 to Bit23 will be 0.')
cpqSePciFunctDeviceNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctDeviceNumberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctDeviceNumberIndex.setDescription('The device index for this function.')
cpqSePciFunctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctIndex.setDescription(' The unique index that specifies this function.')
cpqSePciFunctClassCode = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctClassCode.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctClassCode.setDescription('The class code register as defined in the PCI Local Bus Specification in the following format: Octet Register ----- -------- 1 Programming Interface 2 Sub-class code 3 Base class code')
cpqSePciFunctClassDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctClassDescription.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctClassDescription.setDescription("A text string which describes the PCI Base Class and Sub Class to which this device belongs. This field may empty if no descriptive information is known about this function's class.")
cpqSePciFunctDeviceID = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctDeviceID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctDeviceID.setDescription('This variable identifies this particular device. This identifier is allocated by the component manufacturer.')
cpqSePciFunctVendorID = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctVendorID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctVendorID.setDescription('This variable identifies the component manufacturer. Valid identifiers are assigned by the PCI SIG.')
cpqSePciFunctRevID = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctRevID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctRevID.setDescription('This variable is a vendor defined extension to the device ID and specifies a device specific revision identifier.')
cpqSePciFunctIntLine = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctIntLine.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctIntLine.setDescription("This variable specifies which input of the system interrupt controller(s) the device's interrupt pin is connected to. A value of 0ffh means unknown or no connection.")
cpqSePciFunctDevStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctDevStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciFunctDevStatus.setDescription('The status of the device described by this function. Some PCI devices, such as embedded devices, have the potential of being present but disabled. ')
cpqSePciFunctHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciFunctHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSePciFunctHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the Peripheral Component Interconnect (PCI) bus. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSePcieFunctNegotiatedLinkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePcieFunctNegotiatedLinkSpeed.setStatus('optional')
if mibBuilder.loadTexts: cpqSePcieFunctNegotiatedLinkSpeed.setDescription('This is the negotiated link speed for the PCIe link of the PCI device. An entry of 0 indicates the negotiated link speed could not be determined or the device is not PCIe. The unit is Mb/s.')
cpqSePcieFunctNegotiatedLinkWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePcieFunctNegotiatedLinkWidth.setStatus('optional')
if mibBuilder.loadTexts: cpqSePcieFunctNegotiatedLinkWidth.setDescription('This is the negotiated link width for the PCIe link of the device. Value N means N lanes. An entry of 0 indicates the negotiated link width could not be determined or the device is not PCIe.')
cpqSePcieFunctMaxLinkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePcieFunctMaxLinkSpeed.setStatus('optional')
if mibBuilder.loadTexts: cpqSePcieFunctMaxLinkSpeed.setDescription('This is the maximum link speed for the PCIe device. An entry of 0 indicates the maximum link speed could not be determined or the device is not PCIe. The unit is Mb/s.')
cpqSePcieFunctMaxLinkWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePcieFunctMaxLinkWidth.setStatus('optional')
if mibBuilder.loadTexts: cpqSePcieFunctMaxLinkWidth.setDescription('This is the maximum link width for the PCIe device. Value N means N lanes. An entry of 0 indicates the maximum link width could not be determined or the device is not PCIe.')
cpqSePciMemoryTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3), )
if mibBuilder.loadTexts: cpqSePciMemoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemoryTable.setDescription('A list of PCI base memory entries')
cpqSePciMemoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSePciMemoryBusNumberIndex"), (0, "CPQSTDEQ-MIB", "cpqSePciMemoryDeviceNumberIndex"), (0, "CPQSTDEQ-MIB", "cpqSePciMemoryFunctionIndex"), (0, "CPQSTDEQ-MIB", "cpqSePciMemoryIndex"))
if mibBuilder.loadTexts: cpqSePciMemoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemoryEntry.setDescription('A description of the base memory usage in each function')
cpqSePciMemoryBusNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMemoryBusNumberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemoryBusNumberIndex.setDescription('The PCI bus number for this memory entry. For systems supporting multiple PCI segments, the segment number will be encoded into the middle word of this value (Bit8 to Bit23). If PCI segment is not supported, Bit8 to Bit23 will be 0.')
cpqSePciMemoryDeviceNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMemoryDeviceNumberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemoryDeviceNumberIndex.setDescription('The device index for this memory entry')
cpqSePciMemoryFunctionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMemoryFunctionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemoryFunctionIndex.setDescription(' The unique index that specifies the function associated with this memory entry.')
cpqSePciMemoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMemoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemoryIndex.setDescription(' The unique index that specifies this memory entry. ')
cpqSePciMemoryBaseAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMemoryBaseAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemoryBaseAddr.setDescription('Base address of this memory usage entry.')
cpqSePciMemoryType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("io", 2), ("memory-mapped", 3), ("exp-rom", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMemoryType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemoryType.setDescription('The type of memory this entry describes. This variable is used to determine if this memory entry maps into memory, expansion rom or I/O space.')
cpqSePciMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePciMemorySize.setDescription('This variable specifies how much address space this function requires. A value of 0 will be returned if the agent cannot obtain this information.')
cpqSePciMemoryHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciMemoryHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSePciMemoryHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the Peripheral Component Interconnect (PCI) bus. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSePciSegmentMode = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("single-segment", 2), ("multi-segment", 3), ("auto-segment", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePciSegmentMode.setStatus('optional')
if mibBuilder.loadTexts: cpqSePciSegmentMode.setDescription('The PCI segment mode of the system, if supported.')
cpqSePCCardSlotTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1), )
if mibBuilder.loadTexts: cpqSePCCardSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSlotTable.setDescription('A list of PC Card slot information entries.')
cpqSePCCardSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSePCCardSlotIndex"))
if mibBuilder.loadTexts: cpqSePCCardSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSlotEntry.setDescription('A PC Card slot description table entry. A table entry is defined for each PC Card Slot in the current system configuration.')
cpqSePCCardSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSlotIndex.setDescription('Defines the logical PC Card slot number for this PC Card Slot. In addition, the slot number serves as the index into the PC Card data table. Typical index ranges will be either 1 to 4 (for 4 slots) or 1 to 2 (for 2 slots). (Un)Docking may cause the supported index range to change dynamically.')
cpqSePCCardCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardCondition.setDescription('Defines the overall condition of the PC Card. The supported values are defined as follows: unknown(1) The current condition is unknown for the PC Card or PC Card Slot. ok(2) PC Card operations are normal. No user action required. degraded (3) PC Card operations have degraded. Consult the cpqSePCCardStatus field for recommended actions. failed (4) PC Card operations have failed. Consult the cpqSePCCardStatus field for recommended actions.')
cpqSePCCardPhysLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardPhysLocation.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardPhysLocation.setDescription('Defines the user level PC Card Slot location description. Text strings supported are: - System Unit Top Slot, - System Unit Bottom Slot, - Docking Station Top Slot, - Docking Station Bottom Slot.')
cpqSePCCardSlotType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardSlotType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSlotType.setDescription('Defines the PC Card Slot capabilities. This is a bit mapped value defined by DMI Mobile Supplement for the System Slots Group, Slot Type. Bits of interest for PC Card support are: Bit 6 - PCMCIA slot (if set), Bit 13 - 16 bit PC Card capable (if set), Bit 14 - CardBus PC Card capable (if set), Bit 15 - ZV Port capable (if set), Bit 16 - Modem Ring Resume capable (if set), All other bits should be zero (reset) for PC Card slots.')
cpqSePCCardSlotWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("width8bit", 3), ("width16bit", 4), ("width32bit", 5), ("width64bit", 6), ("width128bit", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardSlotWidth.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSlotWidth.setDescription('Defines the maximum bus width for this PC Card Slot. The supported values are defined as follows: Other (1) Value is not in defined list. Unknown (2) Actual value is not known. width 8 bit (3) Bus is 8 bits wide. width 16 bit (4) Bus is 16 bits wide. width 32 bit (5) Bus is 32 bits wide. width 64 bit (6) Bus is 64 bits wide. width 128 bit (7) Bus is 128 bits wide.')
cpqSePCCardSlotThermalCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardSlotThermalCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSlotThermalCapacity.setDescription('Defines the maximum thermal dissipation capacity (milliwatts) for this PC Card Slot. A value of zero indicates the thermal capacity is unknown. A non-zero value indicates the thermal capacity in milliwatts.')
cpqSePCCardSlotThermalSensor = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardSlotThermalSensor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSlotThermalSensor.setDescription('Defines the Thermal Sensor ID that monitors this PC Card Slot. A value of zero indicates that a sensor is not present or unknown for this slot. A non-zero value indicates the sensor ID as defined by the platform firmware.')
cpqSePCCardSlotPowerState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardSlotPowerState.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSlotPowerState.setDescription('Defines the current power state (On/Off) for this PC Card Slot. The supported values are defined as follows: unknown (1) Current power state is unknown. on (2) Power is currently on. off (3) Power is currently off.')
cpqSePCCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("ok", 2), ("thermalDegraded", 3), ("thermalFailure", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardStatus.setDescription('Defines the operating status for the card in this PC Card Slot. The supported values are defined as follows: unknown (1) The current status is not known for the PC Card or PC Card Slot. ok (2) PC Card operations are normal. No user action required. thermalDegraded (3) PC Card operations have degraded due to unsafe thermal conditions. Recommended Actions include: Discontinue the use of the PC Card as soon as possible. If a Modem or LAN card then close all communication applications/links. If a Memory, ATA, or SCSI device then close all open/related files. Remove PC Card from slot after use is discontinued, if possible. thermalFailure (4) PC Card operations have failed due to unsafe thermal conditions. The PC Card will automatically be powered off to protect itself and the system. Recommended Actions include: Discontinue the use of the PC Card immediately. If a Modem or LAN card then close all communication applications/links. If a Memory, ATA, or SCSI device then close all open/related files. Remove PC Card from slot after use is discontinued, if possible.')
cpqSePCCardDeviceInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardDeviceInfo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardDeviceInfo.setDescription("Defines the PC Card Manufacturer / Device information for the card in this PC Card Slot. The returned string data is read from the PC Card's onboard Card Information Structure (CIS).")
cpqSePCCardProductInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardProductInfo.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardProductInfo.setDescription("Defines the PC Card Model / Part Number information for the card in this PC Card Slot. The returned string data is read from the PC Card's onboard Card Information Structure (CIS).")
cpqSePCCardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardSerialNumber.setDescription("Defines the PC Card Serial Number information for the card in this PC Card Slot. The returned string data is read from the PC Card's onboard Card Information Structure (CIS).")
cpqSePCCardAssetTag = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 14, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePCCardAssetTag.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSePCCardAssetTag.setDescription("Defines the PC Card Asset Tag information for the card in this PC Card Slot. The returned string data is read from the PC Card's onboard Card Information Structure (CIS).")
cpqSeUSBPortTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 15, 1), )
if mibBuilder.loadTexts: cpqSeUSBPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeUSBPortTable.setDescription('A table of USB built-in port descriptions containing one entry for each physical USB connector shipped on the system. Add-in USB ports are not reflected in this table.')
cpqSeUSBPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 15, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeUSBPortIndex"))
if mibBuilder.loadTexts: cpqSeUSBPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeUSBPortEntry.setDescription('A description of a USB port.')
cpqSeUSBPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeUSBPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeUSBPortIndex.setDescription('An index that uniquely specifies this entry.')
cpqSeUSBPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("usbPort", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeUSBPortType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqSeUSBPortType.setDescription('The port type. The supported values are defined as follows: other (1) USB port data is not available. usbPort (2) The port is a USB Port.')
cpqSeUSBPortHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 15, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeUSBPortHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeUSBPortHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the USB port. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqSeCellTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1), )
if mibBuilder.loadTexts: cpqSeCellTable.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellTable.setDescription('A list of cells in the partition.')
cpqSeCellEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeCellUnitIndex"))
if mibBuilder.loadTexts: cpqSeCellEntry.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellEntry.setDescription('A description of a cell in the system.')
cpqSeCellUnitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellUnitIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellUnitIndex.setDescription('This is a number that uniquely specifies the cell.')
cpqSeCellCabinetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellCabinetNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellCabinetNumber.setDescription('This value represents the cabinet that the cell belongs to.')
cpqSeCellCellNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellCellNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellCellNumber.setDescription('This value is cell/slot number that is unique across the cabinet.')
cpqSeCellIOCTablePtr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellIOCTablePtr.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellIOCTablePtr.setDescription('Table index for the I/O chassis which is connected to this cell.')
cpqSeCellPDHCFirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellPDHCFirmwareRevision.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellPDHCFirmwareRevision.setDescription('HP SAL Revision')
cpqSeCellSysFwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellSysFwVersion.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellSysFwVersion.setDescription('This is the revision of system firmware on the cell board')
cpqSeCellBootInhibited = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellBootInhibited.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellBootInhibited.setDescription('This value indicates whether the cell is active.')
cpqSeCellToScanBusConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellToScanBusConnectionStatus.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellToScanBusConnectionStatus.setDescription('This bitmap represents the state of cell to scan bus connection/RIO cable state. if bit 6 is set to 1, Cable port swapped. if bit 5 is set to 1, Cable ID mismatched. if bit 4 is set to 1, Output Cable parity error. if bit 3 is set to 1, Output Cable detached. if bit 2 is set to 1, Input Cable parity error. if bit 1 is set to 1, Input Cable detached. if bit 0 is set to 1, Connection valid.')
cpqSeCellHasCoreIO = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellHasCoreIO.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellHasCoreIO.setDescription('This value indicates whether the cell has core I/O attached to it.')
cpqSeCellBoardSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellBoardSpeed.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellBoardSpeed.setDescription('This value represents the speed of the cell board/FSB ratio')
cpqSeCellPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellPresent.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellPresent.setDescription('This value represents whether there is a cell in the slot')
cpqSeCellHasPower = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellHasPower.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellHasPower.setDescription('This value represents whether the cell has power')
cpqSeCellReadyForReconfig = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellReadyForReconfig.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellReadyForReconfig.setDescription('This value represents whether the cell is ready for reconfiguration')
cpqSeCellTotalMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellTotalMemory.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellTotalMemory.setDescription('This value represents total memory in the cell')
cpqSeCellLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqSeCellLEDState.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellLEDState.setDescription('This value represents state of the cell LED. This is a bit-mapped value defined as follows. Bit 31..30 = 00, LED 3 is Off = 01, LED 3 is On = 10, LED 3 is Blinking = 11, For LED 3 future use Bit 29..27 = 000, LED 3 is Red = 001, LED 3 is Yellow = 010, LED 3 is Green = 011, LED 3 is Blue = 100, For LED 3 future use = 101, For LED 3 future use = 110, For LED 3 future use = 111, For LED 3 future use Bit 26..24 = 000, LED 3 indicates Power = 001, LED 3 indicates Run = 010, LED 3 indicates Attention = 011, LED 3 indicates Fault = 100, For LED 3 future use = 101, For LED 3 future use = 110, For LED 3 future use = 111, For LED 3 future use Bit 23..22 = 00, LED 2 is Off = 01, LED 2 is On = 10, LED 2 is Blinking = 11, For LED 2 future use Bit 21..19 = 000, LED 2 is Red = 001, LED 2 is Yellow = 010, LED 2 is Green = 011, LED 2 is Blue = 100, For LED 2 future use = 101, For LED 2 future use = 110, For LED 2 future use = 111, For LED 2 future use Bit 18..16 = 000, LED 2 indicates Power = 001, LED 2 indicates Run = 010, LED 2 indicates Attention = 011, LED 2 indicates Fault = 100, For LED 2 future use = 101, For LED 2 future use = 110, For LED 2 future use = 111, For LED 2 future use Bit 15..14 = 00, LED 1 is Off = 01, LED 1 is On = 10, LED 1 is Blinking = 11, For LED 1 future use Bit 13..11 = 000, LED 1 is Red = 001, LED 1 is Yellow = 010, LED 1 is Green = 011, LED 1 is Blue = 100, For LED 1 future use = 101, For LED 1 future use = 110, For LED 1 future use = 111, For LED 1 future use Bit 10..8 = 000, LED 1 indicates Power = 001, LED 1 indicates Run = 010, LED 1 indicates Attention = 011, LED 1 indicates Fault = 100, For LED 1 future use = 101, For LED 1 future use = 110, For LED 1 future use = 111, For LED 1 future use Bit 7..6 = 00, LED 0 is Off = 01, LED 0 is On = 10, LED 0 is Blinking = 11, For LED 0 future use Bit 5..3 = 000, LED 0 is Red = 001, LED 0 is Yellow = 010, LED 0 is Green = 011, LED 0 is Blue = 100, For LED 0 future use = 101, For LED 0 future use = 110, For LED 0 future use = 111, For LED 0 future use Bit 2..0 = 000, LED 0 indicates Power = 001, LED 0 indicates Run = 010, LED 0 indicates Attention = 011, LED 0 indicates Fault = 100, For LED 0 future use = 101, For LED 0 future use = 110, For LED 0 future use = 111, For LED 0 future use ')
cpqSeCellState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqSeCellState.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellState.setDescription('This value represents state of the cell')
cpqSeCellCLMRequestPercentage = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellCLMRequestPercentage.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellCLMRequestPercentage.setDescription('The requested percentage of CLM memory to be configured in the cell.')
cpqSeCellCLMRequestSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellCLMRequestSize.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellCLMRequestSize.setDescription('The size of requested CLM memory in the cell in kilobytes.')
cpqSeCellCLMAllocatedSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellCLMAllocatedSize.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellCLMAllocatedSize.setDescription('The size of allocated CLM memory in the cell in kilobytes.')
cpqSeCellInterleaveAllocatedSize = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellInterleaveAllocatedSize.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellInterleaveAllocatedSize.setDescription('The size of allocated interleaved memory in the cell in kilobytes.')
cpqSeCellHasInterleaveMem = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellHasInterleaveMem.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellHasInterleaveMem.setDescription('When set indicates that there is an interleaved memory configured in the cell.')
cpqSeCellSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellSerialNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellSerialNumber.setDescription('This is the cell board serial number.')
cpqSeCellCLMCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 16, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCellCLMCondition.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCellCLMCondition.setDescription('The CLM (Cell Local Memory) settings condition of this cell.')
cpqSeIOCTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 17, 1), )
if mibBuilder.loadTexts: cpqSeIOCTable.setStatus('optional')
if mibBuilder.loadTexts: cpqSeIOCTable.setDescription('A list of I/O chassis in the partition.')
cpqSeIOCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 17, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeIOCUnitIndex"))
if mibBuilder.loadTexts: cpqSeIOCEntry.setStatus('optional')
if mibBuilder.loadTexts: cpqSeIOCEntry.setDescription('A description of an I/O chassis in the system.')
cpqSeIOCUnitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeIOCUnitIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqSeIOCUnitIndex.setDescription('This is a number that uniquely specifies the I/O chassis.')
cpqSeIOCCabinetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeIOCCabinetNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSeIOCCabinetNumber.setDescription('This value represents the cabinet that the I/O chassis belongs to. The default value is 255 if the cabinet number can not be obtained.')
cpqSeIOCBayNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 17, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeIOCBayNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSeIOCBayNumber.setDescription('This value indicates the bay in the cabinet where the I/O chassis resides.')
cpqSeIOCIOCNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeIOCIOCNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSeIOCIOCNumber.setDescription('This is the I/O chassis number that is unique across the bay.')
cpqSeIOCPowerState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("powered-off", 2), ("powered-on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeIOCPowerState.setStatus('optional')
if mibBuilder.loadTexts: cpqSeIOCPowerState.setDescription('This value indicates I/O chassis power state.')
cpqSeIOCLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 17, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqSeIOCLEDState.setStatus('optional')
if mibBuilder.loadTexts: cpqSeIOCLEDState.setDescription('This value represents the state of a IO Chassis LED. This is a bit-mapped value defined as follows. Bit 31..30 = 00, LED 3 is Off = 01, LED 3 is On = 10, LED 3 is Blinking = 11, For LED 3 future use Bit 29..27 = 000, LED 3 is Red = 001, LED 3 is Yellow = 010, LED 3 is Green = 011, LED 3 is Blue = 100, For LED 3 future use = 101, For LED 3 future use = 110, For LED 3 future use = 111, For LED 3 future use Bit 26..24 = 000, LED 3 indicates Power = 001, LED 3 indicates Run = 010, LED 3 indicates Attention = 011, LED 3 indicates Fault = 100, For LED 3 future use = 101, For LED 3 future use = 110, For LED 3 future use = 111, For LED 3 future use Bit 23..22 = 00, LED 2 is Off = 01, LED 2 is On = 10, LED 2 is Blinking = 11, For LED 2 future use Bit 21..19 = 000, LED 2 is Red = 001, LED 2 is Yellow = 010, LED 2 is Green = 011, LED 2 is Blue = 100, For LED 2 future use = 101, For LED 2 future use = 110, For LED 2 future use = 111, For LED 2 future use Bit 18..16 = 000, LED 2 indicates Power = 001, LED 2 indicates Run = 010, LED 2 indicates Attention = 011, LED 2 indicates Fault = 100, For LED 2 future use = 101, For LED 2 future use = 110, For LED 2 future use = 111, For LED 2 future use Bit 15..14 = 00, LED 1 is Off = 01, LED 1 is On = 10, LED 1 is Blinking = 11, For LED 1 future use Bit 13..11 = 000, LED 1 is Red = 001, LED 1 is Yellow = 010, LED 1 is Green = 011, LED 1 is Blue = 100, For LED 1 future use = 101, For LED 1 future use = 110, For LED 1 future use = 111, For LED 1 future use Bit 10..8 = 000, LED 1 indicates Power = 001, LED 1 indicates Run = 010, LED 1 indicates Attention = 011, LED 1 indicates Fault = 100, For LED 1 future use = 101, For LED 1 future use = 110, For LED 1 future use = 111, For LED 1 future use Bit 7..6 = 00, LED 0 is Off = 01, LED 0 is On = 10, LED 0 is Blinking = 11, For LED 0 future use Bit 5..3 = 000, LED 0 is Red = 001, LED 0 is Yellow = 010, LED 0 is Green = 011, LED 0 is Blue = 100, For LED 0 future use = 101, For LED 0 future use = 110, For LED 0 future use = 111, For LED 0 future use Bit 2..0 = 000, LED 0 indicates Power = 001, LED 0 indicates Run = 010, LED 0 indicates Attention = 011, LED 0 indicates Fault = 100, For LED 0 future use = 101, For LED 0 future use = 110, For LED 0 future use = 111, For LED 0 future use ')
cpqSePartitionTotalCPU = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionTotalCPU.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionTotalCPU.setDescription('This is the number of logical CPUs in the partition. Zero will be returned if the value can not be determined.')
cpqSePartitionAvailableCellSlots = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionAvailableCellSlots.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionAvailableCellSlots.setDescription('This is the number of available cell slots in the partition. Zero will be returned if the value can not be determined.')
cpqSePartitionInstalledCells = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionInstalledCells.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionInstalledCells.setDescription('This is the number of installed cells in the partition. Zero will be returned if the value can not be determined.')
cpqSePartitionPoweredOnCells = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionPoweredOnCells.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionPoweredOnCells.setDescription('This denotes the number of powered on cells in the partition. Zero will be returned if the value can not be determined.')
cpqSePartitionReadyForReconfigCells = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionReadyForReconfigCells.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionReadyForReconfigCells.setDescription('This represents the cells that are ready for reconfiguration. Zero will be returned if the value can not be determined.')
cpqSePartitionMemInterleavingType = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionMemInterleavingType.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionMemInterleavingType.setDescription('This represents memory interleaving type for the partition. Zero will be returned if the value can not be determined.')
cpqSePartitionName = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionName.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionName.setDescription('This represents the partition name.')
cpqSePartitionCoreCell = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionCoreCell.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionCoreCell.setDescription("The cell slot number of the partition's core cell.")
cpqSePartitionCoreCellCabinet = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionCoreCellCabinet.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionCoreCellCabinet.setDescription("The cabinet number of the partition's core cell.")
cpqSePartitionCLMRequestPercentage = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionCLMRequestPercentage.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionCLMRequestPercentage.setDescription('The requested percentage of CLM memory to be configured in the partition.')
cpqSePartitionCLMRequestSize = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionCLMRequestSize.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionCLMRequestSize.setDescription('The size of requested CLM memory in the partition in kilobytes.')
cpqSePartitionCLMAllocatedSize = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionCLMAllocatedSize.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionCLMAllocatedSize.setDescription('The size of allocated CLM memory in the partition in kilobytes.')
cpqSePartitionInterleaveAllocatedSize = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionInterleaveAllocatedSize.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionInterleaveAllocatedSize.setDescription('The size of allocated interleaved memory in the partition in kilobytes.')
cpqSePartitionHasInterleaveMem = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionHasInterleaveMem.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionHasInterleaveMem.setDescription('When set, it indicates that there is an interleaved memory configured in the partition.')
cpqSePartitionNumber = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 18, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSePartitionNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqSePartitionNumber.setDescription('This represents the logical partition number of the current partition in the complex.')
cpqSeCabinetTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 19, 1), )
if mibBuilder.loadTexts: cpqSeCabinetTable.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCabinetTable.setDescription('A list of cabinets that contain cells in the partition.')
cpqSeCabinetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 19, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeCabinetUnitIndex"))
if mibBuilder.loadTexts: cpqSeCabinetEntry.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCabinetEntry.setDescription('A description of a cabinet in the system.')
cpqSeCabinetUnitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCabinetUnitIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCabinetUnitIndex.setDescription('This is a number that uniquely specifies the cabinet.')
cpqSeCabinetCPULED = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 19, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCabinetCPULED.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCabinetCPULED.setDescription('This value represents the on/off state of compute cabinet LED.')
cpqSeCabinetIOXLED = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 19, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCabinetIOXLED.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCabinetIOXLED.setDescription('This value represents the on/off state of IOX cabinet LED.')
cpqSeCabinetTypeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 19, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeCabinetTypeNum.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCabinetTypeNum.setDescription('This value represents type and number of a compute or IOX cabinet. Bit 31..16 = 0x0000, type of cabinet is Thin Boy Bit 31..16 = 0x0001, type of cabinet is Fat Boy Bit 31..16 = 0x0002, type of cabinet is Dome Lite Bit 31..16 = 0x0003, type of cabinet is Key Stone Bit 31..16 = 0x0004, type of cabinet is Matter Horn Bit 31..16 = 0x0080, type of cabinet is IOX Bit 15..0, represents the compute cabinet number.')
cpqSeCabinetLED = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 19, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqSeCabinetLED.setStatus('optional')
if mibBuilder.loadTexts: cpqSeCabinetLED.setDescription('This value represents the state of a cabinet LED. This is a bit-mapped value defined as follows. Bit 31..30 = 00, LED 3 is Off = 01, LED 3 is On = 10, LED 3 is Blinking = 11, For LED 3 future use Bit 29..27 = 000, LED 3 is Red = 001, LED 3 is Yellow = 010, LED 3 is Green = 011, LED 3 is Blue = 100, For LED 3 future use = 101, For LED 3 future use = 110, For LED 3 future use = 111, For LED 3 future use Bit 26..24 = 000, LED 3 indicates Power = 001, LED 3 indicates Run = 010, LED 3 indicates Attention = 011, LED 3 indicates Fault = 100, For LED 3 future use = 101, For LED 3 future use = 110, For LED 3 future use = 111, For LED 3 future use Bit 23..22 = 00, LED 2 is Off = 01, LED 2 is On = 10, LED 2 is Blinking = 11, For LED 2 future use Bit 21..19 = 000, LED 2 is Red = 001, LED 2 is Yellow = 010, LED 2 is Green = 011, LED 2 is Blue = 100, For LED 2 future use = 101, For LED 2 future use = 110, For LED 2 future use = 111, For LED 2 future use Bit 18..16 = 000, LED 2 indicates Power = 001, LED 2 indicates Run = 010, LED 2 indicates Attention = 011, LED 2 indicates Fault = 100, For LED 2 future use = 101, For LED 2 future use = 110, For LED 2 future use = 111, For LED 2 future use Bit 15..14 = 00, LED 1 is Off = 01, LED 1 is On = 10, LED 1 is Blinking = 11, For LED 1 future use Bit 13..11 = 000, LED 1 is Red = 001, LED 1 is Yellow = 010, LED 1 is Green = 011, LED 1 is Blue = 100, For LED 1 future use = 101, For LED 1 future use = 110, For LED 1 future use = 111, For LED 1 future use Bit 10..8 = 000, LED 1 indicates Power = 001, LED 1 indicates Run = 010, LED 1 indicates Attention = 011, LED 1 indicates Fault = 100, For LED 1 future use = 101, For LED 1 future use = 110, For LED 1 future use = 111, For LED 1 future use Bit 7..6 = 00, LED 0 is Off = 01, LED 0 is On = 10, LED 0 is Blinking = 11, For LED 0 future use Bit 5..3 = 000, LED 0 is Red = 001, LED 0 is Yellow = 010, LED 0 is Green = 011, LED 0 is Blue = 100, For LED 0 future use = 101, For LED 0 future use = 110, For LED 0 future use = 111, For LED 0 future use Bit 2..0 = 000, LED 0 indicates Power = 001, LED 0 indicates Run = 010, LED 0 indicates Attention = 011, LED 0 indicates Fault = 100, For LED 0 future use = 101, For LED 0 future use = 110, For LED 0 future use = 111, For LED 0 future use ')
cpqSeComplexUUID = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexUUID.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexUUID.setDescription('This is the complex UUID.')
cpqSeComplexTotalCabinet = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexTotalCabinet.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexTotalCabinet.setDescription('This is the total number of cabinets in the complex. Zero will be returned if the value can not be determined.')
cpqSeComplexComputeCabinet = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexComputeCabinet.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexComputeCabinet.setDescription('This is the number of compute cabinets in the complex.')
cpqSeComplexIOXCabinet = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexIOXCabinet.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexIOXCabinet.setDescription('This denotes the number of IOX cabinets in the complex.')
cpqSeComplexName = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexName.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexName.setDescription('This represents the complex name.')
cpqSeComplexLockedProperty = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexLockedProperty.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexLockedProperty.setDescription('Bit 31 - Indicates that there is a locked IPMI property when set. Bit 7:0 - Contains the property number currently locked.')
cpqSeComplexCellSlotStatusTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 7), )
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusTable.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusTable.setDescription('A table of cell slot status in a complex.')
cpqSeComplexCellSlotStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 7, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeComplexCellSlotStatusIndex"))
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusEntry.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusEntry.setDescription('A cell slot status description.')
cpqSeComplexCellSlotStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusIndex.setDescription('The table index of cell slot status in a complex. This value is a unique index for a row in the table of complex cell slot status.')
cpqSeComplexCellSlotStatusCabinetNo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusCabinetNo.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusCabinetNo.setDescription('The cabinet number of this cell slot.')
cpqSeComplexCellSlotStatusSlotNo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusSlotNo.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatusSlotNo.setDescription('The number of this cell slot.')
cpqSeComplexCellSlotStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("inactive", 3), ("assigned-powered-off", 4), ("free-powered-on", 5), ("free-powered-off", 6), ("empty", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatus.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexCellSlotStatus.setDescription('The status of this cell slot.')
cpqSeComplexCellSlotPartitionNo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexCellSlotPartitionNo.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexCellSlotPartitionNo.setDescription('The partition number this cell is assigned.')
cpqSeComplexCellSlotPartitionName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 20, 7, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeComplexCellSlotPartitionName.setStatus('optional')
if mibBuilder.loadTexts: cpqSeComplexCellSlotPartitionName.setDescription('The partition this cell belongs to.')
cpqSeLEDTable = MibTable((1, 3, 6, 1, 4, 1, 232, 1, 2, 21, 1), )
if mibBuilder.loadTexts: cpqSeLEDTable.setStatus('optional')
if mibBuilder.loadTexts: cpqSeLEDTable.setDescription('A list of LEDs in the system.')
cpqSeLEDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 1, 2, 21, 1, 1), ).setIndexNames((0, "CPQSTDEQ-MIB", "cpqSeLEDIndex"))
if mibBuilder.loadTexts: cpqSeLEDEntry.setStatus('optional')
if mibBuilder.loadTexts: cpqSeLEDEntry.setDescription('An entry of an LED in the system.')
cpqSeLEDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 21, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeLEDIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqSeLEDIndex.setDescription('This is a number that uniquely identifies the LED.')
cpqSeLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 21, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqSeLEDState.setStatus('optional')
if mibBuilder.loadTexts: cpqSeLEDState.setDescription('This value represents the state of an LED. Bit 31..24 = ON-duration time in unit of 0.1 sec Bit 23..16 = OFF-duration time in unit of 0.1 sec Bit 15..8 = 0, LED state is OFF = 1, LED state is ON = 2, LED state is BLINKING Bit 7..0 = 0, invalid color value = 1, LED color is Brown = 2, LED color is Red = 3, LED color is Orange = 4, LED color is Yellow = 5, LED color is Green = 6, LED color is Blue = 7, LED color is Violet = 8, LED color is Gray = 9, LED color is White ')
cpqSeLEDStateDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 21, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqSeLEDStateDuration.setStatus('optional')
if mibBuilder.loadTexts: cpqSeLEDStateDuration.setDescription('This is the duration of an LED state in seconds. ')
cpqSeLEDLocationType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 21, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeLEDLocationType.setStatus('optional')
if mibBuilder.loadTexts: cpqSeLEDLocationType.setDescription('This value indicates whether an LED is internal or external. 0 = External 1 = Internal ')
cpqSeLEDDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 21, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeLEDDescription.setStatus('optional')
if mibBuilder.loadTexts: cpqSeLEDDescription.setDescription('Description of the LED entry.')
cpqSeLEDHardwareLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 1, 2, 21, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeLEDHardwareLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqSeLEDHardwareLocation.setDescription('Description of the location of an LED entry.')
cpqSeUSBDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 22, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeUSBDeviceType.setStatus('optional')
if mibBuilder.loadTexts: cpqSeUSBDeviceType.setDescription('Attached USB device type.')
cpqSeUSBDeviceName = MibScalar((1, 3, 6, 1, 4, 1, 232, 1, 2, 22, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqSeUSBDeviceName.setStatus('optional')
if mibBuilder.loadTexts: cpqSeUSBDeviceName.setDescription('Attached USB device name.')
cpqSeCpuThresholdPassed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1001)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSeCpuSlot"), ("CPQSTDEQ-MIB", "cpqSeCpuSocketNumber"))
if mibBuilder.loadTexts: cpqSeCpuThresholdPassed.setDescription('This trap is sent when an internal CPU error threshold has been passed on a particular CPU causing it to go degraded. This trap will be sent when cpqSeCpuThreshPassed transitions from false to true.')
cpqSePCCardThermalDegraded = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1002)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSePCCardDeviceInfo"), ("CPQSTDEQ-MIB", "cpqSePCCardProductInfo"), ("CPQSTDEQ-MIB", "cpqSePCCardSlotIndex"))
if mibBuilder.loadTexts: cpqSePCCardThermalDegraded.setDescription('This trap is sent when the PC Card Slot Thermal Sensor threshold has been exceeded for safe operations thereby causing degraded operations. This trap will be sent when cpqSePCCardStatus transitions from Normal (1) to Thermal Degraded (2). The manufacturer and product information strings as well as the slot number for the degraded PC Card is provided as parameters for this trap.')
cpqSePCCardThermalFailure = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1003)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSePCCardDeviceInfo"), ("CPQSTDEQ-MIB", "cpqSePCCardProductInfo"), ("CPQSTDEQ-MIB", "cpqSePCCardSlotIndex"))
if mibBuilder.loadTexts: cpqSePCCardThermalFailure.setDescription('This trap is sent when the PC Card Slot Thermal Sensor threshold has been exceeded for degraded operations thereby causing failed operations. This trap will be sent when cpqSePCCardStatus transitions from Thermal Degraded (2) to Thermal Failure (3). The manufacturer and product information strings as well as the slot number for the failed PC Card is provided as parameters for this trap.')
cpqSePCCardThermalSafe = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1004)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSePCCardSlotIndex"))
if mibBuilder.loadTexts: cpqSePCCardThermalSafe.setDescription('This trap is sent when the PC Card Slot Thermal Sensor threshold has been crossed which restored the thermal status to normal operations. This trap will be sent when cpqSePCCardStatus transitions from Thermal Degraded (2) or Thermal Failure (3) to Normal (1). The number of the recovered PC Card slot is provided as a parameter for this trap.')
cpqSe2CpuThresholdPassed = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1005)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSeCpuSlot"), ("CPQSTDEQ-MIB", "cpqSeCpuSocketNumber"), ("CPQSTDEQ-MIB", "cpqSeCpuSpeed"), ("CPQSTDEQ-MIB", "cpqSeCpuExtSpeed"), ("CPQSTDEQ-MIB", "cpqSeCpuCacheSize"))
if mibBuilder.loadTexts: cpqSe2CpuThresholdPassed.setDescription('This trap is sent when an internal CPU error threshold has been passed on a particular CPU causing it to go degraded. This trap will be sent when cpqSeCpuThreshPassed transitions from false to true.')
cpqSeCpuStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1006)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSeCpuUnitIndex"), ("CPQSTDEQ-MIB", "cpqSeCpuSlot"), ("CPQSTDEQ-MIB", "cpqSeCpuName"), ("CPQSTDEQ-MIB", "cpqSeCpuSpeed"), ("CPQSTDEQ-MIB", "cpqSeCpuStep"), ("CPQSTDEQ-MIB", "cpqSeCpuStatus"), ("CPQSTDEQ-MIB", "cpqSeCpuExtSpeed"), ("CPQSTDEQ-MIB", "cpqSeCpuSocketNumber"), ("CPQSTDEQ-MIB", "cpqSeCpuHwLocation"))
if mibBuilder.loadTexts: cpqSeCpuStatusChange.setDescription('This trap is sent when CPU status changed. CPU can be brought down to Stop state and removed from O.S Active set or Brought back to Running state and made member of O.S Active set. User Action: None.')
cpqSeCpuPowerPodstatusChange = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1007)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSeCpuUnitIndex"), ("CPQSTDEQ-MIB", "cpqSeCpuSlot"), ("CPQSTDEQ-MIB", "cpqSeCpuName"), ("CPQSTDEQ-MIB", "cpqSeCpuSpeed"), ("CPQSTDEQ-MIB", "cpqSeCpuStep"), ("CPQSTDEQ-MIB", "cpqSeCpuPowerpodStatus"), ("CPQSTDEQ-MIB", "cpqSeCpuExtSpeed"), ("CPQSTDEQ-MIB", "cpqSeCpuSocketNumber"), ("CPQSTDEQ-MIB", "cpqSeCpuHwLocation"))
if mibBuilder.loadTexts: cpqSeCpuPowerPodstatusChange.setDescription('This Trap is sent if CPU Power Pod status changes. User Action: None.')
cpqSeUSBStorageDeviceAttached = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1008)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSeUSBDeviceType"), ("CPQSTDEQ-MIB", "cpqSeUSBDeviceName"))
if mibBuilder.loadTexts: cpqSeUSBStorageDeviceAttached.setDescription('This trap is sent when a USB storage device has been attached ')
cpqSeUSBStorageDeviceRemoved = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,1009)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSTDEQ-MIB", "cpqSeUSBDeviceType"), ("CPQSTDEQ-MIB", "cpqSeUSBDeviceName"))
if mibBuilder.loadTexts: cpqSeUSBStorageDeviceRemoved.setDescription('This trap is sent when a attached USB storage device is removed ')
mibBuilder.exportSymbols("CPQSTDEQ-MIB", cpqSeFloppyDiskHwLocation=cpqSeFloppyDiskHwLocation, cpqSeCellInterleaveAllocatedSize=cpqSeCellInterleaveAllocatedSize, cpqSeCpuCellTablePtr=cpqSeCpuCellTablePtr, cpqSeParrallelPortHwLocation=cpqSeParrallelPortHwLocation, cpqSePciIsSlot0Embedded=cpqSePciIsSlot0Embedded, cpqSeSerialPortHwLocation=cpqSeSerialPortHwLocation, cpqSeIOCBayNumber=cpqSeIOCBayNumber, cpqSeEisaPortSlotIndex=cpqSeEisaPortSlotIndex, cpqSeCabinetUnitIndex=cpqSeCabinetUnitIndex, TruthValue=TruthValue, cpqSeBaseMem=cpqSeBaseMem, cpqSeVideoDesc=cpqSeVideoDesc, cpqSeCpuCacheCpuCoreIndex=cpqSeCpuCacheCpuCoreIndex, cpqSeComplexComputeCabinet=cpqSeComplexComputeCabinet, cpqSeComplexCellSlotStatusIndex=cpqSeComplexCellSlotStatusIndex, cpqSePciSlotHeaderType=cpqSePciSlotHeaderType, cpqSeFloppyDisk=cpqSeFloppyDisk, cpqSeIOCCabinetNumber=cpqSeIOCCabinetNumber, cpqSeCpuDesigner=cpqSeCpuDesigner, cpqSeCellCLMAllocatedSize=cpqSeCellCLMAllocatedSize, cpqSeLEDTable=cpqSeLEDTable, cpqSeEisaIntNum=cpqSeEisaIntNum, cpqSeEisaDmaSlotIndex=cpqSeEisaDmaSlotIndex, cpqSeCellCLMCondition=cpqSeCellCLMCondition, cpqSeOsCommonModuleTable=cpqSeOsCommonModuleTable, cpqSeEisaMemType=cpqSeEisaMemType, cpqSeEisaFunctIndex=cpqSeEisaFunctIndex, cpqSePci=cpqSePci, cpqSeCellCLMRequestSize=cpqSeCellCLMRequestSize, cpqSeCPUCoreIndex=cpqSeCPUCoreIndex, cpqSeLEDHardwareLocation=cpqSeLEDHardwareLocation, cpqSeFixedDiskCyls=cpqSeFixedDiskCyls, cpqSeMibRevMajor=cpqSeMibRevMajor, cpqSeCpuCacheSpeed=cpqSeCpuCacheSpeed, cpqSeFpuHwLocation=cpqSeFpuHwLocation, cpqSeEisaMemAccess=cpqSeEisaMemAccess, cpqSeOsCommon=cpqSeOsCommon, cpqSeOsCommonPollFreq=cpqSeOsCommonPollFreq, cpqSeEisaPortFunctIndex=cpqSeEisaPortFunctIndex, cpqSePciMaxSlotSpeed=cpqSePciMaxSlotSpeed, cpqSeEisaFreeFormFunctIndex=cpqSeEisaFreeFormFunctIndex, cpqSePciFunctRevID=cpqSePciFunctRevID, cpqSeSerialPortAddr=cpqSeSerialPortAddr, cpqSeCellPresent=cpqSeCellPresent, cpqSeSerialPortIndex=cpqSeSerialPortIndex, cpqSeUSBStorageDeviceRemoved=cpqSeUSBStorageDeviceRemoved, cpqSeEisaInitAddr=cpqSeEisaInitAddr, cpqSePciXMaxSlotSpeed=cpqSePciXMaxSlotSpeed, cpqSeFixedDiskIndex=cpqSeFixedDiskIndex, cpqSeCpuMaxPerformanceState=cpqSeCpuMaxPerformanceState, cpqSeCpuCacheCpuSlot=cpqSeCpuCacheCpuSlot, cpqSe2CpuThresholdPassed=cpqSe2CpuThresholdPassed, cpqSeEisaIntShare=cpqSeEisaIntShare, cpqSeFpuType=cpqSeFpuType, cpqSeParallelPort=cpqSeParallelPort, cpqSeFloppyDiskIndex=cpqSeFloppyDiskIndex, cpqSeCellUnitIndex=cpqSeCellUnitIndex, cpqSeEisaDmaXferCount=cpqSeEisaDmaXferCount, cpqSePartitionCoreCellCabinet=cpqSePartitionCoreCellCabinet, cpqSeCabinetTable=cpqSeCabinetTable, cpqSeFpuSpeed=cpqSeFpuSpeed, cpqSeCabinetLED=cpqSeCabinetLED, cpqSeCPUSerialNumberMfgr=cpqSeCPUSerialNumberMfgr, cpqSeFixedDisk=cpqSeFixedDisk, cpqSeCellCLMRequestPercentage=cpqSeCellCLMRequestPercentage, cpqSeFixedDiskHwLocation=cpqSeFixedDiskHwLocation, cpqSeEisaIntTrigger=cpqSeEisaIntTrigger, cpqSeCpuSlot=cpqSeCpuSlot, cpqSeIOCIOCNumber=cpqSeIOCIOCNumber, cpqSeFixedDiskHeads=cpqSeFixedDiskHeads, cpqSePciMemoryHwLocation=cpqSePciMemoryHwLocation, cpqSeCpuMinPerformanceState=cpqSeCpuMinPerformanceState, cpqSePCCardSlotPowerState=cpqSePCCardSlotPowerState, cpqSePartitionCLMRequestPercentage=cpqSePartitionCLMRequestPercentage, cpqSeLEDStateDuration=cpqSeLEDStateDuration, cpqSeEisaIntTable=cpqSeEisaIntTable, cpqSeCellHasCoreIO=cpqSeCellHasCoreIO, cpqSeEisaSlotCfRev=cpqSeEisaSlotCfRev, cpqSeCellCabinetNumber=cpqSeCellCabinetNumber, cpqSePartitionInterleaveAllocatedSize=cpqSePartitionInterleaveAllocatedSize, cpqSeEisaFunctEntry=cpqSeEisaFunctEntry, cpqSeCpuStatus=cpqSeCpuStatus, cpqSePciSlotCurrentMode=cpqSePciSlotCurrentMode, cpqSePcieFunctNegotiatedLinkSpeed=cpqSePcieFunctNegotiatedLinkSpeed, cpqSeSerialPortDesc=cpqSeSerialPortDesc, cpqSeMemory=cpqSeMemory, cpqSeEisaMemSlotIndex=cpqSeEisaMemSlotIndex, cpqSeEisaInitValue=cpqSeEisaInitValue, cpqSeEisaMemCache=cpqSeEisaMemCache, cpqSePartitionReadyForReconfigCells=cpqSePartitionReadyForReconfigCells, cpqSeParallelPortIndex=cpqSeParallelPortIndex, cpqSeFpuTable=cpqSeFpuTable, cpqSeCellBoardSpeed=cpqSeCellBoardSpeed, cpqSeBMCFwVer=cpqSeBMCFwVer, cpqSePciMemoryFunctionIndex=cpqSePciMemoryFunctionIndex, cpqSeSysRomVer=cpqSeSysRomVer, cpqSeEisaSlotTable=cpqSeEisaSlotTable, cpqSeEisaInitUseMask=cpqSeEisaInitUseMask, cpqSeUSBDeviceType=cpqSeUSBDeviceType, cpqSeOptRomAddrIndex=cpqSeOptRomAddrIndex, cpqSeEisaMemAllocIndex=cpqSeEisaMemAllocIndex, cpqSeCpuThresholdPassed=cpqSeCpuThresholdPassed, cpqSeEisaDmaAllocIndex=cpqSeEisaDmaAllocIndex, cpqSeCpuCacheWritePolicy=cpqSeCpuCacheWritePolicy, cpqSeIsaCmos=cpqSeIsaCmos, cpqSeEisaInitTable=cpqSeEisaInitTable, cpqSeComplexTotalCabinet=cpqSeComplexTotalCabinet, cpqSeCabinetTypeNum=cpqSeCabinetTypeNum, cpqSePciSegmentMode=cpqSePciSegmentMode, cpqSePCCardSlotIndex=cpqSePCCardSlotIndex, cpqSeEisaFreeFormSlotIndex=cpqSeEisaFreeFormSlotIndex, cpqSePciFunctBusNumberIndex=cpqSePciFunctBusNumberIndex, cpqSePCCardSlotThermalSensor=cpqSePCCardSlotThermalSensor, cpqSeOsCommonModuleName=cpqSeOsCommonModuleName, cpqSePciMemoryIndex=cpqSePciMemoryIndex, cpqSeUSBPortIndex=cpqSeUSBPortIndex, cpqSePciMemoryTable=cpqSePciMemoryTable, cpqSeEisaInitEntry=cpqSeEisaInitEntry, cpqSeCpuCacheUnitIndex=cpqSeCpuCacheUnitIndex, cpqSeCPUMultiThreadStatus=cpqSeCPUMultiThreadStatus, cpqSeCpuHwLocation=cpqSeCpuHwLocation, cpqSeEisaFunctInfo=cpqSeEisaFunctInfo, cpqSeCpuCacheEntry=cpqSeCpuCacheEntry, cpqSePciFunctEntry=cpqSePciFunctEntry, cpqSeSerialPortTable=cpqSeSerialPortTable, cpqSeEisaFunctType=cpqSeEisaFunctType, cpqSeEisaMemFunctIndex=cpqSeEisaMemFunctIndex, cpqSePCCardSlotThermalCapacity=cpqSePCCardSlotThermalCapacity, cpqSeFixedDiskSectors=cpqSeFixedDiskSectors, cpqSeVideo=cpqSeVideo, cpqSeEisaSlotBoardName=cpqSeEisaSlotBoardName, cpqSeCpuSocketNumber=cpqSeCpuSocketNumber, cpqSeEisaIntEntry=cpqSeEisaIntEntry, cpqSePciSlotWidth=cpqSePciSlotWidth, cpqSePciFunctClassDescription=cpqSePciFunctClassDescription, cpqSeCabinetCPULED=cpqSeCabinetCPULED, cpqSePciMemoryEntry=cpqSePciMemoryEntry, cpqSeInterface=cpqSeInterface, cpqSePCCardCondition=cpqSePCCardCondition, cpqSeEisaPortAddr=cpqSeEisaPortAddr, cpqSeCabinetIOXLED=cpqSeCabinetIOXLED, cpqSePartitionPoweredOnCells=cpqSePartitionPoweredOnCells, cpqSeCpuCacheHwLocation=cpqSeCpuCacheHwLocation, cpqSeBiosRomDataRaw=cpqSeBiosRomDataRaw, cpqSePciFunctIntLine=cpqSePciFunctIntLine, cpqSeCpuCacheTable=cpqSeCpuCacheTable, cpqSeCpuCacheSize=cpqSeCpuCacheSize, cpqSeParallelPortDesc=cpqSeParallelPortDesc, cpqSeComplexUUID=cpqSeComplexUUID, cpqSeComplexIOXCabinet=cpqSeComplexIOXCabinet, cpqSeLEDIndex=cpqSeLEDIndex, cpqSeEisaInitMask=cpqSeEisaInitMask, cpqSeUSBDeviceName=cpqSeUSBDeviceName, cpqSePciSlotSpeed=cpqSePciSlotSpeed, cpqSeParallelPortEntry=cpqSeParallelPortEntry, cpqSeOptRomSize=cpqSeOptRomSize, cpqSeKeyboard=cpqSeKeyboard, cpqSeComplexCellSlotStatusTable=cpqSeComplexCellSlotStatusTable, cpqSePartitionNumber=cpqSePartitionNumber, cpqSeCpuArchitectureRevision=cpqSeCpuArchitectureRevision, cpqSeCpuEntry=cpqSeCpuEntry, cpqSeEisaFreeFormTable=cpqSeEisaFreeFormTable, cpqSeCellSerialNumber=cpqSeCellSerialNumber, cpqSePciSlotBusNumberIndex=cpqSePciSlotBusNumberIndex, cpqSePCCardSerialNumber=cpqSePCCardSerialNumber, cpqSeTotalMemMB=cpqSeTotalMemMB, cpqSeFloppyDiskTable=cpqSeFloppyDiskTable, cpqSePciMemoryBaseAddr=cpqSePciMemoryBaseAddr, cpqSeComplexCellSlotPartitionName=cpqSeComplexCellSlotPartitionName, cpqSeCellToScanBusConnectionStatus=cpqSeCellToScanBusConnectionStatus, cpqSeCpuPowerPodstatusChange=cpqSeCpuPowerPodstatusChange, cpqSePciMemoryBusNumberIndex=cpqSePciMemoryBusNumberIndex, cpqSeCellSysFwVersion=cpqSeCellSysFwVersion, cpqSeIOC=cpqSeIOC, cpqSeUSBPort=cpqSeUSBPort, cpqSeEisaIntSlotIndex=cpqSeEisaIntSlotIndex, cpqSeCellIOCTablePtr=cpqSeCellIOCTablePtr, cpqSeEisaFreeFormEntry=cpqSeEisaFreeFormEntry, cpqSePartitionHasInterleaveMem=cpqSePartitionHasInterleaveMem, cpqSeEisaIntFunctIndex=cpqSeEisaIntFunctIndex, cpqSePcieFunctNegotiatedLinkWidth=cpqSePcieFunctNegotiatedLinkWidth, cpqSeOsCommonModuleEntry=cpqSeOsCommonModuleEntry, cpqSePciMemoryType=cpqSePciMemoryType, cpqSePciSlotTable=cpqSePciSlotTable, cpqSePciSlotEntry=cpqSePciSlotEntry, cpqSePCCardDeviceInfo=cpqSePCCardDeviceInfo, cpqSeLED=cpqSeLED, cpqSeParallelPortTable=cpqSeParallelPortTable, cpqSePciHwLocation=cpqSePciHwLocation, cpqSePciFunctTable=cpqSePciFunctTable, cpqSeCellReadyForReconfig=cpqSeCellReadyForReconfig, cpqSeUSBPortTable=cpqSeUSBPortTable, cpqSeEisaMemSize=cpqSeEisaMemSize, cpqSeFixedDiskCapacity=cpqSeFixedDiskCapacity, cpqSePciSlotBoardName=cpqSePciSlotBoardName, cpqSePCCardAssetTag=cpqSePCCardAssetTag, cpqSeCpuThreshPassed=cpqSeCpuThreshPassed, cpqSePCCardProductInfo=cpqSePCCardProductInfo, cpqSeCpuCacheLevelIndex=cpqSeCpuCacheLevelIndex, cpqSeComplexCellSlotStatusCabinetNo=cpqSeComplexCellSlotStatusCabinetNo, cpqSeCabinetEntry=cpqSeCabinetEntry, cpqSeIsaCmosRaw=cpqSeIsaCmosRaw, cpqSeCpuCoreSteppingText=cpqSeCpuCoreSteppingText, cpqSeCPUPartNumber=cpqSeCPUPartNumber, cpqSeFpuEntry=cpqSeFpuEntry, cpqSeEisaMemTable=cpqSeEisaMemTable, cpqSeEisaSlotIndex=cpqSeEisaSlotIndex, cpqSeEisaMemDecode=cpqSeEisaMemDecode, cpqSeCpuCurrentPerformanceState=cpqSeCpuCurrentPerformanceState, cpqSeLEDEntry=cpqSeLEDEntry, cpqSeEisaNvram=cpqSeEisaNvram, cpqSeEisaFunctSlotIndex=cpqSeEisaFunctSlotIndex, cpqSePartitionCLMAllocatedSize=cpqSePartitionCLMAllocatedSize, cpqSeCellPDHCFirmwareRevision=cpqSeCellPDHCFirmwareRevision, cpqSeUSBPortType=cpqSeUSBPortType, cpqSeFpuUnitIndex=cpqSeFpuUnitIndex, cpqSePciSlotType=cpqSePciSlotType, cpqSePciSlotIOCTablePtr=cpqSePciSlotIOCTablePtr, cpqSeEisaPortTable=cpqSeEisaPortTable, cpqSeEisaIntAllocIndex=cpqSeEisaIntAllocIndex, cpqSeOsCommonModuleVersion=cpqSeOsCommonModuleVersion, cpqSeComplexCellSlotStatusSlotNo=cpqSeComplexCellSlotStatusSlotNo, cpqSeCellBootInhibited=cpqSeCellBootInhibited, cpqStdEquipment=cpqStdEquipment, cpqSeOsCommonModulePurpose=cpqSeOsCommonModulePurpose, cpqSePCCardThermalDegraded=cpqSePCCardThermalDegraded, cpqSeComponent=cpqSeComponent, cpqSeEisaFreeFormValue=cpqSeEisaFreeFormValue, cpqSePCCardThermalSafe=cpqSePCCardThermalSafe, cpqSeOsCommonModuleDate=cpqSeOsCommonModuleDate, cpqSeMPFwVer=cpqSeMPFwVer, cpqSeCell=cpqSeCell, cpqSeSerialPort=cpqSeSerialPort, cpqSePCCardSlotWidth=cpqSePCCardSlotWidth, cpqSePciFunctHwLocation=cpqSePciFunctHwLocation, cpqSePciFunctDeviceNumberIndex=cpqSePciFunctDeviceNumberIndex, cpqSeComplexName=cpqSeComplexName, cpqSeCPUCoreThreadIndex=cpqSeCPUCoreThreadIndex, cpqSePartition=cpqSePartition, cpqSeEisaDmaChannel=cpqSeEisaDmaChannel, cpqSeComplexLockedProperty=cpqSeComplexLockedProperty, cpqSeComplexCellSlotStatus=cpqSeComplexCellSlotStatus, cpqSeEisaSlotBoardId=cpqSeEisaSlotBoardId, cpqSeCellTotalMemory=cpqSeCellTotalMemory, cpqSeEisaDmaXfer=cpqSeEisaDmaXfer, cpqSeIOCEntry=cpqSeIOCEntry, cpqSeLEDLocationType=cpqSeLEDLocationType, cpqSePciFunctIndex=cpqSePciFunctIndex, cpqSeCpuTable=cpqSeCpuTable, cpqSePciFunctVendorID=cpqSePciFunctVendorID, cpqSeEisaSlotRaw=cpqSeEisaSlotRaw, cpqSeEisaSlotType=cpqSeEisaSlotType, cpqSeEisaMemStartAddr=cpqSeEisaMemStartAddr, cpqSeCpuStep=cpqSeCpuStep)
mibBuilder.exportSymbols("CPQSTDEQ-MIB", cpqSeHPVMFwVer=cpqSeHPVMFwVer, cpqSeCPUMaxSpeed=cpqSeCPUMaxSpeed, cpqSeEisaFunctSels=cpqSeEisaFunctSels, cpqSeCabinet=cpqSeCabinet, cpqSeEisaInitAccess=cpqSeEisaInitAccess, cpqSeMibCondition=cpqSeMibCondition, cpqSeCpuSpeed=cpqSeCpuSpeed, cpqSePartitionAvailableCellSlots=cpqSePartitionAvailableCellSlots, cpqSeCellLEDState=cpqSeCellLEDState, cpqSeEisaMemShare=cpqSeEisaMemShare, cpqSeEisaMemEntry=cpqSeEisaMemEntry, cpqSePciSlotDeviceNumberIndex=cpqSePciSlotDeviceNumberIndex, cpqSePciMemoryDeviceNumberIndex=cpqSePciMemoryDeviceNumberIndex, cpqSePartitionInstalledCells=cpqSePartitionInstalledCells, cpqSeEisaDmaShare=cpqSeEisaDmaShare, cpqSeEisaDmaTable=cpqSeEisaDmaTable, cpqSeCellEntry=cpqSeCellEntry, cpqSeEisaFunctTable=cpqSeEisaFunctTable, cpqSeFixedDiskTable=cpqSeFixedDiskTable, cpqSePCCardSlotEntry=cpqSePCCardSlotEntry, cpqSePartitionName=cpqSePartitionName, cpqSePcieFunctMaxLinkWidth=cpqSePcieFunctMaxLinkWidth, cpqSeCPUCoreMaxThreads=cpqSeCPUCoreMaxThreads, cpqSeLEDState=cpqSeLEDState, cpqSePCCard=cpqSePCCard, cpqSePartitionCLMRequestSize=cpqSePartitionCLMRequestSize, cpqSeCPUSerialNumber=cpqSeCPUSerialNumber, cpqSePartitionTotalCPU=cpqSePartitionTotalCPU, cpqSePcieFunctMaxLinkSpeed=cpqSePcieFunctMaxLinkSpeed, cpqSePciSlotSubSystemID=cpqSePciSlotSubSystemID, cpqSeFpuName=cpqSeFpuName, cpqSeCpuCore=cpqSeCpuCore, cpqSePartitionMemInterleavingType=cpqSePartitionMemInterleavingType, cpqSePCCardSlotType=cpqSePCCardSlotType, cpqSePcieSlotMaxLinkWidth=cpqSePcieSlotMaxLinkWidth, cpqSePciFunctDeviceID=cpqSePciFunctDeviceID, cpqSeComplexCellSlotPartitionNo=cpqSeComplexCellSlotPartitionNo, cpqSePciFunctDevStatus=cpqSePciFunctDevStatus, cpqSeKeyboardDesc=cpqSeKeyboardDesc, cpqSeMibRev=cpqSeMibRev, cpqSeCPUPartNumberMfgr=cpqSeCPUPartNumberMfgr, cpqSeFloppyDiskEntry=cpqSeFloppyDiskEntry, cpqSeUSBDevice=cpqSeUSBDevice, cpqSeCpuCacheStatus=cpqSeCpuCacheStatus, cpqSeEisaDmaEntry=cpqSeEisaDmaEntry, cpqSeEisaPortShare=cpqSeEisaPortShare, cpqSeCellCellNumber=cpqSeCellCellNumber, cpqSeCellHasPower=cpqSeCellHasPower, cpqSeOptRomEntry=cpqSeOptRomEntry, cpqSeSmbiosVer=cpqSeSmbiosVer, cpqSeEisaInitFunctIndex=cpqSeEisaInitFunctIndex, cpqSeCellHasInterleaveMem=cpqSeCellHasInterleaveMem, cpqSeEisaMemDataSize=cpqSeEisaMemDataSize, cpqSePciFunctClassCode=cpqSePciFunctClassCode, cpqSePCCardPhysLocation=cpqSePCCardPhysLocation, cpqSeCellState=cpqSeCellState, cpqSeCpuName=cpqSeCpuName, cpqSeUSBStorageDeviceAttached=cpqSeUSBStorageDeviceAttached, cpqSeIOCTable=cpqSeIOCTable, cpqSeEisaPortSize=cpqSeEisaPortSize, cpqSeComplexCellSlotStatusEntry=cpqSeComplexCellSlotStatusEntry, cpqSeEisaPortAllocIndex=cpqSeEisaPortAllocIndex, cpqSeIOCUnitIndex=cpqSeIOCUnitIndex, cpqSePciPhysSlot=cpqSePciPhysSlot, cpqSeRom=cpqSeRom, cpqSeParallelPortAddr=cpqSeParallelPortAddr, cpqSeUSBPortEntry=cpqSeUSBPortEntry, cpqSePCCardThermalFailure=cpqSePCCardThermalFailure, cpqSeCpuStatusChange=cpqSeCpuStatusChange, cpqSeEisaPortEntry=cpqSeEisaPortEntry, cpqSeCpuPowerpodStatus=cpqSeCpuPowerpodStatus, cpqSeMibRevMinor=cpqSeMibRevMinor, cpqSeEisaFunctCfgRev=cpqSeEisaFunctCfgRev, cpqSePciCurrentSlotSpeed=cpqSePciCurrentSlotSpeed, cpqSePCCardSlotTable=cpqSePCCardSlotTable, cpqSeSerialPortEntry=cpqSeSerialPortEntry, cpqSeCpuExtSpeed=cpqSeCpuExtSpeed, cpqSePciMemorySize=cpqSePciMemorySize, cpqSeTotalMem=cpqSeTotalMem, cpqSeProcessor=cpqSeProcessor, cpqSeCellTable=cpqSeCellTable, cpqSeIOCPowerState=cpqSeIOCPowerState, cpqSeFixedDiskType=cpqSeFixedDiskType, cpqSePartitionCoreCell=cpqSePartitionCoreCell, cpqSeEisaSlotEntry=cpqSeEisaSlotEntry, cpqSePCCardStatus=cpqSePCCardStatus, cpqSeOptRomTable=cpqSeOptRomTable, cpqSeFpuSlot=cpqSeFpuSlot, cpqSeCPUChipGenerationName=cpqSeCPUChipGenerationName, cpqSePciSlotExtendedInfo=cpqSePciSlotExtendedInfo, cpqSeFpuChipIndex=cpqSeFpuChipIndex, cpqSeFloppyDiskType=cpqSeFloppyDiskType, cpqSeComplex=cpqSeComplex, cpqSeEisaFunctStatus=cpqSeEisaFunctStatus, cpqSeOsCommonModuleIndex=cpqSeOsCommonModuleIndex, cpqSeEisaInitAllocIndex=cpqSeEisaInitAllocIndex, cpqSeLEDDescription=cpqSeLEDDescription, cpqSeCpuUnitIndex=cpqSeCpuUnitIndex, cpqSeEisaDmaFunctIndex=cpqSeEisaDmaFunctIndex, cpqSeIOCLEDState=cpqSeIOCLEDState, cpqSeCpuLowPowerStatus=cpqSeCpuLowPowerStatus, cpqSePcieSlotMaxLinkSpeed=cpqSePcieSlotMaxLinkSpeed, cpqSeEisaDmaTiming=cpqSeEisaDmaTiming, cpqSeCpuPrimary=cpqSeCpuPrimary, cpqSeFixedDiskEntry=cpqSeFixedDiskEntry, cpqSeRedundantSysRomVer=cpqSeRedundantSysRomVer, cpqSeEisaInitSlotIndex=cpqSeEisaInitSlotIndex, cpqSeUSBPortHwLocation=cpqSeUSBPortHwLocation)

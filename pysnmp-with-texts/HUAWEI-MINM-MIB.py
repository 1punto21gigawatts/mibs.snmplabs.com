#
# PySNMP MIB module HUAWEI-MINM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HUAWEI-MINM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:46:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
VlanList, = mibBuilder.importSymbols("HUAWEI-L2IF-MIB", "VlanList")
hwDatacomm, = mibBuilder.importSymbols("HUAWEI-MIB", "hwDatacomm")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
EnabledStatus, = mibBuilder.importSymbols("P-BRIDGE-MIB", "EnabledStatus")
VlanIdOrNone, VlanId = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanIdOrNone", "VlanId")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Unsigned32, Integer32, Counter32, MibIdentifier, NotificationType, Counter64, IpAddress, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, TimeTicks, ObjectIdentity, Gauge32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Integer32", "Counter32", "MibIdentifier", "NotificationType", "Counter64", "IpAddress", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "TimeTicks", "ObjectIdentity", "Gauge32", "iso")
MacAddress, TruthValue, TextualConvention, DisplayString, RowStatus, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TruthValue", "TextualConvention", "DisplayString", "RowStatus", "TimeStamp")
TransportDomain, TransportAddress = mibBuilder.importSymbols("TRANSPORT-ADDRESS-MIB", "TransportDomain", "TransportAddress")
hwMinMMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1))
if mibBuilder.loadTexts: hwMinMMIB.setLastUpdated('200611230000Z')
if mibBuilder.loadTexts: hwMinMMIB.setOrganization('Huawei Technologies Co., Ltd.')
if mibBuilder.loadTexts: hwMinMMIB.setContactInfo('R&D Beijing, Huawei Technologies Co., Ltd. Huawei Bld., NO.3 Xinxi Rd, Shang-Di Information Industry Base, Hai-Dian District Beijing P.R. China Zip: 100085 Http://www.huawei.com E-mail:support@huawei.com')
if mibBuilder.loadTexts: hwMinMMIB.setDescription('The HUAWEI-MINM-MIB contains objects to Manage configuration for MINM feature. ')
class HWAdminStatus(TextualConvention, Integer32):
    description = 'Indicates the administration status as follows: up(1), down(2) '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("up", 1), ("down", 2))

class HWOperStatus(TextualConvention, Integer32):
    description = 'Indicates the operation status as follows: up(1), down(2) '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("up", 1), ("down", 2))

class HwDot1agCfmCcmInterval(TextualConvention, Integer32):
    description = "Indicates the interval at which CCMs are sent by a MEP. The possible values are: intervalInvalid(1) No CCMs are sent (disabled). interval300Hz(2) CCMs are sent every 3 1/3 milliseconds (300Hz). interval10ms(3) CCMs are sent every 10 milliseconds. interval100ms(4) CCMs are sent every 100 milliseconds. interval1s(5) CCMs are sent every 1 second. interval10s(6) CCMs are sent every 10 seconds. interval1min(7) CCMs are sent every minute. interval10min(8) CCMs are sent every 10 minutes. interval20ms(9) CCMs are sent every 10 milliseconds. interval30ms(10) CCMs are sent every 10 milliseconds. interval50ms(11) CCMs are sent every 10 milliseconds. Note: enumerations start at zero to match the 'CCM Interval field' protocol field. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))
    namedValues = NamedValues(("intervalInvalid", 1), ("interval300Hz", 2), ("interval10ms", 3), ("interval100ms", 4), ("interval1s", 5), ("interval10s", 6), ("interval1min", 7), ("interval10min", 8), ("interval20ms", 9), ("interval30ms", 10), ("interval50ms", 11))

class HwDot1agCfmRelayActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3 g), 20.32.2.5, and Table 21-24. RlyHit(1) The LTM reached an MP whose MAC address matches the target MAC address. RlyFDB(2) The Egress Port was determined by consulting the Filtering Database(20.41.1.1:a). RlyMPDB(3) The Egress Port was determined by consulting the MIP CCM Database(20.41.1.1:b). '
    description = 'Indicates the possible values the Relay action field can take.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("rlyHit", 1), ("rlyFdb", 2), ("rlyMpdb", 3))

class HwLldpChassisIdSubtype(TextualConvention, Integer32):
    description = "This TC describes the source of a chassis identifier. The enumeration 'chassisComponent(1)' represents a chassis identifier based on the value of entPhysicalAlias object (defined in IETF RFC 2737) for a chassis component (i.e., an entPhysicalClass value of 'chassis(3)'). The enumeration 'interfaceAlias(2)' represents a chassis identifier based on the value of ifAlias object (defined in IETF RFC 2863) for an interface on the containing chassis. The enumeration 'portComponent(3)' represents a chassis identifier based on the value of entPhysicalAlias object (defined in IETF RFC 2737) for a port or backplane component (i.e., entPhysicalClass value of 'port(10)' or 'backplane(4)'), within the containing chassis. The enumeration 'macAddress(4)' represents a chassis identifier based on the value of a unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order), of a port on the containing chassis as defined in IEEE Std 802-2001. The enumeration 'networkAddress(5)' represents a chassis identifier based on a network address, associated with a particular chassis. The encoded address is actually composed of two fields. The first field is a single octet, representing the IANA AddressFamilyNumbers value for the specific address type, and the second field is the network address value. The enumeration 'interfaceName(6)' represents a chassis identifier based on the value of ifName object (defined in IETF RFC 2863) for an interface on the containing chassis. The enumeration 'local(7)' represents a chassis identifier based on a locally defined value."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("chassisComponent", 1), ("interfaceAlias", 2), ("portComponent", 3), ("macAddress", 4), ("networkAddress", 5), ("interfaceName", 6), ("local", 7))

class HwLldpChassisId(TextualConvention, OctetString):
    description = "This TC describes the format of a chassis identifier string. Objects of this type are always used with an associated LldpChassisIdSubtype object, which identifies the format of the particular LldpChassisId object instance. If the associated LldpChassisIdSubtype object has a value of 'chassisComponent(1)', then the octet string identifies a particular instance of the entPhysicalAlias object (defined in IETF RFC 2737) for a chassis component (i.e., an entPhysicalClass value of 'chassis(3)'). If the associated LldpChassisIdSubtype object has a value of 'interfaceAlias(2)', then the octet string identifies a particular instance of the ifAlias object (defined in IETF RFC 2863) for an interface on the containing chassis. If the particular ifAlias object does not contain any values, another chassis identifier type should be used. If the associated LldpChassisIdSubtype object has a value of 'portComponent(3)', then the octet string identifies a particular instance of the entPhysicalAlias object (defined in IETF RFC 2737) for a port or backplane component within the containing chassis. If the associated LldpChassisIdSubtype object has a value of 'macAddress(4)', then this string identifies a particular unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order), of a port on the containing chassis as defined in IEEE Std 802-2001. If the associated LldpChassisIdSubtype object has a value of 'networkAddress(5)', then this string identifies a particular network address, encoded in network byte order, associated with one or more ports on the containing chassis. The first octet contains the IANA Address Family Numbers enumeration value for the specific address type, and octets 2 through N contain the network address value in network byte order. If the associated LldpChassisIdSubtype object has a value of 'interfaceName(6)', then the octet string identifies a particular instance of the ifName object (defined in IETF RFC 2863) for an interface on the containing chassis. If the particular ifName object does not contain any values, another chassis identifier type should be used. If the associated LldpChassisIdSubtype object has a value of 'local(7)', then this string identifies a locally assigned Chassis ID."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class HwLldpPortIdSubtype(TextualConvention, Integer32):
    description = "This TC describes the source of a particular type of port identifier used in the LLDP MIB. The enumeration 'interfaceAlias(1)' represents a port identifier based on the ifAlias MIB object, defined in IETF RFC 2863. The enumeration 'portComponent(2)' represents a port identifier based on the value of entPhysicalAlias (defined in IETF RFC 2737) for a port component (i.e., entPhysicalClass value of 'port(10)'), within the containing chassis. The enumeration 'macAddress(3)' represents a port identifier based on a unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order), which has been detected by the agent and associated with a particular port (IEEE Std 802-2001). The enumeration 'networkAddress(4)' represents a port identifier based on a network address, detected by the agent and associated with a particular port. The enumeration 'interfaceName(5)' represents a port identifier based on the ifName MIB object, defined in IETF RFC 2863. The enumeration 'agentCircuitId(6)' represents a port identifier based on the agent-local identifier of the circuit (defined in RFC 3046), detected by the agent and associated with a particular port. The enumeration 'local(7)' represents a port identifier based on a value locally assigned."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("interfaceAlias", 1), ("portComponent", 2), ("macAddress", 3), ("networkAddress", 4), ("interfaceName", 5), ("agentCircuitId", 6), ("local", 7))

class HwLldpPortId(TextualConvention, OctetString):
    description = "This TC describes the format of a port identifier string. Objects of this type are always used with an associated LldpPortIdSubtype object, which identifies the format of the particular LldpPortId object instance. If the associated LldpPortIdSubtype object has a value of 'interfaceAlias(1)', then the octet string identifies a particular instance of the ifAlias object (defined in IETF RFC 2863). If the particular ifAlias object does not contain any values, another port identifier type should be used. If the associated LldpPortIdSubtype object has a value of 'portComponent(2)', then the octet string identifies a particular instance of the entPhysicalAlias object (defined in IETF RFC 2737) for a port or backplane component. If the associated LldpPortIdSubtype object has a value of 'macAddress(3)', then this string identifies a particular unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order) associated with the port (IEEE Std 802-2001). If the associated LldpPortIdSubtype object has a value of 'networkAddress(4)', then this string identifies a network address associated with the port. The first octet contains the IANA AddressFamilyNumbers enumeration value for the specific address type, and octets 2 through N contain the networkAddress address value in network byte order. If the associated LldpPortIdSubtype object has a value of 'interfaceName(5)', then the octet string identifies a particular instance of the ifName object (defined in IETF RFC 2863). If the particular ifName object does not contain any values, another port identifier type should be used. If the associated LldpPortIdSubtype object has a value of 'agentCircuitId(6)', then this string identifies a agent-local identifier of the circuit (defined in RFC 3046). If the associated LldpPortIdSubtype object has a value of 'local(7)', then this string identifies a locally assigned port ID."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class HwLldpManAddrIfSubtype(TextualConvention, Integer32):
    reference = 'IEEE 802.1AB-2005 9.5.9.5'
    description = "This TC describes the basis of a particular type of interface associated with the management address. The enumeration 'unknown(1)' represents the case where the interface is not known. The enumeration 'ifIndex(2)' represents interface identifier based on the ifIndex MIB object. The enumeration 'systemPortNumber(3)' represents interface identifier based on the system port numbering convention."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unknown", 1), ("ifIndex", 2), ("systemPortNumber", 3))

class HwLldpManAddress(TextualConvention, OctetString):
    description = 'The value of a management address associated with the LLDP agent that may be used to reach higher layer entities to assist discovery by network management. It should be noted that appropriate security credentials, such as SNMP engineId, may be required to access the LLDP agent using a management address. These necessary credentials should be known by the network management and the objects associated with the credentials are not included in the LLDP agent.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 31)

class HwDot1agCfmIngressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3 k), 21.9.9.1, 20.35.2.6 and Table 21-26. '
    description = 'Possible values returned in the ingress action field.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("ingOk", 1), ("ingDown", 2), ("ingBlocked", 3), ("ingVid", 4))

class HwDot1agCfmEgressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3 o), 21.9.10.1 and Table 21-28'
    description = 'Possible values returned in the egress action field'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("egrOK", 1), ("egrDown", 2), ("egrBlocked", 3), ("egrVid", 4))

class HWApsInterval(TextualConvention, Integer32):
    description = ' Indicates the time interval for fast sending of Aps packets described in the G.8031. By default, it is 3.3 ms. Optional values for sending interval are as follows: apsInterval3dot3ms(1): indicates a sending interval of 3.3 ms. apsInterval5ms(2): indicates a sending interval of 5 ms. apsInterval10ms(3): indicates a sending interval of 10 ms. apsInterval15ms(4): indicates a sending interval of 15 ms. apsInterval20ms(5): indicates a sending interval of 20 ms. apsInterval30ms(6): indicates a sending interval of 30 ms. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("apsInterval3dot3ms", 1), ("apsInterval5ms", 2), ("apsInterval10ms", 3), ("apsInterval15ms", 4), ("apsInterval20ms", 5), ("apsInterval30ms", 6))

class HWProtectMode(TextualConvention, Integer32):
    description = 'Indicates the protection modes of the G.8031 Aps protection group of mac-tunnels. oneplusonebidirectional(1): 1 + 1 switchover protection modes on both ends oneplusoneunidirectional(2): 1 + 1 switchover protection modes on a single end onetoone(3): 1:1 protection mode By the default, the 1:1 protection mode is used. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("onePlusOneBidirectional", 1), ("onePlusOneUnidirectional", 2), ("oneToOne", 3))

class HWSwitchOperation(TextualConvention, Integer32):
    description = 'Indicates the switchover commands for the Aps protection group of mac-tunnels. The priority levels in a descending order are: clear, lock, force and manual. clear(1): clears the lock, force and manual commands, and WTR state on the local end. After the local commands are cleared, the WTR state cannot be entered. lock(2): locks the services on the working tunnel. force(3): forcibly switches the services to the protection tunnel when the protection tunnel is in sound state. manual(4): forcibly switches the services to the protection channel when the working and the protection tunnel are in sound state. null(5):there is not manual commands. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("clear", 1), ("lock", 2), ("force", 3), ("manual", 4), ("null", 5))

class HWProtectProtocol(TextualConvention, Integer32):
    description = 'Indicates the protection protocol of the protection group of mac-tunnels. protocolAps(1): use an APS protocol to enhance the protection switching. protocolOam(2): not using any APS protocol to enhance the protection switching. By the default, the Protocol OAM is used. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("protocolAps", 1), ("protocolOam", 2))

class HWServiceType(TextualConvention, Integer32):
    description = 'Indicates the type of a service instance as follows: p2p(1): indicates the type of a point-to-point service instance. mp2mp(2): indicates the type of a multi-point to multi-point service instance. By default, the service type is mp2mp. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("p2p", 1), ("mp2mp", 2))

class HWInterfaceType(TextualConvention, Integer32):
    description = 'Indicates the interface type of a service instance. The encApsulation mapping modes of the service instance can be configured as follows: transparent(1): indicates the transparent transmission mode. oneToOne(2): indicates the one-to-one in the s-tagged mode. bundling(3): indicates the bundling in the s-tagged mode. By default, the s-tagged bundling mode is used. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("transparent", 1), ("oneToOne", 2), ("bundling", 3))

class HWProcessBehavior(TextualConvention, Integer32):
    description = 'Indicates the processing behavior of packets as follows: discard(1), forward(2) '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("discard", 1), ("forward", 2))

class HWStaticMacFwdType(TextualConvention, Integer32):
    description = ' Indicates the type of the static MAC forwarding table of a service instance: static(1): indicates a static entry. blackhole(2): indicates a blackhole entry. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("static", 1), ("blackhole", 2))

class HwDot1agCfmMepIdOrZero(TextualConvention, Unsigned32):
    description = 'Indicates the Maintenance association End Point Identifier (MEPID): A small integer, unique over a given Maintenance Association, identifying a specific MEP. The special value 0 is allowed to indicate special cases, for example that no MEPID is configured in a given Maintenance Association point. Whenever an object is defined with this SYNTAX, then the DESCRIPTION clause of such an object MUST specify what the special value of 0 means. '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), )
hwMINM = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133))
hwMinMObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1))
hwMinMSystemObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 1))
hwMinMVirtualMac = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 1, 1), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMinMVirtualMac.setStatus('current')
if mibBuilder.loadTexts: hwMinMVirtualMac.setDescription('Indicates the virtual MAC address of the device. By default, there is no virtual MAC address.')
hwMinMMacTnlBVlanListLow = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 1, 2), VlanList().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMinMMacTnlBVlanListLow.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlBVlanListLow.setDescription('Indicates the starting value of the backbone VLAN that is assigned to the mac-tunnel.')
hwMinMMacTnlBVlanListHigh = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 1, 3), VlanList().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMinMMacTnlBVlanListHigh.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlBVlanListHigh.setDescription('Indicates the ending value of the backbone VLAN that is assigned to the mac-tunnel.')
hwMinMTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 1, 4), EnabledStatus().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMinMTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMTrapEnable.setDescription('Indicates that the Snmp-Agent Trap is enabled on the Mac-in-Mac.By default, it is disable.')
hwMinMMacTnlObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2))
hwMinMMacTnlCfgObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1))
hwMinMMacTnlIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlIndexNext.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlIndexNext.setDescription('Indicates the Index of the Next Mac Tunnel.It begins with one.')
hwMinMMacTnlCfgTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2), )
if mibBuilder.loadTexts: hwMinMMacTnlCfgTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCfgTable.setDescription('Indicates a configuration information table of Mac-tunnel.')
hwMinMMacTnlCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMMacTnlIndex"))
if mibBuilder.loadTexts: hwMinMMacTnlCfgEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCfgEntry.setDescription('Indicates the entry in the tunnel configuration table of the mac-tunnel.')
hwMinMMacTnlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hwMinMMacTnlIndex.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlIndex.setDescription('Indicates the index of Mac Tunnel. It begins with one.')
hwMinMMacTnlName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlName.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlName.setDescription('Indicates the name of the mac-tunnel. It is a character string with a maximum of 31 bytes and a minimum of 1 byte.')
hwMinMMacTnlDMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 12), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlDMac.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlDMac.setDescription('Indicates the remote MAC address of the current mac-tunnel. By default, there is no such configuration.')
hwMinMMacTnlBVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 13), VlanIdOrNone()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlBVlanID.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlBVlanID.setDescription('Indicates BVLAN value of the current BVLAN used by the mac-tunnel: It ranges from 1 to 4094. By default, BVLAN value is not configured. The VLAN here must have been created and be in the backbone VLAN used by the mac-tunnel. The special value of zero is used to indicate that no VLAN-ID is present or used. ')
hwMinMMacTnlBVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlBVlanType.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlBVlanType.setDescription(' Indicates the B-TAG type of the BVLAN. By default, it is 88a8. ')
hwMinMMacTnlPriorityValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlPriorityValue.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlPriorityValue.setDescription('Indicates priority level of the mac-tunnel. It is used to set the priority field of B-TAG. There are eight priority levels. By default, the I-TAG priority is used. The special value of eight is used to indicate that priority was unknown or none. ')
hwMinMMacTnlOutgoingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 16), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlOutgoingIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlOutgoingIfIndex.setDescription('Indicates the port used in the mac-tunnel. By default, it is not configured. The value zero is used to indicate that interface was unknown or none.')
hwMinMMacTnlSplitHorizonEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 17), EnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlSplitHorizonEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlSplitHorizonEnable.setDescription('Indicates the split horizon of tunnels. By default, it is enabled. When split horizon is enabled on two mac-tunnels, the two tunnels cannot exchange packets. ')
hwMinMMacTnlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 18), HWAdminStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlAdminStatus.setDescription('Indicates the administration status of the mac-tunnel.')
hwMinMMacTnlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 19), HWOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlOperStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlOperStatus.setDescription('Indicates the physical state of the mac-tunnel.')
hwMinMMacTnlDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlDescription.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlDescription.setDescription('Indicates descriptive information of the static Mac-In-Mac tunnel. Its length ranges from 1 to 80 bytes and the first byte cannot be a space. ')
hwMinMMacTnlStatisticsReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 21), EnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlStatisticsReset.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlStatisticsReset.setDescription('Indicates the reset on traffic statistics of the mac-tunnel.')
hwMinMMacTnlPriorityTrustITag = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 22), TruthValue().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlPriorityTrustITag.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlPriorityTrustITag.setDescription('Indicates that the I-TAG priority is copied to the mac-tunnel. By default, the I-TAG priority is not copied to the mac-tunnel.')
hwMinMMacTnlDeiTrustIDei = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 23), TruthValue().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlDeiTrustIDei.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlDeiTrustIDei.setDescription('Indicates that the I-DEI priority is copied to the mac-tunnel. By default, the I-DEI priority is not copied to the mac-tunnel.')
hwMinMMacTnlDeiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 24), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlDeiValue.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlDeiValue.setDescription('Indicates DEI of the mac-tunnel. It is used to set the DEI field of B-TAG. When DEI is true, the value is set to 1. When DEI is false, the value is set to 0. By default, the I-DEI priority is not copied to the mac-tunnel, and the DEI is false. When the value of the DEI is set to 2, it indicates that no DEI is configured on the tunnel. ')
hwMinMMacTnlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 2, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlRowStatus.setDescription('Indicates the RowStatus. The following three actions are used: active, createAndGo, destroy')
hwMinMMacTnlStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 3), )
if mibBuilder.loadTexts: hwMinMMacTnlStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlStatisticsTable.setDescription('Indicates a query for the hwMinMMacTnlStatisticsTable of the mac-tunnel. ')
hwMinMMacTnlStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 3, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMMacTnlIndex"))
if mibBuilder.loadTexts: hwMinMMacTnlStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlStatisticsEntry.setDescription('Indicates an entry query for the hwMinMMacTnlStatisticsTable of the mac-tunnel.')
hwMinMMacTnlInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 3, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlInPackets.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlInPackets.setDescription('Indicates the number of packets received by the mac-tunnel. ')
hwMinMMacTnlInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 3, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlInBytes.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlInBytes.setDescription('Indicates the number of bytes received by the mac-tunnel.')
hwMinMMacTnlOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 3, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlOutPackets.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlOutPackets.setDescription('Indicates the number of packets sent by the mac-tunnel. ')
hwMinMMacTnlOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 3, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlOutBytes.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlOutBytes.setDescription('Indicates the number of bytes sent by the mac-tunnel.')
hwMacTnlNameToIndexMappingTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 4), )
if mibBuilder.loadTexts: hwMacTnlNameToIndexMappingTable.setStatus('current')
if mibBuilder.loadTexts: hwMacTnlNameToIndexMappingTable.setDescription('Indicates the mapping table of the tunnel name and tunnel index.')
hwMacTnlNameToIndexMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 4, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMacTnlName"))
if mibBuilder.loadTexts: hwMacTnlNameToIndexMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hwMacTnlNameToIndexMappingEntry.setDescription('Indicates the mapping table entry of the tunnel name and tunnel index.')
hwMacTnlName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31)))
if mibBuilder.loadTexts: hwMacTnlName.setStatus('current')
if mibBuilder.loadTexts: hwMacTnlName.setDescription('Indicates the name of the mac-tunnel. It is a character string with a maximum of 31 bytes and a minimum of 1 byte. ')
hwMacTnlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 1, 4, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMacTnlIndex.setStatus('current')
if mibBuilder.loadTexts: hwMacTnlIndex.setDescription('Indicates the tunnel index.It begins with one.')
hwMinMMacTnlOamObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2))
hwMinMMacTnlCCTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 1), )
if mibBuilder.loadTexts: hwMinMMacTnlCCTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCCTable.setDescription('Indicates the parameters used to describe CC packets. ')
hwMinMMacTnlCCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 1, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMMacTnlIndex"))
if mibBuilder.loadTexts: hwMinMMacTnlCCEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCCEntry.setDescription('Indicates the CC table entry.')
hwMinMMacTnlCfmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 1, 1, 11), EnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlCfmEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCfmEnable.setDescription('Indicates that CFM is enabled.')
hwMinMMacTnlCCInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 1, 1, 12), HwDot1agCfmCcmInterval().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlCCInterval.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCCInterval.setDescription('Indicates the time interval of CC packets.')
hwMinMMacTnlSomeRMepCcmDefect = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 1, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlSomeRMepCcmDefect.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlSomeRMepCcmDefect.setDescription('Indicates a connectivity failure of tunnels.')
hwMinMMacTnlSomeRdiDefect = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 1, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlSomeRdiDefect.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlSomeRdiDefect.setDescription('Indicates whether the RDI packet from the remote end is received.')
hwMinMMacTnlCcReceiveEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 1, 1, 15), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlCcReceiveEnabled.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCcReceiveEnabled.setDescription('Whether CC reception is enabled.')
hwMinMMacTnlCCRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 1, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlCCRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCCRowStatus.setDescription('Indicates the row status.')
hwMinMMacTnlLbTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2), )
if mibBuilder.loadTexts: hwMinMMacTnlLbTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbTable.setDescription('Indicates the parameters used to describe Lb packets.')
hwMinMMacTnlLbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMMacTnlIndex"))
if mibBuilder.loadTexts: hwMinMMacTnlLbEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbEntry.setDescription('Indicates the loopback table entry.')
hwMinMMacTnlLbmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1, 11), EnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLbmEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbmEnable.setDescription(' Indicates that the MAC Ping is started inside the tunnel. ')
hwMinMMacTnlLbmTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLbmTimeStamp.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbmTimeStamp.setDescription('Indicates the operation time.')
hwMinMMacTnlLbmTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1, 13), Integer32().clone(2000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLbmTimeOut.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbmTimeOut.setDescription('Indicates the timeout period entered by a user, in ms. By default, it is 2000.')
hwMinMMacTnlLbmTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLbmTimes.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbmTimes.setDescription(' Indicates the number of times that Ping is entered. ')
hwMinMMacTnlLbmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1480)).clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLbmSize.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbmSize.setDescription(' Indicates the size of an Lbm packet. ')
hwMinMMacTnlLbrIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLbrIn.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbrIn.setDescription('Indicates the number of valid LBR packets received ')
hwMinMMacTnlLbmResult = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLbmResult.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbmResult.setDescription(' Whether the MAC ping operation for a tunnel is over. ')
hwMinMMacTnlLbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 2, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLbRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbRowStatus.setDescription('Indicates the row status.')
hwMinMMacTnlLbResultTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 3), )
if mibBuilder.loadTexts: hwMinMMacTnlLbResultTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbResultTable.setDescription(' Performance statistics returned by using the MAC ping command for a tunnel. ')
hwMinMMacTnlLbResultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 3, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMMacTnlIndex"))
if mibBuilder.loadTexts: hwMinMMacTnlLbResultEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLbResultEntry.setDescription('Indicates the loopback table entry.')
hwMinMMacTnlMacPingRTTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 3, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlMacPingRTTMin.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlMacPingRTTMin.setDescription(' The minimum round trip time. ')
hwMinMMacTnlMacPingRTTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlMacPingRTTMax.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlMacPingRTTMax.setDescription(' The maximum round trip time. ')
hwMinMMacTnlMacPingRTTAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 3, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlMacPingRTTAvg.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlMacPingRTTAvg.setDescription(' The average round trip time. ')
hwMinMMacTnlMacPingPacketLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 3, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlMacPingPacketLossRatio.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlMacPingPacketLossRatio.setDescription(' The packet loss ratio. ')
hwMinMMacTnlLtmTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4), )
if mibBuilder.loadTexts: hwMinMMacTnlLtmTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmTable.setDescription('Indicates the parameters used to describe Ltm packets. ')
hwMinMMacTnlLtmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMMacTnlIndex"))
if mibBuilder.loadTexts: hwMinMMacTnlLtmEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmEntry.setDescription('Indicates the linktrace table entry.')
hwMinMMacTnlLtmEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 11), EnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLtmEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmEnable.setDescription(' Indicates that the MAC Trace is started inside the tunnel. ')
hwMinMMacTnlLtmTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtmTimeStamp.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmTimeStamp.setDescription(' The time stamp for enabling the MAC trace operation for a tunnel. ')
hwMinMMacTnlLtmTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(2000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLtmTimeOut.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmTimeOut.setDescription(' Indicates the timeout period entered by a user, in ms. By default, it is 2000. ')
hwMinMMacTnlLtmTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLtmTtl.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmTtl.setDescription(' Indicates the living cycle of Ltm packets. ')
hwMinMMacTnlLtmFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 15), Bits().clone(namedValues=NamedValues(("useFDBonly", 0))).clone(namedValues=NamedValues(("useFDBonly", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtmFlags.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmFlags.setDescription(' The flags field of an LTM packet. ')
hwMinMMacTnlLtmSeqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmSeqNumber.setDescription(' The sequence number of an LTM packet. ')
hwMinMMacTnlLtmEgressIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 17), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLtmEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmEgressIdentifier.setDescription('Indicates the egress ID of Ltm packets.')
hwMinMMacTnlLtmResult = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtmResult.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmResult.setDescription(' Two conditions are used to determine whether the MAC trace operation to a tunnel is over: (1) The peer of a tunnel has been traced. (2) The preset timer for timeout is triggered. Either condition indicates the completion of an operation. ')
hwMinMMacTnlLtmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 4, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMMacTnlLtmRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtmRowStatus.setDescription('Indicates the row status.')
hwMinMMacTnlLtrTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5), )
if mibBuilder.loadTexts: hwMinMMacTnlLtrTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrTable.setDescription('Indicates the parameters used to describe Ltr packets. ')
hwMinMMacTnlLtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMMacTnlIndex"), (0, "HUAWEI-MINM-MIB", "hwMinMMacTnlLtrSeqNumber"), (0, "HUAWEI-MINM-MIB", "hwMinMMacTnlLtrReceiveOrder"))
if mibBuilder.loadTexts: hwMinMMacTnlLtrEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrEntry.setDescription(' Indicates the linktraceRelay table entry.')
hwMinMMacTnlLtrSeqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hwMinMMacTnlLtrSeqNumber.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrSeqNumber.setDescription(' Indicates the parameters used to describe Ltr packets. ')
hwMinMMacTnlLtrReceiveOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 2), Unsigned32())
if mibBuilder.loadTexts: hwMinMMacTnlLtrReceiveOrder.setReference('802.1ag clause 12.14.7.5.2')
if mibBuilder.loadTexts: hwMinMMacTnlLtrReceiveOrder.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrReceiveOrder.setDescription('An index to distinguish among multiple LTRs with the same LTR Transaction Identifier field value. ')
hwMinMMacTnlLtrTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrTtl.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrTtl.setDescription('TTL field value for a returned LTR.')
hwMinMMacTnlLtrForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrForwarded.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrForwarded.setDescription(' Indicates an identifier that shows whether the LTM packet should be forwarded to the next hop. ')
hwMinMMacTnlLtrLastEgressIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrLastEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrLastEgressIdentifier.setDescription('LTR packet is a response packet to a LTM packet. The LTM packet is the last packet sent by a port on a device. This variable indicates the port identifier of the LTM packet. The last six bytes indicate the MAC address, and the first two bytes represent the board number and outbound port number respectively.')
hwMinMMacTnlLtrNextEgressIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrNextEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrNextEgressIdentifier.setDescription('If the LTM packet needs to be forwarded to the next hop, the port identifier of the next hop should be added to the TVL field in the response LTR packet. The last six bytes indicate the MAC address, and the first two bytes represent the board number and outbound port number respectively.')
hwMinMMacTnlLtrRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 15), HwDot1agCfmRelayActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrRelay.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrRelay.setDescription('Indicates the value in the Relay Action field.')
hwMinMMacTnlLtrIngress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 16), HwDot1agCfmIngressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrIngress.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrIngress.setDescription('The value returned in the Ingress Action Field of the LTM.')
hwMinMMacTnlLtrIngressMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 17), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrIngressMac.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrIngressMac.setDescription('MAC address returned in the ingress MAC address field.')
hwMinMMacTnlLtrIngressPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 18), HwLldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrIngressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrIngressPortIdSubtype.setDescription('Format of the Ingress Port ID.')
hwMinMMacTnlLtrIngressPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 19), HwLldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrIngressPortId.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrIngressPortId.setDescription('Ingress Port ID. The format of this object is determined by the value of the dot1agCfmLtrIngressPortIdSubtype object. ')
hwMinMMacTnlLtrEgress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 20), HwDot1agCfmEgressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrEgress.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrEgress.setDescription('The value returned in the Egress Action Field of the LTM.')
hwMinMMacTnlLtrEgressMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 21), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrEgressMac.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrEgressMac.setDescription('MAC address returned in the egress MAC address field.')
hwMinMMacTnlLtrEgressPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 22), HwLldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrEgressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrEgressPortIdSubtype.setDescription('Format of the egress Port ID.')
hwMinMMacTnlLtrEgressPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 2, 5, 1, 23), HwLldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMMacTnlLtrEgressPortId.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlLtrEgressPortId.setDescription('Egress Port ID. The format of this object is determined by the value of the dot1agCfmLtrEgressPortIdSubtype object. ')
hwMinMMacTnlApsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3))
hwMinMMacTnlApsCfgTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1), )
if mibBuilder.loadTexts: hwMinMMacTnlApsCfgTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlApsCfgTable.setDescription('Indicates the configuration table for the Aps protection of the mac-tunnel.')
hwMinMMacTnlApsCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMMacTnlIndex"))
if mibBuilder.loadTexts: hwMinMMacTnlApsCfgEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlApsCfgEntry.setDescription('Indicates the configuration table entry for the Aps protection of the mac-tunnel. ')
hwMinMProtectMacTnlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMProtectMacTnlIndex.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectMacTnlIndex.setDescription('Indicates the index of ProtectMacTunnel. It begins with one.')
hwMinMProtectMacTnlName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectMacTnlName.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectMacTnlName.setDescription('Indicates the tunnel name of the protective mac-tunnel.')
hwMinMProtectMacTnlDMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 13), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMProtectMacTnlDMac.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectMacTnlDMac.setDescription('Indicates the remote MAC address of the protecting mac-tunnel.')
hwMinMProtectMacTnlBVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 14), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMProtectMacTnlBVlanID.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectMacTnlBVlanID.setDescription('Indicates BVLAN value used by the protecting mac-tunnel: It ranges from 1 to 4094.')
hwMinMProtectApsSwitchMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 15), HWProtectMode().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectApsSwitchMode.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectApsSwitchMode.setDescription('Indicates the protection modes of the G.8031 Aps protection group of mac-tunnels. oneplusonebidirectional(1): 1 + 1 switchover protection modes on both ends oneplusoneunidirectional(2): 1 + 1 switchover protection modes on a single end onetoone(3): 1:1 protection mode By the default, the 1:1 protection mode is used. ')
hwMinMProtectProtocolApsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 16), EnabledStatus().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectProtocolApsEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectProtocolApsEnable.setDescription('Indicates that the G.8031 protocol of Aps protection group in the mac-tunnel is enabled. By default, the protocol is disabled. ')
hwMinMProtectApsFastInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 17), HWApsInterval().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectApsFastInterval.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectApsFastInterval.setDescription(' Indicates the configuration of fast sending time interval for each protection group. The time intervals for fast sending of Aps packets described in the G.8031 are as follows: By default, the time interval for fast sending of Aps packets in G.8031 is 3.3 ms. Optional values for sending interval are as follows: ApsInterval3dot3ms(1): indicates a sending interval of 3.3 ms. ApsInterval5ms(3): indicates a sending interval of 5 ms. ApsInterval10ms(3): indicates a sending interval of 10 ms. ApsInterval5ms(4): indicates a sending interval of 15 ms. ApsInterval20ms(5): indicates a sending interval of 20 ms. ApsInterval30ms(6): indicates a sending interval of 30 ms.')
hwMinMProtectHoldoffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectHoldoffTime.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectHoldoffTime.setDescription('Indicates the switchover restoration time of Aps protection groups in the mac-tunnel, in 100 ms. It ranges from 0 to 100. By default, the switchover restoration time is not delayed. The value of delay is zero. ')
hwMinMProtectRevMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 19), EnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectRevMode.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectRevMode.setDescription('Indicates the non-restoration protection switchover mode of Aps protection group in mac-tunnels.')
hwMinMProtectRevWtrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 120)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectRevWtrTime.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectRevWtrTime.setDescription('Indicates the restoration time of restoration protection switchover mode of Aps protection group in mac-tunnels. By default, the switchover mode is restoration. The restoration time is five minutes.')
hwMinMProtectSwitchOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 21), HWSwitchOperation()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectSwitchOperation.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectSwitchOperation.setDescription('Indicates the switchover commands for the Aps protection group of mac-tunnels. The priority levels in a descending order are: clear, lock, force and manual. clear(1): clears the lock, force and manual commands, and WTR state on the local end. After the local commands are cleared, the WTR state cannot be entered. lock(2): locks the services on the working tunnel. force(3): forcibly switches the services to the protection tunnel when the protection tunnel is in sound state. manual(4): forcibly switches the services to the protection channel when the working and the protection tunnel are in sound state. null(5):there is not manual commands.')
hwMinMProtectProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 22), HWProtectProtocol()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectProtocol.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectProtocol.setDescription('Indicates the protection protocol of the protection group of mac-tunnels. ProtocolAPS(1): use an APS protocol to enhance the protection switching. ProtocolOAM(2): not using any APS protocol to enhance the protection switching. By the default, the ProtocolOAM is used. ')
hwMinMProtectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 2, 3, 1, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMProtectRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMProtectRowStatus.setDescription('Indicates the RowStatus. The following three actions are used: active, createAndGo, destroy')
hwMinMSIObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3))
hwMinMSIIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMSIIndexNext.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIIndexNext.setDescription('Indicates the index of the next Service Instance. It begins with one.')
hwMinMSICfgTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2), )
if mibBuilder.loadTexts: hwMinMSICfgTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSICfgTable.setDescription('Indicates the configuration table of a service instance.')
hwMinMSICfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMSIIndex"))
if mibBuilder.loadTexts: hwMinMSICfgEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMSICfgEntry.setDescription('Indicates the configuration table entry of a service instance.')
hwMinMSIIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hwMinMSIIndex.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIIndex.setDescription('Indicates the Index of Service Instance.It begins with one.')
hwMinMSIID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777216))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIID.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIID.setDescription('Indicates the ID of a service instance. It can be any value within 24 bits. By default, the value is null. One ID can be configured to one service instance only. ')
hwMinMSIName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIName.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIName.setDescription('Indicates the name of a service instance. It is a character string with a maximum of 31 bytes and a minimum of 1 byte. ')
hwMinMSIServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 13), HWServiceType().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIServiceType.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIServiceType.setDescription('Indicates the type of a service instance as follows: p2p: indicates the type of a point-to-point service instance. mp2mp: indicates the type of a multi-point to multi-point service instance. By default, the service type is mp2mp. ')
hwMinMSIPriorityTrust8021p = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 14), TruthValue().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIPriorityTrust8021p.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIPriorityTrust8021p.setDescription('Indicates that the priority of user packet based on 802.1Q is trusted. By default, no user priority is trusted. ')
hwMinMSIPriorityValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIPriorityValue.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIPriorityValue.setDescription('Indicates priority level of a service instance. It is used to set the priority field of I-TAG. By default, no user priority is trusted and the priority is zero. The special value of eight is used to indicate that priority of user is trusted. ')
hwMinMSIInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 16), HWInterfaceType().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIInterfaceType.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIInterfaceType.setDescription('Indicates the interface type of a service instance. transparent: indicates the transparent transmission mode. one-to-one: indicates the one-to-one in the s-tagged mode. bundling: indicates the bundling in the s-tagged mode. By default, the s-tagged bundling mode is used. ')
hwMinMSIAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 17), HWAdminStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIAdminStatus.setDescription('Indicates the administration status of a service instance.')
hwMinMSIOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 18), HWOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMSIOperStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIOperStatus.setDescription('Indicates the physical status of a service instance.')
hwMinMSIMacLearningEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 19), EnabledStatus().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMacLearningEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMacLearningEnable.setDescription('Disable the MAC learning of a service instance. By default, the MAC learning is enabled. This object applies to the service instance of mp2mp only. It is invalid in the service type of p2p. ')
hwMinMSIMacLimitAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 20), HWProcessBehavior()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMacLimitAction.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMacLimitAction.setDescription('Indicates MAC learning restriction of a service instance. After the number of MAC address entries reaches the limit, the system takes the following actions: discard: indicates that packets with new MAC address are discarded. forward: indicates that packets with new MAC address are forwarded, but the address is not added to the MAC address table. ')
hwMinMSIMacLimitAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 21), EnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMacLimitAlarm.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMacLimitAlarm.setDescription('Indicates MAC learning restriction of a service instance. Indicates whether alarm should be sent after the number of MAC address entries reaches the limit as follows: disable: indicates no alarm is sent. enable: indicates alarm is sent in syslog. ')
hwMinMSIMacLimitMaxinum = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 131072))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMacLimitMaxinum.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMacLimitMaxinum.setDescription('Indicates MAC learning restriction of a service instance. The number of MAC addresses that can be learnt by the current service instance ranges from 0 to 131072. When the number is set to zero, no restriction is imposed on the address learning. ')
hwMinMSIL2CtrlProProcess = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 23), Bits().clone(namedValues=NamedValues(("all", 0), ("stp", 1), ("lldp", 2), ("lacp", 3), ("dot3ah", 4), ("dot1ag", 5))).clone(namedValues=NamedValues(("all", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIL2CtrlProProcess.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIL2CtrlProProcess.setDescription('This configuration is unsuitable for the case of port+vlan+cos mapping. Layer 2 control packets of a service instance are handled as follows: By default, all layer 2 control packets are transmitted transparently and all bits are 0; if a bit is 1, it indicates that the packets of this protocol will be discarded. If bit 0 is 1, it indicates that all layer 2 control packets will be discarded. If bit 1 is 1, it indicates that the STP packets will be discarded. If bit 2 is 1, it indicates that the LLAP packets will be discarded. If bit 3 is 1, it indicates that the LACP packets will be discarded. If bit 4 is 1, it indicates that the DOT3AH packets will be discarded. If bit 5 is 1, it indicates that the DOTLAG packets will be discarded. ')
hwMinMSIUnknownUnicastEnbale = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 24), EnabledStatus().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIUnknownUnicastEnbale.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIUnknownUnicastEnbale.setDescription('Indicates how a service instance processes an unknown unicast packet. By default, the service instance is allowed to broadcast the unknown unicast packet. This object applies to the mp2mp service instance only. ')
hwMinMSIMulticastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 25), EnabledStatus().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMulticastEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMulticastEnable.setDescription('Indicates how a service instance processes an unknown multicast packet. By default, the service instance is allowed to broadcast the unknown multicast packet. This object applies to the mp2mp service instance only.')
hwMinMSIBroadcastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 26), EnabledStatus().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIBroadcastEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIBroadcastEnable.setDescription('Indicates how a service instance processes a broadcast packet. By default, the service instance is allowed to forward the broadcast packet. This object applies to the mp2mp service instance only. ')
hwMinMSIDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIDescription.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIDescription.setDescription('Indicates descriptive information of a service instance. Its length ranges from 1 to 80 bytes and the first byte cannot be a space. ')
hwMinMSIStatisticsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 28), EnabledStatus().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMinMSIStatisticsEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStatisticsEnable.setDescription('Indicates that the traffic statistics is enabled on a service instance.')
hwMinMSIStatisticsReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 29), EnabledStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIStatisticsReset.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStatisticsReset.setDescription('Indicates the reset on traffic statistics of a service instance.')
hwMinMSIFcsTransparentEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 30), EnabledStatus().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIFcsTransparentEnable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIFcsTransparentEnable.setDescription('The forwarded packets need to carry the CRC mark. By default, the forwarded packets do not carry the CRC mark.')
hwMinMSIIngressPriorityValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 31), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIIngressPriorityValue.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIIngressPriorityValue.setDescription('Indicates the source priority of a service instance. It is used to set the I-TAG priority field when packets are encapsulated for transmission on the tunnel. The source priority has eight levels that range from 0 to 7. By default, the source priority is copied to the mac-tunnel. When the source priority is set to 8, it indicates that the service instance is not configured with a priority, and the priority does not exist.')
hwMinMSIEgressPriorityTrustBTag = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 32), TruthValue().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIEgressPriorityTrustBTag.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIEgressPriorityTrustBTag.setDescription('Indicates that the destination priority of a service instance is copied from the B-TAG priority. It is used to set whether the I-TAG priority is copied from the B-TAG priority when packets reach the end of the tunnel and are decapsulated. By default, the B-TAG priority is not copied to I-TAG.')
hwMinMSIIngressDeiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 33), Integer32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIIngressDeiValue.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIIngressDeiValue.setDescription('Indicates the source DEI of a service instance. It is used to set the DEI field when packets are encapsulated for transmission on the tunnel. When DEI is true, the value is set to 1. When DEI is false, the value is set to 0. By default, the S-DEI priority is copied to the mac-tunnel. When the value of the DEI is set to 2, it indicates that no DEI is configured on the tunnel.')
hwMinMSIEgressDeiTrustBDei = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 34), TruthValue().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIEgressDeiTrustBDei.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIEgressDeiTrustBDei.setDescription('Indicates that the destination DEI of a service instance is copied from the B-DEI priority. It is used to set whether the DEI of I-TAG is coped from B-DEI when packets reach the end of the tunnel and are decpasulated. By default, B-DEI is not copied to I-TAG.')
hwMinMSIIsolateAll = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 35), EnabledStatus().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIIsolateAll.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIIsolateAll.setDescription('Indicates that all the mapping users of a service instance are isolated. By default, the isolation is disabled. This object applies to the service instance of mp2mp only. It is invalid in the service type of p2p.')
hwMinMSIRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 2, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIRowStatus.setDescription('Indicates the RowStatus. The following three actions are used: active, createAndGo, destroy')
hwMinMSIMappingTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3), )
if mibBuilder.loadTexts: hwMinMSIMappingTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingTable.setDescription('Indicates the configuration table of a service instance user. ')
hwMinMSIMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMSIIndex"), (0, "HUAWEI-MINM-MIB", "hwMinMSIMappingIfIndex"), (0, "HUAWEI-MINM-MIB", "hwMinMSIMappingVlanPriority"), (0, "HUAWEI-MINM-MIB", "hwMinMSIMappingGlobalVlanID"))
if mibBuilder.loadTexts: hwMinMSIMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingEntry.setDescription('Indicates the configuration table entry of a service instance user. ')
hwMinMSIMappingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: hwMinMSIMappingIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingIfIndex.setDescription('The port that is mapped to the current service instance. If the value is 0, it means that port mapping is not supported.')
hwMinMSIMappingVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)))
if mibBuilder.loadTexts: hwMinMSIMappingVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingVlanPriority.setDescription(" The priority of a user's packets that are mapped to the current service instance. If the value is 8, it means that the priority mapping is not supported.")
hwMinMSIMappingGlobalVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3, 1, 3), VlanIdOrNone())
if mibBuilder.loadTexts: hwMinMSIMappingGlobalVlanID.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingGlobalVlanID.setDescription(' The global VLAN ID that is mapped to the current service instance. If the value is 0, it means that the global VLAN mapping is not supported.')
hwMinMSIMappingVlanListLow = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3, 1, 11), VlanList().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMappingVlanListLow.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingVlanListLow.setDescription('Indicates the VLAN ID starting value of a service instance user. ')
hwMinMSIMappingVlanListHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3, 1, 12), VlanList().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMappingVlanListHigh.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingVlanListHigh.setDescription('Indicates the VLAN ID ending value of a service instance user. ')
hwMinMSIMappingUserIsolate = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3, 1, 13), EnabledStatus().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMappingUserIsolate.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingUserIsolate.setDescription('Indicates that the specified mapping user of a service instance is isolated. By default, the isolation is enabled. This object applies to the service instance of mp2mp only. It is invalid in the service type of p2p')
hwMinMSIMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 3, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIMappingRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMappingRowStatus.setDescription('Indicates the RowStatus. The following three actions are used: active, createAndGo, destroy')
hwMinMSIBindMacTnlTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 4), )
if mibBuilder.loadTexts: hwMinMSIBindMacTnlTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIBindMacTnlTable.setDescription('Indicates the mac-tunnel table bound with a service instance.')
hwMinMSIBindMacTnlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 4, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMSIIndex"), (0, "HUAWEI-MINM-MIB", "hwMinMSIBindMacTnlIndex"))
if mibBuilder.loadTexts: hwMinMSIBindMacTnlEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIBindMacTnlEntry.setDescription('Indicates the mac-tunnel table entry bound with a service instance.')
hwMinMSIBindMacTnlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hwMinMSIBindMacTnlIndex.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIBindMacTnlIndex.setDescription('Indicates the index of Mac Tunnel. It begins with one.')
hwMinMSIBindMacTnlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 4, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIBindMacTnlRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIBindMacTnlRowStatus.setDescription('Indicates the RowStatus. The following three actions are used: active, createAndGo, destroy')
hwMinMSIStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 5), )
if mibBuilder.loadTexts: hwMinMSIStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStatisticsTable.setDescription('Indicates the hwMinMSIStatisticsTable of a service instance. ')
hwMinMSIStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 5, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMSIIndex"))
if mibBuilder.loadTexts: hwMinMSIStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStatisticsEntry.setDescription('Indicates the hwMinMSIStatisticsTable entry of a service instance.')
hwMinMSIInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 5, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMSIInPackets.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIInPackets.setDescription('Indicates the number of packets received by a user of the current service instance.')
hwMinMSIInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 5, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMSIInBytes.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIInBytes.setDescription('Indicates the number of bytes received by a user of the current service instance.')
hwMinMSIOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 5, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMSIOutPackets.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIOutPackets.setDescription('Indicates the number of packets sent by a user of the current service instance.')
hwMinMSIOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 5, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMinMSIOutBytes.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIOutBytes.setDescription('Indicates the number of bytes sent by a user of the current service instance.')
hwMinMSIStaticMacFwdTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 6), )
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdTable.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdTable.setDescription('Indicates the static MAC forwarding table of a service instance:')
hwMinMSIStaticMacFwdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 6, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwMinMSIIndex"), (0, "HUAWEI-MINM-MIB", "hwMinMSIStaticMacFwdCDMac"))
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdEntry.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdEntry.setDescription('Indicates the static MAC forwarding table entry of a service instance:')
hwMinMSIStaticMacFwdCDMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 6, 1, 1), MacAddress())
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdCDMac.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdCDMac.setDescription('Indicates the destination MAC address of a customer.')
hwMinMSIStaticMacFwdMacTnlName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 6, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdMacTnlName.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdMacTnlName.setDescription(' Indicates the name of the mac-tunnel. It is a character string with a maximum of 31 bytes and a minimum of 1 byte. ')
hwMinMSIStaticMacFwdOutgoingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 6, 1, 12), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdOutgoingIfIndex.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdOutgoingIfIndex.setDescription('Indicates a outbound port. The value zero is used to indicate that interface was unknown or none.')
hwMinMSIStaticMacFwdVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 6, 1, 13), VlanIdOrNone()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdVlanID.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdVlanID.setDescription('Indicates the downstream vlanid. The special value of zero is used to indicate that no VLAN-ID is present or used. ')
hwMinMSIStaticMacFwdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 6, 1, 14), HWStaticMacFwdType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdType.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdType.setDescription(' Indicates the type of the static MAC forwarding table of a service instance: static(1): indicates a static entry. blackhole(2): indicates a blackhole entry. ')
hwMinMSIStaticMacFwdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 6, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStaticMacFwdRowStatus.setDescription('Indicates the RowStatus. The following three actions are used: active, createAndGo, destroy.')
hwSINameToIndexMappingTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 7), )
if mibBuilder.loadTexts: hwSINameToIndexMappingTable.setStatus('current')
if mibBuilder.loadTexts: hwSINameToIndexMappingTable.setDescription('Indicates the name and the index mapping table of a service instance.')
hwSINameToIndexMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 7, 1), ).setIndexNames((0, "HUAWEI-MINM-MIB", "hwSIName"))
if mibBuilder.loadTexts: hwSINameToIndexMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hwSINameToIndexMappingEntry.setDescription('Indicates the name and the index mapping table entry of a service instance.')
hwSIName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 7, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31)))
if mibBuilder.loadTexts: hwSIName.setStatus('current')
if mibBuilder.loadTexts: hwSIName.setDescription('Indicates the name of a service instance. It is a character string with a maximum of 31 bytes and a minimum of 1 byte. ')
hwSIIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 1, 3, 7, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwSIIndex.setStatus('current')
if mibBuilder.loadTexts: hwSIIndex.setDescription('Indicates the index of a service instance.It begins with one.')
hwMinMNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2))
hwMinMMacTnlUp = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2, 1)).setObjects(("HUAWEI-MINM-MIB", "hwMinMMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlAdminStatus"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlOperStatus"))
if mibBuilder.loadTexts: hwMinMMacTnlUp.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlUp.setDescription('Indicates the Up alarm of the mac-tunnel. This object forms a pair with the following hwMinMMacTnlDown. ')
hwMinMMacTnlDown = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2, 2)).setObjects(("HUAWEI-MINM-MIB", "hwMinMMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlAdminStatus"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlOperStatus"))
if mibBuilder.loadTexts: hwMinMMacTnlDown.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlDown.setDescription('Indicates the Down alarm of the mac-tunnel. This object forms a pair with the previous hwMinMMacTnlUp. ')
hwMinMSIUp = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2, 3)).setObjects(("HUAWEI-MINM-MIB", "hwMinMSIID"), ("HUAWEI-MINM-MIB", "hwMinMSIName"), ("HUAWEI-MINM-MIB", "hwMinMSIAdminStatus"), ("HUAWEI-MINM-MIB", "hwMinMSIOperStatus"))
if mibBuilder.loadTexts: hwMinMSIUp.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIUp.setDescription('Indicates the Up alarm of a service instance. This object forms a pair with the following hwMinMSIDown. ')
hwMinMSIDown = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2, 4)).setObjects(("HUAWEI-MINM-MIB", "hwMinMSIID"), ("HUAWEI-MINM-MIB", "hwMinMSIName"), ("HUAWEI-MINM-MIB", "hwMinMSIAdminStatus"), ("HUAWEI-MINM-MIB", "hwMinMSIOperStatus"))
if mibBuilder.loadTexts: hwMinMSIDown.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIDown.setDescription('Indicates the Down alarm of a service instance. This object forms a pair with the previous hwMinMSIUp. ')
hwMinMMacTnlCCFaultAlarm = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2, 5)).setObjects(("HUAWEI-MINM-MIB", "hwMinMMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlSomeRMepCcmDefect"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlSomeRdiDefect"))
if mibBuilder.loadTexts: hwMinMMacTnlCCFaultAlarm.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCCFaultAlarm.setDescription('Indicates an alarm on the connectivity of fault. ')
hwMinMMacTnlSwitch = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2, 6)).setObjects(("HUAWEI-MINM-MIB", "hwMinMMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMProtectSwitchOperation"))
if mibBuilder.loadTexts: hwMinMMacTnlSwitch.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlSwitch.setDescription('Indicates the Aps protection group switchover alarm of the mac-tunnel. This object forms a pair with the following hwMinMMacTnlRevertive. hwMinMMacTnlName: indicates the name of the primary tunnel. hwMinMMacTnlDMac: indicates the destination MAC address of the primary tunnel. hwMinMMacTnlBVlanID: indicates the BVLANID of the primary tunnel. hwMinMProtectMacTnlName: Indicates the name of the backup tunnel. hwMinMProtectSwitchOperation: Indicates the switchover commands for the Aps protection group of mac-tunnels. hwMinMProtectMacTnlBVlanID: indicates the BVLANID of the backup tunnel. hwMinMProtectMacTnlDMac:indicates the destination MAC address of the backup tunnel. ')
hwMinMMacTnlRevertive = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2, 7)).setObjects(("HUAWEI-MINM-MIB", "hwMinMMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMProtectSwitchOperation"))
if mibBuilder.loadTexts: hwMinMMacTnlRevertive.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlRevertive.setDescription(' Indicates the Aps protection group switchover alarm of the mac-tunnel. This object forms a pair with the previous hwMinMMacTnlSwitch. hwMinMMacTnlName: indicates the name of the primary tunnel. hwMinMMacTnlDMac: indicates the destination MAC address of the primary tunnel. hwMinMMacTnlBVlanID: indicates the BVLANID of the primary tunnel. hwMinMProtectMacTnlName: Indicates the name of the backup tunnel. hwMinMProtectSwitchOperation: Indicates the switchover commands for the Aps protection group of mac-tunnels. hwMinMProtectMacTnlBVlanID: indicates the BVLANID of the backup tunnel. hwMinMProtectMacTnlDMac:indicates the destination MAC address of the backup tunnel.')
hwMinMSIMacLimitNumRaisingThreshold = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 2, 8)).setObjects(("HUAWEI-MINM-MIB", "hwMinMSIName"), ("HUAWEI-MINM-MIB", "hwMinMSIID"), ("HUAWEI-MINM-MIB", "hwMinMSIMacLimitMaxinum"))
if mibBuilder.loadTexts: hwMinMSIMacLimitNumRaisingThreshold.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIMacLimitNumRaisingThreshold.setDescription('Indicates the alarm of the mac limiting number beyond the Threshold.')
hwMinMConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3))
hwMinMGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1))
hwMinMSystemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1, 1)).setObjects(("HUAWEI-MINM-MIB", "hwMinMVirtualMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanListLow"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanListHigh"), ("HUAWEI-MINM-MIB", "hwMinMTrapEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMSystemGroup = hwMinMSystemGroup.setStatus('current')
if mibBuilder.loadTexts: hwMinMSystemGroup.setDescription('A collection of objects providing the System configuration of the MAC-in-MAC capability.')
hwMinMMacTnlCfgGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1, 2)).setObjects(("HUAWEI-MINM-MIB", "hwMinMVirtualMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanListLow"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanListHigh"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlIndexNext"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlBVlanType"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlPriorityValue"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlOutgoingIfIndex"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlSplitHorizonEnable"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlAdminStatus"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlOperStatus"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDescription"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlRowStatus"), ("HUAWEI-MINM-MIB", "hwMacTnlIndex"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlStatisticsReset"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlPriorityTrustITag"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDeiTrustIDei"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDeiValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMMacTnlCfgGroup = hwMinMMacTnlCfgGroup.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlCfgGroup.setDescription('A collection of objects providing the configuration of the MAC TUNNEL capability.')
hwMinMMacTnlStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1, 3)).setObjects(("HUAWEI-MINM-MIB", "hwMinMMacTnlInPackets"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlInBytes"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlOutPackets"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlOutBytes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMMacTnlStatisticsGroup = hwMinMMacTnlStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlStatisticsGroup.setDescription('A collection of objects providing the Statistics of the Service Instance capability.')
hwMinMMacTnlOAMGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1, 4)).setObjects(("HUAWEI-MINM-MIB", "hwMinMMacTnlCfmEnable"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlCCInterval"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlSomeRMepCcmDefect"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlSomeRdiDefect"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlCcReceiveEnabled"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlCCRowStatus"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLbmEnable"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLbmTimeStamp"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLbmTimeOut"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLbmTimes"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLbmSize"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLbrIn"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlMacPingRTTMin"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlMacPingRTTMax"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlMacPingRTTAvg"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlMacPingPacketLossRatio"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLbmResult"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLbRowStatus"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmEnable"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmTimeStamp"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmTimeOut"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmTtl"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmFlags"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmSeqNumber"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmEgressIdentifier"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmResult"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtmRowStatus"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrTtl"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrForwarded"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrLastEgressIdentifier"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrNextEgressIdentifier"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrRelay"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrIngress"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrIngressMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrIngressPortIdSubtype"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrIngressPortId"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrEgress"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrEgressMac"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrEgressPortIdSubtype"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlLtrEgressPortId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMMacTnlOAMGroup = hwMinMMacTnlOAMGroup.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlOAMGroup.setDescription('A collection of objects providing the OAM of the MAC TUNNEL capability.')
hwMinMMacTnlApsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1, 5)).setObjects(("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMProtectApsSwitchMode"), ("HUAWEI-MINM-MIB", "hwMinMProtectProtocolApsEnable"), ("HUAWEI-MINM-MIB", "hwMinMProtectApsFastInterval"), ("HUAWEI-MINM-MIB", "hwMinMProtectHoldoffTime"), ("HUAWEI-MINM-MIB", "hwMinMProtectRevMode"), ("HUAWEI-MINM-MIB", "hwMinMProtectRevWtrTime"), ("HUAWEI-MINM-MIB", "hwMinMProtectSwitchOperation"), ("HUAWEI-MINM-MIB", "hwMinMProtectProtocol"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlDMac"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlBVlanID"), ("HUAWEI-MINM-MIB", "hwMinMProtectRowStatus"), ("HUAWEI-MINM-MIB", "hwMinMProtectMacTnlIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMMacTnlApsGroup = hwMinMMacTnlApsGroup.setStatus('current')
if mibBuilder.loadTexts: hwMinMMacTnlApsGroup.setDescription('A collection of objects providing the Aps of the MAC TUNNEL capability.')
hwMinMSICfgGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1, 6)).setObjects(("HUAWEI-MINM-MIB", "hwMinMSIIndexNext"), ("HUAWEI-MINM-MIB", "hwMinMSIID"), ("HUAWEI-MINM-MIB", "hwMinMSIName"), ("HUAWEI-MINM-MIB", "hwMinMSIServiceType"), ("HUAWEI-MINM-MIB", "hwMinMSIPriorityTrust8021p"), ("HUAWEI-MINM-MIB", "hwMinMSIPriorityValue"), ("HUAWEI-MINM-MIB", "hwMinMSIInterfaceType"), ("HUAWEI-MINM-MIB", "hwMinMSIAdminStatus"), ("HUAWEI-MINM-MIB", "hwMinMSIOperStatus"), ("HUAWEI-MINM-MIB", "hwMinMSIMacLearningEnable"), ("HUAWEI-MINM-MIB", "hwMinMSIMacLimitAction"), ("HUAWEI-MINM-MIB", "hwMinMSIMacLimitAlarm"), ("HUAWEI-MINM-MIB", "hwMinMSIMacLimitMaxinum"), ("HUAWEI-MINM-MIB", "hwMinMSIL2CtrlProProcess"), ("HUAWEI-MINM-MIB", "hwMinMSIUnknownUnicastEnbale"), ("HUAWEI-MINM-MIB", "hwMinMSIMulticastEnable"), ("HUAWEI-MINM-MIB", "hwMinMSIBroadcastEnable"), ("HUAWEI-MINM-MIB", "hwMinMSIDescription"), ("HUAWEI-MINM-MIB", "hwMinMSIRowStatus"), ("HUAWEI-MINM-MIB", "hwMinMSIStaticMacFwdOutgoingIfIndex"), ("HUAWEI-MINM-MIB", "hwMinMSIStaticMacFwdVlanID"), ("HUAWEI-MINM-MIB", "hwMinMSIStaticMacFwdType"), ("HUAWEI-MINM-MIB", "hwMinMSIFcsTransparentEnable"), ("HUAWEI-MINM-MIB", "hwMinMSIStaticMacFwdRowStatus"), ("HUAWEI-MINM-MIB", "hwSIIndex"), ("HUAWEI-MINM-MIB", "hwMinMSIBindMacTnlRowStatus"), ("HUAWEI-MINM-MIB", "hwMinMSIStaticMacFwdMacTnlName"), ("HUAWEI-MINM-MIB", "hwMinMSIMappingVlanListLow"), ("HUAWEI-MINM-MIB", "hwMinMSIMappingVlanListHigh"), ("HUAWEI-MINM-MIB", "hwMinMSIMappingUserIsolate"), ("HUAWEI-MINM-MIB", "hwMinMSIIngressPriorityValue"), ("HUAWEI-MINM-MIB", "hwMinMSIEgressPriorityTrustBTag"), ("HUAWEI-MINM-MIB", "hwMinMSIIngressDeiValue"), ("HUAWEI-MINM-MIB", "hwMinMSIEgressDeiTrustBDei"), ("HUAWEI-MINM-MIB", "hwMinMSIIsolateAll"), ("HUAWEI-MINM-MIB", "hwMinMSIMappingRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMSICfgGroup = hwMinMSICfgGroup.setStatus('current')
if mibBuilder.loadTexts: hwMinMSICfgGroup.setDescription('A collection of objects providing the configuration of Service Instance capability.')
hwMinMSIStatisticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1, 7)).setObjects(("HUAWEI-MINM-MIB", "hwMinMSIInPackets"), ("HUAWEI-MINM-MIB", "hwMinMSIInBytes"), ("HUAWEI-MINM-MIB", "hwMinMSIOutPackets"), ("HUAWEI-MINM-MIB", "hwMinMSIOutBytes"), ("HUAWEI-MINM-MIB", "hwMinMSIStatisticsReset"), ("HUAWEI-MINM-MIB", "hwMinMSIStatisticsEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMSIStatisticsGroup = hwMinMSIStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: hwMinMSIStatisticsGroup.setDescription('A collection of objects providing the Statistics of the Service Instance capability.')
hwMinMNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 1, 8)).setObjects(("HUAWEI-MINM-MIB", "hwMinMMacTnlUp"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlDown"), ("HUAWEI-MINM-MIB", "hwMinMSIUp"), ("HUAWEI-MINM-MIB", "hwMinMSIDown"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlCCFaultAlarm"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlSwitch"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlRevertive"), ("HUAWEI-MINM-MIB", "hwMinMSIMacLimitNumRaisingThreshold"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMNotificationGroup = hwMinMNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hwMinMNotificationGroup.setDescription('Collection of notification objects.')
hwMinMCompliances = ModuleCompliance((1, 3, 6, 1, 4, 1, 2011, 5, 25, 133, 1, 3, 2)).setObjects(("HUAWEI-MINM-MIB", "hwMinMSystemGroup"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlCfgGroup"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlOAMGroup"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlApsGroup"), ("HUAWEI-MINM-MIB", "hwMinMSICfgGroup"), ("HUAWEI-MINM-MIB", "hwMinMMacTnlStatisticsGroup"), ("HUAWEI-MINM-MIB", "hwMinMSIStatisticsGroup"), ("HUAWEI-MINM-MIB", "hwMinMNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hwMinMCompliances = hwMinMCompliances.setStatus('current')
if mibBuilder.loadTexts: hwMinMCompliances.setDescription('The compliance statement for entities implementing the Huawei MINM MIB')
mibBuilder.exportSymbols("HUAWEI-MINM-MIB", hwMinMMacTnlStatisticsReset=hwMinMMacTnlStatisticsReset, hwMinMSIStaticMacFwdTable=hwMinMSIStaticMacFwdTable, HwDot1agCfmCcmInterval=HwDot1agCfmCcmInterval, hwMinMMacTnlLtmEnable=hwMinMMacTnlLtmEnable, hwMinMMacTnlLtmResult=hwMinMMacTnlLtmResult, hwMinMProtectMacTnlName=hwMinMProtectMacTnlName, hwMinMMacTnlLtmEntry=hwMinMMacTnlLtmEntry, HWInterfaceType=HWInterfaceType, hwMinMSIPriorityValue=hwMinMSIPriorityValue, hwMinMMacTnlCCEntry=hwMinMMacTnlCCEntry, hwMinMMacTnlLtrIngressPortIdSubtype=hwMinMMacTnlLtrIngressPortIdSubtype, HwLldpChassisId=HwLldpChassisId, hwMinMSystemGroup=hwMinMSystemGroup, hwMinMMacTnlLbmTimeOut=hwMinMMacTnlLbmTimeOut, hwMinMProtectApsSwitchMode=hwMinMProtectApsSwitchMode, HWProtectProtocol=HWProtectProtocol, hwMinMSIL2CtrlProProcess=hwMinMSIL2CtrlProProcess, hwMinMMacTnlLtrRelay=hwMinMMacTnlLtrRelay, hwMinMMacTnlLbmTimeStamp=hwMinMMacTnlLbmTimeStamp, hwMinMSIMacLimitAlarm=hwMinMSIMacLimitAlarm, hwMinMMacTnlIndexNext=hwMinMMacTnlIndexNext, hwMinMSystemObjects=hwMinMSystemObjects, HWProtectMode=HWProtectMode, hwMinMSIMulticastEnable=hwMinMSIMulticastEnable, hwMinMMacTnlCfgTable=hwMinMMacTnlCfgTable, hwMinMConformance=hwMinMConformance, hwMinMSIOperStatus=hwMinMSIOperStatus, hwMinMMacTnlCfgEntry=hwMinMMacTnlCfgEntry, hwMinMMacTnlLtrTable=hwMinMMacTnlLtrTable, hwMinMSIBindMacTnlRowStatus=hwMinMSIBindMacTnlRowStatus, HWStaticMacFwdType=HWStaticMacFwdType, hwMinMSIMacLimitAction=hwMinMSIMacLimitAction, HwDot1agCfmIngressActionFieldValue=HwDot1agCfmIngressActionFieldValue, hwMinMVirtualMac=hwMinMVirtualMac, hwMinMMacTnlInPackets=hwMinMMacTnlInPackets, hwMinMMIB=hwMinMMIB, hwSIName=hwSIName, hwMinMMacTnlSwitch=hwMinMMacTnlSwitch, hwMinMSIEgressDeiTrustBDei=hwMinMSIEgressDeiTrustBDei, hwMinMSIOutPackets=hwMinMSIOutPackets, hwMinMMacTnlLtrIngressMac=hwMinMMacTnlLtrIngressMac, hwMinMProtectProtocol=hwMinMProtectProtocol, hwMinMMacTnlLtmTable=hwMinMMacTnlLtmTable, hwMinMSIStatisticsGroup=hwMinMSIStatisticsGroup, hwMinMSIStaticMacFwdVlanID=hwMinMSIStaticMacFwdVlanID, hwMinMSIIndex=hwMinMSIIndex, hwMinMMacTnlLtmSeqNumber=hwMinMMacTnlLtmSeqNumber, hwMinMMacTnlLtmFlags=hwMinMMacTnlLtmFlags, hwSINameToIndexMappingTable=hwSINameToIndexMappingTable, hwMinMMacTnlApsObjects=hwMinMMacTnlApsObjects, HwLldpChassisIdSubtype=HwLldpChassisIdSubtype, hwMinMSIStaticMacFwdMacTnlName=hwMinMSIStaticMacFwdMacTnlName, HwDot1agCfmMepIdOrZero=HwDot1agCfmMepIdOrZero, hwMinMMacTnlObjects=hwMinMMacTnlObjects, hwMinMMacTnlApsCfgEntry=hwMinMMacTnlApsCfgEntry, hwMinMProtectApsFastInterval=hwMinMProtectApsFastInterval, hwMinMMacTnlLtmRowStatus=hwMinMMacTnlLtmRowStatus, hwMinMSIInBytes=hwMinMSIInBytes, hwMinMMacTnlApsCfgTable=hwMinMMacTnlApsCfgTable, hwMinMSIIndexNext=hwMinMSIIndexNext, hwMinMMacTnlStatisticsEntry=hwMinMMacTnlStatisticsEntry, hwMinMMacTnlLbmEnable=hwMinMMacTnlLbmEnable, hwMinMSIServiceType=hwMinMSIServiceType, hwMinMMacTnlLtrEgress=hwMinMMacTnlLtrEgress, hwMinMMacTnlBVlanType=hwMinMMacTnlBVlanType, hwMinMSIMappingVlanListLow=hwMinMSIMappingVlanListLow, HWProcessBehavior=HWProcessBehavior, hwMinMSIStaticMacFwdRowStatus=hwMinMSIStaticMacFwdRowStatus, hwMinMMacTnlMacPingRTTMax=hwMinMMacTnlMacPingRTTMax, hwMinMSICfgTable=hwMinMSICfgTable, hwMinMSIStaticMacFwdType=hwMinMSIStaticMacFwdType, hwMinMMacTnlLbTable=hwMinMMacTnlLbTable, hwMinMMacTnlRowStatus=hwMinMMacTnlRowStatus, hwMinMProtectRowStatus=hwMinMProtectRowStatus, hwMacTnlNameToIndexMappingEntry=hwMacTnlNameToIndexMappingEntry, hwMinMSIIsolateAll=hwMinMSIIsolateAll, hwMinMMacTnlIndex=hwMinMMacTnlIndex, hwMinMSIName=hwMinMSIName, hwMinMSIMacLearningEnable=hwMinMSIMacLearningEnable, hwMinMMacTnlUp=hwMinMMacTnlUp, hwMinMMacTnlStatisticsGroup=hwMinMMacTnlStatisticsGroup, hwMinMSIMappingVlanListHigh=hwMinMSIMappingVlanListHigh, hwMinMMacTnlLbResultEntry=hwMinMMacTnlLbResultEntry, hwMinMMacTnlCCTable=hwMinMMacTnlCCTable, hwMinMProtectProtocolApsEnable=hwMinMProtectProtocolApsEnable, hwMinMMacTnlPriorityTrustITag=hwMinMMacTnlPriorityTrustITag, HwLldpManAddrIfSubtype=HwLldpManAddrIfSubtype, hwMinMGroups=hwMinMGroups, hwMinMTrapEnable=hwMinMTrapEnable, hwMinMMacTnlLtmTtl=hwMinMMacTnlLtmTtl, hwMinMMacTnlDMac=hwMinMMacTnlDMac, hwMinMSIBindMacTnlTable=hwMinMSIBindMacTnlTable, hwMinMSIDown=hwMinMSIDown, hwMinMSICfgGroup=hwMinMSICfgGroup, hwMinMObjects=hwMinMObjects, hwMinMSIMappingTable=hwMinMSIMappingTable, hwMinMSIStaticMacFwdOutgoingIfIndex=hwMinMSIStaticMacFwdOutgoingIfIndex, hwMinMMacTnlInBytes=hwMinMMacTnlInBytes, HWApsInterval=HWApsInterval, hwMacTnlNameToIndexMappingTable=hwMacTnlNameToIndexMappingTable, hwMinMMacTnlLtrIngress=hwMinMMacTnlLtrIngress, hwMinMMacTnlLtrEgressPortIdSubtype=hwMinMMacTnlLtrEgressPortIdSubtype, hwMinMSIFcsTransparentEnable=hwMinMSIFcsTransparentEnable, hwMinMSIMappingIfIndex=hwMinMSIMappingIfIndex, hwMinMMacTnlCfmEnable=hwMinMMacTnlCfmEnable, hwMinMMacTnlLtrSeqNumber=hwMinMMacTnlLtrSeqNumber, hwMinMCompliances=hwMinMCompliances, HWServiceType=HWServiceType, hwMinMSIPriorityTrust8021p=hwMinMSIPriorityTrust8021p, HWAdminStatus=HWAdminStatus, hwMinMMacTnlCCInterval=hwMinMMacTnlCCInterval, hwMinMMacTnlLtrTtl=hwMinMMacTnlLtrTtl, hwMinMSIRowStatus=hwMinMSIRowStatus, HwLldpPortIdSubtype=HwLldpPortIdSubtype, hwMinMSIIngressPriorityValue=hwMinMSIIngressPriorityValue, hwMinMMacTnlCCFaultAlarm=hwMinMMacTnlCCFaultAlarm, hwMinMSIInPackets=hwMinMSIInPackets, hwMinMSIOutBytes=hwMinMSIOutBytes, hwMinMMacTnlCfgObjects=hwMinMMacTnlCfgObjects, hwMinMSIMacLimitNumRaisingThreshold=hwMinMSIMacLimitNumRaisingThreshold, hwMinMSIEgressPriorityTrustBTag=hwMinMSIEgressPriorityTrustBTag, hwMinMMacTnlMacPingRTTMin=hwMinMMacTnlMacPingRTTMin, hwMinMMacTnlLtrNextEgressIdentifier=hwMinMMacTnlLtrNextEgressIdentifier, hwMinMSIUnknownUnicastEnbale=hwMinMSIUnknownUnicastEnbale, hwMinMMacTnlLbEntry=hwMinMMacTnlLbEntry, hwMinMProtectHoldoffTime=hwMinMProtectHoldoffTime, hwMinMSIID=hwMinMSIID, hwMinMSIStaticMacFwdCDMac=hwMinMSIStaticMacFwdCDMac, hwMinMMacTnlOutPackets=hwMinMMacTnlOutPackets, hwMinMMacTnlDeiTrustIDei=hwMinMMacTnlDeiTrustIDei, hwMinMMacTnlDescription=hwMinMMacTnlDescription, hwMinMMacTnlLtrReceiveOrder=hwMinMMacTnlLtrReceiveOrder, hwMinMMacTnlOutBytes=hwMinMMacTnlOutBytes, hwMinMMacTnlLbmTimes=hwMinMMacTnlLbmTimes, hwMinMSIStaticMacFwdEntry=hwMinMSIStaticMacFwdEntry, hwMinMMacTnlOamObjects=hwMinMMacTnlOamObjects, HwDot1agCfmEgressActionFieldValue=HwDot1agCfmEgressActionFieldValue, hwMinMMacTnlOutgoingIfIndex=hwMinMMacTnlOutgoingIfIndex, hwMinMMacTnlLbRowStatus=hwMinMMacTnlLbRowStatus, hwMINM=hwMINM, hwMinMSIMappingUserIsolate=hwMinMSIMappingUserIsolate, hwMinMSIStatisticsTable=hwMinMSIStatisticsTable, hwMinMMacTnlDown=hwMinMMacTnlDown, HwLldpPortId=HwLldpPortId, hwMacTnlIndex=hwMacTnlIndex, hwMinMSIStatisticsReset=hwMinMSIStatisticsReset, hwMinMSIDescription=hwMinMSIDescription, hwMacTnlName=hwMacTnlName, hwMinMSIIngressDeiValue=hwMinMSIIngressDeiValue, hwMinMMacTnlCCRowStatus=hwMinMMacTnlCCRowStatus, hwMinMMacTnlSplitHorizonEnable=hwMinMMacTnlSplitHorizonEnable, hwMinMSIMappingGlobalVlanID=hwMinMSIMappingGlobalVlanID, hwMinMSIMappingEntry=hwMinMSIMappingEntry, hwMinMMacTnlLtmTimeOut=hwMinMMacTnlLtmTimeOut, hwMinMProtectMacTnlBVlanID=hwMinMProtectMacTnlBVlanID, hwSIIndex=hwSIIndex, hwMinMSIBindMacTnlEntry=hwMinMSIBindMacTnlEntry, hwMinMNotificationGroup=hwMinMNotificationGroup, HwLldpManAddress=HwLldpManAddress, hwMinMMacTnlLbmResult=hwMinMMacTnlLbmResult, hwMinMSIAdminStatus=hwMinMSIAdminStatus, hwMinMSICfgEntry=hwMinMSICfgEntry, hwMinMMacTnlApsGroup=hwMinMMacTnlApsGroup, hwMinMMacTnlLtrLastEgressIdentifier=hwMinMMacTnlLtrLastEgressIdentifier, hwMinMMacTnlAdminStatus=hwMinMMacTnlAdminStatus, hwMinMMacTnlCfgGroup=hwMinMMacTnlCfgGroup, hwSINameToIndexMappingEntry=hwSINameToIndexMappingEntry, hwMinMMacTnlLtmEgressIdentifier=hwMinMMacTnlLtmEgressIdentifier, HwDot1agCfmRelayActionFieldValue=HwDot1agCfmRelayActionFieldValue, hwMinMMacTnlName=hwMinMMacTnlName, hwMinMMacTnlLbResultTable=hwMinMMacTnlLbResultTable, hwMinMProtectMacTnlIndex=hwMinMProtectMacTnlIndex, hwMinMMacTnlRevertive=hwMinMMacTnlRevertive, hwMinMSIStatisticsEnable=hwMinMSIStatisticsEnable, hwMinMMacTnlBVlanID=hwMinMMacTnlBVlanID, hwMinMMacTnlOAMGroup=hwMinMMacTnlOAMGroup, hwMinMSIMappingVlanPriority=hwMinMSIMappingVlanPriority, hwMinMMacTnlBVlanListLow=hwMinMMacTnlBVlanListLow, hwMinMMacTnlLtrEgressPortId=hwMinMMacTnlLtrEgressPortId, hwMinMProtectRevWtrTime=hwMinMProtectRevWtrTime, hwMinMNotifications=hwMinMNotifications, hwMinMMacTnlPriorityValue=hwMinMMacTnlPriorityValue, hwMinMMacTnlLbmSize=hwMinMMacTnlLbmSize, hwMinMMacTnlLtrEgressMac=hwMinMMacTnlLtrEgressMac, hwMinMMacTnlDeiValue=hwMinMMacTnlDeiValue, hwMinMMacTnlBVlanListHigh=hwMinMMacTnlBVlanListHigh, hwMinMMacTnlLbrIn=hwMinMMacTnlLbrIn, hwMinMMacTnlSomeRdiDefect=hwMinMMacTnlSomeRdiDefect, hwMinMMacTnlCcReceiveEnabled=hwMinMMacTnlCcReceiveEnabled, hwMinMMacTnlMacPingPacketLossRatio=hwMinMMacTnlMacPingPacketLossRatio, hwMinMMacTnlLtrEntry=hwMinMMacTnlLtrEntry, hwMinMSIInterfaceType=hwMinMSIInterfaceType, hwMinMMacTnlStatisticsTable=hwMinMMacTnlStatisticsTable, hwMinMProtectRevMode=hwMinMProtectRevMode, hwMinMMacTnlLtrForwarded=hwMinMMacTnlLtrForwarded, hwMinMSIStatisticsEntry=hwMinMSIStatisticsEntry, hwMinMSIBroadcastEnable=hwMinMSIBroadcastEnable, hwMinMSIMappingRowStatus=hwMinMSIMappingRowStatus, hwMinMProtectMacTnlDMac=hwMinMProtectMacTnlDMac, hwMinMMacTnlMacPingRTTAvg=hwMinMMacTnlMacPingRTTAvg, HWOperStatus=HWOperStatus, PYSNMP_MODULE_ID=hwMinMMIB, hwMinMSIUp=hwMinMSIUp, hwMinMMacTnlLtmTimeStamp=hwMinMMacTnlLtmTimeStamp, hwMinMMacTnlSomeRMepCcmDefect=hwMinMMacTnlSomeRMepCcmDefect, hwMinMMacTnlLtrIngressPortId=hwMinMMacTnlLtrIngressPortId, hwMinMProtectSwitchOperation=hwMinMProtectSwitchOperation, hwMinMMacTnlOperStatus=hwMinMMacTnlOperStatus, HWSwitchOperation=HWSwitchOperation, hwMinMSIMacLimitMaxinum=hwMinMSIMacLimitMaxinum, hwMinMSIBindMacTnlIndex=hwMinMSIBindMacTnlIndex, hwMinMSIObjects=hwMinMSIObjects)

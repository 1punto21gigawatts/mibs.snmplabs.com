#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
Gauge32, RowPointer, Counter32, Unsigned32, StorageType, DisplayString, RowStatus, Integer32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Gauge32", "RowPointer", "Counter32", "Unsigned32", "StorageType", "DisplayString", "RowStatus", "Integer32")
AsciiString, EnterpriseDateAndTime, FixedPoint2, Link, IntegerSequence, NonReplicated, Hex, PassportCounter64 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "AsciiString", "EnterpriseDateAndTime", "FixedPoint2", "Link", "IntegerSequence", "NonReplicated", "Hex", "PassportCounter64")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Gauge32, ObjectIdentity, Counter32, TimeTicks, Counter64, Unsigned32, NotificationType, ModuleIdentity, MibIdentifier, IpAddress, iso, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Gauge32", "ObjectIdentity", "Counter32", "TimeTicks", "Counter64", "Unsigned32", "NotificationType", "ModuleIdentity", "MibIdentifier", "IpAddress", "iso", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
circuitEmulationServiceMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55))
mscAal1Ces = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119))
mscAal1CesRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 1), )
if mibBuilder.loadTexts: mscAal1CesRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesRowStatusTable.setDescription('This entry controls the addition and deletion of mscAal1Ces components.')
mscAal1CesRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"))
if mibBuilder.loadTexts: mscAal1CesRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesRowStatusEntry.setDescription('A single entry in the table represents a single mscAal1Ces component.')
mscAal1CesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAal1Ces components. These components can be added and deleted.')
mscAal1CesComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAal1CesStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesStorageType.setDescription('This variable represents the storage type value for the mscAal1Ces tables.')
mscAal1CesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16383)))
if mibBuilder.loadTexts: mscAal1CesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesIndex.setDescription('This variable represents the index for the mscAal1Ces tables.')
mscAal1CesCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 10), )
if mibBuilder.loadTexts: mscAal1CesCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscAal1CesCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"))
if mibBuilder.loadTexts: mscAal1CesCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesCidDataEntry.setDescription('An entry in the mscAal1CesCidDataTable.')
mscAal1CesCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscAal1CesProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11), )
if mibBuilder.loadTexts: mscAal1CesProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesProvTable.setDescription('This group contains basic provisioning data for the AAL1 Circuit Emulation Service.')
mscAal1CesProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"))
if mibBuilder.loadTexts: mscAal1CesProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesProvEntry.setDescription('An entry in the mscAal1CesProvTable.')
mscAal1CesServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unstructured", 0), ("basicStructured", 1), ("casStructured", 2))).clone('unstructured')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesServiceType.setDescription('This attribute specifies the service type for the CES. In an unstructured service, the entire data stream at the service interface (including any framing bits which may be present) is passed across the network transparently. The unstructured service uses the Unstructured Data Transfer (UDT) mode of AAL1. In a structured service, an Nx64kbit/s fraction of the data stream at the service interface is passed across the network. Two modes of structured service are supported: basicStructured and casStructured. In a casStructured service, the Channel Associated Signalling (CAS) bits are carried in a separate data structure from the Nx64 payload; in a basicStructured service they are not. The structured service uses the Structured Data Transfer (SDT) mode as defined in ITU-T Recommendation I.363.1. The serviceType attributes at both ends of a connection must be the same.')
mscAal1CesBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(94, 15651), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesBufferSize.setDescription("On 4pDS1Aal1 and 4pE1Aal1 cards, this attribute specifies the size of the AAL1 receive segment reassembly buffer in bytes. On initialization the buffer is filled to a level determined by cellDelayVariationTolerance. Thereafter the buffer is emptied as TDM frames are transmitted, and is filled as ATM cells are received. If the buffer overflows, sufficient data is discarded to bring the level down to that set after initialization. The cause of a buffer overflow may be one or a combination of any of the following: cell- arrival-jitter, initialization with delayed ATM cells, or TDM clock difference or wander. On 4pDS1Aal1 and 4pE1Aal1 cards, if this attribute is autoConfigure, the buffer size applied is equivalent to two times cellDelayVariationTolerance. A provisioned numeric value of bufferSize must be higher than the equivalent cellDelayVariationTolerance, plus an allowance of one ATM Cell for the quantization of data in cells, and an allowance, if applicable, for the ATM overheads of structured CES. On MSA cards this attribute's value must be autoConfigure, to acknowledge that maximumBufferDelay is provisioned instead of this attribute. Setting this attribute too low allows traffic with normal CDV to cause unnecessary loss of data on the service interface. Setting this attribute too high permits the buffer to introduce an unnecessarily high propagation delay. VALUES ( 0 = autoConfigure )")
mscAal1CesCellLossIntegrationPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 60000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesCellLossIntegrationPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesCellLossIntegrationPeriod.setDescription('This attribute specifies the cell loss integration period. This period defines the interval of time (in milliseconds) for which a loss of cells condition must persist before a buffer underflow alarm is raised. A loss of cells condition occurs when the flow of cells to the AAL1 reassembly buffer stops, causing a buffer underflow or starvation condition. The operational attribute cellLossStatus will be set to loss when the buffer underflow alarm is raised, and noLoss when it is cleared.')
mscAal1CesInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 5), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesInterfaceName.setDescription('This attribute identifies the instance of Chan to which an instance of Aal1Ces is linked.')
mscAal1CesPartialFill = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(8, 47)).clone(47)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesPartialFill.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPartialFill.setDescription('A significant source of delay in a structured service is the amount of time it takes to collect enough data to fill a cell. This period of time can be reduced by sending cells that are only partially filled with data (idlePattern octets are added to the ATM payload beyond the partial fill level). This attribute specifies the number of payload octets to fill with data. It is applicable to structured services only, and must be set to 47 for unstructured services. On a given AAL1 Function Processor, the maximum cell rate that can be sustained is dependent upon the combined bandwidths of the provisioned services, and (for structured services) the levels of partialFill. The smaller the partialFill level, the greater the cell rate and hence the fewer the services that can be sustained at that fill level.')
mscAal1CesIdleSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesIdleSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesIdleSuppression.setDescription('This attribute controls the suppression of idle cells. An idle cell is one in which the bytes of the ATM payload (up to the partialFill level) match the idlePattern. If idleSuppression is off, idle cells are not suppressed. If idleSuppression is on, at least 75% of cells are suppressed under idle conditions. The strategy is as follows: the first idle cell after a sequence of non- idle cells is always sent; those that follow are suppressed. Note, however, that at least one cell in eight is always sent (to allow the receive end to regenerate the suppressed cells) and more often than not, two cells are sent (the cell containing the AAL1 pointer, which will almost always fail to match, and the one after that).')
mscAal1CesIdlePattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 8), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(126)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesIdlePattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesIdlePattern.setDescription('This attribute specifies the pattern which the bytes of an ATM payload, up to the partialFill level, must match in order for the cell to be classified as idle. Payload bytes beyond the partialFill level are not checked. The suppression of idle cells is controlled by the attribute idleSuppression. If idleSuppression is on, at least 75% of cells are suppressed under idle conditions.')
mscAal1CesCellLossRecoveryPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesCellLossRecoveryPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesCellLossRecoveryPeriod.setDescription('This attribute specifies the cell loss recovery period. This period defines the interval of time (in seconds) for which a loss of cells condition must desist before the buffer underflow alarm is cleared. The operational attribute cellLossStatus will be set to noLoss when the buffer underflow alarm is cleared.')
mscAal1CesDummyDataByte = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 10), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesDummyDataByte.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesDummyDataByte.setDescription('This attribute specifies the pattern which is played out onto the service interface to maintain bit integrity when data is unavailable from the ATM network. For an unstructured service (serviceType is set to unstructured), dummyDataByte must be set to FF.')
mscAal1CesMaximumBufferDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 11), FixedPoint2().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 65500), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesMaximumBufferDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesMaximumBufferDelay.setDescription("This attribute specifies the maximum delay that a Cell Delay Variation buffer is permitted to add to the egress stream. The delay in the buffer is modified in response to variation in the egress cell stream. At the point that the delay would be modified in excess of the maximum, sufficient data is discarded that the delay returns to cellDelayVariationTolerance. Setting this attribute too low allows traffic with normal CDV to cause unnecessary loss of data on the service interface. Setting this attribute too high permits the buffer to introduce an unnecessarily high propagation delay. If this attribute is autoConfigure, the maximum delay tolerated in the buffer is two times cellDelayVariationTolerance. On MSA cards, 'best-effort' applies on a channel with high cellDelayVariationTolerance and low ATM bandwidth. The value applied is the same as the range limit on provisioned maximumBufferDelay on that channel. On MSA cards this attribute's value is rounded up to the nearest multiple of 0.125ms when applied to the buffer. The range is nominally 0.12..63.62ms, but the upper limit may be reduced by up to 6ms one a channel with high cellDelayVariationTolerance and low ATM bandwidth. On 4pDS1Aal1 and 4pE1Aal1 cards this attribute's value is rounded up to the nearest multiple of 1ms when applied to the buffer. The upper limit is roughly inverse- proportional to the ATM bandwidth of the channel. VALUES ( 0 = autoConfigure )")
mscAal1CesDp2CellDelayVariationTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 11, 1, 12), FixedPoint2().subtype(subtypeSpec=ValueRangeConstraint(1, 65500)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesDp2CellDelayVariationTolerance.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesDp2CellDelayVariationTolerance.setDescription("This attribute specifies the maximum time that a cell may arrive late, compared to a nominal time established at buffer initialization, without producing errors on the service interface. The nominal time of a cell's arrival is predicted according to the time interval required to transmit a cell's worth of data on the service interface. This attribute's value is the delay that the Cell Delay Variation Tolerance buffer adds to the egress stream immediately after the buffer initializes. The buffer absorbs variation in the arrival time of cells from the network, so that a steady stream of data appears on the service interface. If the buffer underflows, due to a late cell, fill- in data is output on the service interface while the buffer re- initializes. When the buffer has re-initialized, normal data is output on the service interface and the delay in the buffer is restored to the value of this attribute. This attribute must have a value lower than a numeric value of maximumBufferDelay. The relationship between this attribute and bufferSize is described under that attribute. Setting this attribute too low allows traffic with normal CDV to cause unnecessary loss of data on the service interface. Setting this attribute too high imposes an unnecessarily high propagation delay on the egress stream. On MSA cards this attribute's provisionable range is 0.01..32ms and the value applied is rounded up to the nearest multiple of 0.125ms. On 4pDS1Aal1 and 4pE1Aal1 cards, this attribute's provisionable range is strongly dependent on the bandwidth of the channel, and the value applied is rounded up to the nearest whole number of milliseconds, then rounded down to the equivalent number of cells.")
mscAal1CesStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12), )
if mibBuilder.loadTexts: mscAal1CesStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscAal1CesStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"))
if mibBuilder.loadTexts: mscAal1CesStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesStateEntry.setDescription('An entry in the mscAal1CesStateTable.')
mscAal1CesAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscAal1CesOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscAal1CesUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscAal1CesAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscAal1CesProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscAal1CesControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscAal1CesAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscAal1CesStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscAal1CesUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscAal1CesOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 13), )
if mibBuilder.loadTexts: mscAal1CesOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesOperTable.setDescription('This group contains status information about the AAL1 Circuit Emulation Service.')
mscAal1CesOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"))
if mibBuilder.loadTexts: mscAal1CesOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesOperEntry.setDescription('An entry in the mscAal1CesOperTable.')
mscAal1CesCellLossStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noLoss", 0), ("loss", 1))).clone('noLoss')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesCellLossStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesCellLossStatus.setDescription('This attribute is set to loss when a buffer underflow alarm is raised (see cellLossIntegrationPeriod), and noLoss when it is clear.')
mscAal1CesAal1LayerLossStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noLoss", 0), ("loss", 1))).clone('noLoss')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAal1LayerLossStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAal1LayerLossStatus.setDescription('This attribute is set to loss when an AAL1 layer alarm is raised, and noLoss when it is clear.')
mscAal1CesConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connected", 0), ("channelNotReady", 1), ("atmNotReady", 2), ("atmNotConfigured", 3))).clone('channelNotReady')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesConnectionStatus.setDescription("This attribute indicates whether a service is non-operational because of a problem with the service interface side of the service (in which case, it is set to channelNotReady) or because of a problem with the ATM side of the service (in which case, it is set to atmNotConfigured or atmNotReady). When this attribute is set to channelNotReady, it is an indication that the corresponding Chan component (as defined by the attribute interfaceName) or the Chan component's parent port component (Lp/n Ds1/m or Lp/n E1/m) is locked. When this attribute is set to atmNotConfigured, it is an indication that no sub-component has been provisioned, and thus no ATM connection has been configured for the service. When this attribute is set to atmNotReady, it is an indication that the ATM connection with which the service is associated (as defined by a sub-component) has been lost or that it is currently unable to carry CES data. This attribute is set to connected when a service is operational (that is, the OSI attribute operationalState is enabled.)")
mscAal1CesStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14), )
if mibBuilder.loadTexts: mscAal1CesStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesStatsTable.setDescription('This group contains statistical data for an AAL1 Circuit Emulation Service.')
mscAal1CesStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"))
if mibBuilder.loadTexts: mscAal1CesStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesStatsEntry.setDescription('An entry in the mscAal1CesStatsTable.')
mscAal1CesCellsTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesCellsTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesCellsTransmitted.setDescription('This attribute counts the total number of cells transmitted to the backplane (ingress direction). This includes cells containing CBR data, trunk conditioning cells (structured services), and unframed AIS cells (unstructured services). The counter wraps when the maximum value is exceeded.')
mscAal1CesCellsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesCellsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesCellsReceived.setDescription('This attribute counts the total number of cells received from the backplane (egress direction). This includes CBR user data cells, cells with AAL1 header errors (correctable and non-correctable) and cells with AAL1 sequencing errors. The counter wraps when the maximum value is exceeded.')
mscAal1CesLostCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLostCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLostCells.setDescription('This attribute counts the number of cells declared as never received by the AAL1 protocol layer. The counter wraps when the maximum value is exceeded.')
mscAal1CesBufferUnderflows = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesBufferUnderflows.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesBufferUnderflows.setDescription('This attribute counts the number of times the AAL1 reassembly buffer underflows. In the case of a continuous buffer starvation, a single buffer underflow event will be counted. The counter wraps when the maximum value is exceeded.')
mscAal1CesBufferOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesBufferOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesBufferOverflows.setDescription('This attribute counts the number of times the AAL1 reassembly buffer overflows. Buffer overflows occur when AAL1 cells arrive at a rate above that which is expected. Occurrences of this condition may be reduced by increasing the value of the attribute bufferSize or maximumBufferDelay. The buffer overflow counter wraps when the maximum value is exceeded.')
mscAal1CesReassembledCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesReassembledCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesReassembledCells.setDescription('This attribute counts the number of received cells whose payload has been played out to the service interface. The counter wraps when the maximum value is exceeded.')
mscAal1CesHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesHeaderErrors.setDescription('This attribute counts the number of cells received with AAL1 header errors. The counter wraps when the maximum value is exceeded.')
mscAal1CesPointerReframes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesPointerReframes.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPointerReframes.setDescription('This attribute counts the number of times that the AAL1 reassembly unit found an SDT pointer where it was not expected to be, and as a result had to reacquire it. Errors of this kind can occur because of problems at the far end. This attribute is meaningful for structured services only, and will be 0 for unstructured services. This counter wraps when the maximum value is exceeded.')
mscAal1CesPointerParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesPointerParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPointerParityErrors.setDescription('This attribute counts the number of times that the AAL1 reassembly unit detects a parity check failure at the point where an SDT pointer is expected. Errors of this kind can occur because of problems at the far end. This attribute is meaningful for structured services only, and will be 0 for unstructured services. This counter wraps when the maximum value is exceeded.')
mscAal1CesAal1SequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAal1SequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAal1SequenceErrors.setDescription('This attribute counts the number of times that the sequence number of an incoming AAL1 Type 1 SAR-PDU gets out of synchronisation, as defined by ITU-T Recommendation I.363.1. This counter wraps when the maximum value is exceeded.')
mscAal1CesMisinsertedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 14, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesMisinsertedCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesMisinsertedCells.setDescription('This attribute counts the number of AAL1 sequence violations which the AAL convergence sublayer interprets as misinserted cells, as defined by ITU-T I.363.1. This counter wraps when the maximum value is exceeded.')
mscAal1CesNap = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2))
mscAal1CesNapRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 1), )
if mibBuilder.loadTexts: mscAal1CesNapRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapRowStatusTable.setDescription('This entry controls the addition and deletion of mscAal1CesNap components.')
mscAal1CesNapRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesNapIndex"))
if mibBuilder.loadTexts: mscAal1CesNapRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapRowStatusEntry.setDescription('A single entry in the table represents a single mscAal1CesNap component.')
mscAal1CesNapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesNapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAal1CesNap components. These components can be added and deleted.')
mscAal1CesNapComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesNapComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAal1CesNapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesNapStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapStorageType.setDescription('This variable represents the storage type value for the mscAal1CesNap tables.')
mscAal1CesNapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAal1CesNapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapIndex.setDescription('This variable represents the index for the mscAal1CesNap tables.')
mscAal1CesNapProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 10), )
if mibBuilder.loadTexts: mscAal1CesNapProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapProvTable.setDescription('This group contains the provisioning data for the NailedUpAdaptationPoint component.')
mscAal1CesNapProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesNapIndex"))
if mibBuilder.loadTexts: mscAal1CesNapProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapProvEntry.setDescription('An entry in the mscAal1CesNapProvTable.')
mscAal1CesNapAtmConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesNapAtmConnection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesNapAtmConnection.setDescription('This attribute specifies the identity of the component to which the NailedUpAdaptationPoint is linked. This is an AtmIf Vcc NailedUpEndPoint or an AtmIf Vpt Vcc NailedUpEndPoint (the AAL1 cells are transported off the switch over an ATM UNI, where they are routed to the appropriate AAL1 entity at the other end by the ATM bearer service).')
mscAal1CesAep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3))
mscAal1CesAepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 1), )
if mibBuilder.loadTexts: mscAal1CesAepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepRowStatusTable.setDescription('This entry controls the addition and deletion of mscAal1CesAep components.')
mscAal1CesAepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesAepIndex"))
if mibBuilder.loadTexts: mscAal1CesAepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepRowStatusEntry.setDescription('A single entry in the table represents a single mscAal1CesAep component.')
mscAal1CesAepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAal1CesAep components. These components can be added and deleted.')
mscAal1CesAepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAal1CesAepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepStorageType.setDescription('This variable represents the storage type value for the mscAal1CesAep tables.')
mscAal1CesAepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAal1CesAepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepIndex.setDescription('This variable represents the index for the mscAal1CesAep tables.')
mscAal1CesAepProvEndPointAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 10), )
if mibBuilder.loadTexts: mscAal1CesAepProvEndPointAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepProvEndPointAddrTable.setDescription('This group contains NSAP address provisioning data for components using switched virtual circuits.')
mscAal1CesAepProvEndPointAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesAepIndex"))
if mibBuilder.loadTexts: mscAal1CesAepProvEndPointAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepProvEndPointAddrEntry.setDescription('An entry in the mscAal1CesAepProvEndPointAddrTable.')
mscAal1CesAepExpectedRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepExpectedRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepExpectedRemoteAddress.setDescription('This attribute specifies the expected remote address prefix for an incoming connection setup request. If expectedRemoteAddress is not empty, only matching connections will be considered for acceptance. If expectedRemoteAddress is 40 characters long, the remote address must match exactly to be accepted. If expectedRemoteAddress is less than 40 characters long, the remote address must begin with expectedRemoteAddress to be accepted. If expectedRemoteAddress is empty, the component will process connection requests from any remote address.')
mscAal1CesAepLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepLocalAddress.setDescription('This attribute specifies the local NSAP address. If the switch prefix (the nodePrefix attribute of the ModuleData component) has been provisioned, a default value for localAddress based on nodePrefix will be provided. If ModuleData nodePrefix has not been provisioned and one or more alternate switch prefixes (the alternatePorsPrefixes attribute of the ModuleData component) have been provisioned, a default value for localAddress based on the first provisioned alternatePorsPrefix value will be provided. If no switch prefixes have been provisioned, localAddress will default to an empty string. To obtain a valid default localAddress in this case, either or both of the ModuleData nodePrefix and ModuleData alternatePorsPrefixes attributes must be provisioned, and this end point component must then be deleted and re-added.')
mscAal1CesAepProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11), )
if mibBuilder.loadTexts: mscAal1CesAepProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepProvTable.setDescription('This group contains the provisioning data specific to the ActiveEndPoint component.')
mscAal1CesAepProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesAepIndex"))
if mibBuilder.loadTexts: mscAal1CesAepProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepProvEntry.setDescription('An entry in the mscAal1CesAepProvTable.')
mscAal1CesAepAddressToCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepAddressToCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepAddressToCall.setDescription('This attribute specifies the remote NSAP address which this ActiveEndPoint will call.')
mscAal1CesAepRoutingOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("porsOnly", 0), ("atmOnly", 1), ("porsFirst", 2), ("atmFirst", 3))).clone('porsOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepRoutingOption.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepRoutingOption.setDescription('This attribute specifies the type of routing to use for establishing the connection: AAL1 cards accept only porsOnly. Multi-Service Access cards accept all four options. porsOnly means that only the Path Oriented Routing System may be used in establishing a connection. atmOnly means that only the native ATM Routing may be used in establishing a connection. porsFirst means that the switch tries to establish a connection using the Path Oriented Routing System first, and, if the connection cannot be established, it tries native ATM Routing instead. atmFirst means that the switch tries to establish a connection using native ATM Routing first, and, if the connection cannot be established, it tries the Path Oriented Routing System instead.')
mscAal1CesAepProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepProfile.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepProfile.setDescription('This attribute specifies the PORS routing profile to use for this connection. If profile is empty, PORS will provide a default profile.')
mscAal1CesAepFirstRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepFirstRetryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepFirstRetryInterval.setDescription('This attribute specifies the time to wait, in seconds, before attempting to establish the connection after the first failed attempt. The time to wait between subsequent call attempts will generally differ due to a backoff scheme.')
mscAal1CesAepRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepRetryLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepRetryLimit.setDescription('retryLimit specifies the maximum number of consecutive unsuccessful connection setup attempts that may be made before further attempts are abandoned. If this limit is reached, the Restart verb may be used to restart connection attempts. If retryLimit is 0, there is no limit; attempts will continue indefinitely until a successful connection is established.')
mscAal1CesAepActiveEndPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("svc", 0), ("softPVC", 1))).clone('svc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepActiveEndPointType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepActiveEndPointType.setDescription('activeEndPointType specifies the type of end point: svc or softPvc. The default is svc. When activeEndPointType is svc, calledVpiVci is not relevant. When activeEndPointType is softPVC, routingOption must be atmOnly, and profile, firstRetryInterval, and retryLimit are not relevant.')
mscAal1CesAepCalledVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 11, 1, 7), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesAepCalledVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepCalledVpiVci.setDescription('calledVpiVci specifies the identity of the PVC at the remote ATM node on which the softPVC connection terminates. calledVpiVci is relevant only when activeEndPointType is set to softPVC. The default value is 0.1')
mscAal1CesAepEpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 12), )
if mibBuilder.loadTexts: mscAal1CesAepEpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepEpOperTable.setDescription('This group contains general operational attributes for components using switched virtual circuits.')
mscAal1CesAepEpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesAepIndex"))
if mibBuilder.loadTexts: mscAal1CesAepEpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepEpOperEntry.setDescription('An entry in the mscAal1CesAepEpOperTable.')
mscAal1CesAepRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepRemoteAddress.setDescription('remoteAddress is the address of the remote end point. If a connection is currently established, remoteAddress will contain the address of the remote end point. If a connection is not established, remoteAddress will be Unknown.')
mscAal1CesAepLastTearDownCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepLastTearDownCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepLastTearDownCause.setDescription('lastTearDownCause indicates the cause of the last connection tear down. The values are as defined in the ATM Forum ATM User-Network Interface (UNI) Specification.')
mscAal1CesAepLastTearDownDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 12, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepLastTearDownDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepLastTearDownDiagnostic.setDescription('lastTearDownDiagnostic provides a diagnostic to supplement the lastTearDownCause attribute.')
mscAal1CesAepOutTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 13), )
if mibBuilder.loadTexts: mscAal1CesAepOutTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepOutTable.setDescription('This group contains status information about the AAL1 Circuit Emulation Service ActiveEndPoint component.')
mscAal1CesAepOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesAepIndex"))
if mibBuilder.loadTexts: mscAal1CesAepOutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepOutEntry.setDescription('An entry in the mscAal1CesAepOutTable.')
mscAal1CesAepSvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("initialising", 0), ("connecting", 1), ("connected", 2), ("idle", 3), ("retriesExhausted", 4), ("failed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepSvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepSvcStatus.setDescription('svcStatus indicates the status of the incoming and outgoing connections. When this attribute has the value initialising, it indicates that the component is initialising when first created; a connection has not been established, and no incoming setup requests will be processed. When this attribute has the value connecting, it indicates that a connection has not yet been established, but that incoming setup requests will be processed. When this attribute has the value connected, it indicates that a connection has been established. When this attribute has the value retriesExhausted, it indicates that retryLimit consecutive connection setup attempts have failed, and the connection procedure has been aborted. When this attribute has the value idle, it indicates that a connection has not been established, and that no incoming setup requests will be processed. When this attribute has the value failed, it indicates that the connections is in a state other than those described above.')
mscAal1CesAepLastSetupFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepLastSetupFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepLastSetupFailureCause.setDescription('lastSetupFailureCause indicates the cause of the last connection setup failure. The values are as defined in the ATM Forum ATM User- Network Interface (UNI) Specification.')
mscAal1CesAepLastSetupFailureDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 13, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepLastSetupFailureDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepLastSetupFailureDiagnostic.setDescription('lastSetupFailureDiagnostic provides a diagnostic to supplement the lastSetupFailureCause attribute.')
mscAal1CesAepRetryTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepRetryTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepRetryTimeRemaining.setDescription('retryTimerValue is the current value of the retry timer for this connection; it indicates the number of seconds before the next connection attempt will be made. retryTimerValue is initialized when a connection attempt fails. When retryTimerValue reaches 0, an attempt will be made to establish the connection. When the timer is not running, for example when the connection has been established, retryTimerValue will be 0.')
mscAal1CesAepRetryFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 3, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAepRetryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAepRetryFailures.setDescription('retryFailures counts the number of consecutive failed connection attempts. retryFailures is reset to 0 whenever a connection is successfully established, or the connection is restarted using the Restart verb. The counter wraps when the maximum value is exceeded.')
mscAal1CesPep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4))
mscAal1CesPepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 1), )
if mibBuilder.loadTexts: mscAal1CesPepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepRowStatusTable.setDescription('This entry controls the addition and deletion of mscAal1CesPep components.')
mscAal1CesPepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesPepIndex"))
if mibBuilder.loadTexts: mscAal1CesPepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepRowStatusEntry.setDescription('A single entry in the table represents a single mscAal1CesPep component.')
mscAal1CesPepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesPepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAal1CesPep components. These components can be added and deleted.')
mscAal1CesPepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesPepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAal1CesPepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesPepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepStorageType.setDescription('This variable represents the storage type value for the mscAal1CesPep tables.')
mscAal1CesPepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAal1CesPepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepIndex.setDescription('This variable represents the index for the mscAal1CesPep tables.')
mscAal1CesPepProvEndPointAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 10), )
if mibBuilder.loadTexts: mscAal1CesPepProvEndPointAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepProvEndPointAddrTable.setDescription('This group contains NSAP address provisioning data for components using switched virtual circuits.')
mscAal1CesPepProvEndPointAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesPepIndex"))
if mibBuilder.loadTexts: mscAal1CesPepProvEndPointAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepProvEndPointAddrEntry.setDescription('An entry in the mscAal1CesPepProvEndPointAddrTable.')
mscAal1CesPepExpectedRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesPepExpectedRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepExpectedRemoteAddress.setDescription('This attribute specifies the expected remote address prefix for an incoming connection setup request. If expectedRemoteAddress is not empty, only matching connections will be considered for acceptance. If expectedRemoteAddress is 40 characters long, the remote address must match exactly to be accepted. If expectedRemoteAddress is less than 40 characters long, the remote address must begin with expectedRemoteAddress to be accepted. If expectedRemoteAddress is empty, the component will process connection requests from any remote address.')
mscAal1CesPepLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesPepLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepLocalAddress.setDescription('This attribute specifies the local NSAP address. If the switch prefix (the nodePrefix attribute of the ModuleData component) has been provisioned, a default value for localAddress based on nodePrefix will be provided. If ModuleData nodePrefix has not been provisioned and one or more alternate switch prefixes (the alternatePorsPrefixes attribute of the ModuleData component) have been provisioned, a default value for localAddress based on the first provisioned alternatePorsPrefix value will be provided. If no switch prefixes have been provisioned, localAddress will default to an empty string. To obtain a valid default localAddress in this case, either or both of the ModuleData nodePrefix and ModuleData alternatePorsPrefixes attributes must be provisioned, and this end point component must then be deleted and re-added.')
mscAal1CesPepEpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 11), )
if mibBuilder.loadTexts: mscAal1CesPepEpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepEpOperTable.setDescription('This group contains general operational attributes for components using switched virtual circuits.')
mscAal1CesPepEpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesPepIndex"))
if mibBuilder.loadTexts: mscAal1CesPepEpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepEpOperEntry.setDescription('An entry in the mscAal1CesPepEpOperTable.')
mscAal1CesPepRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesPepRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepRemoteAddress.setDescription('remoteAddress is the address of the remote end point. If a connection is currently established, remoteAddress will contain the address of the remote end point. If a connection is not established, remoteAddress will be Unknown.')
mscAal1CesPepLastTearDownCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesPepLastTearDownCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepLastTearDownCause.setDescription('lastTearDownCause indicates the cause of the last connection tear down. The values are as defined in the ATM Forum ATM User-Network Interface (UNI) Specification.')
mscAal1CesPepLastTearDownDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 11, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesPepLastTearDownDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepLastTearDownDiagnostic.setDescription('lastTearDownDiagnostic provides a diagnostic to supplement the lastTearDownCause attribute.')
mscAal1CesPepPassiveOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 12), )
if mibBuilder.loadTexts: mscAal1CesPepPassiveOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepPassiveOperTable.setDescription('This group contains status information about the AAL1 Circuit Emulation Service PassiveEndPoint component.')
mscAal1CesPepPassiveOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesPepIndex"))
if mibBuilder.loadTexts: mscAal1CesPepPassiveOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepPassiveOperEntry.setDescription('An entry in the mscAal1CesPepPassiveOperTable.')
mscAal1CesPepSvcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 5))).clone(namedValues=NamedValues(("initialising", 0), ("connecting", 1), ("connected", 2), ("idle", 3), ("failed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesPepSvcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesPepSvcStatus.setDescription('svcStatus indicates the status of the incoming connection. When this attribute has the value initialising, it indicates that the component is initialising when first created; a connection has not been established, and no incoming setup requests will be processed. When this attribute has the value connecting, it indicates that a connection has not yet been establised, but that incoming setup requests will be processed. When this attribute has the value connected, it indicates that a connection has been established. When this attribute has the value idle, it indicates that a connection has not been established, and that no incoming setup requests will be processed. When this attribute has the value failed, it indicates that the connections is in a state other than those described above.')
mscAal1CesLCo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5))
mscAal1CesLCoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 1), )
if mibBuilder.loadTexts: mscAal1CesLCoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRowStatusTable.setDescription('This entry controls the addition and deletion of mscAal1CesLCo components.')
mscAal1CesLCoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesLCoIndex"))
if mibBuilder.loadTexts: mscAal1CesLCoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRowStatusEntry.setDescription('A single entry in the table represents a single mscAal1CesLCo component.')
mscAal1CesLCoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAal1CesLCo components. These components cannot be added nor deleted.')
mscAal1CesLCoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAal1CesLCoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoStorageType.setDescription('This variable represents the storage type value for the mscAal1CesLCo tables.')
mscAal1CesLCoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAal1CesLCoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoIndex.setDescription('This variable represents the index for the mscAal1CesLCo tables.')
mscAal1CesLCoPathDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10), )
if mibBuilder.loadTexts: mscAal1CesLCoPathDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathDataTable.setDescription('This group contains all operational attributes for the path oriented LCo.')
mscAal1CesLCoPathDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesLCoIndex"))
if mibBuilder.loadTexts: mscAal1CesLCoPathDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathDataEntry.setDescription('An entry in the mscAal1CesLCoPathDataTable.')
mscAal1CesLCoState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pathDown", 0), ("selectingRoute", 1), ("connecting", 2), ("pathUp", 3), ("pathDownRetrying", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoState.setDescription('This attribute reflects the current state of the connection. The pathDown state indicates a connection that has no remote end provisioned or the application has not yet signalled for a path. The selectingRoute state occurs when a request has been sent to route selector and it has not yet responded. The connectingState occurs while a path is being established. The pathUp state is the normal operational state of a path. The pathDownRetrying state indicates a path that attempted route selection but received no route and is now waiting to retry route selection again.')
mscAal1CesLCoOverrideRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAal1CesLCoOverrideRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoOverrideRemoteName.setDescription("If set and the current PLC remoteName is blank this remoteName will override the blank PLC remoteName. Usually you would set this attribute and then lock/unlock the service component which will result in this new overrideRemoteName being used as if it had been provisioned into the PLC remoteName. The advantage of this attribute is that the connection's remoteName can be changed immediately without having to 'activate prov' but the disadvantage is that the overrideRemoteName is not permanent and if the card or switch is reset the override will be lost.")
mscAal1CesLCoEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("calling", 0), ("called", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoEnd.setDescription('This attribute identifies whether this is the calling or called end of the path.')
mscAal1CesLCoCostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoCostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoCostMetric.setDescription("This attribute gives the route's total cost metric. It is calculated as the sum of the cost metric of all trunks in the path at the time the connection was established. The cost metric of a trunk is defined by the trunkCost attribute of the Trunk component. The costMetric for an LCo that is originated and terminated on the same module is 0.")
mscAal1CesLCoDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoDelayMetric.setDescription('This attribute gives the total delay of the route as the one way delay for a 512 byte packet. It is calculated as the sum of the delays of all trunks in the path stored in topology at the time the connection was established. The delay for an LCo that is originated and terminated on the same module is 0.')
mscAal1CesLCoRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRoundTripDelay.setDescription('This attribute contains the time taken for a packet (cell) of 44 bytes to be transmitted to the remote LCo and return to this LCo. The number reported is given in milliseconds to the nearest millisecond. A value of one millisecond is reported if the time is less than 1 millisecond even though the delay may be less than 1 Millisecond when the LCo is originated and terminated on the same module.')
mscAal1CesLCoSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoSetupPriority.setDescription('This attribute gives the priority at which the current path is established. Zero is the highest priority and four is the lowest. The holdingPriority, a complementary attribute of this component, indicates the priority a path maintains once it is established.')
mscAal1CesLCoHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoHoldingPriority.setDescription('This attribute gives the priority at which a path holds its current path once the path is established. Zero is the highest priority and four is the lowest. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time.')
mscAal1CesLCoRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRequiredTxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of the trunks of its route. This attribute represents the bandwidth for traffic outgoing to the remote end point. The originating end of the connection determines this value.')
mscAal1CesLCoRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRequiredRxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of trunks of its route. This attribute represents the bandwidth for traffic incoming from the remote end point. The originating end of the connection determines this value')
mscAal1CesLCoRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRequiredTrafficType.setDescription('This operational attribute indicates the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1 then only trunks that include trafficType1 in supportedTrafficType, will be candidates for this connection.')
mscAal1CesLCoPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPermittedTrunkTypes.setDescription("This operational attribute lists up to eight types of trunk that can be used on the route. The originating end of the connection determines the types. The terrestrial and satellite trunk types have been defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS only chooses trunks whose trunkType are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
mscAal1CesLCoRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRequiredSecurity.setDescription("This attribute indicates the required minimum level of security of the trunks on the route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
mscAal1CesLCoRequiredCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoRequiredCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRequiredCustomerParameter.setDescription('This attribute indicates the allowed customer defined parameter of the trunks on the route.The originating end of the connection determines the customer defined parameter. Its value, a number from zero to seven, is chosen by a network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
mscAal1CesLCoEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoEmissionPriority.setDescription('This attribute indicates the urgency with which packets on the path are emitted by the trunks on the route. The originating end of the connection selects the emissionPriority. EmissionPriority of zero indicates the highest emission priority, while two indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher).')
mscAal1CesLCoDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path.The originating end of the connection sets discardPriority. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
mscAal1CesLCoPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("manual", 1), ("forced", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoPathType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathType.setDescription('This attribute indicates whether the path for this PLC was determined automatically or by static provisioning. Normal pathTypes are selected automatically by Route Selector.The other pathTypes are both manual pathTypes where the operator must specify, through provisioning, a static route termed the manualPath. A manual pathType connection is nearly identical to a normal path type connection with the exception that the route is pre-provisioned. For a manual pathType, bandwidth reservations are respected along the path exactly as in a normal path. The last type, the forced pathType, is also a manual path but regardless of the bandwidth available the route is granted provided the trunks are operational and there are sufficient Logical Channels (LChs). The forced pathType could result in over committing the reserved bandwidth allowed on a trunk. A better way to achieve the effects of a forced pathType is to use a manual pathType with setupPriority = 0 and holdingPriority = 0. In this manner the path will reserve correct bandwidth and it will bump other paths if required while not being bumped itself.')
mscAal1CesLCoRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoRetryCount.setDescription('This attribute is the count of the number of times the path chosen during route selection could not be instantiated. This count should be three or below if the network is performing adequately. A high value indicates that the route selection is often performed using an out-of-date view of available network bandwidth and/or topology. This attribute will only increase at the calling end of the connection. This attribute is reset each time a path reconnects and stops counting when it reaches its maximum value.')
mscAal1CesLCoPathFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoPathFailureCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathFailureCount.setDescription('This attribute is the count of the number of times the path has successfully connected. It is set to zero the first time the path is up. If a path fails anytime after connecting this count will be incremented when the path is up again. Failed route requests do not count in this statistic. See retryCount above. This attribute stops counting at its maximum value.')
mscAal1CesLCoReasonForNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("none", 0), ("destinationNameTooLong", 1), ("destinationNotSpecified", 2), ("unknownDestinationName", 3), ("incorrectDestination", 4), ("incorrectDestinationEndPoint", 5), ("unknownSource", 6), ("unknownDestination", 7), ("sameNode", 8), ("routeCostTooMuch", 9), ("routesDelayTooLong", 10), ("attributesNotMet", 11), ("anError", 12), ("attributeProfileProblem", 13), ("manualPathIndexProblem", 14))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoReasonForNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoReasonForNoRoute.setDescription("This attribute is the route selection's reasonForNoRoute and provides a brief reason for which a route was not selected. The reasons are essentially self-explanatory. Perhaps two reasons for no route require some explanation. The reason unknownRemoteNodeName is issued when the remote node name is not in the topological database. The reason plcAttributesNotMet is issued when there is no network connectivity at a level specified by the PLC attributes. This reason is also issued when there is no physical connectivity between two end nodes.")
mscAal1CesLCoLastTearDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("none", 0), ("normalShutDown", 1), ("insufficientTxLcOrBandwidth", 2), ("insufficientRxLcOrBandwidth", 3), ("trunkFailure", 4), ("trunkCardFailure", 5), ("operatorForced", 6), ("lostLcnClash", 7), ("networkCongestion", 8), ("trunkNotFound", 9), ("farEndNotFound", 10), ("wrongModuleReached", 11), ("farEndBusy", 12), ("callLoopedBack", 13), ("unknownReason", 14), ("farEndNotReady", 15), ("remoteNameMismatch", 16), ("serviceTypeMismatch", 17), ("reconnectFromFarEnd", 18), ("bumped", 19), ("accessCardFailure", 20), ("optimized", 21), ("overrideRemoteName", 22), ("trunkOrFarEndDidNotSupportMode", 23))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoLastTearDownReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoLastTearDownReason.setDescription("This attribute reflects the last tear down reason for a connection (LCo). In many cases this displays the reason for a momentary service interruption. This attribute applies to the last path failure only. If a path is no longer up, this may give an indication to the reason that the path has failed. In many cases an alarm will also be generated with more specific information. The following is a brief description of the reasons: none - This path has no information for the teardown this is typical of a path provisioned with no remoteName that has not been up. normalShutDown - This path has gone down due to normal call termination. insufficientTxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the transmit direction. insufficientRxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the receive direction. trunkFailure- A trunk on the path has failed or has gone down due to a provisioning change of a critical attribute. trunkCardFailure- A trunk FP card has failed along the path. accessCardFailure- The FP on which the peer access service was running has failed. operatorForced- The path has terminated due to the operator locking a trunk along the path. lostLcnClash- The path has terminated because the PA's at both ends of an intermediate trunk have allocated the same LC to different calls. When this happens both calls must go down and then try to come up again a fraction of a second later (effectively ensuring that they will now be assigned different LC's). It is normal to get the odd clash especially when the PA's usedLC is approaching the PA's maxLC. networkCongestion - The path has failed due to control information being lost and not recoverable. trunkNotFound - Occurs on a manual path usually. Check for trunks not up or names provisioned incorrectly. farEndNotFound - The far end is not provisioned or is not up. Check remote Name. wrongModuleReached - This may occur on a manual path. Check provisioning for correct trunk and service names. For a normal path, the network Topology may be changing check remoteName. farEndBusy - The far end has been reached but it is busy. Check remoteName and remote end provisioning. callLoopedBack - This LCo is provisioned to call itself. Re- provision since this is invalid. unknownReason - The failure was not resolved. farEndNotReady - The remote end was reached but the connection was refused due to the remote end not being enabled. remoteNameMismatch - The remote end has alarmed and rejected this setup due to remoteName provisioning. serviceTypeMismatch - The remote Service Type does not match this service type. Check provisioning. reconnectFromFarEnd - The remote end re-established this connection. Check the remote end lastTearDownReason to determine the real reason. bumped - Another call bumped this path from a trunk to get bandwidth (or an LC) which it required to come up. This other path had a higher setupPriority than this path's holdingPriority hence it was allowed to steal the bandwidth (or LC) from this path. optimized - This call has been rerouted due to the optimization feature. The call is still active this just indicates why the path changed. trunkOrFarEndDidNotSupportMode - This call was unable to complete because a mode required by the service was not supported by one of the trunks the route went through or by the far end service it connected to. Currently the only mode that this applies to is the map/mux mode on TRUNK PA ATM component. Map mode was required by the application (CES/FrAtm etc.) but was not available on the TRUNK PA ATM component through which the call was routed or the far end CES/FrAtm component did not specify the same mode.")
mscAal1CesLCoPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathFailureAction.setDescription('This attribute displays whether the application is set to tolerate momentary interruption of a path while a new path is selected. If disconnectConnection is displayed, the application is informed as soon as possible about a failure by disconnection. If the attribute displays reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails the application is informed of the failure. With this option set to reRoutePath the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. Note that if PLC components are different at both ends only the calling end is allowed to reconnect. All pathTypes respect this attribute. Also on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option will have the desired effect that the path is rerouted without complete disconnection at both ends')
mscAal1CesLCoBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoBumpPreference.setDescription("This attribute specifies when bumping will occur during route selection process. Bumping may occur when necessary or always. It will be necessary for a connection to bump if there is not enough resources for the connection to be established and these resources are occupied by a connection whose setupPriority is lower (numerically higher) than the connection's setupPriority. A connection may also always bump in order to obtain the best route.")
mscAal1CesLCoOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoOptimization.setDescription('This attribute is used to specify whether this connection should attempt to optimize its path when requested by the routing PORS component. Every path is as optimal as it can be when it is established, but as network traffic patterns and configurations change this path may no longer be as optimal as it could be. The PORS connection manager on a module requests circuits to optimize at the optimization interval.')
mscAal1CesLCoPathUpDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 10, 1, 25), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoPathUpDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathUpDateTime.setDescription('This is the time stamp when the current path was established or reestablished.')
mscAal1CesLCoStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 11), )
if mibBuilder.loadTexts: mscAal1CesLCoStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoStatsTable.setDescription('This group contains the operational statistics attributes for the path oriented LCo.')
mscAal1CesLCoStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesLCoIndex"))
if mibBuilder.loadTexts: mscAal1CesLCoStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoStatsEntry.setDescription('An entry in the mscAal1CesLCoStatsTable.')
mscAal1CesLCoPktsToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoPktsToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPktsToNetwork.setDescription('This attribute counts the number of packets transmitted to the network over this Logical Connection.')
mscAal1CesLCoBytesToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoBytesToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoBytesToNetwork.setDescription('This attribute counts the number of bytes sent to the network over this Logical Connection.')
mscAal1CesLCoPktsFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 11, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoPktsFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPktsFromNetwork.setDescription('This attribute counts the number of packets received from the remote LCo via the network.')
mscAal1CesLCoBytesFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoBytesFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoBytesFromNetwork.setDescription('This attribute counts the number of bytes received from the remote LCo via the network.')
mscAal1CesLCoPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 264), )
if mibBuilder.loadTexts: mscAal1CesLCoPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathTable.setDescription('This attribute contains the trunk component names over which the path has been instantiated and the remote end point name terminating the path.')
mscAal1CesLCoPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 264, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesLCoIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesLCoPathValue"))
if mibBuilder.loadTexts: mscAal1CesLCoPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathEntry.setDescription('An entry in the mscAal1CesLCoPathTable.')
mscAal1CesLCoPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 5, 264, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesLCoPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesLCoPathValue.setDescription('This variable represents both the value and the index for the mscAal1CesLCoPathTable.')
mscAal1CesAtmCon = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6))
mscAal1CesAtmConRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 1), )
if mibBuilder.loadTexts: mscAal1CesAtmConRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConRowStatusTable.setDescription('This entry controls the addition and deletion of mscAal1CesAtmCon components.')
mscAal1CesAtmConRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesAtmConIndex"))
if mibBuilder.loadTexts: mscAal1CesAtmConRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConRowStatusEntry.setDescription('A single entry in the table represents a single mscAal1CesAtmCon component.')
mscAal1CesAtmConRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAtmConRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAal1CesAtmCon components. These components cannot be added nor deleted.')
mscAal1CesAtmConComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAtmConComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAal1CesAtmConStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAtmConStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConStorageType.setDescription('This variable represents the storage type value for the mscAal1CesAtmCon tables.')
mscAal1CesAtmConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAal1CesAtmConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConIndex.setDescription('This variable represents the index for the mscAal1CesAtmCon tables.')
mscAal1CesAtmConOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 10), )
if mibBuilder.loadTexts: mscAal1CesAtmConOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConOperTable.setDescription('This attribute group contains the operational attributes for the NapAtmConnection component.')
mscAal1CesAtmConOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscAal1CesAtmConIndex"))
if mibBuilder.loadTexts: mscAal1CesAtmConOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConOperEntry.setDescription('An entry in the mscAal1CesAtmConOperTable.')
mscAal1CesAtmConNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 119, 6, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAal1CesAtmConNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mscAal1CesAtmConNextHop.setDescription('This attribute shows the component name of the AtmIf Vcc Ep or AtmCon component to which this switched connection is established.')
mscMmTx = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151))
mscMmTxRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 1), )
if mibBuilder.loadTexts: mscMmTxRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxRowStatusTable.setDescription('This entry controls the addition and deletion of mscMmTx components.')
mscMmTxRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"))
if mibBuilder.loadTexts: mscMmTxRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxRowStatusEntry.setDescription('A single entry in the table represents a single mscMmTx component.')
mscMmTxRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMmTx components. These components can be added and deleted.')
mscMmTxComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMmTxStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxStorageType.setDescription('This variable represents the storage type value for the mscMmTx tables.')
mscMmTxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)))
if mibBuilder.loadTexts: mscMmTxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxIndex.setDescription('This variable represents the index for the mscMmTx tables.')
mscMmTxCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 10), )
if mibBuilder.loadTexts: mscMmTxCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscMmTxCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"))
if mibBuilder.loadTexts: mscMmTxCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxCidDataEntry.setDescription('An entry in the mscMmTxCidDataTable.')
mscMmTxCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscMmTxProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 11), )
if mibBuilder.loadTexts: mscMmTxProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxProvTable.setDescription('This group contains basic provisioning data for the Maintenance Monitor Transmitter (MmTx). A MmTx represents a mono- directional AAL1 Circuit Emulation Service. AAL1 CES attributes in this group are essential information to the operator about the AAL1 CES service that must be matched in the Aal1Ces component that receives the monitored stream. The check escape checks that only one instance of a MaintenanceMonitorTx is linked to any one Lp.')
mscMmTxProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"))
if mibBuilder.loadTexts: mscMmTxProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxProvEntry.setDescription('An entry in the mscMmTxProvTable.')
mscMmTxLinkToLogicalProcessor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 11, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxLinkToLogicalProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxLinkToLogicalProcessor.setDescription('This attribute specifies the instance of a hardware component to which an instance of this component is linked. Only Lp components may be linked')
mscMmTxMonitoredDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("ingress", 0))).clone('ingress')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxMonitoredDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxMonitoredDirection.setDescription('monitoredDirection specifies the direction of the monitored traffic. The default and only value is ingress.')
mscMmTxServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("basicStructured", 1))).clone('basicStructured')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxServiceType.setDescription('serviceType specifies the service type of the CES. The serviceType attribute in the receiving Aal1Ces component must have the same value as this attribute. The default and only value is basicStructured.')
mscMmTxPartialFill = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(47, 47)).clone(47)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxPartialFill.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxPartialFill.setDescription('partialFill specifies the number of octets that are carried in an ATM cell by the AAL1 CES service. A full cell contains 47 octets. The partialFill attribute in the receiving Aal1Ces component must have the same value as this attribute. The default and only value is 47. DESCRIPTION')
mscMmTxIdleSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("off", 0))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxIdleSuppression.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxIdleSuppression.setDescription('idleSuppression controls the suppression of idle cells. An idle cell is one in which the bytes of the ATM payload (up to the partialFill level) match the idlePattern. If idleSuppression is off, idle cells are not suppressed. If idleSuppression is on, at least 75% of cells are suppressed under idle conditions. The idleSuppression attribute in the receiving Aal1Ces component must have the same value as this attribute The default and only value is off.')
mscMmTxStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12), )
if mibBuilder.loadTexts: mscMmTxStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscMmTxStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"))
if mibBuilder.loadTexts: mscMmTxStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxStateEntry.setDescription('An entry in the mscMmTxStateTable.')
mscMmTxAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMmTxOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMmTxUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMmTxAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscMmTxProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscMmTxControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscMmTxAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscMmTxStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscMmTxUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscMmTxOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 13), )
if mibBuilder.loadTexts: mscMmTxOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxOperTable.setDescription('This group contains status information about the AAL1 Circuit Emulation Service and the related ATM service, and the means to specify the Channel to be monitor.')
mscMmTxOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"))
if mibBuilder.loadTexts: mscMmTxOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxOperEntry.setDescription('An entry in the mscMmTxOperTable.')
mscMmTxConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("connected", 0), ("channelNotReady", 1), ("atmNotReady", 2), ("atmNotConfigured", 3), ("channelNotSpecified", 4))).clone('channelNotReady')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxConnectionStatus.setDescription("This attribute indicates whether a service is non-operational because of a problem with the service interface side of the service (in which case, it is set to channelNotReady) or because of a problem with the ATM side of the service (in which case, it is set to atmNotConfigured or atmNotReady). When this attribute is set to channelNotReady, it is an indication that the corresponding Chan component (as defined by the attribute interfaceName) or the Chan component's parent port component (Lp/n Ds1/m or Lp/n E1/m) is locked. When this attribute is set to atmNotConfigured, it is an indication that no sub-component has been provisioned, and thus no ATM connection has been configured for the service. When this attribute is set to atmNotReady, it is an indication that the ATM connection with which the service is associated (as defined by a sub-component) has been lost or that it is currently unable to carry CES data. When this attribute is set to channelNotSpecified, it is an indication that the chanToMonitor attribute is not set to a valid channel. This attribute is set to connected when a service is operational (that is, the OSI attribute operationalState is enabled.)")
mscMmTxChanToMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 13, 1, 4), RowPointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxChanToMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxChanToMonitor.setDescription("chanToMonitor specifies the LP, port (E1 or DS1), and channel to monitor. The LP must be the same LP specified in the provisionable attribute linkToLogicalProcessor. This attribute's value is of the form Lp/x E1/y Chan/z or Lp/x DS1/y Chan/z.")
mscMmTxNap = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2))
mscMmTxNapRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 1), )
if mibBuilder.loadTexts: mscMmTxNapRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapRowStatusTable.setDescription('This entry controls the addition and deletion of mscMmTxNap components.')
mscMmTxNapRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxNapIndex"))
if mibBuilder.loadTexts: mscMmTxNapRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapRowStatusEntry.setDescription('A single entry in the table represents a single mscMmTxNap component.')
mscMmTxNapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxNapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMmTxNap components. These components can be added and deleted.')
mscMmTxNapComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxNapComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMmTxNapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxNapStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapStorageType.setDescription('This variable represents the storage type value for the mscMmTxNap tables.')
mscMmTxNapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMmTxNapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapIndex.setDescription('This variable represents the index for the mscMmTxNap tables.')
mscMmTxNapProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 10), )
if mibBuilder.loadTexts: mscMmTxNapProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapProvTable.setDescription('This group contains the provisioning data for the NailedUpAdaptationPoint component.')
mscMmTxNapProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxNapIndex"))
if mibBuilder.loadTexts: mscMmTxNapProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapProvEntry.setDescription('An entry in the mscMmTxNapProvTable.')
mscMmTxNapAtmConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMmTxNapAtmConnection.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxNapAtmConnection.setDescription('This attribute specifies the identity of the component to which the NailedUpAdaptationPoint is linked. This is an AtmIf Vcc NailedUpEndPoint or an AtmIf Vpt Vcc NailedUpEndPoint (the AAL1 cells are transported off the switch over an ATM UNI, where they are routed to the appropriate AAL1 entity at the other end by the ATM bearer service).')
mscMmTxAtmCon = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6))
mscMmTxAtmConRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 1), )
if mibBuilder.loadTexts: mscMmTxAtmConRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConRowStatusTable.setDescription('This entry controls the addition and deletion of mscMmTxAtmCon components.')
mscMmTxAtmConRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxAtmConIndex"))
if mibBuilder.loadTexts: mscMmTxAtmConRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConRowStatusEntry.setDescription('A single entry in the table represents a single mscMmTxAtmCon component.')
mscMmTxAtmConRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxAtmConRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMmTxAtmCon components. These components cannot be added nor deleted.')
mscMmTxAtmConComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxAtmConComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMmTxAtmConStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxAtmConStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConStorageType.setDescription('This variable represents the storage type value for the mscMmTxAtmCon tables.')
mscMmTxAtmConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMmTxAtmConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConIndex.setDescription('This variable represents the index for the mscMmTxAtmCon tables.')
mscMmTxAtmConOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 10), )
if mibBuilder.loadTexts: mscMmTxAtmConOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConOperTable.setDescription('This attribute group contains the operational attributes for the NapAtmConnection component.')
mscMmTxAtmConOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxIndex"), (0, "Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", "mscMmTxAtmConIndex"))
if mibBuilder.loadTexts: mscMmTxAtmConOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConOperEntry.setDescription('An entry in the mscMmTxAtmConOperTable.')
mscMmTxAtmConNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 151, 6, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMmTxAtmConNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mscMmTxAtmConNextHop.setDescription('This attribute shows the component name of the AtmIf Vcc Ep or AtmCon component to which this switched connection is established.')
circuitEmulationServiceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55, 1))
circuitEmulationServiceGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55, 1, 1))
circuitEmulationServiceGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55, 1, 1, 3))
circuitEmulationServiceGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55, 1, 1, 3, 2))
circuitEmulationServiceCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55, 3))
circuitEmulationServiceCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55, 3, 1))
circuitEmulationServiceCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55, 3, 1, 3))
circuitEmulationServiceCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 55, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-CircuitEmulationServiceMIB", circuitEmulationServiceCapabilities=circuitEmulationServiceCapabilities, mscAal1CesRowStatus=mscAal1CesRowStatus, mscAal1CesProvTable=mscAal1CesProvTable, mscAal1CesLCoPktsToNetwork=mscAal1CesLCoPktsToNetwork, circuitEmulationServiceGroupCA02=circuitEmulationServiceGroupCA02, mscMmTxAtmConRowStatusEntry=mscMmTxAtmConRowStatusEntry, mscAal1CesLCoRequiredCustomerParameter=mscAal1CesLCoRequiredCustomerParameter, mscMmTxAtmConRowStatusTable=mscMmTxAtmConRowStatusTable, mscMmTxCustomerIdentifier=mscMmTxCustomerIdentifier, mscMmTxServiceType=mscMmTxServiceType, mscAal1CesStatsEntry=mscAal1CesStatsEntry, mscAal1CesLCoSetupPriority=mscAal1CesLCoSetupPriority, mscAal1CesAtmConRowStatusEntry=mscAal1CesAtmConRowStatusEntry, mscMmTxChanToMonitor=mscMmTxChanToMonitor, mscAal1CesLCoPathDataEntry=mscAal1CesLCoPathDataEntry, mscAal1CesLCoDiscardPriority=mscAal1CesLCoDiscardPriority, mscAal1CesAepStorageType=mscAal1CesAepStorageType, mscMmTxProceduralStatus=mscMmTxProceduralStatus, mscMmTxNapRowStatusTable=mscMmTxNapRowStatusTable, mscAal1CesAtmCon=mscAal1CesAtmCon, mscAal1CesNapIndex=mscAal1CesNapIndex, mscAal1Ces=mscAal1Ces, mscAal1CesIdleSuppression=mscAal1CesIdleSuppression, mscAal1CesAepOutEntry=mscAal1CesAepOutEntry, mscMmTxProvTable=mscMmTxProvTable, mscMmTxAtmConIndex=mscMmTxAtmConIndex, mscAal1CesAepRetryLimit=mscAal1CesAepRetryLimit, mscMmTxAtmConStorageType=mscMmTxAtmConStorageType, mscAal1CesDummyDataByte=mscAal1CesDummyDataByte, mscAal1CesAepEpOperTable=mscAal1CesAepEpOperTable, mscMmTx=mscMmTx, mscAal1CesOperTable=mscAal1CesOperTable, mscAal1CesAepProvTable=mscAal1CesAepProvTable, mscAal1CesBufferUnderflows=mscAal1CesBufferUnderflows, mscAal1CesLCoRowStatusEntry=mscAal1CesLCoRowStatusEntry, mscAal1CesLCoRequiredRxBandwidth=mscAal1CesLCoRequiredRxBandwidth, mscMmTxOperEntry=mscMmTxOperEntry, mscAal1CesCellLossIntegrationPeriod=mscAal1CesCellLossIntegrationPeriod, circuitEmulationServiceCapabilitiesCA02=circuitEmulationServiceCapabilitiesCA02, mscAal1CesAepIndex=mscAal1CesAepIndex, mscAal1CesPepProvEndPointAddrTable=mscAal1CesPepProvEndPointAddrTable, mscAal1CesAtmConComponentName=mscAal1CesAtmConComponentName, mscMmTxNapComponentName=mscMmTxNapComponentName, mscAal1CesNapComponentName=mscAal1CesNapComponentName, circuitEmulationServiceCapabilitiesCA=circuitEmulationServiceCapabilitiesCA, mscAal1CesNapRowStatus=mscAal1CesNapRowStatus, mscAal1CesInterfaceName=mscAal1CesInterfaceName, mscAal1CesAep=mscAal1CesAep, mscAal1CesPepRowStatusTable=mscAal1CesPepRowStatusTable, mscAal1CesHeaderErrors=mscAal1CesHeaderErrors, mscMmTxRowStatusEntry=mscMmTxRowStatusEntry, mscMmTxUsageState=mscMmTxUsageState, mscMmTxMonitoredDirection=mscMmTxMonitoredDirection, mscAal1CesCidDataTable=mscAal1CesCidDataTable, mscMmTxAtmConOperTable=mscMmTxAtmConOperTable, mscAal1CesNapRowStatusEntry=mscAal1CesNapRowStatusEntry, mscAal1CesComponentName=mscAal1CesComponentName, mscAal1CesOperationalState=mscAal1CesOperationalState, mscAal1CesAepLastTearDownCause=mscAal1CesAepLastTearDownCause, mscAal1CesLCoCostMetric=mscAal1CesLCoCostMetric, mscMmTxNapAtmConnection=mscMmTxNapAtmConnection, mscAal1CesCellLossRecoveryPeriod=mscAal1CesCellLossRecoveryPeriod, mscMmTxRowStatus=mscMmTxRowStatus, mscAal1CesLCoPathValue=mscAal1CesLCoPathValue, mscAal1CesNap=mscAal1CesNap, mscAal1CesAepOutTable=mscAal1CesAepOutTable, mscAal1CesRowStatusEntry=mscAal1CesRowStatusEntry, mscAal1CesDp2CellDelayVariationTolerance=mscAal1CesDp2CellDelayVariationTolerance, mscAal1CesAvailabilityStatus=mscAal1CesAvailabilityStatus, mscAal1CesPepProvEndPointAddrEntry=mscAal1CesPepProvEndPointAddrEntry, mscAal1CesLCoOptimization=mscAal1CesLCoOptimization, mscMmTxComponentName=mscMmTxComponentName, mscAal1CesPartialFill=mscAal1CesPartialFill, mscMmTxAtmConNextHop=mscMmTxAtmConNextHop, mscAal1CesControlStatus=mscAal1CesControlStatus, mscAal1CesLCoPathEntry=mscAal1CesLCoPathEntry, mscAal1CesPepIndex=mscAal1CesPepIndex, mscMmTxIdleSuppression=mscMmTxIdleSuppression, mscAal1CesPepComponentName=mscAal1CesPepComponentName, mscAal1CesLCoRetryCount=mscAal1CesLCoRetryCount, mscAal1CesCellLossStatus=mscAal1CesCellLossStatus, circuitEmulationServiceMIB=circuitEmulationServiceMIB, mscAal1CesPointerReframes=mscAal1CesPointerReframes, mscMmTxStateEntry=mscMmTxStateEntry, mscAal1CesMaximumBufferDelay=mscAal1CesMaximumBufferDelay, mscAal1CesLCo=mscAal1CesLCo, mscMmTxAtmConComponentName=mscMmTxAtmConComponentName, mscAal1CesReassembledCells=mscAal1CesReassembledCells, mscAal1CesLCoRequiredTxBandwidth=mscAal1CesLCoRequiredTxBandwidth, mscAal1CesLCoPathFailureAction=mscAal1CesLCoPathFailureAction, mscAal1CesMisinsertedCells=mscAal1CesMisinsertedCells, mscAal1CesBufferSize=mscAal1CesBufferSize, mscMmTxNapStorageType=mscMmTxNapStorageType, mscAal1CesLCoLastTearDownReason=mscAal1CesLCoLastTearDownReason, mscAal1CesLCoRoundTripDelay=mscAal1CesLCoRoundTripDelay, mscMmTxRowStatusTable=mscMmTxRowStatusTable, mscAal1CesAal1SequenceErrors=mscAal1CesAal1SequenceErrors, mscMmTxNapRowStatusEntry=mscMmTxNapRowStatusEntry, mscAal1CesAepLastSetupFailureCause=mscAal1CesAepLastSetupFailureCause, mscMmTxAtmConRowStatus=mscMmTxAtmConRowStatus, mscAal1CesServiceType=mscAal1CesServiceType, mscAal1CesLCoStatsTable=mscAal1CesLCoStatsTable, mscAal1CesAepProvEntry=mscAal1CesAepProvEntry, mscAal1CesLCoStorageType=mscAal1CesLCoStorageType, mscMmTxStateTable=mscMmTxStateTable, mscAal1CesAepProvEndPointAddrTable=mscAal1CesAepProvEndPointAddrTable, mscAal1CesLCoStatsEntry=mscAal1CesLCoStatsEntry, mscMmTxOperationalState=mscMmTxOperationalState, mscAal1CesAepLocalAddress=mscAal1CesAepLocalAddress, mscAal1CesAdminState=mscAal1CesAdminState, mscAal1CesAepRetryFailures=mscAal1CesAepRetryFailures, mscMmTxAtmConOperEntry=mscMmTxAtmConOperEntry, mscAal1CesCellsTransmitted=mscAal1CesCellsTransmitted, mscAal1CesAepLastSetupFailureDiagnostic=mscAal1CesAepLastSetupFailureDiagnostic, mscAal1CesPepExpectedRemoteAddress=mscAal1CesPepExpectedRemoteAddress, mscMmTxUnknownStatus=mscMmTxUnknownStatus, mscAal1CesCidDataEntry=mscAal1CesCidDataEntry, mscMmTxProvEntry=mscMmTxProvEntry, mscAal1CesLCoRequiredSecurity=mscAal1CesLCoRequiredSecurity, mscAal1CesNapProvEntry=mscAal1CesNapProvEntry, mscAal1CesLCoComponentName=mscAal1CesLCoComponentName, mscAal1CesNapAtmConnection=mscAal1CesNapAtmConnection, mscAal1CesAepProvEndPointAddrEntry=mscAal1CesAepProvEndPointAddrEntry, mscAal1CesCellsReceived=mscAal1CesCellsReceived, circuitEmulationServiceGroup=circuitEmulationServiceGroup, mscAal1CesNapProvTable=mscAal1CesNapProvTable, mscMmTxStandbyStatus=mscMmTxStandbyStatus, mscAal1CesPepEpOperTable=mscAal1CesPepEpOperTable, mscAal1CesPepPassiveOperTable=mscAal1CesPepPassiveOperTable, mscAal1CesLCoBytesToNetwork=mscAal1CesLCoBytesToNetwork, mscAal1CesAtmConOperEntry=mscAal1CesAtmConOperEntry, mscAal1CesStatsTable=mscAal1CesStatsTable, mscAal1CesAepActiveEndPointType=mscAal1CesAepActiveEndPointType, mscAal1CesLCoPktsFromNetwork=mscAal1CesLCoPktsFromNetwork, mscAal1CesLCoState=mscAal1CesLCoState, mscMmTxNapProvEntry=mscMmTxNapProvEntry, mscMmTxNap=mscMmTxNap, mscAal1CesLCoPermittedTrunkTypes=mscAal1CesLCoPermittedTrunkTypes, mscAal1CesIndex=mscAal1CesIndex, mscAal1CesAal1LayerLossStatus=mscAal1CesAal1LayerLossStatus, mscAal1CesConnectionStatus=mscAal1CesConnectionStatus, mscAal1CesAepCalledVpiVci=mscAal1CesAepCalledVpiVci, mscMmTxCidDataTable=mscMmTxCidDataTable, mscAal1CesAepAddressToCall=mscAal1CesAepAddressToCall, mscAal1CesAepRemoteAddress=mscAal1CesAepRemoteAddress, mscAal1CesLCoEmissionPriority=mscAal1CesLCoEmissionPriority, mscMmTxPartialFill=mscMmTxPartialFill, mscAal1CesCustomerIdentifier=mscAal1CesCustomerIdentifier, mscAal1CesBufferOverflows=mscAal1CesBufferOverflows, mscAal1CesPepRowStatusEntry=mscAal1CesPepRowStatusEntry, mscAal1CesLCoPathFailureCount=mscAal1CesLCoPathFailureCount, mscMmTxIndex=mscMmTxIndex, mscAal1CesAepRowStatus=mscAal1CesAepRowStatus, mscAal1CesLCoBytesFromNetwork=mscAal1CesLCoBytesFromNetwork, mscAal1CesAepRowStatusTable=mscAal1CesAepRowStatusTable, mscAal1CesPepLocalAddress=mscAal1CesPepLocalAddress, mscMmTxCidDataEntry=mscMmTxCidDataEntry, mscAal1CesAepExpectedRemoteAddress=mscAal1CesAepExpectedRemoteAddress, mscAal1CesUsageState=mscAal1CesUsageState, mscAal1CesAepRowStatusEntry=mscAal1CesAepRowStatusEntry, mscAal1CesAtmConRowStatus=mscAal1CesAtmConRowStatus, circuitEmulationServiceGroupCA=circuitEmulationServiceGroupCA, mscAal1CesAepFirstRetryInterval=mscAal1CesAepFirstRetryInterval, mscAal1CesLCoOverrideRemoteName=mscAal1CesLCoOverrideRemoteName, mscAal1CesLCoRequiredTrafficType=mscAal1CesLCoRequiredTrafficType, mscAal1CesLCoPathType=mscAal1CesLCoPathType, mscMmTxLinkToLogicalProcessor=mscMmTxLinkToLogicalProcessor, mscAal1CesUnknownStatus=mscAal1CesUnknownStatus, mscAal1CesLCoRowStatusTable=mscAal1CesLCoRowStatusTable, mscAal1CesPepRowStatus=mscAal1CesPepRowStatus, mscAal1CesAepSvcStatus=mscAal1CesAepSvcStatus, mscAal1CesPepLastTearDownCause=mscAal1CesPepLastTearDownCause, mscAal1CesAepProfile=mscAal1CesAepProfile, mscAal1CesStandbyStatus=mscAal1CesStandbyStatus, mscAal1CesPointerParityErrors=mscAal1CesPointerParityErrors, mscAal1CesAepRoutingOption=mscAal1CesAepRoutingOption, mscMmTxAtmCon=mscMmTxAtmCon, mscAal1CesStorageType=mscAal1CesStorageType, mscMmTxAdminState=mscMmTxAdminState, mscAal1CesStateTable=mscAal1CesStateTable, mscAal1CesPepRemoteAddress=mscAal1CesPepRemoteAddress, mscAal1CesLCoHoldingPriority=mscAal1CesLCoHoldingPriority, mscAal1CesRowStatusTable=mscAal1CesRowStatusTable, mscMmTxNapRowStatus=mscMmTxNapRowStatus, mscMmTxNapProvTable=mscMmTxNapProvTable, mscAal1CesNapRowStatusTable=mscAal1CesNapRowStatusTable, mscAal1CesAtmConNextHop=mscAal1CesAtmConNextHop, mscMmTxNapIndex=mscMmTxNapIndex, mscAal1CesAtmConRowStatusTable=mscAal1CesAtmConRowStatusTable, mscAal1CesAlarmStatus=mscAal1CesAlarmStatus, mscMmTxConnectionStatus=mscMmTxConnectionStatus, mscAal1CesProvEntry=mscAal1CesProvEntry, mscAal1CesAtmConStorageType=mscAal1CesAtmConStorageType, mscAal1CesAepEpOperEntry=mscAal1CesAepEpOperEntry, mscAal1CesOperEntry=mscAal1CesOperEntry, mscAal1CesLCoRowStatus=mscAal1CesLCoRowStatus, mscMmTxAvailabilityStatus=mscMmTxAvailabilityStatus, mscAal1CesPep=mscAal1CesPep, mscAal1CesAtmConIndex=mscAal1CesAtmConIndex, mscAal1CesStateEntry=mscAal1CesStateEntry, mscAal1CesLCoEnd=mscAal1CesLCoEnd, mscAal1CesLCoIndex=mscAal1CesLCoIndex, mscAal1CesProceduralStatus=mscAal1CesProceduralStatus, mscAal1CesPepLastTearDownDiagnostic=mscAal1CesPepLastTearDownDiagnostic, mscMmTxOperTable=mscMmTxOperTable, mscAal1CesAepComponentName=mscAal1CesAepComponentName, mscAal1CesLCoPathUpDateTime=mscAal1CesLCoPathUpDateTime, mscAal1CesIdlePattern=mscAal1CesIdlePattern, mscAal1CesPepStorageType=mscAal1CesPepStorageType, mscAal1CesLCoPathTable=mscAal1CesLCoPathTable, mscMmTxControlStatus=mscMmTxControlStatus, mscMmTxStorageType=mscMmTxStorageType, mscAal1CesPepEpOperEntry=mscAal1CesPepEpOperEntry, mscAal1CesLostCells=mscAal1CesLostCells, mscAal1CesNapStorageType=mscAal1CesNapStorageType, mscAal1CesLCoPathDataTable=mscAal1CesLCoPathDataTable, circuitEmulationServiceCapabilitiesCA02A=circuitEmulationServiceCapabilitiesCA02A, mscAal1CesPepSvcStatus=mscAal1CesPepSvcStatus, mscAal1CesLCoReasonForNoRoute=mscAal1CesLCoReasonForNoRoute, mscAal1CesAepLastTearDownDiagnostic=mscAal1CesAepLastTearDownDiagnostic, mscAal1CesAtmConOperTable=mscAal1CesAtmConOperTable, mscAal1CesPepPassiveOperEntry=mscAal1CesPepPassiveOperEntry, mscAal1CesLCoBumpPreference=mscAal1CesLCoBumpPreference, mscAal1CesAepRetryTimeRemaining=mscAal1CesAepRetryTimeRemaining, mscAal1CesLCoDelayMetric=mscAal1CesLCoDelayMetric, mscMmTxAlarmStatus=mscMmTxAlarmStatus, circuitEmulationServiceGroupCA02A=circuitEmulationServiceGroupCA02A)

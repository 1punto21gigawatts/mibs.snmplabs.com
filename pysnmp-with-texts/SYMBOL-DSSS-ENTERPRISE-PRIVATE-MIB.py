#
# PySNMP MIB module SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:14:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
snmp, = mibBuilder.importSymbols("SNMPv2-MIB", "snmp")
MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, enterprises, Integer32, Counter64, iso, MibIdentifier, Gauge32, TimeTicks, IpAddress, NotificationType, ModuleIdentity, Unsigned32, NotificationType, Counter32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "enterprises", "Integer32", "Counter64", "iso", "MibIdentifier", "Gauge32", "TimeTicks", "IpAddress", "NotificationType", "ModuleIdentity", "Unsigned32", "NotificationType", "Counter32", "Bits")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
symbol = MibIdentifier((1, 3, 6, 1, 4, 1, 388))
spectrum24 = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1))
dsap = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5))
apConfigMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 1))
apPerformMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2))
apFaultMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 3))
apSecurityMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 4))
apManufactureInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1))
apSystemConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2))
apSNMPInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3))
apRFConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4))
apSerialPortConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5))
apEthernetStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3))
apRFStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4))
apSerialPortStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 6))
apWNMPStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 7))
apMUInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8))
apFilterStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 10))
apWLAPInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11))
apMobileIPStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 14))
class WEPKeytype128b(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(13, 13)
    fixedLength = 13

coldStart = NotificationType((1, 3, 6, 1, 2, 1, 11) + (0,0)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"))
if mibBuilder.loadTexts: coldStart.setDescription('Access Point cold boot. - apMyMacAddr is the MAC address of the Access Point sending this trap message.')
authenticationFailure = NotificationType((1, 3, 6, 1, 2, 1, 11) + (0,4)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apAPMacAddr"))
if mibBuilder.loadTexts: authenticationFailure.setDescription('Invalid SNMP Community string. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - apAPMacAddr is the MAC address of the remote host sending SNMP packet with invalid community.')
apDSAPRFStartUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,101)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"))
if mibBuilder.loadTexts: apDSAPRFStartUpTrap.setDescription('RF Driver is up. - apMyMacAddr is the MAC address of the Access Point sending this trap message.')
apDSAPACLViolationTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,102)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "muMacAddr"))
if mibBuilder.loadTexts: apDSAPACLViolationTrap.setDescription('Mobile Unit MAC address not in the Access control Table. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - muMacAddr is the MAC address of the Mobile Unit not in the Access Control Table.')
apDSAPMUAssocTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,111)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "muMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apCurrentMUs"))
if mibBuilder.loadTexts: apDSAPMUAssocTrap.setDescription('Indicates that there is one Mobile Unit associating with this Access Point. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - muMacAddr is the MAC address of the Mobile Unit. Note : If two or more Mobile Units associate with the Access Point at the same time, muMacAddr belongs to the last Mobile Unit. - apCurrentMUs is the number of Mobile Units currently associating with this Access Point.')
apDSAPMUUnAssocTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,112)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "muMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apCurrentMUs"))
if mibBuilder.loadTexts: apDSAPMUUnAssocTrap.setDescription('Indicates that there is one Mobile Unit no longer associating with this Access Point anymore. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - muMacAddr is the MAC address of the Mobile Unit. Note : If two or more Mobile Units un-associate with the Access Point at the same time, muMacAddr belongs to the last Mobile Unit. - apCurrentMUs is the number of Mobile Units currently associating with this Access Point.')
apDSAPMUMaxAssocTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,116)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apCurrentMUs"))
if mibBuilder.loadTexts: apDSAPMUMaxAssocTrap.setDescription('Indicates that the number of MUs associated with this Access Point is at the threshold set by apMaxMUTrigger. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - apCurrentMUs is the number of Mobile Units currently associating with this Access Point.')
apDSRootWLAPUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,121)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apAPMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apNbrOfWLAPItfs"))
if mibBuilder.loadTexts: apDSRootWLAPUpTrap.setDescription('Indicates that the Root AP connection is setup and is ready to forward data. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - apAPMacAddr is the MAC address of the Root AP. - apNbrOfWLAPItfs is the number of current WLAP Interfaces established.')
apDSRootWLAPLostTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,122)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apAPMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apNbrOfWLAPItfs"))
if mibBuilder.loadTexts: apDSRootWLAPLostTrap.setDescription('If the current wireless AP does not receive Beacon packet from its Root AP within one second, it will consider the Root AP is lost. The wireless AP will eventually reset itself to re-establish the network topology. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - apAPMacAddr is the MAC address of the Root AP. - apNbrOfWLAPItfs is the number of current WLAP Interfaces established.')
apDSDsgntedWLAPUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,123)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apAPMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apNbrOfWLAPItfs"))
if mibBuilder.loadTexts: apDSDsgntedWLAPUpTrap.setDescription('Indicates that the Designated WLAP connection is setup and is ready to forward data. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - apAPMacAddr is the MAC address of the Designated WLAP. - apNbrOfWLAPItfs is the number of current WLAP Interfaces established.')
apDSDsgnatedWLAPLostTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,124)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apAPMacAddr"), ("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apNbrOfWLAPItfs"))
if mibBuilder.loadTexts: apDSDsgnatedWLAPLostTrap.setDescription('If the current wireless AP does not receive Config BPDU (Bridge Protocol Data Unit) packet from its Designated WLAP for MAX AGE time, it will consider that the Designated WLAP is lost. - apMyMacAddr is the MAC address of the Access Point sending this trap message. - apAPMacAddr is the MAC address of the Designated WLAP. - apNbrOfWLAPItfs is the number of current WLAP Interfaces established.')
apDSAPDHCPConfigChgTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,130)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"))
if mibBuilder.loadTexts: apDSAPDHCPConfigChgTrap.setDescription('If there are any DHCP network configuration change, This trap will be issued. - apMyMacAddr is the MAC address of the Access Point sending this trap message. ')
apDSAPDHCPLeaseUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 388, 1, 5) + (0,131)).setObjects(("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apMyMacAddr"))
if mibBuilder.loadTexts: apDSAPDHCPLeaseUpTrap.setDescription('If the Access point(Client) is unable to renew the DHCP lease before the lease is expired, this trap is generated. - apMyMacAddr is the MAC address of the Access Point sending this trap message. ')
apModelnumber = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apModelnumber.setStatus('mandatory')
if mibBuilder.loadTexts: apModelnumber.setDescription('The Model Number of the Access Point device.')
apSerialnumber = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apSerialnumber.setStatus('mandatory')
if mibBuilder.loadTexts: apSerialnumber.setDescription('The Serial Number of the Access Point system.')
apHardwareRev = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apHardwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: apHardwareRev.setDescription('The current revision of the Access Point hardware.')
apMyMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apMyMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: apMyMacAddr.setDescription('The MAC address of the Access Point.')
apAPFirmwareRev = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAPFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: apAPFirmwareRev.setDescription('The current revision of the Access Point firmware.')
apRFFirmwareRev = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRFFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: apRFFirmwareRev.setDescription('The current revision of the Access Point radio firmware.')
apMfgDate = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apMfgDate.setStatus('mandatory')
if mibBuilder.loadTexts: apMfgDate.setDescription('The Date this Access Point was manufactured.')
apHTMLFileRev = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apHTMLFileRev.setStatus('mandatory')
if mibBuilder.loadTexts: apHTMLFileRev.setDescription('The current revision of the Access Point HTML file.')
apVendorID = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6, 8, 9))).clone(namedValues=NamedValues(("symbol", 5), ("threeCom", 6), ("ericsson", 8), ("intel", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apVendorID.setStatus('mandatory')
if mibBuilder.loadTexts: apVendorID.setDescription('Displays the Vendor ID of the vendor for which this AP has been manufactured for. The current values are: - Symbol (5) - 3Com (6) - Ericsson (8) - Intel (9) ')
apUnitName = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apUnitName.setStatus('mandatory')
if mibBuilder.loadTexts: apUnitName.setDescription('An ASCII string to identify this Access Point (up to 31 characters).')
apMyIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMyIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: apMyIPAddr.setDescription('The IP address for the AP.')
apSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: apSubnetMask.setDescription('The IP subnet mask for the AP.')
apGatewayIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apGatewayIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: apGatewayIPAddr.setDescription('The IP address for the default gateway.')
apDefaultInterface = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ethernet", 1), ("ppp", 2), ("wlap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apDefaultInterface.setStatus('mandatory')
if mibBuilder.loadTexts: apDefaultInterface.setDescription('Specifies the default interface (Ethernet, PPP or WLAP) for the AP to forward an unknown packet. Default is ethernet(1).')
apEnetPortState = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apEnetPortState.setStatus('mandatory')
if mibBuilder.loadTexts: apEnetPortState.setDescription('Specifies the state of the Ethernet interface. Default is up(1).')
apEthernetTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apEthernetTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: apEthernetTimeOut.setDescription("If the value is: - 0: the Ethernet Time Out function is disabled. - 1: detect Ethernet timeout by hardware circuitry. - 30-255: Ethernet timeout is detected by software algorithm. When the Ethernet connection is broken and the WLAP mode is either enabled or disabled, the AP will clear the MU table and disable the RF interface until the Etherent connection is up. The following values are only valid when WLAP mode is enabled and it does not matter whetehr WLAP associates with the root AP or not. - 2: send WLAP Alive BPDU on Ethernet interface to let other WLAP on the same Ethernet segment to detect it's existence. - 3: keep track of WLAP Alive BPDU on Ethernet inter- face. If the BPDU is missing for 'WLAP Hello Time' seconds, the Ethernet Activity LEDs will flash and the RF interface is disabled until the WLAP Alive BPDU is received again, then the AP will reset itself. The default value is 0.")
apTelnetEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apTelnetEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apTelnetEnable.setDescription('Enables/Disables Telnet access to the AP. Default is enabled(1).')
apAccCtrlEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAccCtrlEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apAccCtrlEnable.setDescription('Enables/Disables the Access Control function. When it is enabled, a Mobile Unit can associate with the Access Point only if its MAC address is in the Access Control Table. Default is disabled(2).')
apTypeFilterEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("forward", 2), ("discard", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apTypeFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apTypeFilterEnable.setDescription('Specifies the type of Access Point Type Filtering operation, i.e. Disabled/Forward/Discard. Default is disabled(1).')
apWNMPEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWNMPEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apWNMPEnable.setDescription('Enables/Disables Use of the WNMP agent. Default is enabled(1).')
apAPStateXchgEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAPStateXchgEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apAPStateXchgEnable.setDescription('Enables/Disables exchanging Access Point to Access Point state information by using WNMP protocol. Default is enabled(1).')
apS24MobileIPEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apS24MobileIPEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apS24MobileIPEnable.setDescription('Enables/Disables Spectrum24 Mobile IP support, i.e. AP will act as Mobility Agent. Default is disabled(2).')
apAgentAdInterval = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAgentAdInterval.setStatus('mandatory')
if mibBuilder.loadTexts: apAgentAdInterval.setDescription('Interval in second at which Mobility Agent Advertise- ments are sent by the Third Party Mobility Agent(s). AP will cache the Third Party Advertisement and pass it to MU at association time. If AP does not receive the Advertisement within the interval seconds, the cached Advertisement will be deleted. If the interval is 0 or apS24MobileIPEnable is enabled, caching of the Advertisement will not occur. Range (0..1200) 3*Seconds . Default is 0.')
apWebServerEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWebServerEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apWebServerEnable.setDescription('Enables/Disables Access Point Web Server. When enabled, the Access Point will serve Web clients. Default is enabled(1)')
apMobileHomeMD5Key = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMobileHomeMD5Key.setStatus('mandatory')
if mibBuilder.loadTexts: apMobileHomeMD5Key.setDescription('The MD5 key is a secret key shared between home agent and the mobile unit. This is used to generate a MD5 checksum, which is used for packet authentication. Length of this variable should not exceed 13 characters.')
apAdditionalGatewaysTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 19), )
if mibBuilder.loadTexts: apAdditionalGatewaysTable.setStatus('mandatory')
if mibBuilder.loadTexts: apAdditionalGatewaysTable.setDescription('A table of information for additional Gateways. The current number of entries is 7.')
apAdditionalGatewaysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 19, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "additionalGatewaysIndex"))
if mibBuilder.loadTexts: apAdditionalGatewaysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apAdditionalGatewaysEntry.setDescription('An entry in the table of information for additional gateways for this access point. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
additionalGatewaysIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: additionalGatewaysIndex.setStatus('mandatory')
if mibBuilder.loadTexts: additionalGatewaysIndex.setDescription('Specific Gateway information Table index. Range (1..8).')
apAdditionalGatewaysIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 19, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAdditionalGatewaysIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: apAdditionalGatewaysIPAddr.setDescription('The IP address of the Gateway used for this AP.')
apMUMUDisallowed = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMUMUDisallowed.setStatus('mandatory')
if mibBuilder.loadTexts: apMUMUDisallowed.setDescription('Controls inter-MU communication. When enabled(on), it will disallow one MU to talk to another MU through RF only.')
apEncryptAdmin = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("serial", 1), ("any", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEncryptAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: apEncryptAdmin.setDescription('Controls the administration of Encryption keys. This variable could only be modified thru the Serial Interface. Default is any(2).')
apSNMPMode = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("readonly", 2), ("readwrite", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSNMPMode.setStatus('mandatory')
if mibBuilder.loadTexts: apSNMPMode.setDescription('Specifies the mode of the SNMP Agent operation, i.e. Disabled/Readonly/ReadWrite. Default is readwrite(3).')
apROCommunityName = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apROCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: apROCommunityName.setDescription('The Read-Only community name of the SNMP command for management station accessing this Access Point (up to 31 characters).')
apRWCommunityName = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRWCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: apRWCommunityName.setDescription("The Read-Write community name of the SNMP command for management station accessing this Access Point (up to 13 characters). This community name is same as the System Password or Telnet Password. For security purpose, if the management station uses the READ-ONLY community name to access this object, a string of 'xxxxx' will be returned.")
apTrapHost1IpAdr = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apTrapHost1IpAdr.setStatus('mandatory')
if mibBuilder.loadTexts: apTrapHost1IpAdr.setDescription("Trap receiver's (i.e. Network Manager's) IP address.")
apAllTrapsEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAllTrapsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apAllTrapsEnable.setDescription('Enables/Disables all SNMP traps. Default is disabled (2).')
apColdBootTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("trapHost1", 2), ("trapHost2", 3), ("all-TrapHosts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apColdBootTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apColdBootTrapEnable.setDescription('Enables/Disables Access Point Cold Boot trap. Default is disabled(1). This is a generic-trap and the trap code is 0. When not disabled the trap could be directed to TrapHost1, TrapHost2 or all TrapHosts. The apAllTrapsEnable flag should be enabled for this trap to be issued.')
apAuthenFailureTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("trapHost1", 2), ("trapHost2", 3), ("all-TrapHosts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAuthenFailureTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apAuthenFailureTrapEnable.setDescription('Enables/Disables authentication failure trap. Default is disabled(2). This is a generic-trap and the trap code is 4. When not disabled the trap could be directed to TrapHost1, TrapHost2 or all TrapHosts. The apAllTrapsEnable flag should be enabled for this trap to be issued.')
apRFTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("trapHost1", 2), ("trapHost2", 3), ("all-TrapHosts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRFTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apRFTrapEnable.setDescription('Enables/Disables Access Point RF driver startup trap. Default is disabled(2). This is an enterprise-specific trap and the trap code is 101. When not disabled the trap could be directed to TrapHost1, TrapHost2 or all TrapHosts. The apAllTrapsEnable flag should be enabled for this trap to be issued.')
apACLTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("trapHost1", 2), ("trapHost2", 3), ("all-TrapHosts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apACLTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apACLTrapEnable.setDescription('Enables/Disables Access Control violation trap. Default is disabled(2). This is an enterprise-specific trap and the trap code is 102. When not disabled the trap could be directed to TrapHost1, TrapHost2 or all TrapHosts. The apAllTrapsEnable flag should be enabled for this trap to be issued.')
apMUStateChngTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("trapHost1", 2), ("trapHost2", 3), ("all-TrapHosts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMUStateChngTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apMUStateChngTrapEnable.setDescription('Enables/Disables Mobile Unit State Change trap. Default is disabled(1). When not disabled, the following four (2) enterprise-specific traps will be generated and directed to trapHost1, TrapHost2 or all traphosts.: - MU Association Trap, the trap code is 111. - MU Un-association Trap, the trap code is 112. The enabled/disabled state of this trap depends on the state of apAllTrapsEnable.')
apWLAPConnChngTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("trapHost1", 2), ("trapHost2", 3), ("all-TrapHosts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWLAPConnChngTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPConnChngTrapEnable.setDescription('When Enabled, if there are any WLAP Connection Change, one of four (4) following enterprise-specific traps will be issued. - Root AP Up Trap, the trap code is 121. - Root AP Lost Trap, the trap code is 122. - Designated WLAP Up Trap, the trap code is 123. - Designated WLAP Lost Trap, the trap code is 124. Default is disabled(2). When not disabled the trap could be directed to TrapHost1, TrapHost2 or all TrapHosts. The apAllTrapsEnable flag should be enabled for this trap to be issued.')
apDHCPChangeEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("trapHost1", 2), ("trapHost2", 3), ("all-TrapHosts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apDHCPChangeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apDHCPChangeEnable.setDescription('When Enabled, if there are any DHCP network configuration change, a trap will be issued. Default is disabled(2). When not disabled the trap could be directed to TrapHost1, TrapHost2 or all TrapHosts. The apAllTrapsEnable flag should be enabled for this trap to be issued.')
apSNMPRequests = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apSNMPRequests.setStatus('mandatory')
if mibBuilder.loadTexts: apSNMPRequests.setDescription('Indicates the number of SNMP requests to this SNMP Agent.')
apSNMPTraps = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apSNMPTraps.setStatus('mandatory')
if mibBuilder.loadTexts: apSNMPTraps.setDescription('Indicates the number of Traps that were generated by this SNMP Agent.')
apTrapHost2IpAdr = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 3, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apTrapHost2IpAdr.setStatus('mandatory')
if mibBuilder.loadTexts: apTrapHost2IpAdr.setDescription("Trap receiver's (i.e. Network Manager's) IP address.")
apRFPortState = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRFPortState.setStatus('mandatory')
if mibBuilder.loadTexts: apRFPortState.setDescription('Specifies the state of the RF Interface. Default is up(1).')
apNetID = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apNetID.setStatus('mandatory')
if mibBuilder.loadTexts: apNetID.setDescription('The current RF Network ID for the AP. The Network name can have up to 32 alphanumerical characters.')
apCountryName = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apCountryName.setStatus('mandatory')
if mibBuilder.loadTexts: apCountryName.setDescription('The country for which the Access Point radio is configured. It is set at the factory and may not be altered.')
apAntennaSelect = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary-only", 1), ("diversity-On", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAntennaSelect.setStatus('mandatory')
if mibBuilder.loadTexts: apAntennaSelect.setDescription('Select either Primary antenna only (i.e. Disable antenna diversity) or both Primary and Secondary antennas (i.e. Enable antenna diversity-On). Default is diversity-On(2).')
apBCMCQMax = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apBCMCQMax.setStatus('mandatory')
if mibBuilder.loadTexts: apBCMCQMax.setDescription('The maximum size of broadcast/multicast queue. Range (0..32). Default is 10.')
apReassemblyTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apReassemblyTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: apReassemblyTimeOut.setDescription('Sets the time in 0.5 ms units before a timeout occurs during a packet re-assembly. Packet re-assemblies occur when a large Ethernet packet is fragmented into smaller wireless network packets. Range : 0...9999. Default is 9000.')
apMaxRetries = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: apMaxRetries.setDescription('The maximum number of allowed retries before aborting a single transmission. Range (0..32). Default is 15.')
apMulticastMask = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMulticastMask.setStatus('mandatory')
if mibBuilder.loadTexts: apMulticastMask.setDescription('Supports broadcast download protocol for Point-of-Sale terminals that load a new operating image over the network instead of using a local non-volatile drive. The multicast mask is the top 32 bits of the MAC address and allows for a series of MAC addresses to receive multicast messages. These messages are transmitted by the AP immediately and not queued for processing at DTIM intervals.')
apAcceptBCESSID = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAcceptBCESSID.setStatus('mandatory')
if mibBuilder.loadTexts: apAcceptBCESSID.setDescription('Enables/Disables the function to accept Broadcast ESS ID. Enabling this feature is NOT recommended. See manual for details. Default is disabled(2).')
apMUInactivityTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMUInactivityTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: apMUInactivityTimeOut.setDescription('Allowable Mobile Unit inactivity time in minutes. The time out limit is from 3 to 600 minutes. Default is 60 minutes.')
apWLAPMode = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("link-required", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWLAPMode.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPMode.setDescription('Enables/Disables Wireless AP capability and set link required option to wireless AP. Once in link-required mode, upon power-up, Root AP requires connection to the Ethernet cable and WLAP requires association with the Root AP and WLAP will keep probing forever. Default is disabled(2).')
apWLAPPriority = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWLAPPriority.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPPriority.setDescription('Provides a user with the influence to determine the Root AP in wireless operation. The priority value is added as the most significant portion of the MAC address to form the WLAP ID. A WLAP with a lower numerical value for priority is more likely to become the Root AP. Priority 0xFFFF is special. It grants the WLAP with roaming capability. Default is 8000 hex from the 0 - 0xFFFF range. Reset AP for value to take effect.')
apWLAPManualBSSID = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 18), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWLAPManualBSSID.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPManualBSSID.setDescription('Specifies the BSS-ID of a particular WLAP and forces the current WLAP to associate only with that WLAP. When WLAP Manaul BSS ID is set to the current WLAP MAC address, the current WLAP jumps into Functional state immediately and waits for an Association Request from the other WLAP. Reset AP for value to take effect.')
apWLAPHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWLAPHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPHelloTime.setDescription('Sets the time lapse, in seconds, between Configuration BPDUs (Bridge Protocol Data Unit) sent to the Root AP by a designated WLAP to indicate that it is still alive. Default is 20 seconds. Reset AP for value to take effect. Range: 0..9999.')
apWLAPMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWLAPMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPMaxAge.setDescription('Specifies how long, in seconds, a Configuration BPDU (Bridge Protocol Data Unit) is kept by the Root AP before it is judged too old and discarded. Consequently, the interface is considered to be disconnected. Default is 100 seconds. Recommended value is multiple of the WLAP Hello Time. Reset AP for value to take effect. Range: 0..9999.')
apWLAPFwdDelay = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWLAPFwdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPFwdDelay.setDescription('Specifies how long, in seconds, an WLAP is prevented from forwarding data packets to an interface. This delay is to allow the spread of news of a topology change to all parts of a network. Default is 5 seconds. Reset AP for value to take effect. Range: 0..9999.')
apMaxMUTrigger = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMaxMUTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: apMaxMUTrigger.setDescription('Indicates the trigger point for sending apMUMaxAssocTrap trap. Range (1..255). The default value is 255.')
apMaxRetriesVoice = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMaxRetriesVoice.setStatus('mandatory')
if mibBuilder.loadTexts: apMaxRetriesVoice.setDescription('The maximum number of allowed retries before aborting a single transmission. Range (0..32). Default is 5.')
apMcastMaskVoice = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apMcastMaskVoice.setStatus('mandatory')
if mibBuilder.loadTexts: apMcastMaskVoice.setDescription('This is used for Spectrum 24 telephone for intercomm function. The multicast mask is the top 32 bits of the MAC address and allows for a series of MAC addresses to receive multicast messages. These messages are transmitted by the AP immediately and not queued for processing at DTIM intervals..')
apWEPAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wep-128b-Key", 1), ("wep-40b-Key", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWEPAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: apWEPAlgorithm.setDescription('This attribute is a set of all the shared key WEP algorithms supported by the STAs. The following are the default values and the associated algorithm. Value = 1: 128 bit Key Value = 2: 40 bit Key. IMPORTANT NOTE: The 128 bit WEP key ENcryption is currently restricted by U.S. laws. In order to activate the 128 bit Encryption, an authentic License key has to be obtained and entered through one of the interfaces such as Telnet, SNMP or Web. Upon authentication of the key the AP will enable the 128 bit ENcryption. See Access Point manual for details.')
apRFRate11Mb = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("optional", 1), ("not-used", 2), ("required", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRFRate11Mb.setStatus('mandatory')
if mibBuilder.loadTexts: apRFRate11Mb.setDescription('Specifies the Current state of the RF data rate. There are three options: - optional(1) - not-used(2) - required(3) Default is optional for 11 Mb/s data rate.')
apRFRate5_5Mb = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("optional", 1), ("not-used", 2), ("required", 3)))).setLabel("apRFRate5-5Mb").setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRFRate5_5Mb.setStatus('mandatory')
if mibBuilder.loadTexts: apRFRate5_5Mb.setDescription('Specifies the Current state of the RF data rate. There are three options: - optional(1) - not-used(2) - required(3) Default is optional for 5.5 Mb/S data rate.')
apRFRate2Mb = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("optional", 1), ("not-used", 2), ("required", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRFRate2Mb.setStatus('mandatory')
if mibBuilder.loadTexts: apRFRate2Mb.setDescription('Specifies the Current state of the RF data rate. There are three options: - optional(1) - not-used(2) - required(3) Default is optional for 2 Mb/s data rate.')
apRFRate1Mb = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("optional", 1), ("not-used", 2), ("required", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRFRate1Mb.setStatus('mandatory')
if mibBuilder.loadTexts: apRFRate1Mb.setDescription('Specifies the Current state of the RF data rate. There are three options: - optional(1) - not-used(2) - required(3) Default is required for 1 Mb/s data rate.')
apRFPreamble = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apRFPreamble.setStatus('mandatory')
if mibBuilder.loadTexts: apRFPreamble.setDescription('This attribute is set to disabled for compatibility within the 802.11 community. Setting it to enabled shall result in performance enhancement. Default is enabled. NOTE: Only radios with version 2 hardware support RF Preamble, hence configurable to enabled state.')
apRadioType = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 4, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds11-V2", 1), ("ds11-v1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRadioType.setStatus('mandatory')
if mibBuilder.loadTexts: apRadioType.setDescription('This attribute displays the type of radio installed in the Access Point. ds11-v1 Ver.1 Hardware short RF Preamble not supported. ds11-V2 Ver.2 Hardware Short RF Preamble supported.')
apPPPState = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apPPPState.setStatus('mandatory')
if mibBuilder.loadTexts: apPPPState.setDescription('Indicates the current state of the PPP connection machine. Default is down(2).')
apSerialPortUse = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppp", 1), ("ui", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSerialPortUse.setStatus('mandatory')
if mibBuilder.loadTexts: apSerialPortUse.setDescription('Specifies whether the Serial Interface is to be used as User Interface(UI) or PPP. Default is ui(2).')
apModemConnected = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apModemConnected.setStatus('mandatory')
if mibBuilder.loadTexts: apModemConnected.setDescription('Specifies whether the Serial Interface has a modem attached to it. Default is no(2).')
apConnectMode = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("originate", 1), ("answer", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apConnectMode.setStatus('mandatory')
if mibBuilder.loadTexts: apConnectMode.setDescription('Specifies the Modem connection mode: - originate(1): AP sends dial-out information. - answer(2): AP waits for dial-in information. Default is answer(2).')
apDialOutNumber = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apDialOutNumber.setStatus('mandatory')
if mibBuilder.loadTexts: apDialOutNumber.setDescription('Specifies the number to be dialed by the modem.')
apDialOutMode = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("auto", 1), ("manual", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apDialOutMode.setStatus('mandatory')
if mibBuilder.loadTexts: apDialOutMode.setDescription('Specifies the dialout mode: - auto(1): Modem dial out during startup time. - manual(2): Modem dial out by manned intervention Default is auto(1).')
apAnswerWaitTime = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apAnswerWaitTime.setStatus('mandatory')
if mibBuilder.loadTexts: apAnswerWaitTime.setDescription('Specifies the period (in seconds) the AP will wait for the remote unit to answer the call. Default is 60 seconds.')
apModemSpeaker = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apModemSpeaker.setStatus('mandatory')
if mibBuilder.loadTexts: apModemSpeaker.setDescription('Specifies if modem speaker is turned on(1) or off(2). Default is on(1).')
apInactivityTimeout = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apInactivityTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: apInactivityTimeout.setDescription('Specifies the User Interface inactivity timeout in minutes. 0 means no timeout. Default is 5 minutes.')
apPPPTimeout = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apPPPTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: apPPPTimeout.setDescription('Specifies the PPP event timeout in seconds. Default is 3 seconds.')
apPPPTerminates = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 5, 11), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apPPPTerminates.setStatus('mandatory')
if mibBuilder.loadTexts: apPPPTerminates.setDescription('Specifies the maximum number of PPP terminate requests. Default is 10.')
apAddrFilterTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 6), )
if mibBuilder.loadTexts: apAddrFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: apAddrFilterTable.setDescription('A table of MAC addresses not allowed to associate with the Access Point. The maximum number of entries in the table is 512.')
apAddrFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 6, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "disallowedIndex"))
if mibBuilder.loadTexts: apAddrFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apAddrFilterEntry.setDescription("An entry in the table of Address Filter. A row in this table is created by setting the value of disallowedMU to the MAC address of the MU not allowed to associate with the Access Point. A row in this table is deleted by setting the value of disallowedMU to '000000000000'.")
disallowedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: disallowedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: disallowedIndex.setDescription('Address Filter Table index. Range (1..512).')
disallowedMU = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 6, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: disallowedMU.setStatus('mandatory')
if mibBuilder.loadTexts: disallowedMU.setDescription('MU MAC address which is not allowed to be associated with this Access Point.')
apTypeFilterTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 7), )
if mibBuilder.loadTexts: apTypeFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: apTypeFilterTable.setDescription('A table of Ethernet types (i.e. 16-bit DIX Ethernet type), which are entered by the user and supported for the type filtering function. The maximum number of entries in the table is 16.')
apTypeFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 7, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "typeIndex"))
if mibBuilder.loadTexts: apTypeFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apTypeFilterEntry.setDescription('An entry in the table of Type Filter. A row in this table is created by setting the value of etherType to Ethernet packet type in hexadecimal. A row in this table is deleted by setting the value of etherType to 00')
typeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: typeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: typeIndex.setDescription('Filter Type Table index. Range (1..16).')
etherType = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: etherType.setStatus('mandatory')
if mibBuilder.loadTexts: etherType.setDescription('A 16-bit Ethernet Protocol Type in hexadecimal. Range of valid Entries: 0X05DD .. 0XFFFE')
ap128bWEPKeyTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 8), )
if mibBuilder.loadTexts: ap128bWEPKeyTable.setStatus('mandatory')
if mibBuilder.loadTexts: ap128bWEPKeyTable.setDescription('A table of default WEP Keys The maximum number of entries in the table is 4.')
apWEPKeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 8, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "ap128bWepkeyIndex"))
if mibBuilder.loadTexts: apWEPKeyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apWEPKeyEntry.setDescription('An entry in the table of Default WEP Keys.')
ap128bWepkeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ap128bWepkeyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ap128bWepkeyIndex.setDescription('WEP Key Table index. Range (1..4).')
ap128bWepKeyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 1, 8, 1, 2), WEPKeytype128b()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ap128bWepKeyValue.setStatus('mandatory')
if mibBuilder.loadTexts: ap128bWepKeyValue.setDescription("A Default WEP Key Value. This value should be 26 character long. IMPORTANT NOTE: The 128 bit WEP key Encryption is currently restricted by U.S. laws. Its use is restricted to AP's manufactured for U.S. only. In order to activate the 128 bit Encryption for all other countries, an access code has to be obtained and entered through one of the interfaces such as Serial, Telnet, SNMP or Web. Upon authentication of the key the AP will enable the 128 bit Encryption. See Access Point manual for details.")
apTrafficMatrixTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 1), )
if mibBuilder.loadTexts: apTrafficMatrixTable.setStatus('mandatory')
if mibBuilder.loadTexts: apTrafficMatrixTable.setDescription('A table of Access Point Traffic Matrix which provides information on packets transmitted from one interface to another (Ethernet, PPP, radio, AP). The table also displays the number of broadcast packets transmitted from the Access Point. The current number of entries is 5.')
apTrafficMatrixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 1, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apTMTableIndex"))
if mibBuilder.loadTexts: apTrafficMatrixEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apTrafficMatrixEntry.setDescription('An entry in the table of Access Point Traffic Matrix. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
apTMTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTMTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apTMTableIndex.setDescription('Access Point Traffic Matrix Table index. Range (1..5).')
apProtoItfName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apProtoItfName.setStatus('mandatory')
if mibBuilder.loadTexts: apProtoItfName.setDescription('Access Point Protocol Interface Name (i.e. Ethernet, PPP, Radio, AP).')
apNPktsToEnets = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNPktsToEnets.setStatus('mandatory')
if mibBuilder.loadTexts: apNPktsToEnets.setDescription('Indicates the number of packets sent from the Access Point Protocol Interface to the Ethernet Interface. This field should always be zero if the Access Point Protocol Interface is Ethernet.')
apNPktsToPpps = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNPktsToPpps.setStatus('mandatory')
if mibBuilder.loadTexts: apNPktsToPpps.setDescription('Indicates the number of packets sent from the Access Point Protocol Interface to the PPP Interface. This field is meaningful only if the PPP interface is enabled. ')
apNPktsToRfs = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNPktsToRfs.setStatus('mandatory')
if mibBuilder.loadTexts: apNPktsToRfs.setDescription('Indicates the number of packets sent from the Access Point Protocol Interface to the RF Interface. If the Access Point Protocol Interface is RF, these are frames from one MU to another.')
apNPktsToAPStks = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNPktsToAPStks.setStatus('mandatory')
if mibBuilder.loadTexts: apNPktsToAPStks.setDescription('Indicates the number of packets sent from the Access Point Protocol Interface to the internal Access Point stack. This field should always be zero if the Access Point Protocol Interface is Access Point Stack.')
apItfStatTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2), )
if mibBuilder.loadTexts: apItfStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: apItfStatTable.setDescription('A table of Access Point Interfaces Statistics, which provides packets forwarding statistics for each inter- face (Ethernet, PPP, RF, AP stack). Interface statistics also provide performance informa- tion for each interface in Packets-per-second (PPS) and Bytes- per-second (BPS). The AP interface indicates packets sent to the AP stack (e.g. configuration requests, SNMP, Telnet etc.). The current number of entries is 4.')
apItfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apItfStatIndex"))
if mibBuilder.loadTexts: apItfStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apItfStatEntry.setDescription('An entry in the table of Access Point Interface Statistics. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
apItfStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apItfStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apItfStatIndex.setDescription('Access Point Interface Statistics Table index. Range (1..4).')
apInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: apInterfaceName.setDescription('Access Point Interface Name (Ethernet, PPP, RF, AP).')
apPacketsIns = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPacketsIns.setStatus('mandatory')
if mibBuilder.loadTexts: apPacketsIns.setDescription('Indicates the number of good packets received on the specified interface.')
apPacketsOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPacketsOuts.setStatus('mandatory')
if mibBuilder.loadTexts: apPacketsOuts.setDescription('Indicates the number of packets successfully transmitted on the specified interface.')
apOctetsIns = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOctetsIns.setStatus('mandatory')
if mibBuilder.loadTexts: apOctetsIns.setDescription('Indicates the number of good bytes received on the specified interface.')
apOctetsOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOctetsOuts.setStatus('mandatory')
if mibBuilder.loadTexts: apOctetsOuts.setDescription('Indicates the number of bytes successfully transmitted on the specified interface.')
apPktsInPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPktsInPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: apPktsInPerSec.setDescription('Indicates the number of good packets per second received on the specified Interface.')
apPktsOutPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPktsOutPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: apPktsOutPerSec.setDescription('Indicates the number of packets per second successfully transmitted on the specified interface.')
apOctInPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOctInPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: apOctInPerSec.setDescription('Indicates the number of good bytes per second received on the specified Interface.')
apOctOutPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apOctOutPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: apOctOutPerSec.setDescription('Indicates the number of bytes per second successfully transmitted on the specified interface.')
apEPktsSeens = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEPktsSeens.setStatus('mandatory')
if mibBuilder.loadTexts: apEPktsSeens.setDescription('Indicates the number of packets that have been seen on the Ethernet interface. Most of these packets are for stations other than those associated with this AP.')
apEPktsForwardeds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEPktsForwardeds.setStatus('mandatory')
if mibBuilder.loadTexts: apEPktsForwardeds.setDescription('Indicates the number of Ethernet packets forwarded from the Ethernet interface to other interfaces.')
apEPktsDiscNoMatchs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEPktsDiscNoMatchs.setStatus('mandatory')
if mibBuilder.loadTexts: apEPktsDiscNoMatchs.setDescription('Indicates the number of packets discarded due to unknown destination (i.e. no database entry).')
apEPktsDiscForceds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEPktsDiscForceds.setStatus('mandatory')
if mibBuilder.loadTexts: apEPktsDiscForceds.setDescription('Indicates the number of packets discarded due to Type or Address filters applied.')
apEPktsDiscBuffers = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEPktsDiscBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: apEPktsDiscBuffers.setDescription('Indicates the number of packets discarded due to lack of available buffers in AP.')
apEPktsDiscCRCs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEPktsDiscCRCs.setStatus('mandatory')
if mibBuilder.loadTexts: apEPktsDiscCRCs.setDescription('Indicates the number of packets discarded due to CRC errors.')
apEPktsSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEPktsSents.setStatus('mandatory')
if mibBuilder.loadTexts: apEPktsSents.setDescription('Indicates the number of packets sent by this Ethernet Port.')
apEAnyCollisions = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEAnyCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: apEAnyCollisions.setDescription('Indicates the number of packets that suffer at least one collision.')
apE1orMoreColls = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apE1orMoreColls.setStatus('mandatory')
if mibBuilder.loadTexts: apE1orMoreColls.setDescription('Indicates the number of packets that suffer more than one collision.')
apEMaxCollisions = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEMaxCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: apEMaxCollisions.setDescription('Indicates the number of packets that suffer more than the maximum number of collisions.')
apELateCollisions = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apELateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: apELateCollisions.setDescription('Indicates the number of packets that suffer late collisions.')
apEPktsDefers = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEPktsDefers.setStatus('mandatory')
if mibBuilder.loadTexts: apEPktsDefers.setDescription('Indicates the times AP had to defer transmit requests on Ethernet due to busy medium.')
apEBcMcPkts = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEBcMcPkts.setStatus('mandatory')
if mibBuilder.loadTexts: apEBcMcPkts.setDescription('Indicates the number of broadcast/multicast packets that have been transmitted.')
apEIndividualAddrs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 3, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apEIndividualAddrs.setStatus('mandatory')
if mibBuilder.loadTexts: apEIndividualAddrs.setDescription('Indicates the number of individual address (unicast) packets that have been received.')
rfBcMcPktsSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfBcMcPktsSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfBcMcPktsSents.setDescription('Indicates the number of broadcast/multicast packets that have been successfully transmitted.')
rfBcMcPktsRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfBcMcPktsRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfBcMcPktsRcvds.setDescription('Indicates the number of broadcast/multicast packets that have been successfully received.')
rfBcMcOctSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfBcMcOctSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfBcMcOctSents.setDescription('Indicates the number of broadcast/multicast bytes that have been successfully transmitted.')
rfBcMcOctRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfBcMcOctRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfBcMcOctRcvds.setDescription('Indicates the number of broadcast/multicast bytes that have been successfully received.')
rfSysPktsSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfSysPktsSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfSysPktsSents.setDescription('Indicates the number of system packets (includes probe operations packets) that have been successfully transmitted.')
rfSysPktsRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfSysPktsRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfSysPktsRcvds.setDescription('Indicates the number of system packets (includes probes /associate packets) that have been successfully received.')
rfSBcMcPktsSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfSBcMcPktsSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfSBcMcPktsSents.setDescription('Indicates the number of system broadcast/multicast packets (includes beacons) that have been successfully transmitted.')
rfSBcMcPktsRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfSBcMcPktsRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfSBcMcPktsRcvds.setDescription('Indicates the number of system broadcast/multicast (includes beacons) packets that have been successfully received.')
rfSuccFragPkts = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfSuccFragPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rfSuccFragPkts.setDescription('Indicates the number of packets that were fragmented and for which all fragments were acked.')
rfUnsuccFragPkts = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfUnsuccFragPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rfUnsuccFragPkts.setDescription('Indicates the number of packets that were fragmented but for which one or more fragments were not acked.')
rfTotalFragSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfTotalFragSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfTotalFragSents.setDescription('Indicates the number of packets fragments that have been sent.')
rfTotalFragRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfTotalFragRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfTotalFragRcvds.setDescription('Indicates the number of packets fragments that have been received.')
rfSuccReassPkts = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfSuccReassPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rfSuccReassPkts.setDescription('Indicates the number of packets that were reassigned and successfully reassembled.')
rfUnsuccReassPkts = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfUnsuccReassPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rfUnsuccReassPkts.setDescription('Indicates the number of packets that were unsuccessfully reassembled.')
rfAssocMUs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfAssocMUs.setStatus('mandatory')
if mibBuilder.loadTexts: rfAssocMUs.setDescription('Indicates the number of MUs currently associated with this AP.')
rfRcvdCRCErrors = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfRcvdCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rfRcvdCRCErrors.setDescription('Indicates the number of packets that were received but had the CRC errors.')
rfRcvdDupPkts = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfRcvdDupPkts.setStatus('mandatory')
if mibBuilder.loadTexts: rfRcvdDupPkts.setDescription('Indicates the number of packets that were received but were duplicates of previously received. This is usually an indication that an ACK was not received by the sending unit.')
rfTotalCollisions = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfTotalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rfTotalCollisions.setDescription('Indicates the number of collisions that have occured on the interface. A collision on the RF interface means that an ack was not received or that a RTS was not answered by a CTS.')
rfPktsWithoutColls = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfPktsWithoutColls.setStatus('mandatory')
if mibBuilder.loadTexts: rfPktsWithoutColls.setDescription('Indicates the number of packets without any collision.')
rfPktsWithMaxColls = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfPktsWithMaxColls.setStatus('mandatory')
if mibBuilder.loadTexts: rfPktsWithMaxColls.setDescription('Indicates the number of packets that suffered the maximum number of collisions.')
rfPktsWithColls = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfPktsWithColls.setStatus('mandatory')
if mibBuilder.loadTexts: rfPktsWithColls.setDescription('Indicates the number of packets that suffered at least one collision.')
rfDataPktsSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfDataPktsSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfDataPktsSents.setDescription('Indicates the number of packets transmitted.')
rfDataPktsRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfDataPktsRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfDataPktsRcvds.setDescription('Indicates the number of packets that were successfully received.')
rfDataOctetsSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfDataOctetsSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfDataOctetsSents.setDescription('Indicates the number of octets transmitted.')
rfDataOctetsRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfDataOctetsRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfDataOctetsRcvds.setDescription('Indicates the number of octets that were successfully received.')
rfEncrypPktsSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfEncrypPktsSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfEncrypPktsSents.setDescription('Indicates the number of Encrypted packets transmitted.')
rfEncrypPktsRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 4, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfEncrypPktsRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfEncrypPktsRcvds.setDescription('Indicates the number of Encrypted packets that were successfully received.')
apNbrOfDialouts = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNbrOfDialouts.setStatus('mandatory')
if mibBuilder.loadTexts: apNbrOfDialouts.setDescription('Indicates the number of dialout attempts by the AP.')
apDialoutFailures = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apDialoutFailures.setStatus('mandatory')
if mibBuilder.loadTexts: apDialoutFailures.setDescription('Indicates the number of dialout failures by the AP.')
apNbrOfAnswers = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNbrOfAnswers.setStatus('mandatory')
if mibBuilder.loadTexts: apNbrOfAnswers.setDescription('Indicates the number of answer attempts by the AP.')
apCurrCallTime = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 6, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apCurrCallTime.setStatus('mandatory')
if mibBuilder.loadTexts: apCurrCallTime.setDescription('Indicates the length in seconds of current connection session. Note: the time is relative to the boot time of this AP.')
apLastCallTime = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 6, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apLastCallTime.setStatus('mandatory')
if mibBuilder.loadTexts: apLastCallTime.setDescription('Indicates the length in seconds of last connection session. Note: the time is relative to the boot time of this AP.')
apWNMPCfgPkts = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apWNMPCfgPkts.setStatus('mandatory')
if mibBuilder.loadTexts: apWNMPCfgPkts.setDescription('Indicates the number of WNMP configuration requests received from NetVision.')
wEchoRequests = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wEchoRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wEchoRequests.setDescription('Indicates the number of WNMP Echo Requests received by this AP.')
wPingRequests = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wPingRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wPingRequests.setDescription('Indicates the number of WNMP ping requests received by this AP.')
wPktsFromNVs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 7, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wPktsFromNVs.setStatus('mandatory')
if mibBuilder.loadTexts: wPktsFromNVs.setDescription('Indicates the number of WNMP packets that were received from NetVision via this AP.')
wPPktsToNVs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wPPktsToNVs.setStatus('mandatory')
if mibBuilder.loadTexts: wPPktsToNVs.setDescription('Indicates the number of WNMP packets that were sent to the NetVision via this AP.')
wPassThruEchoes = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 7, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wPassThruEchoes.setStatus('mandatory')
if mibBuilder.loadTexts: wPassThruEchoes.setDescription('Indicates the number of WNMP packets for other stations that passed through this AP.')
apCurrentMUs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apCurrentMUs.setStatus('mandatory')
if mibBuilder.loadTexts: apCurrentMUs.setDescription('Indicates the number of MUs currently associated with this AP.')
apMaxMUs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apMaxMUs.setStatus('mandatory')
if mibBuilder.loadTexts: apMaxMUs.setDescription('Indicates the highest number of MUs ever associated with this AP.')
apTotalAssocs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTotalAssocs.setStatus('mandatory')
if mibBuilder.loadTexts: apTotalAssocs.setDescription('Indicates the total number of associations by all MUs with this AP.')
apMUTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4), )
if mibBuilder.loadTexts: apMUTable.setStatus('mandatory')
if mibBuilder.loadTexts: apMUTable.setDescription('A table of information for a specific MU associated with this Access Point. The current number of entries is 127.')
apMUEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "muIndex"))
if mibBuilder.loadTexts: apMUEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apMUEntry.setDescription('An entry in the table of information for a specific MU associated with this Access Point. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
muIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muIndex.setStatus('mandatory')
if mibBuilder.loadTexts: muIndex.setDescription('Specific MU information Table index. Range (1..127).')
muMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: muMacAddr.setDescription('The MAC address of the MU associated with this AP.')
muInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernet", 1), ("ppp", 2), ("rf", 3), ("apstack", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muInterface.setStatus('mandatory')
if mibBuilder.loadTexts: muInterface.setDescription('Indicates the interface on which this MU is located. Note: The AP may learn of an MU via the RF network or from the wired networks such as Ethernet or PPP. In this release, the AP does not keep track of those MUs reachable via the Ethernet, but that will change in future releases.')
muState = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("associated", 3), ("not-associated", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muState.setStatus('mandatory')
if mibBuilder.loadTexts: muState.setDescription('Indicates the state of this MU.')
muPowerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cam", 1), ("psp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muPowerMode.setStatus('mandatory')
if mibBuilder.loadTexts: muPowerMode.setDescription('Indicates the MU power mode (Power Save Protocol mode or Continue Active Mode.)')
muStationID = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muStationID.setStatus('mandatory')
if mibBuilder.loadTexts: muStationID.setDescription('Indicates the MU station ID.')
muLastAPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 7), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muLastAPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: muLastAPAddr.setDescription('Indicates the MAC address of the last AP with which this MU had an association.')
muTotalAssoc = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muTotalAssoc.setStatus('mandatory')
if mibBuilder.loadTexts: muTotalAssoc.setDescription('Indicates the total associations for this MU.')
muAssocStart = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muAssocStart.setStatus('mandatory')
if mibBuilder.loadTexts: muAssocStart.setDescription('Indicates when the MU began its current association with this AP. Note: Time is represented in seconds and the time is relative to the boot time of this AP. This is also true for all the association objects listed below.')
muLstAssStrt = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muLstAssStrt.setStatus('mandatory')
if mibBuilder.loadTexts: muLstAssStrt.setDescription('Indicates when the MU began its prior association with this AP. If this is the first association with this AP, this value is zero. ')
muLastAssEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muLastAssEnd.setStatus('mandatory')
if mibBuilder.loadTexts: muLastAssEnd.setDescription('Indicates when the MU ended its previous association with this AP. If this is the first association with this AP, this value is zero. ')
muNPktsSents = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muNPktsSents.setStatus('mandatory')
if mibBuilder.loadTexts: muNPktsSents.setDescription('Indicates the number of packets successfully transmitted to this MU.')
muNPktsRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muNPktsRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: muNPktsRcvds.setDescription('Indicates the number of Good Packets received from this MU.')
muNBytesSents = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muNBytesSents.setStatus('mandatory')
if mibBuilder.loadTexts: muNBytesSents.setDescription('Indicates the number of bytes successfully transmitted to this MU.')
muNBytesRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muNBytesRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: muNBytesRcvds.setDescription('Indicates the number of Good Bytes received from this MU.')
muNDiscdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muNDiscdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: muNDiscdPkts.setDescription('Indicates the number of received packets discarded because no buffers.')
muTmLastData = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 17), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muTmLastData.setStatus('mandatory')
if mibBuilder.loadTexts: muTmLastData.setDescription('Indicates the time when the last good packet was received from this MU. The packet may be either an ACK, Data, or Poll. ')
muPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("voice", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muPriority.setStatus('mandatory')
if mibBuilder.loadTexts: muPriority.setDescription('Indicates the Voice/Data priority mode for this MU. ')
muSupportedRates = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("one-Mb", 1), ("two-Mb", 2), ("one-and-two-Mb", 3), ("five-half-Mb", 4), ("one-and-five-half-Mb", 5), ("two-and-five-half-Mb", 6), ("one-and-two-and-five-half-Mb", 7), ("eleven-Mb", 8), ("one-and-eleven-Mb", 9), ("two-and-eleven-Mb", 10), ("one-and-two-and-eleven-Mb", 11), ("five-half-and-eleven-Mb", 12), ("one-and-five-half-and-eleven-Mb", 13), ("two-and-five-half-and-eleven-Mb", 14), ("one-and-two-and-five-half-and-eleven-Mb", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muSupportedRates.setStatus('mandatory')
if mibBuilder.loadTexts: muSupportedRates.setDescription('Indicates the supported data rates for this MU. The unit is MB/second. ')
muCurrentXmtRate = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one-Megabit", 1), ("two-Megabit", 2), ("five-half-Megabit", 3), ("eleven-Megabit", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: muCurrentXmtRate.setStatus('mandatory')
if mibBuilder.loadTexts: muCurrentXmtRate.setDescription('Indicates the current transmit data rate for this MU. The unit is MB/second. ')
muLastActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 4, 1, 21), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muLastActivity.setStatus('mandatory')
if mibBuilder.loadTexts: muLastActivity.setDescription('Indicates the time for the last activity for this MU.')
apMUHmAgTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 5), )
if mibBuilder.loadTexts: apMUHmAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: apMUHmAgTable.setDescription('A table of information on Mobile IP Home agent. The current number of entries is 127.')
apMUHATEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 5, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "muHATMUIpAddr"))
if mibBuilder.loadTexts: apMUHATEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apMUHATEntry.setDescription('An entry in the table of information on on Mobile IP Home agent. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
muHATMUIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muHATMUIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: muHATMUIpAddr.setDescription('This is the IP Address of the MU visiting in the foreign network.')
muHATFrAgIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muHATFrAgIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: muHATFrAgIpAddr.setDescription('This is the IP Address of the Foreign agent for the visiting MU.')
apMUFrAgTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 6), )
if mibBuilder.loadTexts: apMUFrAgTable.setStatus('mandatory')
if mibBuilder.loadTexts: apMUFrAgTable.setDescription('A table of information on Mobile IP Foreign agent. The current number of entries is 127.')
apMUFATEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 6, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "muFATMUIpAddr"))
if mibBuilder.loadTexts: apMUFATEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apMUFATEntry.setDescription('An entry in the table of information on Mobile IP Foreign agent. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
muFATMUIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 6, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muFATMUIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: muFATMUIpAddr.setDescription('This is the IP Address of the MU visiting in the foreign network.')
muFATHmAgIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 8, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: muFATHmAgIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: muFATHmAgIpAddr.setDescription('This is the IP Address of the home agent for the visiting MU.')
apKnownAPsTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9), )
if mibBuilder.loadTexts: apKnownAPsTable.setStatus('mandatory')
if mibBuilder.loadTexts: apKnownAPsTable.setDescription('A table of information on other Access Points known by this Access Point. The current number of entries is 32.')
apKnownAPsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apAPMacAddr"))
if mibBuilder.loadTexts: apKnownAPsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apKnownAPsEntry.setDescription('An entry in the table of information on the Known Access Points. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
apAPMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAPMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: apAPMacAddr.setDescription('Mac Address of this Known AP.')
apAPIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAPIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: apAPIpAddr.setDescription('IP Address of this Known AP.')
apHoppingSet = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apHoppingSet.setStatus('mandatory')
if mibBuilder.loadTexts: apHoppingSet.setDescription('Hopping Set of this Known AP.')
apHoppingSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apHoppingSeq.setStatus('mandatory')
if mibBuilder.loadTexts: apHoppingSeq.setDescription('Hopping Sequence of this Known AP.')
apNbrOfMUs = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNbrOfMUs.setStatus('mandatory')
if mibBuilder.loadTexts: apNbrOfMUs.setDescription('Indicates the number of MUs currently associated with this known AP.')
apKBIOS = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apKBIOS.setStatus('mandatory')
if mibBuilder.loadTexts: apKBIOS.setDescription('Kilobytes sent and received per second by this known AP on the radio interface.')
apAway = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAway.setStatus('mandatory')
if mibBuilder.loadTexts: apAway.setDescription("Indicate that whether this known AP is still alive or not. If the current AP does not receive WNMP packet from this known AP within 36 seconds, this known AP is considered 'AWAY'.")
ap802dot11Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ap802dot11Protocol.setStatus('mandatory')
if mibBuilder.loadTexts: ap802dot11Protocol.setDescription('Indicate that whether this known AP is 802.11 compliant.')
apFwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apFwVer.setStatus('mandatory')
if mibBuilder.loadTexts: apFwVer.setDescription('Indicates The firmware revision for this known Access Point.')
apDSchannel = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 9, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apDSchannel.setStatus('mandatory')
if mibBuilder.loadTexts: apDSchannel.setDescription('The current operating frequency channel of the DSSS PHY. Valid channel numbers are as defined in IEEE 802.11 specification section 15.4.6.2.')
apAdrViolations = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAdrViolations.setStatus('mandatory')
if mibBuilder.loadTexts: apAdrViolations.setDescription('Indicates the number of Mobile Unit MAC address violations counted.')
apTypeViolations = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apTypeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: apTypeViolations.setDescription('Indicates the number of Ethernet packet type violations counted.')
apNbrOfWLAPItfs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNbrOfWLAPItfs.setStatus('mandatory')
if mibBuilder.loadTexts: apNbrOfWLAPItfs.setDescription('Indicates number of WLAP interfaces established.')
apWLAPState = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 15, 16))).clone(namedValues=NamedValues(("initializing", 1), ("send-probe", 2), ("send-assoc-req", 3), ("send-cfg-bpdu", 4), ("wait-for-probe", 5), ("send-probe-rsp", 6), ("send-assoc-rsp", 7), ("send-cfg-rsp", 8), ("receive-root-rsp", 10), ("root-ap-lost", 12), ("disabled", 14), ("functional", 15), ("wlap-lost-on-ethernet", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apWLAPState.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPState.setDescription('Indicates the current WLAP state. The state values and meanings are as follows: - During power-up initialization: Initializing(1) - During WLAP association process: send-probe(2) send-assoc-req(3) send-cfg-bpdu(4) wait-for-probe(5) send-probe-rsp(6) send-assoc-rsp(7) send-cfg-rsp(8) receive-root-rsp(10) - During WLAP operation: root-ap-lost(12) disabled(14) functional(15) wlap-lost-on-ethernet(16) ')
apWLAPHopSequence = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apWLAPHopSequence.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPHopSequence.setDescription('Indicates the hop sequence of the Root AP followed by this WLAP.')
apRootInterface = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRootInterface.setStatus('mandatory')
if mibBuilder.loadTexts: apRootInterface.setDescription('Indicates the WLAP interface leading to the Root AP.')
apRootWLAPID = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRootWLAPID.setStatus('mandatory')
if mibBuilder.loadTexts: apRootWLAPID.setDescription('Indicates the WLAP ID of the Root AP. It consists of 2 bytes of priority (Default is 0x8000) and 6 bytes of MAC address of the Root AP')
apRootPathCost = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRootPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: apRootPathCost.setDescription('Indicates how many hops away the current WLAP is from the Root AP.')
apWLAPID = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apWLAPID.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPID.setDescription('Indicates the WLAP ID of the current WLAP. It consists of 2 bytes of priority (Default is 0x8000) and 6 bytes MAC address of the current WLAP')
apWLAPItfTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8), )
if mibBuilder.loadTexts: apWLAPItfTable.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPItfTable.setDescription('A table of wireless AP interfaces information, which contains four (4) AP-to-AP interfaces.')
apWLAPItfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apWLAPItfID"))
if mibBuilder.loadTexts: apWLAPItfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPItfEntry.setDescription('An entry in the table of wireless AP interfaces information.')
apWLAPItfID = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apWLAPItfID.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPItfID.setDescription('WLAP interface ID. It consists of 1 byte of priority (Default is 0x80) and 1 byte of interface ID.')
apWLAPItfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apWLAPItfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPItfAddr.setDescription('The MAC address of the associated WLAP on this interface.')
apWLAPItfState = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("listening", 2), ("learning", 3), ("forwarding", 4), ("blocking", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apWLAPItfState.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPItfState.setDescription('The current state of the Wireless AP interface, ie : Disabled(1), Listening(2), Learning(3), Forwarding(4), or Blocking(5).')
apWLAPPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apWLAPPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: apWLAPPathCost.setDescription('The cost to be added to the root path cost field in the config BPDU (Bridge Protocol Data Unit) received on this interface in order to determine the cost of the path to the root WLAP.')
apDsgnatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apDsgnatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: apDsgnatedRoot.setDescription('The unique Root AP ID designated by the Root AP.')
apDsgnatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apDsgnatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: apDsgnatedCost.setDescription('The cost of the path to the Root AP designated by the Root AP.')
apDsgnatedWLAP = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apDsgnatedWLAP.setStatus('mandatory')
if mibBuilder.loadTexts: apDsgnatedWLAP.setDescription('The unique WLAP ID designated by the Root AP.')
apDsgnatedItf = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 11, 8, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apDsgnatedItf.setStatus('mandatory')
if mibBuilder.loadTexts: apDsgnatedItf.setDescription('The WLAP interface ID designated by the Root AP.')
apRetryHistogramTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 12), )
if mibBuilder.loadTexts: apRetryHistogramTable.setStatus('mandatory')
if mibBuilder.loadTexts: apRetryHistogramTable.setDescription('A table of Retry statistics, which is based on number of packets with various retries over time. The current number of entries is 16.')
apRetryHistogramEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 12, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apRetryHistogramIndex"))
if mibBuilder.loadTexts: apRetryHistogramEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apRetryHistogramEntry.setDescription('An entry in the table of Retry Histogram, which is based on number of packets with various retries over time. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
apRetryHistogramIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRetryHistogramIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apRetryHistogramIndex.setDescription('Number of retries index. Range (1..16).')
apNumberOfRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apNumberOfRetries.setStatus('mandatory')
if mibBuilder.loadTexts: apNumberOfRetries.setDescription('Packets with this Number of retries. Range (0..15).')
apPacketsHistogramCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apPacketsHistogramCounts.setStatus('mandatory')
if mibBuilder.loadTexts: apPacketsHistogramCounts.setDescription('Counter for the packets per number of retries.')
apDSPerFreqStatTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 13), )
if mibBuilder.loadTexts: apDSPerFreqStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: apDSPerFreqStatTable.setDescription('A table of Radio Per Frequency statistics, which is based on the historical frequency records used by this Access Point. The current number of entries is 78.')
apDSPerFreqStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 13, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "rfDSFrequency"))
if mibBuilder.loadTexts: apDSPerFreqStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apDSPerFreqStatEntry.setDescription('An entry in the table of Radio per frequency statistics. A row in this table cannot be created or deleted by SNMP operations on columns of the table.')
rfDSFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfDSFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: rfDSFrequency.setDescription('Radio Frequency channel number.')
rfDSPerFqPktsSents = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfDSPerFqPktsSents.setStatus('mandatory')
if mibBuilder.loadTexts: rfDSPerFqPktsSents.setDescription('Counter for the packets sent per frequency.')
rfDSPerFqPktsRcvds = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfDSPerFqPktsRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: rfDSPerFqPktsRcvds.setDescription('Counter for the packets received per frequency.')
rfDSPerFqRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfDSPerFqRetries.setStatus('mandatory')
if mibBuilder.loadTexts: rfDSPerFqRetries.setDescription('Counter for the retries per frequency.')
apAgentAdSents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 14, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apAgentAdSents.setStatus('mandatory')
if mibBuilder.loadTexts: apAgentAdSents.setDescription('Counter for the number agent advertisement sent.')
apRegRequestRcvds = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 14, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRegRequestRcvds.setStatus('mandatory')
if mibBuilder.loadTexts: apRegRequestRcvds.setDescription('Counter for the number registration request received.')
apRegReplySents = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 2, 14, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apRegReplySents.setStatus('mandatory')
if mibBuilder.loadTexts: apRegReplySents.setDescription('Counter for the number registration reply sent.')
apClrAllStatistics = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apClrAllStatistics.setStatus('mandatory')
if mibBuilder.loadTexts: apClrAllStatistics.setDescription('Clear all the interface statistics (yes = 1, no = 2).')
apClrMUTable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apClrMUTable.setStatus('mandatory')
if mibBuilder.loadTexts: apClrMUTable.setDescription('Clear the MU Table (yes = 1, no = 2).')
apClrACL = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apClrACL.setStatus('mandatory')
if mibBuilder.loadTexts: apClrACL.setDescription('Clear the Access Control Table (yes = 1, no = 2).')
apClrACLRangeTable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apClrACLRangeTable.setStatus('mandatory')
if mibBuilder.loadTexts: apClrACLRangeTable.setDescription('Clear the Access Control Range Table (yes = 1, no = 2).')
apClrAddrFilterTbl = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apClrAddrFilterTbl.setStatus('mandatory')
if mibBuilder.loadTexts: apClrAddrFilterTbl.setDescription('Clear the Address Filtering Table (yes = 1, no = 2).')
apLdACLFrMUList = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apLdACLFrMUList.setStatus('mandatory')
if mibBuilder.loadTexts: apLdACLFrMUList.setDescription('Load the Access Control Table from MU Table (yes = 1, no = 2).')
apModemDialOut = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apModemDialOut.setStatus('mandatory')
if mibBuilder.loadTexts: apModemDialOut.setDescription('Commands the modem to dialout (yes = 1, no = 2).')
apModemHangUp = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apModemHangUp.setStatus('mandatory')
if mibBuilder.loadTexts: apModemHangUp.setDescription("Forces the AP to issue a 'hangup' string to the modem attached to the serial port (yes = 1, no = 2). This command is meaning-ful only if the AP is configured for a modem connection on the serial port. If there is no modem or there is no connection, the command will be ignored.")
apUpdateFirmware = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apUpdateFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: apUpdateFirmware.setDescription("Update the AP firmware through TFTP server. The AP firmware will be saved in NVRAM (yes = 1, no = 2). Before issuing this command, set 'apDnLdFileName', and 'apTFTPServer' to the proper values.")
apDnLdFileName = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apDnLdFileName.setStatus('mandatory')
if mibBuilder.loadTexts: apDnLdFileName.setDescription('The name of the file to be downloaded to the AP. (Including path name and total up to 49 characters.) Note: IF DHCP is responded to, that name will take precedence and overwrite this name.')
apTFTPServer = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apTFTPServer.setStatus('mandatory')
if mibBuilder.loadTexts: apTFTPServer.setDescription('The IP address for the TFTP Server. Note: IF DHCP is responded to, that IP address will take precedence and overwrite this setting.')
apResetAP = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apResetAP.setStatus('mandatory')
if mibBuilder.loadTexts: apResetAP.setDescription('Forces a reset of the AP (yes = 1, no = 2). Upon reset, the AP clears all the statistics and restores the last saved configuration information. If changes are made without being saved, the AP clears those changes upon reset.')
apHTMLFileName = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apHTMLFileName.setStatus('mandatory')
if mibBuilder.loadTexts: apHTMLFileName.setDescription('The name of the HTML file to be downloaded to the AP. (Including path name and total up to 49 characters.) Note: IF DHCP is responded to, that name will take precedence and overwrite this name.')
apUpdateHTMLFile = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apUpdateHTMLFile.setStatus('mandatory')
if mibBuilder.loadTexts: apUpdateHTMLFile.setDescription("Update the AP HTML file through TFTP server. The AP HTML file will be saved in NVRAM (yes = 1, no = 2). Before issuing this command, set 'apHTMLFileName', and 'apTFTPServer' to the proper values.")
apDHCPEnable = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apDHCPEnable.setStatus('mandatory')
if mibBuilder.loadTexts: apDHCPEnable.setDescription('Enables/Disables DHCP mode for the AP. Default is disabled(2).')
apUpdAllAPsFirmware = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apUpdAllAPsFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: apUpdAllAPsFirmware.setDescription("Update all APs firmware on this network which share the same NetID through TFTP server. The AP firmware will be saved in NVRAM (yes = 1, no = 2). Before issuing this command, set 'apDnLdFileName', and 'apTFTPServer' to the proper values.")
apUpdAllAPsHTMLFile = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apUpdAllAPsHTMLFile.setStatus('mandatory')
if mibBuilder.loadTexts: apUpdAllAPsHTMLFile.setDescription("Update all APs HTML file on this network which share the same NetID through TFTP server. The AP HTML file will be saved in NVRAM (yes = 1, no = 2). Before issuing this command, set 'apHTMLFileName', and 'apTFTPServer' to the proper values.")
apTFTPUpdBothFiles = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apTFTPUpdBothFiles.setStatus('mandatory')
if mibBuilder.loadTexts: apTFTPUpdBothFiles.setDescription("Update Both HTML file and Firmware for this Access Point The AP HTML file will be saved in NVRAM (yes = 1, no = 2). Before issuing this command, set 'apHTMLFileName', and 'apTFTPServer' to the proper values.")
apHelpURL = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apHelpURL.setStatus('mandatory')
if mibBuilder.loadTexts: apHelpURL.setDescription('The name of the HTML Help file . (Including path name and total up to 39 characters.)')
apFileUpdateStatus = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("download-successful", 1), ("too-many-XMODEM-errors", 2), ("xmodem-transfer-cancelled", 3), ("xmodem-packets-out-of-order", 4), ("tftp-server-unreachable", 5), ("no-ARP-response-from-server", 6), ("no-TFTP-service-on-server", 7), ("firmware-file-not-found", 8), ("html-file-not-found", 9), ("bad-permissions-for-firmware-file", 10), ("unable-to-open-firmware-file", 11), ("unable-to-open-HTML-file", 12), ("error-during-TFTP-download", 13), ("too-many-TFTP-retries", 14), ("corrupted-firmware-file", 15), ("general-download-failure", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apFileUpdateStatus.setStatus('mandatory')
if mibBuilder.loadTexts: apFileUpdateStatus.setDescription('Reports the Firmware/HTML file download and update status.')
apFlashLEDs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 3, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apFlashLEDs.setStatus('mandatory')
if mibBuilder.loadTexts: apFlashLEDs.setDescription('When this command is issued, it forces all status LEDs on the AP to start flashing. This command is primarily used for physically locating the AP where multiple APs are deployed. (yes = 1, no = 2) Default is no.')
apACLViolations = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apACLViolations.setStatus('mandatory')
if mibBuilder.loadTexts: apACLViolations.setDescription('Indicates the number of Access Control violations occurred.')
apSaveConfig = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSaveConfig.setStatus('mandatory')
if mibBuilder.loadTexts: apSaveConfig.setDescription('Saves the current configuration to NVRAM (yes = 1, no = 2).')
apAccCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 3), )
if mibBuilder.loadTexts: apAccCtrlTable.setStatus('mandatory')
if mibBuilder.loadTexts: apAccCtrlTable.setDescription('A table of MAC addresses allowed to associate with the Access Point. The maximum number of entries in the table is 512.')
apAccCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 3, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "allowedIndex"))
if mibBuilder.loadTexts: apAccCtrlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apAccCtrlEntry.setDescription("An entry in the table of MAC address Access Control. A row in this table is created by setting the value of allowedMU to the MAC address of the MU allowed to associate with this Access Point. A row in this table is deleted by setting the value of allowedMU to '000000000000'.")
allowedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: allowedIndex.setStatus('mandatory')
if mibBuilder.loadTexts: allowedIndex.setDescription('Access Control Table index. Range (1..512).')
allowedMU = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 3, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowedMU.setStatus('mandatory')
if mibBuilder.loadTexts: allowedMU.setDescription('MU MAC address which is allowed to associate with this AP.')
apACLRangeTable = MibTable((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 4), )
if mibBuilder.loadTexts: apACLRangeTable.setStatus('mandatory')
if mibBuilder.loadTexts: apACLRangeTable.setDescription('A table of Access Control Range, which consists of eight (8) pairs of low and high MAC addresses. Any Mobile Unit with the MAC address within the range is allowed to associate with the Access Point. The maximum number of entries in the table is 8.')
apACLRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 4, 1), ).setIndexNames((0, "SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", "apACLRangeIndex"))
if mibBuilder.loadTexts: apACLRangeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: apACLRangeEntry.setDescription("An entry in the table of MAC address Access Control Range. A row in this table is created by first setting the value of lowMacAddr to the lowest MAC address and then the value of highMacAddr to the highest MAC address of a group of Mobile Units allowed to associate with this Access Point. This sequence of setting is very important, otherwise a wrong result will occur. A row in this table is deleted by setting the value of either lowMacAddr or highMacAddr to '000000000000'.")
apACLRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apACLRangeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: apACLRangeIndex.setDescription('Access Control Range Table index. Range (1..8).')
lowMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 4, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lowMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lowMacAddr.setDescription('The lowest Mobile Unit MAC address in the range which is allowed to be associated with this AP. Note: When setting the ACL range, Both lowMacAddr and highMacAddr have to be set in order for the ACL range setting to take effect. lowMacAddr should be entered first. lowMacAddr < highMacAddr')
highMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 4, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: highMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: highMacAddr.setDescription('The highest Mobile Unit MAC address in the range which is allowed to be associated with this AP. Note: When setting the ACL range, Both lowMacAddr and highMacAddr have to be set in order for the ACL range setting to take effect. highMacAddr should be entered last. highMacAddr > lowMacAddr')
apSaveConfigAllAPs = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSaveConfigAllAPs.setStatus('mandatory')
if mibBuilder.loadTexts: apSaveConfigAllAPs.setDescription('Saves the current configuration to NVRAM for all APs on this network which share the same NetID(yes = 1, no = 2).')
apWEPLicenseKey = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apWEPLicenseKey.setStatus('mandatory')
if mibBuilder.loadTexts: apWEPLicenseKey.setDescription('This is a license key (a string of 18 alphanumeric characters). It is arranaged as follows: xxxx-yyyyyyy-zzzzzzz xxxx : vendor specific ID code ( 4 alphabetical characters) -yyyyyyy-zzzzzzz : a string of 14 alphanumeric characters Note: It is important to insert the hyphens in as shown. When entered and authenticated by the AP, the Strong(128 bit) encryption is enabled. Check the state of ap128bWEPFlag object.')
ap128bWEPFlag = MibScalar((1, 3, 6, 1, 4, 1, 388, 1, 5, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ap128bWEPFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ap128bWEPFlag.setDescription('When enabled, This flag indicates that AP is enabled to supports strong(128 bit) Encryption. The state of this flag is internally set only by the AP. when a valid access code is entered for apWEPLicenseKey object and accepted the AP will set the state of this flag to enabled. Default is disabled.')
mibBuilder.exportSymbols("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", apDSAPMUMaxAssocTrap=apDSAPMUMaxAssocTrap, apAdditionalGatewaysTable=apAdditionalGatewaysTable, wEchoRequests=wEchoRequests, apTelnetEnable=apTelnetEnable, apWLAPMode=apWLAPMode, apNbrOfDialouts=apNbrOfDialouts, apPktsInPerSec=apPktsInPerSec, apMUTable=apMUTable, apWLAPState=apWLAPState, rfBcMcPktsRcvds=rfBcMcPktsRcvds, muLastActivity=muLastActivity, apSubnetMask=apSubnetMask, apMUStateChngTrapEnable=apMUStateChngTrapEnable, apEIndividualAddrs=apEIndividualAddrs, apMUEntry=apMUEntry, apAgentAdSents=apAgentAdSents, rfAssocMUs=rfAssocMUs, lowMacAddr=lowMacAddr, apRootPathCost=apRootPathCost, apTrafficMatrixEntry=apTrafficMatrixEntry, apRetryHistogramTable=apRetryHistogramTable, apDialoutFailures=apDialoutFailures, apClrACL=apClrACL, apBCMCQMax=apBCMCQMax, apEPktsDiscForceds=apEPktsDiscForceds, apSaveConfigAllAPs=apSaveConfigAllAPs, muMacAddr=muMacAddr, apDSRootWLAPUpTrap=apDSRootWLAPUpTrap, rfUnsuccReassPkts=rfUnsuccReassPkts, rfTotalFragSents=rfTotalFragSents, apAPMacAddr=apAPMacAddr, ap128bWepkeyIndex=ap128bWepkeyIndex, apEAnyCollisions=apEAnyCollisions, apDSDsgnatedWLAPLostTrap=apDSDsgnatedWLAPLostTrap, apTotalAssocs=apTotalAssocs, apWEPKeyEntry=apWEPKeyEntry, muSupportedRates=muSupportedRates, apAnswerWaitTime=apAnswerWaitTime, rfPktsWithColls=rfPktsWithColls, rfPktsWithoutColls=rfPktsWithoutColls, apRetryHistogramIndex=apRetryHistogramIndex, apAddrFilterEntry=apAddrFilterEntry, apWLAPPriority=apWLAPPriority, apWLAPItfState=apWLAPItfState, muPowerMode=muPowerMode, apWLAPInfo=apWLAPInfo, disallowedIndex=disallowedIndex, dsap=dsap, rfDataOctetsRcvds=rfDataOctetsRcvds, apRetryHistogramEntry=apRetryHistogramEntry, apWLAPFwdDelay=apWLAPFwdDelay, apACLRangeEntry=apACLRangeEntry, apDsgnatedCost=apDsgnatedCost, apClrACLRangeTable=apClrACLRangeTable, apE1orMoreColls=apE1orMoreColls, rfUnsuccFragPkts=rfUnsuccFragPkts, apAgentAdInterval=apAgentAdInterval, apPPPTerminates=apPPPTerminates, muState=muState, apSNMPInfo=apSNMPInfo, apDSAPDHCPLeaseUpTrap=apDSAPDHCPLeaseUpTrap, apWLAPPathCost=apWLAPPathCost, rfBcMcPktsSents=rfBcMcPktsSents, muNDiscdPkts=muNDiscdPkts, apDSPerFreqStatTable=apDSPerFreqStatTable, muLastAssEnd=muLastAssEnd, apAntennaSelect=apAntennaSelect, rfDSPerFqPktsRcvds=rfDSPerFqPktsRcvds, muInterface=muInterface, apAdrViolations=apAdrViolations, apTypeFilterEnable=apTypeFilterEnable, apMUFrAgTable=apMUFrAgTable, highMacAddr=highMacAddr, apEPktsDiscBuffers=apEPktsDiscBuffers, wPktsFromNVs=wPktsFromNVs, apFilterStatistics=apFilterStatistics, apEPktsSents=apEPktsSents, apDHCPEnable=apDHCPEnable, wPPktsToNVs=wPPktsToNVs, rfTotalCollisions=rfTotalCollisions, apMaxRetriesVoice=apMaxRetriesVoice, muHATFrAgIpAddr=muHATFrAgIpAddr, apOctetsOuts=apOctetsOuts, apMUInactivityTimeOut=apMUInactivityTimeOut, apDsgnatedWLAP=apDsgnatedWLAP, WEPKeytype128b=WEPKeytype128b, ap128bWepKeyValue=ap128bWepKeyValue, apKBIOS=apKBIOS, apHardwareRev=apHardwareRev, allowedMU=allowedMU, wPingRequests=wPingRequests, apRegRequestRcvds=apRegRequestRcvds, muNBytesSents=muNBytesSents, rfRcvdDupPkts=rfRcvdDupPkts, apEPktsForwardeds=apEPktsForwardeds, apRFTrapEnable=apRFTrapEnable, apAPStateXchgEnable=apAPStateXchgEnable, apAway=apAway, apWLAPManualBSSID=apWLAPManualBSSID, apDSDsgntedWLAPUpTrap=apDSDsgntedWLAPUpTrap, apAllTrapsEnable=apAllTrapsEnable, apDSchannel=apDSchannel, apMaxMUs=apMaxMUs, apEPktsDefers=apEPktsDefers, apPPPTimeout=apPPPTimeout, apRFRate11Mb=apRFRate11Mb, apNPktsToEnets=apNPktsToEnets, apHTMLFileName=apHTMLFileName, rfBcMcOctSents=rfBcMcOctSents, apWEPLicenseKey=apWEPLicenseKey, apEPktsDiscNoMatchs=apEPktsDiscNoMatchs, apReassemblyTimeOut=apReassemblyTimeOut, rfPktsWithMaxColls=rfPktsWithMaxColls, apNetID=apNetID, apKnownAPsTable=apKnownAPsTable, apRootWLAPID=apRootWLAPID, apPPPState=apPPPState, apColdBootTrapEnable=apColdBootTrapEnable, rfBcMcOctRcvds=rfBcMcOctRcvds, apHelpURL=apHelpURL, apACLRangeIndex=apACLRangeIndex, apACLRangeTable=apACLRangeTable, wPassThruEchoes=wPassThruEchoes, apModemConnected=apModemConnected, apDSPerFreqStatEntry=apDSPerFreqStatEntry, apInterfaceName=apInterfaceName, apDSAPRFStartUpTrap=apDSAPRFStartUpTrap, apTypeViolations=apTypeViolations, apDSAPMUUnAssocTrap=apDSAPMUUnAssocTrap, apTFTPUpdBothFiles=apTFTPUpdBothFiles, authenticationFailure=authenticationFailure, muFATHmAgIpAddr=muFATHmAgIpAddr, apDsgnatedRoot=apDsgnatedRoot, apWNMPStatistics=apWNMPStatistics, apOctOutPerSec=apOctOutPerSec, rfSBcMcPktsRcvds=rfSBcMcPktsRcvds, muFATMUIpAddr=muFATMUIpAddr, apPacketsOuts=apPacketsOuts, apNPktsToAPStks=apNPktsToAPStks, apWebServerEnable=apWebServerEnable, apUnitName=apUnitName, apAccCtrlEnable=apAccCtrlEnable, apWLAPItfID=apWLAPItfID, apPacketsHistogramCounts=apPacketsHistogramCounts, apMUMUDisallowed=apMUMUDisallowed, apNbrOfMUs=apNbrOfMUs, apNbrOfWLAPItfs=apNbrOfWLAPItfs, apItfStatIndex=apItfStatIndex, apUpdateFirmware=apUpdateFirmware, apWLAPMaxAge=apWLAPMaxAge, apSerialPortUse=apSerialPortUse, apGatewayIPAddr=apGatewayIPAddr, muAssocStart=muAssocStart, ap128bWEPKeyTable=ap128bWEPKeyTable, apAPIpAddr=apAPIpAddr, apFileUpdateStatus=apFileUpdateStatus, apModemDialOut=apModemDialOut, apDialOutMode=apDialOutMode, apCurrCallTime=apCurrCallTime, rfEncrypPktsSents=rfEncrypPktsSents, apDialOutNumber=apDialOutNumber, apRFRate5_5Mb=apRFRate5_5Mb, rfSysPktsSents=rfSysPktsSents, apFaultMgmt=apFaultMgmt, apWLAPItfEntry=apWLAPItfEntry, apEPktsSeens=apEPktsSeens, apSerialnumber=apSerialnumber, muTotalAssoc=muTotalAssoc, apRFRate1Mb=apRFRate1Mb, apManufactureInfo=apManufactureInfo, muIndex=muIndex, rfSysPktsRcvds=rfSysPktsRcvds, coldStart=coldStart, rfDataOctetsSents=rfDataOctetsSents, rfDataPktsRcvds=rfDataPktsRcvds, apTrafficMatrixTable=apTrafficMatrixTable, apPacketsIns=apPacketsIns, rfRcvdCRCErrors=rfRcvdCRCErrors, apClrMUTable=apClrMUTable, apNumberOfRetries=apNumberOfRetries, apAdditionalGatewaysIPAddr=apAdditionalGatewaysIPAddr, muCurrentXmtRate=muCurrentXmtRate, apModemSpeaker=apModemSpeaker, apEthernetTimeOut=apEthernetTimeOut, apPktsOutPerSec=apPktsOutPerSec, muNPktsSents=muNPktsSents, apEPktsDiscCRCs=apEPktsDiscCRCs, apMUHmAgTable=apMUHmAgTable, etherType=etherType, apUpdateHTMLFile=apUpdateHTMLFile, muNBytesRcvds=muNBytesRcvds, apS24MobileIPEnable=apS24MobileIPEnable, rfEncrypPktsRcvds=rfEncrypPktsRcvds, apSerialPortConfig=apSerialPortConfig, apSaveConfig=apSaveConfig, apAccCtrlEntry=apAccCtrlEntry, apInactivityTimeout=apInactivityTimeout, apTypeFilterEntry=apTypeFilterEntry, apMfgDate=apMfgDate, apSNMPTraps=apSNMPTraps, apRFFirmwareRev=apRFFirmwareRev, apHoppingSet=apHoppingSet, ap802dot11Protocol=ap802dot11Protocol, apMaxMUTrigger=apMaxMUTrigger, rfTotalFragRcvds=rfTotalFragRcvds, apEncryptAdmin=apEncryptAdmin, apDefaultInterface=apDefaultInterface, apClrAddrFilterTbl=apClrAddrFilterTbl, apDnLdFileName=apDnLdFileName, apWLAPItfTable=apWLAPItfTable, apItfStatTable=apItfStatTable, apRegReplySents=apRegReplySents, apMyMacAddr=apMyMacAddr, apVendorID=apVendorID, apRFStatistics=apRFStatistics, apMUHATEntry=apMUHATEntry, apConfigMgmt=apConfigMgmt, apEMaxCollisions=apEMaxCollisions, apItfStatEntry=apItfStatEntry, muNPktsRcvds=muNPktsRcvds, apWLAPHelloTime=apWLAPHelloTime, apDSRootWLAPLostTrap=apDSRootWLAPLostTrap, apWLAPItfAddr=apWLAPItfAddr, ap128bWEPFlag=ap128bWEPFlag, apACLTrapEnable=apACLTrapEnable, rfSuccReassPkts=rfSuccReassPkts, apDSAPMUAssocTrap=apDSAPMUAssocTrap, apDSAPACLViolationTrap=apDSAPACLViolationTrap, rfDSFrequency=rfDSFrequency, symbol=symbol, apLdACLFrMUList=apLdACLFrMUList, apTrapHost1IpAdr=apTrapHost1IpAdr, apFlashLEDs=apFlashLEDs, apSNMPRequests=apSNMPRequests, typeIndex=typeIndex, apClrAllStatistics=apClrAllStatistics, muStationID=muStationID, apModemHangUp=apModemHangUp, apKnownAPsEntry=apKnownAPsEntry, apTMTableIndex=apTMTableIndex, apMUFATEntry=apMUFATEntry, apEthernetStatistics=apEthernetStatistics, apTypeFilterTable=apTypeFilterTable, apOctInPerSec=apOctInPerSec, apEBcMcPkts=apEBcMcPkts, apMobileHomeMD5Key=apMobileHomeMD5Key, apWNMPCfgPkts=apWNMPCfgPkts, apNPktsToPpps=apNPktsToPpps, apMcastMaskVoice=apMcastMaskVoice, apMyIPAddr=apMyIPAddr, apMaxRetries=apMaxRetries, rfSuccFragPkts=rfSuccFragPkts, apAccCtrlTable=apAccCtrlTable, apACLViolations=apACLViolations)
mibBuilder.exportSymbols("SYMBOL-DSSS-ENTERPRISE-PRIVATE-MIB", muTmLastData=muTmLastData, apWNMPEnable=apWNMPEnable, apMUInfo=apMUInfo, apMulticastMask=apMulticastMask, apRadioType=apRadioType, apAdditionalGatewaysEntry=apAdditionalGatewaysEntry, apNbrOfAnswers=apNbrOfAnswers, apWLAPHopSequence=apWLAPHopSequence, allowedIndex=allowedIndex, apNPktsToRfs=apNPktsToRfs, apSystemConfig=apSystemConfig, apAPFirmwareRev=apAPFirmwareRev, apUpdAllAPsFirmware=apUpdAllAPsFirmware, apSerialPortStatistics=apSerialPortStatistics, apCountryName=apCountryName, disallowedMU=disallowedMU, apResetAP=apResetAP, apEnetPortState=apEnetPortState, apRFPreamble=apRFPreamble, additionalGatewaysIndex=additionalGatewaysIndex, apHTMLFileRev=apHTMLFileRev, apROCommunityName=apROCommunityName, muLastAPAddr=muLastAPAddr, apRootInterface=apRootInterface, apDHCPChangeEnable=apDHCPChangeEnable, apModelnumber=apModelnumber, apWLAPID=apWLAPID, apRWCommunityName=apRWCommunityName, rfSBcMcPktsSents=rfSBcMcPktsSents, apTrapHost2IpAdr=apTrapHost2IpAdr, apWLAPConnChngTrapEnable=apWLAPConnChngTrapEnable, apConnectMode=apConnectMode, apTFTPServer=apTFTPServer, apAuthenFailureTrapEnable=apAuthenFailureTrapEnable, rfDSPerFqRetries=rfDSPerFqRetries, rfDataPktsSents=rfDataPktsSents, apMobileIPStatistics=apMobileIPStatistics, apRFRate2Mb=apRFRate2Mb, apFwVer=apFwVer, apWEPAlgorithm=apWEPAlgorithm, apSNMPMode=apSNMPMode, apRFConfig=apRFConfig, muHATMUIpAddr=muHATMUIpAddr, apDsgnatedItf=apDsgnatedItf, apAcceptBCESSID=apAcceptBCESSID, apSecurityMgmt=apSecurityMgmt, apCurrentMUs=apCurrentMUs, apUpdAllAPsHTMLFile=apUpdAllAPsHTMLFile, muPriority=muPriority, apAddrFilterTable=apAddrFilterTable, spectrum24=spectrum24, apOctetsIns=apOctetsIns, apHoppingSeq=apHoppingSeq, apProtoItfName=apProtoItfName, apDSAPDHCPConfigChgTrap=apDSAPDHCPConfigChgTrap, muLstAssStrt=muLstAssStrt, apRFPortState=apRFPortState, apELateCollisions=apELateCollisions, rfDSPerFqPktsSents=rfDSPerFqPktsSents, apLastCallTime=apLastCallTime, apPerformMgmt=apPerformMgmt)

#
# PySNMP MIB module HM2-TRAFFICMGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-TRAFFICMGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:32:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
hm2ConfigurationMibs, HmEnabledStatus = mibBuilder.importSymbols("HM2-TC-MIB", "hm2ConfigurationMibs", "HmEnabledStatus")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, Integer32, Bits, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, ObjectIdentity, iso, Gauge32, NotificationType, TimeTicks, IpAddress, Counter64, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Integer32", "Bits", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "ObjectIdentity", "iso", "Gauge32", "NotificationType", "TimeTicks", "IpAddress", "Counter64", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
hm2TrafficMgmtMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 31))
hm2TrafficMgmtMib.setRevisions(('2011-03-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2TrafficMgmtMib.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hm2TrafficMgmtMib.setLastUpdated('201103160000Z')
if mibBuilder.loadTexts: hm2TrafficMgmtMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2TrafficMgmtMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2TrafficMgmtMib.setDescription('Hirschmann Traffic Management MIB. Copyright (C) 2011. All Rights Reserved.')
hm2TrafficMgmtMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 31, 0))
hm2TrafficMgmtMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 31, 1))
hm2TrafficMgmtIfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1), )
if mibBuilder.loadTexts: hm2TrafficMgmtIfTable.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfTable.setDescription('A list of management objects for traffic control per interface.')
hm2TrafficMgmtIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hm2TrafficMgmtIfEntry.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfEntry.setDescription('Traffic Mgmt table entry.')
hm2TrafficMgmtIfFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 1), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfFlowControl.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfFlowControl.setDescription('Enables or disables flow control per port')
hm2TrafficMgmtIfEgressShapingRate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfEgressShapingRate.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfEgressShapingRate.setDescription('Maximum bandwidth allowed for this interface as a whole, typically used to shape the outbound transmission rate. The value is either specified in terms of percentage of overall link speed for the port in 1% increments or absolute in kbps. A value of 0 means there is no maximum bandwidth limit in effect. The default value is 0. Valid value ranges depend on the value returned by object hm2TrafficMgmtIfEgressShapingRateUnit. If that object returns percent(1), hm2TrafficMgmtIfEgressShapingRate accepts values 0..100. If that object returns kbps(2), hm2TrafficMgmtIfEgressShapingRate accepts values 0,64..4294967295.')
hm2TrafficMgmtIfEgressShapingRateUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("percent", 1), ("kbps", 2))).clone('percent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2TrafficMgmtIfEgressShapingRateUnit.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfEgressShapingRateUnit.setDescription('The unit of the interface shaping value. Can be either percentage of port speed or kilobits per second (kbps).')
hm2TrafficMgmtIfIngressStormCtlThresholdUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("percent", 1), ("pps", 2))).clone('percent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlThresholdUnit.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlThresholdUnit.setDescription('Configures the units of the threshold value(s) to percentage of port speed or absolute packets per second.')
hm2TrafficMgmtIfIngressStormCtlBcastMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 5), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlBcastMode.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlBcastMode.setDescription('If enabled, broadcast storm recovery will function on this port. When you specify Enable for Broadcast Storm Recovery and the broadcast traffic on this Ethernet port exceeds the configured threshold, the switch blocks (discards) the broadcast traffic.')
hm2TrafficMgmtIfIngressStormCtlBcastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 14880000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlBcastThreshold.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlBcastThreshold.setDescription("Configures the broadcast storm recovery threshold for this port as a percentage of port speed in 1% increments or as an absolute pps rate. This threshold is also valid for multicasts or unknown unicasts, when the device does not support a separate limiter per storm type. (A separate limiter per storm-type is supported when hm2TrafficMgmtIngressStormBucketType has the value 'multi-bucket')")
hm2TrafficMgmtIfIngressStormCtlMcastMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 7), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlMcastMode.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlMcastMode.setDescription('If enabled, multicast storm recovery will function on this port. When you specify Enable for multicast Storm Recovery and the multicast traffic on this Ethernet port exceeds the configured threshold, the switch blocks (discards) the multicast traffic.')
hm2TrafficMgmtIfIngressStormCtlMcastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 14880000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlMcastThreshold.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlMcastThreshold.setDescription('Configures the multicast storm recovery threshold for this port as a percentage of port speed in 1% increments or as an absolute pps rate.')
hm2TrafficMgmtIfIngressStormCtlUcastMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 9), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlUcastMode.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlUcastMode.setDescription('If enabled, unknown unicast storm recovery will function on this port. When you specify Enable for unicast Storm Recovery and the unknown unicast traffic on this Ethernet port exceeds the configured threshold, the switch blocks (discards) the unknown unicast traffic.')
hm2TrafficMgmtIfIngressStormCtlUcastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 14880000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlUcastThreshold.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIfIngressStormCtlUcastThreshold.setDescription('Configures the unicast storm recovery threshold for this port as a percentage of port speed in 1% increments or as an absolute pps rate.')
hm2TrafficMgmtFlowControl = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 2), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2TrafficMgmtFlowControl.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtFlowControl.setDescription('Enables or disables flow control for the switch unit.')
hm2TrafficMgmtIngressStormBucketType = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 31, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("single-bucket", 1), ("multi-bucket", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2TrafficMgmtIngressStormBucketType.setStatus('current')
if mibBuilder.loadTexts: hm2TrafficMgmtIngressStormBucketType.setDescription('Enables or disables ingress storm admin state.')
mibBuilder.exportSymbols("HM2-TRAFFICMGMT-MIB", hm2TrafficMgmtIfIngressStormCtlThresholdUnit=hm2TrafficMgmtIfIngressStormCtlThresholdUnit, hm2TrafficMgmtMib=hm2TrafficMgmtMib, hm2TrafficMgmtIngressStormBucketType=hm2TrafficMgmtIngressStormBucketType, hm2TrafficMgmtIfIngressStormCtlBcastThreshold=hm2TrafficMgmtIfIngressStormCtlBcastThreshold, hm2TrafficMgmtIfIngressStormCtlBcastMode=hm2TrafficMgmtIfIngressStormCtlBcastMode, hm2TrafficMgmtIfIngressStormCtlMcastMode=hm2TrafficMgmtIfIngressStormCtlMcastMode, hm2TrafficMgmtMibObjects=hm2TrafficMgmtMibObjects, hm2TrafficMgmtIfIngressStormCtlUcastMode=hm2TrafficMgmtIfIngressStormCtlUcastMode, hm2TrafficMgmtIfEgressShapingRateUnit=hm2TrafficMgmtIfEgressShapingRateUnit, hm2TrafficMgmtIfTable=hm2TrafficMgmtIfTable, hm2TrafficMgmtIfIngressStormCtlMcastThreshold=hm2TrafficMgmtIfIngressStormCtlMcastThreshold, PYSNMP_MODULE_ID=hm2TrafficMgmtMib, hm2TrafficMgmtFlowControl=hm2TrafficMgmtFlowControl, hm2TrafficMgmtIfEgressShapingRate=hm2TrafficMgmtIfEgressShapingRate, hm2TrafficMgmtIfIngressStormCtlUcastThreshold=hm2TrafficMgmtIfIngressStormCtlUcastThreshold, hm2TrafficMgmtMibNotifications=hm2TrafficMgmtMibNotifications, hm2TrafficMgmtIfEntry=hm2TrafficMgmtIfEntry, hm2TrafficMgmtIfFlowControl=hm2TrafficMgmtIfFlowControl)

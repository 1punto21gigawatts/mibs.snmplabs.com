#
# PySNMP MIB module PDN-BRIDGE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PDN-BRIDGE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:38:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
pdn_bridge, = mibBuilder.importSymbols("PDN-HEADER-MIB", "pdn-bridge")
VnidRange, = mibBuilder.importSymbols("PDN-TC", "VnidRange")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, TimeTicks, ObjectIdentity, MibIdentifier, Unsigned32, Bits, ModuleIdentity, IpAddress, Gauge32, Counter64, NotificationType, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "TimeTicks", "ObjectIdentity", "MibIdentifier", "Unsigned32", "Bits", "ModuleIdentity", "IpAddress", "Gauge32", "Counter64", "NotificationType", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32")
TextualConvention, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "MacAddress")
pdnBridgeGenericMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1))
pdnBridgeMIBTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 2))
pdnDot1dGenericBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 1))
pdnDot1dTpFdb = MibIdentifier((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2))
pdnDot1dTp = MibIdentifier((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 3))
pdnDot1dBaseBridgeAddress = MibScalar((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dBaseBridgeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dBaseBridgeAddress.setDescription('The MAC address used by this bridge when it must be referred to in a unique fashion. It is recommended that this be the numerically smallest MAC address of all ports that belong to this bridge. However it is only required to be unique.')
pdnDot1dBaseNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dBaseNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dBaseNumPorts.setDescription('The number of ports controlled by this bridging entity.')
pdnDot1dBaseType = MibScalar((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("transparent-only", 2), ("sourceroute-only", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dBaseType.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dBaseType.setDescription('Indicates what type of bridging this bridge can perform.')
pdnDot1dTpLearnedEntryDiscards = MibScalar((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpLearnedEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpLearnedEntryDiscards.setDescription('The total number of Forwarding Database entries, which have been or would have been learned, but have been discarded due to a lack of space to store them in the Forwarding Database. If this counter is increasing, it indicates that the Forwarding Database is regularly becoming full (a condition which has unpleasant performance effects on the subnetwork). If this counter has a significant value but is not presently increasing, it indicates that the problem has been occurring but is not persistent.')
pdnDot1dTpAgeingTime = MibScalar((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pdnDot1dTpAgeingTime.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpAgeingTime.setDescription('The timeout period in seconds for aging out dynamically learned forwarding information. 802.1D-1990 recommends a default of 300 seconds.')
pdnDot1dTpAgeingCleanupTime = MibScalar((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 500000)).clone(150)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pdnDot1dTpAgeingCleanupTime.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpAgeingCleanupTime.setDescription(' pdnDot1dTpEntryAgeingCleanupupTime is the length of time before an entry is removed from the bridge . This parameter is typically set to one-half of the bridge Ageing time.')
pdnDot1dTpFdbTable = MibTable((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2, 1), )
if mibBuilder.loadTexts: pdnDot1dTpFdbTable.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpFdbTable.setDescription('A table that contains information about unicast entries for which the bridge has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame.')
pdnDot1dTpFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2, 1, 1), ).setIndexNames((0, "PDN-BRIDGE-MIB", "pdnDot1dTpFdbAddress"), (0, "PDN-BRIDGE-MIB", "pdnDot1dTpFdbVnidId"))
if mibBuilder.loadTexts: pdnDot1dTpFdbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpFdbEntry.setDescription('Information about a specific unicast MAC address for which the bridge has some forwarding and/or filtering information.')
pdnDot1dTpFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpFdbAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpFdbAddress.setDescription('A unicast MAC address for which the bridge has forwarding and/or filtering information.')
pdnDot1dTpFdbVnidId = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2, 1, 1, 2), VnidRange()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpFdbVnidId.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpFdbVnidId.setDescription('The VNID Id number of the virtual network for which the bridge has forwarding and/or filtering information.')
pdnDot1dTpFdbIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpFdbIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpFdbIfIndex.setDescription('The ifIndex of the interface associated with the mac address and vlan-id.')
pdnDot1dTpFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpFdbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpFdbStatus.setDescription("The status of this entry. The meanings of the values are: other(1) : none of the following. This would include the case where some other MIB object (not the corresponding instance of pdnDot1dTpFdbPort, nor an entry in the pdnDot1dStaticTable) in being used to determine if and how frames addressed to the value of the corresponding instance of pdnDot1dTpFdbAddress are being forwarded. invalid(2) : this entry is not longer valid (e.g., it was learned but has since aged-out), but has not yet been flushed from the table. learned(3) : the value of the corresponding instance of pdnDot1dTpFdbPort was learned, and is being used. self(4) : the value of the corresponding instance of pdnDot1dTpFdbAddress represents one of the bridge's addresses. The corresponding instance of pdnDot1dTpFdbPort indicates which of the bridge's ports has this address. mgmt(5) : the value of the corresponding instance of pdnDot1dTpFdbAddress is also the value of an existing instance of pdnDot1dStaticAddress.")
pdnDot1dTpFdbAgeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpFdbAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpFdbAgeTime.setDescription('The amount of time in seconds that this entry is in the Bridge table')
pdnDot1dTpFdbFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("permanentDHCP", 2), ("permanentCONFIGURED", 3), ("dynamic", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpFdbFlags.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpFdbFlags.setDescription('This object indicates the type of entry in the Bridge table. permanentDHCP -- Entry added due to DHCP client permanentCONFIGURED -- Entry added by User dynamic -- Dynamic Entry ')
pdnDot1dTpPortTable = MibTable((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 3, 1), )
if mibBuilder.loadTexts: pdnDot1dTpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpPortTable.setDescription('A table that contains information about every port that is associated with this transparent bridge.')
pdnDot1dTpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pdnDot1dTpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpPortEntry.setDescription('A list of information for each port of a transparent bridge.')
pdnDot1dTpPortMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpPortMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpPortMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
pdnDot1dTpPortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpPortInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpPortInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function, including bridge management frames.')
pdnDot1dTpPortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpPortOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpPortOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function, including bridge management frames.')
pdnDot1dTpPortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1795, 2, 24, 2, 21, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pdnDot1dTpPortInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: pdnDot1dTpPortInDiscards.setDescription('Count of frames received which were discarded (i.e., filtered) by the Forwarding Process.')
mibBuilder.exportSymbols("PDN-BRIDGE-MIB", pdnDot1dTpAgeingCleanupTime=pdnDot1dTpAgeingCleanupTime, pdnDot1dTpFdbAddress=pdnDot1dTpFdbAddress, pdnDot1dTp=pdnDot1dTp, pdnDot1dBaseNumPorts=pdnDot1dBaseNumPorts, pdnDot1dTpFdbEntry=pdnDot1dTpFdbEntry, pdnDot1dTpFdbVnidId=pdnDot1dTpFdbVnidId, pdnDot1dTpFdbTable=pdnDot1dTpFdbTable, pdnDot1dTpFdbStatus=pdnDot1dTpFdbStatus, pdnDot1dTpPortMaxInfo=pdnDot1dTpPortMaxInfo, pdnDot1dTpFdbFlags=pdnDot1dTpFdbFlags, pdnDot1dGenericBridge=pdnDot1dGenericBridge, pdnDot1dTpLearnedEntryDiscards=pdnDot1dTpLearnedEntryDiscards, pdnDot1dTpAgeingTime=pdnDot1dTpAgeingTime, pdnDot1dTpPortInDiscards=pdnDot1dTpPortInDiscards, pdnDot1dBaseType=pdnDot1dBaseType, pdnDot1dTpFdb=pdnDot1dTpFdb, pdnDot1dBaseBridgeAddress=pdnDot1dBaseBridgeAddress, pdnDot1dTpFdbIfIndex=pdnDot1dTpFdbIfIndex, pdnDot1dTpPortTable=pdnDot1dTpPortTable, pdnDot1dTpPortOutFrames=pdnDot1dTpPortOutFrames, pdnDot1dTpPortInFrames=pdnDot1dTpPortInFrames, pdnBridgeMIBTraps=pdnBridgeMIBTraps, pdnDot1dTpFdbAgeTime=pdnDot1dTpFdbAgeTime, pdnBridgeGenericMIBObjects=pdnBridgeGenericMIBObjects, pdnDot1dTpPortEntry=pdnDot1dTpPortEntry)

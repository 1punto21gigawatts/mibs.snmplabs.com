#
# PySNMP MIB module Nortel-Magellan-Passport-ShelfMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-ShelfMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:27:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
Integer32, Unsigned32, StorageType, RowPointer, RowStatus, DisplayString, Gauge32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "Integer32", "Unsigned32", "StorageType", "RowPointer", "RowStatus", "DisplayString", "Gauge32")
ExtendedAsciiString, AsciiString, Link, Hex, NonReplicated = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "ExtendedAsciiString", "AsciiString", "Link", "Hex", "NonReplicated")
passportMIBs, components = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs", "components")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Counter32, Integer32, Counter64, ModuleIdentity, ObjectIdentity, Unsigned32, IpAddress, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Bits, Gauge32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter32", "Integer32", "Counter64", "ModuleIdentity", "ObjectIdentity", "Unsigned32", "IpAddress", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Bits", "Gauge32", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
shelfMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12))
shelf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13))
shelfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 1), )
if mibBuilder.loadTexts: shelfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfRowStatusTable.setDescription('This entry controls the addition and deletion of shelf components.')
shelfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"))
if mibBuilder.loadTexts: shelfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfRowStatusEntry.setDescription('A single entry in the table represents a single shelf component.')
shelfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelf components. These components cannot be added nor deleted.')
shelfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfStorageType.setDescription('This variable represents the storage type value for the shelf tables.')
shelfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: shelfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfIndex.setDescription('This variable represents the index for the shelf tables.')
shelfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 10), )
if mibBuilder.loadTexts: shelfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfProvTable.setDescription('This group contains the provisionable attributes for the Shelf component.')
shelfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"))
if mibBuilder.loadTexts: shelfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfProvEntry.setDescription('An entry in the shelfProvTable.')
shelfCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCommentText.setDescription('This is an arbitrary string that can be used to specify the location of the module. It is not used by the system.')
shelfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 11), )
if mibBuilder.loadTexts: shelfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfOperTable.setDescription('This group contains the operational attributes for the Shelf component.')
shelfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"))
if mibBuilder.loadTexts: shelfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfOperEntry.setDescription('An entry in the shelfOperTable.')
shelfBusOperatingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noBus", 0), ("singleBusX", 1), ("singleBusY", 2), ("dualBus", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusOperatingMode.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusOperatingMode.setDescription('This attribute indicates the current backplane bus operating mode: noBus No bus is in service now. singleBusX The shelf is running on bus X only. singleBusY The shelf is running on bus Y only. dualBus The shelf is running on bus X and bus Y.')
shelfHardwareFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 11, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfHardwareFailures.setStatus('mandatory')
if mibBuilder.loadTexts: shelfHardwareFailures.setDescription("The hardware's fault detection system can report four kinds of component failures: card, power converter, cooling unit or terminator card failures. This attribute is a set that specifies which type of components have failed. Description of bits: card(0) powerConverter(1) coolingUnit(2) terminatorCard(3)")
shelfNumberOfSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfNumberOfSlots.setStatus('mandatory')
if mibBuilder.loadTexts: shelfNumberOfSlots.setDescription('This attribute specifies the number of slots for this shelf.')
shelfCard = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2))
shelfCardRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 1), )
if mibBuilder.loadTexts: shelfCardRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardRowStatusTable.setDescription('This entry controls the addition and deletion of shelfCard components.')
shelfCardRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"))
if mibBuilder.loadTexts: shelfCardRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardRowStatusEntry.setDescription('A single entry in the table represents a single shelfCard component.')
shelfCardRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCard components. These components can be added.')
shelfCardComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardStorageType.setDescription('This variable represents the storage type value for the shelfCard tables.')
shelfCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardIndex.setDescription('This variable represents the index for the shelfCard tables.')
shelfCardProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 10), )
if mibBuilder.loadTexts: shelfCardProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardProvTable.setDescription('This group contains the provisionable attributes for the Card component.')
shelfCardProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"))
if mibBuilder.loadTexts: shelfCardProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardProvEntry.setDescription('An entry in the shelfCardProvTable.')
shelfCardCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 82))).clone(namedValues=NamedValues(("cP", 0), ("v11", 1), ("v35", 2), ("dS1", 3), ("dS1V", 4), ("dS3", 5), ("e1", 6), ("e1V", 7), ("e3", 8), ("none", 9), ("n1pFddiMultiMode", 10), ("n4pTokenRing", 11), ("n6pEth10BaseT", 12), ("dS1C", 13), ("e1C", 14), ("n3pE3Atm", 15), ("n3pDS3Atm", 16), ("n3pOC3MmAtm", 17), ("n3pOC3SmAtm", 19), ("n3pE1Atm", 20), ("n3pDS1Atm", 21), ("j2MV", 22), ("n4pEthAui", 23), ("n1pFddiSingleMode", 24), ("n1pDS1V", 25), ("n1pE1V", 26), ("n2pJ6MAtm", 27), ("hSSI", 33), ("n8pDS1", 34), ("cFP1", 35), ("dEV1", 36), ("cFP2", 37), ("dEV2", 38), ("n4pDS1Aal1", 39), ("n4pE1Aal1", 40), ("n1pDS3C", 41), ("ilsForwarder", 42), ("n8pDS1Atm", 43), ("n8pE1Atm", 44), ("n1pE1Mvp", 45), ("n1pDS1Mvp", 46), ("n1pTTC2mMvp", 47), ("n1pDS3cAal", 51), ("n2pDS3cAal", 52), ("n12mVspAal", 53), ("n2pEth100BaseT", 54), ("n2pOC3MmAtm2", 55), ("n2pOC3SmAtm2", 56), ("n3pDS3Atm2", 57), ("n3pE3Atm2", 58), ("cPeD", 59), ("cPeE", 60), ("n4pOC3SmIrAtm", 61), ("n4pOC3MmAtm", 62), ("n12pDS3Atm", 63), ("n12pE3Atm", 64), ("n1pOC12SmLrAtm", 65), ("n1pE1Mvpe", 66), ("n1pDS1Mvpe", 67), ("n1pTTC2mMvpe", 68), ("msa32", 69), ("msa32mt", 70), ("msa32mtp", 71), ("msa32st", 72), ("msa32stp", 73), ("n32pE1Aal", 74), ("n12mPcusp", 82))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardCardType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCardType.setDescription('This is the type of card expected in this slot. Specifying a card type here has the effect of configuring a card to run in this slot. A value of none means that no card is configured to run in this slot.')
shelfCardSparingConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 16))).clone(namedValues=NamedValues(("notApplicable", 0), ("mainA", 1), ("mainB", 2), ("mainC", 3), ("mainD", 4), ("spare", 16))).clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardSparingConnection.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardSparingConnection.setDescription('This attribute contains the identification of the 1 for N sparing panel group of connectors to which the card is connected. This identification should coincide with the label located on the sparing panel.')
shelfCardCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 10, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 80)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCommentText.setDescription('This is an arbitrary string that can be used to specify the location of the sparing panel.')
shelfCardStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11), )
if mibBuilder.loadTexts: shelfCardStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
shelfCardStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"))
if mibBuilder.loadTexts: shelfCardStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardStateEntry.setDescription('An entry in the shelfCardStateTable.')
shelfCardAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfCardOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfCardUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfCardAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
shelfCardProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
shelfCardControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
shelfCardAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
shelfCardStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
shelfCardUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
shelfCardOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 12), )
if mibBuilder.loadTexts: shelfCardOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardOperTable.setDescription('This group contains the operational attributes that reflect the current status of the card.')
shelfCardOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"))
if mibBuilder.loadTexts: shelfCardOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardOperEntry.setDescription('An entry in the shelfCardOperTable.')
shelfCardCurrentLP = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 12, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardCurrentLP.setStatus('obsolete')
if mibBuilder.loadTexts: shelfCardCurrentLP.setDescription('This is the component name of the LP currently running on this card.')
shelfCardFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 0), ("wrongCardType", 1), ("notConfigured", 2), ("cannotLoadSoftware", 3), ("failedSelfTests", 4), ("notResponding", 5), ("busConnectivityProblem", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardFailureCause.setDescription('This attribute specifies why the card has failed. This attribute is meaningful when the OSI AvailabilityStatus attribute is set to failed.')
shelfCardSelfTestFault = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("none", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardSelfTestFault.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardSelfTestFault.setDescription("This attribute indicates the result of the processor card's self-tests that were performed when it initially came up.")
shelfCardSparingConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 0), ("n1for1Ok", 1), ("n1forNOk", 2), ("unconfirmed", 3), ("notConnected", 4), ("incorrectlyConnected", 5), ("inconsistentlyConnected", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardSparingConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardSparingConnectionStatus.setDescription('This attribute indicates if the control signal received from a 1forN sparing panel or a 1for1 sparing panel is properly terminated. notApplicable - The card is not provisioned as part of a sparing configuration, and is not connected to any sparing panel. 1for1Ok -The card is provisioned correctly for 1for1 sparing and is connected to the active relay of a 1for1 sparing panel. 1forNOk -The card is provisioned correctly for either 1for1 or 1forN sparing and is connected to either the standby or active relay of a 1forN sparing panel. unconfirmed -The card is provisioned as part of a sparing configuration, but its connection status cannot be determined. To determine if the card is connected to a sparing panel, perform a switchover of the LP to see if the card will grab a relay when it is active. If the card has grabbed the relay, the sparing connection status should change from, unconfirmed, to 1for1Ok and the LED on the sparing panel corresponfing to that relay should be illuminated. Please note: Performing the switchover will disrupt traffic on the other card and this test should be conducted when no traffic is running on the active card. notConnected - The card is provisioned as part of a sparing configuration, but is not connected to a sparing panel. Remedial Action: Check the cable connectivity between the card and the sparing panel. incorrectlyConnected - The card is provisioned as part of a sparing configuration, but is connected to the wrong port on a 1forN panel, or is connected to a 1for1 sparing panel while configured for 1forN. Remedial Action: Connect the cable to the port that was specified by the sparingConnection attribute. inconsistentlyConnected - The card is provisioned as part of a 1forN sparing configuration, but is connected to a sparing panel which is not the same as the other cards sharing the same spare card. Remedial Action: Ensure all cards that share the same spare card are connected to the same sparing panel. This value is also used to indicate that two sparing panels with the same sparing panel IDs are being used by cards on the same shelf. Remedial Action: Replace one of the sparing panels with another panel that has a different sparing panel ID. Sparing panel IDs are assigned at the time of manufacture and cannot be changed by the user.')
shelfCardPropTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13), )
if mibBuilder.loadTexts: shelfCardPropTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardPropTable.setDescription('This group contains the operational attributes that specify the fixed characteristics of the card.')
shelfCardPropEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"))
if mibBuilder.loadTexts: shelfCardPropEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardPropEntry.setDescription('An entry in the shelfCardPropTable.')
shelfCardInsertedCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 82))).clone(namedValues=NamedValues(("cP", 0), ("v11", 1), ("v35", 2), ("dS1", 3), ("dS1V", 4), ("dS3", 5), ("e1", 6), ("e1V", 7), ("e3", 8), ("none", 9), ("n1pFddiMultiMode", 10), ("n4pTokenRing", 11), ("n6pEth10BaseT", 12), ("dS1C", 13), ("e1C", 14), ("n3pE3Atm", 15), ("n3pDS3Atm", 16), ("n3pOC3MmAtm", 17), ("n1pOC3MmAtm", 18), ("n3pOC3SmAtm", 19), ("n3pE1Atm", 20), ("n3pDS1Atm", 21), ("j2MV", 22), ("n4pEthAui", 23), ("n1pFddiSingleMode", 24), ("n1pDS1V", 25), ("n1pE1V", 26), ("n2pJ6MAtm", 27), ("hSSI", 33), ("n8pDS1", 34), ("cFP1", 35), ("dEV1", 36), ("cFP2", 37), ("dEV2", 38), ("n4pDS1Aal1", 39), ("n4pE1Aal1", 40), ("n1pDS3C", 41), ("ilsForwarder", 42), ("n8pDS1Atm", 43), ("n8pE1Atm", 44), ("n1pE1Mvp", 45), ("n1pDS1Mvp", 46), ("n1pTTC2mMvp", 47), ("n1pDS3cAal", 51), ("n2pDS3cAal", 52), ("n12mVspAal", 53), ("n2pEth100BaseT", 54), ("n2pOC3MmAtm2", 55), ("n2pOC3SmAtm2", 56), ("n3pDS3Atm2", 57), ("n3pE3Atm2", 58), ("cPeD", 59), ("cPeE", 60), ("n4pOC3SmIrAtm", 61), ("n4pOC3MmAtm", 62), ("n12pDS3Atm", 63), ("n12pE3Atm", 64), ("n1pOC12SmLrAtm", 65), ("n1pE1Mvpe", 66), ("n1pDS1Mvpe", 67), ("n1pTTC2mMvpe", 68), ("msa32", 69), ("msa32mt", 70), ("msa32mtp", 71), ("msa32st", 72), ("msa32stp", 73), ("n32pE1Aal", 74), ("n12mPcusp", 82)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardInsertedCardType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardInsertedCardType.setDescription('This attribute indicates the type of card that is currently inserted in this slot.')
shelfCardPmRevisionCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardPmRevisionCode.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardPmRevisionCode.setDescription('This attribute indicates the hardware revision level of the Processor Module (PM).')
shelfCardImRevisionCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardImRevisionCode.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardImRevisionCode.setDescription('This attribute indicates the hardware revision level of the Interface Module (IM).')
shelfCardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardSerialNumber.setDescription("This attribute indicates the processor card's serial number.")
shelfCardActiveFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardActiveFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardActiveFirmwareVersion.setDescription('This attribute indicates the firmware version of the currently active flash memory bank.')
shelfCardInactiveFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13, 1, 6), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardInactiveFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardInactiveFirmwareVersion.setDescription('This attribute indicates the firmware version of the currently inactive flash memory bank.')
shelfCardProductCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 13, 1, 7), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardProductCode.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardProductCode.setDescription('This attribute indicates the product ordering code and release of the card.')
shelfCardUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14), )
if mibBuilder.loadTexts: shelfCardUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardUtilTable.setDescription("This group contains the operational attributes that specify the processor's utilization levels. When this group exists for an LP component, the attributes are representative of the active card.")
shelfCardUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"))
if mibBuilder.loadTexts: shelfCardUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardUtilEntry.setDescription('An entry in the shelfCardUtilTable.')
shelfCardTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTimeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTimeInterval.setDescription('This attribute indicates the time period (in minutes) for which the average, minimum and maximum utilization values are calculated. This attribute is reset to 0 every 15 minutes.')
shelfCardCpuUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardCpuUtil.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCpuUtil.setDescription('This attribute indicates an approximation of the current processor utilization level (expressed as a percentage).')
shelfCardCpuUtilAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardCpuUtilAvg.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCpuUtilAvg.setDescription('This attribute indicates an average processor utilization level over the specified time period, timeInterval. This average is calculated based on one minute CPU utilization averages.')
shelfCardCpuUtilAvgMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardCpuUtilAvgMin.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCpuUtilAvgMin.setDescription('This attribute indicates the minimum processor utilization level over a specified time period, timeInterval. This is based on one minute CPU utilization averages.')
shelfCardCpuUtilAvgMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardCpuUtilAvgMax.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCpuUtilAvgMax.setDescription('This attribute indicates the maximum processor utilization level over a specified time period, timeInterval. This is based on one minute CPU utilization averages.')
shelfCardMsgBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMsgBlockUsage.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMsgBlockUsage.setDescription("This attribute indicates the processor's current shared message block memory utilization (in kilobytes). If there is no shared memory on the card, this attribute indicates 0.")
shelfCardMsgBlockUsageAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMsgBlockUsageAvg.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMsgBlockUsageAvg.setDescription("This attribute indicates the processor's average memory utilization (in kilobytes) of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this average memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
shelfCardMsgBlockUsageAvgMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMsgBlockUsageAvgMin.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMsgBlockUsageAvgMin.setDescription("This attribute indicates the processor's minimum memory utilization (in kilobytes) of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this minimum memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
shelfCardMsgBlockUsageAvgMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMsgBlockUsageAvgMax.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMsgBlockUsageAvgMax.setDescription("This attribute indicates the processor's maximum memory utilization (in kilobytes) of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this maximum memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
shelfCardLocalMsgBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardLocalMsgBlockUsage.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardLocalMsgBlockUsage.setDescription("This attribute indicates the processor's current memory utilization (in kilobytes) of message blocks which are used for local messaging on the card.")
shelfCardLocalMsgBlockUsageAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardLocalMsgBlockUsageAvg.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardLocalMsgBlockUsageAvg.setDescription("This attribute indicates the processor's average memory utilization (in kilobytes) of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this average memory utilization is reset to the current usage, localMsgBlockUsage.")
shelfCardLocalMsgBlockUsageMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardLocalMsgBlockUsageMin.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardLocalMsgBlockUsageMin.setDescription("This attribute indicates the processor's minimum memory utilization (in kilobytes) of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is updated at 15 second intervals. At the start of each timeInterval, this minimum memory utilization is reset to the current usage, localMsgBlockUsage.")
shelfCardLocalMsgBlockUsageMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 14, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardLocalMsgBlockUsageMax.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardLocalMsgBlockUsageMax.setDescription("This attribute indicates the processor's maximum memory utilization (in kilobytes) of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is updated at 15 second intervals. At the start of each timeInterval, this maximum memory utilization is reset to the current usage, localMsgBlockUsage.")
shelfCardCapTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 15), )
if mibBuilder.loadTexts: shelfCardCapTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCapTable.setDescription("This group contains the operational attributes that specify the processor's capacity levels. When this group exists for an LP component, the attributes are representative of the active Card.")
shelfCardCapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"))
if mibBuilder.loadTexts: shelfCardCapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCapEntry.setDescription('An entry in the shelfCardCapTable.')
shelfCardMsgBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMsgBlockCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMsgBlockCapacity.setDescription("This attribute indicates the processor card's shared message block memory capacity (in kilobytes).")
shelfCardLocalMsgBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 15, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardLocalMsgBlockCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardLocalMsgBlockCapacity.setDescription("This attribute indicates the processor card's local message block memory capacity (in kilobytes). These message blocks are used for local messaging on the card.")
shelfCardConfiguredLPsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 243), )
if mibBuilder.loadTexts: shelfCardConfiguredLPsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardConfiguredLPsTable.setDescription("This is a read-only attribute that shows which LPs are currently configured to run on this card (it is the opposite side of the LP component's mainCard and spareCard link attributes). Note that there is only one case where more than one LP can be configured to run on a card. This is when the card is configured as an N+1 spare. If this is not the case, the card is configured as a main card or as a 1for1 spare, only one LP can appear in this list.")
shelfCardConfiguredLPsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 243, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardConfiguredLPsValue"))
if mibBuilder.loadTexts: shelfCardConfiguredLPsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardConfiguredLPsEntry.setDescription('An entry in the shelfCardConfiguredLPsTable.')
shelfCardConfiguredLPsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 243, 1, 1), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardConfiguredLPsValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardConfiguredLPsValue.setDescription('This variable represents both the value and the index for the shelfCardConfiguredLPsTable.')
shelfCardMemoryCapacityTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 244), )
if mibBuilder.loadTexts: shelfCardMemoryCapacityTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryCapacityTable.setDescription("This attribute indicates the processor card's memory capacity (in kilobytes) for each type of memory.")
shelfCardMemoryCapacityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 244, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardMemoryCapacityIndex"))
if mibBuilder.loadTexts: shelfCardMemoryCapacityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryCapacityEntry.setDescription('An entry in the shelfCardMemoryCapacityTable.')
shelfCardMemoryCapacityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 244, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: shelfCardMemoryCapacityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryCapacityIndex.setDescription('This variable represents the shelfCardMemoryCapacityTable specific index for the shelfCardMemoryCapacityTable.')
shelfCardMemoryCapacityValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 244, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMemoryCapacityValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryCapacityValue.setDescription('This variable represents an individual value for the shelfCardMemoryCapacityTable.')
shelfCardMemoryUsageTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 245), )
if mibBuilder.loadTexts: shelfCardMemoryUsageTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageTable.setDescription("This attribute indicates the processor's current memory utilization (in kilobytes) for each type of memory.")
shelfCardMemoryUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 245, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardMemoryUsageIndex"))
if mibBuilder.loadTexts: shelfCardMemoryUsageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageEntry.setDescription('An entry in the shelfCardMemoryUsageTable.')
shelfCardMemoryUsageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 245, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: shelfCardMemoryUsageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageIndex.setDescription('This variable represents the shelfCardMemoryUsageTable specific index for the shelfCardMemoryUsageTable.')
shelfCardMemoryUsageValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 245, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMemoryUsageValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageValue.setDescription('This variable represents an individual value for the shelfCardMemoryUsageTable.')
shelfCardMemoryUsageAvgTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 276), )
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgTable.setDescription("This attribute indicates the processor's average memory utilization (in kilobytes) for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
shelfCardMemoryUsageAvgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 276, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardMemoryUsageAvgIndex"))
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgEntry.setDescription('An entry in the shelfCardMemoryUsageAvgTable.')
shelfCardMemoryUsageAvgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 276, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgIndex.setDescription('This variable represents the shelfCardMemoryUsageAvgTable specific index for the shelfCardMemoryUsageAvgTable.')
shelfCardMemoryUsageAvgValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 276, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgValue.setDescription('This variable represents an individual value for the shelfCardMemoryUsageAvgTable.')
shelfCardMemoryUsageAvgMinTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 277), )
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMinTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMinTable.setDescription("This attribute indicates the processor's minimum memory utilization (in kilobytes) for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
shelfCardMemoryUsageAvgMinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 277, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardMemoryUsageAvgMinIndex"))
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMinEntry.setDescription('An entry in the shelfCardMemoryUsageAvgMinTable.')
shelfCardMemoryUsageAvgMinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 277, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMinIndex.setDescription('This variable represents the shelfCardMemoryUsageAvgMinTable specific index for the shelfCardMemoryUsageAvgMinTable.')
shelfCardMemoryUsageAvgMinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 277, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMinValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMinValue.setDescription('This variable represents an individual value for the shelfCardMemoryUsageAvgMinTable.')
shelfCardMemoryUsageAvgMaxTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 278), )
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMaxTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMaxTable.setDescription("This attribute indicates the processor's maximum memory utilization (in kilobytes) for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
shelfCardMemoryUsageAvgMaxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 278, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardMemoryUsageAvgMaxIndex"))
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMaxEntry.setDescription('An entry in the shelfCardMemoryUsageAvgMaxTable.')
shelfCardMemoryUsageAvgMaxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 278, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMaxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMaxIndex.setDescription('This variable represents the shelfCardMemoryUsageAvgMaxTable specific index for the shelfCardMemoryUsageAvgMaxTable.')
shelfCardMemoryUsageAvgMaxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 278, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMaxValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardMemoryUsageAvgMaxValue.setDescription('This variable represents an individual value for the shelfCardMemoryUsageAvgMaxTable.')
shelfCardCurrentLpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 406), )
if mibBuilder.loadTexts: shelfCardCurrentLpTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCurrentLpTable.setDescription('This attribute indicates which LPs are currently associated with this card. A card configured as a 1forN spare may be associated with more than one LP.')
shelfCardCurrentLpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 406, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardCurrentLpValue"))
if mibBuilder.loadTexts: shelfCardCurrentLpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCurrentLpEntry.setDescription('An entry in the shelfCardCurrentLpTable.')
shelfCardCurrentLpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 406, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardCurrentLpValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardCurrentLpValue.setDescription('This variable represents both the value and the index for the shelfCardCurrentLpTable.')
shelfCardBusTap = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2))
shelfCardBusTapRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 1), )
if mibBuilder.loadTexts: shelfCardBusTapRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapRowStatusTable.setDescription('This entry controls the addition and deletion of shelfCardBusTap components.')
shelfCardBusTapRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardBusTapIndex"))
if mibBuilder.loadTexts: shelfCardBusTapRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapRowStatusEntry.setDescription('A single entry in the table represents a single shelfCardBusTap component.')
shelfCardBusTapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCardBusTap components. These components cannot be added nor deleted.')
shelfCardBusTapComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardBusTapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapStorageType.setDescription('This variable represents the storage type value for the shelfCardBusTap tables.')
shelfCardBusTapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x", 0), ("y", 1))))
if mibBuilder.loadTexts: shelfCardBusTapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapIndex.setDescription('This variable represents the index for the shelfCardBusTap tables.')
shelfCardBusTapStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10), )
if mibBuilder.loadTexts: shelfCardBusTapStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
shelfCardBusTapStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardBusTapIndex"))
if mibBuilder.loadTexts: shelfCardBusTapStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapStateEntry.setDescription('An entry in the shelfCardBusTapStateTable.')
shelfCardBusTapAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfCardBusTapOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfCardBusTapUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfCardBusTapAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
shelfCardBusTapProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
shelfCardBusTapControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
shelfCardBusTapAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
shelfCardBusTapStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
shelfCardBusTapUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
shelfCardBusTapOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 11), )
if mibBuilder.loadTexts: shelfCardBusTapOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapOperTable.setDescription('This attribute group contains operational attributes of a bus tap. This information outlines what the bus tap is doing and why it is doing it, and is primarily intended for use in diagnosing the cause of a bus- related problem reported by the module.')
shelfCardBusTapOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardBusTapIndex"))
if mibBuilder.loadTexts: shelfCardBusTapOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapOperEntry.setDescription('An entry in the shelfCardBusTapOperTable.')
shelfCardBusTapFailuresInEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 11, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapFailuresInEffect.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapFailuresInEffect.setDescription('This attribute records the hardware problems that prevent the bus tap from using the associated bus. It may contain any combination of the following values. selfTest: the bus tap has failed its self-test clockSignal: the bus tap is not receiving clock signals from the bus parityError: the bus tap has detected too many parity errors on the bus Description of bits: selfTest(0) clockSignal(1) parityError(2)')
shelfCardBusTapDependenciesInEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 11, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapDependenciesInEffect.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapDependenciesInEffect.setDescription('This attribute records the non-hardware problems that prevent the bus tap from using the associated bus. It may contain any combination of the following values. busLocked: the bus is locked busDisabled: the bus is disabled Description of bits: busLocked(0) busDisabled(1)')
shelfCardBusTapCardsAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 11, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapCardsAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapCardsAvailable.setDescription("This attribute records the slot numbers of the cards that the bus tap considers available on the busthat is, the cards that have an operational bus tap connected to the bus. The value of this attribute is determined automatically by the bus tap by monitoring signals generated by each bus tap on the bus; it cannot be changed by the operator. Normally, every card in the module signals its availability on both buses; if a card does not signal its availability on a bus this indicates that the card is not present or that its bus tap has failed. By examining this attribute for both of a card's BusTap components, it is possible to determine which cards are present in the module and which buses each can use. Note: If failuresInEffect contains either selfTest or clockSignal the bus tap is unable to monitor the availability of the bus taps on the bus; cardsAvailable will indicate that no bus taps are available on the bus. Description of bits: n0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15)")
shelfCardBusTapCardsTxTo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapCardsTxTo.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapCardsTxTo.setDescription("This attribute records the slot numbers of the cards which the bus tap is currently configured to transmit cells to. This configuration is managed automatically, and cannot be changed by the operator. By examining this attribute for both of a card's BusTap components, it is possible to determine which bus (if any) the card uses when it needs to transmits cells to a specific card in the module. Description of bits: n0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15)")
shelfCardBusTapErrorsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12), )
if mibBuilder.loadTexts: shelfCardBusTapErrorsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapErrorsTable.setDescription('This attribute group records errors that the bus tap has detected since the card was last rebooted. This information is intended for use in detecting and diagnosing bus-related problems within a module.')
shelfCardBusTapErrorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardBusTapIndex"))
if mibBuilder.loadTexts: shelfCardBusTapErrorsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapErrorsEntry.setDescription('An entry in the shelfCardBusTapErrorsTable.')
shelfCardBusTapSelfTestErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapSelfTestErrorCode.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapSelfTestErrorCode.setDescription('This attribute records the error code generated by the most recent self-test of the bus tap. The value zero indicates that the self-test was successful. A non-zero value indicates that the self-test failed, and is used by the service technician when a defective card is returned for repair.')
shelfCardBusTapClockErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapClockErrors.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapClockErrors.setDescription("This attribute records the number of times that the bus tap has detected a loss of the fundamental clock signal used by the bus. Each occurrence may result in the loss of one or more cells or frames. This type of event may occur during normal operation of the module, for example when switching from one of the bus's clock sources to the other; it may also be caused by a hardware fault. The attribute's value wraps around to zero when it exceeds the maximum permitted value.")
shelfCardBusTapEndOfCellErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapEndOfCellErrors.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapEndOfCellErrors.setDescription("This attribute records the number of times that the bus tap has detected a loss of the end-of-cell timing signal used by the bus. Each occurrence may result in the loss of one or more cells or frames. This type of event may occur during normal operation of the module, for example switching the bus's clock source from one card to another; it may also be caused by a hardware fault. The attribute's value wraps around to zero when it exceeds the maximum permitted value.")
shelfCardBusTapParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapParityErrors.setDescription("This attribute records the number of times that the bus tap has detected a cell with invalid parity on the bus. Each occurrence may result in the loss of one or more cells or frames. This type of event may occur during normal operation of the module, for example when a card is inserted, removed, or reboots; it may also be caused by a hardware fault. The attribute's value wraps around to zero when it exceeds the maximum permitted value.")
shelfCardBusTapFrmCongestionErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapFrmCongestionErrors.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapFrmCongestionErrors.setDescription("This attribute records the number of times that the bus tap was unable to receive a frame from the bus because all of its bus receive channels were in use. Each occurrence results in the loss of the frame. This type of event may occur during normal operation of the module, for example when the module is operating in single bus mode; it may also be caused by a hardware fault. The attribute's value wraps around to zero when it exceeds the maximum permitted value.")
shelfCardBusTapFrmCollisionErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapFrmCollisionErrors.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapFrmCollisionErrors.setDescription("This attribute records the number of times that the bus tap was unable to receive a frame from the bus because it did not receive the last cell of the frame before the first cell of the following frame from the same source. Each occurrence results in the loss of both frames. This type of event may occur during normal operation of the module, for example when a card reboots; it may also be caused by a hardware fault. The attribute's value wraps around to zero when it exceeds the maximum permitted value.")
shelfCardBusTapFrmTimeoutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapFrmTimeoutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapFrmTimeoutErrors.setDescription("This attribute records the number of times that the bus tap was unable to receive a frame from the bus because the delay between two successive cells in that frame exceeded the maximum allowable duration. Each occurrence results in the loss of the frame. This type of event may occur during normal operation of the module, for example when the module changes bus mode; it may also be caused by a hardware fault. The attribute's value wraps around to zero when it exceeds the maximum permitted value.")
shelfCardBusTapFrmDeliveryErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapFrmDeliveryErrors.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapFrmDeliveryErrors.setDescription("This attribute records the number of times that the bus tap was unable to receive a frame from the bus because it was destined for a bus transmit queue; that is, the frame would have been immediately retransmitted over a bus. Each occurrence results in the loss of the frame. This type of event should never occur during normal operation of the module and indicates the occurrence of a hardware or software fault. The attribute's value wraps around to zero when it exceeds the maximum permitted value.")
shelfCardBusTapFrmSizeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 2, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardBusTapFrmSizeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardBusTapFrmSizeErrors.setDescription("This attribute records the number of times that the bus tap was unable to receive a frame from the bus because it required more than 255 blocks of shared memory. Each occurrence results in the loss of the frame. This type of event should never occur during normal operation of the module and indicates improper configuration of the card or the occurrence of a hardware or software fault. The attribute's value wraps around to zero when it exceeds the maximum permitted value.")
shelfCardTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3))
shelfCardTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 1), )
if mibBuilder.loadTexts: shelfCardTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestRowStatusTable.setDescription('This entry controls the addition and deletion of shelfCardTest components.')
shelfCardTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestIndex"))
if mibBuilder.loadTexts: shelfCardTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestRowStatusEntry.setDescription('A single entry in the table represents a single shelfCardTest component.')
shelfCardTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCardTest components. These components cannot be added nor deleted.')
shelfCardTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestStorageType.setDescription('This variable represents the storage type value for the shelfCardTest tables.')
shelfCardTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: shelfCardTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestIndex.setDescription('This variable represents the index for the shelfCardTest tables.')
shelfCardTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 10), )
if mibBuilder.loadTexts: shelfCardTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
shelfCardTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestIndex"))
if mibBuilder.loadTexts: shelfCardTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestStateEntry.setDescription('An entry in the shelfCardTestStateTable.')
shelfCardTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
shelfCardTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
shelfCardTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
shelfCardTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 11), )
if mibBuilder.loadTexts: shelfCardTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestSetupTable.setDescription('This attribute group contains the attributes that govern the operation of a card test. These attributes cannot be changed while a card test is running.')
shelfCardTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestIndex"))
if mibBuilder.loadTexts: shelfCardTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestSetupEntry.setDescription('An entry in the shelfCardTestSetupTable.')
shelfCardTestTargetCard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardTestTargetCard.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestTargetCard.setDescription("This attribute specifies the slot number of the card to which frames are sent during the card test. There is no single default value for this attributeit defaults to the slot number of the Test component's own card and must be changed to a different value before the test can be started.")
shelfCardTestFrmTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 11, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardTestFrmTypes.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestFrmTypes.setDescription("This attribute specifies the types of frames that are sent during the card test. It must contain at least one of the following values. loading: A set of 'loading frames' is circulated between the Test component and the Test component on the target card as rapidly as possible. This frame type should be selected when the test is intended to verify the operation of the cards and the backplane buses under a specified load. verification: A single 'verification frame' is transmitted to the Test component on the target card; when the frame is returned, its contents are verified and the next verification frame in the series is transmitted. This frame type should be selected when the test is intended to verify that frames are not being corrupted as they pass from card to card. Description of bits: loading(0) verification(1)")
shelfCardTestFrmPriorities = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 11, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardTestFrmPriorities.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestFrmPriorities.setDescription('This attribute specifies the priorities of the frames that are sent during the card test. It must contain at least one of the following values. low: Low priority frames are sent. high: High priority frames are sent. Description of bits: lowPriority(0) highPriority(1)')
shelfCardTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestFrmPatternType.setDescription('This attribute specifies the bit sequence used to fill the frames used in the card test. It must contain one of the following values. ccitt32kBitPattern: a pseudo-random sequence of 32 Kbit is used ccitt8MBitPattern: a pseudo-random sequence of 8 Mbit is used customizedPattern: the pattern defined by the customizedPattern attribute is used')
shelfCardTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestCustomizedPattern.setDescription('This attribute specifies a 32 bit sequence used to fill frames when the framePatternType attribute has value customizedPattern. The default value gives a pattern of alternating 0 and 1 bits.')
shelfCardTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 43200)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestDuration.setDescription('This attribute specifies the maximum length of time that the card test is allowed to run. The value is expressed in minutes. The maximum allowed value permits the card test to be run for up to 30 days.')
shelfCardTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 12), )
if mibBuilder.loadTexts: shelfCardTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestResultsTable.setDescription('This attribute group contains the results of the card test that is currently running; if no test is running, the attribute group contains the results of the most recently completed card test. The attributes of the Results group are reset to their inital values whenever a card test is started or any attribute of the Setup group is set.')
shelfCardTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestIndex"))
if mibBuilder.loadTexts: shelfCardTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestResultsEntry.setDescription('An entry in the shelfCardTestResultsTable.')
shelfCardTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 43200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestElapsedTime.setDescription('This attribute records the length of time (in minutes) that the card test has been running.')
shelfCardTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 43200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestTimeRemaining.setDescription('This attribute records the maximum length of time (in minutes) that the card test will continue to run before stopping.')
shelfCardTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("neverStarted", 0), ("testRunning", 1), ("testTimeExpired", 2), ("stoppedByOperator", 3), ("targetFailed", 4), ("becameActive", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestCauseOfTermination.setDescription('This attribute records the reason the card test ended. It contains one of the following values. neverStarted: the card test has not been started testRunning: the card test is currently running testTimeExpired: the card test ran for the specified duration stoppedByOperator: a STOP command was issued targetFailed: the target card became non-operational becameActive: the source card became the active card for some LP')
shelfCardTestSizeTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 253), )
if mibBuilder.loadTexts: shelfCardTestSizeTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestSizeTable.setDescription('This attribute specifies for each priority level the number of data bytes in each frame sent during the card test. (The value specified does not include the 4-byte header that is automatically added to a frame when it is transmitted over the backplane.)')
shelfCardTestSizeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 253, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestSizeIndex"))
if mibBuilder.loadTexts: shelfCardTestSizeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestSizeEntry.setDescription('An entry in the shelfCardTestSizeTable.')
shelfCardTestSizeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 253, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("lowPriority", 0), ("highPriority", 1))))
if mibBuilder.loadTexts: shelfCardTestSizeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestSizeIndex.setDescription('This variable represents the shelfCardTestSizeTable specific index for the shelfCardTestSizeTable.')
shelfCardTestSizeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 253, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 16000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfCardTestSizeValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestSizeValue.setDescription('This variable represents an individual value for the shelfCardTestSizeTable.')
shelfCardTestLoadingFrmDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 254), )
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataTable.setDescription("This attribute records information about the loading frames that have been transmitted to the Test component on the target card. The following data is shown for each priority level: the number of frames that have been transmitted, the number of frames that were not returned successfully. The attribute's values wrap around to zero when they exceed the maximum permitted value. Note: A loading frame is considered to have been successfully returned even if it contains bit errors. Frame error statistics are recorded in the verificationFrmData attribute.")
shelfCardTestLoadingFrmDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 254, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestLoadingFrmDataResultsIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestLoadingFrmDataPriorityIndex"))
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataEntry.setDescription('An entry in the shelfCardTestLoadingFrmDataTable.')
shelfCardTestLoadingFrmDataResultsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 254, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("framesSent", 0), ("framesLost", 1))))
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataResultsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataResultsIndex.setDescription('This variable represents the next to last index for the shelfCardTestLoadingFrmDataTable.')
shelfCardTestLoadingFrmDataPriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 254, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("low", 0), ("high", 1))))
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataPriorityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataPriorityIndex.setDescription('This variable represents the final index for the shelfCardTestLoadingFrmDataTable.')
shelfCardTestLoadingFrmDataValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 254, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestLoadingFrmDataValue.setDescription('This variable represents an individual value for the shelfCardTestLoadingFrmDataTable.')
shelfCardTestVerificationFrmDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 255), )
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataTable.setDescription("This attribute records information about the verification frames that have been transmitted to the Test component on the target card. The following data is shown for each priority level: the number of frames that have been tested, the number of frames that had incorrect bits when returned. The attribute's values wrap around to zero when they exceed the maximum permitted value. Note: Verification frames that are not returned at all, or are returned too late, are considered 'lost' and are not counted in either of the above values. Frame loss statistics are recorded in the loadingFrmData attribute.")
shelfCardTestVerificationFrmDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 255, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestVerificationFrmDataResultsIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardTestVerificationFrmDataPriorityIndex"))
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataEntry.setDescription('An entry in the shelfCardTestVerificationFrmDataTable.')
shelfCardTestVerificationFrmDataResultsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 255, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("framesTested", 0), ("framesBad", 1))))
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataResultsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataResultsIndex.setDescription('This variable represents the next to last index for the shelfCardTestVerificationFrmDataTable.')
shelfCardTestVerificationFrmDataPriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 255, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("low", 0), ("high", 1))))
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataPriorityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataPriorityIndex.setDescription('This variable represents the final index for the shelfCardTestVerificationFrmDataTable.')
shelfCardTestVerificationFrmDataValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 3, 255, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardTestVerificationFrmDataValue.setDescription('This variable represents an individual value for the shelfCardTestVerificationFrmDataTable.')
shelfCardDiag = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4))
shelfCardDiagRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 1), )
if mibBuilder.loadTexts: shelfCardDiagRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRowStatusTable.setDescription('This entry controls the addition and deletion of shelfCardDiag components.')
shelfCardDiagRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagIndex"))
if mibBuilder.loadTexts: shelfCardDiagRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRowStatusEntry.setDescription('A single entry in the table represents a single shelfCardDiag component.')
shelfCardDiagRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCardDiag components. These components cannot be added nor deleted.')
shelfCardDiagComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardDiagStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagStorageType.setDescription('This variable represents the storage type value for the shelfCardDiag tables.')
shelfCardDiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: shelfCardDiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagIndex.setDescription('This variable represents the index for the shelfCardDiag tables.')
shelfCardDiagTrapData = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2))
shelfCardDiagTrapDataRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 1), )
if mibBuilder.loadTexts: shelfCardDiagTrapDataRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataRowStatusTable.setDescription('This entry controls the addition and deletion of shelfCardDiagTrapData components.')
shelfCardDiagTrapDataRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagTrapDataIndex"))
if mibBuilder.loadTexts: shelfCardDiagTrapDataRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataRowStatusEntry.setDescription('A single entry in the table represents a single shelfCardDiagTrapData component.')
shelfCardDiagTrapDataRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagTrapDataRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCardDiagTrapData components. These components cannot be added nor deleted.')
shelfCardDiagTrapDataComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagTrapDataComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardDiagTrapDataStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagTrapDataStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataStorageType.setDescription('This variable represents the storage type value for the shelfCardDiagTrapData tables.')
shelfCardDiagTrapDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: shelfCardDiagTrapDataIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataIndex.setDescription('This variable represents the index for the shelfCardDiagTrapData tables.')
shelfCardDiagTrapDataLine = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2))
shelfCardDiagTrapDataLineRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 1), )
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of shelfCardDiagTrapDataLine components.')
shelfCardDiagTrapDataLineRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagTrapDataIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagTrapDataLineIndex"))
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineRowStatusEntry.setDescription('A single entry in the table represents a single shelfCardDiagTrapDataLine component.')
shelfCardDiagTrapDataLineRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCardDiagTrapDataLine components. These components cannot be added nor deleted.')
shelfCardDiagTrapDataLineComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardDiagTrapDataLineStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineStorageType.setDescription('This variable represents the storage type value for the shelfCardDiagTrapDataLine tables.')
shelfCardDiagTrapDataLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 500)))
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineIndex.setDescription('This variable represents the index for the shelfCardDiagTrapDataLine tables.')
shelfCardDiagTrapDataLineOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 10), )
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute group contains operational attributes for one line of trap data or recoverable error report.')
shelfCardDiagTrapDataLineOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagTrapDataIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagTrapDataLineIndex"))
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineOperEntry.setDescription('An entry in the shelfCardDiagTrapDataLineOperTable.')
shelfCardDiagTrapDataLineData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 2, 2, 10, 1, 1), ExtendedAsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineData.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagTrapDataLineData.setDescription('This attribute contains one line of trap data or recoverable error report.')
shelfCardDiagRecErr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3))
shelfCardDiagRecErrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 1), )
if mibBuilder.loadTexts: shelfCardDiagRecErrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrRowStatusTable.setDescription('This entry controls the addition and deletion of shelfCardDiagRecErr components.')
shelfCardDiagRecErrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagRecErrIndex"))
if mibBuilder.loadTexts: shelfCardDiagRecErrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrRowStatusEntry.setDescription('A single entry in the table represents a single shelfCardDiagRecErr component.')
shelfCardDiagRecErrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagRecErrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCardDiagRecErr components. These components cannot be added nor deleted.')
shelfCardDiagRecErrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagRecErrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardDiagRecErrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagRecErrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrStorageType.setDescription('This variable represents the storage type value for the shelfCardDiagRecErr tables.')
shelfCardDiagRecErrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: shelfCardDiagRecErrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrIndex.setDescription('This variable represents the index for the shelfCardDiagRecErr tables.')
shelfCardDiagRecErrLine = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2))
shelfCardDiagRecErrLineRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 1), )
if mibBuilder.loadTexts: shelfCardDiagRecErrLineRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of shelfCardDiagRecErrLine components.')
shelfCardDiagRecErrLineRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagRecErrIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagRecErrLineIndex"))
if mibBuilder.loadTexts: shelfCardDiagRecErrLineRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineRowStatusEntry.setDescription('A single entry in the table represents a single shelfCardDiagRecErrLine component.')
shelfCardDiagRecErrLineRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagRecErrLineRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCardDiagRecErrLine components. These components cannot be added nor deleted.')
shelfCardDiagRecErrLineComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagRecErrLineComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardDiagRecErrLineStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagRecErrLineStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineStorageType.setDescription('This variable represents the storage type value for the shelfCardDiagRecErrLine tables.')
shelfCardDiagRecErrLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 500)))
if mibBuilder.loadTexts: shelfCardDiagRecErrLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineIndex.setDescription('This variable represents the index for the shelfCardDiagRecErrLine tables.')
shelfCardDiagRecErrLineOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 10), )
if mibBuilder.loadTexts: shelfCardDiagRecErrLineOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute group contains operational attributes for one line of trap data or recoverable error report.')
shelfCardDiagRecErrLineOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagRecErrIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDiagRecErrLineIndex"))
if mibBuilder.loadTexts: shelfCardDiagRecErrLineOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineOperEntry.setDescription('An entry in the shelfCardDiagRecErrLineOperTable.')
shelfCardDiagRecErrLineData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 4, 3, 2, 10, 1, 1), ExtendedAsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDiagRecErrLineData.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDiagRecErrLineData.setDescription('This attribute contains one line of trap data or recoverable error report.')
shelfCardDcard = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16))
shelfCardDcardRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 1), )
if mibBuilder.loadTexts: shelfCardDcardRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of shelfCardDcard components.')
shelfCardDcardRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDcardIndex"))
if mibBuilder.loadTexts: shelfCardDcardRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardRowStatusEntry.setDescription('A single entry in the table represents a single shelfCardDcard component.')
shelfCardDcardRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDcardRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfCardDcard components. These components cannot be added nor deleted.')
shelfCardDcardComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDcardComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfCardDcardStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDcardStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardStorageType.setDescription('This variable represents the storage type value for the shelfCardDcard tables.')
shelfCardDcardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)))
if mibBuilder.loadTexts: shelfCardDcardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardIndex.setDescription('This variable represents the index for the shelfCardDcard tables.')
shelfCardDcardDcardOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 17), )
if mibBuilder.loadTexts: shelfCardDcardDcardOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardDcardOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of the DaughterCard component.')
shelfCardDcardDcardOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfCardDcardIndex"))
if mibBuilder.loadTexts: shelfCardDcardDcardOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardDcardOperEntry.setDescription('An entry in the shelfCardDcardDcardOperTable.')
shelfCardDcardType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("ram", 1), ("aqm", 2), ("pqc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDcardType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardType.setDescription('This attributes indicates the type of a daugher card.')
shelfCardDcardMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDcardMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardMemorySize.setDescription('This attribute indicates the memory size in megabytes of the daughter card.')
shelfCardDcardProductCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 2, 16, 17, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfCardDcardProductCode.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCardDcardProductCode.setDescription('This attribute indicates the product equipment code of the daughter card.')
shelfBus = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3))
shelfBusRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 1), )
if mibBuilder.loadTexts: shelfBusRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusRowStatusTable.setDescription('This entry controls the addition and deletion of shelfBus components.')
shelfBusRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"))
if mibBuilder.loadTexts: shelfBusRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusRowStatusEntry.setDescription('A single entry in the table represents a single shelfBus component.')
shelfBusRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfBus components. These components cannot be added nor deleted.')
shelfBusComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfBusStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusStorageType.setDescription('This variable represents the storage type value for the shelfBus tables.')
shelfBusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x", 0), ("y", 1))))
if mibBuilder.loadTexts: shelfBusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusIndex.setDescription('This variable represents the index for the shelfBus tables.')
shelfBusStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10), )
if mibBuilder.loadTexts: shelfBusStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
shelfBusStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"))
if mibBuilder.loadTexts: shelfBusStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusStateEntry.setDescription('An entry in the shelfBusStateTable.')
shelfBusAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfBusOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfBusUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
shelfBusAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
shelfBusProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
shelfBusControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
shelfBusAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
shelfBusStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
shelfBusUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
shelfBusOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 11), )
if mibBuilder.loadTexts: shelfBusOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusOperTable.setDescription('This attribute group contains operational attributes of a bus.')
shelfBusOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"))
if mibBuilder.loadTexts: shelfBusOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusOperEntry.setDescription('An entry in the shelfBusOperTable.')
shelfBusClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("activeCP", 0), ("alternate", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusClockSource.setDescription('This attribute records the source of the fundamental clock signal and end-of-cell synchronization signal used by the bus. It contains one of the following values. activeCP: the card which is the active control processor (CP) is providing clock signals alternate: the card at the opposite end of the module from the active CP is providing clock signals')
shelfBusUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusUtilization.setDescription('This attribute records how much of the available bus bandwidth was actually used during the most recently sampled 1 second interval. The value is expressed as a percentage.')
shelfBusBusTapStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 246), )
if mibBuilder.loadTexts: shelfBusBusTapStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusBusTapStatusTable.setDescription('This attribute records the operability of each bus tap on the bus, as reported by the associated BusTap component; the entries are indexed by slot number of the card. Each entry contains one of the following values. ok: the bus tap is operational failed: the bus tap has failed none: the bus tap status is not availablethe associated BusTap component does not currently exist')
shelfBusBusTapStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 246, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusBusTapStatusIndex"))
if mibBuilder.loadTexts: shelfBusBusTapStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusBusTapStatusEntry.setDescription('An entry in the shelfBusBusTapStatusTable.')
shelfBusBusTapStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 246, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusBusTapStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusBusTapStatusIndex.setDescription('This variable represents the shelfBusBusTapStatusTable specific index for the shelfBusBusTapStatusTable.')
shelfBusBusTapStatusValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 246, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("failed", 1), ("none", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusBusTapStatusValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusBusTapStatusValue.setDescription('This variable represents an individual value for the shelfBusBusTapStatusTable.')
shelfBusClockSourceStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 247), )
if mibBuilder.loadTexts: shelfBusClockSourceStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusClockSourceStatusTable.setDescription("This vector attribute, indexed with activeCP or alternate, represents the state of the bus clock sources. It can be set to one of the following values: ok: all operational cards can receive signals from the clock source. failed: at least one operational card is unable to receive signals from the clock source. unknown: status of a clock source is unknown. To determine the status of the clock source, a test must be run. testInProgress: the clock source is currently being tested. notApplicable: the LP state of the clock source's card is down or not provisioned.")
shelfBusClockSourceStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 247, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusClockSourceStatusIndex"))
if mibBuilder.loadTexts: shelfBusClockSourceStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusClockSourceStatusEntry.setDescription('An entry in the shelfBusClockSourceStatusTable.')
shelfBusClockSourceStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 247, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("activeCP", 0), ("alternate", 1))))
if mibBuilder.loadTexts: shelfBusClockSourceStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusClockSourceStatusIndex.setDescription('This variable represents the shelfBusClockSourceStatusTable specific index for the shelfBusClockSourceStatusTable.')
shelfBusClockSourceStatusValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 247, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 0), ("failed", 1), ("unknown", 2), ("testInProgress", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusClockSourceStatusValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusClockSourceStatusValue.setDescription('This variable represents an individual value for the shelfBusClockSourceStatusTable.')
shelfBusTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2))
shelfBusTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 1), )
if mibBuilder.loadTexts: shelfBusTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestRowStatusTable.setDescription('This entry controls the addition and deletion of shelfBusTest components.')
shelfBusTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"))
if mibBuilder.loadTexts: shelfBusTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestRowStatusEntry.setDescription('A single entry in the table represents a single shelfBusTest component.')
shelfBusTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfBusTest components. These components cannot be added nor deleted.')
shelfBusTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfBusTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestStorageType.setDescription('This variable represents the storage type value for the shelfBusTest tables.')
shelfBusTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: shelfBusTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestIndex.setDescription('This variable represents the index for the shelfBusTest tables.')
shelfBusTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 10), )
if mibBuilder.loadTexts: shelfBusTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
shelfBusTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"))
if mibBuilder.loadTexts: shelfBusTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestStateEntry.setDescription('An entry in the shelfBusTestStateTable.')
shelfBusTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
shelfBusTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
shelfBusTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
shelfBusTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 11), )
if mibBuilder.loadTexts: shelfBusTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestSetupTable.setDescription('This attribute group contains the attributes that govern the operation of a bus test. These attributes cannot be changed while the bus test is running.')
shelfBusTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"))
if mibBuilder.loadTexts: shelfBusTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestSetupEntry.setDescription('An entry in the shelfBusTestSetupTable.')
shelfBusTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 43200)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfBusTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestDuration.setDescription('This attribute specifies the maximum length of time that the bus test is allowed to run. The value is expressed in minutes. The maximum allowed value permits the bus test to be run for up to 30 days.')
shelfBusTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 12), )
if mibBuilder.loadTexts: shelfBusTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestResultsTable.setDescription('This attribute group contains the results of the bus test that is currently running; if no bus test is running, the attribute group contains the results of the most recently completed bus test. The attributes of the Results group are reset to their initial values whenever a bus test is started or any attribute in the Setup group is set.')
shelfBusTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"))
if mibBuilder.loadTexts: shelfBusTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestResultsEntry.setDescription('An entry in the shelfBusTestResultsTable.')
shelfBusTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 43200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestElapsedTime.setDescription('This attribute records the length of time (in minutes) that the bus test has been running.')
shelfBusTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 43200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestTimeRemaining.setDescription('This attribute records the maximum length of time (in minutes) that the bus test will continue to run before stopping.')
shelfBusTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("neverStarted", 0), ("testRunning", 1), ("testTimeExpired", 2), ("stoppedByOperator", 3), ("selfTestFailure", 4), ("clockSourceFailure", 5), ("broadcastFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestCauseOfTermination.setDescription('This attribute records the reason the bus test ended. It contains one of the following values. neverStarted: the bus test has not been started testRunning: the bus test is currently running testTimeExpired: the bus test ran for the specified duration stoppedByOperator: a STOP command was issued selfTestFailure: a failure was detected during the bus tap self-test clockSourceFailure: a failure was detected during the test of the active control processor (CP) clock source broadcastFailure: a failure was detected during the broadcast test')
shelfBusTestTestsDone = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestTestsDone.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestTestsDone.setDescription('This attribute records the tests that have been performed during the bus test. It may contain zero or more of the following values. selfTest: the bus tap self-test has been performed clockSourceTest: the clock source test has been performed broadcastTest: the broadcast test has been performed pingTest: at least one ping test has been performed Description of bits: selfTest(0) clockSourceTest(1) broadcastTest(2) pingTest(3)')
shelfBusTestSelfTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 248), )
if mibBuilder.loadTexts: shelfBusTestSelfTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestSelfTestResultsTable.setDescription('This attribute records the results of the bus tap self-test, indexed by the slot number of the card containing the bus tap tested. Each entry contains one of the following values. +: the bus tap passed its self-test X: the bus tap failed its self-test .: the bus tap was not tested The bus test terminates automatically if a failure is detected.')
shelfBusTestSelfTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 248, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestSelfTestResultsIndex"))
if mibBuilder.loadTexts: shelfBusTestSelfTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestSelfTestResultsEntry.setDescription('An entry in the shelfBusTestSelfTestResultsTable.')
shelfBusTestSelfTestResultsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 248, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusTestSelfTestResultsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestSelfTestResultsIndex.setDescription('This variable represents the shelfBusTestSelfTestResultsTable specific index for the shelfBusTestSelfTestResultsTable.')
shelfBusTestSelfTestResultsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 248, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("x", 0), ("n1", 1), ("n2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestSelfTestResultsValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestSelfTestResultsValue.setDescription('This variable represents an individual value for the shelfBusTestSelfTestResultsTable.')
shelfBusTestClockSourceTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 249), )
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsTable.setDescription('This attribute records the results of the clock source test, indexed by the clock source and the slot number of the card containing the bus tap tested. Each entry contains one of the following values. +: the bus tap was able to receive clock signals from the clock source X: the bus tap was unable to receive clock signals from the clock source .: the bus tap was not tested against the clock source The bus test terminates automatically if a failure is detected involving the active control processor (CP) clock source.')
shelfBusTestClockSourceTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 249, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestClockSourceTestResultsSourceIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestClockSourceTestResultsCardIndex"))
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsEntry.setDescription('An entry in the shelfBusTestClockSourceTestResultsTable.')
shelfBusTestClockSourceTestResultsSourceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 249, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("activeCP", 0), ("alternate", 1))))
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsSourceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsSourceIndex.setDescription('This variable represents the next to last index for the shelfBusTestClockSourceTestResultsTable.')
shelfBusTestClockSourceTestResultsCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 249, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsCardIndex.setDescription('This variable represents the final index for the shelfBusTestClockSourceTestResultsTable.')
shelfBusTestClockSourceTestResultsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 249, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("x", 0), ("n1", 1), ("n2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestClockSourceTestResultsValue.setDescription('This variable represents an individual value for the shelfBusTestClockSourceTestResultsTable.')
shelfBusTestBroadcastTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 250), )
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsTable.setDescription('This attribute records the results of the broadcast test, indexed by the slot numbers of the cards containing the bus taps tested. Each entry contains one of the following values. +: a broadcast message was successfully sent from the transmitting bus tap to the receiving bus tap X: a broadcast message was not successfully sent from the transmitting bus tap to the receiving bus tap .: the associated pair of bus taps was not tested The bus test terminates automatically if a failure is detected.')
shelfBusTestBroadcastTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 250, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestBroadcastTestResultsTxCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestBroadcastTestResultsRxCardIndex"))
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsEntry.setDescription('An entry in the shelfBusTestBroadcastTestResultsTable.')
shelfBusTestBroadcastTestResultsTxCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 250, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsTxCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsTxCardIndex.setDescription('This variable represents the next to last index for the shelfBusTestBroadcastTestResultsTable.')
shelfBusTestBroadcastTestResultsRxCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 250, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsRxCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsRxCardIndex.setDescription('This variable represents the final index for the shelfBusTestBroadcastTestResultsTable.')
shelfBusTestBroadcastTestResultsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 250, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("x", 0), ("n1", 1), ("n2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestBroadcastTestResultsValue.setDescription('This variable represents an individual value for the shelfBusTestBroadcastTestResultsTable.')
shelfBusTestPingTestsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 251), )
if mibBuilder.loadTexts: shelfBusTestPingTestsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingTestsTable.setDescription('This attribute records the number of ping tests performed, indexed by the slot numbers of the cards containing the bus taps involved. Each test attempts to transmit a single low-priority frame from the transmitting bus tap to the receiving bus tap.')
shelfBusTestPingTestsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 251, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestPingTestsTxCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestPingTestsRxCardIndex"))
if mibBuilder.loadTexts: shelfBusTestPingTestsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingTestsEntry.setDescription('An entry in the shelfBusTestPingTestsTable.')
shelfBusTestPingTestsTxCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 251, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusTestPingTestsTxCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingTestsTxCardIndex.setDescription('This variable represents the next to last index for the shelfBusTestPingTestsTable.')
shelfBusTestPingTestsRxCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 251, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusTestPingTestsRxCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingTestsRxCardIndex.setDescription('This variable represents the final index for the shelfBusTestPingTestsTable.')
shelfBusTestPingTestsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 251, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestPingTestsValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingTestsValue.setDescription('This variable represents an individual value for the shelfBusTestPingTestsTable.')
shelfBusTestPingFailuresTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 252), )
if mibBuilder.loadTexts: shelfBusTestPingFailuresTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingFailuresTable.setDescription('This attribute records the number of ping test failures detected, indexed by the slot numbers of the cards containing the bus taps involved. Each failure represents a single low-priority frame that was not successfully transmitted from the transmitting bus tap to the receiving bus tap. The bus test does not terminate automatically if a failure is detected.')
shelfBusTestPingFailuresEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 252, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestPingFailuresTxCardIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfBusTestPingFailuresRxCardIndex"))
if mibBuilder.loadTexts: shelfBusTestPingFailuresEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingFailuresEntry.setDescription('An entry in the shelfBusTestPingFailuresTable.')
shelfBusTestPingFailuresTxCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 252, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusTestPingFailuresTxCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingFailuresTxCardIndex.setDescription('This variable represents the next to last index for the shelfBusTestPingFailuresTable.')
shelfBusTestPingFailuresRxCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 252, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: shelfBusTestPingFailuresRxCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingFailuresRxCardIndex.setDescription('This variable represents the final index for the shelfBusTestPingFailuresTable.')
shelfBusTestPingFailuresValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 3, 2, 252, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBusTestPingFailuresValue.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBusTestPingFailuresValue.setDescription('This variable represents an individual value for the shelfBusTestPingFailuresTable.')
shelfTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4))
shelfTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 1), )
if mibBuilder.loadTexts: shelfTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestRowStatusTable.setDescription('This entry controls the addition and deletion of shelfTest components.')
shelfTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfTestIndex"))
if mibBuilder.loadTexts: shelfTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestRowStatusEntry.setDescription('A single entry in the table represents a single shelfTest component.')
shelfTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of shelfTest components. These components cannot be added nor deleted.')
shelfTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
shelfTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestStorageType.setDescription('This variable represents the storage type value for the shelfTest tables.')
shelfTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: shelfTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestIndex.setDescription('This variable represents the index for the shelfTest tables.')
shelfTestProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 10), )
if mibBuilder.loadTexts: shelfTestProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestProvTable.setDescription('This group contains provisionable attributes of the Test component.')
shelfTestProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfTestIndex"))
if mibBuilder.loadTexts: shelfTestProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestProvEntry.setDescription('An entry in the shelfTestProvTable.')
shelfTestAutomaticBusClockTest = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfTestAutomaticBusClockTest.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestAutomaticBusClockTest.setDescription("This attribute specifies whether or not a bus clock source test is automatically executed after a clock source's LP state changes, and after failure or recovery of the active CP bus clock source. Since tests of an alternate bus clock source may cause a minor loss of traffic, the attribute is set to disabled by default. If set to enabled, a bus clock source test is automatically executed. If the status of the corresponding Shelf Bus clockSourceStatus is changed after the test, an alarm is issued if the status is one of the following: ok, failed, or unknown. If set to disabled, no bus clock source test is automatically executed. However, a test can be executed by the RUN command. If the status is changed after the test, an alarm is issued if the status is one of the following: ok, or failed.")
shelfTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 11), )
if mibBuilder.loadTexts: shelfTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestSetupTable.setDescription('This attribute group contains the attributes that govern the operation of a shelf test.')
shelfTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfTestIndex"))
if mibBuilder.loadTexts: shelfTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestSetupEntry.setDescription('An entry in the shelfTestSetupTable.')
shelfTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("busClock", 0))).clone('busClock')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfTestType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestType.setDescription('type The attribute determines the test to be executed when the RUN command is applied to the component. Note that running a busClock test may cause a minor loss of traffic.')
shelfTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 12), )
if mibBuilder.loadTexts: shelfTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestResultsTable.setDescription('This attribute group contains the results of the Shelf Test that is currently running; if no test is running, the attribute group contains the results of the most recently completed Shelf Test. The attributes of the Results group are reset to their initial values whenever a corresponding Shelf Test is run or the corresponding attribute of the Setup group is set.')
shelfTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "shelfIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "shelfTestIndex"))
if mibBuilder.loadTexts: shelfTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestResultsEntry.setDescription('An entry in the shelfTestResultsTable.')
shelfTestBusClockTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 13, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noTest", 0), ("fail", 1), ("pass", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfTestBusClockTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTestBusClockTestResult.setDescription('busClockTestResult This attribute records the result of the bus clock manual test. The result can be one of the following values. pass : the test passed fail : the test failed noTest : the test was not executed when RUN command is issued, because the shelf was in single bus mode.')
mod = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16))
modRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 1), )
if mibBuilder.loadTexts: modRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: modRowStatusTable.setDescription('This entry controls the addition and deletion of mod components.')
modRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"))
if mibBuilder.loadTexts: modRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modRowStatusEntry.setDescription('A single entry in the table represents a single mod component.')
modRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: modRowStatus.setDescription('This variable is used as the basis for SNMP naming of mod components. These components cannot be added nor deleted.')
modComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: modComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
modStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: modStorageType.setDescription('This variable represents the storage type value for the mod tables.')
modIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: modIndex.setStatus('mandatory')
if mibBuilder.loadTexts: modIndex.setDescription('This variable represents the index for the mod tables.')
modProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 10), )
if mibBuilder.loadTexts: modProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: modProvTable.setDescription('Mod Provisionable This group provides attributes that are used by internal and external systems to identify the module.')
modProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"))
if mibBuilder.loadTexts: modProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modProvEntry.setDescription('An entry in the modProvTable.')
modNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: modNodeId.setDescription('The nodeId is a number that uniquely identifies a Magellan Passport module in a Passport network. Changing the value of the nodeId will cause the node to restart.')
modNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 12)).clone(hexValue="4e4f4e414d45")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: modNodeName.setDescription('The nodeName is a 12 character ASCII string that is unique to every Passport module in a Passport network. This name is the component instance value of EM - the root of the Passport component hierarchy. It has, therefore, the same restriction and behaviour as any ascii string instance value, e.g., it is converted to upper case. Note that the EM component is typically suppressed on output. Changing the value of the nodeName will cause the node to restart.')
modNamsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 49151)).clone(49151)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modNamsId.setStatus('mandatory')
if mibBuilder.loadTexts: modNamsId.setDescription('This attribute stores the Network Administration (Nams) Identifier associated with the Passport node. It must be unique across the entire network of Passport nodes supporting the transport of DPN traffic as well as all RMs and AMs in the network. The namsId must be set when a DpnAddressPlan component is configured on an Passport node. The namsId is used in the accounting record, statistics record and in time change accounting record and identifies nodes in these records. The Nams Id is to be assigned by the network administrator. Value 49151 indicates that no Nams Id was assigned to the module. Changing the value of the namsId will cause the node to restart.')
modRegionId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modRegionId.setStatus('mandatory')
if mibBuilder.loadTexts: modRegionId.setDescription('This attribute identifies the Topology Region to which the node belongs. Nodes will only exchange topological information with connected nodes in the same region. The default value of 0 indicates that no regionId has been assigned to the module. A module using the default regionId belongs to the same region as the first neighbour which stages with it using a non- zero regionId. If another neighbour tries to stage using a different non-zero regionId, the trunk will not be allowed to come up. Changing the value of the regionId will cause the node to restart.')
modNodePrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 10, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 26)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modNodePrefix.setStatus('mandatory')
if mibBuilder.loadTexts: modNodePrefix.setDescription("This attribute specifies an NSAP prefix which is distributed to all other Passport nodes within a Topology region and by which this node can be identified. This prefix is used by PORS, PNNI routing, and Data Shunts. PORS calls that use NSAP addressing (for example, CES) will look for the node with the longest NSAP prefix that matches the called party address. The NSAP prefixes that PORS matches against are the nodePrefix and the alternatePorsPrefixes. PNNI forms the default value of the nodeAddressPrefix under the AtmPnni component with this NSAP prefix followed by a unique MAC address. Data Shunts uses the nodePrefix to form an NSAP address that is registered with the Networking API. This NSAP address is used to identify this node when establishing a Data Shunt. The value entered must be 26 characters long. All characters must be hexadecimal with the following restrictions: - the first two characters must be either '39', '45', or '47' - if the first two characters are '45', the 18th character must be an 'f' or an 'F'")
modNodePrefixesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 338), )
if mibBuilder.loadTexts: modNodePrefixesTable.setStatus('obsolete')
if mibBuilder.loadTexts: modNodePrefixesTable.setDescription('This attribute specifies five different NSAP prefixes which are distributed to all other Passport nodes within a Topology region and by which this node can be identified. PORS calls that use NSAP addressing (for example, CES) will look for the node with the longest NSAP prefix that matches the called party address. The default value of the nodeAddressPrefix under the AtmPnni component is formed by the first NSAP prefix followed by a unique MAC address. Each NSAP prefix may contain 40 hexadecimal characters with the exception of the first prefix which has a maximum length of 26 chracacters. This attribute was never deployed and will be removed prior to Gate 2..')
modNodePrefixesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 338, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "modNodePrefixesIndex"))
if mibBuilder.loadTexts: modNodePrefixesEntry.setStatus('obsolete')
if mibBuilder.loadTexts: modNodePrefixesEntry.setDescription('An entry in the modNodePrefixesTable.')
modNodePrefixesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 338, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: modNodePrefixesIndex.setStatus('obsolete')
if mibBuilder.loadTexts: modNodePrefixesIndex.setDescription('This variable represents the modNodePrefixesTable specific index for the modNodePrefixesTable.')
modNodePrefixesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 338, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modNodePrefixesValue.setStatus('obsolete')
if mibBuilder.loadTexts: modNodePrefixesValue.setDescription('This variable represents an individual value for the modNodePrefixesTable.')
modAlternatePorsPrefixesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 405), )
if mibBuilder.loadTexts: modAlternatePorsPrefixesTable.setStatus('mandatory')
if mibBuilder.loadTexts: modAlternatePorsPrefixesTable.setDescription('This attribute specifies four NSAP prefixes which are distributed to all other Passport nodes within a Topology region and by which this node can be identified. These prefixes are used by PORS. PORS calls that use NSAP addressing (for example, CES) will look for the node with the longest NSAP prefix that matches the called party address. The NSAP prefixes that PORS matches against are the alternatePorsPrefixes and the nodePrefix. These prefixes may contain up to 40 hexadecimal characters.')
modAlternatePorsPrefixesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 405, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"), (0, "Nortel-Magellan-Passport-ShelfMIB", "modAlternatePorsPrefixesIndex"))
if mibBuilder.loadTexts: modAlternatePorsPrefixesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modAlternatePorsPrefixesEntry.setDescription('An entry in the modAlternatePorsPrefixesTable.')
modAlternatePorsPrefixesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 405, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: modAlternatePorsPrefixesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: modAlternatePorsPrefixesIndex.setDescription('This variable represents the modAlternatePorsPrefixesTable specific index for the modAlternatePorsPrefixesTable.')
modAlternatePorsPrefixesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 405, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modAlternatePorsPrefixesValue.setStatus('mandatory')
if mibBuilder.loadTexts: modAlternatePorsPrefixesValue.setDescription('This variable represents an individual value for the modAlternatePorsPrefixesTable.')
shelfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12, 1))
shelfGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12, 1, 5))
shelfGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12, 1, 5, 2))
shelfGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12, 1, 5, 2, 2))
shelfCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12, 3))
shelfCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12, 3, 5))
shelfCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12, 3, 5, 2))
shelfCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 12, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-ShelfMIB", shelfCardMemoryUsageAvgMinEntry=shelfCardMemoryUsageAvgMinEntry, shelfCardBusTapErrorsTable=shelfCardBusTapErrorsTable, shelfCardDiagRecErr=shelfCardDiagRecErr, shelfBusClockSource=shelfBusClockSource, shelfTestStorageType=shelfTestStorageType, shelfCardDiagRecErrLineData=shelfCardDiagRecErrLineData, shelfCardMemoryUsageAvgMinIndex=shelfCardMemoryUsageAvgMinIndex, shelfCardTestSizeTable=shelfCardTestSizeTable, shelfCardBusTapParityErrors=shelfCardBusTapParityErrors, shelfBusTestClockSourceTestResultsTable=shelfBusTestClockSourceTestResultsTable, shelfCardDiagRecErrIndex=shelfCardDiagRecErrIndex, modAlternatePorsPrefixesTable=modAlternatePorsPrefixesTable, shelfCardControlStatus=shelfCardControlStatus, shelfCardMemoryUsageAvgMaxEntry=shelfCardMemoryUsageAvgMaxEntry, shelfCardUnknownStatus=shelfCardUnknownStatus, shelfCardDcardRowStatusEntry=shelfCardDcardRowStatusEntry, shelfBusTestSelfTestResultsTable=shelfBusTestSelfTestResultsTable, shelfCardRowStatusTable=shelfCardRowStatusTable, modComponentName=modComponentName, shelfBusTestPingFailuresValue=shelfBusTestPingFailuresValue, shelfBusClockSourceStatusIndex=shelfBusClockSourceStatusIndex, shelfCardTest=shelfCardTest, shelfCardTestCauseOfTermination=shelfCardTestCauseOfTermination, shelfBusTestPingTestsTable=shelfBusTestPingTestsTable, shelfCardUsageState=shelfCardUsageState, shelfCardMemoryUsageEntry=shelfCardMemoryUsageEntry, modRegionId=modRegionId, shelfCardMemoryUsageAvgEntry=shelfCardMemoryUsageAvgEntry, shelfBusComponentName=shelfBusComponentName, shelfBusTestPingTestsTxCardIndex=shelfBusTestPingTestsTxCardIndex, shelfCardBusTapClockErrors=shelfCardBusTapClockErrors, shelfCardDiagTrapDataLineOperTable=shelfCardDiagTrapDataLineOperTable, shelfCardImRevisionCode=shelfCardImRevisionCode, shelfTestIndex=shelfTestIndex, shelfCardProceduralStatus=shelfCardProceduralStatus, shelfCardDiagTrapDataLineOperEntry=shelfCardDiagTrapDataLineOperEntry, shelfCardBusTapRowStatusTable=shelfCardBusTapRowStatusTable, modStorageType=modStorageType, shelfCardMsgBlockCapacity=shelfCardMsgBlockCapacity, shelfCapabilities=shelfCapabilities, shelfCardPropEntry=shelfCardPropEntry, shelfCardCpuUtilAvg=shelfCardCpuUtilAvg, shelfCardTestTargetCard=shelfCardTestTargetCard, shelfCardDiagRecErrLineOperTable=shelfCardDiagRecErrLineOperTable, shelfBusTestPingFailuresRxCardIndex=shelfBusTestPingFailuresRxCardIndex, shelfProvEntry=shelfProvEntry, shelfBusTestPingTestsValue=shelfBusTestPingTestsValue, shelfCardStandbyStatus=shelfCardStandbyStatus, shelfBusTestSetupEntry=shelfBusTestSetupEntry, shelfCardBusTapRowStatus=shelfCardBusTapRowStatus, shelfCardDiagRecErrLineRowStatusTable=shelfCardDiagRecErrLineRowStatusTable, shelfCardDiagTrapDataRowStatusEntry=shelfCardDiagTrapDataRowStatusEntry, shelfCardBusTapStandbyStatus=shelfCardBusTapStandbyStatus, shelfCardBusTapAvailabilityStatus=shelfCardBusTapAvailabilityStatus, shelfCardOperTable=shelfCardOperTable, modNodePrefixesValue=modNodePrefixesValue, shelfCardDiagTrapDataLineRowStatus=shelfCardDiagTrapDataLineRowStatus, shelfCardActiveFirmwareVersion=shelfCardActiveFirmwareVersion, shelfCardBusTapOperEntry=shelfCardBusTapOperEntry, shelfGroupBE=shelfGroupBE, shelfCardBusTapCardsAvailable=shelfCardBusTapCardsAvailable, modNodePrefix=modNodePrefix, shelfCardLocalMsgBlockCapacity=shelfCardLocalMsgBlockCapacity, shelfBusOperTable=shelfBusOperTable, shelfBusTestStorageType=shelfBusTestStorageType, shelfBusTestSelfTestResultsIndex=shelfBusTestSelfTestResultsIndex, shelfIndex=shelfIndex, shelfCardDiagRowStatusTable=shelfCardDiagRowStatusTable, shelfCardTestOperationalState=shelfCardTestOperationalState, shelfCardTimeInterval=shelfCardTimeInterval, shelfBusTestBroadcastTestResultsRxCardIndex=shelfBusTestBroadcastTestResultsRxCardIndex, shelfCardTestSizeEntry=shelfCardTestSizeEntry, shelfCardTestVerificationFrmDataEntry=shelfCardTestVerificationFrmDataEntry, shelfCardInsertedCardType=shelfCardInsertedCardType, shelfCommentText=shelfCommentText, shelfCardDiagTrapDataLineRowStatusTable=shelfCardDiagTrapDataLineRowStatusTable, modProvTable=modProvTable, modRowStatus=modRowStatus, shelfCardCapEntry=shelfCardCapEntry, shelfCardPmRevisionCode=shelfCardPmRevisionCode, shelfTestRowStatusEntry=shelfTestRowStatusEntry, shelfBusStateTable=shelfBusStateTable, shelfBusTestClockSourceTestResultsCardIndex=shelfBusTestClockSourceTestResultsCardIndex, shelfTest=shelfTest, shelfCardTestSetupEntry=shelfCardTestSetupEntry, shelfBusTestRowStatusEntry=shelfBusTestRowStatusEntry, shelfCapabilitiesBE=shelfCapabilitiesBE, shelfBusBusTapStatusEntry=shelfBusBusTapStatusEntry, shelfBusRowStatusEntry=shelfBusRowStatusEntry, shelfCardDiagRecErrLineOperEntry=shelfCardDiagRecErrLineOperEntry, shelfBusProceduralStatus=shelfBusProceduralStatus, shelfBusTestOperationalState=shelfBusTestOperationalState, shelfCardDiagRowStatusEntry=shelfCardDiagRowStatusEntry, shelfCardBusTapSelfTestErrorCode=shelfCardBusTapSelfTestErrorCode, shelfCardDiagRecErrStorageType=shelfCardDiagRecErrStorageType, shelfOperEntry=shelfOperEntry, shelfBusUtilization=shelfBusUtilization, shelfCardComponentName=shelfCardComponentName, shelfCardDcardMemorySize=shelfCardDcardMemorySize, shelfTestResultsTable=shelfTestResultsTable, shelfCardMemoryUsageAvgMinTable=shelfCardMemoryUsageAvgMinTable, shelfBusAdminState=shelfBusAdminState, shelfCardDiagRecErrRowStatusTable=shelfCardDiagRecErrRowStatusTable, shelfCardLocalMsgBlockUsage=shelfCardLocalMsgBlockUsage, shelfCardDcardStorageType=shelfCardDcardStorageType, mod=mod, shelfCardCapTable=shelfCardCapTable, shelfBusTestPingTestsRxCardIndex=shelfBusTestPingTestsRxCardIndex, shelfCardTestCustomizedPattern=shelfCardTestCustomizedPattern, shelfCardSerialNumber=shelfCardSerialNumber, shelfCardBusTapFrmCollisionErrors=shelfCardBusTapFrmCollisionErrors, shelfCardDiagRecErrLineRowStatus=shelfCardDiagRecErrLineRowStatus, shelfCard=shelfCard, shelfGroupBE01A=shelfGroupBE01A, shelfBusTestBroadcastTestResultsValue=shelfBusTestBroadcastTestResultsValue, shelfCardBusTapOperationalState=shelfCardBusTapOperationalState, shelfCardDiagComponentName=shelfCardDiagComponentName, shelfCardConfiguredLPsValue=shelfCardConfiguredLPsValue, shelfBusTestClockSourceTestResultsSourceIndex=shelfBusTestClockSourceTestResultsSourceIndex, shelfCardCurrentLP=shelfCardCurrentLP, shelfCardTestRowStatus=shelfCardTestRowStatus, shelfCardTestSizeIndex=shelfCardTestSizeIndex, shelfCardTestFrmTypes=shelfCardTestFrmTypes, shelfCardDcardDcardOperTable=shelfCardDcardDcardOperTable, shelfCardCpuUtil=shelfCardCpuUtil, shelfCardTestLoadingFrmDataValue=shelfCardTestLoadingFrmDataValue, shelfCardBusTapControlStatus=shelfCardBusTapControlStatus, shelf=shelf, shelfCardMemoryUsageAvgMaxValue=shelfCardMemoryUsageAvgMaxValue, shelfBusBusTapStatusValue=shelfBusBusTapStatusValue, shelfBusUsageState=shelfBusUsageState, modAlternatePorsPrefixesValue=modAlternatePorsPrefixesValue, shelfBusStateEntry=shelfBusStateEntry, shelfCardBusTapStateEntry=shelfCardBusTapStateEntry, shelfTestRowStatus=shelfTestRowStatus, shelfTestResultsEntry=shelfTestResultsEntry, shelfGroup=shelfGroup, shelfBusTestTestsDone=shelfBusTestTestsDone, shelfBusTestSelfTestResultsValue=shelfBusTestSelfTestResultsValue, shelfCardBusTapFrmTimeoutErrors=shelfCardBusTapFrmTimeoutErrors, shelfBusClockSourceStatusTable=shelfBusClockSourceStatusTable, shelfBusTestComponentName=shelfBusTestComponentName, shelfCardCurrentLpTable=shelfCardCurrentLpTable, shelfCardMemoryCapacityValue=shelfCardMemoryCapacityValue, shelfBusTestDuration=shelfBusTestDuration, shelfCardDcard=shelfCardDcard, shelfCardDiagRecErrRowStatusEntry=shelfCardDiagRecErrRowStatusEntry, shelfCardMemoryUsageAvgTable=shelfCardMemoryUsageAvgTable, shelfCardTestSetupTable=shelfCardTestSetupTable, shelfCardBusTapComponentName=shelfCardBusTapComponentName, shelfGroupBE01=shelfGroupBE01, shelfCardTestAdminState=shelfCardTestAdminState, shelfCardLocalMsgBlockUsageAvg=shelfCardLocalMsgBlockUsageAvg, shelfCardMsgBlockUsage=shelfCardMsgBlockUsage, shelfTestType=shelfTestType, shelfTestSetupTable=shelfTestSetupTable, shelfCardDiagTrapDataLineStorageType=shelfCardDiagTrapDataLineStorageType, shelfCardAvailabilityStatus=shelfCardAvailabilityStatus, modAlternatePorsPrefixesIndex=modAlternatePorsPrefixesIndex, shelfBusTestPingFailuresTable=shelfBusTestPingFailuresTable, shelfCardInactiveFirmwareVersion=shelfCardInactiveFirmwareVersion, shelfBusAvailabilityStatus=shelfBusAvailabilityStatus, shelfCardTestLoadingFrmDataEntry=shelfCardTestLoadingFrmDataEntry, shelfBusTestTimeRemaining=shelfBusTestTimeRemaining, shelfBusTestBroadcastTestResultsTxCardIndex=shelfBusTestBroadcastTestResultsTxCardIndex, shelfBusStorageType=shelfBusStorageType, shelfCardPropTable=shelfCardPropTable, shelfBusTestElapsedTime=shelfBusTestElapsedTime, shelfCardDcardIndex=shelfCardDcardIndex, shelfCardMemoryUsageAvgValue=shelfCardMemoryUsageAvgValue, shelfBusStandbyStatus=shelfBusStandbyStatus, shelfBusOperEntry=shelfBusOperEntry, shelfBusTestSelfTestResultsEntry=shelfBusTestSelfTestResultsEntry, shelfCardDiagRecErrComponentName=shelfCardDiagRecErrComponentName, shelfTestProvTable=shelfTestProvTable, shelfCardProvEntry=shelfCardProvEntry, modProvEntry=modProvEntry, modRowStatusTable=modRowStatusTable, shelfCardTestResultsTable=shelfCardTestResultsTable, shelfCardDiagTrapDataIndex=shelfCardDiagTrapDataIndex, shelfCardDiagTrapDataLineData=shelfCardDiagTrapDataLineData, shelfBusTestRowStatusTable=shelfBusTestRowStatusTable, shelfCardDcardRowStatus=shelfCardDcardRowStatus, shelfBusTestAdminState=shelfBusTestAdminState, shelfCardTestRowStatusEntry=shelfCardTestRowStatusEntry, shelfCardProvTable=shelfCardProvTable, shelfCardDiagTrapDataLine=shelfCardDiagTrapDataLine, shelfBusTestPingFailuresEntry=shelfBusTestPingFailuresEntry, shelfCardTestElapsedTime=shelfCardTestElapsedTime, shelfBusRowStatusTable=shelfBusRowStatusTable, shelfCardDiagTrapDataRowStatus=shelfCardDiagTrapDataRowStatus, shelfCardCommentText=shelfCardCommentText, shelfCardBusTapFrmDeliveryErrors=shelfCardBusTapFrmDeliveryErrors, shelfCardBusTapOperTable=shelfCardBusTapOperTable, shelfCardConfiguredLPsTable=shelfCardConfiguredLPsTable, shelfCardDiagRecErrLineComponentName=shelfCardDiagRecErrLineComponentName, shelfCardMemoryUsageAvgMinValue=shelfCardMemoryUsageAvgMinValue, shelfBusBusTapStatusIndex=shelfBusBusTapStatusIndex, shelfProvTable=shelfProvTable, shelfCardCurrentLpValue=shelfCardCurrentLpValue, shelfCardMemoryUsageIndex=shelfCardMemoryUsageIndex, shelfCardBusTapAdminState=shelfCardBusTapAdminState, shelfCardDiagTrapDataStorageType=shelfCardDiagTrapDataStorageType, shelfBusOperationalState=shelfBusOperationalState, shelfCardMemoryUsageTable=shelfCardMemoryUsageTable, shelfCardMemoryCapacityEntry=shelfCardMemoryCapacityEntry, shelfCardDcardProductCode=shelfCardDcardProductCode, shelfCardBusTapProceduralStatus=shelfCardBusTapProceduralStatus, shelfCardTestFrmPriorities=shelfCardTestFrmPriorities, shelfCardIndex=shelfCardIndex, shelfBusUnknownStatus=shelfBusUnknownStatus, shelfTestRowStatusTable=shelfTestRowStatusTable, shelfComponentName=shelfComponentName, shelfBusClockSourceStatusEntry=shelfBusClockSourceStatusEntry, shelfCardCpuUtilAvgMax=shelfCardCpuUtilAvgMax, shelfCardDiagRecErrLineRowStatusEntry=shelfCardDiagRecErrLineRowStatusEntry, modNodePrefixesTable=modNodePrefixesTable, modNodePrefixesEntry=modNodePrefixesEntry, shelfCardBusTapFrmSizeErrors=shelfCardBusTapFrmSizeErrors, shelfCardProductCode=shelfCardProductCode, shelfCardBusTapFrmCongestionErrors=shelfCardBusTapFrmCongestionErrors, shelfCardDiagRecErrLineIndex=shelfCardDiagRecErrLineIndex, shelfTestSetupEntry=shelfTestSetupEntry, shelfCardBusTapEndOfCellErrors=shelfCardBusTapEndOfCellErrors, shelfCardDcardComponentName=shelfCardDcardComponentName, shelfBusTestClockSourceTestResultsValue=shelfBusTestClockSourceTestResultsValue, shelfCardDiagRecErrLineStorageType=shelfCardDiagRecErrLineStorageType, shelfCardMsgBlockUsageAvg=shelfCardMsgBlockUsageAvg, shelfMIB=shelfMIB, shelfCardConfiguredLPsEntry=shelfCardConfiguredLPsEntry, shelfCardStateTable=shelfCardStateTable, shelfCardBusTapDependenciesInEffect=shelfCardBusTapDependenciesInEffect, shelfBusTestBroadcastTestResultsTable=shelfBusTestBroadcastTestResultsTable, shelfCardTestStateTable=shelfCardTestStateTable, shelfBusTestResultsEntry=shelfBusTestResultsEntry, shelfCardMemoryCapacityTable=shelfCardMemoryCapacityTable, shelfCardSelfTestFault=shelfCardSelfTestFault, modNodeName=modNodeName, modAlternatePorsPrefixesEntry=modAlternatePorsPrefixesEntry, shelfCardDcardType=shelfCardDcardType, shelfRowStatusEntry=shelfRowStatusEntry, shelfBus=shelfBus, shelfBusTestCauseOfTermination=shelfBusTestCauseOfTermination, shelfCardSparingConnection=shelfCardSparingConnection, shelfCardBusTapIndex=shelfCardBusTapIndex, shelfCardUtilTable=shelfCardUtilTable, shelfCardOperationalState=shelfCardOperationalState, shelfCardTestLoadingFrmDataResultsIndex=shelfCardTestLoadingFrmDataResultsIndex, shelfCardDiagRecErrRowStatus=shelfCardDiagRecErrRowStatus, shelfCardDiagIndex=shelfCardDiagIndex, shelfCardSparingConnectionStatus=shelfCardSparingConnectionStatus, shelfCardCurrentLpEntry=shelfCardCurrentLpEntry, shelfHardwareFailures=shelfHardwareFailures, shelfCardBusTapUsageState=shelfCardBusTapUsageState)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-ShelfMIB", shelfCardStateEntry=shelfCardStateEntry, shelfTestAutomaticBusClockTest=shelfTestAutomaticBusClockTest, shelfCardTestRowStatusTable=shelfCardTestRowStatusTable, shelfCardTestFrmPatternType=shelfCardTestFrmPatternType, shelfCardDiagTrapData=shelfCardDiagTrapData, shelfCapabilitiesBE01=shelfCapabilitiesBE01, shelfCardMemoryUsageValue=shelfCardMemoryUsageValue, shelfCardBusTapStorageType=shelfCardBusTapStorageType, shelfCardBusTapStateTable=shelfCardBusTapStateTable, shelfRowStatusTable=shelfRowStatusTable, shelfCardDiagRecErrLine=shelfCardDiagRecErrLine, shelfCapabilitiesBE01A=shelfCapabilitiesBE01A, shelfCardTestLoadingFrmDataPriorityIndex=shelfCardTestLoadingFrmDataPriorityIndex, shelfCardTestVerificationFrmDataPriorityIndex=shelfCardTestVerificationFrmDataPriorityIndex, shelfCardDiagStorageType=shelfCardDiagStorageType, shelfBusClockSourceStatusValue=shelfBusClockSourceStatusValue, shelfBusTestRowStatus=shelfBusTestRowStatus, shelfCardTestVerificationFrmDataTable=shelfCardTestVerificationFrmDataTable, shelfBusRowStatus=shelfBusRowStatus, shelfBusControlStatus=shelfBusControlStatus, shelfBusTestUsageState=shelfBusTestUsageState, modNamsId=modNamsId, shelfCardTestResultsEntry=shelfCardTestResultsEntry, shelfCardBusTapUnknownStatus=shelfCardBusTapUnknownStatus, shelfBusTestPingFailuresTxCardIndex=shelfBusTestPingFailuresTxCardIndex, shelfCardRowStatusEntry=shelfCardRowStatusEntry, shelfCardDcardDcardOperEntry=shelfCardDcardDcardOperEntry, shelfBusTestPingTestsEntry=shelfBusTestPingTestsEntry, shelfRowStatus=shelfRowStatus, modNodePrefixesIndex=modNodePrefixesIndex, shelfBusTestResultsTable=shelfBusTestResultsTable, shelfBusTestClockSourceTestResultsEntry=shelfBusTestClockSourceTestResultsEntry, shelfCardAdminState=shelfCardAdminState, shelfCardTestLoadingFrmDataTable=shelfCardTestLoadingFrmDataTable, shelfBusBusTapStatusTable=shelfBusBusTapStatusTable, shelfCardMemoryUsageAvgMaxIndex=shelfCardMemoryUsageAvgMaxIndex, shelfTestComponentName=shelfTestComponentName, shelfCardDiagTrapDataRowStatusTable=shelfCardDiagTrapDataRowStatusTable, shelfCardDiagRowStatus=shelfCardDiagRowStatus, shelfCardTestComponentName=shelfCardTestComponentName, shelfCardBusTapCardsTxTo=shelfCardBusTapCardsTxTo, shelfBusTest=shelfBusTest, shelfCardBusTapErrorsEntry=shelfCardBusTapErrorsEntry, shelfCardTestUsageState=shelfCardTestUsageState, shelfCardFailureCause=shelfCardFailureCause, shelfCardTestStorageType=shelfCardTestStorageType, shelfBusTestBroadcastTestResultsEntry=shelfBusTestBroadcastTestResultsEntry, shelfCardDiagTrapDataLineRowStatusEntry=shelfCardDiagTrapDataLineRowStatusEntry, shelfCardDiag=shelfCardDiag, shelfCardBusTapRowStatusEntry=shelfCardBusTapRowStatusEntry, shelfCardBusTapAlarmStatus=shelfCardBusTapAlarmStatus, shelfBusTestSetupTable=shelfBusTestSetupTable, shelfOperTable=shelfOperTable, shelfCardTestVerificationFrmDataValue=shelfCardTestVerificationFrmDataValue, shelfCardDiagTrapDataLineComponentName=shelfCardDiagTrapDataLineComponentName, shelfBusIndex=shelfBusIndex, shelfCardTestStateEntry=shelfCardTestStateEntry, shelfBusTestStateEntry=shelfBusTestStateEntry, modRowStatusEntry=modRowStatusEntry, shelfCardTestDuration=shelfCardTestDuration, shelfCardDiagTrapDataComponentName=shelfCardDiagTrapDataComponentName, shelfBusTestIndex=shelfBusTestIndex, shelfCardMemoryUsageAvgIndex=shelfCardMemoryUsageAvgIndex, shelfCardLocalMsgBlockUsageMin=shelfCardLocalMsgBlockUsageMin, shelfCardRowStatus=shelfCardRowStatus, shelfTestBusClockTestResult=shelfTestBusClockTestResult, shelfCardMemoryCapacityIndex=shelfCardMemoryCapacityIndex, modNodeId=modNodeId, shelfStorageType=shelfStorageType, shelfCardOperEntry=shelfCardOperEntry, shelfCardCardType=shelfCardCardType, shelfCardMsgBlockUsageAvgMax=shelfCardMsgBlockUsageAvgMax, modIndex=modIndex, shelfCardAlarmStatus=shelfCardAlarmStatus, shelfCardLocalMsgBlockUsageMax=shelfCardLocalMsgBlockUsageMax, shelfBusOperatingMode=shelfBusOperatingMode, shelfCardTestIndex=shelfCardTestIndex, shelfCardBusTap=shelfCardBusTap, shelfBusAlarmStatus=shelfBusAlarmStatus, shelfCardCpuUtilAvgMin=shelfCardCpuUtilAvgMin, shelfCardMemoryUsageAvgMaxTable=shelfCardMemoryUsageAvgMaxTable, shelfNumberOfSlots=shelfNumberOfSlots, shelfCardBusTapFailuresInEffect=shelfCardBusTapFailuresInEffect, shelfCardUtilEntry=shelfCardUtilEntry, shelfCardStorageType=shelfCardStorageType, shelfCardDcardRowStatusTable=shelfCardDcardRowStatusTable, shelfCardTestVerificationFrmDataResultsIndex=shelfCardTestVerificationFrmDataResultsIndex, shelfBusTestStateTable=shelfBusTestStateTable, shelfCardTestSizeValue=shelfCardTestSizeValue, shelfCardTestTimeRemaining=shelfCardTestTimeRemaining, shelfCardDiagTrapDataLineIndex=shelfCardDiagTrapDataLineIndex, shelfTestProvEntry=shelfTestProvEntry, shelfCardMsgBlockUsageAvgMin=shelfCardMsgBlockUsageAvgMin)

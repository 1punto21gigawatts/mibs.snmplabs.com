#
# PySNMP MIB module LIEBERT-GP-POWER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LIEBERT-GP-POWER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:47 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
liebertPowerModuleReg, lgpPower = mibBuilder.importSymbols("LIEBERT-GP-REGISTRATION-MIB", "liebertPowerModuleReg", "lgpPower")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, Integer32, Bits, ModuleIdentity, TimeTicks, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, IpAddress, Unsigned32, Counter32, Counter64, ObjectIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Integer32", "Bits", "ModuleIdentity", "TimeTicks", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "IpAddress", "Unsigned32", "Counter32", "Counter64", "ObjectIdentity", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
liebertGlobalProductsPowerModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 1, 6, 1))
liebertGlobalProductsPowerModule.setRevisions(('2013-07-10 00:00', '2008-11-17 00:00', '2008-07-02 00:00', '2008-01-10 00:00', '2006-02-22 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setRevisionsDescriptions(('Added support for GXT4 economic operation mode and outlet control.', 'Added support for NXL unit.', 'Replaced INTEGER with Integer32 (SMIv2). Minor spelling fixes and formatting.', 'Modified contact email address and removed redundant lgpPwrMeasurementPointNumLines.', 'Added support for Liebert DS Unit.',))
if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setLastUpdated('201307100000Z')
if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setOrganization('Liebert Corporation')
if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setContactInfo('Contact: Technical Support Postal: Liebert Corporation 1050 Dearborn Drive P.O. Box 29186 Columbus OH, 43229 US Tel: +1 (800) 222-5877 E-mail: liebert.monitoring@emerson.com Web: www.liebert.com Author: Gregory M. Hoge')
if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setDescription("The MIB module used to register Liebert POWER related SNMP OIDs. Copyright 2000-2008 Liebert Corporation. All rights reserved. Reproduction of this document is authorized on the condition that the forgoing copyright notice is included. This Specification is supplied 'AS IS' and Liebert Corporation makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification.")
lgpPwrBattery = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1))
if mibBuilder.loadTexts: lgpPwrBattery.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBattery.setDescription('This sub-tree is used to register Liebert Power Battery object identifiers.')
if mibBuilder.loadTexts: lgpPwrBattery.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Battery Group.')
lgpPwrMeasurements = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2))
if mibBuilder.loadTexts: lgpPwrMeasurements.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurements.setDescription('This sub-tree registers Liebert Power Measurement object identifiers. The sub-tree contains tables and well known power measurement points.')
if mibBuilder.loadTexts: lgpPwrMeasurements.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Measurement Group.')
lgpPwrStatus = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3))
if mibBuilder.loadTexts: lgpPwrStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStatus.setDescription('This sub-tree registers Liebert Power Status object identifiers. This is the location of power related status information that does not fit into a more specific category such as the lgpPwrConversion sub-tree.')
if mibBuilder.loadTexts: lgpPwrStatus.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Status Group')
lgpPwrSettings = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4))
if mibBuilder.loadTexts: lgpPwrSettings.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSettings.setDescription('This sub-tree registers Liebert Power Static Switch object identifiers.')
if mibBuilder.loadTexts: lgpPwrSettings.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Settings Group.')
lgpPwrConversion = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5))
if mibBuilder.loadTexts: lgpPwrConversion.setStatus('current')
if mibBuilder.loadTexts: lgpPwrConversion.setDescription('This sub-tree is used to register Liebert Power Conversion object identifiers.')
if mibBuilder.loadTexts: lgpPwrConversion.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Conversion Group.')
lgpPwrControl = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6))
if mibBuilder.loadTexts: lgpPwrControl.setStatus('current')
if mibBuilder.loadTexts: lgpPwrControl.setDescription('This sub-tree is used to register Liebert Power Control object identifiers.')
if mibBuilder.loadTexts: lgpPwrControl.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Control Group.')
lgpPwrTopology = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7))
if mibBuilder.loadTexts: lgpPwrTopology.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopology.setDescription('This sub-tree is used to register Liebert Power Topology object identifiers.')
if mibBuilder.loadTexts: lgpPwrTopology.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Topology Group.')
lgpPwrStatistic = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8))
if mibBuilder.loadTexts: lgpPwrStatistic.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStatistic.setDescription('This sub-tree is used to register Liebert Power Statistic object identifiers.')
if mibBuilder.loadTexts: lgpPwrStatistic.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Statistic Group.')
lgpPwrConfig = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9))
if mibBuilder.loadTexts: lgpPwrConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPwrConfig.setDescription('This sub-tree is used to register Liebert Power Configuration Object identifiers.')
if mibBuilder.loadTexts: lgpPwrConfig.setReference('The registrations for the objects in this sub-tree are defined below in the sub-section titled Liebert Power Configuration Group.')
lgpPwrNumberInstalledBatteryModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberInstalledBatteryModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberInstalledBatteryModules.setDescription('The number of battery modules installed in the device.')
lgpPwrNumberFailedBatteryModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberFailedBatteryModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberFailedBatteryModules.setDescription('The number of battery modules in the device that have failed.')
lgpPwrNumberRedundantBatteryModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberRedundantBatteryModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberRedundantBatteryModules.setDescription('The number of redundant battery modules in the device.')
lgpPwrNumberActiveBatteryModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberActiveBatteryModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberActiveBatteryModules.setDescription('The number of active battery modules in the device.')
lgpPwrConfigLowBatteryWarningTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 5), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrConfigLowBatteryWarningTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrConfigLowBatteryWarningTime.setDescription("The value of the device's estimated minutes of remaining battery at which a lgpEventLowBatteryWarning notification will be sent.")
lgpPwrNumberBatteryModuleWarnings = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberBatteryModuleWarnings.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberBatteryModuleWarnings.setDescription('The number of battery modules in the device that have a warning.')
lgpPwrBatteryCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 7), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCount.setDescription('The number of batteries installed.')
lgpPwrBatteryTestResult = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("systemFailure", 5), ("inhibited", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryTestResult.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryTestResult.setDescription('The outcome of the previous battery test.')
lgpPwrNominalBatteryCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 9), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrNominalBatteryCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNominalBatteryCapacity.setDescription('The nominal battery capacity of the system (in minutes) at full load.')
lgpPwrBatteryFloatVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 10), Integer32()).setUnits('Volt').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryFloatVoltage.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryFloatVoltage.setDescription('The battery float voltage of the system.')
lgpPwrBatteryEndOfDischargeVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryEndOfDischargeVoltage.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryEndOfDischargeVoltage.setDescription('The battery voltage threshold at which the batteries are considered completely discharged.')
lgpPwrAutomaticBatteryTestInterval = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 12), Integer32()).setUnits('hours').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTestInterval.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTestInterval.setDescription('The automatic battery test interval.')
lgpPwrAutomaticBatteryTestCountdown = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 13), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTestCountdown.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTestCountdown.setDescription('The time remaining before the next battery test.')
lgpPwrBatteryChargeStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fullycharged", 1), ("notfullycharged", 2), ("charging", 3), ("discharging", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryChargeStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryChargeStatus.setDescription("The present state of the system's battery charge. A value of 'charging' indicates the batteries are currently charging. A value of 'discharging' indicates the batteries are currently discharging. A value of 'fullycharged' indicates the batteries are charged to their full capacity. A value of 'notfullycharged' indicates the battery charge is neither fully charged, charging or discharging.")
lgpPwrBatteryLifeEnhancer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryLifeEnhancer.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryLifeEnhancer.setDescription("The state of the battery life enhancer. When 'on', it will preserve battery life.")
lgpPwrBatteryCharger = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCharger.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCharger.setDescription('The state of the battery charger.')
lgpPwrBatteryChargeMode = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("float", 1), ("equalize", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryChargeMode.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryChargeMode.setDescription("The mode of the battery charger: 'float' charging or 'equalize' charging.")
lgpPwrBatteryTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 18), Integer32()).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryTimeRemaining.setDescription('An estimate of the time to battery charge depletion under the present load conditions if the utility power is off and remains off, or if it were to be lost and remain off. NOTE: A UPS is expected to provide a battery time remaining value when not operating on battery. However, if the system is not capable of providing this information, then this point will return 65535 to indicate that the value is unavailable.')
lgpPwrBatteryCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 19), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCapacity.setDescription('The present percentage of battery capacity.')
lgpPwrBatteryCabinet = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20))
if mibBuilder.loadTexts: lgpPwrBatteryCabinet.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCabinet.setDescription('This sub-tree contains items related to battery cabinets.')
lgpPwrBatteryCabinetCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 1), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryCabinetCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCabinetCount.setDescription('The number of battery cabinets installed with this device. Note some devices may not permit writing a value to this object.')
lgpPwrBatteryCabinetType = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSpecified", 1), ("internal", 2), ("external", 3), ("lrt", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryCabinetType.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCabinetType.setDescription("The type of battery cabinet(s) installed on this device. Enumeration definitions: notSpecified - The type has not been specified in the device's configuration. internal - Battery cabinets are internal to the device. external - Device has external battery cabinets installed. lrt - Long Run Time cabinets. Note some devices may not permit writing a value to this object.")
lgpPwrBatteryCabinetRatedCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 3), Integer32()).setUnits('0.1 Amp-hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryCabinetRatedCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCabinetRatedCapacity.setDescription('Battery cabinet rated capacity (tenths of Amp-hours). This assumes that each cabinet is of the same type and capacity. This is not a sum of the rating for all attached cabinets. Note some devices may not permit writing a value to this object.')
lgpPwrBatteryLeadAcidCellCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 4), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryLeadAcidCellCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryLeadAcidCellCount.setDescription('Battery cell count - lead-acid. The number of cells that comprise the lead acid battery string.')
lgpPwrBatteryNiCadCellCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 5), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryNiCadCellCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryNiCadCellCount.setDescription('Battery cell count - nickel-cadmium. The number of cells that comprise the nickel-cadmium battery string.')
lgpPwrBatteryAmpHoursConsumed = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 21), Integer32()).setUnits('Amp-hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryAmpHoursConsumed.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryAmpHoursConsumed.setDescription('The cumulative battery Amp-hours withdrawn over the life of the battery. This value persists across reboots. Typically, this value is reset back to zero when the batteries are replaced.')
lgpPwrBatteryAmpHoursDischargeConsumed = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 22), Integer32()).setUnits('Amp-hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryAmpHoursDischargeConsumed.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryAmpHoursDischargeConsumed.setDescription('The battery Amp-hours withdrawn during the current/latest discharge. This value does not persist across reboots.')
lgpPwrBatteryLastDischargeTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 23), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryLastDischargeTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryLastDischargeTime.setDescription('The date and time of the last battery discharge. Typically this is the time when the discharge starts. This value persists across reboots. The date and time are determined in seconds since the epoch on January 1, 1970.')
lgpPwrBatteryLastCommissionTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 24), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryLastCommissionTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryLastCommissionTime.setDescription('The date and time when the battery system was put into service. This information persists across system reboot events. It is the responsibility of Service to reset this date/time when the batteries are replaced. The date and time are determined in seconds since the epoch on January 1, 1970.')
lgpPwrBatteryPresentDischargeTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 25), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryPresentDischargeTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryPresentDischargeTime.setDescription('The total time spent on battery during the current or last discharge. NOTE: While not discharging, some systems may display zero instead of the last discharge.')
lgpPwrBatteryCapacityStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("batteryNormal", 2), ("batteryLow", 3), ("batteryDepleted", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCapacityStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCapacityStatus.setDescription("The indication of the capacity remaining in the UPS system's batteries. NOTE: In a single-module system, this point is intended to have the same behavior as the RFC1628 point upsBatteryStatus.")
lgpPwrBatteryCircuitBreakerState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("open", 1), ("closed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCircuitBreakerState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCircuitBreakerState.setDescription('The state of the Battery Circuit Breaker.')
lgpPwrWellKnownMeasurementPoints = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1))
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementPoints.setStatus('current')
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementPoints.setDescription("This sub-tree registers well known Liebert Power Measurement Points. The object identifier names usually imply locations where the measurement is taken -- such as 'input', 'output' and 'bypass'.")
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementPoints.setReference("These well known measurement identifiers are referenced in the 'lgpPwrMeasurementPointId' column in the 'lgpPwrMeasurementPointTable'.")
lgpPwrSource1Input = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 1))
if mibBuilder.loadTexts: lgpPwrSource1Input.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSource1Input.setDescription("This sub-tree is used to register a source 1 input as a well known measurement point. It is intended that no sub-trees be created below this node. Power input to the managed device from power source 1. Many power systems contain more than one input source and many of them have more than one measurement point per input source. This identifier represents one input source for the system but does not necessarily represent the 'first' one. The input sources' numbering with respect to 'lgpPwrSource1Input' etc. may depend on the physical wiring of the system when it was installed.")
lgpPwrSource2Input = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 2))
if mibBuilder.loadTexts: lgpPwrSource2Input.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSource2Input.setDescription("This sub-tree is used to register a source 2 input as a well known measurement point. It is intended that no sub-trees be created below this node. Power input to the managed device from power source 2. Many power systems contain more than one input source and many of them have more than one measurement point per input source. This identifier represents one input source for the system but does not necessarily represent the 'first' one. The input sources' numbering with respect to 'lgpPwrSource2Input' etc. may depend on the physical wiring of the system when it was installed.")
lgpPwrSourcePdu1Input = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 3))
if mibBuilder.loadTexts: lgpPwrSourcePdu1Input.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSourcePdu1Input.setDescription("This sub-tree is used to register a source PDU 1 input as a well known measurement point. It is intended that no sub-trees be created below this node. Power input to the managed device from power distribution unit 1. Many power systems contain more than one input source and many of them have more than one measurement point per input source. This identifier represents one input source for the system but does not necessarily represent the 'first' one. The input sources' numbering with respect to 'lgpPwrSourcePdu1Input' etc. may depend on the physical wiring of the system when it was installed.")
lgpPwrSourcePdu2Input = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 4))
if mibBuilder.loadTexts: lgpPwrSourcePdu2Input.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSourcePdu2Input.setDescription("This sub-tree is used to register a source PDU 2 input as a well known measurement point. It is intended that no sub-trees be created below this node. Power input to the managed device from power distribution unit 1. Many power systems contain more than one input source and many of them have more than one measurement point per input source. This identifier represents one input source for the system but does not necessarily represent the 'first' one. The input sources' numbering with respect to 'lgpPwrSourcePdu2Input' etc. may depend on the physical wiring of the system when it was installed.")
lgpPwrOutputToLoad = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 5))
if mibBuilder.loadTexts: lgpPwrOutputToLoad.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputToLoad.setDescription('This sub-tree is used to register the output to the critical load as a well known measurement point. It is intended that no sub-trees be created below this node.')
lgpPwrMeasBattery = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 6))
if mibBuilder.loadTexts: lgpPwrMeasBattery.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasBattery.setDescription('This sub-tree is used to register a battery as a well known measurement point. It is intended that no sub-trees be created below this node.')
lgpPwrMeasBypass = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 7))
if mibBuilder.loadTexts: lgpPwrMeasBypass.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasBypass.setDescription('This sub-tree is used to register a bypass as a well known measurement point. It is intended that no sub-trees be created below this node.')
lgpPwrMeasDcBus = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 8))
if mibBuilder.loadTexts: lgpPwrMeasDcBus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasDcBus.setDescription('This sub-tree is used to register a DC bus as a well known measurement point. It is intended that no sub-trees be created below this node.')
lgpPwrMeasSystemOutput = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 9))
if mibBuilder.loadTexts: lgpPwrMeasSystemOutput.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasSystemOutput.setDescription('This sub-tree is used to register the output of a multi-module system as a well known measurement point. It is intended that no sub-trees be created below this node. This identifier represents the power related data of the system.')
lgpPwrMeasBatteryCabinet = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 10))
if mibBuilder.loadTexts: lgpPwrMeasBatteryCabinet.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasBatteryCabinet.setDescription("This sub-tree is used to register the voltage between the most negative and the most postive terminals of a battery cabinet. To determine the cabinet being described in a multi-cabinet system, this point implements an additional two indexes. The first index describes the module the cabinet is located in. The second index describes the cabinet number. In an SMS(Single-Module System) the first index is always 1. Example: lgpPwrMeasBatteryCabinet.2.4 'lgpPwrMeasBatteryCabinet' = Point is a battery cabinet. '.2' = Cabinet is in the second module. '.4' = Cabinet number 4")
lgpPwrMeasurementPointTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2), )
if mibBuilder.loadTexts: lgpPwrMeasurementPointTable.setReference("The measurement points represented by 'lgpPwrMeasurementPointId' can be found in the sub-tree lgpPwrWellKnownMeasurementPoints. Additional measurement detail on a 'per line' basis is available in the lgpPwrLineMeasurementTable")
if mibBuilder.loadTexts: lgpPwrMeasurementPointTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointTable.setDescription("This table contains a list of AC power measurement point entries. The table contains zero, one, or many rows, depending upon the number of power related measurement points available. The NMS cannot create or delete rows from the table. The rows are created by the agent based upon the capabilities of the managed device. Each row in the table represents a series of measurements on a given point or location within the system. Measurement points/locations are identified by the object identifier 'lgpPwrMeasurementPointId' in the 'LgpPwrMeasurementPointEntry' object. The actual measurement being taken at that identified point is identified by the other corresponding columns in the LgpPwrMeasurementPointEntry for the particular row of the table.")
lgpPwrMeasurementPointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrMeasurementPointIndex"))
if mibBuilder.loadTexts: lgpPwrMeasurementPointEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointEntry.setDescription("This entry defines the measurements to be populated in the various columns of the 'lgpPwrMeasurementPointTable'.")
lgpPwrMeasurementPointIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrMeasurementPointIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointIndex.setDescription("This is the index that indicates the row of the 'lgpPwrMeasurementPointTable' for a power measurement point.")
lgpPwrMeasurementPointId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointId.setReference("The object identifiers in this column can be found in the sub-tree 'lgpPwrWellKnownMeasurementPoints'.")
if mibBuilder.loadTexts: lgpPwrMeasurementPointId.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointId.setDescription("An OID representing a well known measurement point. These object identifiers indicate a point or location of power measurement in a power system. The OID's name usually implies a location of the measurement point such as 'input', 'output', 'bypass' etc.")
lgpPwrMeasurementPointNumLines = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 3), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNumLines.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNumLines.setDescription('The number of lines on the indicated power measurement point. (i.e. the number of phases on the power source being measured.)')
lgpPwrMeasurementPointNomVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 4), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomVolts.setDescription('The magnitude of the nominal voltage on the power source being measured.')
lgpPwrMeasurementPointNomFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 5), Integer32()).setUnits('Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomFrequency.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomFrequency.setDescription("The nominal or configured/expected frequency for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 6), Integer32()).setUnits('Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointFrequency.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointFrequency.setDescription("The present (actual) frequency for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointApparentPower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 7), Integer32()).setUnits('Volt-Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointApparentPower.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointApparentPower.setDescription("The present apparent AC power for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointTruePower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 8), Integer32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointTruePower.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointTruePower.setDescription("The present AC power for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 9), Integer32()).setUnits('.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointPowerFactor.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointPowerFactor.setDescription("The present Power Factor for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointWattHours = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 10), Integer32()).setUnits('Watt-Hour').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointWattHours.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointWattHours.setDescription("The present number of Watt Hours for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointVAPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 11), Integer32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointVAPercent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointVAPercent.setDescription("The percentage of the rated apparent AC power of the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNeutralCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 12), Integer32()).setUnits('Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNeutralCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNeutralCurrent.setDescription("The present neutral current of the power point indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointGroundCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 13), Integer32()).setUnits('0.1 Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointGroundCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointGroundCurrent.setDescription("The present ground current of the power point indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNomCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 14), Integer32()).setUnits('0.1 Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomCurrent.setDescription("The nominal or configured/expected current of the power point indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNomPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 15), Integer32()).setUnits('.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomPowerFactor.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomPowerFactor.setDescription("The nominal or configured/expected power factor of the power point indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNomVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 16), Integer32()).setUnits('Volt-Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomVA.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomVA.setDescription("The nominal or configured/expected apparent AC power for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNomW = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 17), Integer32()).setUnits('Watt').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomW.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomW.setDescription("The nominal or configured/expected true AC power for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointPowerFactorTag = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("leading", 1), ("lagging", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointPowerFactorTag.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointPowerFactorTag.setDescription("The present description of the Power Factor for the power source indicated by 'lgpPwrMeasurementPointId' in the corresponding row in the lgpPwrMeasurementPointTable. If Leading, the load is said to be capacitive and the phase of the current leads the voltage. If Lagging, the load is said to be inductive and the phase of the current lags the voltage.")
lgpPwrLineMeasurementTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3), )
if mibBuilder.loadTexts: lgpPwrLineMeasurementTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementTable.setDescription("A list of power measurements for each phase/line for a given power measurement point/location in the 'lgpPwrMeasurementPointTable'. The lgpPwrMeasurementPointIndex in this table corresponds to the index in the lgpPwrMeasurementPointTable. This table contains zero, one, or many rows, depending upon the number of power line source objects available. The NMS cannot create or delete rows from the table. The rows are created by the agent based upon the capabilities of the managed device.")
lgpPwrLineMeasurementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrMeasurementPtIndex"), (0, "LIEBERT-GP-POWER-MIB", "lgpPwrLineMeasurementIndex"))
if mibBuilder.loadTexts: lgpPwrLineMeasurementEntry.setReference('The lgpPwrMeasurementPointIndex can be found in the lgpPwrMeasurementPointTable. This index identifies the measurement point for which the line detail measurement in the table applies.')
if mibBuilder.loadTexts: lgpPwrLineMeasurementEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementEntry.setDescription("This entry defines the contents of the columns for the table 'lgpPwrLineMeasurementTable'.")
lgpPwrMeasurementPtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrMeasurementPtIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPtIndex.setDescription("This is the index indicating the row of the table 'lgpPwrMeasurementPointTable' for a power measurement point.")
lgpPwrLineMeasurementIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 2), Unsigned32())
if mibBuilder.loadTexts: lgpPwrLineMeasurementIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementIndex.setDescription("This is the index indicating the row of the table 'lgpPwrLineMeasurementTable' for a power measurement point.")
lgpPwrMeasurementPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPoint.setReference("The object identifiers in this column can be found in the sub-tree 'lgpPwrWellKnownMeasurementPoints' and correspond to the entry in the table lgpPwrMeasurementPointTable.")
if mibBuilder.loadTexts: lgpPwrMeasurementPoint.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPoint.setDescription("An OID representing a well known measurement point. These object identifiers indicate a point or location of power measurement in a power system. The OID name usually implies a location of the measurement point such as 'input', 'output', 'bypass', etc.")
lgpPwrLineMeasurementVoltsLL = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 4), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltsLL.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltsLL.setDescription('The present Line-to-Line voltage measurement for the indicated source. The line being measured is given by the lgpPwrLineMeasurementIndex [1 = AB, 2 = BC, 3 = CA].')
lgpPwrLineMeasurementVoltsLN = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 5), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltsLN.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltsLN.setDescription('The present Line-to-neutral voltage measurement for the indicated source. The line being measured is given by the lgpPwrLineMeasurementIndex where [1 = A, 2 = B, 3 = C].')
lgpPwrLineMeasurementCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 6), Integer32()).setUnits('Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementCurrent.setDescription("The present current measurement for the indicated source. The line being measured is given by the 'lgpPwrLineMeasurementIndex' where [1 = A, 2 = B, 3 = C].")
lgpPwrLineMeasurementCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 7), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementCapacity.setDescription('The percentage of the power capacity presently being used on this line.')
lgpPwrLineMeasurementVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 8), Integer32()).setUnits('Volt-Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVA.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVA.setDescription('The present apparent AC line power.')
lgpPwrLineMeasurementTruePower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 9), Integer32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementTruePower.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementTruePower.setDescription('The present AC line power measured in watts.')
lgpPwrLineMeasurementVoltageTHD = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 10), Integer32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltageTHD.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltageTHD.setDescription('The present total harmonic distortion on the AC line voltage.')
lgpPwrLineMeasurementCurrentTHD = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 11), Integer32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementCurrentTHD.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementCurrentTHD.setDescription('The present total harmonic distortion on the AC line current.')
lgpPwrLineMeasurementKFactorCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 12), Integer32()).setUnits('0.1 K Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementKFactorCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementKFactorCurrent.setDescription('The present line K Factor.')
lgpPwrLineMeasurementCrestFactorCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 13), Integer32()).setUnits('0.1 Crest Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementCrestFactorCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementCrestFactorCurrent.setDescription('The present crest factor of the line current.')
lgpPwrLineMeasurementPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 14), Integer32()).setUnits('0.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementPowerFactor.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementPowerFactor.setDescription('The present Power Factor for the line.')
lgpPwrLineMeasurementPowerFactorTag = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("leading", 1), ("lagging", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementPowerFactorTag.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementPowerFactorTag.setDescription('The present description of the Power Factor for the line. If Leading, the load is said to be capacitive and the phase of the current leads the voltage. If Lagging, the load is said to be inductive and the phase of the current lags the voltage.')
lgpPwrLineMeasurementMaxVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 16), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementMaxVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementMaxVolts.setDescription("The maximum voltage measurement recorded for the indicated source since the command 'lgpPwrStatisticsReset' was executed.")
lgpPwrLineMeasurementMinVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 17), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementMinVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementMinVolts.setDescription("The minimum voltage measurement recorded for the indicated source since the command 'lgpPwrStatisticsReset' was executed.")
lgpPwrLineMeasurementVAR = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 18), Integer32()).setUnits('Volt-Amp-Reactive').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVAR.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVAR.setDescription("The present reactive AC line power of the power source indicated by 'lgpPwrMeasurementPoint'.")
lgpPwrLineMeasurementPercentLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 19), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementPercentLoad.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementPercentLoad.setDescription('The present percent load of the AC line power.')
lgpPwrLineMeasurementVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 20), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVolts.setDescription('The present voltage measurement for the indicated source.')
lgpPwrLineMeasurementVACapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 21), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVACapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVACapacity.setDescription('The percentage of the apparent power capacity presently being used on this line.')
lgpPwrDcMeasurementPointTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4), )
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTable.setReference("The measurement points represented by 'lgpPwrDcMeasurementPointId' can be found in the sub-tree lgpPwrWellKnownMeasurementPoints. Additional measurement detail on a 'per line' basis is available in the lgpPwrLineMeasurementTable")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTable.setDescription("This table contains a list of DC power measurement point entries. The table contains zero, one, or many rows, depending upon the number of power related measurement points available. The NMS cannot create or delete rows from the table. The rows are created by the agent based upon the capabilities of the managed device. Each row in the table represents a series of measurements on a given point or location within the system. Measurement points/locations are identified by the object identifier 'lgpPwrDcMeasurementPointId' in the 'LgpPwrDcMeasurementPointEntry' object. The actual measurement being taken at that identified point is identified by the other corresponding columns in the LgpPwrDcMeasurementPointEntry for the particular row of the table.")
lgpPwrDcMeasurementPointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrDcMeasurementPointIndex"))
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointEntry.setDescription("This entry defines the measurements to be populated in the various columns of the 'lgpPwrDcMeasurementPointTable'.")
lgpPwrDcMeasurementPointIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointIndex.setDescription("This is the index that indicates the row of the 'lgpPwrMeasurementPointTable' for a power measurement point.")
lgpPwrDcMeasurementPointId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointId.setReference("The object identifiers in this column can be found in the sub-tree 'lgpPwrWellKnownMeasurementPoints'.")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointId.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointId.setDescription("An OID representing a well known measurement point. These object identifiers indicate a point or location of power measurement in a power system. The OID's name usually implies a location of the measurement point such as 'input', 'output', 'bypass' etc.")
lgpPwrDcMeasurementPointSubID = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 3), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointSubID.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointSubID.setDescription('The identifier used to differentiate between identical thresholds for a given point index and point ID in the DC measurements table.')
lgpPwrDcMeasurementPointVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 4), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointVolts.setDescription("The present DC voltage for the power source indicated by 'lgpPwrDcMeasurementPointId' in the corresponding row in the lgpPwrDcMeasurementPointTable.")
lgpPwrDcMeasurementPointCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 5), Integer32()).setUnits('Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointCurrent.setDescription("The present DC current for the power source indicated by 'lgpPwrDcMeasurementPointId' in the corresponding row in the lgpPwrDcMeasurementPointTable.")
lgpPwrDcMeasurementPointNomVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 6), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointNomVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointNomVolts.setDescription("The nominal(configured/expected) DC voltage for the power source indicated by 'lgpPwrDcMeasurementPointId' in the corresponding row in the lgpPwrDcMeasurementPointTable.")
lgpPwrDcMeasurementPointTruePower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 7), Integer32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTruePower.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTruePower.setDescription("The present DC power for the power source indicated by 'lgpPwrDcMeasurementPointId' in the corresponding row in the lgpPwrDcMeasurementPointTable.")
lgpPwrWellKnownMeasurementTypes = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 5))
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementTypes.setStatus('current')
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementTypes.setDescription("This sub-tree registers well known Liebert Power Measurement Types. The object identifier names usually encompass units of measure, lines of reference, and device location. The OID's name usually implies a measurement type such as 'voltsAC', 'current', 'voltsDc', 'VoltsLL', etc.")
lgpPwrVoltsAc = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 5, 1))
if mibBuilder.loadTexts: lgpPwrVoltsAc.setStatus('current')
if mibBuilder.loadTexts: lgpPwrVoltsAc.setDescription('This identifier represents an AC voltage.')
lgpPwrVoltsDc = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 5, 2))
if mibBuilder.loadTexts: lgpPwrVoltsDc.setStatus('current')
if mibBuilder.loadTexts: lgpPwrVoltsDc.setDescription('This identifier represents a DC voltage.')
lgpPwrAmpsNeutral = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 5, 3))
if mibBuilder.loadTexts: lgpPwrAmpsNeutral.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAmpsNeutral.setDescription('This identifier represents a current measurement in Amps on the neutral line.')
lgpPwrWellKnownControlPoints = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 1))
if mibBuilder.loadTexts: lgpPwrWellKnownControlPoints.setStatus('current')
if mibBuilder.loadTexts: lgpPwrWellKnownControlPoints.setDescription("This sub-tree registers well known Liebert Power Control Points. The object identifier names usually imply locations where control of a device is available -- such 'output' or 'load circuits'.")
if mibBuilder.loadTexts: lgpPwrWellKnownControlPoints.setReference("These well known control identifiers are referenced in the 'lgpPwrLoadCircuitId' column in the 'lgpPwrLoadCircuitTable'.")
lgpPwrLoadCircuit = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 1, 1))
if mibBuilder.loadTexts: lgpPwrLoadCircuit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuit.setDescription("The managed device's controllable load circuit. Many power systems contain more than one load circuit. This identifier represents one load circuit for the system but does not necessarily represent the 'first' one. The load circuits' numbering with respect to 'lgpPwrLoadCircuit1' etc. may depend on the physical wiring of the system when it was installed.")
lgpPwrLoadCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2), )
if mibBuilder.loadTexts: lgpPwrLoadCircuitTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitTable.setDescription('A list of load circuits that can be controlled(opened or closed). The NMS cannot create or delete rows from the table. The rows are created by the agent based upon the capabilities of the managed device.')
lgpPwrLoadCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrLoadCircuitIndex"))
if mibBuilder.loadTexts: lgpPwrLoadCircuitEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitEntry.setDescription("This entry defines the contents of the columns for the table 'lgpPwrLoadCircuitTable'.")
lgpPwrLoadCircuitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrLoadCircuitIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitIndex.setDescription("This is the index indicating the row of the table 'lgpPwrLoadCircuitTable'.")
lgpPwrLoadCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLoadCircuitId.setReference("The object identifiers in this column can be found in the sub-tree 'lgpPwrWellKnownMeasurementPoints'.")
if mibBuilder.loadTexts: lgpPwrLoadCircuitId.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitId.setDescription('An OID representing a well known load circuit identifier. These load circuit identifiers indicate the name or type of load circuit reference in the table.')
lgpPwrLoadCircuitSubID = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLoadCircuitSubID.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitSubID.setDescription("This is a sub identifier for the 'lgpPwrLoadCircuitId'. It indicates the hardware identifier of the load control circuit.")
lgpPwrLoadCircuitState = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrLoadCircuitState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitState.setDescription('This identifier indicates the state of the load circuit. When read, only a closed or open response will be returned. When written to, the state of the circuit will transition to desired state.')
lgpPwrLoadCircuitStateAndControl = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("reboot", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrLoadCircuitStateAndControl.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitStateAndControl.setDescription('This identifier indicates the state of the load circuit. When read, only a closed or open response will be returned. When written to, the state of the circuit will transition to desired state.')
lgpPwrAlarmSilence = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAlarmSilence.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAlarmSilence.setDescription("Audible Alarm Silence Command. This command turns off the device's audible alarm. It will not affect the status of the alarm(s) that caused the audible alarm. This command should be sent with a parameter of 1. This variable doesn't return a value when read.")
lgpPwrBatteryTest = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("abort", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryTest.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryTest.setDescription('Battery Test Command. This command will initiate a battery test if one is not already in progress, or abort the current test if it is in progress.')
lgpPwrUpsAbortCommand = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUpsAbortCommand.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsAbortCommand.setDescription("UPS Abort command. This command will abort the pending command on the device. There is no guarantee a client using the abort command will cancel a command sent moments before from the same client. Another client could initiate a command and change what command is actually pending on the device. This command should be sent with a parameter of 1. This variable doesn't return a value when read.")
lgpPwrTransferToBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrTransferToBypass.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTransferToBypass.setDescription("Transfer to Bypass Command. This command will initiate a transfer of the load to the bypass of the system. This command should be sent with a parameter of 1. This variable doesn't return a value when read.")
lgpPwrTransferToInverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrTransferToInverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTransferToInverter.setDescription("Transfer to Inverter Command. This command will initiate a transfer of the load to the inverter of the system. This command should be sent with a parameter of 1. This variable doesn't return a value when read.")
lgpPwrOutputOnDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 8), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrOutputOnDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputOnDelay.setDescription('Output On Delay Command. This command will turn on the output of the device after a user specified delay. The number of seconds to delay is subject to the precision of the device and should be kept to 10 second intervals.')
lgpPwrOutputOffDelayWithRestart = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 9), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrOutputOffDelayWithRestart.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputOffDelayWithRestart.setDescription('Output Off Delay with Restart Command. This command will turn off the output of the device after a user specified delay. The number of seconds to delay is subject to the precision of the device and should be kept to 10 second intervals. The device will then turn the output on again after a specified amount of time. ')
lgpPwrOutputOffDelayWithoutRestart = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 10), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrOutputOffDelayWithoutRestart.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputOffDelayWithoutRestart.setDescription('Output Off Delay without Restart Command. This command will turn off the output of the device after a specified delay. The number of seconds to delay is subject to the precision of the device and should be kept to 10 second intervals. The device will NOT automatically turn the output on following this command.')
lgpPwrTransferCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 1), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTransferCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTransferCount.setDescription('Number of times that the output load has been transferred between the available input sources.')
lgpPwrAutoTransferTimer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 2), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrAutoTransferTimer.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutoTransferTimer.setDescription('The required wait time between output load auto transfer attempts between available input sources.')
lgpPwrAutoReTransferEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrAutoReTransferEnabled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutoReTransferEnabled.setDescription("The ability to retransfer the output load automatically to the well known measurement source from the 'lgpPwrWellKnownMeasurements' sub-tree that is the preferred input source of the system")
lgpPwrSyncPhaseAngle = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-3600, 3600))).setUnits('0.1 Degrees').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrSyncPhaseAngle.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSyncPhaseAngle.setDescription('The phase angle difference of source 1 in relation to source 2.')
lgpPwrParallelSystemOutputToLoadSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("utility", 1), ("battery", 2), ("bypass", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrParallelSystemOutputToLoadSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrParallelSystemOutputToLoadSource.setDescription("The source supporting the parallel system's load.")
lgpPwrDcToDcConverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcToDcConverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcToDcConverter.setDescription('The state of the DC to DC converter.')
lgpPwrOutputToLoadOnInverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrOutputToLoadOnInverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputToLoadOnInverter.setDescription('The present source of output power is the Inverter.')
lgpPwrBatteryChargeCompensating = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryChargeCompensating.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryChargeCompensating.setDescription('The system is adjusting the battery charging algorithm to accommodate for the battery temperature.')
lgpPwrInverterReady = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrInverterReady.setStatus('current')
if mibBuilder.loadTexts: lgpPwrInverterReady.setDescription('The ability of the inverter to support the output load of the system.')
lgpPwrOutputToLoadOnBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrOutputToLoadOnBypass.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputToLoadOnBypass.setDescription('The present source of output power is the Bypass.')
lgpPwrBoost = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBoost.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBoost.setDescription('The present state of the boost circuitry')
lgpPwrBuck = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBuck.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBuck.setDescription('The present state of the buck circuitry')
lgpPwrShutdownOverTemperature = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownOverTemperature.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownOverTemperature.setDescription('The system has previously shutdown due to an over temperature condition.')
lgpPwrShutdownOverload = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownOverload.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownOverload.setDescription('The system has previously shutdown due to an over load condition.')
lgpPwrShutdownDcBusOverload = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownDcBusOverload.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownDcBusOverload.setDescription('The system has previously shutdown due to a DC bus over load condition.')
lgpPwrShutdownOutputShort = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownOutputShort.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownOutputShort.setDescription('The system has previously shutdown due to an output short condition.')
lgpPwrShutdownLineSwap = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownLineSwap.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownLineSwap.setDescription('The system has previously shutdown due to a condition where the line and neutral were reversed.')
lgpPwrShutdownLowBattery = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownLowBattery.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownLowBattery.setDescription('The system has previously shutdown due to a low battery condition.')
lgpPwrShutdownRemote = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownRemote.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownRemote.setDescription('The system has previously shutdown due to a remote shutdown command.')
lgpPwrShutdownInputUnderVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownInputUnderVoltage.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownInputUnderVoltage.setDescription('The system has previously shutdown due to an under voltage condition during startup.')
lgpPwrShutdownPowerFactorCorrectionFailure = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownPowerFactorCorrectionFailure.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownPowerFactorCorrectionFailure.setDescription('The system has previously shutdown due to a power factor correction startup failure.')
lgpPwrShutdownHardware = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownHardware.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownHardware.setDescription('The system has previously shutdown due external shutdown signal.')
lgpPwrRedundantSubModule = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRedundantSubModule.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRedundantSubModule.setDescription('The system has a redundant battery module installed.')
lgpPwrBypassReady = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBypassReady.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBypassReady.setDescription('The ability of the bypass to support the output load of the system. If Yes, the bypass is available to transfer to.')
lgpPwrGeneratorStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("disconnected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrGeneratorStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrGeneratorStatus.setDescription('The state of the system generator.')
lgpPwrRotaryBreakerStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("closed", 2), ("test", 3), ("normal", 4), ("bypass", 5), ("maintenance", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRotaryBreakerStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRotaryBreakerStatus.setDescription('The state of the system rotary breaker.')
lgpPwrPowerFactorCorrection = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrPowerFactorCorrection.setStatus('current')
if mibBuilder.loadTexts: lgpPwrPowerFactorCorrection.setDescription('The state of the power factor correction circuitry of the system.')
lgpPwrBypassSyncDiff = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 28), Integer32()).setUnits('0.1 Degrees').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBypassSyncDiff.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBypassSyncDiff.setDescription('The phase angle difference between the inverter output and bypass source. A positive value means the inverter leads the bypass source. A negative value means the inverter lags the bypass source.')
lgpPwrBypassOverloadShutdownTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 29), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBypassOverloadShutdownTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBypassOverloadShutdownTime.setDescription('The calculated time remaining before bypass static switch shutdown due to the present overload condition. If the bypass is not in an overload condition, this object returns -1.')
lgpPwrInverterOverloadShutdownTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 30), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrInverterOverloadShutdownTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrInverterOverloadShutdownTime.setDescription('The calculated time remaining before inverter shutdown. The calculated time of inverter operation remaining for the present overload event. Note: If the inverter is not experiencing an overload event this point will return 65535 indicating this value is unavailable.')
lgpPwrStateOutputSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("inverter", 2), ("bypass", 3), ("maintenanceBypass", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutputSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutputSource.setDescription("The UPS's output power source (inverter, bypass, or none). NOTE: It is possible that the load still has power from the Maintenance Bypass.")
lgpPwrStateInputSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("utility", 2), ("generator", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInputSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInputSource.setDescription('The system input power source (none, utility, generator).')
lgpPwrStateInputQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInputQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInputQualification.setDescription("The current state of the system input. The unit may or may not operate normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateBypassStaticSwitchState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBypassStaticSwitchState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBypassStaticSwitchState.setDescription('The current state of the bypass static switch.')
lgpPwrStateBypassQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBypassQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBypassQualification.setDescription("The current operational state of the bypass static switch. The unit may or may not operate normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateDCBusQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateDCBusQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateDCBusQualification.setDescription("The current operational state of the DC bus. The unit may or may not operate normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateOutQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutQualification.setDescription("The current operational state of the output. The unit may or may not operate normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateInverterQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInverterQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInverterQualification.setDescription("The current operational state of the inverter. The unit may or may not operate normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateInverterState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInverterState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInverterState.setDescription('The current state of the inverter.')
lgpPwrStateRectifierState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateRectifierState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateRectifierState.setDescription('The current state of the rectifier.')
lgpPwrStateModuleGroup = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 41))
if mibBuilder.loadTexts: lgpPwrStateModuleGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateModuleGroup.setDescription('This group contains UPS module information.')
lgpPwrStateUpsModuleCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 41, 1), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrStateUpsModuleCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateUpsModuleCount.setDescription('Number of UPS modules in the system. In a single module system, this value is one.')
lgpPwrStateUpsModuleRedundantCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 41, 2), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateUpsModuleRedundantCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateUpsModuleRedundantCount.setDescription('Number of redundant UPS modules in the system. In a single module system, the value is zero. This value is dependent upon the present load and the number of modules (i.e. the value may change during normal operation based upon a load change). This value represents the number of extra modules above the minimum needed to support the load.')
lgpPwrStateBackfeedBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBackfeedBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBackfeedBrkrState.setDescription('The state of the Static Bypass Switch Line Disconnect Breaker.')
lgpPwrStateLoadDisconnectState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateLoadDisconnectState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateLoadDisconnectState.setDescription('The state of the Static Bypass Switch Load Disconnect Breaker.')
lgpPwrStateInputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInputBrkrState.setDescription('The state of the Input Disconnect Breaker.')
lgpPwrStateTrapFilterBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateTrapFilterBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateTrapFilterBrkrState.setDescription('The state of the Trap Filter Disconnect Breaker.')
lgpPwrStateInvOutputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInvOutputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInvOutputBrkrState.setDescription('The state of the Inverter Output Disconnect Breaker.')
lgpPwrStateIntBypassBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateIntBypassBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateIntBypassBrkrState.setDescription('The state of the Internal Bypass Breaker.')
lgpPwrStateBypassIsolBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBypassIsolBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBypassIsolBrkrState.setDescription('The state of the Bypass Isolation Breaker.')
lgpPwrStateRectifierIsolBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateRectifierIsolBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateRectifierIsolBrkrState.setDescription('The state of the Rectifier Isolation Breaker.')
lgpPwrStateMaintBypassBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateMaintBypassBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateMaintBypassBrkrState.setDescription('The state of the Maintenance Bypass Breaker.')
lgpPwrStateMaintIsolBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateMaintIsolBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateMaintIsolBrkrState.setDescription('The state of the Maintenance Isolation Breaker.')
lgpPwrStateOutStaticSwState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutStaticSwState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutStaticSwState.setDescription('The state of the Output Series Static Switch.')
lgpPwrStateModuleOutBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateModuleOutBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateModuleOutBrkrState.setDescription('The state of the Module Output Breaker.')
lgpPwrBypassReXfrRemainTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 54), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBypassReXfrRemainTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBypassReXfrRemainTime.setDescription('The time remaining before an inverter overload or inverter fault can be cleared and auto retransfer from the bypass to the inverter can take place. Note: If an inverter overload or fault is not taking place, this point will return 65535.')
lgpPwrStateUpsOutputSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("normal", 3), ("bypass", 4), ("battery", 5), ("booster", 6), ("reducer", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateUpsOutputSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateUpsOutputSource.setDescription('The present source of output power. The enumeration none(2) indicates that there is no source of output power (and therefore no output power), for example, the system has opened the output breaker. NOTE: In a single-module system, this point is intended to have the same behavior as the RFC1628 point upsOutputSource.')
lgpPwrStateLoadBusSynchronization = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("active", 1), ("abnormal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateLoadBusSynchronization.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateLoadBusSynchronization.setDescription('The state of the Load Bus Synchronizer (LBS).')
lgpPwrStateCircuitBrkrStateGroup = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57))
if mibBuilder.loadTexts: lgpPwrStateCircuitBrkrStateGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateCircuitBrkrStateGroup.setDescription('This group contains Static Switch circuit breaker state information.')
lgpPwrStateSource1InputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource1InputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource1InputBrkrState.setDescription('The states of Source 1 Input Breaker.')
lgpPwrStateSource2InputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource2InputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource2InputBrkrState.setDescription('The states of Source 2 Input Breaker.')
lgpPwrStateSource1BypassBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource1BypassBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource1BypassBrkrState.setDescription('The states of Source 1 Bypass Breaker.')
lgpPwrStateSource2BypassBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource2BypassBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource2BypassBrkrState.setDescription('The states of Source 2 Bypass Breaker.')
lgpPwrStateOutputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutputBrkrState.setDescription('The states of Output Breaker.')
lgpPwrStateAuxOutputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateAuxOutputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateAuxOutputBrkrState.setDescription('The states of Auxiliary Output Breaker.')
lgpPwrStateSource1PduInputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource1PduInputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource1PduInputBrkrState.setDescription('The states of Source 1 PDU Input Breaker.')
lgpPwrStateSource2PduInputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource2PduInputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource2PduInputBrkrState.setDescription('The states of Source 2 PDU Input Breaker.')
lgpPwrEconomicOperation = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrEconomicOperation.setStatus('current')
if mibBuilder.loadTexts: lgpPwrEconomicOperation.setDescription('The present state of ECO mode operation, on(1) if system is on bypass due to ECO mode operation, off(0) any other time.')
lgpPwrPreferredSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 1), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrPreferredSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrPreferredSource.setDescription("The well known measurement source from the 'lgpPwrWellKnownMeasurements' sub-tree that is the preferred input source of the system.")
lgpPwrLoadOnSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLoadOnSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadOnSource.setDescription("The well known measurement source from the 'lgpPwrWellKnownMeasurements' sub-tree that is currently powering the output (load).")
lgpPwrNominalVoltageDeviation = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 3), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNominalVoltageDeviation.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNominalVoltageDeviation.setDescription('The nominal voltage deviation between the well known measurement source lgpPwrSource1Input and lgpPwrSource2Input.')
lgpPwrNominalVoltageDeviationPercent = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 4), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNominalVoltageDeviationPercent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNominalVoltageDeviationPercent.setDescription('The percentage of the nominal voltage deviation between the well known measurement source lgpPwrSource1Input and lgpPwrSource2Input.')
lgpPwrPhaseDifferenceLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 5), Integer32()).setUnits('0.1 Degrees').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrPhaseDifferenceLimit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrPhaseDifferenceLimit.setDescription('The maximum phase difference (between the well known input sources ) in which a transfer to an available input source is permitted.')
lgpPwrFrequencyDeviationLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 6), Integer32()).setUnits('0.1 Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrFrequencyDeviationLimit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrFrequencyDeviationLimit.setDescription('The maximum frequency deviation (between the well known input sources ) in which a transfer to an available input source is permitted.')
lgpPwrThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7), )
if mibBuilder.loadTexts: lgpPwrThresholdTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdTable.setDescription("A list of power thresholds for a given power measurement at a point/location in the system. The lgpPwrThresholdType in this table corresponds to the type of measurement the high and low thresholds applies to. This table contains zero, one, or many rows, depending upon the number of 'lgpPwrThresholdPoint' and 'lgpPwrThresholdSubID' available in the table. The NMS cannot create or delete rows from the table. The rows are created by the agent based upon the capabilities of the managed device.")
lgpPwrThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrThresholdIndex"))
if mibBuilder.loadTexts: lgpPwrThresholdEntry.setReference('The lgpPwrThresholdType in this table corresponds to the type of measurement the high and low thresholds applies to.')
if mibBuilder.loadTexts: lgpPwrThresholdEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdEntry.setDescription("This entry defines the contents of the columns for the table 'lgpPwrThresholdTable'.")
lgpPwrThresholdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrThresholdIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdIndex.setDescription("This is the index indicating the row of the table 'lgpPwrLineMeasurementTable' for a power measurement point.")
lgpPwrThresholdPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrThresholdPoint.setReference("The object identifiers in this column can be found in the sub-tree 'lgpPwrWellKnownMeasurementPoints' and correspond to the entry in the table 'lgpPwrThresholdTable'.")
if mibBuilder.loadTexts: lgpPwrThresholdPoint.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdPoint.setDescription("An OID representing a well known measurement point. These object identifiers indicate a point or location of power measurement in a power system. The OID's name usually implies a location of the measurement point such as 'input', 'output', 'bypass' etc.")
lgpPwrThresholdSubID = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrThresholdSubID.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdSubID.setDescription("This is a sub identifier for the 'lgpPwrThresholdPoint'. It indicates the instance number of the well known threshold point.")
lgpPwrThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrThresholdType.setReference("The object identifiers in this column can be found in the sub-tree 'lgpPwrWellKnownThresholdTypes' and correspond to the entry in the table lgpPwrThresholdTable.")
if mibBuilder.loadTexts: lgpPwrThresholdType.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdType.setDescription("An OID representing a well known measurement type. These object identifiers indicate the type of measurement referenced by the row of the table. These object identifiers can encompass units of measure, lines of reference, and device location. The OID's name usually implies a measurement type such as 'voltsAc', 'current', 'voltsDc', 'VoltsLL', etc.")
lgpPwrThresholdHighWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrThresholdHighWarning.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdHighWarning.setDescription("The high warning threshold of a type of measurement designated by the 'lgpPwrThresholdType' at a location designated by the 'lgpPwrThresholdPoint'. If multiple thresholds are available at a single 'lgpPwrThresholdPoint', of the same 'lgpPwrThresholdType', then the 'lgpPwrThresholdSubID' will differentiate between them. When this threshold is met, the agent will send a notification.")
lgpPwrThresholdHighFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrThresholdHighFailure.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdHighFailure.setDescription("The high failure threshold of a type of measurement designated by the 'lgpPwrThresholdType' at a location designated by the 'lgpPwrThresholdPoint'. If multiple thresholds are available at a single 'lgpPwrThresholdPoint', of the same 'lgpPwrThresholdType', then the 'lgpPwrThresholdSubID' will differentiate between them. When this threshold is met, the agent will send a notification.")
lgpPwrThresholdLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrThresholdLowWarning.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdLowWarning.setDescription("The low warning threshold of a type of measurement designated by the 'lgpPwrThresholdType' at a location designated by the 'lgpPwrThresholdPoint'. If multiple thresholds are available at a single 'lgpPwrThresholdPoint', of the same 'lgpPwrThresholdType', then the 'lgpPwrThresholdSubID' will differentiate between them. When this threshold is met, the agent will send a notification.")
lgpPwrThresholdLowFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrThresholdLowFailure.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdLowFailure.setDescription("The low failure threshold of a type of measurement designated by the 'lgpPwrThresholdType' at a location designated by the 'lgpPwrThresholdPoint'. If multiple thresholds are available at a single 'lgpPwrThresholdPoint', of the same 'lgpPwrThresholdType', then the 'lgpPwrThresholdSubID' will differentiate between them. When this threshold is met, the agent will send a notification.")
lgpPwrUpsAutoRestart = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUpsAutoRestart.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsAutoRestart.setDescription('The device will automatically restart when utility power is restored following a battery discharge.')
lgpPwrUpsAutoRestartDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 9), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUpsAutoRestartDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsAutoRestartDelay.setDescription('The device will automatically delay a certain number of seconds and then restart after utility power is restored following a battery discharge. The number of seconds to delay is subject to the precision of the device and should be kept to 10 second intervals.')
lgpPwrAutoRestartBatteryChargeThreshold = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 10), Integer32()).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAutoRestartBatteryChargeThreshold.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutoRestartBatteryChargeThreshold.setDescription('The battery charge percentage required before the device can automatically restart.')
lgpPwrParallelModuleCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 11), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrParallelModuleCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrParallelModuleCount.setDescription('The number of modules in the parallel system.')
lgpPwrParallelRedundancyCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 12), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrParallelRedundancyCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrParallelRedundancyCount.setDescription('The number of redundant modules in the parallel system.')
lgpPwrLoadBusSyncMode = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrLoadBusSyncMode.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadBusSyncMode.setDescription('The configuration of Load Bus Synchronization (LBS) between independent systems.')
lgpPwrEconomicOperationMode = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrEconomicOperationMode.setStatus('current')
if mibBuilder.loadTexts: lgpPwrEconomicOperationMode.setDescription('The configuration of the economic operation mode of the system.')
lgpPwrAutomaticBatteryTest = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTest.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTest.setDescription("Automatic battery test option. If enabled, the battery will be tested on a fixed interval. If disabled, the battery test must be initiated by a battery test command. The interval at which a battery test is performed is defined by 'lgpPwrAutomaticBatteryTestInterval'.")
lgpPwrMinimumRedundantPowerModule = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 16), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrMinimumRedundantPowerModule.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMinimumRedundantPowerModule.setDescription('The minimum number of redundant power modules that must be present before sending a loss of power redundancy alarm. If 0, there is no redundant power functionality.')
lgpPwrMinimumRedundantBatteryModule = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 17), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrMinimumRedundantBatteryModule.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMinimumRedundantBatteryModule.setDescription('The minimum number of redundant battery modules that must be present before sending an alarm. If 0, the redundant battery module alarm is disabled.')
lgpPwrOutputToLoadUserOverloadLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 18), Integer32()).setUnits('Volt-Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrOutputToLoadUserOverloadLimit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputToLoadUserOverloadLimit.setDescription('This is the user specified maximum load the device can support without sending an alarm.')
lgpPwrNoLoadWarningLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 19), Integer32()).setUnits('Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrNoLoadWarningLimit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNoLoadWarningLimit.setDescription("The minimum current draw on the output in which the device considers there to be a load present on the output. The condition lgpConditionWarningNoLoadDetected will be triggered if the output current falls below this value. If this value is '-1' then the lgpConditionNoLoadDetectedWarning condition is 'disabled'.")
lgpPwrNoLoadWarningDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrNoLoadWarningDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNoLoadWarningDelay.setDescription('The amount of time to delay before annunciation of the condition lgpConditionNoLoadDetectedWarning after the output current load falls below the threshold lgpPwrOutputNoLoadWarningLimit.')
lgpPwrEconomicOperationModeControl = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("mode1", 1), ("mode2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrEconomicOperationModeControl.setStatus('current')
if mibBuilder.loadTexts: lgpPwrEconomicOperationModeControl.setDescription('The configuration of the economic operation mode of the system. Note that this supersedes lgpPwrEconomicOperationMode in newer devices.')
lgpPwrBrownOutCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 1), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBrownOutCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBrownOutCount.setDescription("The number of occurrences where the input line voltage has fallen below a pre-determined threshold for a specified amount of time. This number resets when the command 'lgpPwrStatisticsReset' is executed.")
lgpPwrBlackOutCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 2), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBlackOutCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBlackOutCount.setDescription("The number of occurrences where there is a total loss of electric power. This number resets when the command 'lgpPwrStatisticsReset' is executed.")
lgpPwrTransientCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 3), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTransientCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTransientCount.setDescription("The number of occurrences where the input line voltage spikes above a pre-determined threshold for a specified amount of time. This number resets when the command 'lgpPwrStatisticsReset' is executed.")
lgpPwrBatteryDischargeCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 4), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryDischargeCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryDischargeCount.setDescription('The number of battery discharges since the last reset.')
lgpPwrBatteryDischargeTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 5), Integer32()).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryDischargeTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryDischargeTime.setDescription('The total accumulated time spent on battery since the last reset.')
lgpPwrBatteryAmpHours = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 6), Integer32()).setUnits('Amp-hour').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryAmpHours.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryAmpHours.setDescription('The total accumulated Amp-hours removed from the battery since last reset.')
lgpPwrBatteryWattHours = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 7), Integer32()).setUnits('Watt-Hour').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryWattHours.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryWattHours.setDescription("The total accumulated Watt-Hours removed from the battery since last reset. This command should be sent with a parameter of 1. This variable doesn't return a value when read.")
lgpPwrBatteryStatisticsReset = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryStatisticsReset.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryStatisticsReset.setDescription("Battery statistics clear command. The command to reset all battery statistics stored by the device. This command should be sent with a parameter of 1. This variable doesn't return a value when read.")
lgpPwrStatisticsReset = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrStatisticsReset.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStatisticsReset.setDescription("Reset Power Statistics Command. This command will reset the power statistics stored in the system. This command should be sent with a parameter of 1. This variable doesn't return a value when read.")
lgpPwrNumberInstalledPowerModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 1), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberInstalledPowerModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberInstalledPowerModules.setDescription('The number of power modules installed in the device.')
lgpPwrNumberFailedPowerModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 2), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberFailedPowerModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberFailedPowerModules.setDescription('The number of power modules in the device that have failed.')
lgpPwrNumberRedundantPowerModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 3), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberRedundantPowerModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberRedundantPowerModules.setDescription('The number of redundant power modules installed in the device.')
lgpPwrNumberActivePowerModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 4), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberActivePowerModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberActivePowerModules.setDescription('The number of active power modules in the device.')
lgpPwrNumberPowerModuleWarnings = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 6), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberPowerModuleWarnings.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberPowerModuleWarnings.setDescription('The number of power modules in the device that have a warning.')
lgpPwrUpsInverterStandby = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUpsInverterStandby.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsInverterStandby.setDescription('The output to the load is supported by the bypass and the inverter is on standby.')
lgpPwrUpsTopOffline = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrUpsTopOffline.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsTopOffline.setDescription('The UPS has an offline topology. Under normal operating conditions, AC power from the utility passes straight through the UPS to the critical load. The inverter is used to convert the DC power from the battery to create AC power to support the load when the utility fails. Normally the inverter is operating in the stand-by mode, keeping the batteries charged. Should the utility power go out of specification, the inverter will power the load by drawing energy from the battery.')
lgpPwrUpsTopLineInteractive = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrUpsTopLineInteractive.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsTopLineInteractive.setDescription('The UPS has a line-interactive topology. This topology resembles the offline product, but inserts a transformer or inductor in series between the utility power source and the load. This inline inductor enables the UPS inverter to interact with incoming power and provide a measure of power conditioning to the load. This buck-and-boost circuitry helps with high and low input voltage conditions.')
lgpPwrUPSTopDualInput = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrUPSTopDualInput.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUPSTopDualInput.setDescription('The system has separate input sources for the bypass and inverter.')
lgpPwrTopFrequencyConverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTopFrequencyConverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopFrequencyConverter.setDescription('The system has a frequency converter.')
lgpPwrTopVoltageConverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTopVoltageConverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopVoltageConverter.setDescription('The system has a voltage converter.')
lgpPwrTopMaximumFrameCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 6), Integer32()).setUnits('Volt-Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrTopMaximumFrameCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopMaximumFrameCapacity.setDescription('The maximum device system capacity.')
lgpPwrTopRedundantControlModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTopRedundantControlModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopRedundantControlModules.setDescription('The device has a redundant control module installed.')
lgpPwrInputIsolationTransformerInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrInputIsolationTransformerInstalled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrInputIsolationTransformerInstalled.setDescription('Indicates whether the input isolation transformer is installed.')
lgpPwrStateStaticSwitchType = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("continuousDuty", 2), ("momentaryDuty", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateStaticSwitchType.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateStaticSwitchType.setDescription('Static switch type (N/A, continous duty, or momentary duty).')
lgpPwrStateModuleType = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("singleModuleSystem", 1), ("module1plus1", 2), ("module1plusN", 3), ("moduleNplus1", 4), ("systemControlCabinet", 5), ("mainStaticSwitch", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateModuleType.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateModuleType.setDescription('UPS module type. SMS -- Single Module System 1 + 1 -- Redundant system for capacity 1 + N -- Distributed multi-module system N + 1 -- A multi-module system with one bypass for the system SCC -- System Control Cabinet used in an N+1 system to provide a single bypass for the system. MSS -- Main Static Switch')
lgpPwrStateBypassInputConfig = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singlePhase2WireL1WithReturn", 1), ("twoPhase2WireL1L2", 2), ("twoPhase3WireL1L2WithNeutral", 3), ("threePhase3WireL1L2L3", 4), ("threePhase4WireL1L2L3WithNeutral", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBypassInputConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBypassInputConfig.setDescription('Bypass input wire physical wiring configuration. singlePhase2WireL1WithReturn Single phase input with 2 wires (Line 1, and Return). twoPhase2WireL1L2 Two phase input with 2 wires (Line 1, and Line 2). twoPhase3WireL1L2WithNeutral Two phase input with 3 wires (Line 1, Line 2, and Neutral) threePhase3WireL1L2L3 Three phase input with 3 wires (Line 1, Line 2, and Line 3) threePhase4WireL1L2L3WithNeutral Three phase input with 4 wires (Line 1, Line 2, Line 3, and Neutral).')
lgpPwrStateOutputConfig = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singlePhase2WireL1WithReturn", 1), ("twoPhase2WireL1L2", 2), ("twoPhase3WireL1L2WithNeutral", 3), ("threePhase3WireL1L2L3", 4), ("threePhase4WireL1L2L3WithNeutral", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutputConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutputConfig.setDescription('Output wire physical wiring configuration. singlePhase2WireL1WithReturn Single phase output with 2 wires (Line 1, and Return). twoPhase2WireL1L2 Two phase output with 2 wires (Line 1, and Line 2). twoPhase3WireL1L2WithNeutral Two phase output with 3 wires (Line 1, Line 2, and Neutral) threePhase3WireL1L2L3 Three phase output with 3 wires (Line 1, Line 2, and Line 3) threePhase4WireL1L2L3WithNeutral Three phase output with 4 wires (Line 1, Line 2, Line 3, and Neutral).')
lgpPwrRectifierPassiveFilterInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRectifierPassiveFilterInstalled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRectifierPassiveFilterInstalled.setDescription('Indicates whether the rectifier passive filter is installed.')
lgpPwrRectifierTrapInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRectifierTrapInstalled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRectifierTrapInstalled.setDescription('Indicates whether the rectifier input passive filter is installed.')
lgpPwrRectifierActiveFilterInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRectifierActiveFilterInstalled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRectifierActiveFilterInstalled.setDescription('Indicates whether the rectifier active filter is installed.')
lgpPwrSysCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9, 1), Integer32()).setUnits('Volt-Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrSysCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSysCapacity.setDescription('The current device system capacity.')
lgpPwrUPSModuleMode = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("single", 1), ("parallel", 2), ("hotmaster", 3), ("hotslave", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUPSModuleMode.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUPSModuleMode.setDescription('The module mode of the UPS.')
lgpPwrMaxRatedCurrent = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9, 3), Integer32()).setUnits('Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMaxRatedCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMaxRatedCurrent.setDescription('System output maximum amperage rating. The maximum rated amperage for the system. This value is based upon the model type and is typically limited by the wiring, breakers, power devices, etc.')
lgpPwrRectifierPulseCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sixPulse", 1), ("twelvePulse", 2), ("eighteenPulse", 3), ("twentyFourPulse", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRectifierPulseCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRectifierPulseCount.setDescription('Rectifier pulse count per waveform cycle (6-, 12-, 18-, or 24-pulse).')
mibBuilder.exportSymbols("LIEBERT-GP-POWER-MIB", lgpPwrLineMeasurementPercentLoad=lgpPwrLineMeasurementPercentLoad, lgpPwrEconomicOperation=lgpPwrEconomicOperation, lgpPwrConversion=lgpPwrConversion, PYSNMP_MODULE_ID=liebertGlobalProductsPowerModule, lgpPwrMeasBatteryCabinet=lgpPwrMeasBatteryCabinet, lgpPwrStateSource2BypassBrkrState=lgpPwrStateSource2BypassBrkrState, lgpPwrVoltsDc=lgpPwrVoltsDc, lgpPwrBuck=lgpPwrBuck, lgpPwrBatteryDischargeTime=lgpPwrBatteryDischargeTime, lgpPwrStateModuleType=lgpPwrStateModuleType, lgpPwrConfigLowBatteryWarningTime=lgpPwrConfigLowBatteryWarningTime, lgpPwrStateBackfeedBrkrState=lgpPwrStateBackfeedBrkrState, lgpPwrBatteryDischargeCount=lgpPwrBatteryDischargeCount, lgpPwrLoadCircuitTable=lgpPwrLoadCircuitTable, lgpPwrTopRedundantControlModules=lgpPwrTopRedundantControlModules, lgpPwrThresholdHighWarning=lgpPwrThresholdHighWarning, lgpPwrBrownOutCount=lgpPwrBrownOutCount, lgpPwrTransferToInverter=lgpPwrTransferToInverter, lgpPwrOutputToLoadUserOverloadLimit=lgpPwrOutputToLoadUserOverloadLimit, lgpPwrBypassReady=lgpPwrBypassReady, lgpPwrRotaryBreakerStatus=lgpPwrRotaryBreakerStatus, lgpPwrControl=lgpPwrControl, lgpPwrNumberRedundantBatteryModules=lgpPwrNumberRedundantBatteryModules, lgpPwrSource1Input=lgpPwrSource1Input, lgpPwrMeasDcBus=lgpPwrMeasDcBus, lgpPwrLineMeasurementCurrent=lgpPwrLineMeasurementCurrent, lgpPwrAmpsNeutral=lgpPwrAmpsNeutral, lgpPwrBlackOutCount=lgpPwrBlackOutCount, lgpPwrStateOutputBrkrState=lgpPwrStateOutputBrkrState, lgpPwrBatteryCircuitBreakerState=lgpPwrBatteryCircuitBreakerState, lgpPwrNumberFailedPowerModules=lgpPwrNumberFailedPowerModules, lgpPwrBatteryChargeMode=lgpPwrBatteryChargeMode, lgpPwrBypassOverloadShutdownTime=lgpPwrBypassOverloadShutdownTime, lgpPwrStateSource1PduInputBrkrState=lgpPwrStateSource1PduInputBrkrState, lgpPwrBatteryFloatVoltage=lgpPwrBatteryFloatVoltage, lgpPwrBatteryCabinetRatedCapacity=lgpPwrBatteryCabinetRatedCapacity, lgpPwrLineMeasurementCapacity=lgpPwrLineMeasurementCapacity, lgpPwrLoadBusSyncMode=lgpPwrLoadBusSyncMode, lgpPwrNominalBatteryCapacity=lgpPwrNominalBatteryCapacity, lgpPwrTopVoltageConverter=lgpPwrTopVoltageConverter, lgpPwrMinimumRedundantBatteryModule=lgpPwrMinimumRedundantBatteryModule, lgpPwrStateOutQualification=lgpPwrStateOutQualification, lgpPwrLineMeasurementVolts=lgpPwrLineMeasurementVolts, lgpPwrMaxRatedCurrent=lgpPwrMaxRatedCurrent, lgpPwrThresholdLowWarning=lgpPwrThresholdLowWarning, lgpPwrStateInputQualification=lgpPwrStateInputQualification, lgpPwrBatteryPresentDischargeTime=lgpPwrBatteryPresentDischargeTime, lgpPwrBatteryChargeCompensating=lgpPwrBatteryChargeCompensating, lgpPwrBatteryLifeEnhancer=lgpPwrBatteryLifeEnhancer, lgpPwrUPSModuleMode=lgpPwrUPSModuleMode, lgpPwrNumberFailedBatteryModules=lgpPwrNumberFailedBatteryModules, lgpPwrNumberActiveBatteryModules=lgpPwrNumberActiveBatteryModules, lgpPwrMeasurementPointPowerFactorTag=lgpPwrMeasurementPointPowerFactorTag, lgpPwrThresholdType=lgpPwrThresholdType, lgpPwrShutdownOverload=lgpPwrShutdownOverload, lgpPwrDcMeasurementPointVolts=lgpPwrDcMeasurementPointVolts, lgpPwrBatteryCharger=lgpPwrBatteryCharger, lgpPwrRectifierPassiveFilterInstalled=lgpPwrRectifierPassiveFilterInstalled, lgpPwrPowerFactorCorrection=lgpPwrPowerFactorCorrection, lgpPwrStateUpsModuleRedundantCount=lgpPwrStateUpsModuleRedundantCount, lgpPwrWellKnownControlPoints=lgpPwrWellKnownControlPoints, lgpPwrPreferredSource=lgpPwrPreferredSource, lgpPwrRectifierActiveFilterInstalled=lgpPwrRectifierActiveFilterInstalled, lgpPwrThresholdLowFailure=lgpPwrThresholdLowFailure, lgpPwrMeasurementPointNomVA=lgpPwrMeasurementPointNomVA, lgpPwrBatteryCapacityStatus=lgpPwrBatteryCapacityStatus, lgpPwrStateUpsModuleCount=lgpPwrStateUpsModuleCount, lgpPwrMeasurementPointWattHours=lgpPwrMeasurementPointWattHours, lgpPwrLoadCircuitEntry=lgpPwrLoadCircuitEntry, lgpPwrSettings=lgpPwrSettings, lgpPwrDcMeasurementPointTable=lgpPwrDcMeasurementPointTable, lgpPwrNumberInstalledBatteryModules=lgpPwrNumberInstalledBatteryModules, lgpPwrEconomicOperationModeControl=lgpPwrEconomicOperationModeControl, lgpPwrStatisticsReset=lgpPwrStatisticsReset, lgpPwrNumberRedundantPowerModules=lgpPwrNumberRedundantPowerModules, lgpPwrStateDCBusQualification=lgpPwrStateDCBusQualification, lgpPwrAlarmSilence=lgpPwrAlarmSilence, lgpPwrStateOutputSource=lgpPwrStateOutputSource, lgpPwrStateMaintIsolBrkrState=lgpPwrStateMaintIsolBrkrState, lgpPwrTransientCount=lgpPwrTransientCount, lgpPwrBatteryCabinet=lgpPwrBatteryCabinet, lgpPwrMeasurementPointNeutralCurrent=lgpPwrMeasurementPointNeutralCurrent, lgpPwrShutdownRemote=lgpPwrShutdownRemote, lgpPwrNumberInstalledPowerModules=lgpPwrNumberInstalledPowerModules, lgpPwrBatteryNiCadCellCount=lgpPwrBatteryNiCadCellCount, lgpPwrUPSTopDualInput=lgpPwrUPSTopDualInput, lgpPwrTopology=lgpPwrTopology, lgpPwrLineMeasurementCrestFactorCurrent=lgpPwrLineMeasurementCrestFactorCurrent, lgpPwrLoadOnSource=lgpPwrLoadOnSource, lgpPwrEconomicOperationMode=lgpPwrEconomicOperationMode, lgpPwrOutputToLoadOnBypass=lgpPwrOutputToLoadOnBypass, lgpPwrTopFrequencyConverter=lgpPwrTopFrequencyConverter, lgpPwrMeasSystemOutput=lgpPwrMeasSystemOutput, lgpPwrSysCapacity=lgpPwrSysCapacity, lgpPwrLineMeasurementPowerFactor=lgpPwrLineMeasurementPowerFactor, lgpPwrMeasBattery=lgpPwrMeasBattery, lgpPwrLineMeasurementIndex=lgpPwrLineMeasurementIndex, lgpPwrAutomaticBatteryTest=lgpPwrAutomaticBatteryTest, lgpPwrMeasurementPointIndex=lgpPwrMeasurementPointIndex, lgpPwrBypassSyncDiff=lgpPwrBypassSyncDiff, lgpPwrStateSource1InputBrkrState=lgpPwrStateSource1InputBrkrState, lgpPwrBatteryWattHours=lgpPwrBatteryWattHours, lgpPwrLineMeasurementVoltsLL=lgpPwrLineMeasurementVoltsLL, lgpPwrBatteryTimeRemaining=lgpPwrBatteryTimeRemaining, lgpPwrBatteryAmpHoursDischargeConsumed=lgpPwrBatteryAmpHoursDischargeConsumed, lgpPwrMeasurementPointTable=lgpPwrMeasurementPointTable, lgpPwrStateInverterQualification=lgpPwrStateInverterQualification, lgpPwrShutdownInputUnderVoltage=lgpPwrShutdownInputUnderVoltage, lgpPwrDcToDcConverter=lgpPwrDcToDcConverter, lgpPwrMeasurementPointNumLines=lgpPwrMeasurementPointNumLines, lgpPwrShutdownPowerFactorCorrectionFailure=lgpPwrShutdownPowerFactorCorrectionFailure, lgpPwrStateBypassIsolBrkrState=lgpPwrStateBypassIsolBrkrState, lgpPwrStateSource2PduInputBrkrState=lgpPwrStateSource2PduInputBrkrState, lgpPwrOutputOffDelayWithRestart=lgpPwrOutputOffDelayWithRestart, lgpPwrWellKnownMeasurementPoints=lgpPwrWellKnownMeasurementPoints, lgpPwrBatteryCount=lgpPwrBatteryCount, lgpPwrBatteryEndOfDischargeVoltage=lgpPwrBatteryEndOfDischargeVoltage, lgpPwrSourcePdu1Input=lgpPwrSourcePdu1Input, lgpPwrTransferCount=lgpPwrTransferCount, lgpPwrStateBypassStaticSwitchState=lgpPwrStateBypassStaticSwitchState, lgpPwrFrequencyDeviationLimit=lgpPwrFrequencyDeviationLimit, lgpPwrSyncPhaseAngle=lgpPwrSyncPhaseAngle, lgpPwrShutdownHardware=lgpPwrShutdownHardware, lgpPwrMeasurementPointNomFrequency=lgpPwrMeasurementPointNomFrequency, lgpPwrMeasurementPointNomW=lgpPwrMeasurementPointNomW, lgpPwrShutdownOverTemperature=lgpPwrShutdownOverTemperature, lgpPwrShutdownLowBattery=lgpPwrShutdownLowBattery, lgpPwrStateModuleOutBrkrState=lgpPwrStateModuleOutBrkrState, lgpPwrLineMeasurementVACapacity=lgpPwrLineMeasurementVACapacity, lgpPwrThresholdHighFailure=lgpPwrThresholdHighFailure, lgpPwrParallelRedundancyCount=lgpPwrParallelRedundancyCount, lgpPwrBatteryLastCommissionTime=lgpPwrBatteryLastCommissionTime, lgpPwrStateOutStaticSwState=lgpPwrStateOutStaticSwState, lgpPwrBypassReXfrRemainTime=lgpPwrBypassReXfrRemainTime, lgpPwrLoadCircuit=lgpPwrLoadCircuit, lgpPwrMinimumRedundantPowerModule=lgpPwrMinimumRedundantPowerModule, lgpPwrSource2Input=lgpPwrSource2Input, lgpPwrStateCircuitBrkrStateGroup=lgpPwrStateCircuitBrkrStateGroup, lgpPwrStateIntBypassBrkrState=lgpPwrStateIntBypassBrkrState, lgpPwrMeasurementPtIndex=lgpPwrMeasurementPtIndex, lgpPwrStateSource2InputBrkrState=lgpPwrStateSource2InputBrkrState, lgpPwrDcMeasurementPointId=lgpPwrDcMeasurementPointId, lgpPwrBoost=lgpPwrBoost, lgpPwrBatteryCabinetCount=lgpPwrBatteryCabinetCount, lgpPwrDcMeasurementPointCurrent=lgpPwrDcMeasurementPointCurrent, lgpPwrStateStaticSwitchType=lgpPwrStateStaticSwitchType, lgpPwrStatus=lgpPwrStatus, lgpPwrWellKnownMeasurementTypes=lgpPwrWellKnownMeasurementTypes, lgpPwrNominalVoltageDeviationPercent=lgpPwrNominalVoltageDeviationPercent, lgpPwrThresholdSubID=lgpPwrThresholdSubID, lgpPwrVoltsAc=lgpPwrVoltsAc, lgpPwrLoadCircuitIndex=lgpPwrLoadCircuitIndex, lgpPwrNumberActivePowerModules=lgpPwrNumberActivePowerModules, lgpPwrMeasurementPointId=lgpPwrMeasurementPointId, lgpPwrMeasurementPointVAPercent=lgpPwrMeasurementPointVAPercent, lgpPwrOutputOnDelay=lgpPwrOutputOnDelay, lgpPwrShutdownDcBusOverload=lgpPwrShutdownDcBusOverload, lgpPwrShutdownLineSwap=lgpPwrShutdownLineSwap, lgpPwrUpsTopOffline=lgpPwrUpsTopOffline, lgpPwrStateLoadBusSynchronization=lgpPwrStateLoadBusSynchronization, lgpPwrThresholdTable=lgpPwrThresholdTable, lgpPwrDcMeasurementPointEntry=lgpPwrDcMeasurementPointEntry, lgpPwrStateModuleGroup=lgpPwrStateModuleGroup, lgpPwrDcMeasurementPointIndex=lgpPwrDcMeasurementPointIndex, lgpPwrLineMeasurementPowerFactorTag=lgpPwrLineMeasurementPowerFactorTag, lgpPwrStateInvOutputBrkrState=lgpPwrStateInvOutputBrkrState, lgpPwrNoLoadWarningDelay=lgpPwrNoLoadWarningDelay, lgpPwrMeasurementPointGroundCurrent=lgpPwrMeasurementPointGroundCurrent, lgpPwrInputIsolationTransformerInstalled=lgpPwrInputIsolationTransformerInstalled, lgpPwrBatteryCapacity=lgpPwrBatteryCapacity, lgpPwrLineMeasurementVoltsLN=lgpPwrLineMeasurementVoltsLN, lgpPwrLineMeasurementKFactorCurrent=lgpPwrLineMeasurementKFactorCurrent, lgpPwrBatteryAmpHours=lgpPwrBatteryAmpHours, lgpPwrStateInputSource=lgpPwrStateInputSource, lgpPwrStateInverterState=lgpPwrStateInverterState, lgpPwrDcMeasurementPointSubID=lgpPwrDcMeasurementPointSubID, lgpPwrStateTrapFilterBrkrState=lgpPwrStateTrapFilterBrkrState, lgpPwrDcMeasurementPointTruePower=lgpPwrDcMeasurementPointTruePower, lgpPwrStateBypassInputConfig=lgpPwrStateBypassInputConfig, lgpPwrRedundantSubModule=lgpPwrRedundantSubModule, lgpPwrUpsAbortCommand=lgpPwrUpsAbortCommand, lgpPwrLineMeasurementTable=lgpPwrLineMeasurementTable, lgpPwrStateAuxOutputBrkrState=lgpPwrStateAuxOutputBrkrState, lgpPwrTopMaximumFrameCapacity=lgpPwrTopMaximumFrameCapacity, lgpPwrStateMaintBypassBrkrState=lgpPwrStateMaintBypassBrkrState, lgpPwrThresholdIndex=lgpPwrThresholdIndex, lgpPwrLineMeasurementTruePower=lgpPwrLineMeasurementTruePower, lgpPwrLineMeasurementVA=lgpPwrLineMeasurementVA, lgpPwrBatteryChargeStatus=lgpPwrBatteryChargeStatus, lgpPwrInverterOverloadShutdownTime=lgpPwrInverterOverloadShutdownTime, lgpPwrPhaseDifferenceLimit=lgpPwrPhaseDifferenceLimit, lgpPwrAutoRestartBatteryChargeThreshold=lgpPwrAutoRestartBatteryChargeThreshold, lgpPwrAutoReTransferEnabled=lgpPwrAutoReTransferEnabled, lgpPwrNumberPowerModuleWarnings=lgpPwrNumberPowerModuleWarnings, lgpPwrRectifierPulseCount=lgpPwrRectifierPulseCount, lgpPwrDcMeasurementPointNomVolts=lgpPwrDcMeasurementPointNomVolts, lgpPwrAutomaticBatteryTestInterval=lgpPwrAutomaticBatteryTestInterval, lgpPwrStatistic=lgpPwrStatistic, lgpPwrMeasBypass=lgpPwrMeasBypass, lgpPwrUpsInverterStandby=lgpPwrUpsInverterStandby, liebertGlobalProductsPowerModule=liebertGlobalProductsPowerModule, lgpPwrRectifierTrapInstalled=lgpPwrRectifierTrapInstalled, lgpPwrMeasurementPointFrequency=lgpPwrMeasurementPointFrequency, lgpPwrThresholdPoint=lgpPwrThresholdPoint, lgpPwrStateUpsOutputSource=lgpPwrStateUpsOutputSource, lgpPwrMeasurementPointNomVolts=lgpPwrMeasurementPointNomVolts, lgpPwrStateOutputConfig=lgpPwrStateOutputConfig, lgpPwrShutdownOutputShort=lgpPwrShutdownOutputShort, lgpPwrMeasurementPointPowerFactor=lgpPwrMeasurementPointPowerFactor, lgpPwrLoadCircuitSubID=lgpPwrLoadCircuitSubID, lgpPwrStateInputBrkrState=lgpPwrStateInputBrkrState, lgpPwrGeneratorStatus=lgpPwrGeneratorStatus, lgpPwrMeasurementPoint=lgpPwrMeasurementPoint, lgpPwrTransferToBypass=lgpPwrTransferToBypass, lgpPwrUpsTopLineInteractive=lgpPwrUpsTopLineInteractive, lgpPwrParallelSystemOutputToLoadSource=lgpPwrParallelSystemOutputToLoadSource, lgpPwrBatteryLeadAcidCellCount=lgpPwrBatteryLeadAcidCellCount, lgpPwrBatteryTestResult=lgpPwrBatteryTestResult, lgpPwrOutputOffDelayWithoutRestart=lgpPwrOutputOffDelayWithoutRestart, lgpPwrThresholdEntry=lgpPwrThresholdEntry, lgpPwrBattery=lgpPwrBattery, lgpPwrNominalVoltageDeviation=lgpPwrNominalVoltageDeviation, lgpPwrBatteryCabinetType=lgpPwrBatteryCabinetType, lgpPwrBatteryStatisticsReset=lgpPwrBatteryStatisticsReset, lgpPwrLineMeasurementEntry=lgpPwrLineMeasurementEntry, lgpPwrMeasurementPointNomCurrent=lgpPwrMeasurementPointNomCurrent, lgpPwrLoadCircuitStateAndControl=lgpPwrLoadCircuitStateAndControl, lgpPwrMeasurementPointApparentPower=lgpPwrMeasurementPointApparentPower, lgpPwrStateRectifierState=lgpPwrStateRectifierState, lgpPwrStateBypassQualification=lgpPwrStateBypassQualification, lgpPwrUpsAutoRestartDelay=lgpPwrUpsAutoRestartDelay, lgpPwrLineMeasurementVAR=lgpPwrLineMeasurementVAR, lgpPwrStateSource1BypassBrkrState=lgpPwrStateSource1BypassBrkrState, lgpPwrMeasurementPointEntry=lgpPwrMeasurementPointEntry, lgpPwrInverterReady=lgpPwrInverterReady, lgpPwrParallelModuleCount=lgpPwrParallelModuleCount, lgpPwrLineMeasurementCurrentTHD=lgpPwrLineMeasurementCurrentTHD, lgpPwrLoadCircuitState=lgpPwrLoadCircuitState, lgpPwrMeasurementPointNomPowerFactor=lgpPwrMeasurementPointNomPowerFactor, lgpPwrBatteryLastDischargeTime=lgpPwrBatteryLastDischargeTime, lgpPwrMeasurementPointTruePower=lgpPwrMeasurementPointTruePower, lgpPwrNoLoadWarningLimit=lgpPwrNoLoadWarningLimit, lgpPwrLineMeasurementMaxVolts=lgpPwrLineMeasurementMaxVolts, lgpPwrMeasurements=lgpPwrMeasurements, lgpPwrLineMeasurementVoltageTHD=lgpPwrLineMeasurementVoltageTHD, lgpPwrAutoTransferTimer=lgpPwrAutoTransferTimer, lgpPwrOutputToLoad=lgpPwrOutputToLoad, lgpPwrLineMeasurementMinVolts=lgpPwrLineMeasurementMinVolts, lgpPwrBatteryAmpHoursConsumed=lgpPwrBatteryAmpHoursConsumed, lgpPwrUpsAutoRestart=lgpPwrUpsAutoRestart, lgpPwrConfig=lgpPwrConfig, lgpPwrNumberBatteryModuleWarnings=lgpPwrNumberBatteryModuleWarnings, lgpPwrLoadCircuitId=lgpPwrLoadCircuitId, lgpPwrAutomaticBatteryTestCountdown=lgpPwrAutomaticBatteryTestCountdown)
mibBuilder.exportSymbols("LIEBERT-GP-POWER-MIB", lgpPwrOutputToLoadOnInverter=lgpPwrOutputToLoadOnInverter, lgpPwrSourcePdu2Input=lgpPwrSourcePdu2Input, lgpPwrBatteryTest=lgpPwrBatteryTest, lgpPwrStateLoadDisconnectState=lgpPwrStateLoadDisconnectState, lgpPwrStateRectifierIsolBrkrState=lgpPwrStateRectifierIsolBrkrState)

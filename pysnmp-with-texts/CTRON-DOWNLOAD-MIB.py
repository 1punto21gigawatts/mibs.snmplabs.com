#
# PySNMP MIB module CTRON-DOWNLOAD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CTRON-DOWNLOAD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:29:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
ctDownLoad, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctDownLoad")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, MibIdentifier, ModuleIdentity, Counter64, ObjectIdentity, Integer32, iso, Gauge32, NotificationType, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "MibIdentifier", "ModuleIdentity", "Counter64", "ObjectIdentity", "Integer32", "iso", "Gauge32", "NotificationType", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ctDL = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1))
ctDLForceOnBoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLForceOnBoot.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLForceOnBoot.setDescription('When set to a 1, the system will request a download during the next system restart. If no server is found and the current image in flash memory is valid, the system will boot using the flash-resident image.')
ctDLCommitRAMToFlash = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLCommitRAMToFlash.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLCommitRAMToFlash.setDescription('When written with a 1, the boot software will erase flash memory, compress the downloaded code if necessary, and save the image into flash memory. Upon completion of this operation, the flash memory driver resets this object to 0, indicating completion of the programming operation.')
ctDLInitiateColdBoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLInitiateColdBoot.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLInitiateColdBoot.setDescription('When written with a 1, the boot software initiates a system reboot. When written with a 2, the boot software initiates a soft reboot of the system. The soft reboot does not perform the Boot PROM Power-Up diagnostics. If only one form of reboot is supported initiate that reboot in both cases. A read always returns a 0.')
ctDLTFTPRequestHost = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLTFTPRequestHost.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLTFTPRequestHost.setDescription('The IP address of the TFTP server to be used when firmware is to be loaded across the network.')
ctDLTFTPRequest = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLTFTPRequest.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLTFTPRequest.setDescription('The filename requested of the server when firmware is to be loaded across the network.')
ctDLLastImageFilename = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLLastImageFilename.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLLastImageFilename.setDescription('The value of ctDLFileName during the last successful image download. This is the name of the file, on the TFTP server, that was download to become the current image.')
ctDLLastServerIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLLastServerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLLastServerIPAddress.setDescription('The value of ctDLNetAddress during the last successful image download. This is the IP address of the TFTP server used to download the current image.')
ctDLFlashSize = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLFlashSize.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLFlashSize.setDescription('Denotes the size, in bytes, of flash memory contained on this module.')
ctDLFlashCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLFlashCount.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLFlashCount.setDescription('Denotes the number of times that flash memory has been reprogrammed. This value is initialized to 1, when the module is initially powered up.')
ctDLFirmwareBase = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLFirmwareBase.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLFirmwareBase.setDescription('Denotes the starting RAM address of the firmware.')
ctDLFirmwareTop = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLFirmwareTop.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLFirmwareTop.setDescription('Denotes the ending RAM address of firmware.')
ctDLFirmwareStart = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLFirmwareStart.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLFirmwareStart.setDescription('Denotes the RAM entry point of the firmware as established by the boot process.')
ctDLBootRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLBootRev.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLBootRev.setDescription('Denotes the revision of boot firmware in the module. The first octet provides the version, and the second provides the revision.')
ctDLForceBootp = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLForceBootp.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLForceBootp.setDescription('When set to 1, this object forces the client to send a BOOTP request packet when rebooting. The client will make several attempts before timing out if a BOOTP server does not respond. This object remains set.')
ctDLServerName = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 15), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLServerName.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLServerName.setDescription('This OID is reserved for future use of the BOOTP server name. This field can be used when a client wants to get boot information from a particular BOOTP server.')
ctDLOnLineDownLoad = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normalOperation", 1), ("forceDownLoad", 2), ("forceDownLoadReset", 3), ("downLoadConfiguration", 4), ("upLoadConfiguration", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLOnLineDownLoad.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLOnLineDownLoad.setDescription('During normal operation this object has the value of 1. By setting this object to a value of forceDownLoad(2) an image download via TFTP will be performed, ctDLNetAddress specifies the TFTP server and ctDLFileName specifies the file name of the image on the TFTP server. By setting this object to a value of forceDownLoadReset(3) an image download via TFTP will be performed, ctDLNetAddress specifies the TFTP server and ctDLFileName specifies the file name of the image on the TFTP server. A reset will be forced upon successful completion of the download. By setting this object to a value of downLoadConfiguration(4) the specified configuration file will be downloaded, verified, and, if valid, committed to NVRAM, if valid. A reset will be forced upon successful completion. ctDLNetAddress specifies the TFTP server and ctDLFileName specifies the name of the configuration file on the TFTP server. By setting this object to upLoadConfiguration(5), the contents of NVRAM will be uploaded via TFTP to the specified file on the specified TFTP server. ctDLNetAddress specifies the TFTP server and ctDLFileName specifies the name of the configuration file.')
ctDLOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("normalOperation", 3), ("downLoadActive", 4), ("downLoadCompleteError", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLOperStatus.setDescription('This object reflects the status of the download code. normalOperation(3) - Indicates that either no download has been started, or that a download was started and has finished normally. downLoadActive(4) - indicates a download is currently in progress. downLoadCompleteError(5) - Indicates that a download was started but an error was detected.')
ctDLNetAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLNetAddress.setDescription('The IP Address of the TFTP server to be used for uploading and downloading configuration files and for downloading images.')
ctDLFileName = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLFileName.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLFileName.setDescription('The file name to be used to specify the image or configuration file on the TFTP server specified by ctDLNetAddress. This should be a complete path filename.')
ctDLErrorString = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLErrorString.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLErrorString.setDescription('If the value of ctDLOperStatus is downloadCompleteError(5) then this object will provide a more complete description of the error. Otherwise this object will be the zero length string.')
ctDLTftpServerGatewayIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctDLTftpServerGatewayIPAddress.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLTftpServerGatewayIPAddress.setDescription('The IP address of the gateway/router which connects this SNMP agent to the TFTP server.')
ctDLBlockCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLBlockCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctDLBlockCount.setDescription('Current TFTP block count of an active session. If no TFTP transfer is in progress, zero is returned.')
ctDLBootPartitionStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 5, 8, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("good", 1), ("bad", 2), ("inProgress", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDLBootPartitionStatus.setStatus('obsolete')
if mibBuilder.loadTexts: ctDLBootPartitionStatus.setDescription('Status of the boot partition or partitions. A value of good(1) indicates that all boot partitions contain a valid checksum. A value of bad(2) indicates that one or more boot partitions contain an invalid checksum and the the image was not able to fix the invalid boot partition. A value of inProgress(3) indicates that the image is attempting to fix an invalid boot partition and this status will change to either good(1) or bad(2).')
mibBuilder.exportSymbols("CTRON-DOWNLOAD-MIB", ctDLFlashCount=ctDLFlashCount, ctDLBlockCount=ctDLBlockCount, ctDLTftpServerGatewayIPAddress=ctDLTftpServerGatewayIPAddress, ctDLForceBootp=ctDLForceBootp, ctDLTFTPRequestHost=ctDLTFTPRequestHost, ctDLFirmwareStart=ctDLFirmwareStart, ctDLCommitRAMToFlash=ctDLCommitRAMToFlash, ctDLLastImageFilename=ctDLLastImageFilename, ctDLFirmwareBase=ctDLFirmwareBase, ctDLErrorString=ctDLErrorString, ctDLBootRev=ctDLBootRev, ctDLFirmwareTop=ctDLFirmwareTop, ctDLFlashSize=ctDLFlashSize, ctDLForceOnBoot=ctDLForceOnBoot, ctDLServerName=ctDLServerName, ctDLLastServerIPAddress=ctDLLastServerIPAddress, ctDLNetAddress=ctDLNetAddress, ctDLInitiateColdBoot=ctDLInitiateColdBoot, ctDL=ctDL, ctDLTFTPRequest=ctDLTFTPRequest, ctDLOperStatus=ctDLOperStatus, ctDLBootPartitionStatus=ctDLBootPartitionStatus, ctDLOnLineDownLoad=ctDLOnLineDownLoad, ctDLFileName=ctDLFileName)

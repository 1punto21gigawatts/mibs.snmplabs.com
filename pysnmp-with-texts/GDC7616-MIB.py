#
# PySNMP MIB module GDC7616-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDC7616-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:18:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Bits, IpAddress, Counter32, ModuleIdentity, Gauge32, Counter64, enterprises, ObjectIdentity, Unsigned32, MibIdentifier, iso, TimeTicks, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Bits", "IpAddress", "Counter32", "ModuleIdentity", "Gauge32", "Counter64", "enterprises", "ObjectIdentity", "Unsigned32", "MibIdentifier", "iso", "TimeTicks", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
bql2 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12))
uas7616 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 4))
uas7616MIBVersion = MibScalar((1, 3, 6, 1, 4, 1, 498, 12, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616MIBVersion.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616MIBVersion.setDescription('The version number of the MIB, to allow products to know which MIB is being supported. The version number will be x.yzT where x is a major revision (1-9), y is a minor revision(0-9), z is a typo revision (0-9) and T indicates the MIB is still a test revision(A-Z). When a release is complete no T should exist.')
uas7616WhatAreYouTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 2), )
if mibBuilder.loadTexts: uas7616WhatAreYouTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616WhatAreYouTable.setDescription('The GDC 7616 What Are You Table.')
uas7616WhatAreYouEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 2, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616WhatAreYouIndex"))
if mibBuilder.loadTexts: uas7616WhatAreYouEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616WhatAreYouEntry.setDescription('An entry in the GDC 7616 What Are You table.')
uas7616WhatAreYouIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616WhatAreYouIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616WhatAreYouIndex.setDescription('This object is the identifier of the 7616 What Are You table.')
uas7616CodeRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616CodeRev.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616CodeRev.setDescription('This function returns the firmware code level. Example A- ,B- ')
uas7616AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616AlarmStatus.setDescription('The current alarms of the unit without the alarm masks.')
uas7616SystemTimingGenStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("clk8khz", 2), ("clk4mhz", 3), ("clk8khzand4mhz", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616SystemTimingGenStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616SystemTimingGenStatus.setDescription('Indicates if the units configured for primary or secondary system clock are actually supplying clock and if it is the 8hkz, 4mhz, or both.')
uas7616ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 3), )
if mibBuilder.loadTexts: uas7616ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ConfigTable.setDescription('The GDC 7616 configuration table.')
uas7616ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 3, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616ConfigIndex"))
if mibBuilder.loadTexts: uas7616ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ConfigEntry.setDescription('A listing of GDC 2B1Q 7616 options.')
uas7616ConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616ConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ConfigIndex.setDescription('A unique index for the Configuration Table.')
uas7616TXClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("system", 1), ("recovered", 2), ("internal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616TXClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616TXClockSource.setDescription('Object to select the Transmit Clock Source for the 7616.')
uas7616TerminationType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nt", 1), ("lt", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616TerminationType.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616TerminationType.setDescription('Object to select the Termination Type for the 7616.')
uas7616ChADataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("kbps64", 1), ("kbps128", 2), ("inhibit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616ChADataRate.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ChADataRate.setDescription('Object to select the Data Rate on Channel A, Loop n.')
uas7616ChBDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("kbps64", 1), ("inhibit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616ChBDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ChBDataRate.setDescription('Object to select the Data Rate on Channel B, Loop n.')
uas7616ControlTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 5), )
if mibBuilder.loadTexts: uas7616ControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ControlTable.setDescription('The GDC 7616 Control Table.')
uas7616ControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616ControlIndex"))
if mibBuilder.loadTexts: uas7616ControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ControlEntry.setDescription('An entry in the GDC 7616 Control table.')
uas7616ControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616ControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ControlIndex.setDescription('This object is the identifier of the 7616 Control table.')
uas7616SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616SoftReset.setDescription('Forces a soft reset on the network element. The reset selection is write only. The normal selection is read only.')
uas7616EraseConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("erase", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616EraseConfig.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616EraseConfig.setDescription('Forces an erase of the stored configuration in the network element. The erase selection is write only.')
uas7616LEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616LEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LEDStatus.setDescription('The GDC 7616 front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - not used 1.5 - loop 1 channel A (00 = No Change 01 = Green Active) 1.4 - (10 = Red Solid 11 = RedFlashing ) 1.3 - loop 1 channel B (00 = No Change 01 = Green Active) 1.2 - (10 = Red Solid 11 = RedFlashing ) 1.1 - loop 2 channel A (00 = No Change 01 = Green Active) 1.0 - (10 = Red Solid 11 = RedFlashing ) 2.7 - not used 2.6 - not used 2.5 - loop 2 channel B (00 = No Change 01 = Green Active) 2.4 - (10 = Red Solid 11 = RedFlashing ) 2.3 - loop 3 channel A (00 = No Change 01 = Green Active) 2.2 - (10 = Red Solid 11 = RedFlashing ) 2.1 - loop 3 channel B (00 = No Change 01 = Green Active) 2.0 - (10 = Red Solid 11 = RedFlashing ) 3.7 - not used 3.6 - not used 3.5 - not used 3.4 - alarm led 3.3 - test mode led 3.2 - in service 3.1 - system timing source 3.0 - management response')
uas7616InterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("diu", 1), ("niu", 2), ("notAssigned", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616InterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616InterfaceType.setDescription('Object used to configure the transmission interface type.')
uas7616SysTimingGen = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("primary", 2), ("secondary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616SysTimingGen.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616SysTimingGen.setDescription('Selects if the unit provides system timing. none(1) - does not provide Timing Generator primary(2) - unit is primary Timing Generator for the shelf. secondary(3) - unit is secondary Timig Generator for the shelf. Only 1 unit in the shelf can the primary or secondary timing generator. All other must be none.')
uas7616ResetIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616ResetIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ResetIntervals.setDescription(' This variable is used to reset Loop performance intervals. When it is set to reset, the Loop performance tables are reset to zero.')
uas7616SysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616SysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616SysUpTime.setDescription('This variable is used to report the elapsed system tick time for conversion to real time at the controller and is not related to the sysUpTime referenced in MIB-II. Upon power-up of the unit, the elapsed time is cleared. The elapsed time counter rolls over upon reaching the maximum count.')
uas7616SetRealTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616SetRealTime.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616SetRealTime.setDescription('Number of seconds from midnight Dec 31, 1969.')
uas7616ModuleClkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("system", 1), ("internal", 2), ("recovered", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616ModuleClkSrc.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ModuleClkSrc.setDescription('This variable is used to read or set the Module Clock Source. This variable must be system when uas7616SysTimingGen is set to none. Any of the three selections when uas7616SysTimingGen is set to secondary, and internal or recovered when uas7616SysTimingGen is set to primary.')
uas7616ResetMajorAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616ResetMajorAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ResetMajorAlarm.setDescription(' This variable is used to reset alarm per Loop basis.')
uas7616ResetMinorAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616ResetMinorAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ResetMinorAlarm.setDescription(' This variable is used to reset alarm per Loop basis.')
uas7616DiagnosticTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 6), )
if mibBuilder.loadTexts: uas7616DiagnosticTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616DiagnosticTable.setDescription('The GDC 7616 diagnostics table.')
uas7616DiagnosticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 6, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616DiagnosticIndex"), (0, "GDC7616-MIB", "uas7616DiagnosticChnlIndex"))
if mibBuilder.loadTexts: uas7616DiagnosticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616DiagnosticEntry.setDescription('A listing of GDC 7616 diagnostic tests')
uas7616DiagnosticIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616DiagnosticIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616DiagnosticIndex.setDescription('A unique index for the Diagnostic Table.')
uas7616DiagnosticChnlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("channelA", 1), ("channelB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616DiagnosticChnlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616DiagnosticChnlIndex.setDescription('A unique channel index for the Channel the test will run on.')
uas7616DiagnosticTest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("stopTest", 1), ("digitalLoopback", 2), ("patternGenTest", 3), ("unitTest", 4), ("rdl", 5), ("rdlSelfTest", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616DiagnosticTest.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616DiagnosticTest.setDescription('Selections digitalLoopback(2), patternGenTest(3), and unitTest(4) start the associated test when written. Reading will show which (if any) test is active. Writing a stopTestwill stop the test if any was in progress.')
uas7616DiagnosticResetErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616DiagnosticResetErrorCount.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616DiagnosticResetErrorCount.setDescription('This function resets the error count on a given loop and channel. Management will always read a norm(1) and can only write a reset(2).')
uas7616DiagnosticResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2097153))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616DiagnosticResults.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616DiagnosticResults.setDescription('This function reads the self test results in bit errors. 2^20')
uas7616Alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13))
uas7616AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1))
uas7616NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 1))
uas7616DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 2))
uas7616PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 3))
uas7616LossOfClockAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 4))
uas7616LpOutofSyncAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 5))
uas7616LpSealingCurrentNoContinuityAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 6))
uas7616LpUnavailableSecondAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 7))
uas7616LpSeverelyErroredSecondAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 8))
uas7616LpErroredSecondAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 13, 1, 9))
uas7616AlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 13, 2), )
if mibBuilder.loadTexts: uas7616AlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616AlarmConfigTable.setDescription('The uas7616AlarmConfigTable contains entries that configure alarm reporting. The structure of the table is such that alarm configuration is supported on a unit and interface basis, and then on an alarm type basis within the interface. For simplicity sake alarms, be they unit or interface related, are represented in one table.')
uas7616AlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 13, 2, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616AlarmConfigIndex"), (0, "GDC7616-MIB", "uas7616AlarmConfigIdentifier"))
if mibBuilder.loadTexts: uas7616AlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616AlarmConfigEntry.setDescription('An entry in the GDC Alarm Configuration table.')
uas7616AlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 13, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616AlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616AlarmConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
uas7616AlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 13, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616AlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616AlarmConfigIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
uas7616AlarmCountWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 1), ("last1sec", 2), ("last10secs", 3), ("last30secs", 4), ("last1min", 5), ("last15min", 6), ("last1hr", 7), ("last24hrs", 8), ("infinite", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616AlarmCountWindow.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616AlarmCountWindow.setDescription('This variable sets/reads the UAS, SES or ES alarm window. This window is used with the alarm threshold to determine how long the alarm should be active before reporting.')
uas7616AlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("occurrence1x", 1), ("occurrence3x", 2), ("occurrence10x", 3), ("occurrence100x", 4), ("occurrence1Kx", 5), ("occurrence10Kx", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616AlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616AlarmCountThreshold.setDescription('This function sets/reads the UAS, SES or ES alarm threshold criteria. This threshold is used along with the the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active.')
uas7616Current15MinTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 8), )
if mibBuilder.loadTexts: uas7616Current15MinTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Current15MinTable.setDescription('The 7616 15 Min Current table.')
uas7616Current15MinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 8, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616Current15MinIndex"))
if mibBuilder.loadTexts: uas7616Current15MinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Current15MinEntry.setDescription('An entry in the 7616 Current table.')
uas7616Current15MinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616Current15MinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Current15MinIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface.')
uas7616Current15MinStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616Current15MinStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Current15MinStat.setDescription('Returns a bitwise snapshot of the interval statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^1 bit 0 - 2^0 Loop ID Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 4 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 6 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 8 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 9 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 FEBE (Far End Block Error Count) (not available on network element type 30) ')
uas7616IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 9), )
if mibBuilder.loadTexts: uas7616IntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616IntervalTable.setDescription('The 7616 Interval table.')
uas7616IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 9, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616IntervalIndex"), (0, "GDC7616-MIB", "uas7616IntervalNumber"))
if mibBuilder.loadTexts: uas7616IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616IntervalEntry.setDescription('An entry in the Interval table.')
uas7616IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 9, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616IntervalIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface.')
uas7616IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616IntervalNumber.setDescription('The number of Errored Seconds, Unavailable Seconds & Severely Errored Seconds encountered in one of the previous 16, individual 15 minute, intervals.')
uas7616IntervalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 9, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616IntervalStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616IntervalStat.setDescription('Returns a bitwise map of the interface in one of the previous 16, individual 15 minute, intervals. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^1 bit 0 - 2^0 Loop ID Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Interval Octet 3 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 6 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 7 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 8 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 9 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 10 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 11 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 FEBE (Far End Block Error Count) (not available on network element type 30) ')
uas7616Current24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 10), )
if mibBuilder.loadTexts: uas7616Current24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Current24HrTable.setDescription('The Current24Hr table. 4 hour interval.')
uas7616Current24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 10, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616Current24HrIndex"))
if mibBuilder.loadTexts: uas7616Current24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Current24HrEntry.setDescription('An entry in the Current24Hr table.')
uas7616Current24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 10, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616Current24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Current24HrIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface.')
uas7616Current24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616Current24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Current24HrStat.setDescription('Returns a bitwise snapshot of the interval statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^1 bit 0 - 2^0 Loop ID Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 3 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 6 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 8 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 9 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 11 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^23 bit 1 - 2^22 bit 0 - 2^21 Octet 12 bit 7 - not used bit 6 - 2^20 bit 5 - 2^19 bit 4 - 2^18 bit 3 - 2^17 bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 13 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 FEBE (Far End Block Error Count) (not available on network element type 30) ')
uas7616Recent24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 11), )
if mibBuilder.loadTexts: uas7616Recent24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Recent24HrTable.setDescription('The Recent24Hr table. 4 hour interval.')
uas7616Recent24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 11, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616Recent24HrIndex"))
if mibBuilder.loadTexts: uas7616Recent24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Recent24HrEntry.setDescription('An entry in the Recent24Hr table.')
uas7616Recent24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 11, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616Recent24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Recent24HrIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface.')
uas7616Recent24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 11, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616Recent24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Recent24HrStat.setDescription('Returns a bitwise snapshot of the interval statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - 2^1 bit 0 - 2^0 Loop ID Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 3 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 6 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 8 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 9 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 11 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^23 bit 1 - 2^22 bit 0 - 2^21 Octet 12 bit 7 - not used bit 6 - 2^20 bit 5 - 2^19 bit 4 - 2^18 bit 3 - 2^17 bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 13 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 FEBE (Far End Block Error Count) (not available on network element type 30) ')
uas7616UnavailableTimeRegTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 12), )
if mibBuilder.loadTexts: uas7616UnavailableTimeRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616UnavailableTimeRegTable.setDescription('The 7616 Unavailable Time Register table.')
uas7616UnavailableTimeRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 12, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616UnavailableTimeRegIndex"), (0, "GDC7616-MIB", "uas7616UnavailableTimeRegNumber"))
if mibBuilder.loadTexts: uas7616UnavailableTimeRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616UnavailableTimeRegEntry.setDescription('An entry in the Unavailable Time Register table.')
uas7616UnavailableTimeRegIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 12, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616UnavailableTimeRegIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616UnavailableTimeRegIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface.')
uas7616UnavailableTimeRegNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616UnavailableTimeRegNumber.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616UnavailableTimeRegNumber.setDescription('A number between 1 and 6, where the number is the number of the Unavailable Time Register.')
uas7616UnavailableTimeRegStart = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616UnavailableTimeRegStart.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616UnavailableTimeRegStart.setDescription('Start time of one of the Unavailable Time Registers.')
uas7616UnavailableTimeRegStop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616UnavailableTimeRegStop.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616UnavailableTimeRegStop.setDescription('Stop time of one of the Unavailable Time Registers.')
uas7616IntervalMaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 13), )
if mibBuilder.loadTexts: uas7616IntervalMaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616IntervalMaintenanceTable.setDescription('The 7616 Loop Interval Maintenance table. ')
uas7616IntervalMaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 13, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616IntervalMaintenanceIndex"))
if mibBuilder.loadTexts: uas7616IntervalMaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616IntervalMaintenanceEntry.setDescription('The 7616 Interval Maintenance table entry. ')
uas7616IntervalMaintenanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 13, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616IntervalMaintenanceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616IntervalMaintenanceIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a Loop interface.')
uas7616NumberofValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616NumberofValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616NumberofValidIntervals.setDescription(' This variable is used to read the number of intervals collected. Each interval is an increment of 15 minutes.')
uas7616LocalAlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 14), )
if mibBuilder.loadTexts: uas7616LocalAlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalAlarmConfigTable.setDescription('The 7616LocalAlarmConfigTable contains entries that configure alarm reporting.')
uas7616LocalAlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616LocalAlarmConfigIndex"))
if mibBuilder.loadTexts: uas7616LocalAlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalAlarmConfigEntry.setDescription('An entry in the GDC Local Alarm Configuration table.')
uas7616LocalAlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616LocalAlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalAlarmConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
uas7616LocalLossOfClock = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616LocalLossOfClock.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalLossOfClock.setDescription('Disables or enables the Loss of Clock alarm on the Major buss or Minor buss.')
uas7616LocalUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616LocalUAS.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalUAS.setDescription('Disables or enables the UAS alarm on the Major buss or Minor buss.')
uas7616LocalSES = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616LocalSES.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalSES.setDescription('Disables or enables the SES alarm on the Major buss or Minor buss.')
uas7616LocalES = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616LocalES.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalES.setDescription('Disables or enables the ES alarm on the Major buss or Minor buss.')
uas7616LocalOutOfSync = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616LocalOutOfSync.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalOutOfSync.setDescription('Disables or enables the Out of Sync alarm on the Major buss or Minor buss.')
uas7616LocalNoSealingCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616LocalNoSealingCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LocalNoSealingCurrent.setDescription('Disables or enables the No Sealing Current alarm on the Major buss or Minor buss.')
uas7616LPMajor = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616LPMajor.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LPMajor.setDescription('Disables or enables the Major alarm on the Major buss or Minor buss.')
uas7616LPMinor = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616LPMinor.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616LPMinor.setDescription('Disables or enables the Minor alarm on the Minor buss or Minor buss.')
uas7616TSAssignTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 4, 15), )
if mibBuilder.loadTexts: uas7616TSAssignTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616TSAssignTable.setDescription('The 7616TSAssignTable contains entries that provide a means to assign a highway and time slot of that highway to the channel of a loop.')
uas7616TSAssignEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 4, 15, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616TSAssignIndex"), (0, "GDC7616-MIB", "uas7616ChannelIndex"))
if mibBuilder.loadTexts: uas7616TSAssignEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616TSAssignEntry.setDescription('An entry in the GDC Circuit Identification table.')
uas7616TSAssignIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 15, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616TSAssignIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616TSAssignIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
uas7616ChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("channelA", 1), ("channelB", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616ChannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616ChannelIndex.setDescription('The index value which uniquely identifies the channel of the interface to which this entry is applicable.')
uas7616Highway = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notAssigned", 1), ("highway1", 2), ("highway2", 3), ("highway3", 4), ("highway4", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616Highway.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616Highway.setDescription('Defines the highway the channel of the loop is assigned to.')
uas7616TimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 15, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616TimeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616TimeSlot.setDescription('Defines the time slot of the highway the channel of the loop is assigned to. Valid range is 1 to 31. A value of 64 indicates the channel is not assigned to a highway.')
uas7616TSCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 4, 15, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616TSCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616TSCircuitID.setDescription('Name to identify the circuit for the channel of this loop.')
uas7616mAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14))
uas7616mAlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1))
uas7616mNoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 1))
uas7616mDiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 2))
uas7616mPowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 3))
uas7616mLossOfClockAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 4))
uas7616mLpOutofSyncAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 5))
uas7616mLpSealingCurrentNoContinuityAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 6))
uas7616mLpUnavailableSecondAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 7))
uas7616mLpErroredSecondAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 8))
uas7616mLPMajorAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 9))
uas7616mLPMinorAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 14, 1, 10))
uas7616mAlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 14, 2), )
if mibBuilder.loadTexts: uas7616mAlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616mAlarmConfigTable.setDescription('The uas7616mAlarmConfigTable contains entries that configure alarm reporting. The structure of the table is such that alarm configuration is supported on a unit and interface basis, and then on an alarm type basis within the interface. For simplicity sake alarms, be they unit or interface related, are represented in one table.')
uas7616mAlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 14, 2, 1), ).setIndexNames((0, "GDC7616-MIB", "uas7616mAlarmConfigIndex"), (0, "GDC7616-MIB", "uas7616mAlarmConfigIdentifier"))
if mibBuilder.loadTexts: uas7616mAlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616mAlarmConfigEntry.setDescription('An entry in the GDC Alarm Configuration table.')
uas7616mAlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 14, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616mAlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616mAlarmConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
uas7616mAlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 14, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7616mAlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616mAlarmConfigIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
uas7616mAlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("thres10E03", 1), ("thres10E04", 2), ("thres10E05", 3), ("thres10E06", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7616mAlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: uas7616mAlarmCountThreshold.setDescription('This function sets/reads the Major or Minor BER alarm threshold criteria.')
mibBuilder.exportSymbols("GDC7616-MIB", uas7616LocalAlarmConfigIndex=uas7616LocalAlarmConfigIndex, uas7616=uas7616, uas7616ResetMinorAlarm=uas7616ResetMinorAlarm, uas7616mLpErroredSecondAlm=uas7616mLpErroredSecondAlm, uas7616TSAssignTable=uas7616TSAssignTable, uas7616ChBDataRate=uas7616ChBDataRate, uas7616LpSeverelyErroredSecondAlm=uas7616LpSeverelyErroredSecondAlm, uas7616ConfigTable=uas7616ConfigTable, uas7616mDiagRxErrAlm=uas7616mDiagRxErrAlm, uas7616mLPMajorAlm=uas7616mLPMajorAlm, uas7616UnavailableTimeRegNumber=uas7616UnavailableTimeRegNumber, uas7616IntervalNumber=uas7616IntervalNumber, uas7616LocalAlarmConfigEntry=uas7616LocalAlarmConfigEntry, uas7616TXClockSource=uas7616TXClockSource, uas7616mNoResponseAlm=uas7616mNoResponseAlm, uas7616ResetIntervals=uas7616ResetIntervals, uas7616DiagnosticResults=uas7616DiagnosticResults, uas7616AlarmConfigIdentifier=uas7616AlarmConfigIdentifier, uas7616Current15MinTable=uas7616Current15MinTable, uas7616Recent24HrTable=uas7616Recent24HrTable, uas7616WhatAreYouTable=uas7616WhatAreYouTable, uas7616Current15MinStat=uas7616Current15MinStat, uas7616ChannelIndex=uas7616ChannelIndex, uas7616CodeRev=uas7616CodeRev, uas7616WhatAreYouEntry=uas7616WhatAreYouEntry, uas7616UnavailableTimeRegStop=uas7616UnavailableTimeRegStop, uas7616SoftReset=uas7616SoftReset, uas7616LocalAlarmConfigTable=uas7616LocalAlarmConfigTable, uas7616DiagnosticIndex=uas7616DiagnosticIndex, uas7616LossOfClockAlm=uas7616LossOfClockAlm, uas7616IntervalMaintenanceTable=uas7616IntervalMaintenanceTable, uas7616AlarmData=uas7616AlarmData, uas7616IntervalMaintenanceIndex=uas7616IntervalMaintenanceIndex, uas7616WhatAreYouIndex=uas7616WhatAreYouIndex, uas7616mAlarmConfigIndex=uas7616mAlarmConfigIndex, uas7616LpUnavailableSecondAlm=uas7616LpUnavailableSecondAlm, uas7616LPMajor=uas7616LPMajor, uas7616mLPMinorAlm=uas7616mLPMinorAlm, uas7616AlarmCountWindow=uas7616AlarmCountWindow, uas7616Current24HrIndex=uas7616Current24HrIndex, uas7616DiagnosticEntry=uas7616DiagnosticEntry, uas7616SetRealTime=uas7616SetRealTime, uas7616LocalNoSealingCurrent=uas7616LocalNoSealingCurrent, uas7616Highway=uas7616Highway, uas7616mPowerUpAlm=uas7616mPowerUpAlm, uas7616EraseConfig=uas7616EraseConfig, uas7616mAlarm=uas7616mAlarm, uas7616AlarmConfigTable=uas7616AlarmConfigTable, uas7616ChADataRate=uas7616ChADataRate, uas7616ModuleClkSrc=uas7616ModuleClkSrc, uas7616SystemTimingGenStatus=uas7616SystemTimingGenStatus, uas7616AlarmStatus=uas7616AlarmStatus, uas7616NumberofValidIntervals=uas7616NumberofValidIntervals, uas7616LocalSES=uas7616LocalSES, uas7616mAlarmData=uas7616mAlarmData, uas7616SysUpTime=uas7616SysUpTime, uas7616UnavailableTimeRegEntry=uas7616UnavailableTimeRegEntry, uas7616UnavailableTimeRegIndex=uas7616UnavailableTimeRegIndex, uas7616InterfaceType=uas7616InterfaceType, uas7616AlarmCountThreshold=uas7616AlarmCountThreshold, uas7616Recent24HrStat=uas7616Recent24HrStat, uas7616LocalLossOfClock=uas7616LocalLossOfClock, uas7616mLpSealingCurrentNoContinuityAlm=uas7616mLpSealingCurrentNoContinuityAlm, uas7616TerminationType=uas7616TerminationType, uas7616ControlIndex=uas7616ControlIndex, uas7616Recent24HrIndex=uas7616Recent24HrIndex, uas7616LPMinor=uas7616LPMinor, uas7616Current15MinEntry=uas7616Current15MinEntry, uas7616IntervalEntry=uas7616IntervalEntry, uas7616Alarm=uas7616Alarm, uas7616mAlarmConfigIdentifier=uas7616mAlarmConfigIdentifier, uas7616ControlEntry=uas7616ControlEntry, uas7616UnavailableTimeRegStart=uas7616UnavailableTimeRegStart, uas7616TSCircuitID=uas7616TSCircuitID, uas7616LpSealingCurrentNoContinuityAlm=uas7616LpSealingCurrentNoContinuityAlm, uas7616AlarmConfigEntry=uas7616AlarmConfigEntry, uas7616DiagnosticChnlIndex=uas7616DiagnosticChnlIndex, uas7616Current24HrTable=uas7616Current24HrTable, uas7616LocalOutOfSync=uas7616LocalOutOfSync, uas7616LEDStatus=uas7616LEDStatus, bql2=bql2, uas7616TSAssignIndex=uas7616TSAssignIndex, uas7616PowerUpAlm=uas7616PowerUpAlm, uas7616AlarmConfigIndex=uas7616AlarmConfigIndex, uas7616IntervalStat=uas7616IntervalStat, uas7616NoResponseAlm=uas7616NoResponseAlm, uas7616TimeSlot=uas7616TimeSlot, uas7616LpOutofSyncAlm=uas7616LpOutofSyncAlm, uas7616Current24HrStat=uas7616Current24HrStat, uas7616ConfigEntry=uas7616ConfigEntry, uas7616mLossOfClockAlm=uas7616mLossOfClockAlm, uas7616DiagnosticTable=uas7616DiagnosticTable, uas7616mAlarmConfigTable=uas7616mAlarmConfigTable, uas7616IntervalIndex=uas7616IntervalIndex, uas7616SysTimingGen=uas7616SysTimingGen, uas7616mLpUnavailableSecondAlm=uas7616mLpUnavailableSecondAlm, uas7616IntervalTable=uas7616IntervalTable, uas7616mAlarmConfigEntry=uas7616mAlarmConfigEntry, gdc=gdc, uas7616Current24HrEntry=uas7616Current24HrEntry, uas7616DiagRxErrAlm=uas7616DiagRxErrAlm, uas7616LocalUAS=uas7616LocalUAS, uas7616mAlarmCountThreshold=uas7616mAlarmCountThreshold, uas7616DiagnosticResetErrorCount=uas7616DiagnosticResetErrorCount, uas7616LpErroredSecondAlm=uas7616LpErroredSecondAlm, uas7616UnavailableTimeRegTable=uas7616UnavailableTimeRegTable, uas7616ResetMajorAlarm=uas7616ResetMajorAlarm, uas7616IntervalMaintenanceEntry=uas7616IntervalMaintenanceEntry, uas7616MIBVersion=uas7616MIBVersion, uas7616DiagnosticTest=uas7616DiagnosticTest, uas7616mLpOutofSyncAlm=uas7616mLpOutofSyncAlm, uas7616LocalES=uas7616LocalES, uas7616ControlTable=uas7616ControlTable, uas7616TSAssignEntry=uas7616TSAssignEntry, uas7616Recent24HrEntry=uas7616Recent24HrEntry, uas7616ConfigIndex=uas7616ConfigIndex, uas7616Current15MinIndex=uas7616Current15MinIndex)

#
# PySNMP MIB module DES3225G-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DES3225G-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:40:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, ModuleIdentity, Gauge32, TimeTicks, Counter64, Bits, Integer32, Counter32, Unsigned32, NotificationType, IpAddress, MibIdentifier, iso, ObjectIdentity, enterprises = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "ModuleIdentity", "Gauge32", "TimeTicks", "Counter64", "Bits", "Integer32", "Counter32", "Unsigned32", "NotificationType", "IpAddress", "MibIdentifier", "iso", "ObjectIdentity", "enterprises")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

dlink = MibIdentifier((1, 3, 6, 1, 4, 1, 171))
dlink_products = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10)).setLabel("dlink-products")
dlink_Des3225gProd = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 24)).setLabel("dlink-Des3225gProd")
swProperty = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 24, 1))
swModule = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 24, 1, 1))
dlink_mgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11)).setLabel("dlink-mgmt")
des3225gSeries = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 24))
swDevPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 24, 1))
swModulePackage = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 24, 2))
swPortPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 24, 3))
swFdbPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 24, 4))
swDevInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1))
swDevInfoSystemUpTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDevInfoSystemUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: swDevInfoSystemUpTime.setDescription('The value of sysUpTime at the time the switch entered its current operational state. If the current state was entered prior to the last re-initialization, then this object contains a zero value. This value is in units of seconds.')
swDevInfoMaxNumOfModule = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDevInfoMaxNumOfModule.setStatus('mandatory')
if mibBuilder.loadTexts: swDevInfoMaxNumOfModule.setDescription('The maximum number of modules in this device.')
swDevInfoTotalNumOfModule = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDevInfoTotalNumOfModule.setStatus('mandatory')
if mibBuilder.loadTexts: swDevInfoTotalNumOfModule.setDescription('The current actual number of modules in this device.The values range is 1..swDevInfoMaxNumOfModule.')
swDevInfoTotalNumOfPort = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDevInfoTotalNumOfPort.setStatus('mandatory')
if mibBuilder.loadTexts: swDevInfoTotalNumOfPort.setDescription('The number of ports within this switch. This value is the sum of the ports within this switch.')
swDevInfoNumOfPortInUse = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDevInfoNumOfPortInUse.setStatus('mandatory')
if mibBuilder.loadTexts: swDevInfoNumOfPortInUse.setDescription('The number of ports in this switch connected to the segment or the end stations.')
swDevInfoConsoleInUse = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("in-use", 2), ("not-in-use", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDevInfoConsoleInUse.setStatus('mandatory')
if mibBuilder.loadTexts: swDevInfoConsoleInUse.setDescription('This usage indication of console system.')
swDevInfoSystemLedStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDevInfoSystemLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swDevInfoSystemLedStatus.setDescription('This object is a set of system LED indications. The first four octets is defined as system LED. The first LED is power LED. The second LED is console LED. The third LED is GIGA module existing LED. The fourth LED is GIGA module link LED. The other octets following the fourth octets are the port LED. Every two bytes are presented to a port. The first byte is presentd to the Link/Activity LED. The second byte is presented to the Speed LED. There is one byte per LED. The most significant bit is used for blink/solid: Off = The LED is lit permanently. On = The LED blinks. The three least significant bits are used for color: 1 = not lit, 2 = green, 3 = yellow,(orange) 4 = blue, 5 = red, 0+6+7 not used The four remaining bits are currently unused and must be 0. The lastest two octects are defined as slot module type. The first octect is slot 1 module type. The second octect is slot 2 module type, and so on. The module type representation for each byte is listed below: 1 = no slot module, 2 = 1 port BNC, 3 = 2 port Fiber MTRJ, 4 = 2 port TX UTP, 5 = 1 port Fiber SC, 6 = Gigabit other not used')
swDevInfoSaveCfg = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("proceeding", 2), ("completed", 3), ("changed-not-save", 4), ("failed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swDevInfoSaveCfg.setStatus('mandatory')
if mibBuilder.loadTexts: swDevInfoSaveCfg.setDescription('This object indicates the status of the device configuration. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. proceeding(2) - the device configuration is saving into the NV-RAM. completed(3) V all of the device configuration parameters have been saved into NV-RAM. changed-not-save V some of the device configuration parameters have been changed but not saved into NV-RAM. failed(5) - The processing of saving device configuration is failed.')
swDevCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2))
swDevCtrlStpState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevCtrlStpState.setStatus('mandatory')
if mibBuilder.loadTexts: swDevCtrlStpState.setDescription('This object can be enabled or disabled spanning tree algorithm during runtime of the system. When the device is in 802.1Q Vlan mode, this object will be enabled and cannot be disabled.')
swDevIGMPCaptureState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevIGMPCaptureState.setStatus('mandatory')
if mibBuilder.loadTexts: swDevIGMPCaptureState.setDescription('This object indicates Internet Group Management Protocol (IGMP) capture function is enabled or disabled.')
swDevCtrlPartitionModeState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevCtrlPartitionModeState.setStatus('mandatory')
if mibBuilder.loadTexts: swDevCtrlPartitionModeState.setDescription('This object used to enable or disable port auto partition. When the object apply for all ports of the device')
swDevCtrlTableLockState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevCtrlTableLockState.setStatus('mandatory')
if mibBuilder.loadTexts: swDevCtrlTableLockState.setDescription("This object indicates whether the address table is locked. In other words, the address table doesn't learn any more new address. The aging timer is suspended when the address table is locked. As long as the table is locked, all of the frames are dropped if the destination can not be found in the address.When swVlanInfoStatus is in MAC-Base VLAN mode, this object is always disabled.")
swDevCtrlSaveCfg = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 5), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: swDevCtrlSaveCfg.setStatus('mandatory')
if mibBuilder.loadTexts: swDevCtrlSaveCfg.setDescription('As the object is set, the current device configuration is save into to NV-RAM.')
swDevCtrlHOLState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevCtrlHOLState.setStatus('mandatory')
if mibBuilder.loadTexts: swDevCtrlHOLState.setDescription("The object provides a way to prevent HOL (Head Of Line) blocking between ports. HOL protection may prevent forwarding a packet to a blocking port.The idea relies on the assumption that it is better to discard packets destined to blocking ports, then to let them consume more and more buffers in the input-port's Rx-counters because eventually these input ports may become totally blocked. The meanings of the values are: other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. disabled(2) - HOL function disable for device. enabled(3) - HOL function enable for device.")
swDevCtrlAddrLookupModesAndHitRate = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("level0", 1), ("level1", 2), ("level2", 3), ("level3", 4), ("level4", 5), ("level5", 6), ("level6", 7), ("level7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevCtrlAddrLookupModesAndHitRate.setStatus('mandatory')
if mibBuilder.loadTexts: swDevCtrlAddrLookupModesAndHitRate.setDescription('According to the differnet address looke mode setting, to enlarge the address table size is possible in device. But there is side effect as the higher level you have, the lower thorughput device has. That means Level 0 get the smallest table size, but get better performace. We recommand the user use the Level 1 as defualt setting.')
swDevCtrlUploadImageFileName = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevCtrlUploadImageFileName.setStatus('mandatory')
if mibBuilder.loadTexts: swDevCtrlUploadImageFileName.setDescription('The name of the image file to be uploaded from the device to TFTP server when enabling image upload function (by writing swDevCtrlUploadImage).')
swDevCtrlUploadImage = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 2, 9), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: swDevCtrlUploadImage.setStatus('mandatory')
if mibBuilder.loadTexts: swDevCtrlUploadImage.setDescription('Image file upload control. Writing it by any value will immediately invoke image upload function.')
swDevAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 3))
swDevAlarmPartition = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevAlarmPartition.setStatus('mandatory')
if mibBuilder.loadTexts: swDevAlarmPartition.setDescription("Depending on this object, the device send a trap or not when any one of the device's ports was partitioned.")
swDevAlarmNewRoot = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevAlarmNewRoot.setStatus('mandatory')
if mibBuilder.loadTexts: swDevAlarmNewRoot.setDescription('When the device has become the new root of the Spanning Tree, this object decide whether to send a new root trap.')
swDevAlarmTopologyChange = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevAlarmTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: swDevAlarmTopologyChange.setDescription("This object determine to send a trap or not when the switch topology was changed. If the object is enabled(3), the topologyChange trap is sent by the device when any of its configured ports transitions from the Learning state to the Forwarding state, or from the Forwarding state to the Blocking state. For the same port tranition, the device doesn't send the trap if this object value is disabled or other.")
swDevAlarmLinkChange = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swDevAlarmLinkChange.setStatus('mandatory')
if mibBuilder.loadTexts: swDevAlarmLinkChange.setDescription("This object determine to send a trap or not when the link was changed. If the object is enabled(3), the Link Change trap is sent by the device when any of its ports link change. The device doesn't send the trap if this object value is disabled or other.")
swModuleInfoTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 24, 2, 1), )
if mibBuilder.loadTexts: swModuleInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: swModuleInfoTable.setDescription('A table that contains information about every module.')
swModuleInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 24, 2, 1, 1), ).setIndexNames((0, "DES3225G-MIB", "swModuleInfoIndex"))
if mibBuilder.loadTexts: swModuleInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swModuleInfoEntry.setDescription('A list of information for each module of the device.')
swModuleInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swModuleInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swModuleInfoIndex.setDescription('This object indicates switch module number.(1..swDevInfoMaxNumOfModule)')
swModuleInfoDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swModuleInfoDesc.setStatus('mandatory')
if mibBuilder.loadTexts: swModuleInfoDesc.setDescription('A textual description of the module for memorization .')
swModuleInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("baseModule-UTP", 2), ("optionModule-2PortFiber-MTRJ", 3), ("optionModule-2PortTX-UTP", 4), ("optionModule-1PortFiber-SC", 5), ("optionModule-1000Base-SX", 6), ("optionModule-1000Base-LX", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swModuleInfoType.setStatus('mandatory')
if mibBuilder.loadTexts: swModuleInfoType.setDescription('This object indicates the type of this module.')
swModuleInfoTotalNumOfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swModuleInfoTotalNumOfPort.setStatus('mandatory')
if mibBuilder.loadTexts: swModuleInfoTotalNumOfPort.setDescription('The number of ports within this module. This value is the sum of the ports within this module.')
swModuleInfoNumOfPortInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swModuleInfoNumOfPortInUse.setStatus('mandatory')
if mibBuilder.loadTexts: swModuleInfoNumOfPortInUse.setDescription('The number of ports in this module connected to the segment or the end stations.')
swModuleInfoPortLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swModuleInfoPortLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swModuleInfoPortLedStatus.setDescription("This object is a set of module's port LED indications. Every two bytes are presented to a port. Except the module 3 (Gigabit module) ,the first byte is presentd to the Link/Activity LED. The second byte is presented to the Speed LED. For the module 3 ,the first byte is presentd to the module's existing LED. The second byte is presented to the Link/Activity LED. There is one byte per LED. The most significant bit is used for blink/solid: Off = The LED is lit permanently. On = The LED blinks. The three least significant bits are used for color: 1 = not lit, 2 = green, 3 = yellow,(orange) 4 = blue, 5 = red, 0+6+7 not used The four remaining bits are currently unused and must be 0.")
swPortInfoTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 1), )
if mibBuilder.loadTexts: swPortInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInfoTable.setDescription('A table that contains information about every port.')
swPortInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 1, 1), ).setIndexNames((0, "DES3225G-MIB", "swPortInfoModuleIndex"), (0, "DES3225G-MIB", "swPortInfoPortIndex"))
if mibBuilder.loadTexts: swPortInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInfoEntry.setDescription('A list of information for each port of the device.')
swPortInfoModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortInfoModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInfoModuleIndex.setDescription('This object indicates switch module number.(1..Max module number)')
swPortInfoPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortInfoPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInfoPortIndex.setDescription("This object indicates the module's port number.(1..Max port number in the module)")
swPortInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("portType-UTP", 2), ("portType-AUI", 3), ("portType-Fiber-MTRJ", 4), ("portType-Fiber-SC", 5), ("portType-BNC", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortInfoType.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInfoType.setDescription('This object indicates the connector type of this port.')
swPortInfoLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("link-pass", 2), ("link-fail", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortInfoLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInfoLinkStatus.setDescription('This object indicates the port link status.')
swPortInfoNwayStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("half-10Mbps", 2), ("full-10Mbps", 3), ("half-100Mbps", 4), ("full-100Mbps", 5), ("half-1Gigabps", 6), ("full-1Gigabps", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortInfoNwayStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInfoNwayStatus.setDescription('This object indicates the port speed and duplex mode.')
swPortInfoFlowCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("flowctrl-disabled", 2), ("flowctrl-enabled", 3), ("backpressure-disabled", 4), ("backpressure-enabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortInfoFlowCtrlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swPortInfoFlowCtrlStatus.setDescription('This object indicates the port flow control status.')
swPortCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2), )
if mibBuilder.loadTexts: swPortCtrlTable.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlTable.setDescription('A table that contains control information about every port.')
swPortCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1), ).setIndexNames((0, "DES3225G-MIB", "swPortCtrlModuleIndex"), (0, "DES3225G-MIB", "swPortCtrlPortIndex"))
if mibBuilder.loadTexts: swPortCtrlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlEntry.setDescription('A list of control information for each port of the device.')
swPortCtrlModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortCtrlModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlModuleIndex.setDescription('This object indicates the device module number.(1..Max module number)')
swPortCtrlPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortCtrlPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlPortIndex.setDescription("This object indicates the module's port number.(1..Max port number in the module)")
swPortCtrlAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlAdminState.setDescription('This object decide the port enabled or disabled.')
swPortCtrlLinkStatusAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlLinkStatusAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlLinkStatusAlarmState.setDescription('Depending on this object to determine to send a trap or not when link status changes .')
swPortCtrlNwayState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("nway-enabled", 2), ("nway-disabled-10Mbps-Half", 3), ("nway-disabled-10Mbps-Full", 4), ("nway-disabled-100Mbps-Half", 5), ("nway-disabled-100Mbps-Full", 6), ("nway-disabled-1Gigabps-Half", 7), ("nway-disabled-1Gigabps-Full", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlNwayState.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlNwayState.setDescription('Chose the port speed, duplex mode, and N-Way function mode.')
swPortCtrlFlowCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlFlowCtrlState.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlFlowCtrlState.setDescription('Set IEEE 802.3x compliant flow control function as enabled or disabled. And IEEE 802.3x compliant flow control function work only when the port is in full duplex mode.If the port is set Auto-negotiation enabled, the object stands for flow control capability. The results should be referred to swPortInfoFlowCtrlStatus object. If the port is in force mode, this objects is simply used to set the flow control state (on/off). In force mode, if you change it from enabled to disabled state, it will work after next system restart. But the flow control changing from disabled to enabled state, it will immediately work.')
swPortCtrlBackPressState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlBackPressState.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlBackPressState.setDescription('Depending on this object determine to enable or disable the backpressure function when the port is working in half duplex mode.')
swPortCtrlLockState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlLockState.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlLockState.setDescription("The state of this entry. When the swDevCtrlTableLockState object is enabled, the state is not changed. When swVlanInfoStatus is in MAC-Base VLAN mode, this object is always disabled.The meanings of the values are: other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. disable(2) - Port lock funtion disable. enable(3) - Locking a port. Once the port is locked, it will not learn new SA addresses, and drop unknown/moved-SA packets forwarding to/from such ports. This is a way to prevent undesired traffic from being received or transmmited on the port. Note that locking a port doesn't lock the MAC address entries associated with the locked port, i.e. the existing address entries of the locked port will be age out even though it is locked.")
swPortCtrlPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("default", 2), ("force-low-priority", 3), ("force-high-priority", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlPriority.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlPriority.setDescription('The priority queueing for packets received on this port, except for BPDU/IGMP packets and packets with unknown unicast destination address. IGMP and BPDU packets are always routed with high priority; packets with unknown unicast destination addresses are always routed with low priority. Other packets follow the rules below: other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. default(2) - A packet is normally classified as low priority ,unless at least one of the following is true: .The packet contained a TAG (per 802.1Q definition) with the priority greater or equal to 4. .The address-table entry for the destination address had Pd=HIGH. force-low_priority(3) - A packet is normally classified as low priority. force-high_priority(4) - A packet is normally classified as high priority.')
swPortCtrlStpState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlStpState.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlStpState.setDescription("The state of STP(spanning tree algorithm) operation on this port. That's meaning the port whether add in the STP. The value enabled(3) indicates that STP is enabled on this port, as long as swDevCtrlStpState is also enabled for this device. When disabled(2) but swDevCtrlStpState is still enabled for the device, STP is disabled on this port : any BPDU packets received will be discarded and no BPDU packets will be propagated from the port. When the device is in 802.1Q Vlan mode, this object will be enabled and cannot be disabled.")
swPortCtrlHOLState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlHOLState.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlHOLState.setDescription("The object provides a way to prevent HOL (Head Of Line) blocking between ports. HOL protection may prevent forwarding a packet to a blocking port.The idea relies on the assumption that it is better to discard packets destined to blocking ports, then to let them consume more and more buffers in the input-port's Rx-counters because eventually these input ports may become totally blocked. The value enabled(3) indicates that HOL function is enabled on this port, as long as swDevCtrlHOLState is also enabled for this device. When disabled(2) but swDevCtrlHOLState is still enabled for the device, HOL function is disabled on this port. The meanings of the values are: other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. disabled(2) - HOL function disable. enabled(3) - HOL function enable.")
swPortCtrlBroadcastRisingThr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1488000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlBroadcastRisingThr.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlBroadcastRisingThr.setDescription('This allows the user to specify the broadcast packets per second. Broadcast traffic above this rate activates broadcast storm control (i.e. swPortCtrlBroadcastRisingAct) on the port. The default value is 500 broadcast packets per second. The setting must be bigger than the value in swPortCtrlBroadcastFallingThr.')
swPortCtrlBroadcastFallingThr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1488000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlBroadcastFallingThr.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlBroadcastFallingThr.setDescription('This allows the user to specify the broadcast packets per second. If broadcast traffic is below this rate and rising threshold condition has been met at least once before this falling threshold is met, the device will apply the action described in swPortCtrlBroadcastFallingAct. The default value 250. The setting must be fewer than the value in swPortCtrlBroadcastRisingThr.')
swPortCtrlBroadcastRisingAct = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("do-nothing", 2), ("blocking", 3), ("blocking-trap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlBroadcastRisingAct.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlBroadcastRisingAct.setDescription('This object indicates the system action when broadcast storm rising threshold is met. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. do-nothing(2) - no action. blocking(3) - the port can discard any coming broadcast frame. blocking-trap(4) - the port can discard any coming broadcast frame. And the device can send a broadcast rising trap.')
swPortCtrlBroadcastFallingAct = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("do-nothing", 2), ("forwarding", 3), ("forwarding-trap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swPortCtrlBroadcastFallingAct.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlBroadcastFallingAct.setDescription('This object indicates the device action when broadcast storm falling threshold is met. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. do-nothing(2) - no action. forwarding(3) - the port has returned to normal operation mode. forwarding-trap(4) - the port has returned to normal operation mode. And the device can send a broadcast falling trap.')
swPortCtrlCleanAllStatisticCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 2, 1, 16), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: swPortCtrlCleanAllStatisticCounter.setStatus('mandatory')
if mibBuilder.loadTexts: swPortCtrlCleanAllStatisticCounter.setDescription("Setting this object will reset current device's all statistic counters.")
swPortStTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3), )
if mibBuilder.loadTexts: swPortStTable.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStTable.setDescription('A list of port statistic Counter entries.')
swPortStEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1), ).setIndexNames((0, "DES3225G-MIB", "swPortStModuleIndex"), (0, "DES3225G-MIB", "swPortStPortIndex"))
if mibBuilder.loadTexts: swPortStEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStEntry.setDescription('This entry include all the port statistic Counter which support by the device, like Bytes received, Bytes Sent ...')
swPortStModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStModuleIndex.setDescription('This object indicates the device module number.(1..Max module number)')
swPortStPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStPortIndex.setDescription("This object indicates the module's port number.(1..Max port number in the module)")
swPortStByteRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStByteRx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStByteRx.setDescription('swDevCtrlCounterMode = 2(switched-frames):This counter is incre- mented once for every data octet of good packets(unicast + multi- cast + broadcast) received. swDevCtrlCounterMode = 3(all-frames):This counter is incremented once for every data octet of good packets(unicast + multicast + broadcast packets) and for local and dropped packets.')
swPortStByteTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStByteTx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStByteTx.setDescription('This counter is incremented once for every data octet of a trans- mitted good packet.')
swPortStFrameRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFrameRx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFrameRx.setDescription('swDevCtrlCounterMode = 2(switched-frames):This counter is incre- mented once for every good packet(unicast + multicast + broadcast ) received. swDevCtrlCounterMode = 3(all-frames):This counter is incremented once for every good packet(unicast + multicast + broadcast packets) and for local and dropped packets received.')
swPortStFrameTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFrameTx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFrameTx.setDescription('This counter is incremented once for every transmitted good packet.')
swPortStTotalBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStTotalBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStTotalBytesRx.setDescription('This counter is incremented once for every data octet of all received packets. This include data octets of rejected and local packets which are not forwarded to the switching core for trans- mission. This counter should reflect all the data octets received on the line. Note: A nibble is not counted as a whole byte.')
swPortStTotalFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStTotalFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStTotalFramesRx.setDescription('This counter is incremented once for every received packets. This include rejected and local packets which are not forwarded to the switching core for transmission. This counter should reflect all packets received on the line.')
swPortStBroadcastFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStBroadcastFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStBroadcastFramesRx.setDescription('swDevCtrlCounterMode = 2(switched-frames):This counter is incre- mented once for every good broadcast packet received. swDevCtrlCounterMode = 3(all-frames):This counter is incremented once for every good broadcast packet received and for local and dropped broadcast packets.')
swPortStMulticastFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStMulticastFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStMulticastFramesRx.setDescription('swDevCtrlCounterMode = 2(switched-frames):This counter is incre- mented once for every good multicast packet received. swDevCtrlCounterMode = 3(all-frames):This counter is incremented once for every good multicast packet received and for local and dropped multicast packets. This counter does not include broad- cast packets.')
swPortStCRCError = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStCRCError.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStCRCError.setDescription('This counter is incremented once for every received packet which meets all the following conditions: 1.Packet data length is between 64 and 1518 bytes inclusive. 2.Packet has invalid CRC. 3.Collision event , late collision event and receive error event have not been detected.')
swPortStOversizeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStOversizeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStOversizeFrames.setDescription('The number of good frames with length more than 1518 bytes.')
swPortStFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFragments.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFragments.setDescription('This counter is incremented once for every received packet which meets all the following conditions: 1.Packet data length is less than 64 bytes or packet withourt SFD and is less than 64 bytes in length. 2.Packet has invalid CRC. 3.Collision event , late collision event and receive error event have not been detected.')
swPortStJabber = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStJabber.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStJabber.setDescription('The number of frames with length more than 1518 bytes and with CRC error or misaligned.')
swPortStCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStCollision.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStCollision.setDescription('The number of Collisions')
swPortStLateCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStLateCollision.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStLateCollision.setDescription('The number of Late Collision(collision occurring later than 576th transmitted bit).')
swPortStFrames_64_bytes = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 17), Counter32()).setLabel("swPortStFrames-64-bytes").setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFrames_64_bytes.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFrames_64_bytes.setDescription('This counter is incremented once for every received and trans- mitted packet with size of 64 bytes. This counter includes reject- ed received and transmitted packets.')
swPortStFrames_65_127_bytes = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 18), Counter32()).setLabel("swPortStFrames-65-127-bytes").setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFrames_65_127_bytes.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFrames_65_127_bytes.setDescription('This counter is incremented once for every received and trans- mitted packet with size of 65 to 127 bytes. This counter includes rejected received and transmitted packets.')
swPortStFrames_128_255_bytes = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 19), Counter32()).setLabel("swPortStFrames-128-255-bytes").setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFrames_128_255_bytes.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFrames_128_255_bytes.setDescription('This counter is incremented once for every received and trans- mitted packet with size of 128 to 255 bytes. This counter includes rejected received and transmitted packets.')
swPortStFrames_256_511_bytes = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 20), Counter32()).setLabel("swPortStFrames-256-511-bytes").setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFrames_256_511_bytes.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFrames_256_511_bytes.setDescription('This counter is incremented once for every received and trans- mitted packet with size of 256 to 511 bytes. This counter includes rejected received and transmitted packets.')
swPortStFrames_512_1023_bytes = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 21), Counter32()).setLabel("swPortStFrames-512-1023-bytes").setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFrames_512_1023_bytes.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFrames_512_1023_bytes.setDescription('This counter is incremented once for every received and trans- mitted packet with size of 512 to 1023 bytes. This counter includ- es rejected received and transmitted packets.')
swPortStFrames_1024_1536_bytes = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 22), Counter32()).setLabel("swPortStFrames-1024-1536-bytes").setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFrames_1024_1536_bytes.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFrames_1024_1536_bytes.setDescription('This counter is incremented once for every received and trans- mitted packet with size of 1024 to 1536 bytes. This counter includ- es rejected received and transmitted packets.')
swPortStFramesDroppedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStFramesDroppedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStFramesDroppedFrames.setDescription('This counter is incremented once for every received dropped pack- et.')
swPortStMulticastFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStMulticastFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStMulticastFramesTx.setDescription('The number of multicast frames sent. This counter does not include broadcast packets.')
swPortStBroadcastFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStBroadcastFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStBroadcastFramesTx.setDescription('The number of broadcast frames sent.')
swPortStUndersizeFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 3, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swPortStUndersizeFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swPortStUndersizeFrames.setDescription('This counter is incremented once for every received packet which meets all the following conditions: 1.Packet data length is less than 64 bytes. 2.Packet has valid CRC. 3.Collision event , late collision event and receive error event have not been detected.')
swFdbStaticTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 1), )
if mibBuilder.loadTexts: swFdbStaticTable.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbStaticTable.setDescription('Like typical legacy bridge devices, FDB table records the mapping of Source MAC Address and its associated source port, and forward incoming packets to its destination port according to the Destination MAC Address of the packet as well as the MAC-port pair entries of the FDB table. Note that the priority of FDB table entries is lower than Filtering Table, i.e. if there is a table hash collision between the entries of FDB Table and Filtering Table inside the switch H/W address table, then Filtering Table entry overwrite the colliding entry of FDB Table. See swFdbFilterTable description also.')
swFdbStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 1, 1), ).setIndexNames((0, "DES3225G-MIB", "swFdbStaticVid"), (0, "DES3225G-MIB", "swFdbStaticAddressIndex"))
if mibBuilder.loadTexts: swFdbStaticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbStaticEntry.setDescription('A list of information specifies which ports the frames with specific destination MAC address to go. ')
swFdbStaticVid = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swFdbStaticVid.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbStaticVid.setDescription('This object indicates the VLAN-ID. If VLAN is in mac-based mode or disabled, the object indicates the default VLAN-ID (0).')
swFdbStaticAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swFdbStaticAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbStaticAddressIndex.setDescription("The destination MAC address in a frame to which this entry's forwarding information applies. This object can take the value of an unicast address or the multicast address.")
swFdbStaticPortMap = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swFdbStaticPortMap.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbStaticPortMap.setDescription("The set of ports to which frames received from a specific port and destined for a specific MAC address, are allowed to be forwarded. Each octet within the value of this object specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'.(Note that the setting of the bit corresponding to the port from which a frame is received is irrelevant.). In module 1 (base module), there are 22 100M twisted-pair ports (port 1..22) which is mapped to the PortMap's port 1 to 22 respectively. In module 2 (slot 1 module), there are 2 100M FX/100 TX (or a single port 100M FX) ports which is mapped to the PortMap's port 23, 24 respectively (if the module is a single port 100M FX , it is just mapped to port 23 and port 24 is ignored). Module 3 (slot 2 module) is a single-port Gigabit Ethernet and it is mapped to the PortMap's port 25.")
swFdbStaticState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swFdbStaticState.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbStaticState.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
swFdbStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("apply", 2), ("not-apply", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swFdbStaticStatus.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbStaticStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. apply(2) - this entry is currently in use and reside in the table. not-apply(3) - this entry is reside in the table but currently not in use due to conflict with filter table.')
swFdbFilterTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 2), )
if mibBuilder.loadTexts: swFdbFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbFilterTable.setDescription("A table which contains the filtering information of the unicast/multicast entries. This table is used by the transparent switching function in determining how to filter the received frames. The Filtering Table entries' priority overrides Static FDB Table as well as IGMP table entries, say, if there is a hash table entry collision between Filtering Table and Static FDB Table setting in the switch device's H/W address table, then Filter Table entry setting overwrites the colliding entry in Static FDB Table. See swFdbStaticTable description also.")
swFdbFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 2, 1), ).setIndexNames((0, "DES3225G-MIB", "swFdbFilterVid"), (0, "DES3225G-MIB", "swFdbFilterAddressIndex"))
if mibBuilder.loadTexts: swFdbFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbFilterEntry.setDescription('A list of information about a specific unicast/multicast MAC address for which the switch has filtering information.')
swFdbFilterVid = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swFdbFilterVid.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbFilterVid.setDescription('This object indicates the VLAN-ID. If VLAN is in mac-based mode or disabled, the object indicates the default VLAN-ID (0).')
swFdbFilterAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swFdbFilterAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbFilterAddressIndex.setDescription('This object indicates a unicast/multicast MAC address for which the bridge has filtering information.')
swFdbFilterState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 24, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("dst-src-addr", 2), ("invalid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swFdbFilterState.setStatus('mandatory')
if mibBuilder.loadTexts: swFdbFilterState.setDescription("This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. dst-src-addr(2) - recieved frames's destination address or source address are currently used to be filtered as it meets with the MAC address entry of the table. invalid(3) - writing this value to the object, and then the corresponding entry will be removed from the table.")
portPartition = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 24, 1) + (0,1)).setObjects(("DES3225G-MIB", "swPortInfoModuleIndex"), ("DES3225G-MIB", "swPortInfoPortIndex"))
if mibBuilder.loadTexts: portPartition.setDescription('The trap is sent whenever the port state enter the Partion mode when more than 61 collisions occur while trasmitting.')
linkChangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 24, 1) + (0,2)).setObjects(("DES3225G-MIB", "swPortInfoModuleIndex"), ("DES3225G-MIB", "swPortInfoPortIndex"))
if mibBuilder.loadTexts: linkChangeEvent.setDescription('The trap is sent whenever the link state of a port changes from link up to link down or from link down to link up')
broadcastRisingStorm = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 24, 1) + (0,3)).setObjects(("DES3225G-MIB", "swPortInfoModuleIndex"), ("DES3225G-MIB", "swPortInfoPortIndex"))
if mibBuilder.loadTexts: broadcastRisingStorm.setDescription('The trap indicates that broadcast higher rising threshold . This trap including the port ID')
broadcastFallingStorm = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 24, 1) + (0,4)).setObjects(("DES3225G-MIB", "swPortInfoModuleIndex"), ("DES3225G-MIB", "swPortInfoPortIndex"))
if mibBuilder.loadTexts: broadcastFallingStorm.setDescription('The trap indicates that broadcast higher falling threshold . This trap including the port ID')
mibBuilder.exportSymbols("DES3225G-MIB", swDevAlarmTopologyChange=swDevAlarmTopologyChange, swDevCtrlUploadImageFileName=swDevCtrlUploadImageFileName, swFdbFilterState=swFdbFilterState, swPortCtrlAdminState=swPortCtrlAdminState, swDevAlarmLinkChange=swDevAlarmLinkChange, swPortStEntry=swPortStEntry, swPortStCollision=swPortStCollision, swPortStFrames_512_1023_bytes=swPortStFrames_512_1023_bytes, swDevInfo=swDevInfo, swPortStTotalBytesRx=swPortStTotalBytesRx, swPortCtrlEntry=swPortCtrlEntry, swPortStFrameRx=swPortStFrameRx, swPortStMulticastFramesRx=swPortStMulticastFramesRx, swDevAlarmNewRoot=swDevAlarmNewRoot, swFdbStaticVid=swFdbStaticVid, swPortStFramesDroppedFrames=swPortStFramesDroppedFrames, swPortInfoFlowCtrlStatus=swPortInfoFlowCtrlStatus, swDevInfoNumOfPortInUse=swDevInfoNumOfPortInUse, swPortCtrlBroadcastRisingAct=swPortCtrlBroadcastRisingAct, swPortCtrlCleanAllStatisticCounter=swPortCtrlCleanAllStatisticCounter, swDevInfoSystemLedStatus=swDevInfoSystemLedStatus, swModuleInfoDesc=swModuleInfoDesc, swModule=swModule, swPortStFragments=swPortStFragments, swModuleInfoType=swModuleInfoType, swDevCtrlAddrLookupModesAndHitRate=swDevCtrlAddrLookupModesAndHitRate, swPortStFrames_65_127_bytes=swPortStFrames_65_127_bytes, swModuleInfoEntry=swModuleInfoEntry, swFdbStaticTable=swFdbStaticTable, swPortStByteTx=swPortStByteTx, swFdbStaticPortMap=swFdbStaticPortMap, linkChangeEvent=linkChangeEvent, broadcastFallingStorm=broadcastFallingStorm, swPortInfoNwayStatus=swPortInfoNwayStatus, swPortStTable=swPortStTable, swDevCtrlStpState=swDevCtrlStpState, swPortStMulticastFramesTx=swPortStMulticastFramesTx, swPortStCRCError=swPortStCRCError, dlink_mgmt=dlink_mgmt, swPortCtrlBroadcastFallingAct=swPortCtrlBroadcastFallingAct, dlink_Des3225gProd=dlink_Des3225gProd, swPortStBroadcastFramesRx=swPortStBroadcastFramesRx, swFdbStaticState=swFdbStaticState, swDevAlarmPartition=swDevAlarmPartition, swFdbStaticStatus=swFdbStaticStatus, swModulePackage=swModulePackage, swDevInfoSaveCfg=swDevInfoSaveCfg, swPortStFrameTx=swPortStFrameTx, swFdbPackage=swFdbPackage, swPortCtrlBroadcastFallingThr=swPortCtrlBroadcastFallingThr, dlink_products=dlink_products, swPortCtrlNwayState=swPortCtrlNwayState, MacAddress=MacAddress, swDevAlarm=swDevAlarm, swPortStLateCollision=swPortStLateCollision, swPortCtrlLockState=swPortCtrlLockState, swDevInfoConsoleInUse=swDevInfoConsoleInUse, portPartition=portPartition, swPortCtrlLinkStatusAlarmState=swPortCtrlLinkStatusAlarmState, swPortCtrlBroadcastRisingThr=swPortCtrlBroadcastRisingThr, swPortStPortIndex=swPortStPortIndex, swModuleInfoIndex=swModuleInfoIndex, swFdbStaticEntry=swFdbStaticEntry, swPortInfoEntry=swPortInfoEntry, swPortCtrlFlowCtrlState=swPortCtrlFlowCtrlState, swPortStFrames_256_511_bytes=swPortStFrames_256_511_bytes, swDevCtrlUploadImage=swDevCtrlUploadImage, broadcastRisingStorm=broadcastRisingStorm, swPortCtrlHOLState=swPortCtrlHOLState, swDevCtrlTableLockState=swDevCtrlTableLockState, swModuleInfoTotalNumOfPort=swModuleInfoTotalNumOfPort, swPortStTotalFramesRx=swPortStTotalFramesRx, swPortInfoPortIndex=swPortInfoPortIndex, swPortCtrlBackPressState=swPortCtrlBackPressState, des3225gSeries=des3225gSeries, swPortStUndersizeFrames=swPortStUndersizeFrames, swPortCtrlPriority=swPortCtrlPriority, swPortCtrlStpState=swPortCtrlStpState, swPortCtrlModuleIndex=swPortCtrlModuleIndex, swFdbFilterEntry=swFdbFilterEntry, swDevInfoTotalNumOfPort=swDevInfoTotalNumOfPort, swDevIGMPCaptureState=swDevIGMPCaptureState, swPortInfoLinkStatus=swPortInfoLinkStatus, swPortStFrames_64_bytes=swPortStFrames_64_bytes, swDevInfoMaxNumOfModule=swDevInfoMaxNumOfModule, swPortStJabber=swPortStJabber, swDevCtrlPartitionModeState=swDevCtrlPartitionModeState, swPortStOversizeFrames=swPortStOversizeFrames, swDevCtrlHOLState=swDevCtrlHOLState, swPortCtrlPortIndex=swPortCtrlPortIndex, dlink=dlink, swFdbFilterAddressIndex=swFdbFilterAddressIndex, swPortStFrames_1024_1536_bytes=swPortStFrames_1024_1536_bytes, swModuleInfoTable=swModuleInfoTable, swPortStModuleIndex=swPortStModuleIndex, swDevCtrlSaveCfg=swDevCtrlSaveCfg, swPortInfoType=swPortInfoType, swPortInfoTable=swPortInfoTable, swPortPackage=swPortPackage, swPortCtrlTable=swPortCtrlTable, swProperty=swProperty, swDevPackage=swDevPackage, swPortInfoModuleIndex=swPortInfoModuleIndex, swPortStBroadcastFramesTx=swPortStBroadcastFramesTx, swFdbStaticAddressIndex=swFdbStaticAddressIndex, swFdbFilterTable=swFdbFilterTable, swDevInfoTotalNumOfModule=swDevInfoTotalNumOfModule, swDevCtrl=swDevCtrl, swDevInfoSystemUpTime=swDevInfoSystemUpTime, swModuleInfoNumOfPortInUse=swModuleInfoNumOfPortInUse, swModuleInfoPortLedStatus=swModuleInfoPortLedStatus, swFdbFilterVid=swFdbFilterVid, swPortStByteRx=swPortStByteRx, swPortStFrames_128_255_bytes=swPortStFrames_128_255_bytes)

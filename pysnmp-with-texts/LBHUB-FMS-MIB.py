#
# PySNMP MIB module LBHUB-FMS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LBHUB-FMS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:01 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
rpMauMediaAvailable, rptrPortAutoPartitionState = mibBuilder.importSymbols("MAU-MIB", "rpMauMediaAvailable", "rptrPortAutoPartitionState")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, Counter64, NotificationType, Unsigned32, NotificationType, enterprises, ObjectIdentity, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, IpAddress, Counter32, Bits, Gauge32, MibIdentifier, mgmt, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Counter64", "NotificationType", "Unsigned32", "NotificationType", "enterprises", "ObjectIdentity", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "IpAddress", "Counter32", "Bits", "Gauge32", "MibIdentifier", "mgmt", "TimeTicks")
DisplayString, TextualConvention, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "PhysAddress")
mib_2 = MibIdentifier((1, 3, 6, 1, 2, 1)).setLabel("mib-2")
class DisplayString(OctetString):
    pass

class PhysAddress(OctetString):
    pass

system = MibIdentifier((1, 3, 6, 1, 2, 1, 1))
interfaces = MibIdentifier((1, 3, 6, 1, 2, 1, 2))
at = MibIdentifier((1, 3, 6, 1, 2, 1, 3))
ip = MibIdentifier((1, 3, 6, 1, 2, 1, 4))
icmp = MibIdentifier((1, 3, 6, 1, 2, 1, 5))
tcp = MibIdentifier((1, 3, 6, 1, 2, 1, 6))
udp = MibIdentifier((1, 3, 6, 1, 2, 1, 7))
egp = MibIdentifier((1, 3, 6, 1, 2, 1, 8))
transmission = MibIdentifier((1, 3, 6, 1, 2, 1, 10))
snmp = MibIdentifier((1, 3, 6, 1, 2, 1, 11))
dot1dBridge = MibIdentifier((1, 3, 6, 1, 2, 1, 17))
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1))
terminalServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 1))
dedicatedBridgeServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 2))
dedicatedRouteServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 3))
brouter = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 4))
genericMSWorkstation = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 5))
genericMSServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 6))
genericUnixServer = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 7))
hub = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8))
cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9))
chipsets = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 10))
linkBuilder3GH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 1))
linkBuilder10BTi = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 2))
linkBuilderECS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 3))
linkBuilderMSH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 4))
linkBuilderFMS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 5))
linkBuilderFDDIwg = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 6))
linkBuilderFMSII = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 7))
linkSwitchFMS = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 8))
linkSwitchMSH = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 9))
linkBuilderFMSLBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 8, 10))
linkBuilder3GH_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 1)).setLabel("linkBuilder3GH-cards")
linkBuilder10BTi_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2)).setLabel("linkBuilder10BTi-cards")
linkBuilderECS_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 3)).setLabel("linkBuilderECS-cards")
linkBuilderMSH_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 4)).setLabel("linkBuilderMSH-cards")
linkBuilderFMS_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5)).setLabel("linkBuilderFMS-cards")
linkBuilderFMSII_cards = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6)).setLabel("linkBuilderFMSII-cards")
linkBuilder10BTi_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2, 1)).setLabel("linkBuilder10BTi-cards-utp")
linkBuilder10BT_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 2, 2)).setLabel("linkBuilder10BT-cards-utp")
linkBuilderFMS_cards_utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 1)).setLabel("linkBuilderFMS-cards-utp")
linkBuilderFMS_cards_coax = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 2)).setLabel("linkBuilderFMS-cards-coax")
linkBuilderFMS_cards_fiber = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 3)).setLabel("linkBuilderFMS-cards-fiber")
linkBuilderFMS_cards_12fiber = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 4)).setLabel("linkBuilderFMS-cards-12fiber")
linkBuilderFMS_cards_24utp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 5, 5)).setLabel("linkBuilderFMS-cards-24utp")
linkBuilderFMSII_cards_12tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 1)).setLabel("linkBuilderFMSII-cards-12tp-rj45")
linkBuilderFMSII_cards_10coax_bnc = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 2)).setLabel("linkBuilderFMSII-cards-10coax-bnc")
linkBuilderFMSII_cards_6fiber_st = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 3)).setLabel("linkBuilderFMSII-cards-6fiber-st")
linkBuilderFMSII_cards_12fiber_st = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 4)).setLabel("linkBuilderFMSII-cards-12fiber-st")
linkBuilderFMSII_cards_24tp_rj45 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 5)).setLabel("linkBuilderFMSII-cards-24tp-rj45")
linkBuilderFMSII_cards_24tp_telco = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 1, 9, 6, 6)).setLabel("linkBuilderFMSII-cards-24tp-telco")
amp_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 3)).setLabel("amp-mib")
genericTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 4))
viewBuilderApps = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 5))
specificTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 6))
linkBuilder3GH_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 7)).setLabel("linkBuilder3GH-mib")
linkBuilder10BTi_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8)).setLabel("linkBuilder10BTi-mib")
linkBuilderECS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 9)).setLabel("linkBuilderECS-mib")
generic = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10))
genExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1))
setup = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2))
sysLoader = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 3))
security = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 4))
gauges = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 5))
asciiAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 6))
serialIf = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 7))
repeaterMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8))
endStation = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 9))
localSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 10))
manager = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 11))
unusedGeneric12 = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 12))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 14))
mrmResilience = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 15))
tokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 16))
multiRepeater = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17))
bridgeMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 18))
fault = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 19))
poll = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 20))
powerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 21))
testData = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1, 1))
ifExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 1, 2))
netBuilder_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 11)).setLabel("netBuilder-mib")
lBridgeECS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 12)).setLabel("lBridgeECS-mib")
deskMan_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 13)).setLabel("deskMan-mib")
linkBuilderMSH_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 14)).setLabel("linkBuilderMSH-mib")
linkBuilderFMS_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 15)).setLabel("linkBuilderFMS-mib")
linkBuilderFDDI_wghub_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 16)).setLabel("linkBuilderFDDI-wghub-mib")
linkSwitch_mib = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 17)).setLabel("linkSwitch-mib")
linkbuilderMonitorPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 1))
linkbuilderConfigPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 2))
linkbuilderStatusPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 3))
linkbuilderMonitorMacPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 6))
vmMonBatteryStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("low", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonBatteryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vmMonBatteryStatus.setDescription('The results of the start up check on NVRAM Battery condition.')
vmMonPOSTResults = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonPOSTResults.setStatus('mandatory')
if mibBuilder.loadTexts: vmMonPOSTResults.setDescription('The results of the Power On Self Test are recorded here. The value read is a bit mask of possible errors, these are as follows:- bit 3 set - error accessing the Ethernet Address PROM bit 5 set - error accessing System RAM bit 6 set - error accessing NVRAM bit 7 set - battery level low bit 8 set - MFP errors bit 9 set - LANCE errors bit 11 set - error allocating unit ids to units bit 12 set - error on acessing repeater bit 13 set - as above bit 14 set - as above bit 15 set - as above bit 16 set - as above bit 17 set - error accessing processor bus bit 2 set - error accessing the Ethernet Address PROM bit 3 set - error accessing System RAM bit 4 set - as above bit 5 set - error accessing NVRAM bit 6 set - battery level low bit 7 set - MFP errors bit 8 set - LANCE errors bit 9 set - MBGA errors bit 10 set - watchdog bit 11 set - error allocating unit ids bit 12 set - error on acessing repeater bit 13 set - as above bit 14 set - as above bit 15 set - as above bit 16 set - as above bit 17 set - as above bit 18 set - hardware bus error bit 19 set - as above bit 20 set - as above bit 21 set - as above bit 22 set - interrupt error bit 23 set - as above bit 24 set - unknown ')
vmMonFault = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 1, 3))
vmMonFaultModifiedFlag = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean-read", 1), ("modified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmMonFaultModifiedFlag.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonFaultModifiedFlag.setDescription('In order to ensure a clean read of the Fault table this flag should be set to clean_read when commencing to read the table and should be examined after reading the entire table. If still set to clean_read then the table read is okay, if not the table should be re-read as it has been modified during the read process.')
vmMonFaultTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 1, 3, 2), )
if mibBuilder.loadTexts: vmMonFaultTable.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonFaultTable.setDescription('The Fault Table.')
vmMonFaultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 1, 3, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "vmMonFaultIndex"))
if mibBuilder.loadTexts: vmMonFaultEntry.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonFaultEntry.setDescription('Information relating to a single fault.')
vmMonFaultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonFaultIndex.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonFaultIndex.setDescription('The index into the Fault table. The initial read from the table should be read as the next, from an index of 0; subsequent reads should read the next from the index returned by the previous read.')
vmMonFaultErrorNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonFaultErrorNumber.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonFaultErrorNumber.setDescription('This error number for this fault log entry.')
vmMonFaultTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 1, 3, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonFaultTimeStamp.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonFaultTimeStamp.setDescription('The time since startup, in milliseconds, when the fault occurred.')
vmMonFaultRestartCount = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonFaultRestartCount.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonFaultRestartCount.setDescription('The number of restarts at time of fault.')
vmMonDvtEcho = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vmMonDvtEcho.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonDvtEcho.setDescription('This enables/disables the Echo service for test purposes only.')
vmMonMgmtBusOverrunError = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonMgmtBusOverrunError.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonMgmtBusOverrunError.setDescription('Hardware error counter.')
vmMonMgmtBusFramingError = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonMgmtBusFramingError.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonMgmtBusFramingError.setDescription('Hardware error counter.')
vmMonMgmtBusOverflowError = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonMgmtBusOverflowError.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonMgmtBusOverflowError.setDescription('Hardware error counter.')
vmMonMgmtBusFiFoFullCounter = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMonMgmtBusFiFoFullCounter.setStatus('deprecated')
if mibBuilder.loadTexts: vmMonMgmtBusFiFoFullCounter.setDescription('Hardware error counter.')
vmConfigGroupTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 2, 2), )
if mibBuilder.loadTexts: vmConfigGroupTable.setStatus('deprecated')
if mibBuilder.loadTexts: vmConfigGroupTable.setDescription('Table configuration options for all of the groups.')
vmConfigGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 2, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "vmConGroupIndex"))
if mibBuilder.loadTexts: vmConfigGroupEntry.setStatus('deprecated')
if mibBuilder.loadTexts: vmConfigGroupEntry.setDescription('Configuration options for a single group.')
vmConGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: vmConGroupIndex.setDescription('This attribute uniquely identifies this group within the repeater, it is part of the index for the group table.')
vmConGroupPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConGroupPortMask.setStatus('deprecated')
if mibBuilder.loadTexts: vmConGroupPortMask.setDescription('This attribute identifies which ports are present on this group. It is formatted as a bit mask. Bit 0, the least significant bit, represents port number one, bit 1 represents port number two and so on. Port number one is the port that has a xxxxPortIndex of 1 where xxxx depends upon which MIB table is being examined. The bits in the bit mask are set to a 1 if the port is present in this group and set to a zero if the port is not present.')
vmConfigPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 2, 3), )
if mibBuilder.loadTexts: vmConfigPortTable.setStatus('deprecated')
if mibBuilder.loadTexts: vmConfigPortTable.setDescription('Table configuration options for all of the ports.')
vmConfigPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 2, 3, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "vmConPortGroupIndex"), (0, "LBHUB-FMS-MIB", "vmConPortIndex"))
if mibBuilder.loadTexts: vmConfigPortEntry.setStatus('deprecated')
if mibBuilder.loadTexts: vmConfigPortEntry.setDescription('Configuration options for a single port.')
vmConPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConPortGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: vmConPortGroupIndex.setDescription('This attribute uniquely identifies this group within the repeater, it is part of the index for the port table.')
vmConPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConPortIndex.setStatus('deprecated')
if mibBuilder.loadTexts: vmConPortIndex.setDescription('This attribute uniquely identifies this port within the group, it is part of the index for the port table.')
vmConPortSquelch = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("low", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmConPortSquelch.setStatus('deprecated')
if mibBuilder.loadTexts: vmConPortSquelch.setDescription('This attribute controls the 10BaseT squelch level for a 10BaseT port. It enables it to be set to the IEEE standard level = normal, or to be set more sensative = low.')
vmConPortLinkPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vmConPortLinkPulse.setStatus('deprecated')
if mibBuilder.loadTexts: vmConPortLinkPulse.setDescription('This attribute determines if link pulse generating and monitoring is enabled or disabled for a 10BaseT port. The attribute may take the values of enabled (standard) or disabled (non standard).')
vmConPortXoverSwitchState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("normal", 2), ("crossed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConPortXoverSwitchState.setStatus('deprecated')
if mibBuilder.loadTexts: vmConPortXoverSwitchState.setDescription('This attribute determines the state of the cross over switch, this is only applicable to fixed UTP ports.')
vmConPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14, 15, 32, 40, 41, 50, 60))).clone(namedValues=NamedValues(("fms-FixedTP", 1), ("fms-FixedCoax", 2), ("fms-FixedFibreFL", 3), ("fms-ModularBridge", 4), ("fms-ModularMaleAUI", 8), ("fms-ModularFMaleAUI", 9), ("fms-ModularCoax", 10), ("fms-ModularFibreFL", 11), ("fms-ModularUTP", 12), ("fms-ModularSTP", 13), ("fms-ModularFibreFB", 14), ("fms-AUI", 15), ("bti-FixedUTP", 32), ("bti-ModularFibreFL", 40), ("bti-ModularCoax", 41), ("bti-AUI", 50), ("unknown", 60)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConPortType.setStatus('deprecated')
if mibBuilder.loadTexts: vmConPortType.setDescription('This attribute describes the port type in terms of media supported, modular or fixed and manufacturer.')
vmConfigMediaTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 2, 4), )
if mibBuilder.loadTexts: vmConfigMediaTable.setStatus('deprecated')
if mibBuilder.loadTexts: vmConfigMediaTable.setDescription('Configuration information and control variables for a collection of media cards this repeater.')
vmConfigMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 2, 4, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "vmConMediaIndex"))
if mibBuilder.loadTexts: vmConfigMediaEntry.setStatus('deprecated')
if mibBuilder.loadTexts: vmConfigMediaEntry.setDescription('Configuration information and control variables for a single media card.')
vmConMediaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConMediaIndex.setStatus('deprecated')
if mibBuilder.loadTexts: vmConMediaIndex.setDescription('This attribute uniquely identifies this media card, it is part of the index for the Media Table.')
vmConMediaModuleRevNo = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConMediaModuleRevNo.setStatus('deprecated')
if mibBuilder.loadTexts: vmConMediaModuleRevNo.setDescription('The Media Module Hardware revision number.')
vmConMediaModuleCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 14, 15, 30, 31, 65, 66, 67, 68, 69, 70, 71))).clone(namedValues=NamedValues(("fms-12Port-UTP", 1), ("fms-10Port-Coax", 2), ("fms-12Port-Fibre", 3), ("fms-6Port-Fibre", 4), ("fms-24PortUTP", 5), ("bt-12Port-UTP-Rev2", 14), ("bt-12Port-UTP-Rev1", 15), ("bti-12Port-UTP-Rev2", 30), ("bti-12Port-UTP-Rev1", 31), ("fmsII-12Port-TP-RJ45", 65), ("fmsII-10Port-Coax", 66), ("fmsII-12Port-Fibre", 67), ("fmsII-6Port-Fibre", 68), ("fmsII-24Port-TP-RJ45", 69), ("fmsII-24Port-TP-Telco", 70), ("fmsII-RMON-Box", 71)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmConMediaModuleCardType.setStatus('deprecated')
if mibBuilder.loadTexts: vmConMediaModuleCardType.setDescription('The Media Module Card Type.')
vmMacMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 6, 1), )
if mibBuilder.loadTexts: vmMacMonitorTable.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorTable.setDescription('Table of performance and error statistics for the MACs.')
vmMacMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "vmMacMonitorIndex"))
if mibBuilder.loadTexts: vmMacMonitorEntry.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorEntry.setDescription(' ')
vmMacMonitorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorIndex.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorIndex.setDescription('This object identifies the MAC for which this entry contains information.')
vmMacMonitorMissErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorMissErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorMissErrors.setDescription('The number of packets the MAC has failed to receive. This may be due to no receive buffer being available or a SILO overflow.')
vmMacMonitorBabbleErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorBabbleErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorBabbleErrors.setDescription('The number of packets, whose length has exceeded 1519 bytes, transmitted by the MAC.')
vmMacMonitorMemoryErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorMemoryErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorMemoryErrors.setDescription('The number of times the MAC has been unable to obtain bus mastership with the specified period.')
vmMacMonitorFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorFCSErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorFCSErrors.setDescription('The number packets received by the MAC containing an FCS error.')
vmMacMonitorOverflowErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorOverflowErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorOverflowErrors.setDescription('The number of packets received by the MAC which caused a SILO overflow error.')
vmMacMonitorFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorFramingErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorFramingErrors.setDescription('The number of packets received by the MAC containing a non-integer multiple of 8 bits and a FCS error.')
vmMacMonitorRetryErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorRetryErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorRetryErrors.setDescription('The number of times the MAC has failed, in 16 attempts, to transmit a packet due to collisions on the network.')
vmMacMonitorLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorLateEvents.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorLateEvents.setDescription('The number of times the MAC detected an out of window collision during transmission of a packet.')
vmMacMonitorLCarErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorLCarErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorLCarErrors.setDescription('The number of times the MAC has detected a loss of carrier during transmission of a packet.')
vmMacMonitorUnderflowErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 6, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vmMacMonitorUnderflowErrors.setStatus('deprecated')
if mibBuilder.loadTexts: vmMacMonitorUnderflowErrors.setDescription('The number of times the MAC has truncated an outgoing packet due to the SILO emptying before the end of packet has been reached.')
vmMauMediaAvailable = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,25)).setObjects(("MAU-MIB", "rpMauMediaAvailable"))
if mibBuilder.loadTexts: vmMauMediaAvailable.setDescription('This trap indicates that the mau for this port has entered or left rpMauMediaAvailable = available(3) state.')
vmAutoPartitionState = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,26)).setObjects(("MAU-MIB", "rptrPortAutoPartitionState"))
if mibBuilder.loadTexts: vmAutoPartitionState.setDescription('This trap indicates that the repeater SM for this port has entered or left the partitioned state.')
pddrmBasicPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 1))
pddrmMonitorPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 2))
pddrmBasRepeaterPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 1, 1))
pddrmBasGroupPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 1, 2))
pddrmBasPortPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 1, 3))
pddrmMonRepeaterPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1))
pddrmMonGroupPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2))
pddrmMonPortPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3))
pddrmMonRepeaterDummyPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 4))
pddrmMonGroupDummyPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 5))
pddrmMonPortDummyPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 6))
pddrmMonRepeaterReadableFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterReadableFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterReadableFrames.setDescription('This counter is incremented by one for each frame whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFraneSize and for which FCSError is not asserted that is received by the repeater.')
pddrmMonRepeaterReadableOctets = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterReadableOctets.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterReadableOctets.setDescription('This counter is incremented by the octet count for each readable frame received by the repeater.')
pddrmMonRepeaterFCSErrors = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterFCSErrors.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterFCSErrors.setDescription('This counter is incremented by one for each frame with an FCS error that does not have a framing error and which is of legal frame size received by the repeater.')
pddrmMonRepeaterAlignmentErrors = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterAlignmentErrors.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterAlignmentErrors.setDescription('This counter is incremented by one for each frame with an FCS error that does have a framing error and which is of legal frame size received by the repeater.')
pddrmMonRepeaterFrameTooLongs = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterFrameTooLongs.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterFrameTooLongs.setDescription('This counter is incremented by one for each frame whose octet count is greater than the max frame size that is received by the repeater.')
pddrmMonRepeaterShortEvents = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterShortEvents.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterShortEvents.setDescription('This counter is incremented by one for each carrier event whose duration is less than short event max time that is detected by the repeater.')
pddrmMonRepeaterRunts = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterRunts.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterRunts.setDescription('This counter is incremented by one for each carrier event whose duration is greater than short event max time and less than valid packet min time and which does not suffer a collision detected by the repeater.')
pddrmMonRepeaterCollisions = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterCollisions.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterCollisions.setDescription('This counter is incremented by one each time the repeater state machine enters the COLLISION COUNT INCREMENT state.')
pddrmMonRepeaterLateEvents = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterLateEvents.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterLateEvents.setDescription('This counter is incremented by one each time a collisions occurs after valid packet min time, a late event is counted as both a collision and as a late event.')
pddrmMonRepeaterVeryLongEvents = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterVeryLongEvents.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterVeryLongEvents.setDescription('This counter is incremented by one each time a carrier event occurs whose duration is greater than the MAU Jabber Lockup Protection time.')
pddrmMonRepeaterDataRateMismatches = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterDataRateMismatches.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterDataRateMismatches.setDescription('This counter is incremented by one each time a packet has been received by this repeater with the data rate detectably mismatched from the local frequency.')
pddrmMonRepeaterAutoPartitions = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterAutoPartitions.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterAutoPartitions.setDescription('This counter is incremented by one each time the repeater has automatically partitioned any port.')
pddrmMonRepeaterUniCastFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterUniCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterUniCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the repeater that is addressed to a unicast (non group) address.')
pddrmMonRepeaterMultiCastFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterMultiCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterMultiCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the repeater that is addressed to a multicast (non broadcast) address.')
pddrmMonRepeaterBroadCastFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterBroadCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterBroadCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the repeater that is addressed to the broadcast address.')
pddrmMonRepeaterClearCounters = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChangeCounters", 1), ("clearCounters", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: pddrmMonRepeaterClearCounters.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterClearCounters.setDescription('This attribute allows all counters on this repeater to be cleared.')
pddrmMonRepeaterMediaAvailableTraps = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enableMediaTraps", 1), ("disableMediaTraps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pddrmMonRepeaterMediaAvailableTraps.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterMediaAvailableTraps.setDescription('This attribute enable/disables traps to be issued when a ports media is lost/regained.')
pddrmMonRepeaterAutoPartitionTraps = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enablePartitionTraps", 1), ("disablePartitionTraps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pddrmMonRepeaterAutoPartitionTraps.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterAutoPartitionTraps.setDescription('This attribute enables/disables traps to be issued when ports autopartition or reconnect.')
pddrmMonRepeaterTotalErrors = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonRepeaterTotalErrors.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonRepeaterTotalErrors.setDescription('This counter is incremented by one for each erroneous frame seen by the repeater.')
pddrmMonitorGroupTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1), )
if mibBuilder.loadTexts: pddrmMonitorGroupTable.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonitorGroupTable.setDescription('Status information and control variables for a collection of groups in this repeater.')
pddrmMonitorGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "pddrmMonGroupIndex"))
if mibBuilder.loadTexts: pddrmMonitorGroupEntry.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonitorGroupEntry.setDescription('Status information and control variables for a single group of ports.')
pddrmMonGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupIndex.setDescription('This attribute uniquely identifies this group, it is part of the index for the Group Table.')
pddrmMonGroupFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupFCSErrors.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupFCSErrors.setDescription('This counter is incremented by one for each frame with an FCS error that does not have a framing error and which is of legal frame size.')
pddrmMonGroupAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupAlignmentErrors.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupAlignmentErrors.setDescription('This counter is incremented by one for each frame with an FCS error that does have a framing error and which is of legal frame size .')
pddrmMonGroupFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupFrameTooLongs.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupFrameTooLongs.setDescription('This counter is incremented by one for each frame whose octet count is greater than the max frame size that is received by the repeater.')
pddrmMonGroupShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupShortEvents.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupShortEvents.setDescription('This counter is incremented by one for each carrier event whose duration is less than short event max time that is detected.')
pddrmMonGroupRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupRunts.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupRunts.setDescription('This counter is incremented by one for each carrier event whose duration is greater than short event max time and less than valid packet min time and which does not suffer a collision.')
pddrmMonGroupCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupCollisions.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupCollisions.setDescription('This counter is incremented by one each time the repeater state machine enters the COLLISION COUNT INCREMENT state.')
pddrmMonGroupLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupLateEvents.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupLateEvents.setDescription('This counter is incremented by one each time a collisions occurs after valid packet min time, a late event is counted as both a collision and as a late event.')
pddrmMonGroupVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupVeryLongEvents.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupVeryLongEvents.setDescription('This counter is incremented by one each time a carrier event occurs whose duration is greater than the MAU Jabber Lockup Protection time.')
pddrmMonGroupDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupDataRateMismatches.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupDataRateMismatches.setDescription('This counter is incremented by one each time a packet has been received with the data rate detectably mismatched from the local frequency.')
pddrmMonGroupAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupAutoPartitions.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupAutoPartitions.setDescription('This counter is incremented by one each time the repeater has automatically partitioned any port.')
pddrmMonGroupUniCastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupUniCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupUniCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the group that is addressed to a unicast (non group) address.')
pddrmMonGroupMultiCastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupMultiCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupMultiCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the group that is addressed to a multicast (non broadcast) address.')
pddrmMonGroupBroadCastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonGroupBroadCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupBroadCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the group that is addressed to the broadcast address.')
pddrmMonGroupClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChangeCounters", 1), ("clearCounters", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: pddrmMonGroupClearCounters.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonGroupClearCounters.setDescription('This attribute allows all counters on this Group to be cleared.')
pddrmMonitorPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1), )
if mibBuilder.loadTexts: pddrmMonitorPortTable.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonitorPortTable.setDescription('Table of performance and error statistics for the ports.')
pddrmMonitorPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "pddrmMonPortGroupIndex"), (0, "LBHUB-FMS-MIB", "pddrmMonPortIndex"))
if mibBuilder.loadTexts: pddrmMonitorPortEntry.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonitorPortEntry.setDescription('Performance and error statistics for a single port.')
pddrmMonPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonPortGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortGroupIndex.setDescription('This attribute uniquely identifies this group within the repeater, it is part of the index for the port table.')
pddrmMonPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonPortIndex.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortIndex.setDescription('This attribute uniquely identifies this port within the group, it is part of the index for the port table.')
pddrmMonPortUniCastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonPortUniCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortUniCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the group that is addressed to a unicast (non group) address.')
pddrmMonPortMultiCastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonPortMultiCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortMultiCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the group that is addressed to a multicast (non broadcast) address.')
pddrmMonPortBroadCastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pddrmMonPortBroadCastFrames.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortBroadCastFrames.setDescription('This counter is incremented by one for each readable frame seen by the group that is addressed to the broadcast address.')
pddrmMonPortClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChangeCounters", 1), ("clearCounters", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: pddrmMonPortClearCounters.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortClearCounters.setDescription('This attribute allows all counters on this Port to be cleared.')
pddrmMonPortESTFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filter", 1), ("pass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pddrmMonPortESTFilter.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortESTFilter.setDescription('This attribute passes or filters out entries from this port from going to the End Station Table processing. For instance the backbone port on a repeater would normally have this atribute set to filter, while the UTP ports would normally have this set to pass.')
pddrmMonPortMediaAvailableTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enableMediaTraps", 1), ("disableMediaTraps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pddrmMonPortMediaAvailableTraps.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortMediaAvailableTraps.setDescription('This attribute enable/disables traps to be issued when a ports media is lost/regained.')
pddrmMonPortAutoPartitionTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 8, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enablePartitionTraps", 1), ("disablePartitionTraps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pddrmMonPortAutoPartitionTraps.setStatus('deprecated')
if mibBuilder.loadTexts: pddrmMonPortAutoPartitionTraps.setDescription('This attribute enables/disables traps to be issued when ports autopartition or reconnect.')
deprSnmpDot3RptrMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4))
deprRptrBasicPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 1))
deprRptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 2))
deprRptrAddrTrackPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 3))
deprRptrRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 1))
deprRptrGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2))
deprRptrPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 3))
deprRptrMonitorRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 1))
deprRptrMonitorGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 2))
deprRptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3))
deprRptrAddrTrackRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 1))
deprRptrAddrTrackGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 2))
deprRptrAddrTrackPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 3))
deprRptrGroupCapacity = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrGroupCapacity.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupCapacity.setDescription('The deprRptrGroupCapacity is the number of groups that can be contained within the repeater. Within each managed repeater, the groups are uniquely numbered in the range from 1 to deprRptrGroupCapacity. Some groups may not be present in a given repeater instance, in which case the actual number of groups present will be less than deprRptrGroupCapacity. The number of groups present will never be greater than deprRptrGroupCapacity. Note: In practice, this will generally be the number of field-replaceable units (i.e., modules, cards, or boards) that can fit in the physical repeater enclosure, and the group numbers will correspond to numbers marked on the physical enclosure.')
deprRptrOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrOperStatus.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrOperStatus.setDescription("The deprRptrOperStatus object indicates the operational state of the repeater. The deprRptrHealthText object may be consulted for more specific information about the state of the repeater's health. In the case of multiple kinds of failures (e.g., repeater failure and port failure), the value of this attribute shall reflect the highest priority failure in the following order: rptrFailure(3) groupFailure(4) portFailure(5) generalFailure(6)")
deprRptrHealthText = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrHealthText.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrHealthText.setDescription('The health text object is a text string that provides information relevant to the operational state of the repeater. Agents may use this mechanism to provide detailed failure information or instructions for problem resolution. The contents are agent-specific.')
deprRptrReset = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deprRptrReset.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrReset.setDescription('Setting this variable to reset(2) causes a transition to the START state of Fig 9-2 in section 9 [11]. Setting this variable to noReset(1) has no effect. The agent will always return the value noReset(1) when this variable is read. This action does not reset the management counters defined in this document nor does it affect the portAdminState parameters. Included in this action is the execution of a disruptive Self-Test. As a result of this action a deprRptrReset trap may be sent. Note: This action may result in the loss of packets.')
deprRptrNonDisruptTest = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deprRptrNonDisruptTest.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrNonDisruptTest.setDescription('Setting this variable to selfTest(2) causes the repeater to perform a agent-specific, non- disruptive self-test that has the following characteristics: (1) The nature of the tests is not specified. (2) The test does not change the state of the repeater or management information about the repeater. (3) The test does not inject packets onto any segment. (4) The test does not prevent the relay of any packets. (5) The test does not interfere with management functions. After performing this test the agent will update the repeater health information. If a change in the repeater health has occurred, the agent will send a deprRptrHealth trap. Setting this variable to noSelfTest(1) has no effect. The agent will always return the value noSelfTest(1) when this variable is read.')
deprRptrTotalPartitionedPorts = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrTotalPartitionedPorts.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrTotalPartitionedPorts.setDescription('This object returns the total number of ports in the repeater whose current state meets all three of the following criteria: deprRptrPortOperStatus does not have the value notPresent(3), deprRptrPortAdminStatus is enabled(1), and deprRptrPortAutoPartitionState is autoPartitioned(1).')
deprRptrGroupTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2, 1), )
if mibBuilder.loadTexts: deprRptrGroupTable.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupTable.setDescription('Table of descriptive and status information about the groups of ports.')
deprRptrGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "deprRptrGroupIndex"))
if mibBuilder.loadTexts: deprRptrGroupEntry.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupEntry.setDescription('An entry in the table, containing information about a single group of ports.')
deprRptrGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupIndex.setDescription('This variable identifies the group within the repeater for which this entry contains information. This value is never greater than deprRptrGroupCapacity.')
deprRptrGroupDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrGroupDescr.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupDescr.setDescription("A textual description of the group. This value should include the full name and version identification of the group's hardware type and indicate how the group is differentiated from other groups in the repeater. 'Wilma Flintstone 6-Port FOIRL Plug-in Module, Rev A' or 'Barney Rubble 10BASE-T 4-port SIMM socket V. 2.1' are examples of valid group descriptions. It is mandatory that this only contain printable ASCII characters.")
deprRptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrGroupObjectID.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupObjectID.setDescription("The vendor's authoritative identification of the group. This value is allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides a straight-forward and unambiguous means for determining what kind of group is being managed. For example, this variable could take the value 1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, and had assigned the identifier 1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone 6-Port FOIRL Plug-in Module.'")
deprRptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malFunctioning", 3), ("notPresent", 4), ("undertest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrGroupOperStatus.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupOperStatus.setDescription('An object that indicates the operational status of the group. A status of notPresent(4) indicates that the group has been physically removed from the repeater. A status of operational(2) indicates that the group is functioning, and a status of malFunctioning(3) indicates that the group is malfunctioning in some way.')
deprRptrGroupLastOperStatusChange = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrGroupLastOperStatusChange.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupLastOperStatusChange.setDescription("An object that contains the value of sysUpTime at the time that the value of the deprRptrGroupOperStatus object for this group last changed. A value of zero indicates that the group's oper status has not changed since the agent last restarted.")
deprRptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrGroupPortCapacity.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrGroupPortCapacity.setDescription('The deprRptrGroupPortCapacity is the number of ports that can be contained within the group. Valid range is 1-1024. Within each group, the ports are uniquely numbered in the range from 1 to deprRptrGroupPortCapacity. Note: In practice, this will generally be the number of ports on a module, card, or board, and the port numbers will correspond to numbers marked on the physical embodiment.')
deprRptrPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 3, 1), )
if mibBuilder.loadTexts: deprRptrPortTable.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrPortTable.setDescription('Table of descriptive and status information about the ports.')
deprRptrPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 3, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "deprRptrPortGroupIndex"), (0, "LBHUB-FMS-MIB", "deprRptrPortIndex"))
if mibBuilder.loadTexts: deprRptrPortEntry.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrPortEntry.setDescription('An entry in the table, containing information about a single port.')
deprRptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrPortGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrPortGroupIndex.setDescription('This variable identifies the group containing the port for which this entry contains information.')
deprRptrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrPortIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrPortIndex.setDescription('This variable identifies the port within the group within the repeater for which this entry contains management information. This value can never be greater than deprRptrGroupPortCapacity for the associated group.')
deprRptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deprRptrPortAdminStatus.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrPortAdminStatus.setDescription("Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes. The admin status takes precedence over auto- partition and functionally operates between the auto-partition mechanism and the AUI/PMA. Setting this object to enabled(1) enables the port and exerts a BEGIN on the port's auto-partition state machine. (In effect, when a port is disabled, the value of deprRptrPortAutoPartitionState for that port is frozen until the port is next enabled. When the port becomes enabled, the deprRptrPortAutoPartitionState becomes notAutoPartitioned(2), regardless of its pre-disabling state.)")
deprRptrPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autoPartitioned", 1), ("notAutoPartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrPortAutoPartitionState.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrPortAutoPartitionState.setDescription("The autoPartitionState flag indicates whether the port is currently partitioned by the repeater's auto-partition protection. The conditions that cause port partitioning are specified in partition state machine in Sect. 9 [11]. They are not differentiated here.")
deprRptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrPortOperStatus.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrPortOperStatus.setDescription("This object indicates the port's operational state. The notPresent(3) state indicates the port is physically removed (note this may or may not be possible depending on the type of port.) The operational(1) state indicates that the port is enabled (see deprRptrPortAdminStatus) and working, even though it might be auto-partitioned (see deprRptrPortAutoPartitionState).")
deprRptrMonitorTransmitCollisions = MibScalar((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorTransmitCollisions.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorTransmitCollisions.setDescription('This counter is incremented every time the repeater state machine enters the TRANSMIT COLLISION state from any state other than ONE PORT LEFT (Ref: Fig 9-2) [11]. Note: The approximate minimum time for counter rollover is 16 hours.')
deprRptrMonitorGroupTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 2, 1), )
if mibBuilder.loadTexts: deprRptrMonitorGroupTable.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorGroupTable.setDescription('Table of performance and error statistics for the groups.')
deprRptrMonitorGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 2, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "deprRptrMonitorGroupIndex"))
if mibBuilder.loadTexts: deprRptrMonitorGroupEntry.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorGroupEntry.setDescription("An entry in the table, containing total performance and error statistics for a single group. Regular retrieval of the information in this table provides a means of tracking the performance and health of the networked devices attached to this group's ports. The counters in this table are redundant in the sense that they are the summations of information already available through other objects. However, these sums provide a considerable optimization of network management traffic over the otherwise necessary retrieval of the individual counters included in each sum.")
deprRptrMonitorGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorGroupIndex.setDescription('This object identifies the group within the repeater for which this entry contains information.')
deprRptrMonitorGroupTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorGroupTotalFrames.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorGroupTotalFrames.setDescription('The total number of frames of valid frame length that have been received on the ports in this group. This counter is the summation of the values of the deprRptrMonitorPortReadableFrames counters for all of the ports in the group. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours.')
deprRptrMonitorGroupTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorGroupTotalOctets.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorGroupTotalOctets.setDescription('The total number of octets contained in the valid frames that have been received on the ports in this group. This counter is the summation of the values of the deprRptrMonitorPortReadableOctets counters for all of the ports in the group. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes.')
deprRptrMonitorGroupTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorGroupTotalErrors.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorGroupTotalErrors.setDescription('The total number of errors which have occurred on all of the ports in this group. This counter is the summation of the values of the deprRptrMonitorPortTotalErrors counters for all of the ports in the group.')
deprRptrMonitorPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1), )
if mibBuilder.loadTexts: deprRptrMonitorPortTable.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortTable.setDescription('Table of performance and error statistics for the ports.')
deprRptrMonitorPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "deprRptrMonitorPortGroupIndex"), (0, "LBHUB-FMS-MIB", "deprRptrMonitorPortIndex"))
if mibBuilder.loadTexts: deprRptrMonitorPortEntry.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortEntry.setDescription('An entry in the table, containing performance and error statistics for a single port.')
deprRptrMonitorPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
deprRptrMonitorPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortIndex.setDescription('This object identifies the port within the group for which this entry contains information.')
deprRptrMonitorPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortReadableFrames.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortReadableFrames.setDescription('This object is the number of frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours.')
deprRptrMonitorPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortReadableOctets.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortReadableOctets.setDescription('This object is the number of octets contained in valid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes.')
deprRptrMonitorPortFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortFCSErrors.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortFCSErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). The approximate minimum time for rollover of this counter is 80 hours.')
deprRptrMonitorPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortAlignmentErrors.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortAlignmentErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError and FramingError signals asserted and CollisionEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1). If deprRptrMonitorPortAlignmentErrors is incremented then the deprRptrMonitorPortFCSErrors Counter shall not be incremented for the same frame. The approximate minimum time for rollover of this counter is 80 hours.')
deprRptrMonitorPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortFrameTooLongs.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortFrameTooLongs.setDescription('This counter is incremented by one for each frame received on this port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If deprRptrMonitorPortFrameTooLongs is incremented then neither the deprRptrMonitorPortAlignmentErrors nor the deprRptrMonitorPortFCSErrors counter shall be incremented for the frame. The approximate minimum time for rollover of this counter is 61 days.')
deprRptrMonitorPortShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortShortEvents.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortShortEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times. ShortEventMaxTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Note: shortEvents may indicate externally generated noise hits which will cause the repeater to transmit Runts to its other ports, or propagate a collision (which may be late) back to the transmitting DTE and damaged frames to the rest of the network. Implementors may wish to consider selecting the ShortEventMaxTime towards the lower end of the allowed tolerance range to accommodate bit losses suffered through physical channel devices not budgeted for within this standard. The approximate minimum time for rollover of this counter is 16 hours.')
deprRptrMonitorPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortRunts.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortRunts.setDescription('This counter is incremented by one for each CarrierEvent on this port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than ValidPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times and less than 565 bit times. An event whose length is greater than 74 bit times but less than 82 bit times shall increment either the shortEvents counter or the runts counter but not both. A CarrierEvent greater than or equal to 552 bit times but less than 565 bit times may or may not be counted as a runt. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. In certain situations associated with large diameter networks a percentage of runts may exceed ValidPacketMinTime. The approximate minimum time for rollover of this counter is 16 hours.')
deprRptrMonitorPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortCollisions.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortCollisions.setDescription('This counter is incremented by one for any CarrierEvent signal on any port for which the CollisionEvent signal on this port is asserted. The approximate minimum time for rollover of this counter is 16 hours.')
deprRptrMonitorPortLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortLateEvents.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortLateEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port in which the CollIn(X) variable transitions to the value SQE (Ref: 9.6.6.2, IEEE 802.3 Std) while the ActivityDuration is greater than the LateEventThreshold. Such a CarrierEvent is counted twice, as both a collision and as a lateEvent. The LateEventThreshold is greater than 480 bit times and less than 565 bit times. LateEventThreshold has tolerances included to permit an implementation to build a single threshold to serve as both the LateEventThreshold and ValidPacketMinTime threshold. The approximate minimum time for rollover of this counter is 81 hours.')
deprRptrMonitorPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortVeryLongEvents.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortVeryLongEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port whose ActivityDuration is greater than the MAU Jabber Lockup Protection timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std). Other counters may be incremented as appropriate.')
deprRptrMonitorPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortDataRateMismatches.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortDataRateMismatches.setDescription("This counter is incremented by one for each frame received on this port that meets all of the following conditions: a) The CollisionEvent signal is not asserted. b) The ActivityDuration is greater than ValidPacketMinTime. c) The frequency (data rate) is detectably mismatched from the local transmit frequency. The exact degree of mismatch is vendor specific and is to be defined by the vendor for conformance testing. When this event occurs, other counters whose increment conditions were satisfied may or may not also be incremented, at the implementor's discretion. Whether or not the repeater was able to maintain data integrity is beyond the scope of this standard.")
deprRptrMonitorPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortAutoPartitions.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortAutoPartitions.setDescription('This counter is incremented by one for each time the repeater has automatically partitioned this port. The conditions that cause port partitioning are specified in the partition state machine in Section 9 [IEEE 802.3 Std]. They are not differentiated here.')
deprRptrMonitorPortTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrMonitorPortTotalErrors.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrMonitorPortTotalErrors.setDescription('The total number of errors which have occurred on this port. This counter is the summation of the values of other error counters (for the same port), namely: deprRptrMonitorPortFCSErrors, deprRptrMonitorPortAlignmentErrors, deprRptrMonitorPortFrameTooLongs, deprRptrMonitorPortShortEvents, deprRptrMonitorPortLateEvents, deprRptrMonitorPortVeryLongEvents, and deprRptrMonitorPortDataRateMismatches. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters.')
deprRptrAddrTrackTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 3, 1), )
if mibBuilder.loadTexts: deprRptrAddrTrackTable.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrAddrTrackTable.setDescription('Table of address mapping information about the ports.')
deprRptrAddrTrackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 3, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "deprRptrAddrTrackGroupIndex"), (0, "LBHUB-FMS-MIB", "deprRptrAddrTrackPortIndex"))
if mibBuilder.loadTexts: deprRptrAddrTrackEntry.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrAddrTrackEntry.setDescription('An entry in the table, containing address mapping information about a single port.')
deprRptrAddrTrackGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrAddrTrackGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrAddrTrackGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
deprRptrAddrTrackPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrAddrTrackPortIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrAddrTrackPortIndex.setDescription('This object identifies the port within the group for which this entry contains information.')
deprRptrAddrTrackLastSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 3, 1, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrAddrTrackLastSourceAddress.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrAddrTrackLastSourceAddress.setDescription('This object is the SourceAddress of the last readable frame (i.e., counted by deprRptrMonitorPortReadableFrames) received by this port.')
deprRptrAddrTrackSourceAddrChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 4, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRptrAddrTrackSourceAddrChanges.setStatus('deprecated')
if mibBuilder.loadTexts: deprRptrAddrTrackSourceAddrChanges.setDescription('This counter is incremented by one for each time that the deprRptrAddrTrackLastSourceAddress attribute for this port has changed. This may indicate whether a link is connected to a single DTE or another multi-user segment. The approximate minimum time for rollover of this counter is 81 hours.')
deprRptrHealth = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,1)).setObjects(("LBHUB-FMS-MIB", "deprRptrOperStatus"))
if mibBuilder.loadTexts: deprRptrHealth.setDescription('The deprRptrHealth trap conveys information related to the operational state of the repeater. This trap is sent only when the oper status of the repeater changes. The deprRptrHealth trap must contain the deprRptrOperStatus variable. The agent may optionally include the deprRptrHealthText variable in the varBind list. See the deprRptrOperStatus and deprRptrHealthText objects for descriptions of the information that is sent. The agent must throttle the generation of consecutive deprRptrHealth traps so that there is at least a five-second gap between them.')
deprRptrGroupChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,2)).setObjects(("LBHUB-FMS-MIB", "deprRptrGroupIndex"))
if mibBuilder.loadTexts: deprRptrGroupChange.setDescription('This trap is sent when a change occurs in the group structure of a repeater. This occurs only when a group is logically removed from or added to a repeater. The varBind list contains the identifier of the group that was removed or added. The agent must throttle the generation of consecutive deprRptrGroupChange traps for the same group so that there is at least a five-second gap between them.')
deprRptrResetEvent = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,3)).setObjects(("LBHUB-FMS-MIB", "deprRptrOperStatus"))
if mibBuilder.loadTexts: deprRptrResetEvent.setDescription('The deprRptrReset trap conveys information related to the operational state of the repeater. This trap is sent on completion of a repeater reset action. A repeater reset action is defined as an a transition to the START state of Fig 9-2 in section 9 [11], when triggered by a management command (e.g., an SNMP Set on the deprRptrReset object). The agent must throttle the generation of consecutive deprRptrReset traps so that there is at least a five-second gap between them. The deprRptrReset trap is not sent when the agent restarts and sends an SNMP coldStart or warmStart trap. However, it is recommended that a repeater agent send the deprRptrHealth variables as optional variables with its coldStart and warmStart trap PDUs. The deprRptrOperStatus variable must be included in the varbind list sent with this trap. The agent may optionally include the deprRptrHealthText variable as well.')
deprSnmpDot3RpMauMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 5))
deprRpMauBasicGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 8, 5, 1))
deprRpMauTable = MibTable((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1), )
if mibBuilder.loadTexts: deprRpMauTable.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauTable.setDescription('Table of descriptive and status information about the groups of ports.')
deprRpMauEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "deprRpMauGroupIndex"), (0, "LBHUB-FMS-MIB", "deprRpMauPortIndex"), (0, "LBHUB-FMS-MIB", "deprRpMauIndex"))
if mibBuilder.loadTexts: deprRpMauEntry.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauEntry.setDescription('An entry in the table, containing information about a single group of ports.')
deprRpMauGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRpMauGroupIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauGroupIndex.setDescription('This variable uniquely identifies the repeater group that contains the port to which is connected the MAU for which this entry contains information.')
deprRpMauPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRpMauPortIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauPortIndex.setDescription('This variable uniquely identifies the repeater port to which is connected the MAU for which this entry contains information.')
deprRpMauIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRpMauIndex.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauIndex.setDescription('This variable uniquely identifies the MAU for which this entry contains information.')
deprRpMauType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 7, 8, 9, 10, 14, 16, 17, 18))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("aui", 7), ("tenbase5", 8), ("foirl", 9), ("tenbase2", 10), ("tenbaseT", 14), ("tenbaseFP", 16), ("tenbaseFB", 17), ("tenbaseFL", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRpMauType.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauType.setDescription('A value that identifies the 10 Mb/s baseband MAU type. The enumeration of the type is such that the value matches the section number of the IEEE 802.3 standard that specifies the particular MAU.')
deprRpMauAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("operational", 3), ("standby", 4), ("shutdown", 5), ("reset", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deprRpMauAdminState.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauAdminState.setDescription('The administrative state of the MAU. This object may be implemented as a read-only object by those agents and MAUs that do not implement software control of the administrative state. A MAU in the operational(3) state is fully functional, operates, and passes signals to its attached DTE or repeater port in accordance to its specification. A MAU in standby(4) state forces DI and CI and the media transmitter to idle. Standby(4) mode only applies to link type MAUs. The state of mauMediaAvailable is unaffected. A MAU in shutdown(5) state assumes the same condition on DI, CI, and the media transmitter as if it were powered down. The MAU may return other(1) state for the mauJabber and mauMediaAvailable objects when it is in this state. For an AUI, this state will remove power from the AUI. Setting this variable to the value reset(6) resets the MAU in the same manner as a power-off, power- on cycle would. Setting this variable to the value operational(3), standby(4), or shutdown(5) causes the MAU to assume the respective state except that setting a mixing-type MAU or an AUI to standby(4) will cause the MAU to enter the shutdown state.')
deprRpMauMediaAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("present", 3), ("notPresent", 4), ("remoteFault", 5), ("invalidSignal", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRpMauMediaAvailable.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauMediaAvailable.setDescription('If the MAU is a link or fiber type (FOIRL, 10BASE-T, 10BASE-F) then this is equivalent to the link integrity/low light state. For an AUI or coax MAU this indicates whether or not loopback is detected on the DI circuit. The value of this attribute persists between packets for MAU types AUI, 10BASE5, 10BASE2, and 10BASE-FP. NOTE: IEEE 802.3 modified the following descriptive text at their meeting the week of 3/9/92. New text will be provided at the San Diego IETF plenary. At power-up or following a reset, the value of this attribute will be unknown for AUI, coax, and 10BASE-FP MAUs. For these MAUs loopback will be tested on each transmission during which no collision is detected. If DI receives input within startUpDelay of the start of output on DO, loopback will be detected. The value of startUpDelay shall be between 15 and 25 BT (bit times). Transition form input to output_idle on DI while output is present on DO may also be detected on loopback. The value of this attribute will only change during non-collided transmissions for AUI, coax, and 10BASE-FP MAUs.')
deprRpMauLostMedias = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRpMauLostMedias.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauLostMedias.setDescription('A count of the number of times that deprRpMauMediaAvailable for this MAU instance leaves the state available(3). Implementation of this object is mandatory for MAU instances with deprRpMauType of AUI(7). It is recommended for all MAU types.')
deprRpMauJabberState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("noJabber", 3), ("jabbering", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRpMauJabberState.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauJabberState.setDescription('If the MAU is in jabber state the attribute is set to the jabbering(4) value. This object returns the value other(1) for MAU type AUI.')
deprRpMauJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 8, 5, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deprRpMauJabbers.setStatus('deprecated')
if mibBuilder.loadTexts: deprRpMauJabbers.setDescription('A count of the number of times that deprRpMauJabberState for this MAU instance enters the state jabbering(4).')
deprRpMauJabberTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,24)).setObjects(("LBHUB-FMS-MIB", "deprRptrOperStatus"))
if mibBuilder.loadTexts: deprRpMauJabberTrap.setDescription('This trap is sent whenever a managed MAU enters the jabber state. The agent must throttle the generation of consecutive deprRpMauJabberTraps so that there is at least a five-second gap between them.')
faultModifiedFlag = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 19, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clean-read", 1), ("modified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultModifiedFlag.setStatus('mandatory')
if mibBuilder.loadTexts: faultModifiedFlag.setDescription('In order to ensure a clean read of the Fault table this flag should be set to clean_read when commencing to read the table and should be examined after reading the entire table. If still set to clean_read then the table read is okay, if not the table should be re-read as it has been modified during the read process.')
faultTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 19, 2), )
if mibBuilder.loadTexts: faultTable.setStatus('mandatory')
if mibBuilder.loadTexts: faultTable.setDescription('The Fault Table.')
faultEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "faultIndex"))
if mibBuilder.loadTexts: faultEntry.setStatus('mandatory')
if mibBuilder.loadTexts: faultEntry.setDescription('Information relating to a single fault.')
faultIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultIndex.setStatus('mandatory')
if mibBuilder.loadTexts: faultIndex.setDescription('The index into the Fault table. The initial read from the table should be read as the next, from an index of 0; subsequent reads should read the next from the index returned by the previous read.')
faultErrorNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultErrorNumber.setStatus('mandatory')
if mibBuilder.loadTexts: faultErrorNumber.setDescription('This error number for this fault log entry.')
faultTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: faultTimeStamp.setDescription('The time since startup, in milliseconds, when the fault occurred.')
faultRestartCount = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 19, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: faultRestartCount.setStatus('mandatory')
if mibBuilder.loadTexts: faultRestartCount.setDescription('The number of restarts at time of fault.')
mrmBasicPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 1))
mrmMonitorPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2))
mrmBasCardPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1))
mrmBasPortPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2))
mrmMonRepeaterPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1))
mrmMonCardPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2))
mrmMonPortPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3))
mrmMonDummyPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 4))
mrmMonRepeaterSmartPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 5))
mrmMonCardSmartPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 6))
mrmMonPortSmartPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 7))
mrmCardTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1), )
if mibBuilder.loadTexts: mrmCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardTable.setDescription(' Table of descriptive and status information about the groups of ports.')
mrmCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "mrmCardServiceId"), (0, "LBHUB-FMS-MIB", "mrmCardIndex"))
if mibBuilder.loadTexts: mrmCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardEntry.setDescription(' An entry in the table, containing information about a single group of ports.')
mrmCardServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardServiceId.setDescription(' This identifies one of the repeaters within the chassis as the target of a request.')
mrmCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardIndex.setDescription(' This object identifies the card within the repeater for which this entry contains information.')
mrmCardPortCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardPortCapacity.setDescription(' The mrmCardPortCapacity is the number of ports that can be contained within the group. Valid range is 1-1024. Within each group, the ports are uniquely numbered in the range from 1 to mrmCardPortCapacity. Note: In practice, this will generally be the number of ports on a module, card, or board, and the port numbers will correspond to numbers marked on the physical embodiment.')
mrmCardTest = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noTest", 1), ("test", 2), ("testing", 3), ("passed", 4), ("failed", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmCardTest.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardTest.setDescription(' An object that allows the user to test the operation of a card. Writing test(2) to this object forces the card to perform a disruptive test to determine if the card is functioning properly. Reading this object while the card is under test return the value testing(3). When the test is completed, reading this value will return either passed(4) or failed(5).')
mrmCardDOBPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardDOBPorts.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardDOBPorts.setDescription(' MSH Repeater Cards have the ability to disable ports at power up or reset. Ports configured in this way are useful for configuring resilient links because they prevent loops in the network from occurring at startup. The disable on boot feature is determined according to a hardware strap which cannot be changed via software. This parameter is a mask containing a single bit for each port on the card. Port 1 is represented by bit 0 and so-on. If a bit representing a particular port is 0 this port boots up disabled. If the bit is a 1 the port boots up enabled. This parameter allows the state of these parameters to be rapidly determined by a network management application.')
mrmCardMDIenable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("mdiDisabled", 2), ("mdiEnabled", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmCardMDIenable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmCardMDIenable.setDescription(' 10Base-T line cards are normally configured (mdi_disabled(2)) to link to an external network device ( internal crossover ). Port 1 may be configured ( mdi_enabled(3) ) to link to another 10Base-T line card ( with no internal crossover ). This parameter allows the configuration to be determined. Note ECS line cards show unknown(1) since the configuration cannot be accessed via the management interface.')
mrmPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1), )
if mibBuilder.loadTexts: mrmPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortTable.setDescription(' Table of descriptive and status information about the ports.')
mrmPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "mrmPortServiceId"), (0, "LBHUB-FMS-MIB", "mrmPortCardIndex"), (0, "LBHUB-FMS-MIB", "mrmPortIndex"))
if mibBuilder.loadTexts: mrmPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortEntry.setDescription(' An entry in the table, containing information about a single port.')
mrmPortServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortServiceId.setDescription(' This object identifies the repeater which this entry contains information.')
mrmPortCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortCardIndex.setDescription(' This object identifies the group containing the port for which this entry contains information.')
mrmPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortIndex.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,aPortID.')
if mibBuilder.loadTexts: mrmPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortIndex.setDescription(' This object identifies the port within the group for which this entry contains information. This value can never be greater than mrmCardPortCapacity for the associated group.')
mrmPortInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("maleAUI", 2), ("femaleAUI", 3), ("thinCoax", 4), ("twistedPair", 5), ("unshieldedTP", 6), ("fiber", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortInterfaceType.setDescription(' This object specifies the type of electrical interface made available at the interface to the card for this port. The interface does not necessarily specify what the actual media to end station is.')
mrmPortConnectorType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("rj45", 2), ("telco", 3), ("st", 4), ("sma", 5), ("dtype-15", 6), ("bnc", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortConnectorType.setDescription(' This specifies the type of the physical connector through which one would attach to this card. This is distinct from the media type. For example UTP may be connected to the port via either an RJ45 or a Telco connector.')
mrmPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortAdminStatus.setDescription(" Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes. The admin status takes precedence over auto- partition and functionally operates between the auto-partition mechanism and the AUI/PMA. Setting this object to enabled(1) enables the port and exerts a BEGIN on the port's auto-partition state machine. In effect, when a port is disabled, the value of mrmPortAutoPartitionState for that port is frozen until the port is next enabled. When the port becomes enabled, the mrmPortAutoPartitionState becomes notAutoPartitioned(2), regardless of its pre-disabling state.)")
mrmPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("partitioned", 1), ("unpartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortAutoPartitionState.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aAutoPartitionState.')
if mibBuilder.loadTexts: mrmPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortAutoPartitionState.setDescription(" The autoPartitionState flag indicates whether the port is currently partitioned by the repeater's auto-partition protection. The conditions that cause port partitioning are specified in partition state machine in Section 9 IEEE 802.3 Std]. They are not differentiated here.")
mrmPortLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("present", 1), ("absent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortLinkState.setDescription(' This object reflects the presence or absence of signal on this port. The signal may be either light in the case of fiber, or general link present in the case of copper. The value of this parameter is correct regardless of the state the admin state or the partition state.')
mrmPortBootState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortBootState.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortBootState.setDescription(' A repeater port may be enabled or disabled after a reset. This parameter indicates the default for this port.')
mrmPortESTFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 127, 128))).clone(namedValues=NamedValues(("forwardMAC", 1), ("forwardIP", 2), ("forwardAll", 127), ("forwardNone", 128)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortESTFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortESTFilter.setDescription(' This attribute determines whether and which address information is extracted from packets received on a port and forwarded to the end station database. It is recommended that this attribute be disabled for inter-repeater links to prevent the database being filled with remote information. To disable this feature for all address types write the value forwardNone (128) to this variable.')
mrmPortPartitionEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortPartitionEvent.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortPartitionEvent.setDescription('Specifies whether a trap should be sent if the port partition state changes.')
mrmPortLinkStateEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortLinkStateEvent.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortLinkStateEvent.setDescription('Specifies whether a trap should be sent if the link state changes.')
mrmPortSecurityAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("available", 1), ("notAvailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortSecurityAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortSecurityAvailable.setDescription('Specifies whether security is an available feature on this port. Only ports that have this feature available can have an entry in the repeater security table.')
mrmPortLinkPulse = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notApplicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortLinkPulse.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortLinkPulse.setDescription(' This attribute determines if link pulse generating and monitoring is enabled or disabled for a 10BaseT port. The attribute may take the values of enabled (standard) or disabled (non standard).')
mrmPortModule = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("modularPort", 2), ("notModularPort", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortModule.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortModule.setDescription(' This attribute indicates whether the port is a modular port or not.')
mrmPortDUDAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("notify", 2), ("disconnect", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmPortDUDAction.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortDUDAction.setDescription(' DUD Action for this port. ')
mrmPortFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 1, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("repeater", 2), ("bridge", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmPortFunction.setStatus('mandatory')
if mibBuilder.loadTexts: mrmPortFunction.setDescription(' This atribute indicates the function of the port.')
mrmMonitorRepTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1), )
if mibBuilder.loadTexts: mrmMonitorRepTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorRepTable.setDescription('Table of performance and error statistics for the ports.')
mrmMonitorRepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "mrmMonRepServiceId"))
if mibBuilder.loadTexts: mrmMonitorRepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorRepEntry.setDescription(' This table provides statistical and control information concerning the entire repeater.')
mrmMonRepServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepServiceId.setDescription(' This parameter is used as the index in this table. A modular chassis contains potentially many repeater services. Each repeater service contains a number of cards (or groups). This parameter allows one of those repeaters to be selected.')
mrmMonRepReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepReadableFrames.setDescription(' This counter is incremented by one for each frame whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize and for which FCSError is not asserted that is received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepUnicastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Repeater that is addressed to a unicast (non Card) address.')
mrmMonRepMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepMulticastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Repeater that is addressed to a multicast (non broadcast) address.')
mrmMonRepBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBroadcastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Repeater that is addressed to the broadcast address ffffffffffff.')
mrmMonRepReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepReadableOctets.setDescription(' This counter is incremented by the octet count for each readable frame received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepUnicastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination field was a unicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonRepMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepMulticastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was a multicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonRepBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBroadcastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was the broadcast address ffffffffffff. By attaching a gauge to this counter one can monitor the port for broadcast storms. Action can then be taken to automatically recover network normal operation. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonRepFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepFCSErrors.setDescription(' This counter is incremented by one for each frame with an FCS error that does not have a framing error and which is of legal frame size received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepAlignmentErrors.setDescription(' This counter is incremented by one for each frame with an FCS error that does have a framing error and which is of legal frame size received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepFrameTooLongs.setDescription(' This counter is incremented by one for each frame whose octet count is greater than the max frame size that is received by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepShortEvents.setDescription(' This counter is incremented by one for each carrier event whose duration is less than short event max time that is detected by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepRunts.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepRunts.setDescription(' This counter is incremented by one for each carrier event whose duration is greater than short event max time and less than valid packet min time and which does not suffer a collision detected by the repeater. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepTxCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepTxCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepTxCollisions.setDescription(' This counter is incremented by one for any CarrierEvent signal on any port of this repeater for which the CollisionEvent signal on this port is asserted. The approximate minimum time for rollover of this counter is 16 hours.')
mrmMonRepLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepLateEvents.setDescription(' This counter is incremented by one each time a collisions occurs after valid packet min time, a late event is counted as both a collision and as a late event. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepVeryLongEvents.setDescription(' This counter is incremented by one each time a carrier event occurs whose duration is greater than the MAU Jabber Lockup Protection time. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepDataRateMismatches.setDescription(' This counter is incremented by one each time a packet has been received by this repeater with the data rate detectably mismatched from the local frequency. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepAutoPartitions.setDescription(' This counter is incremented by one each time the repeater has automatically partitioned any port. NOTE: This counter does not really exist. It is calculated by adding together all the port counters within this repeater.')
mrmMonRepTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepTotalErrors.setDescription(' The total number of errors which have occurred on all ports on all groups of this repeater. This counter is the summation of the values of the mrmMonCardTotalErrors counters for all of the cards in the repeater. It is the sum of the following: FCS, Alignment, Frames Too Long, Short Events, Late Events, Very Long Events and Data Rate Mismatches. As a general indicator the individual error counters are too detailed. This parameter gives a very good monitor type parameter.')
mrmMonRepBound0 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound0.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound0.setDescription(' This object is a summation of the number of frames (including error frames) with a length of 64 octets which were received by each port on every card of this repeater.')
mrmMonRepBound1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound1.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound1.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 65 and 127 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepBound2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound2.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound2.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 128 and 255 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepBound3 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound3.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound3.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 256 and 511 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepBound4 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound4.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound4.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 512 and 1023 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepBound5 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBound5.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBound5.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 1024 and 1518 octets inclusive which were received by each port on every card of this repeater.')
mrmMonRepAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 128))).clone(namedValues=NamedValues(("clearCounters", 1), ("noAction", 128)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmMonRepAction.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepAction.setDescription(" This object allows repeater stats specific actions to be implemented. There is only one action currently defined, 'clearCounters'. Writing this value to a repeater entry will clear ALL counters in this repeater. That include port stats, card and repeater totals. If this object is read then noAction will be returned.")
mrmMonRepBandwidthUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepBandwidthUsed.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepBandwidthUsed.setDescription(" This is a high level 'smart MIB' object. This object provides a running average of the bandwidth in use. This value is calculated locally on the agent and so does not require processor bandwidth from the management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following characteristics: 1) The parameter will be recalculated at approx 15 second intervals 2) Every calculation period the device will read the value of rptrMonitorPortReadableOctets. 3) The calculation will be performed on the most recent 4 samples as follows: 4 Sum(sample(i)/(time(i) * K)) * 100/4 i=1 Sample(i) is rptrMonitorPortReadableOctets(i)-rptrMonitorPortReadableOctets(i-1) time(i) is the time between sample(i-1) and sample(i) K is the max bytes per unit time (i.e. the available bandwidth K depends on the ring speed. The value is expressed as a percentage. A default threshold exists on this average so that if a calculated average exceeds 15% a trap will be sent to the management station. Further traps will not be sent until the average drops to below 10%. A particular device may provide a means of changing the number of samples, the averaging period, threshold and threshold action if it so wishes.")
mrmMonRepErrorsPer10000Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 1, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepErrorsPer10000Packets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepErrorsPer10000Packets.setDescription(" This is a high level 'smart MIB' object. This object provides a running average of the number of errors per 10000 packets. This is an error rate, and is calculated over the number of packets received in the sample periods, and not on every 10000 packets. This value is calculated locally on the agent and so does not require processor bandwidth from a management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following behaviour: 1) The parameter will be recalculated at approx 15 second intervals. 2) Every calculation period the device will read the value of rptrMonitorPortTotalErrors and rptrMonitorPortReadableFrames. 3) The calculation will be performed on the most recent 4 samples as follows: 4 10000 * Sum(Errors(i)/Frames(i)) i=1 Errors(i) = rptrMonitorPortTotalErrors(i)-rptrMonitorPortTotalErrors(i-1) Frames(i) = rptrMonitorPortReadableFrames(i)-rptrMonitorPortReadableFrames(i-1) The value is an integer number of errors per 10,000 packets received by this repeater. A default threshold exists on this average so that if a calculated average exceeds 200 (i.e. 2% of frames are in error) a trap will be sent to the management station. Further traps will not be sent until the average drops to below 100 (i.e. 1% of frames are in error). A particular device may provide a means of changing the number of samples, the averaging period and threshold if it so wishes.")
mrmMonitorCardTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1), )
if mibBuilder.loadTexts: mrmMonitorCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorCardTable.setDescription(" This table contains parameters about the various repeater cards within the chassis. The table is indexed using the 'serviceIndex' for the repeater and the slot number within that repeater.")
mrmMonitorCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "mrmMonCardServiceId"), (0, "LBHUB-FMS-MIB", "mrmMonCardIndex"))
if mibBuilder.loadTexts: mrmMonitorCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorCardEntry.setDescription('Status information and control variables for the ports on a single card.')
mrmMonCardServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardServiceId.setDescription(' This parameter is used as the first of two indices in this table. A modular chassis contains potentially many repeater services. Each repeater service contains a number of cards (or groups). In order to uniquely identify a port it is necessary to specify both the repeater service and the card within that repeater.')
mrmMonCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardIndex.setDescription(' This is the second part of the key on this table. Having selected one of the repeaters within the chassis it is necessary to identify the card within that repeater.')
mrmMonCardReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardReadableFrames.setDescription(' This counter is incremented by one for each frame whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize and for which FCSError is not asserted that is received for any port on this card.')
mrmMonCardUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardUnicastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to a unicast (non Card) address.')
mrmMonCardMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardMulticastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to a multicast (non broadcast) address.')
mrmMonCardBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBroadcastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to the broadcast address ffffffffffff.')
mrmMonCardReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardReadableOctets.setDescription(' This counter is incremented by the octet count for each readable frame received by any port on this card.')
mrmMonCardUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardUnicastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination field was a unicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonCardMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardMulticastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was a multicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonCardBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBroadcastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was the broadcast address ffffffffffff. By attaching a gauge to this counter one can monitor the port for broadcast storms. Action can then be taken to automatically recover network normal operation. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonCardFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardFCSErrors.setDescription(' This counter is incremented by one for each frame with an FCS error that does not have a framing error and which is of legal frame size.')
mrmMonCardAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardAlignmentErrors.setDescription(' This counter is incremented by one for each frame with an FCS error that does have a framing error and which is of legal frame size .')
mrmMonCardFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardFrameTooLongs.setDescription(' This counter is incremented by one for each frame whose octet count is greater than the max frame size that is received by the repeater.')
mrmMonCardShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardShortEvents.setDescription(' This counter is incremented by one for each carrier event whose duration is less than short event max time that is detected.')
mrmMonCardRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardRunts.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardRunts.setDescription(' This counter is incremented by one for each carrier event whose duration is greater than short event max time and less than valid packet min time and which does not suffer a collision.')
mrmMonCardLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardLateEvents.setDescription(' This counter is incremented by one each time a collisions occurs after valid packet min time, a late event is counted as both a collision and as a late event.')
mrmMonCardVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardVeryLongEvents.setDescription(' This counter is incremented by one each time a carrier event occurs whose duration is greater than the MAU Jabber Lockup Protection time.')
mrmMonCardDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardDataRateMismatches.setDescription(' This counter is incremented by one each time a packet has been received with the data rate detectably mismatched from the local frequency.')
mrmMonCardAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardAutoPartitions.setDescription(' This counter is incremented by one each time the repeater has automatically partitioned any port.')
mrmMonCardTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardTotalErrors.setDescription(' The total number of errors which have occurred on all ports of this card. This counter is the summation of the values of other error counters (for each port), namely: FCS Errors, Alignment Errors, Frames Too Long, Short Events, Late Events, Very Long Events, Data Rate Mismatches. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters.')
mrmMonCardBound0 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound0.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound0.setDescription(' This object is a summation of the number of frames (including error frames) with a length of 64 octets which were received by each port on this card.')
mrmMonCardBound1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound1.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound1.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 65 and 127 octets inclusive which were received by each port on this card.')
mrmMonCardBound2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound2.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound2.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 128 and 255 octets inclusive which were received by each port on this card.')
mrmMonCardBound3 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound3.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound3.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 256 and 511 octets inclusive which were received by each port on this card.')
mrmMonCardBound4 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound4.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound4.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 512 and 1023 octets inclusive which were received by each port on this card.')
mrmMonCardBound5 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBound5.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBound5.setDescription(' This object is a summation of the number of frames (including error frames) with a length of between 1024 and 1518 octets inclusive which were received by each port on this card.')
mrmMonCardClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChangeCounters", 1), ("clearCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmMonCardClearCounters.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardClearCounters.setDescription(' This attribute allows all counters on this Card to be cleared. If this object is read then it will return noChangeCounters(1).')
mrmMonCardBandwidthUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardBandwidthUsed.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardBandwidthUsed.setDescription(" This is a high level 'smart MIB' object. This object provides a running average of the bandwidth in use. This value is calculated locally on the agent and so does not require processor bandwidth from the management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following characteristics: 1) The parameter will be recalculated at approx 15 second intervals 2) Every calculation period the device will read the value of rptrMonitorGroupTotalOctets. 3) The calculation will be performed on the most recent 4 samples as follows: 4 Sum(sample(i)/(time(i) * K)) * 100/4 i=1 Sample(i) is rptrMonitorGroupTotalOctets(i)-rptrMonitorGroupTotalOctets(i-1) time(i) is the time between sample(i-1) and sample(i) K is the max bytes per unit time (i.e. the available bandwidth K depends on the ring speed. The value is expressed as a percentage. A default threshold exists on this average so that if a calculated average exceeds 15% a trap will be sent to the management station. Further traps will not be sent until the average drops to below 10%. A particular device may provide a means of changing the number of samples, the averaging period, threshold and threshold action if it so wishes.")
mrmMonCardErrorsPer10000Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 2, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardErrorsPer10000Packets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardErrorsPer10000Packets.setDescription(" This is a high level 'smart MIB' object. This object provides a running average of the number of errors per 10000 packets. This is an error rate, and is calculated over the number of packets received in the sample periods, and not on every 10000 packets. This value is calculated locally on the agent and so does not require processor bandwidth from a management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following behaviour: 1) The parameter will be recalculated at approx 15 second intervals. 2) Every calculation period the device will read the value of rptrMonitorGroupTotalErrors and rptrMonitorGroupTotalFrames. 3) The calculation will be performed on the most recent 4 samples as follows: 4 10000 * Sum(Errors(i)/Frames(i)) i=1 Errors(i) = rptrMonitorGroupTotalErrors(i)-rptrMonitorGroupTotalErrors(i-1) Frames(i) = rptrMonitorGroupTotalFrames(i)-rptrMonitorGroupTotalFrames(i-1) The value is an integer number of errors per 10,000 packets received by this repeater. A default threshold exists on this average so that if a calculated average exceeds 200 (i.e. 2% of frames are in error) a trap will be sent to the management station. Further traps will not be sent until the average drops to below 100 (i.e. 1% of frames are in error). A particular device may provide a means of changing the number of samples, the averaging period and threshold if it so wishes.")
mrmMonitorPortTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1), )
if mibBuilder.loadTexts: mrmMonitorPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorPortTable.setDescription('Table of performance and error statistics for the ports.')
mrmMonitorPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "mrmMonPortServiceId"), (0, "LBHUB-FMS-MIB", "mrmMonPortCardIndex"), (0, "LBHUB-FMS-MIB", "mrmMonPortIndex"))
if mibBuilder.loadTexts: mrmMonitorPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonitorPortEntry.setDescription(' Performance and error statistics for a single port.')
mrmMonPortServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortServiceId.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortServiceId.setDescription(' This parameter selects one of the repeaters within the chassis. This forms the first, most significant index column. Having selected a repeater one must select a card then port within that repeater.')
mrmMonPortCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortCardIndex.setDescription(' This attribute uniquely identifies this Card within the repeater, it is part of the index for the port table.')
mrmMonPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortIndex.setDescription(' This attribute uniquely identifies this port within the Card, it is part of the index for the port table.')
mrmMonPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortReadableFrames.setDescription(' This object is the number of frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours.')
mrmMonPortUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortUnicastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to a unicast (non Card) address.')
mrmMonPortMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortMulticastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to a multicast (non broadcast) address.')
mrmMonPortBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBroadcastFrames.setDescription(' This counter is incremented by one for each readable frame seen by the Card that is addressed to the broadcast address.')
mrmMonPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortReadableOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonPortUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortUnicastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination field was a unicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonPortMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortMulticastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was a multicast address. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonPortBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBroadcastOctets.setDescription(' This object is the number of octets contained in valid frames that have been received on this port in which the destination was the broadcast address ffffffffffff. By attaching a gauge to this counter one can monitor the port for broadcast storms. Action can then be taken to automatically recover network normal operation. The approximate minimum time for rollover of this counter is 58 minutes.')
mrmMonPortFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortFCSErrors.setDescription(' This counter is incremented by one for each frame received on this port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). The approximate minimum time for rollover of this counter is 80 hours.')
mrmMonPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortAlignmentErrors.setDescription(' This counter is incremented by one for each frame received on this port with the FCSError and FramingError signals asserted and CollisionEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1). If rptrMonitorPortAlignmentErrors is incremented then the rptrMonitorPortFCSErrors Counter shall not be incremented for the same frame. The approximate minimum time for rollover of this counter is 80 hours.')
mrmMonPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortFrameTooLongs.setDescription(' This counter is incremented by one for each frame received on this port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If this parameter is incremented then neither the alignment error nor the FCS error counters shall be incremented for the frame. The approximate minimum time for rollover of this counter is 61 days.')
mrmMonPortShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortShortEvents.setDescription(' This counter is incremented by one for each CarrierEvent on this port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times. ShortEventMaxTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Note: shortEvents may indicate externally generated noise hits which will cause the repeater to transmit Runts to its other ports, or propagate a collision (which may be late) back to the transmitting DTE and damaged frames to the rest of the network. The approximate minimum time for rollover of this counter is 16 hours.')
mrmMonPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortRunts.setDescription(' This counter is incremented by one for each CarrierEvent on this port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than ValidPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times and less than 565 bit times. An event whose length is greater than 74 bit times but less than 82 bit times shall increment either the shortEvents counter or the runts counter but not both. A CarrierEvent greater than or equal to 552 bit times but less than 565 bit times may or may not be counted as a runt. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. In certain situations associated with large diameter networks a percentage of runts may exceed ValidPacketMinTime. The approximate minimum time for rollover of this counter is 16 hours.')
mrmMonPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortCollisions.setDescription(' This counter is incremented by one each time a collision is detected on this port or when the CollisionEvent signal is asserted on this port. The approximate minimum time for rollover of this counter is 16 hours.')
mrmMonPortLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortLateEvents.setDescription(' This counter is incremented by one for each CarrierEvent on this port in which the CollIn(X) variable transitions to the value SQE (Ref: 9.6.6.2, IEEE 802.3 Std) while the ActivityDuration is greater than the LateEventThreshold. Such a CarrierEvent is counted twice, as both a collision and as a lateEvent. The LateEventThreshold is greater than 480 bit times and less than 565 bit times. LateEventThreshold has tolerances included to permit an implementation to build a single threshold to serve as both the LateEventThreshold and ValidPacketMinTime threshold. The approximate minimum time for rollover of this counter is 81 hours.')
mrmMonPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortVeryLongEvents.setDescription(' This counter is incremented by one for each CarrierEvent on this port whose ActivityDuration is greater than the MAU Jabber Lockup Protection timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std). Other counters may be incremented as appropriate.')
mrmMonPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortDataRateMismatches.setDescription(" This counter is incremented by one for each frame received on this port that meets all of the following conditions: a) The CollisionEvent signal is not asserted. b) The ActivityDuration is greater than ValidPacketMinTime. c) The frequency (data rate) is detectably mismatched from the local transmit frequency. The exact degree of mismatch is vendor specific and is to be defined by the vendor for conformance testing. When this event occurs, other counters whose increment conditions were satisfied may or may not also be incremented, at the implementor's discretion. Whether or not the repeater was able to maintain data integrity is beyond the scope of this standard.")
mrmMonPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortAutoPartitions.setDescription(' This counter is incremented by one for each time the repeater has automatically partitioned this port. The conditions that cause port partitioning are specified in the partition state machine in Section 9 [IEEE 802.3 Std]. They are not differentiated here.')
mrmMonPortTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortTotalErrors.setDescription(' The total number of errors which have occurred on this port. This counter is the summation of the values of other error counters (for the same port), namely: FCS Errors, Alignment Errors, Frames Too Long, Short Events, Late Events, Very Long Events, Data Rate Mismatches. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters.')
mrmMonPortBound0 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound0.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound0.setDescription(' This object is the number of frames (including error frames) with a length of 64 octets which were received on this port.')
mrmMonPortBound1 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound1.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound1.setDescription(' This object is the number of frames (including error frames) with a length of between 65 and 127 octets inclusive which were received on this port.')
mrmMonPortBound2 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound2.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound2.setDescription(' This object is the number of frames (including error frames) with a length of between 128 and 255 octets inclusive which were received on this port.')
mrmMonPortBound3 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound3.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound3.setDescription(' This object is the number of frames (including error frames) with a length of between 256 and 511 octets inclusive which were received on this port.')
mrmMonPortBound4 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound4.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound4.setDescription(' This object is the number of frames (including error frames) with a length of between 512 and 1023 octets inclusive which were received on this port.')
mrmMonPortBound5 = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBound5.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBound5.setDescription(' This object is the number of frames (including error frames) with a length of between 1024 and 1518 octets inclusive which were received on this port.')
mrmMonPortBandwidthUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortBandwidthUsed.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortBandwidthUsed.setDescription(" This is a high level 'smart MIB' object. This object provides a running average of the bandwidth in use. This value is calculated locally on the agent and so does not require processor bandwidth from the management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following characteristics: 1) The parameter will be recalculated at approx 15 second intervals 2) Every calculation period the device will read the value of mrmMonPortReadableOctets. 3) The calculation will be performed on the most recent 4 samples as follows: 4 Sum(sample(i)/(time(i) * K)) * 100/4 i=1 Sample(i) is mrmMonPortReadableOctets(i)-mrmMonPortReadableOctets(i-1) time(i) is the time between sample(i-1) and sample(i) K is the max bytes per unit time (i.e. the available bandwidth K depends on the ring speed. The value is expressed as a percentage. A default threshold exists on this average so that if a calculated average exceeds 15% a trap will be sent to the management station. Further traps will not be sent until the average drops to below 10%. A particular device may provide a means of changing the number of samples, the averaging period, threshold and threshold action if it so wishes.")
mrmMonPortErrorsPer10000Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortErrorsPer10000Packets.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortErrorsPer10000Packets.setDescription(" This is a high level 'smart MIB' object. This object provides a running average of the number of errors per 10000 packets. This is an error rate, and is calculated over the number of packets received in the sample periods, and not on every 10000 packets. This value is calculated locally on the agent and so does not require processor bandwidth from a management station or occupy valuable network bandwidth communicating with that station. By default an agent supporting this parameter will exhibit the following behaviour: 1) The parameter will be recalculated at approx 15 second intervals. 2) Every calculation period the device will read the value of mrmMonPortTotalErrors and mrmMonPortReadableFrames. 3) The calculation will be performed on the most recent 4 samples as follows: 4 Sum(Errors(i)/Frames(i)) * 10000/4 i=1 Errors(i) = mrmMonPortTotalErrors(i)-mrmMonPortTotalErrors(i-1) Frames(i) = mrmMonPortReadableFrames(i)-mrmMonPortReadableFrames(i-1) The value is an integer number of errors per 10,000 packets received by this repeater. A default threshold exists on this average so that if a calculated average exceeds 200 (i.e. 2% of frames are in error) a trap will be sent to the management station. Further traps will not be sent until the average drops to below 100 (i.e. 1% of frames are in error). A particular device may provide a means of changing the number of samples, the averaging period and threshold if it so wishes.")
mrmMonPortClearCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChangeCounters", 1), ("clearCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mrmMonPortClearCounters.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortClearCounters.setDescription(' This attribute allows all counters on this Port to be cleared. If read this object will return noChangeCounters(1).')
mrmMonPortLastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 32), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortLastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortLastAddress.setDescription(' This is the last MAC address seen on this port.')
mrmMonPortAddressChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 3, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortAddressChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortAddressChanges.setDescription(' This is a count of the number of times the MAC address on this port has changed. A high number of changes indicates this is either an inter-repeater link or a multi-drop segment.')
trafficLevel = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficLevel.setStatus('deprecated')
if mibBuilder.loadTexts: trafficLevel.setDescription(" This is a dummy 'smart MIB' object which is used internally by the agent to provide a running average of the bandwidth in use. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonPortBandwidthUsed'. See 'mrmMonPortBandwidthUsed' for a description of how the bandwidth used is calculated.")
errorFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: errorFrames.setStatus('deprecated')
if mibBuilder.loadTexts: errorFrames.setDescription(" This is a dummy 'smart MIB' object which is used internally by the agent to provide a running average of the error rate. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonPortErrorsPer10000Packets'. See 'mrmMonPortErrorsPer10000Packets' for a description of how the error rate is calculated.")
mrmMonRepeaterTrafficLevel = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepeaterTrafficLevel.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepeaterTrafficLevel.setDescription("This is a smart MIB object which is used internally by the agent to provide a running average of the bandwidth in use. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonRepeaterBandwidthUsed'. See 'mrmMonRepeaterBandwidthUsed' for a description of how the bandwidth used is calculated.")
mrmMonRepeaterErrorFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonRepeaterErrorFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonRepeaterErrorFrames.setDescription("This is a smart MIB object which is used internally by the agent to provide a running average of the error rate. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonRepeaterErrorsPer10000Packets'. See 'mrmMonRepeaterErrorsPer10000Packets' for a description of how the error rate is calculated.")
mrmMonCardTrafficLevel = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardTrafficLevel.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardTrafficLevel.setDescription("This is a smart MIB object which is used internally by the agent to provide a running average of the bandwidth in use. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonCardBandwidthUsed'. See 'mrmMonCardBandwidthUsed' for a description of how the bandwidth used is calculated.")
mrmMonCardErrorFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonCardErrorFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonCardErrorFrames.setDescription("This is a smart MIB object which is used internally by the agent to provide a running average of the error rate. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonCardErrorsPer10000Packets'. See 'mrmMonCardErrorsPer10000Packets' for a description of how the error rate is calculated.")
mrmMonPortTrafficLevel = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortTrafficLevel.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortTrafficLevel.setDescription("This is a smart MIB object which is used internally by the agent to provide a running average of the bandwidth in use. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonPortBandwidthUsed'. See 'mrmMonPortBandwidthUsed' for a description of how the bandwidth used is calculated.")
mrmMonPortErrorFrames = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 17, 2, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mrmMonPortErrorFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mrmMonPortErrorFrames.setDescription("This is a smart MIB object which is used internally by the agent to provide a running average of the error rate. It should not be accessed by a management station and is used by the logic which calculates the value of its associated object 'mrmMonPortErrorsPer10000Packets'. See 'mrmMonPortErrorsPer10000Packets' for a description of how the error rate is calculated.")
repPartitionStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,38)).setObjects(("LBHUB-FMS-MIB", "mrmPortAutoPartitionState"))
if mibBuilder.loadTexts: repPartitionStateChange.setDescription(' This trap is sent when the partition state of a port changes. The trap is accompanied by the new partition state of the port.')
repLinkStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,39)).setObjects(("LBHUB-FMS-MIB", "mrmPortLinkState"))
if mibBuilder.loadTexts: repLinkStateChange.setDescription(' This trap is sent when the link state of a port changes. The var-bind identifies which port has changed state and what the new state of that port is.')
repAdminStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,40)).setObjects(("LBHUB-FMS-MIB", "mrmPortAdminStatus"))
if mibBuilder.loadTexts: repAdminStateChange.setDescription(' This trap is only sent when the administration state of a port is changed by a gauge. It is not sent if a user initiates a state change via SNMP, Telnet or the V.24 terminal interface.')
repPortTopUsage = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,41)).setObjects(("LBHUB-FMS-MIB", "mrmMonPortBandwidthUsed"), ("LBHUB-FMS-MIB", "gaugeThresholdLevel"), ("LBHUB-FMS-MIB", "gaugeSamplePeriod"), ("LBHUB-FMS-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: repPortTopUsage.setDescription(' This trap is sent when the port bandwidth used exceeds the defined threshold. This threshold is by default 15%, although this may have been changed on a particular device.')
repPortErrors = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,42)).setObjects(("LBHUB-FMS-MIB", "mrmMonPortErrorsPer10000Packets"), ("LBHUB-FMS-MIB", "gaugeThresholdLevel"), ("LBHUB-FMS-MIB", "gaugeSamplePeriod"), ("LBHUB-FMS-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: repPortErrors.setDescription(' This trap is sent when the errors per packet exceeds the the defined threshold.')
dudUnauthorisedDevice = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,66)).setObjects(("LBHUB-FMS-MIB", "mrmPortDUDAction"))
if mibBuilder.loadTexts: dudUnauthorisedDevice.setDescription('This trap is sent when an unrecognised MAC address appears on the port. It is only sent if DUD is set on the port.')
repRepTopUsage = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,67)).setObjects(("LBHUB-FMS-MIB", "mrmMonRepBandwidthUsed"), ("LBHUB-FMS-MIB", "gaugeThresholdLevel"), ("LBHUB-FMS-MIB", "gaugeSamplePeriod"), ("LBHUB-FMS-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: repRepTopUsage.setDescription(' This trap is sent when the repeater bandwidth used exceeds the defined threshold. This threshold is by default 15%, although this may have been changed on a particular device.')
repRepErrors = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,68)).setObjects(("LBHUB-FMS-MIB", "mrmMonRepErrorsPer10000Packets"), ("LBHUB-FMS-MIB", "gaugeThresholdLevel"), ("LBHUB-FMS-MIB", "gaugeSamplePeriod"), ("LBHUB-FMS-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: repRepErrors.setDescription(' This trap is sent when the repeater errors per packet exceeds the the defined threshold.')
repCardTopUsage = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,69)).setObjects(("LBHUB-FMS-MIB", "mrmMonCardBandwidthUsed"), ("LBHUB-FMS-MIB", "gaugeThresholdLevel"), ("LBHUB-FMS-MIB", "gaugeSamplePeriod"), ("LBHUB-FMS-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: repCardTopUsage.setDescription(' This trap is sent when the card bandwidth used exceeds the defined threshold. This threshold is by default 15%, although this may have been changed on a particular device.')
repCardErrors = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,70)).setObjects(("LBHUB-FMS-MIB", "mrmMonCardErrorsPer10000Packets"), ("LBHUB-FMS-MIB", "gaugeThresholdLevel"), ("LBHUB-FMS-MIB", "gaugeSamplePeriod"), ("LBHUB-FMS-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: repCardErrors.setDescription(' This trap is sent when the errors per packet exceeds the the defined threshold.')
setupGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2, 1))
heartbeatInterval = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: heartbeatInterval.setStatus('mandatory')
if mibBuilder.loadTexts: heartbeatInterval.setDescription('The time, in seconds, between successive heartbeat events sent to the management station. An interval of 0 indicates that no heartbeat events are to be generated.')
heartbeatEvent = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,13))
if mibBuilder.loadTexts: heartbeatEvent.setDescription('Generated at a regular interval to inform the manager this device is still operating and can be reached on the network.')
setupIp = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2, 2))
setIpIfTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1), )
if mibBuilder.loadTexts: setIpIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfTable.setDescription('This table shows the IP address and network mask to be used to initialise ipAddrTable on each network interface after the next system restart. There is one entry per network interface and the index is equivalent to the index for the ifTable in the MIB-II interfaces group.')
setIpIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "setIpIfIndex"))
if mibBuilder.loadTexts: setIpIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfEntry.setDescription('The default information relating to a single IP interface.')
setIpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: setIpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex (for ifTable).')
setIpIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setIpIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfAddr.setDescription('The IP address to be used for this interface.')
setIpIfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setIpIfMask.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfMask.setDescription('The IP network mask to be used for this interface.')
setIpIfRouter = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setIpIfRouter.setStatus('mandatory')
if mibBuilder.loadTexts: setIpIfRouter.setDescription("This is the IP address of the default router to be used for sending IP datagrams to remote destinations which have no suitable entry in the routing table. This corresponds to an entry in the MIB-II ipRouteTable with an ipRouteDest field of '0.0.0.0' (the default router) which is set up from this value after a system restart. Changes to this value do not affect the IP routing table until after the next system restart. (To change the default router without a restart, the IP routing table should be changed directly, with an equivalent change to setIpIfRouter only if the change is required to be made permanently.)")
setupStart = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 2, 3))
startPROMSwVerNo = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: startPROMSwVerNo.setStatus('mandatory')
if mibBuilder.loadTexts: startPROMSwVerNo.setDescription('The PROM software version number.')
startRestartCount = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: startRestartCount.setStatus('mandatory')
if mibBuilder.loadTexts: startRestartCount.setDescription('The number of restarts the box has undergone, either power on or reset switch or watchdog expiries.')
startLastRestartType = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("command", 2), ("watchdog", 3), ("power-reset", 4), ("system-error", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: startLastRestartType.setStatus('mandatory')
if mibBuilder.loadTexts: startLastRestartType.setDescription('The reason for the last system restart. This may be due to management command; watchdog timeout expiry; power interruption; the reset switch was pressed or system error. It is not possible to differentiate between the latter two causes.')
startResetAction = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nochange", 1), ("manDefaultReset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: startResetAction.setStatus('mandatory')
if mibBuilder.loadTexts: startResetAction.setDescription('Reset the device with manufacturers default configuration if the manDefaultReset value is written to this item.')
startLastSystemError = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: startLastSystemError.setStatus('mandatory')
if mibBuilder.loadTexts: startLastSystemError.setDescription('The last System Error experienced by the system. This is set to the NVRAM last system error code on startup. When the system issues a TRAP indicating the last system error number the NVRAM version is set to zero. Hence after the next restart this attribute will have the value zero also.')
startRestartAction = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 2, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nochange", 1), ("restart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: startRestartAction.setStatus('mandatory')
if mibBuilder.loadTexts: startRestartAction.setDescription("Restart the device with it's current configuration if the restart value is written to this item.")
loadableDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 3, 1), )
if mibBuilder.loadTexts: loadableDeviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: loadableDeviceTable.setDescription('A table which is used to control the loading of new software images to the devices controlled by the management agent. By convention the first entry in the table (device type = system(1), instance = 1) controls the loading of the device containing the management agent itself. Agents which have no subsidiary devices will have only this one entry in the table. If the Agent does control subsidiary devices, the other entries control the loading of software into subsidiary devices.')
loadableDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "slDeviceType"), (0, "LBHUB-FMS-MIB", "slDeviceInstance"))
if mibBuilder.loadTexts: loadableDeviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loadableDeviceEntry.setDescription('An entry containing the objects for controlling the loading of a software image to a device controlled by the agent.')
slDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("system", 1), ("component", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: slDeviceType.setDescription("The type of the device to load. Simple agents only contain one device type, which is always `system'. More complex agents, probably containing multiple processors, may contain subsidiary devices denoted (for the purposes of the system loader) as `component'. In general, a `system' device is one which monitors and/or manages the operation of `component' devices.")
slDeviceInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slDeviceInstance.setStatus('mandatory')
if mibBuilder.loadTexts: slDeviceInstance.setDescription('The instance of the device type specified by slDeviceType. By convention instance 1 of the system devices is the one containing the management agent, and always exists. Many systems will contain only the one instance of the system device type.')
slLoadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 200, 201, 202, 203, 204, 205, 255))).clone(namedValues=NamedValues(("fileNotFound", 1), ("accessViolation", 2), ("illegalOperation", 4), ("unknownTransferID", 5), ("noSuchUser", 7), ("noResponse", 8), ("noResource", 9), ("recLenMismatch", 10), ("invalidRecType", 11), ("checksumError", 12), ("wrongDevice", 13), ("wrongHardwareVersion", 14), ("noFileHeader", 15), ("byteCountError", 16), ("invalidProgAddress", 17), ("eraseFailed", 18), ("progFailed", 19), ("loadPending", 20), ("loadActive", 21), ("success", 22), ("paused", 23), ("modInvalidAdress", 200), ("modChecksumError", 201), ("modTimeout", 202), ("modBusy", 203), ("modRemoved", 204), ("modNoResource", 205), ("modFailure", 255))).clone('success')).setMaxAccess("readonly")
if mibBuilder.loadTexts: slLoadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: slLoadStatus.setDescription('The status of the last system load operation requested for this device. If the value of this object is in the range 1 to 19 inclusive, or 200 or more, the download failed, and the value is an error code indicating the reason why. Codes 1 to 7 are a direct mapping from the TFTP error codes defined in RFC-783. The possible status values and their meanings are as follows:- fileNotFound(1) the server cannot find the requested file; accessViolation(2) the file system security mechanism does not permit TFTP to access the requested file; illegalOperation(4) TFTP protocol error; unknownTransferID(5) TFTP protocol error; noSuchUser(7) user number not recognised; noResponse(8) load server failed to respond; noResource(9) the download could not be started because of a lack of resources; recLenMismatch(10) the record length differs from that implied by the value of the record length field; invalidRecType(11) the record type is not recognised; checksumError(12) record checksum error; wrongDevice(13) the device type in the file is incorrect; wrongHardwareVersion(14) the software image is not suitable for this version of the hardware; noFileHeader(15) the first record in the file was not a file header; byteCountError(16) the byte count reported in the file trailer record differed from the number of bytes actually received; invalidProgAddress(17) the load file contained a load address which was outside the valid range of memory; eraseFailed(18) unable to erase the program memory; progFailed(19) hardware error programming the memory. The meanings of the remaining values are as follows:- loadPending(20) a load has been requested but has not yet begun; loadActive(21) the device is currently being downloaded; success(22) the device has been downloaded successfully; paused(23) the device could not complete the download at this time, it will request that the load be restarted when it is ready. The following status values may result from downloading a subsidiary module:- modInvalidAdress(200) the load file contained a load address which was outside the valid range of memory; modChecksumError(201) the load data was corrupted as it was transferred from the management agent to the subsidiary module; modTimeout(202) the management agent timed out while waiting for a response from the subsidiary module; modBusy(203) the subsidiary module was unable to accept a command from the management agent; modRemoved(204) the subsidiary module was removed during the download; modNoResource(205) the download could not continue because of a lack of resources; modFailure(255) the subsidiary module failed during the download.')
slSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: slSoftwareVersion.setDescription('The version identifier of the software running in the device.')
slHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slHardwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: slHardwareVersion.setDescription('The version number identifying the revision level of the hardware of the device')
slFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slFilename.setStatus('mandatory')
if mibBuilder.loadTexts: slFilename.setDescription('The name of the file which contains the software image to load, or which was the last loaded to the device.')
slServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slServerIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: slServerIpAddress.setDescription('The IP address of the host containing the software image to load, or from which the last image loaded was read. This object has been deprecated in favour of writing the IP address into slServerAddress.')
slLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("startDownload", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: slLoad.setStatus('mandatory')
if mibBuilder.loadTexts: slLoad.setDescription('Writing 2 to this object causes the agent to attempt to load a new software image to the corresponding device. The file to load and the address of the server to load it from are specified in the other objects in the same row of the table.')
slServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: slServerAddress.setDescription('The address of the server containing the software image to load, or from which the last image was loaded. This is either an IP address in standard dotted notation, or an IPX address in the format aabbccdd:112233445566. An error is returned if the agent does not support the download protocol implied by the address format.')
slServerProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("tftp-ip", 2), ("tftp-ipx", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: slServerProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: slServerProtocol.setDescription('This is the protocol to use when downloading the software from the server specified in slServerAddress. At present, this value is determined by the value of slServerAddress which is currently un-ambiguous and so this object is read-only.')
slFailed = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,18)).setObjects(("LBHUB-FMS-MIB", "slLoadStatus"))
if mibBuilder.loadTexts: slFailed.setDescription('When a system load is requested, a response is returned immediately and the load proceeds in the background. If an error is detected this trap is generated indicating the reason why in the status, as follows:- (1) file not found; (2) access violation; (4) illegal TFTP operation; (5) unknown transfer ID; (7) no such user; (8) no response from the load server; (9) the download could not be started because of a lack of resources; (10) the length of a record differs from that implied by the value of the record length field; (11) the record type is not recognised; (12) record checksum error; (13) the device type in the file is incorrect; (14) the software image is not suitable for this version of the hardware; (15) the first record in the file was not a file header; (16) The byte count reported in the file trailer record differed from the number of bytes actually received; (200) the load file contained a load address which was outside the valid range of memory; (201) the load data was corrupted as it was transferred from the management agent to the subsidiary module; (202) the management agent timed out while waiting for a response from the subsidiary module; (203) the subsidiary module was unable to accept a command from the management agent; (204) the subsidiary module was removed during the download; (205) the download could not continue because of a lack of resources; (255) the subsidiary module failed during the download. When loading a new image into the device containing the agent itself, the agent first reads the beginning of the image file to test if it is accessible and contains a valid image. If there is anything wrong, this trap is generated, no download is performed and the device continues to run uninterrupted. If this check is successful the download proper is begun. Should that fail, it is simply retried continuously until either an attempt succeeds or the device is reset.')
securityEnableTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 4, 1), )
if mibBuilder.loadTexts: securityEnableTable.setStatus('mandatory')
if mibBuilder.loadTexts: securityEnableTable.setDescription('A table of permissions for access to the managed device from each of its interfaces, at each security access level. The table is fixed at 5 rows, indexed by the access level.')
securityEnableTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "securityLevel"))
if mibBuilder.loadTexts: securityEnableTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: securityEnableTableEntry.setDescription('This table allows individual interfaces to be enabled or disabled separately for each security level.')
securityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("monitor", 1), ("secureMonitor", 2), ("manager", 3), ("specialist", 4), ("security", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityLevel.setStatus('mandatory')
if mibBuilder.loadTexts: securityLevel.setDescription('Index to the security enable table.')
securityCommunityEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityCommunityEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securityCommunityEnable.setDescription('Community SNMP access permission')
securitySecureEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securitySecureEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securitySecureEnable.setDescription('Secure SNMP access permission')
securityTermEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityTermEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securityTermEnable.setDescription('Local Terminal access permission')
securityTelnetEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityTelnetEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securityTelnetEnable.setDescription('Telnet access permission')
securityFrontPanelEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("permanentlyEnabled", 3), ("permanentlyDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityFrontPanelEnable.setStatus('mandatory')
if mibBuilder.loadTexts: securityFrontPanelEnable.setDescription('Front Panel access permission')
securityUserTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 4, 2), )
if mibBuilder.loadTexts: securityUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserTable.setDescription('A table used to define Users. Users can be created/modified or deleted, with the exception of the default Users which cannot be deleted.')
securityUserTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "securityUserName"))
if mibBuilder.loadTexts: securityUserTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserTableEntry.setDescription("1. Creating a new user is done by using the username as a qualifier and SETting any of the items in the row - defaults will be used for the remaining values. 2. Deleting a user is by writing 'invalid' to the status column. 3. There must always be users called 'monitor', 'manager' and 'security' - these cannot be deleted.")
securityUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserStatus.setDescription("User Status. `invalid' is used to indicate this user is no longer allowed to access this device, and the table entry may subsequently be re-used. Note that the Status of default Users cannot be set to invalid.")
securityUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityUserName.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserName.setDescription('An ASCII string for the User Name. Empty strings are not allowed. The index column for the User Table.')
securityUserLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("monitor", 1), ("secureMonitor", 2), ("manager", 3), ("specialist", 4), ("security", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserLevel.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserLevel.setDescription('User Access Level defining the scope of management allowed for this user. Note that the access level of default Users cannot be changed.')
securityUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: securityUserPassword.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserPassword.setDescription('The password required for user confirmation, when access is made via the local serial port, the front panel, or via Telnet.')
securityUserCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserCommunity.setDescription('The community string identifying this user, when access is made via the original community-based SNMP (RFC1157).')
securityUserLocParty = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 6), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserLocParty.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserLocParty.setDescription('The local party identity of this user, when access is made via secure SNMP.')
securityUserMgrParty = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 2, 1, 7), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityUserMgrParty.setStatus('mandatory')
if mibBuilder.loadTexts: securityUserMgrParty.setDescription('The manager party identity for this user, when access is made via secure SNMP.')
securityAuditLogTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 4, 3), )
if mibBuilder.loadTexts: securityAuditLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditLogTable.setDescription('The audit log is a circular table recording all updates to the managed database on the device. The log must be read regularly by a management device, to maintain a more permanent record of the management history.')
securityAuditLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "securityAuditIndex"))
if mibBuilder.loadTexts: securityAuditLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditLogEntry.setDescription('Each entry contains the time an update was made, by whom, the item referenced, the new value and the result of this request.')
securityAuditIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditIndex.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditIndex.setDescription('Audit Log Index. A monotonically increasing value to uniquely identify an entry in the audit log. This value wraps around (to 1) after reaching the maximum value (65535).')
securityAuditTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditTime.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditTime.setDescription('The time, in hundredths of a second since the last system restart, of the update request.')
securityAuditUser = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditUser.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditUser.setDescription('The name of the user making the request.')
securityAuditObject = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditObject.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditObject.setDescription('The object identifier of the item being updated. This includes any qualifier for the item.')
securityAuditValue = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditValue.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditValue.setDescription('The new value for the item.')
securityAuditResult = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("success", 255), ("pending", 1), ("too-big", 2), ("failed", 3), ("locked", 4), ("security-violation", 5), ("no-such-function", 6), ("no-such-item", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityAuditResult.setStatus('mandatory')
if mibBuilder.loadTexts: securityAuditResult.setDescription('The result of the update request may indicate that it was applied successfully, that it failed (for one of a number of reasons) or that it is still in progress.')
gaugeTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 5, 1), )
if mibBuilder.loadTexts: gaugeTable.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeTable.setDescription('A table used to define Alarms.')
gaugeTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "gaugeIndex"))
if mibBuilder.loadTexts: gaugeTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeTableEntry.setDescription('This table allows Alarms to be set-up on items in the MIB.')
gaugeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gaugeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeIndex.setDescription('Unique identifier for a row in the Alarm Table. Allocated by the Alarms Subsystem. An integer in the range 1..gaugeTableSize.')
gaugeItemId = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeItemId.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeItemId.setDescription('The object Id and qualifier of the item to be monitored by this alarm. ')
gaugeItemType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("counter", 1), ("signedMeter", 2), ("unsignedMeter", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeItemType.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeItemType.setDescription("A 'counter', by definition will always be a positive number. 'Meters' can be signed or unsigned.")
gaugeSamplesPerAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nonAveraging", 1), ("twoSamples", 2), ("threeSamples", 3), ("maxSamples", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeSamplesPerAverage.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeSamplesPerAverage.setDescription('The number of samples used to calculate the Alarm Value. The default number of samples is four. If a SamplesPerAverage value of one is used, no average is calculated and the GaugeValue will be the most recent sample.')
gaugeSamplePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeSamplePeriod.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeSamplePeriod.setDescription('Number of seconds between samples. The total averaging period is given by (gaugeSamplesPerAverage * gaugeSamplePeiod) secs.')
gaugeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeValue.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeValue.setDescription("The most recently computed average of the item being monitored. For a `meter' alarm, this is the simple average of the samples. For a 'counter' alarm, this is the average of the differences between successive samples. Counters and unsignedMeters are unsigned 32-bit values and have a maximum value of 4294967295. signedMeters are signed 32-bit values and have a maximum value of +-2147483647 divided by the value of gaugeSamplesPerAverage .")
gaugePeakValue = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugePeakValue.setStatus('mandatory')
if mibBuilder.loadTexts: gaugePeakValue.setDescription('The highest recorded Alarm Value. This will be either a signed or unsigned 32 bit value depending on the gaugeItemType')
gaugeThresholdLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeThresholdLevel.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeThresholdLevel.setDescription("The threshold value of the the Alarm which causes the ThresholdState to move from the 'ready' state to the 'fired' state and also causes the the ThresholdAction to be taken. It will be either a signed or unsigned 32-bit integer depending on the gaugeItemType.")
gaugeRecoveryLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeRecoveryLevel.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeRecoveryLevel.setDescription("The threshold value of the the Alarm which causes the ThresholdState to move from the `fired' state to the `ready' state and also causes the the RecoveryAction to be taken. This value will be either a signed or unsigned 32-bit integer depending on the gaugeItemType.")
gaugeThresholdAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 8, 9, 12, 13, 14, 15, 18, 19, 20, 22, 23))).clone(namedValues=NamedValues(("noAction", 1), ("sendTrap", 2), ("disable", 3), ("enable", 4), ("notifyAndBlipPortOff", 5), ("notifyAndBlipCardOff", 6), ("notifyAndDisablePort", 8), ("notifyAndDisableCard", 9), ("blipPortOff", 12), ("blipCardOff", 13), ("disablePort", 14), ("disableCard", 15), ("notifyAndResilientSwitch", 18), ("notifyBandwidthExceeded", 19), ("notifyErrorsExceeded", 20), ("notifyPollFailed", 22), ("notifyFilterBridgePort", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeThresholdAction.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeThresholdAction.setDescription('This object identifies the action to be taken when an Alarm crosses the Threshold Level. The default action will be to send a trigger event (sendTrap). The other actions are device specific and may not be available on all devices. See the RMON Event Table for the actions supported by this device.')
gaugeRecoveryAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 10, 11, 16, 17, 21, 24))).clone(namedValues=NamedValues(("noAction", 1), ("sendTrap", 2), ("disable", 3), ("enable", 4), ("notifyAndEnablePort", 10), ("notifyAndEnableCard", 11), ("enablePort", 16), ("enableCard", 17), ("notifyPollSuccess", 21), ("notifyUnfilterBridgePort", 24)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeRecoveryAction.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeRecoveryAction.setDescription("This object identifies the action to be taken when a 'fired' Alarm crosses the Recovery Level. The default action will be to send a recovery event (sendTrap). The actions for 'disable' and 'enable' are device specific.")
gaugeState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("onTriggersEnabled", 1), ("onTriggersDisabled", 2), ("off", 3), ("deleted", 4), ("autoCalibrate", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeState.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeState.setDescription(" onTriggersEnabled - This is the normal active state of a alarm. The gaugeValue is updated on every sample and if it crosses the Threshold or Recovery Levels, the corresponding Action will be taken. onTriggersDisabled - This is used when a new device, or alarm is set up and the Threshold and Recovery Levels have not been calibrated. The Alarm runs as normal and the gaugeValue and peakValue are updated. However, if the gaugeValue crosses the Threshold or Recovery Levels, no action is taken. off - This de-activates the alarm, allowing it to be configured safely . Before updating any of the Alarm fields the alarm SHOULD be turned off. Turning the alarm 'off' and then 'on' will not lose any of the sampling data, gaugeValue, peakValue, or thresholdStatus. Updates to the index fields will fail since they are read-only. deleted - An alarm is invalidated by setting it to 'deleted'. A 'deleted' alarm will not be returned by a 'GetNext' request. autoCalibrate - Updates the Threshold and Recovery values according to the current peak value. The gaugeState will then be set to 'onTriggersEnabled'. This can be done when the gaugeState is in states (1), (2), or (3). After this operation: thresholdLevel = peakValue * %gaugeThresholdLevelScaler recoveryLevel = peakValue * %gaugeRecoveryLevelScaler gaugeState = onTriggersEnabled When the gaugeState is set to either of the 'on' states, all the fields for the Alarm are validated. If any of the fields are invalid, the operation will fail. The sampling data, gaugeValue, peakValue and thresholdState can be reset by writing 'onTriggersEnabled', 'onTriggers- Disabled' , or 'autoCalibrate' to the gaugeState when it is already in either of the 'on' states.")
gaugeOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 5, 1, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeOwner.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
gaugeTableSize = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gaugeTableSize.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeTableSize.setDescription('Number of entries in Alarm Table. The size of the Alarm Table depends on the requirements and available resources of the device. The actual maximum will probably be around 1000.')
gaugeThresholdLevelScaler = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeThresholdLevelScaler.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeThresholdLevelScaler.setDescription("The ThresholdLevel is set to this percentage of the peakValue when the Alarm is auto-calibrated. e.g gaugeThresholdLevelScaler = 120 gaugePeakValue = 360 After writing 'calibrateTriggers' to the gaugeState: ThresholdLevel = 120/100 * 360 = 432")
gaugeRecoveryLevelScaler = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gaugeRecoveryLevelScaler.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeRecoveryLevelScaler.setDescription("The RecoveryLevel is set to this percentage of the peakValue when the Alarm is auto-calibrated. e.g gaugeRecoveryLevelScaler = 90 gaugePeakValue = 360 After writing 'calibrateTriggers' to the gaugeState: RecoveryLevel = 90/100 * 360 = 324")
gaugeTableUpdate = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("deleteAll", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gaugeTableUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeTableUpdate.setDescription('Performs the specified operation on every Alarm in the table.')
gaugeConfigureObjId = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 6), ObjectIdentifier()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gaugeConfigureObjId.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeConfigureObjId.setDescription('Object Id and qualifier of alarm(s) to be updated.')
gaugeConfigureColumn = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("itemType", 1), ("samplesPerAverage", 2), ("samplePeriod", 3), ("thresholdLevel", 4), ("recoveryLevel", 5), ("thresholdAction", 6), ("recoveryAction", 7), ("gaugeState", 8)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gaugeConfigureColumn.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeConfigureColumn.setDescription('Alarm Table Column to be updated.')
gaugeConfigureValue = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: gaugeConfigureValue.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeConfigureValue.setDescription("Value to be written to the 'gaugeConfigureColumn' of the Alarms which match the 'gaugeConfigureObjId'. Writing to this value initiates the operation.")
gaugeNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 5, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gaugeNextFreeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: gaugeNextFreeIndex.setDescription('Indicates the gaugeIndex which must be used to create the next alarm. Index is set to GAUGE_TABLE_FULL (zero) if there are no free rows in the table.')
gaugesThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,16)).setObjects(("LBHUB-FMS-MIB", "gaugeItemId"), ("LBHUB-FMS-MIB", "gaugeThresholdLevel"), ("LBHUB-FMS-MIB", "gaugeSamplePeriod"), ("LBHUB-FMS-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: gaugesThresholdTrap.setDescription(' Generated when the Alarm value for this Alarm crosses the Threshold Level.')
gaugesRecoveryTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,17)).setObjects(("LBHUB-FMS-MIB", "gaugeItemId"), ("LBHUB-FMS-MIB", "gaugeRecoveryLevel"), ("LBHUB-FMS-MIB", "gaugeSamplePeriod"), ("LBHUB-FMS-MIB", "gaugeSamplesPerAverage"))
if mibBuilder.loadTexts: gaugesRecoveryTrap.setDescription(' Generated when the Alarm value for this Alarm crosses the Recovery Level.')
rmon = MibIdentifier((1, 3, 6, 1, 2, 1, 16))
statistics = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 1))
history = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 2))
alarm = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 3))
hosts = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 4))
hostTopN = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 5))
matrix = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 6))
filter = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 7))
capture = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 8))
event = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 9))
alarmTable = MibTable((1, 3, 6, 1, 2, 1, 16, 3, 1), )
if mibBuilder.loadTexts: alarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: alarmTable.setDescription('A list of alarm entries.')
alarmEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 3, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "alarmIndex"))
if mibBuilder.loadTexts: alarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: alarmEntry.setDescription('A list of parameters that set up a periodic checking for alarm conditions.')
alarmIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alarmIndex.setDescription('An index that uniquely identifies an entry in the alarm table. Each such entry defines a diagnostic sample at a particular interval for an object on the device.')
alarmInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmInterval.setStatus('mandatory')
if mibBuilder.loadTexts: alarmInterval.setDescription('The interval in seconds over which the data is sampled and compared with the rising and falling thresholds. When setting this variable, care should be given to ensure that the variable being monitored will not exceed 2^31 - 1 and roll over the alarmValue object during the interval. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmVariable = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmVariable.setStatus('mandatory')
if mibBuilder.loadTexts: alarmVariable.setDescription('The object identifier of the particular variable to be sampled. Only variables that resolve to an ASN.1 primitive type of INTEGER (INTEGER, Counter, Gauge, or TimeTicks) may be sampled. Because SNMP access control is articulated entirely in terms of the contents of MIB views, no access control mechanism exists that can restrict the value of this object to identify only those objects that exist in a particular MIB view. Because there is thus no acceptable means of restricting the read access that could be obtained through the alarm mechanism, the probe must only grant write access to this object in those views that have read access to all objects on the probe. During a set operation, if the supplied variable name is not available in the selected MIB view, a badValue error must be returned. If at any time the variable name of an established alarmEntry is no longer available in the selected MIB view, the probe must change the status of this alarmEntry to invalid(4). This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmSampleType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absoluteValue", 1), ("deltaValue", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmSampleType.setStatus('mandatory')
if mibBuilder.loadTexts: alarmSampleType.setDescription('The method of sampling the selected variable and calculating the value to be compared against the thresholds. If the value of this object is absoluteValue(1), the value of the selected variable will be compared directly with the thresholds at the end of the sampling interval. If the value of this object is deltaValue(2), the value of the selected variable at the last sample will be subtracted from the current value, and the difference compared with the thresholds. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmValue.setStatus('mandatory')
if mibBuilder.loadTexts: alarmValue.setDescription('The value of the statistic during the last sampling period. The value during the current sampling period is not made available until the period is completed.')
alarmStartupAlarm = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("risingAlarm", 1), ("fallingAlarm", 2), ("risingOrFallingAlarm", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmStartupAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: alarmStartupAlarm.setDescription('The alarm that may be sent when this entry is first set to valid. If the first sample after this entry becomes valid is greater than or equal to the risingThreshold and alarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3), then a single rising alarm will be generated. If the first sample after this entry becomes valid is less than or equal to the fallingThreshold and alarmStartupAlarm is equal to fallingAlarm(2) or risingOrFallingAlarm(3), then a single falling alarm will be generated. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmRisingThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmRisingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: alarmRisingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is greater than or equal to this threshold, and the value at the last sampling interval was less than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is greater than or equal to this threshold and the associated alarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3). After a rising event is generated, another such event will not be generated until the sampled value falls below this threshold and reaches the alarmFallingThreshold. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmFallingThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmFallingThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: alarmFallingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is less than or equal to this threshold, and the value at the last sampling interval was greater than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is less than or equal to this threshold and the associated alarmStartupAlarm is equal to fallingAlarm(2) or risingOrFallingAlarm(3). After a falling event is generated, another such event will not be generated until the sampled value rises above this threshold and reaches the alarmRisingThreshold. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmRisingEventIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmRisingEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alarmRisingEventIndex.setDescription('The index of the eventEntry that is used when a rising threshold is crossed. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmFallingEventIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmFallingEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: alarmFallingEventIndex.setDescription('The index of the eventEntry that is used when a falling threshold is crossed. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
alarmOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmOwner.setStatus('mandatory')
if mibBuilder.loadTexts: alarmOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
alarmStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: alarmStatus.setDescription('The status of this alarm entry.')
eventTable = MibTable((1, 3, 6, 1, 2, 1, 16, 9, 1), )
if mibBuilder.loadTexts: eventTable.setStatus('mandatory')
if mibBuilder.loadTexts: eventTable.setDescription('A list of events to be generated.')
eventEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 9, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "eventIndex"))
if mibBuilder.loadTexts: eventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eventEntry.setDescription('A set of parameters that describe an event to be generated when certain conditions are met.')
eventIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: eventIndex.setDescription('An index that uniquely identifies an entry in the event table. Each such entry defines one event that is to be generated when the appropriate conditions occur.')
eventDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventDescription.setStatus('mandatory')
if mibBuilder.loadTexts: eventDescription.setDescription('A comment describing this event entry.')
eventType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("log", 2), ("snmp-trap", 3), ("log-and-trap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventType.setStatus('mandatory')
if mibBuilder.loadTexts: eventType.setDescription('The type of notification that the probe will make about this event. In the case of log, an entry is made in the log table for each event. In the case of snmp-trap, an SNMP trap is sent to one or more management stations.')
eventCommunity = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: eventCommunity.setDescription('If an SNMP trap is to be sent, it will be sent to the SNMP community specified by this octet string. In the future this table will be extended to include the party security mechanism. This object shall be set to a string of length zero if it is intended that that mechanism be used to specify the destination of the trap.')
eventLastTimeSent = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventLastTimeSent.setStatus('mandatory')
if mibBuilder.loadTexts: eventLastTimeSent.setDescription('The value of sysUpTime at the time this event entry last generated an event. If this entry has not generated any events, this value will be zero.')
eventOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventOwner.setStatus('mandatory')
if mibBuilder.loadTexts: eventOwner.setDescription("The entity that configured this entry and is therefore using the resources assigned to it. If this object contains a string starting with 'monitor' and has associated entries in the log table, all connected management stations should retrieve those log entries, as they may have significance to all management stations connected to this device")
eventStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: eventStatus.setDescription('The status of this event entry. If this object is not equal to valid(1), all associated log entries shall be deleted by the agent.')
logTable = MibTable((1, 3, 6, 1, 2, 1, 16, 9, 2), )
if mibBuilder.loadTexts: logTable.setStatus('mandatory')
if mibBuilder.loadTexts: logTable.setDescription('A list of events that have been logged.')
logEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 9, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "logEventIndex"), (0, "LBHUB-FMS-MIB", "logIndex"))
if mibBuilder.loadTexts: logEntry.setStatus('mandatory')
if mibBuilder.loadTexts: logEntry.setDescription('A set of data describing an event that has been logged.')
logEventIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: logEventIndex.setDescription('The event entry that generated this log entry. The log identified by a particular value of this index is associated with the same eventEntry as identified by the same value of eventIndex.')
logIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logIndex.setStatus('mandatory')
if mibBuilder.loadTexts: logIndex.setDescription('An index that uniquely identifies an entry in the log table amongst those generated by the same eventEntries. These indexes are assigned beginning with 1 and increase by one with each new log entry. The association between values of logIndex and logEntries is fixed for the lifetime of each logEntry. The agent may choose to delete the oldest instances of logEntry as required because of lack of memory. It is an implementation-specific matter as to when this deletion may occur.')
logTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: logTime.setStatus('mandatory')
if mibBuilder.loadTexts: logTime.setDescription('The value of sysUpTime when this log entry was created.')
logDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 9, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logDescription.setStatus('mandatory')
if mibBuilder.loadTexts: logDescription.setDescription('An implementation dependent description of the event that activated this log entry.')
risingAlarm = NotificationType((1, 3, 6, 1, 2, 1, 16) + (0,1)).setObjects(("LBHUB-FMS-MIB", "alarmIndex"), ("LBHUB-FMS-MIB", "alarmVariable"), ("LBHUB-FMS-MIB", "alarmSampleType"), ("LBHUB-FMS-MIB", "alarmValue"), ("LBHUB-FMS-MIB", "alarmRisingThreshold"))
if mibBuilder.loadTexts: risingAlarm.setDescription('The SNMP trap that is generated when an alarm entry crosses its rising threshold and generates an event that is configured for sending SNMP traps.')
fallingAlarm = NotificationType((1, 3, 6, 1, 2, 1, 16) + (0,2)).setObjects(("LBHUB-FMS-MIB", "alarmIndex"), ("LBHUB-FMS-MIB", "alarmVariable"), ("LBHUB-FMS-MIB", "alarmSampleType"), ("LBHUB-FMS-MIB", "alarmValue"), ("LBHUB-FMS-MIB", "alarmFallingThreshold"))
if mibBuilder.loadTexts: fallingAlarm.setDescription('The SNMP trap that is generated when an alarm entry crosses its falling threshold and generates an event that is configured for sending SNMP traps.')
ascTimeAttemptedLogin = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 6, 1), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascTimeAttemptedLogin.setStatus('mandatory')
if mibBuilder.loadTexts: ascTimeAttemptedLogin.setDescription('Time in hundredths of a second when the last Login was attempted. Note, that only the ASCII Agent can write to this parameter. A write operation from any other agent will result in an ERROR')
ascUserNameForLastAttemptedLogin = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 6, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascUserNameForLastAttemptedLogin.setStatus('mandatory')
if mibBuilder.loadTexts: ascUserNameForLastAttemptedLogin.setDescription('An ASCII string used when attempted login. Empty string is NOT valid. Note, that only the ASCII Agent can write to this parameter. A write operation from any other agent will result in an ERROR')
ascLoginStatus = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("loginOKFromTelnet", 1), ("loginOKFromSerialPort", 2), ("deniedAccessFromTelnet", 3), ("deniedAccessFromSerialPort", 4), ("unknownUserFromTelnet", 5), ("unknownUserFromSerialPort", 6), ("incorrectPasswordFromTelnet", 7), ("incorrectPasswordFromSerialPort", 8), ("securityViolationFromTelnet", 9), ("securityViolationFromSerialPort", 10), ("nologin", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLoginStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ascLoginStatus.setDescription("Status of last attempted login. The value 'loginOKFromTelnet' or 'loginOKFromSerialPort' is used to show that the user was allowed access via Telnet or Serial Port. 'DeniedAccessFromTelnet' indicates that a user was denied access via Telnet. The value 'unknownUserFromTelnet' is used to show that a user attempted to login with an invalid user name from a Telnet session and 'incorrectPasswordFromTelnet' is used to show that an invalid password was entered having supplied a valid user name. The value 'securityViolationFromTelnet' is used to indicate that a user has entered the password incorrectly three time consecutively from a Telnet session. Note that only the ASCII Agent can write to this parameter. A write operation from any other agent will result in an ERROR")
ascLocalManagementBanner = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 6, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 490))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ascLocalManagementBanner.setStatus('mandatory')
if mibBuilder.loadTexts: ascLocalManagementBanner.setDescription('An ASCII string describing the Banner to appear on the FIRST screen of the Local Management Terminal. The string of 490 characters defines a region in the centre of the screen which is 7 Rows by 70 Columns')
localManagementUpdate = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,14))
if mibBuilder.loadTexts: localManagementUpdate.setDescription('A local management update trap indicates that the configuration of the device has been modified via the ascii agent. This may be through Telnet or the V24 port.')
securityViolation = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,15)).setObjects(("LBHUB-FMS-MIB", "ascUserNameForLastAttemptedLogin"), ("LBHUB-FMS-MIB", "ascLoginStatus"))
if mibBuilder.loadTexts: securityViolation.setDescription('A security violation trap indicates that a user has attempted to login and failed to enter the correct password Three times consecutively.')
siSlipPort = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 7, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: siSlipPort.setStatus('mandatory')
if mibBuilder.loadTexts: siSlipPort.setDescription('This object identifies the serial port which SLIP can use to send/receive packets. If this object is set to 0xFFFF, then SLIP cannot send/receive packets.')
configV24Table = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 7, 2), )
if mibBuilder.loadTexts: configV24Table.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Table.setDescription('Configuration parameters for all the V.24 ports in a system.')
configV24Entry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "configV24PortID"))
if mibBuilder.loadTexts: configV24Entry.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Entry.setDescription('Configuration parameters for a V.24 port in the system.')
configV24PortID = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configV24PortID.setStatus('mandatory')
if mibBuilder.loadTexts: configV24PortID.setDescription('This attribute uniquely identifies this V.24 port, it is the index for the V.24 table.')
configV24ConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24ConnType.setStatus('mandatory')
if mibBuilder.loadTexts: configV24ConnType.setDescription('This determines if the V.24 port is to be connected locally to a terminal or terminal emulator in which case no interface signals need to be asserted unless requested by other management options below or if the V.24 port is to be connected to a modem when at least DSR is required to be asserted.')
configV24AutoConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24AutoConfig.setStatus('mandatory')
if mibBuilder.loadTexts: configV24AutoConfig.setDescription('This determines if the configuration parameters for the V.24 port, speed, parity, stop bits, character size, are to be determined automatically from an initial character sequence entered by the user or they will be defined by the management options below.')
configV24Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("speed1200", 4), ("speed2400", 5), ("speed4800", 6), ("speed9600", 7), ("speed19200", 8), ("speed38400", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24Speed.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Speed.setDescription('This determines the receive and transmit speed of the V.24 port unless the autoconfigure attribute is enabled when the data rates are determined from the line. Split rx and tx speeds are not possible.')
configV24CharSize = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("size7", 3), ("size8", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24CharSize.setStatus('mandatory')
if mibBuilder.loadTexts: configV24CharSize.setDescription('This determines the character size, unless the autoconfigure attribute is enabled when character size is determined automatically from the line, it may be set to either 7 or 8 bits.')
configV24StopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stopOne", 1), ("stopOneDotFive", 2), ("stopTwo", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24StopBits.setStatus('mandatory')
if mibBuilder.loadTexts: configV24StopBits.setDescription('This determines the number of stop bits.')
configV24Parity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noParity", 1), ("spaceParity", 2), ("markParity", 3), ("oddParity", 4), ("evenParity", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24Parity.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Parity.setDescription('This determines the parity option to be used, unless the autoconfigure attribute is enabled when parity is determined automatically from the line, it may be set to either no parity, space (parity bit always 0), mark (parity bit always 1), odd or even.')
configV24DSRControl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24DSRControl.setStatus('mandatory')
if mibBuilder.loadTexts: configV24DSRControl.setDescription('This attribute is only applicable to local connection types. It determines if DSR need be asserted for a local connection to be made and if the connection need be released if DSR is seen deasserted.')
configV24DCDControl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24DCDControl.setStatus('mandatory')
if mibBuilder.loadTexts: configV24DCDControl.setDescription('This attribute is only applicable to local connection types. It determines if DCD need be asserted for a local connection to be made and if the connection should be release if DCD is seen deasserted.')
configV24FlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noFlowControl", 1), ("xonXoff", 2), ("rtsCtsFullDplx", 3), ("rtsCtsHalfDplx", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24FlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: configV24FlowControl.setDescription('This determines the flow control protocol to be used, either no flow control, xon-xoff, rts-cts full duplex or rts-cts. Full duplex rts/cts uses the rts and cts lines as two independent signals. The DTE signals to the DCE that it is prepared to accept more data by asserting RTS, the DCE signals to the DTE that is is prepared to accept more data by asserting CTS. Half duplex rts/cts (the conventional way) uses CTS as a response to RTS, the DCE flow controls the DTE by only returning CTS is response to a RTS from the DTE when the DCE can accept more data. The DTE can flow control the DCE by raising RTS when it does not want to receive any more input and dropping it when it is ready to receive more.')
configV24Update = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 7, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nochange", 1), ("update", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configV24Update.setStatus('mandatory')
if mibBuilder.loadTexts: configV24Update.setDescription('This attribute may be written to to force the operational V.24 port parameters to be updated.')
esDatabaseState = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noChange", 1), ("modified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: esDatabaseState.setStatus('mandatory')
if mibBuilder.loadTexts: esDatabaseState.setDescription(" This parameter is normally set to 'NO-CHANGE'. When any change is made to the database the value of this parameter becomes 'MODIFIED'. It will remain in this state until a manager sets it back to NO-CHANGE. ")
esDatabaseFlush = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("flush", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: esDatabaseFlush.setStatus('mandatory')
if mibBuilder.loadTexts: esDatabaseFlush.setDescription(' This parameter clears the End Station Database')
esTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 9, 3), )
if mibBuilder.loadTexts: esTable.setStatus('mandatory')
if mibBuilder.loadTexts: esTable.setDescription('End Station Table')
esTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "esAddrType"), (0, "LBHUB-FMS-MIB", "esAddress"))
if mibBuilder.loadTexts: esTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: esTableEntry.setDescription(" The end station database maintains information concerning end-station address information against device port for 802.3 repeater type devices. This table provides one of three views on that database. The view provided by this particular table is indexed firstly on address type and then on address and so can be used to read the entire contents of the database in end-station address order. Additionally one can read all addresses of a certain type from the database, e.g. all IP addresses known. There are some points to note when reading the contents of the end station table. Firstly the repeater number reported will change if a unit is moved from one repeater within a device to another or if a unit is isolated. Secondly an address will only appear in the table once. If an address which is already present in the database is found on another port then the original record is changed and the 'modified' flag set for that entry.")
esAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8021", 1), ("internet", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: esAddrType.setDescription(" The end station database is capable of storing information for a number of different protocols. Each protocol has it's own addressing format. This parameter allows access to the end station database indexed on address type. For example to read all IEE8021 addresses simply start with a get-next operation on IEEE8021.0 and read until the type changes.")
esAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: esAddress.setStatus('mandatory')
if mibBuilder.loadTexts: esAddress.setDescription(' The address information held in this entry of the database. The length and format of the string depends on the address type. For example a MAC address will be a 6 byte OCTET STRING, an IP address a 4 byte OCTET STRING.')
esSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: esSlotNumber.setDescription(' Number of unit on which this address was learnt.')
esPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: esPortNumber.setDescription(' Port number of unit on which this address was learnt.')
esModTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 9, 4), )
if mibBuilder.loadTexts: esModTable.setStatus('mandatory')
if mibBuilder.loadTexts: esModTable.setDescription('End Station Table ( Modified )')
esModTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "esModAddrType"), (0, "LBHUB-FMS-MIB", "esModAddress"))
if mibBuilder.loadTexts: esModTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: esModTableEntry.setDescription(" The end station database maintains information concerning end-station address information against device port for 802.3 repeater type devices. This table provides one of three views on that database. The view provided by this particular table is indexed firstly on address type and then on address. The view is restricted to include only those entries in the database which have the MODIFIED flag set, i.e. that have been changed since the database was last viewed by the manager. This table can be used to read all the modified entries in the table. This is the table generally used to update the contents of a station map in a management station. Note that it can take a reasonable time to read the contents of the table and in that time other changes may occur. To detect this an additional MIB parameter is specified 'esDatabaseState'. This parameter is normally set to 'NO-CHANGE'. When any change is made to the database the value of this parameter becomes 'MODIFIED'. It will remain in this state until a manager sets it back to NO-CHANGE. The recommended access for this table is as follows: do { write 'NO-CHANGE' to esDatabaseState read modified table read esDatabaseState } while esDatabaseState is MODIFIED There are some points to note when reading the contents of the end station table. Firstly the repeater number reported will change if a unit is moved from one repeater within a device to another or if a unit is isolated. Secondly an address will only appear in the table once. If an address which is already present in the database is found on another port then the original record is changed and the 'modified' flag set for that entry.")
esModAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8021", 1), ("internet", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: esModAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: esModAddrType.setDescription(" The end station database is capable of storing information for a number of different protocols. Each protocol has it's own addressing format. This parameter allows access to the end station database indexed on address type. For example to read all IEE8021 addresses simply start with a get-next operation on IEEE8021.0 and read until the type changes.")
esModAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: esModAddress.setStatus('mandatory')
if mibBuilder.loadTexts: esModAddress.setDescription(' The address information held in this entry of the database. The length and format of the string depends on the address type. For example a MAC address will be a 6 byte OCTET STRING, an IP address a 4 byte OCTET STRING.')
esModSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esModSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: esModSlotNumber.setDescription(' Unit number on which this address was learnt.')
esModPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: esModPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: esModPortNumber.setDescription(' Port number of unit on which this address was learnt.')
esPortAccessTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 9, 5), )
if mibBuilder.loadTexts: esPortAccessTable.setStatus('mandatory')
if mibBuilder.loadTexts: esPortAccessTable.setDescription('End Station Table ( Port Access )')
esPortAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "ecPortCardNo"), (0, "LBHUB-FMS-MIB", "ecPortPortNo"), (0, "LBHUB-FMS-MIB", "ecPortIndex"))
if mibBuilder.loadTexts: esPortAccessEntry.setStatus('mandatory')
if mibBuilder.loadTexts: esPortAccessEntry.setDescription(' The end station database maintains information concerning end-station address information against device port for 802.3 repeater type devices. This table provides one of three views on that database. The view provided by this particular table allows one to determine the addresses learnt against a particular port.')
ecPortCardNo = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortCardNo.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortCardNo.setDescription('Unit part of the identifier for this port.')
ecPortPortNo = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortPortNo.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortPortNo.setDescription(' Port number on unit of port for which end station information is required.')
ecPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortIndex.setDescription(' Each port may have a number of addresses against it. This index allows these various addresses to be distinguished. The only stipulation on this number is that it will be unique for the any combination of unit and port. The numbers will be returned in numerically ascending order for a particular unit.port combination but will not be contiguous. For example the following sequence could be seen: Unit Port Index 1 1 211 1 1 231 1 1 438 1 1 672 1 2 120 etc')
ecPortAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8021", 1), ("internet", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortAddrType.setDescription(" The end station database is capable of storing information for a number of different protocols. Each protocol has it's own addressing format. This parameter identifies the type of address in this entry of the table.")
ecPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 9, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ecPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ecPortAddress.setDescription(' The address information held in this entry of the database. The length and format of the string depends on the address type. For example a MAC address will be a 6 byte OCTET STRING, an IP address a 4 byte OCTET STRING.')
estStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,19))
if mibBuilder.loadTexts: estStateChange.setDescription(" When the end-station table moves from the noChange to modified state this trap is generated. The trap is sent once on this transition and not subsequently until the 'Database State' is changed back to 'noChange' by a manager.")
estTableFull = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,20))
if mibBuilder.loadTexts: estTableFull.setDescription(' When the end-station table becomes full this trap is generated.')
pollTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 20, 1), )
if mibBuilder.loadTexts: pollTable.setStatus('mandatory')
if mibBuilder.loadTexts: pollTable.setDescription('This table is used to provide remote device monitoring facilities. This table allows a list of network devices to be set up and polled regularly (or only once) by a variety of protocols. The table can be configured to inform the management station(s) of devices that are not responding to polls or that have started to respond after a period of silence. The minimum effort required to do a single poll is 1. In one packet, Write the address, rate=once-only(1) and RowStatus=CreateAndGo. 2. In the next packet, read the roundTripTime. The minimum effort required to monitor a device is 1. In one packet, Write the address, rate=every-30-seconds(1) and RowStatus=CreateAndGo. 2. Wait for traps to come in.')
pollTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "pollIndex"))
if mibBuilder.loadTexts: pollTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pollTableEntry.setDescription('A table used to define device monitoring.')
pollIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pollIndex.setDescription('Unique identifier of a row in the Poll Table. The actual number of rows that can be created on any particular device depends on the memory and processing resources available at the time.')
pollAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pollAddress.setDescription('This DisplayString is the network address of the device to monitor. Typically this is an IP, MAC or IPX address. The following formats can be used. IP nnn.nnn.nnn.nnn - dotted format IPX AABBCCDD:AABBCCDDEEFF - network : node')
pollProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("ip", 2), ("ipx", 3), ("learn", 4), ("llc", 5))).clone('unknown')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: pollProtocol.setDescription('This defines the protocol to use with which to monitor the device. Writing an address to the pollAddress field causes a default pollProtocol value to be setup. The default value is derived from the format of the address - four bytes means ip(2), and 10 bytes means ipx(3) addresses. If the requested protocol is not supported or is not compatible with the pollAddress, then an error is returned when an attempt is made to set the RowStatus to active or notInService.')
pollRate = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("once-only", 1), ("every-30-seconds", 2), ("every-minute", 3), ("every-5-minutes", 4), ("every-30-minutes", 5), ("every-hour", 6))).clone('once-only')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollRate.setStatus('mandatory')
if mibBuilder.loadTexts: pollRate.setDescription('This defines how often a poll packet is sent to the device. If once-only(1) is chosen, then when the RowStatus is set to active, a single poll packet is to be sent. There are no re-transmissions and no traps are generated. The results of the operation can be read in the pollLastPollSent and pollRoundTripTime fields. When a reply to the poll is received, then the RowStatus is changed to notInService. For the other values, setting the RowStatus to active causes the device to be regularly polled. The operation of the poll can be monitored by reading the pollLastPollSent and pollRoundTripTime fields. After four un-successful polls a pollLostContact trap is generated. The next successful poll to the device causes a pollEstablishedContact trap to be generated. Changing RowStatus from the active state causes polling to stop - in particular changing RowStatus from active to notInService (and vice-versa) is a convenient way of stopping and starting the polls. A poll is said to have been un-successful, if no reply has been received by the time the device is due to be polled again - i.e. if the pollRoundTripTime is still zero. By convention, row 1 of the PollTable is only ever used for once-only(1) polls. The facilities of the RMON Alarm and RMON Event groups are used when regular polling is taking place. These groups perform the timing, threshold checking and trap generation.')
pollTargetType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("file-server", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollTargetType.setStatus('mandatory')
if mibBuilder.loadTexts: pollTargetType.setDescription('This field is provided solely for the purpose of the Network Management station to allow extra information to be stored about this poll table entry. This value is not used by the device.')
pollLastPollSent = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollLastPollSent.setStatus('mandatory')
if mibBuilder.loadTexts: pollLastPollSent.setDescription('Reading this variable returns the sysUpTime at which the last poll was sent to the device. A value of 0 means that no polls have been sent or that the poll could not be sent e.g. protocol error.')
pollRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: pollRoundTripTime.setDescription('This is the round trip time in milli-seconds of the most recent poll to the pollAddress device. A value of 0 means that no reply has been received from the last poll. Round trip times of less than one hundred of a second are reported with the value of 10 milli-seconds.')
pollInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollInformation.setStatus('mandatory')
if mibBuilder.loadTexts: pollInformation.setDescription('After each successful poll, this field is updated with some protocol specific information that was gleaned from the packet exchange. For the IPX protocol, this string contains the number of router hops made by the poll response packet. For the IP protocol, this string contains the value of Time-To-Live from the IP packet header.')
pollAlarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollAlarmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pollAlarmIndex.setDescription('This is a value of alarmIndex from the RMON Alarm Table. The alarm indicated is being used by the PollTable to provide the timing and trap generation facilities. If this value is 0, then no alarm is associated with this PollTable entry.')
pollOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollOwner.setStatus('mandatory')
if mibBuilder.loadTexts: pollOwner.setDescription("The RMON OwnerString conventions are used here to help control the multi-manager situations. This data type is used to model an administratively assigned name of the owner of a resource. This information is taken from the NVT ASCII character set. It is suggested that this name contain one or more of the following: IP address, management station name, network manager's name, location, or phone number. In some cases the agent itself will be the owner of an entry. In these cases, this string shall be set to a string starting with 'monitor'. SNMP access control is articulated entirely in terms of the contents of MIB views; access to a particular SNMP object instance depends only upon its presence or absence in a particular MIB view and never upon its value or the value of related object instances. Thus, objects of this type afford resolution of resource contention only among cooperating managers; they realize no access control function with respect to uncooperative parties.")
pollRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 20, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pollRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pollRowStatus.setDescription('The SNMPv2 RowStatus convention. Notes: 1) Writing any data to a destroyed row, changes its state to notReady. 2) If the status is active or notInService and any of the configuration parameters are changed, then the polling stops and the status is set to notReady.')
pollNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 20, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pollNextFreeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pollNextFreeIndex.setDescription('Indicates the the next value of pollIndex which can be used to create the next poll entry. This value is set to zero if there are no free rows in the table.')
pollTableSuccessTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,61)).setObjects(("LBHUB-FMS-MIB", "pollAddress"), ("LBHUB-FMS-MIB", "pollProtocol"), ("LBHUB-FMS-MIB", "pollTargetType"))
if mibBuilder.loadTexts: pollTableSuccessTrap.setDescription('This trap is generated when the PollTable in the managed agent receives a reply to a poll after a sequence of four or more un-successful polls.')
pollTableFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,62)).setObjects(("LBHUB-FMS-MIB", "pollAddress"), ("LBHUB-FMS-MIB", "pollProtocol"), ("LBHUB-FMS-MIB", "pollTargetType"))
if mibBuilder.loadTexts: pollTableFailedTrap.setDescription('This trap is generated when the PollTable in the managed agent fails to receive a reply to four successive polls.')
trapTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 10, 1), )
if mibBuilder.loadTexts: trapTable.setStatus('deprecated')
if mibBuilder.loadTexts: trapTable.setDescription('The snmp Trap database ')
trapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "trapDestination"))
if mibBuilder.loadTexts: trapEntry.setStatus('deprecated')
if mibBuilder.loadTexts: trapEntry.setDescription('A single snmp Trap entry')
trapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapStatus.setStatus('deprecated')
if mibBuilder.loadTexts: trapStatus.setDescription('The Status of the Entry valid(1) or invalid(2), writing invalid(2) will delete the entry from the table')
trapDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDestination.setStatus('deprecated')
if mibBuilder.loadTexts: trapDestination.setDescription('The Destination IP Address')
trapCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapCommunity.setStatus('deprecated')
if mibBuilder.loadTexts: trapCommunity.setDescription('SNMP Community to be used to send traps to destination trapDestination')
trapSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapSubject.setStatus('deprecated')
if mibBuilder.loadTexts: trapSubject.setDescription('SNMP Subject Party used to generate traps to destination trapDestination')
trapCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapCategory.setStatus('deprecated')
if mibBuilder.loadTexts: trapCategory.setDescription("32 Bit Mask indicating which Trap categories that the snmpTrapDestination is interested in. '00000001'h - High Priority Configuration Traps '00000002'h - Low Priority Configuration Traps '00000004'h - High Priority Security Traps '00000008'h - Low Priority Security Traps '00000010'h - Alarms & Polling Traps '00000020'h - Regular Heartbeat Traps '00000040'h - End Station Table Traps '00000080'h - reserved '00000100'h - Physical Entity Traps '00000200'h - Facility Traps '00000400'h - Service Related Traps A value of 0xFFFFFFFF enables all traps.")
trapThrottle = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapThrottle.setStatus('deprecated')
if mibBuilder.loadTexts: trapThrottle.setDescription('The Maximum rate at which that trapDestination is willing to receive traps, specified as the minimum interval in milliseconds between traps. A value of zero indicates that no trap throttling is required.')
snmpTrapTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 10, 2), )
if mibBuilder.loadTexts: snmpTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapTable.setDescription('This table can store the destination addresses of SNMP managers that wish to receive traps from this device.')
snmpTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "snmpTrapIndex"))
if mibBuilder.loadTexts: snmpTrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapEntry.setDescription('This table can store the destination addresses of SNMP managers that wish to receive traps from this device.')
snmpTrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapIndex.setDescription('This is the unique identifier for this row in the snmpTrapTable. When creating a new row, a manager can read the value of the snmpTrapNextFreeIndex object and (if non-zero) can use this value as the index of the new row to be created. The actual number of rows that can be created on any particular device depends on the memory and processing resources available at the time.')
snmpTrapDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapDestination.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapDestination.setDescription('This DisplayString is the network address of the device to which SNMP traps will be sent. This is an IP or IPX address. The following formats can be used. IP nnn.nnn.nnn.nnn - dotted format IPX AABBCCDD:AABBCCDDEEFF - network : node Destination addresses must be unique within this table. An error is returned if an attempt is made to add a duplicate address.')
snmpTrapProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("ip", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapProtocol.setDescription('This defines the transport protocol to use when sending an SNMP trap. At present, this value is determined by the format/value of snmpTrapDestionation which is currently un-ambiguous and so this object is read-only.')
snmpTrapCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCommunity.setDescription('SNMP Community String to be used when sending Traps to this destination.')
snmpTrapCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapCategory.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCategory.setDescription("32 Bit Mask indicating which Trap categories that the snmpTrapDestination is interested in. '00000001'h - High Priority Configuration Traps '00000002'h - Low Priority Configuration Traps '00000004'h - High Priority Security Traps '00000008'h - Low Priority Security Traps '00000010'h - Alarms & Polling Traps '00000020'h - Regular Heartbeat Traps '00000040'h - End Station Table Traps '00000080'h - reserved '00000100'h - Physical Entity Traps '00000200'h - Facility Traps '00000400'h - Service Related Traps A value of 0xFFFFFFFF enables all traps.")
snmpTrapThrottle = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99999)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapThrottle.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapThrottle.setDescription('The maximum rate at which that snmpTrapDestination is willing to receive traps, specified as the minimum interval in milliseconds between traps. For example, a value of 2000 will limit traps sent to this destination to one trap every 2 seconds. A value of zero indicates that no trap throttling is required.')
snmpTrapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapRowStatus.setDescription('The SNMPv2 RowStatus convention. Notes: Because this is such a simple table:- 1) Writing any data to a destroyed row, changes its state to active. 2) There is no notReady or notInService state. Each row is either active or destroyed.')
snmpTrapNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 10, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapNextFreeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapNextFreeIndex.setDescription('Indicates the the next value of snmpTrapIndex which can be used to create a new trap destination entry. This value is zero if there are no free rows in the table.')
novell = MibIdentifier((1, 3, 6, 1, 4, 1, 23))
mibDoc = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2))
ipx = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5))
ipxSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 1))
ipxCircuit = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 2))
ipxForwarding = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 3))
ipxServices = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 4))
ipxTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 5, 5))
ipxBasicSysTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1), )
if mibBuilder.loadTexts: ipxBasicSysTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysTable.setDescription('The IPX System Table - basic information.')
ipxBasicSysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "ipxBasicSysInstance"))
if mibBuilder.loadTexts: ipxBasicSysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysEntry.setDescription('Each entry corresponds to one instance of IPX running on the system.')
ipxBasicSysInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInstance.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInstance.setDescription('The unique identifier of the instance of IPX to which this row corresponds. This value may be written only when creating a new entry in the table.')
ipxBasicSysExistState = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxBasicSysExistState.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysExistState.setDescription("The validity of this entry in the IPX system table. Setting this field to off indicates that this entry may be deleted from the system table at the IPX implementation's discretion.")
ipxBasicSysNetNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxBasicSysNetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysNetNumber.setDescription('The network number portion of the IPX address of this system.')
ipxBasicSysNode = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxBasicSysNode.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysNode.setDescription('The node number portion of the IPX address of this system.')
ipxBasicSysName = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxBasicSysName.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysName.setDescription('The readable name for this system.')
ipxBasicSysInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInReceives.setDescription('The total number of IPX packets received, including those received in error.')
ipxBasicSysInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInHdrErrors.setDescription('The number of IPX packets discarded due to errors in their headers, including any IPX packets with a size less than the minimum of 30 bytes.')
ipxBasicSysInUnknownSockets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInUnknownSockets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInUnknownSockets.setDescription('The number of IPX packets discarded because the destination socket was not open.')
ipxBasicSysInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInDiscards.setDescription('The number of IPX packets received but discarded due to reasons other than those accounted for by ipxBasicSysInHdrErrors, ipxBasicSysInUnknownSockets, ipxAdvSysInDiscards, and ipxAdvSysInCompressDiscards.')
ipxBasicSysInBadChecksums = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInBadChecksums.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInBadChecksums.setDescription('The number of IPX packets received with incorrect checksums.')
ipxBasicSysInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysInDelivers.setDescription('The total number of IPX packets delivered locally, including packets from local applications.')
ipxBasicSysNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysNoRoutes.setDescription('The number of times no route to a destination was found.')
ipxBasicSysOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOutRequests.setDescription('The number of IPX packets supplied locally for transmission, not including any packets counted in ipxAdvForwPackets.')
ipxBasicSysOutMalformedRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOutMalformedRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOutMalformedRequests.setDescription('The number of IPX packets supplied locally that contained errors in their structure.')
ipxBasicSysOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOutDiscards.setDescription('The number of outgoing IPX packets discarded due to reasons other than those accounted for in ipxBasicSysOutMalformedDiscards, ipxAdvSysOutFiltered, and ipxAdvSysOutCompressDiscards.')
ipxBasicSysOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOutPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOutPackets.setDescription('The total number of IPX packets transmitted.')
ipxBasicSysConfigSockets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysConfigSockets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysConfigSockets.setDescription('The configured maximum number of IPX sockets that may be open at one time.')
ipxBasicSysOpenSocketFails = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxBasicSysOpenSocketFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipxBasicSysOpenSocketFails.setDescription('The number of IPX socket open calls which failed.')
ipxAdvSysTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2), )
if mibBuilder.loadTexts: ipxAdvSysTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysTable.setDescription('The IPX System Table - advanced information.')
ipxAdvSysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "ipxAdvSysInstance"))
if mibBuilder.loadTexts: ipxAdvSysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysEntry.setDescription('Each entry corresponds to one instance of IPX running on the system.')
ipxAdvSysInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxAdvSysInstance.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysInstance.setDescription('The unique identifer of the instance of IPX to which this row corresponds. This value may be written only when creating a new entry in the table.')
ipxAdvSysMaxPathSplits = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxAdvSysMaxPathSplits.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysMaxPathSplits.setDescription('The maximum number of paths with equal routing metric value which this instance of the IPX my split between when forwarding packets.')
ipxAdvSysMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 3), Integer32().clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipxAdvSysMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysMaxHops.setDescription('The maximum number of hops a packet may take.')
ipxAdvSysTooManyHops = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysTooManyHops.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysTooManyHops.setDescription('The number of IPX packets discarded due to exceeding the maximum hop count.')
ipxAdvSysInFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysInFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysInFiltered.setDescription('The number of incoming IPX packets discarded due to filtering.')
ipxAdvSysCompressDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysCompressDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysCompressDiscards.setDescription('The number of incoming IPX packets discarded due to decompression errors.')
ipxAdvSysNETBIOSPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysNETBIOSPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysNETBIOSPackets.setDescription('The number of NETBIOS packets received.')
ipxAdvSysForwPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysForwPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysForwPackets.setDescription('The number of IPX packets forwarded.')
ipxAdvSysOutFiltered = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysOutFiltered.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysOutFiltered.setDescription('The number of outgoing IPX packets discarded due to filtering.')
ipxAdvSysOutCompressDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysOutCompressDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysOutCompressDiscards.setDescription('The number of outgoing IPX packets discarded due to compression errors.')
ipxAdvSysCircCount = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysCircCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysCircCount.setDescription('The number of circuits known to this instance of IPX.')
ipxAdvSysDestCount = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysDestCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysDestCount.setDescription('The number of currently reachable destinations known to this instance of IPX.')
ipxAdvSysServCount = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 5, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipxAdvSysServCount.setStatus('mandatory')
if mibBuilder.loadTexts: ipxAdvSysServCount.setDescription('The number of services known to this instance of IPX.')
resTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 15, 1), )
if mibBuilder.loadTexts: resTable.setStatus('mandatory')
if mibBuilder.loadTexts: resTable.setDescription('')
resTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "resRepeater"), (0, "LBHUB-FMS-MIB", "resMainSlot"), (0, "LBHUB-FMS-MIB", "resMainPort"))
if mibBuilder.loadTexts: resTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: resTableEntry.setDescription(" An MSH may be configured to contain a number of 'resilient pairs'. These are 802.3 point to point connections, e.g. UTP, that allow two repeaters to be connected together in a resilient configuration. In such a configuration one of the two ports is nominated the 'main' port while the other is the 'standby' port. One of these two ports is enabled and is the current active port. The other is present in case of failure of the active port. Such a failure is detected by the MSH and a switch performed. There are a couple of rules that must apply to a resilient pair definition before that definition becomes a valid resilient pair. Firstly both ports must be on the same repeater. Secondly the standby port must be configured to be 'disabled on boot'. That is it must recover from a power failure in a disabled state. This prevents loops in the network. Several tables control the resilient repeater configuration for the MSH. This is the first. This is the main table and allows the creation and deletion of pairs and provides status control and information. The information in this table is indexed on the repeater number and the slot/port location of the main port. To create a new resilient pair simply write any writeable object indexed on the main port. This will create a new entry in the table which has the state 'invalid' (read resPairState). Having created the row, write to the other parameters specifying valid information. When all the parameters are valid the resPairState will become 'operational'. In this state the pair will correctly operate as a resilient pair. If any of the attributes in the table change so that the pair in no linger valid this will be reflected in the resPortState parameter. To delete a resilient pair, write 'delete' to resPairAction.")
resRepeater = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resRepeater.setStatus('mandatory')
if mibBuilder.loadTexts: resRepeater.setDescription(' A resilient pair must be attached to one of the repeaters in the chassis. This is part of the index value required to access this table.')
resMainSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resMainSlot.setDescription(' This is the second key in the index to this table. This is the slot number of the main port in this pair.')
resMainPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainPort.setStatus('mandatory')
if mibBuilder.loadTexts: resMainPort.setDescription(' This is the final, key used to index entries in this table. It is the port number of the main port in the pair.')
resMainState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("failed", 1), ("ok", 2), ("ok-and-active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainState.setStatus('mandatory')
if mibBuilder.loadTexts: resMainState.setDescription(' Each port in a pair is constantly monitored for signs of failure. Failure information is used to automatically change the active port from main to standby or vice-versa. Each port may be in one of three states. Failed indicates there is a loss of signal on this port. A port in this state cannot be active. Secondly OK. This state indicates that the port is capable of carrying traffic but is at the moment acting in the role of backup link. The other port in this pair will be in the OK and Active state. OK and Active means what it says, this port is capable of carrying traffic and is so doing at the time this parameter has been read.')
resStandbySlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resStandbySlot.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbySlot.setDescription(' This is the slot number of the standby port for this pair. The port must be present on the same repeater as the main port and so this information is not duplicated.')
resStandbyPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resStandbyPort.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyPort.setDescription('This is the port number of the standby port.')
resStandbyState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("failed", 1), ("ok", 2), ("ok-and-active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resStandbyState.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyState.setDescription(' Each port in a pair is constantly monitored for signs of failure. Failure information is used to automatically change the active port from main to standby or vice-versa. Each port may be in one of three states. Failed indicates there is a loss of signal on this port. A port in this state cannot be active. Secondly OK. This state indicates that the port is capable of carrying traffic but is at the moment acting in the role of backup link. The other port in this pair will be in the OK and Active state. OK and Active means what it says, this port is capable of carrying traffic and is so doing at the time this parameter has been read.')
resPairState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("operational", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resPairState.setStatus('mandatory')
if mibBuilder.loadTexts: resPairState.setDescription(" Each row in the table is in one of two states, 'invalid' or 'operational'. If the state is 'invalid', the resilient pair represented by this row is not active. There are several reasons why this may be the case. Firstly during the row creation process, not all information necessary may have been provided. Secondly an operational pair may become invalid because the resilient pair rules are no longer met because of a change in the MSH configuration. The rules are that both main and standby ports be on the same repeater and that the standby port be 'disable on boot'. Changing the standby card, moving one of the cards to a different repeater are two possible changes that can invalidate a pair configration. If the parameters in the row are all valid then the pair becomes 'operational'.")
resPairModificationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("under-modification", 1), ("stable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairModificationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: resPairModificationStatus.setDescription(' This parameter must be set to under-modification before any changes are made to an existing configuration. Changes are not applied until this parameter is set to stable. ')
resPairAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("create", 1), ("delete", 2), ("togglePort", 3)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: resPairAction.setStatus('mandatory')
if mibBuilder.loadTexts: resPairAction.setDescription(" This is object allows the state of a resilient pair to be modified. The create operation configures the resilient port from this table entry. The delete operation removes the resilient definitions from this table and terminates operation of resilience on this pair of ports. The togglePort operation allows the current active port to be changed to the other port. This second operation will only take affect if the state of the currently non-active port is 'OK'.")
resPairEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairEnable.setStatus('mandatory')
if mibBuilder.loadTexts: resPairEnable.setDescription(' This parameter controls whether the resilient pair is enabled or not. In the disabled state , both ports of the resilient pair are disabled. The default value of this parameter is enable ')
resStandbyMapTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 15, 2), )
if mibBuilder.loadTexts: resStandbyMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyMapTable.setDescription('')
resStandbyMapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "resSbRepeater"), (0, "LBHUB-FMS-MIB", "resSbSlot"), (0, "LBHUB-FMS-MIB", "resSbPort"))
if mibBuilder.loadTexts: resStandbyMapTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyMapTableEntry.setDescription(' This table is read-only. If provides shortcut information to allow for the translation of a port number to a corresponding main port number. This value can then be used to access the main resilience table. Each resilient pair has two entries in this table, one for the main port and one for the standby port. The entry for the main port returns the same port, the entry for the standby port returns the corresponding main port.')
resSbRepeater = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbRepeater.setStatus('mandatory')
if mibBuilder.loadTexts: resSbRepeater.setDescription(' The repeater index of the port being accessed. This is the first of three indices on this table.')
resSbSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resSbSlot.setDescription('Second index on this table.')
resSbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbPort.setStatus('mandatory')
if mibBuilder.loadTexts: resSbPort.setDescription('Third index on this table.')
resSbType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("standby", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbType.setStatus('mandatory')
if mibBuilder.loadTexts: resSbType.setDescription(' This attribute specifies whether the port indexed is a main or standby port in the resilient pair table. If the port is neither then there will not be a row in this table indexed for that port.')
resSbMainSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbMainSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resSbMainSlot.setDescription(" This is the slot number of the main port for the pair in which the indexed port participates. NOTE if the index port is the main port of a pair (resSbType is 'main') this value will be the same as the index.")
resSbMainPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbMainPort.setStatus('mandatory')
if mibBuilder.loadTexts: resSbMainPort.setDescription(" This is the port number of the main port for the pair in which the indexed port participates. NOTE if the index port is the main port of a pair (resSbType is 'main') this value will be the same as the index.")
resFlushTable = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 15, 3), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: resFlushTable.setStatus('mandatory')
if mibBuilder.loadTexts: resFlushTable.setDescription(' This parameter causes all entries in the resilience table to be flushed. Flushing the resilience table does not affect the state of any of the resilient links or ports. Once the table has been flushed , NO resilient links are configured. This parameter is used to ensure that the resilient link table is empty , before new resilient links are configured.')
resResilienceSwitch = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,43)).setObjects(("LBHUB-FMS-MIB", "resMainState"), ("LBHUB-FMS-MIB", "resStandbyState"))
if mibBuilder.loadTexts: resResilienceSwitch.setDescription(" This trap is generated when a change of state of one of the ports in a resilient pair does not result in a switch of active port. If such a switch were to occur the resResilienceSwitch would be generated. Generation of this trap is summarised in the following table: ------------------------------------------------------------------------------ State | Event Main Backup |Main Fail |Main OK |StandBy Fail |Standby OK ------------------------------------------------------------------------------ Active OK | switch | ----- | state | ----- Active Fail | state | ----- | ----- | state OK Active | state | ----- | switch | ----- Fail Active | ----- | state | state | ----- Fail Fail | ----- | switch | ----- | state ----------------------------------------------------------------------------- In this table '-----' indicates no trap is sent. 'switch' indicates the resResilienceSwitch trap is sent and 'state' indicates resStateChange is sent. NOTE: The agent in the MSH does not suppress any traps that caused the state change. For example if the active link is lost then both a 'loss-of-link' trap AND a resilienceSwitch trap are generated.")
resStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,44)).setObjects(("LBHUB-FMS-MIB", "resMainState"), ("LBHUB-FMS-MIB", "resStandbyState"))
if mibBuilder.loadTexts: resStateChange.setDescription(" This trap is generated when a change of state of one of the ports in a resilient pair does not result in a switch of active port. If such a switch were to occur the resResilienceSwitch would be generated. Generation of this trap is summarised in the following table: ------------------------------------------------------------------------------ State | Event Main Backup |Main Fail |Main OK |StandBy Fail |Standby OK ------------------------------------------------------------------------------ Active OK | switch | ----- | state | ----- Active Fail | state | ----- | ----- | state OK Active | state | ----- | switch | ----- Fail Active | ----- | state | state | ----- Fail Fail | ----- | switch | ----- | state ----------------------------------------------------------------------------- In this table '-----' indicates no trap is sent. 'switch' indicates the resResilienceSwitch trap is sent and 'state' indicates resStateChange is sent. NOTE: The agent in the MSH does not suppress any traps that caused the state change. For example if the active link is lost then both a 'loss-of-link' trap AND a resilienceSwitch trap are generated.")
powerStackPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 21, 1))
powerStackBackupPresent = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 21, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerStackBackupPresent.setStatus('mandatory')
if mibBuilder.loadTexts: powerStackBackupPresent.setDescription('Indicates whether a Resilient Backup Power Supply is being used by this stack of units.')
powerStackBackupData = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 21, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerStackBackupData.setStatus('mandatory')
if mibBuilder.loadTexts: powerStackBackupData.setDescription('Supplies all the information about the power supplies attached to each unit in a stack. This object is provided to speed up processing by Network Manager applications. There is one octet for each unit in the stack. Each octet contains the following information: Bit 1: RBS applicable ( 1 = Yes, 0 = No ) Bit 2: RBS present ( 1 = Yes, 0 = No ) Bit 3: RBS status ( 1 = fault, 0 = OK ) ( RBS = Resilient Backup Power Supply ) If Bit 1 is zero, this means that an RBS cannot be attached to this unit and all the other bits will be zero.')
powerStackTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 21, 1, 3), )
if mibBuilder.loadTexts: powerStackTable.setStatus('mandatory')
if mibBuilder.loadTexts: powerStackTable.setDescription('This table provides power supply status information for all units in an FMS stack.')
powerStackTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 21, 1, 3, 1), ).setIndexNames((0, "LBHUB-FMS-MIB", "powerStackTableIndex"))
if mibBuilder.loadTexts: powerStackTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: powerStackTableEntry.setDescription('Each Table entry provides information for a single unit in the stack.')
powerStackTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 21, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerStackTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: powerStackTableIndex.setDescription('Identifies which FMS unit (1-8) the table entry relates to.')
powerStackRBSPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 21, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rbsNotApplicable", 1), ("rbsPresent", 2), ("rbsNotPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerStackRBSPresent.setStatus('mandatory')
if mibBuilder.loadTexts: powerStackRBSPresent.setDescription("This indicates whether a Resilient Power Supply is attached to this unit. A value of rbsNotApplicable indicates that this unit does not support Resilient Power Supplies, rbsPresent indicates that a RBS is attached and in use, rbsNotPresent indicates that this unit is using it's internal supply.")
powerStackRBSStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 21, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rbsNotApplicable", 1), ("rbsOK", 2), ("rbsFault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerStackRBSStatus.setStatus('mandatory')
if mibBuilder.loadTexts: powerStackRBSStatus.setDescription('This indicates the status of a Resilient Power Supply attached to this unit. A value of rbsNotApplicable indicates that this unit does not support Resilient Power Supplies, rbsok indicates that the attached RBS is functioning with no faults, rbsFault indicates that the RBS has a fault e.g. fan has failed or switched power supplies.')
powerStackBackupFault = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,63))
if mibBuilder.loadTexts: powerStackBackupFault.setDescription('This trap indicates that a Resilient Backup Power Supply connected to this repeater has developed a fault. This fault has not stopped the RBS from functioning e.g. fan failed, unit overheating, or unit has switched to resilient power supply.')
powerStackBackupRecovered = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,64))
if mibBuilder.loadTexts: powerStackBackupRecovered.setDescription('This trap indicates that a Resilient Backup Power Supply connected to this repeater has recovered from and outstanding fault.')
mibBuilder.exportSymbols("LBHUB-FMS-MIB", gaugesRecoveryTrap=gaugesRecoveryTrap, deprRptrPortOperStatus=deprRptrPortOperStatus, trapSubject=trapSubject, linkBuilderFMSII_cards_12fiber_st=linkBuilderFMSII_cards_12fiber_st, mrmMonCardBroadcastOctets=mrmMonCardBroadcastOctets, gaugeTableEntry=gaugeTableEntry, pollLastPollSent=pollLastPollSent, pddrmMonGroupUniCastFrames=pddrmMonGroupUniCastFrames, deprSnmpDot3RpMauMgt=deprSnmpDot3RpMauMgt, mrmMonRepeaterPackage=mrmMonRepeaterPackage, mrmCardDOBPorts=mrmCardDOBPorts, faultEntry=faultEntry, vmConfigGroupTable=vmConfigGroupTable, mrmMonCardIndex=mrmMonCardIndex, lBridgeECS_mib=lBridgeECS_mib, repPortTopUsage=repPortTopUsage, linkBuilderFDDI_wghub_mib=linkBuilderFDDI_wghub_mib, pddrmMonRepeaterDataRateMismatches=pddrmMonRepeaterDataRateMismatches, setIpIfAddr=setIpIfAddr, ipxAdvSysEntry=ipxAdvSysEntry, ipxBasicSysInDelivers=ipxBasicSysInDelivers, linkBuilderMSH_cards=linkBuilderMSH_cards, deprRptrGroupLastOperStatusChange=deprRptrGroupLastOperStatusChange, alarmStatus=alarmStatus, powerStackTableIndex=powerStackTableIndex, pddrmMonGroupFrameTooLongs=pddrmMonGroupFrameTooLongs, slHardwareVersion=slHardwareVersion, vmMonDvtEcho=vmMonDvtEcho, mrmMonCardDataRateMismatches=mrmMonCardDataRateMismatches, ascTimeAttemptedLogin=ascTimeAttemptedLogin, pddrmMonGroupVeryLongEvents=pddrmMonGroupVeryLongEvents, alarm=alarm, resMainPort=resMainPort, securityUserName=securityUserName, vmMacMonitorTable=vmMacMonitorTable, linkBuilder10BTi=linkBuilder10BTi, mrmMonPortServiceId=mrmMonPortServiceId, mrmMonCardUnicastOctets=mrmMonCardUnicastOctets, mrmPortTable=mrmPortTable, ipxBasicSysConfigSockets=ipxBasicSysConfigSockets, deprRptrMonitorPackage=deprRptrMonitorPackage, deprRptrMonitorRptrInfo=deprRptrMonitorRptrInfo, mrmCardMDIenable=mrmCardMDIenable, mrmMonCardClearCounters=mrmMonCardClearCounters, ipxAdvSysInFiltered=ipxAdvSysInFiltered, resPairEnable=resPairEnable, securityViolation=securityViolation, linkBuilderFMS_cards_12fiber=linkBuilderFMS_cards_12fiber, gaugeState=gaugeState, mrmMonCardShortEvents=mrmMonCardShortEvents, fault=fault, ipxTraps=ipxTraps, pddrmMonPortDummyPackage=pddrmMonPortDummyPackage, securityEnableTable=securityEnableTable, snmpTrapCommunity=snmpTrapCommunity, deprRptrMonitorPortReadableOctets=deprRptrMonitorPortReadableOctets, linkBuilder3GH_cards=linkBuilder3GH_cards, deprRpMauType=deprRpMauType, pddrmMonGroupAutoPartitions=pddrmMonGroupAutoPartitions, mrmMonCardBound1=mrmMonCardBound1, configV24Parity=configV24Parity, pddrmMonRepeaterLateEvents=pddrmMonRepeaterLateEvents, genericMSWorkstation=genericMSWorkstation, pddrmMonitorPortTable=pddrmMonitorPortTable, deprRptrMonitorPortRunts=deprRptrMonitorPortRunts, configV24DSRControl=configV24DSRControl, esModAddress=esModAddress, at=at, mrmPortAdminStatus=mrmPortAdminStatus, mrmMonPortDataRateMismatches=mrmMonPortDataRateMismatches, eventIndex=eventIndex, faultModifiedFlag=faultModifiedFlag, deprRptrAddrTrackLastSourceAddress=deprRptrAddrTrackLastSourceAddress, ipxBasicSysInstance=ipxBasicSysInstance, pddrmMonRepeaterReadableFrames=pddrmMonRepeaterReadableFrames, slDeviceType=slDeviceType, deprRptrMonitorPortFCSErrors=deprRptrMonitorPortFCSErrors, mrmPortConnectorType=mrmPortConnectorType, terminalServer=terminalServer, repRepTopUsage=repRepTopUsage, setIpIfRouter=setIpIfRouter, slFailed=slFailed, snmpTrapEntry=snmpTrapEntry, linkBuilder10BTi_cards_utp=linkBuilder10BTi_cards_utp, powerSupply=powerSupply, pddrmMonGroupClearCounters=pddrmMonGroupClearCounters, deprRptrGroupDescr=deprRptrGroupDescr, mrmMonPortSmartPackage=mrmMonPortSmartPackage, mrmMonRepAutoPartitions=mrmMonRepAutoPartitions, esModTableEntry=esModTableEntry, ipxAdvSysCompressDiscards=ipxAdvSysCompressDiscards, ipxBasicSysOutPackets=ipxBasicSysOutPackets, slServerIpAddress=slServerIpAddress, mrmMonPortCollisions=mrmMonPortCollisions, slLoadStatus=slLoadStatus, mrmMonRepMulticastFrames=mrmMonRepMulticastFrames, deprRptrBasicPackage=deprRptrBasicPackage, snmpTrapThrottle=snmpTrapThrottle, multiRepeater=multiRepeater, deprRptrOperStatus=deprRptrOperStatus, esPortAccessTable=esPortAccessTable, pddrmMonitorGroupTable=pddrmMonitorGroupTable, mrmMonPortTrafficLevel=mrmMonPortTrafficLevel, vmMonFaultRestartCount=vmMonFaultRestartCount, ecPortAddress=ecPortAddress, ipxBasicSysInBadChecksums=ipxBasicSysInBadChecksums, pddrmMonRepeaterMultiCastFrames=pddrmMonRepeaterMultiCastFrames, mrmCardIndex=mrmCardIndex, ipxBasicSysOutMalformedRequests=ipxBasicSysOutMalformedRequests, vmConGroupPortMask=vmConGroupPortMask, ipxBasicSysNetNumber=ipxBasicSysNetNumber, vmMonFaultEntry=vmMonFaultEntry, esSlotNumber=esSlotNumber, a3Com=a3Com, genericTrap=genericTrap, pddrmMonRepeaterReadableOctets=pddrmMonRepeaterReadableOctets, resPairAction=resPairAction, linkBuilderFDDIwg=linkBuilderFDDIwg, pollIndex=pollIndex, ipxForwarding=ipxForwarding, deprRpMauJabberState=deprRpMauJabberState, pddrmMonRepeaterAlignmentErrors=pddrmMonRepeaterAlignmentErrors, linkbuilderMonitorPackage=linkbuilderMonitorPackage, securityTelnetEnable=securityTelnetEnable, trapCommunity=trapCommunity, vmMonMgmtBusFramingError=vmMonMgmtBusFramingError, mrmMonRepRunts=mrmMonRepRunts, mrmMonCardAutoPartitions=mrmMonCardAutoPartitions, mrmMonPortShortEvents=mrmMonPortShortEvents, deprRptrAddrTrackPortInfo=deprRptrAddrTrackPortInfo, mrmMonRepUnicastOctets=mrmMonRepUnicastOctets, deprRptrAddrTrackGroupInfo=deprRptrAddrTrackGroupInfo, vmConfigPortTable=vmConfigPortTable, mrmMonRepReadableOctets=mrmMonRepReadableOctets, mrmMonCardReadableFrames=mrmMonCardReadableFrames, snmpTrapRowStatus=snmpTrapRowStatus, ipxBasicSysOutDiscards=ipxBasicSysOutDiscards, mrmPortLinkState=mrmPortLinkState, deprRpMauMediaAvailable=deprRpMauMediaAvailable, deprRptrMonitorPortDataRateMismatches=deprRptrMonitorPortDataRateMismatches, pddrmMonGroupAlignmentErrors=pddrmMonGroupAlignmentErrors, linkBuilderFMS_mib=linkBuilderFMS_mib, vmMacMonitorIndex=vmMacMonitorIndex, pddrmMonPortIndex=pddrmMonPortIndex, mrmMonPortFrameTooLongs=mrmMonPortFrameTooLongs, novell=novell, alarmTable=alarmTable, powerStackBackupPresent=powerStackBackupPresent, vmMonFaultIndex=vmMonFaultIndex, mrmCardTable=mrmCardTable, mrmMonRepBound2=mrmMonRepBound2, deprRptrNonDisruptTest=deprRptrNonDisruptTest, mrmMonCardMulticastFrames=mrmMonCardMulticastFrames, endStation=endStation, ipxBasicSysNode=ipxBasicSysNode, powerStackBackupData=powerStackBackupData, mrmMonPortAlignmentErrors=mrmMonPortAlignmentErrors, serialIf=serialIf, vmMacMonitorOverflowErrors=vmMacMonitorOverflowErrors, pddrmMonPortESTFilter=pddrmMonPortESTFilter, pddrmMonRepeaterAutoPartitionTraps=pddrmMonRepeaterAutoPartitionTraps, mrmMonPortBound4=mrmMonPortBound4, securityUserTableEntry=securityUserTableEntry, resStandbyMapTable=resStandbyMapTable, pddrmMonRepeaterVeryLongEvents=pddrmMonRepeaterVeryLongEvents, linkBuilderFMS_cards_utp=linkBuilderFMS_cards_utp, mrmMonCardErrorFrames=mrmMonCardErrorFrames, resFlushTable=resFlushTable, linkBuilder3GH=linkBuilder3GH, eventCommunity=eventCommunity, configV24Speed=configV24Speed, ipxSystem=ipxSystem, ascLocalManagementBanner=ascLocalManagementBanner, pddrmMonPortAutoPartitionTraps=pddrmMonPortAutoPartitionTraps, mrmMonRepDataRateMismatches=mrmMonRepDataRateMismatches, deprRptrGroupInfo=deprRptrGroupInfo, deprRptrAddrTrackPortIndex=deprRptrAddrTrackPortIndex, ipxBasicSysNoRoutes=ipxBasicSysNoRoutes, linkBuilderFMSII_cards_24tp_rj45=linkBuilderFMSII_cards_24tp_rj45, rmon=rmon, esModAddrType=esModAddrType, faultTimeStamp=faultTimeStamp, trapStatus=trapStatus, mrmMonCardFCSErrors=mrmMonCardFCSErrors, securityUserPassword=securityUserPassword, pollTableFailedTrap=pollTableFailedTrap, faultTable=faultTable, linkBuilderECS_cards=linkBuilderECS_cards, vmMacMonitorEntry=vmMacMonitorEntry, trapDestination=trapDestination, powerStackBackupRecovered=powerStackBackupRecovered, mrmMonCardLateEvents=mrmMonCardLateEvents, ipxAdvSysForwPackets=ipxAdvSysForwPackets, mib_2=mib_2, pddrmMonGroupBroadCastFrames=pddrmMonGroupBroadCastFrames, gaugeValue=gaugeValue, configV24StopBits=configV24StopBits, esDatabaseState=esDatabaseState, PhysAddress=PhysAddress, pddrmMonitorPortEntry=pddrmMonitorPortEntry, mrmPortEntry=mrmPortEntry, mrmMonPortMulticastOctets=mrmMonPortMulticastOctets, deprRptrMonitorGroupTotalOctets=deprRptrMonitorGroupTotalOctets, securityTermEnable=securityTermEnable, deprRptrMonitorPortLateEvents=deprRptrMonitorPortLateEvents, snmpTrapDestination=snmpTrapDestination, startPROMSwVerNo=startPROMSwVerNo, localManagementUpdate=localManagementUpdate, mrmPortServiceId=mrmPortServiceId, repLinkStateChange=repLinkStateChange, deprRptrMonitorTransmitCollisions=deprRptrMonitorTransmitCollisions, alarmRisingEventIndex=alarmRisingEventIndex, DisplayString=DisplayString, deprRptrMonitorPortVeryLongEvents=deprRptrMonitorPortVeryLongEvents, pddrmMonGroupShortEvents=pddrmMonGroupShortEvents, deprRptrAddrTrackPackage=deprRptrAddrTrackPackage, pddrmMonRepeaterShortEvents=pddrmMonRepeaterShortEvents, mrmMonCardMulticastOctets=mrmMonCardMulticastOctets, deprSnmpDot3RptrMgt=deprSnmpDot3RptrMgt, dedicatedBridgeServer=dedicatedBridgeServer, hosts=hosts, linkBuilder10BTi_mib=linkBuilder10BTi_mib, linkBuilderFMS=linkBuilderFMS, snmpTrapTable=snmpTrapTable, esModPortNumber=esModPortNumber, ecPortCardNo=ecPortCardNo, trapEntry=trapEntry, ipxBasicSysExistState=ipxBasicSysExistState, generic=generic, pddrmMonitorPackage=pddrmMonitorPackage, vmConPortGroupIndex=vmConPortGroupIndex, deprRptrGroupIndex=deprRptrGroupIndex, mrmMonCardBound0=mrmMonCardBound0, deprRptrMonitorPortAlignmentErrors=deprRptrMonitorPortAlignmentErrors, configV24AutoConfig=configV24AutoConfig, alarmStartupAlarm=alarmStartupAlarm, asciiAgent=asciiAgent, linkbuilderStatusPackage=linkbuilderStatusPackage, eventTable=eventTable, linkBuilderECS=linkBuilderECS, ascUserNameForLastAttemptedLogin=ascUserNameForLastAttemptedLogin, vmMonBatteryStatus=vmMonBatteryStatus, securitySecureEnable=securitySecureEnable, mrmMonRepBroadcastFrames=mrmMonRepBroadcastFrames, mrmMonPortReadableOctets=mrmMonPortReadableOctets, mrmMonitorRepEntry=mrmMonitorRepEntry, mrmMonitorCardTable=mrmMonitorCardTable, alarmIndex=alarmIndex, resPairState=resPairState, slLoad=slLoad, securityUserCommunity=securityUserCommunity, gaugeTableUpdate=gaugeTableUpdate, mrmMonPortClearCounters=mrmMonPortClearCounters, ifExtensions=ifExtensions)
mibBuilder.exportSymbols("LBHUB-FMS-MIB", alarmFallingEventIndex=alarmFallingEventIndex, egp=egp, faultIndex=faultIndex, mrmMonCardAlignmentErrors=mrmMonCardAlignmentErrors, mrmMonPortUnicastFrames=mrmMonPortUnicastFrames, esPortAccessEntry=esPortAccessEntry, vmMonMgmtBusOverflowError=vmMonMgmtBusOverflowError, pollTableEntry=pollTableEntry, gauges=gauges, ipxBasicSysTable=ipxBasicSysTable, vmConPortType=vmConPortType, history=history, setIpIfIndex=setIpIfIndex, heartbeatEvent=heartbeatEvent, icmp=icmp, mrmMonRepServiceId=mrmMonRepServiceId, gaugeThresholdAction=gaugeThresholdAction, pddrmMonitorGroupEntry=pddrmMonitorGroupEntry, udp=udp, pddrmMonPortGroupIndex=pddrmMonPortGroupIndex, logDescription=logDescription, logEntry=logEntry, mrmMonRepMulticastOctets=mrmMonRepMulticastOctets, mrmMonRepBroadcastOctets=mrmMonRepBroadcastOctets, repPortErrors=repPortErrors, gaugeItemType=gaugeItemType, alarmRisingThreshold=alarmRisingThreshold, powerStackBackupFault=powerStackBackupFault, configV24Update=configV24Update, snmpTrapCategory=snmpTrapCategory, resStandbyMapTableEntry=resStandbyMapTableEntry, vmMacMonitorLateEvents=vmMacMonitorLateEvents, mrmMonCardFrameTooLongs=mrmMonCardFrameTooLongs, gaugeSamplePeriod=gaugeSamplePeriod, deprRptrGroupCapacity=deprRptrGroupCapacity, deprRptrGroupTable=deprRptrGroupTable, deprRptrPortGroupIndex=deprRptrPortGroupIndex, dudUnauthorisedDevice=dudUnauthorisedDevice, alarmInterval=alarmInterval, ipxAdvSysOutCompressDiscards=ipxAdvSysOutCompressDiscards, configV24FlowControl=configV24FlowControl, trapThrottle=trapThrottle, vmConPortSquelch=vmConPortSquelch, startLastSystemError=startLastSystemError, alarmEntry=alarmEntry, vmMonFaultModifiedFlag=vmMonFaultModifiedFlag, mrmMonPortBroadcastFrames=mrmMonPortBroadcastFrames, mrmMonRepeaterTrafficLevel=mrmMonRepeaterTrafficLevel, linkBuilder3GH_mib=linkBuilder3GH_mib, securityLevel=securityLevel, gaugeConfigureValue=gaugeConfigureValue, dot1dBridge=dot1dBridge, estTableFull=estTableFull, tcp=tcp, mrmMonPortRunts=mrmMonPortRunts, powerStackTableEntry=powerStackTableEntry, mrmMonCardBound3=mrmMonCardBound3, mrmMonRepShortEvents=mrmMonRepShortEvents, startLastRestartType=startLastRestartType, ipxBasicSysInReceives=ipxBasicSysInReceives, vmMonFault=vmMonFault, dedicatedRouteServer=dedicatedRouteServer, snmpTrapIndex=snmpTrapIndex, mrmMonPortBound5=mrmMonPortBound5, mrmPortIndex=mrmPortIndex, mrmMonCardErrorsPer10000Packets=mrmMonCardErrorsPer10000Packets, ip=ip, ipxBasicSysName=ipxBasicSysName, pddrmMonRepeaterCollisions=pddrmMonRepeaterCollisions, mrmMonRepVeryLongEvents=mrmMonRepVeryLongEvents, slDeviceInstance=slDeviceInstance, trafficLevel=trafficLevel, securityAuditLogTable=securityAuditLogTable, deprRptrPortAutoPartitionState=deprRptrPortAutoPartitionState, mrmMonRepErrorsPer10000Packets=mrmMonRepErrorsPer10000Packets, specificTrap=specificTrap, vmMauMediaAvailable=vmMauMediaAvailable, ipxAdvSysInstance=ipxAdvSysInstance, mrmMonCardServiceId=mrmMonCardServiceId, mrmCardServiceId=mrmCardServiceId, eventLastTimeSent=eventLastTimeSent, brouter=brouter, system=system, vmMacMonitorMissErrors=vmMacMonitorMissErrors, setIpIfTable=setIpIfTable, gaugesThresholdTrap=gaugesThresholdTrap, poll=poll, vmMonFaultTimeStamp=vmMonFaultTimeStamp, deprRptrMonitorPortInfo=deprRptrMonitorPortInfo, gaugeThresholdLevel=gaugeThresholdLevel, vmConfigGroupEntry=vmConfigGroupEntry, pddrmMonGroupPackage=pddrmMonGroupPackage, gaugeConfigureObjId=gaugeConfigureObjId, gaugeItemId=gaugeItemId, ipxBasicSysInUnknownSockets=ipxBasicSysInUnknownSockets, deprRptrMonitorGroupInfo=deprRptrMonitorGroupInfo, mrmCardTest=mrmCardTest, pddrmMonRepeaterTotalErrors=pddrmMonRepeaterTotalErrors, gaugeSamplesPerAverage=gaugeSamplesPerAverage, securityUserLevel=securityUserLevel, ipxAdvSysDestCount=ipxAdvSysDestCount, deprRptrPortEntry=deprRptrPortEntry, mrmBasCardPackage=mrmBasCardPackage, deprRptrMonitorPortAutoPartitions=deprRptrMonitorPortAutoPartitions, deprRpMauGroupIndex=deprRpMauGroupIndex, pollTargetType=pollTargetType, resSbMainSlot=resSbMainSlot, filter=filter, repeaterMgmt=repeaterMgmt, mrmMonRepAlignmentErrors=mrmMonRepAlignmentErrors, vmConPortXoverSwitchState=vmConPortXoverSwitchState, deprRptrMonitorPortShortEvents=deprRptrMonitorPortShortEvents, securityAuditTime=securityAuditTime, deprRptrPortInfo=deprRptrPortInfo, deprRptrPortIndex=deprRptrPortIndex, resSbSlot=resSbSlot, vmMacMonitorFramingErrors=vmMacMonitorFramingErrors, deprRptrHealth=deprRptrHealth, ipxAdvSysOutFiltered=ipxAdvSysOutFiltered, alarmValue=alarmValue, linkBuilderFMS_cards_coax=linkBuilderFMS_cards_coax, ipx=ipx, ipxAdvSysMaxHops=ipxAdvSysMaxHops, estStateChange=estStateChange, pollOwner=pollOwner, eventEntry=eventEntry, vmMonPOSTResults=vmMonPOSTResults, vmMacMonitorBabbleErrors=vmMacMonitorBabbleErrors, mrmMonPortAutoPartitions=mrmMonPortAutoPartitions, gaugeRecoveryLevel=gaugeRecoveryLevel, netBuilder_mib=netBuilder_mib, mrmBasPortPackage=mrmBasPortPackage, mrmMonPortAddressChanges=mrmMonPortAddressChanges, gaugeTableSize=gaugeTableSize, gaugeTable=gaugeTable, deprRptrMonitorPortReadableFrames=deprRptrMonitorPortReadableFrames, deprRpMauLostMedias=deprRpMauLostMedias, logEventIndex=logEventIndex, ipxBasicSysEntry=ipxBasicSysEntry, mrmResilience=mrmResilience, securityAuditIndex=securityAuditIndex, mrmMonRepLateEvents=mrmMonRepLateEvents, resStandbySlot=resStandbySlot, pddrmMonGroupIndex=pddrmMonGroupIndex, deprRptrMonitorGroupTable=deprRptrMonitorGroupTable, deprRptrMonitorPortIndex=deprRptrMonitorPortIndex, deprRpMauPortIndex=deprRpMauPortIndex, capture=capture, linkBuilderFMS_cards_fiber=linkBuilderFMS_cards_fiber, mrmMonPortBound0=mrmMonPortBound0, mrmMonCardPackage=mrmMonCardPackage, resStandbyPort=resStandbyPort, deprRptrMonitorGroupIndex=deprRptrMonitorGroupIndex, resTableEntry=resTableEntry, alarmSampleType=alarmSampleType, cards=cards, deprRptrAddrTrackTable=deprRptrAddrTrackTable, snmpTrapNextFreeIndex=snmpTrapNextFreeIndex, mrmMonCardReadableOctets=mrmMonCardReadableOctets, pddrmMonGroupLateEvents=pddrmMonGroupLateEvents, logTime=logTime, mrmMonitorPortTable=mrmMonitorPortTable, pddrmMonGroupDataRateMismatches=pddrmMonGroupDataRateMismatches, esTableEntry=esTableEntry, pollRoundTripTime=pollRoundTripTime, deprRptrTotalPartitionedPorts=deprRptrTotalPartitionedPorts, mrmMonRepFrameTooLongs=mrmMonRepFrameTooLongs, mrmMonRepTotalErrors=mrmMonRepTotalErrors, hostTopN=hostTopN, alarmFallingThreshold=alarmFallingThreshold, resSbPort=resSbPort, mrmMonCardSmartPackage=mrmMonCardSmartPackage, mrmMonRepFCSErrors=mrmMonRepFCSErrors, securityAuditLogEntry=securityAuditLogEntry, mrmMonCardUnicastFrames=mrmMonCardUnicastFrames, genExperimental=genExperimental, deprRptrResetEvent=deprRptrResetEvent, vmMacMonitorFCSErrors=vmMacMonitorFCSErrors, deprRptrMonitorPortGroupIndex=deprRptrMonitorPortGroupIndex, risingAlarm=risingAlarm, pddrmMonRepeaterAutoPartitions=pddrmMonRepeaterAutoPartitions, mrmMonRepeaterSmartPackage=mrmMonRepeaterSmartPackage, pddrmMonGroupCollisions=pddrmMonGroupCollisions, mrmPortModule=mrmPortModule, trapTable=trapTable, mrmMonRepBandwidthUsed=mrmMonRepBandwidthUsed, linkbuilderMonitorMacPackage=linkbuilderMonitorMacPackage, loadableDeviceEntry=loadableDeviceEntry, linkBuilderFMSII_cards_12tp_rj45=linkBuilderFMSII_cards_12tp_rj45, linkBuilderFMSII_cards_24tp_telco=linkBuilderFMSII_cards_24tp_telco, mrmPortLinkStateEvent=mrmPortLinkStateEvent, linkBuilderFMSII_cards_6fiber_st=linkBuilderFMSII_cards_6fiber_st, mrmCardEntry=mrmCardEntry, mrmMonPortErrorsPer10000Packets=mrmMonPortErrorsPer10000Packets, pddrmMonPortMultiCastFrames=pddrmMonPortMultiCastFrames, amp_mib=amp_mib, powerStackRBSPresent=powerStackRBSPresent, vmConGroupIndex=vmConGroupIndex, deprRpMauJabberTrap=deprRpMauJabberTrap, pollNextFreeIndex=pollNextFreeIndex, mrmMonRepBound4=mrmMonRepBound4, configV24PortID=configV24PortID, mrmMonitorPortEntry=mrmMonitorPortEntry, eventStatus=eventStatus, vmConPortIndex=vmConPortIndex, mrmMonRepBound3=mrmMonRepBound3, linkbuilderConfigPackage=linkbuilderConfigPackage, mrmMonCardBandwidthUsed=mrmMonCardBandwidthUsed, deprRptrMonitorGroupTotalErrors=deprRptrMonitorGroupTotalErrors, gaugeRecoveryLevelScaler=gaugeRecoveryLevelScaler, deprRptrReset=deprRptrReset, ipxCircuit=ipxCircuit, ipxBasicSysInDiscards=ipxBasicSysInDiscards, fallingAlarm=fallingAlarm, vmConfigPortEntry=vmConfigPortEntry, pddrmMonRepeaterPackage=pddrmMonRepeaterPackage, chipsets=chipsets, ipxBasicSysOutRequests=ipxBasicSysOutRequests, mrmMonPortBound2=mrmMonPortBound2, hub=hub, deprRptrAddrTrackEntry=deprRptrAddrTrackEntry, resRepeater=resRepeater, mrmMonPortBroadcastOctets=mrmMonPortBroadcastOctets, linkBuilderECS_mib=linkBuilderECS_mib, chassis=chassis, securityUserLocParty=securityUserLocParty, deprRpMauEntry=deprRpMauEntry, mrmMonCardVeryLongEvents=mrmMonCardVeryLongEvents, event=event, pollProtocol=pollProtocol, deprRptrMonitorPortFrameTooLongs=deprRptrMonitorPortFrameTooLongs, powerStackPackage=powerStackPackage, securityAuditUser=securityAuditUser, pddrmMonPortUniCastFrames=pddrmMonPortUniCastFrames, deprRptrAddrTrackRptrInfo=deprRptrAddrTrackRptrInfo, deprRptrGroupPortCapacity=deprRptrGroupPortCapacity, linkBuilderFMSLBridge=linkBuilderFMSLBridge, configV24Table=configV24Table, mrmPortBootState=mrmPortBootState, pddrmMonPortPackage=pddrmMonPortPackage, mrmMonPortIndex=mrmMonPortIndex, deprRptrPortTable=deprRptrPortTable, deprRptrMonitorPortTotalErrors=deprRptrMonitorPortTotalErrors, ipxAdvSysTooManyHops=ipxAdvSysTooManyHops, resTable=resTable, mrmMonRepReadableFrames=mrmMonRepReadableFrames, securityFrontPanelEnable=securityFrontPanelEnable, configV24DCDControl=configV24DCDControl, mrmMonPortCardIndex=mrmMonPortCardIndex, linkBuilderMSH=linkBuilderMSH, mrmMonPortErrorFrames=mrmMonPortErrorFrames, vmConMediaModuleCardType=vmConMediaModuleCardType, linkBuilderFMS_cards=linkBuilderFMS_cards, deprRptrMonitorGroupTotalFrames=deprRptrMonitorGroupTotalFrames)
mibBuilder.exportSymbols("LBHUB-FMS-MIB", interfaces=interfaces, mrmMonDummyPackage=mrmMonDummyPackage, esAddrType=esAddrType, ipxAdvSysMaxPathSplits=ipxAdvSysMaxPathSplits, deskMan_mib=deskMan_mib, pddrmMonRepeaterFCSErrors=pddrmMonRepeaterFCSErrors, resSbType=resSbType, linkSwitch_mib=linkSwitch_mib, loadableDeviceTable=loadableDeviceTable, pddrmBasPortPackage=pddrmBasPortPackage, pddrmMonGroupMultiCastFrames=pddrmMonGroupMultiCastFrames, vmMonMgmtBusOverrunError=vmMonMgmtBusOverrunError, gaugeIndex=gaugeIndex, slFilename=slFilename, ipxBasicSysOpenSocketFails=ipxBasicSysOpenSocketFails, repCardErrors=repCardErrors, faultRestartCount=faultRestartCount, pollAddress=pollAddress, pollTableSuccessTrap=pollTableSuccessTrap, viewBuilderApps=viewBuilderApps, linkBuilder10BTi_cards=linkBuilder10BTi_cards, setIpIfEntry=setIpIfEntry, mrmMonPortLastAddress=mrmMonPortLastAddress, sysLoader=sysLoader, vmMacMonitorMemoryErrors=vmMacMonitorMemoryErrors, esDatabaseFlush=esDatabaseFlush, configV24ConnType=configV24ConnType, ecPortIndex=ecPortIndex, pollTable=pollTable, snmpTrapProtocol=snmpTrapProtocol, linkBuilderFMSII_cards=linkBuilderFMSII_cards, configV24CharSize=configV24CharSize, esModSlotNumber=esModSlotNumber, pollAlarmIndex=pollAlarmIndex, deprRptrAddrTrackSourceAddrChanges=deprRptrAddrTrackSourceAddrChanges, eventOwner=eventOwner, ecPortPortNo=ecPortPortNo, vmMacMonitorUnderflowErrors=vmMacMonitorUnderflowErrors, mrmMonRepeaterErrorFrames=mrmMonRepeaterErrorFrames, trapCategory=trapCategory, pollInformation=pollInformation, mrmMonPortMulticastFrames=mrmMonPortMulticastFrames, genericMSServer=genericMSServer, slServerProtocol=slServerProtocol, powerStackRBSStatus=powerStackRBSStatus, deprRpMauAdminState=deprRpMauAdminState, vmConMediaModuleRevNo=vmConMediaModuleRevNo, startResetAction=startResetAction, deprRptrGroupChange=deprRptrGroupChange, ipxBasicSysInHdrErrors=ipxBasicSysInHdrErrors, vmConfigMediaTable=vmConfigMediaTable, bridgeMgmt=bridgeMgmt, mrmMonPortPackage=mrmMonPortPackage, repRepErrors=repRepErrors, esAddress=esAddress, pddrmMonGroupDummyPackage=pddrmMonGroupDummyPackage, vmConfigMediaEntry=vmConfigMediaEntry, ipxAdvSysCircCount=ipxAdvSysCircCount, deprRptrHealthText=deprRptrHealthText, slServerAddress=slServerAddress, deprRptrGroupObjectID=deprRptrGroupObjectID, pddrmMonPortClearCounters=pddrmMonPortClearCounters, ipxAdvSysServCount=ipxAdvSysServCount, repPartitionStateChange=repPartitionStateChange, pddrmBasicPackage=pddrmBasicPackage, statistics=statistics, resMainSlot=resMainSlot, ipxServices=ipxServices, resMainState=resMainState, securityCommunityEnable=securityCommunityEnable, pddrmMonGroupRunts=pddrmMonGroupRunts, mrmPortESTFilter=mrmPortESTFilter, securityEnableTableEntry=securityEnableTableEntry, genericUnixServer=genericUnixServer, pddrmMonRepeaterClearCounters=pddrmMonRepeaterClearCounters, mrmMonitorPackage=mrmMonitorPackage, mrmMonPortVeryLongEvents=mrmMonPortVeryLongEvents, vmConMediaIndex=vmConMediaIndex, mrmMonCardBroadcastFrames=mrmMonCardBroadcastFrames, gaugeNextFreeIndex=gaugeNextFreeIndex, gaugeRecoveryAction=gaugeRecoveryAction, vmMacMonitorRetryErrors=vmMacMonitorRetryErrors, deprRptrPortAdminStatus=deprRptrPortAdminStatus, resPairModificationStatus=resPairModificationStatus, mrmMonRepAction=mrmMonRepAction, deprRptrMonitorGroupEntry=deprRptrMonitorGroupEntry, mrmCardPortCapacity=mrmCardPortCapacity, mrmPortFunction=mrmPortFunction, deprRptrAddrTrackGroupIndex=deprRptrAddrTrackGroupIndex, mrmMonRepBound0=mrmMonRepBound0, pddrmMonRepeaterRunts=pddrmMonRepeaterRunts, eventDescription=eventDescription, slSoftwareVersion=slSoftwareVersion, manager=manager, deprRptrMonitorPortCollisions=deprRptrMonitorPortCollisions, pddrmMonGroupFCSErrors=pddrmMonGroupFCSErrors, securityUserStatus=securityUserStatus, pollRate=pollRate, security=security, mrmMonPortBound1=mrmMonPortBound1, matrix=matrix, securityUserTable=securityUserTable, mrmPortLinkPulse=mrmPortLinkPulse, setupStart=setupStart, esPortNumber=esPortNumber, startRestartCount=startRestartCount, mrmMonitorCardEntry=mrmMonitorCardEntry, deprRpMauTable=deprRpMauTable, unusedGeneric12=unusedGeneric12, mrmMonPortBandwidthUsed=mrmMonPortBandwidthUsed, pddrmMonPortMediaAvailableTraps=pddrmMonPortMediaAvailableTraps, vmConPortLinkPulse=vmConPortLinkPulse, ipxAdvSysTable=ipxAdvSysTable, mrmMonCardTrafficLevel=mrmMonCardTrafficLevel, repAdminStateChange=repAdminStateChange, resSbRepeater=resSbRepeater, siSlipPort=siSlipPort, mrmPortCardIndex=mrmPortCardIndex, resStateChange=resStateChange, securityAuditResult=securityAuditResult, securityAuditObject=securityAuditObject, gaugeConfigureColumn=gaugeConfigureColumn, gaugeOwner=gaugeOwner, eventType=eventType, mrmMonRepBound1=mrmMonRepBound1, deprRpMauIndex=deprRpMauIndex, products=products, mrmMonCardRunts=mrmMonCardRunts, pddrmMonRepeaterMediaAvailableTraps=pddrmMonRepeaterMediaAvailableTraps, mrmMonPortTotalErrors=mrmMonPortTotalErrors, vmMacMonitorLCarErrors=vmMacMonitorLCarErrors, mrmBasicPackage=mrmBasicPackage, setupGeneral=setupGeneral, ipxAdvSysNETBIOSPackets=ipxAdvSysNETBIOSPackets, mrmMonCardBound5=mrmMonCardBound5, mrmMonitorRepTable=mrmMonitorRepTable, errorFrames=errorFrames, mrmMonRepBound5=mrmMonRepBound5, gaugeThresholdLevelScaler=gaugeThresholdLevelScaler, pddrmMonRepeaterFrameTooLongs=pddrmMonRepeaterFrameTooLongs, mrmMonRepUnicastFrames=mrmMonRepUnicastFrames, linkBuilderFMSII=linkBuilderFMSII, mrmMonCardTotalErrors=mrmMonCardTotalErrors, mrmMonPortLateEvents=mrmMonPortLateEvents, ecPortAddrType=ecPortAddrType, deprRptrGroupOperStatus=deprRptrGroupOperStatus, vmMonFaultErrorNumber=vmMonFaultErrorNumber, mibDoc=mibDoc, linkBuilder10BT_cards_utp=linkBuilder10BT_cards_utp, vmMonMgmtBusFiFoFullCounter=vmMonMgmtBusFiFoFullCounter, deprRpMauJabbers=deprRpMauJabbers, mrmPortSecurityAvailable=mrmPortSecurityAvailable, vmMonFaultTable=vmMonFaultTable, snmp=snmp, linkSwitchFMS=linkSwitchFMS, logTable=logTable, deprRpMauBasicGroup=deprRpMauBasicGroup, configV24Entry=configV24Entry, alarmVariable=alarmVariable, deprRptrRptrInfo=deprRptrRptrInfo, logIndex=logIndex, testData=testData, mrmPortDUDAction=mrmPortDUDAction, resStandbyState=resStandbyState, transmission=transmission, pddrmMonRepeaterUniCastFrames=pddrmMonRepeaterUniCastFrames, localSnmp=localSnmp, deprRptrMonitorPortTable=deprRptrMonitorPortTable, deprRptrGroupEntry=deprRptrGroupEntry, esTable=esTable, setup=setup, linkBuilderMSH_mib=linkBuilderMSH_mib, pollRowStatus=pollRowStatus, mrmMonCardBound4=mrmMonCardBound4, setIpIfMask=setIpIfMask, alarmOwner=alarmOwner, resSbMainPort=resSbMainPort, mrmMonCardBound2=mrmMonCardBound2, setupIp=setupIp, faultErrorNumber=faultErrorNumber, pddrmMonRepeaterDummyPackage=pddrmMonRepeaterDummyPackage, mrmMonPortBound3=mrmMonPortBound3, powerStackTable=powerStackTable, linkSwitchMSH=linkSwitchMSH, pddrmMonPortBroadCastFrames=pddrmMonPortBroadCastFrames, securityAuditValue=securityAuditValue, heartbeatInterval=heartbeatInterval, mrmMonPortReadableFrames=mrmMonPortReadableFrames, pddrmMonRepeaterBroadCastFrames=pddrmMonRepeaterBroadCastFrames, pddrmBasGroupPackage=pddrmBasGroupPackage, mrmPortInterfaceType=mrmPortInterfaceType, linkBuilderFMSII_cards_10coax_bnc=linkBuilderFMSII_cards_10coax_bnc, gaugePeakValue=gaugePeakValue, mrmPortAutoPartitionState=mrmPortAutoPartitionState, esModTable=esModTable, securityUserMgrParty=securityUserMgrParty, mrmMonPortUnicastOctets=mrmMonPortUnicastOctets, startRestartAction=startRestartAction, resResilienceSwitch=resResilienceSwitch, vmAutoPartitionState=vmAutoPartitionState, tokenRing=tokenRing, linkBuilderFMS_cards_24utp=linkBuilderFMS_cards_24utp, mrmPortPartitionEvent=mrmPortPartitionEvent, mrmMonPortFCSErrors=mrmMonPortFCSErrors, mrmMonRepTxCollisions=mrmMonRepTxCollisions, deprRptrMonitorPortEntry=deprRptrMonitorPortEntry, repCardTopUsage=repCardTopUsage, pddrmBasRepeaterPackage=pddrmBasRepeaterPackage, ascLoginStatus=ascLoginStatus)

#
# PySNMP MIB module OCTOPUSE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/OCTOPUSE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:32:13 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, IpAddress, Integer32, Bits, Gauge32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, NotificationType, Counter64, TimeTicks, enterprises, Counter32, MibIdentifier, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "IpAddress", "Integer32", "Bits", "Gauge32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "NotificationType", "Counter64", "TimeTicks", "enterprises", "Counter32", "MibIdentifier", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
sni = MibIdentifier((1, 3, 6, 1, 4, 1, 231))
siemensUnits = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7))
pn = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2))
octopusE = ModuleIdentity((1, 3, 6, 1, 4, 1, 231, 7, 2, 9))
if mibBuilder.loadTexts: octopusE.setLastUpdated('24.11.00')
if mibBuilder.loadTexts: octopusE.setOrganization('Siemens Information & Communication Networks')
if mibBuilder.loadTexts: octopusE.setContactInfo(' Technical Support ')
if mibBuilder.loadTexts: octopusE.setDescription('Octopus E MIB.')
octoControlGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1))
octoErrorHistoryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2))
octoSystemInfoGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3))
octoStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4))
octoCdrConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5))
octoTrapSpecifications = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6))
octoNetworkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7))
class DisplayString(OctetString):
    pass

class DateAndTime(TextualConvention, OctetString):
    description = 'A date-time specification identical to rfc 1443 definition. field octets contents range ----- ------ -------- ----- 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minutes 0..59 6 7 seconds 0..60 (use 60 for leap-second) 7 8 deci-seconds 0..9 For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be displayed as: 1992-5-26,13:30:15.0'
    status = 'current'
    displayHint = '2d-1d-1d,1d:1d:1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class ReadWrite(TextualConvention, Integer32):
    description = 'A textual convention for describing objects that enable or disable some sort of write access.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("readWrite", 1), ("readOnly", 2))

octoSysState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoSysState.setStatus('current')
if mibBuilder.loadTexts: octoSysState.setDescription('The actual error state of the Octopus E PABX. Contains the highest severity level of the recent error events. This object is updated automatically, but it can also be modified manually.')
tftpSwitchoverDateTime = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 2), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpSwitchoverDateTime.setStatus('current')
if mibBuilder.loadTexts: tftpSwitchoverDateTime.setDescription('Date and time for the switchover to the new system software. The configured time will be ignored, if the upgrade is started with the downloadAndImmediateSwitchover define of the tftpDownloadAction object. octet format: field octets contents range hex (range dez) ----- ------ -------- --------- ---------- 1 1-2 year 00 00 - FF FF (0 - 65536) 2 3 month 01 - 0C (1 - 12) 3 4 day 01 - 1F (1 - 31) 4 5 hour 00 - 17 (0 - 23) 5 6 minutes 00 - 3B (0 - 59) 6 7 seconds 00 - 3B (0 - 60) 7 8 deci-seconds 00 - 09 (0 - 9) For example, to configure Wednesday June 16, 1999 at 8:30:15 AM would be configured as 07 cf 06 10 08 1E 0F 00')
tftpDownloadAction = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notDownloading", 1), ("downloadAndImmediateSwitchover", 2), ("downloadAndDelayedSwitchover", 3), ("downloadWithoutSwitchover", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpDownloadAction.setStatus('current')
if mibBuilder.loadTexts: tftpDownloadAction.setDescription('When this object is set to downloadAndImmediateSwitchover (2), the device will download the new software from the configured host. After the download is finished, the device will automatically restart with the new software. If downloadAndDelayedSwitchover (3) is specified, the new image is copied to the device. When the tftpDateTime value is matched, the device discontinues its normal operation and does the software switchover. After an automatic reset, it starts with the new system software. Setting downloadWithoutSwitchover (4) initiates a download without switching over to the new software. When the device is not downloading, this object will have a value of notDownloading(1).')
octoResetControl = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("running", 1), ("warmBoot", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoResetControl.setStatus('current')
if mibBuilder.loadTexts: octoResetControl.setDescription('Setting this object to warmBoot(2) causes the device to restart the application software with current configuration parameters saved in non-volatile memory. When the device is running normally, this variable has a value of running(1). The effect of configuring this object is identical to the configuration of the probeResetControl object of RFC 2021, except for the coldBoot option which is not supported.')
octoSwitchoverState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("readyForSwitchover", 1), ("notReadyForSwitchover", 2), ("initSwitchoverNow", 3), ("initSwitchoverDelayed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoSwitchoverState.setStatus('current')
if mibBuilder.loadTexts: octoSwitchoverState.setDescription('The values readyForSwitchover (1) and notReadyForSwitchover (2) indicate whether the system is ready to be switched over to the new software that was downloaded to the shadow flash area, or not. If it is not passible, octoShadowFlashState gives details on the reason. Setting this object to switchoverNow (3) causes the device to switchover immediately to the new software which was downloaded to the shadow flash area before and restart the system. initSwitchoverDelayed(4) causes a delayed switchover.')
octoShadowFlashState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("flashDeleted", 1), ("flashNotDeleted", 2), ("flashWriteProtected", 3), ("flashTooSmall", 4), ("deleteFlashNow", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoShadowFlashState.setStatus('current')
if mibBuilder.loadTexts: octoShadowFlashState.setDescription("This object informs about the state of the shadow flash memory area which is used to buffer a new software image that is being downloaded to the system. A download is only possible when the state is flashDeleted (1). It is not possible to download if the state is flashNotDeleted(2), nor if it's flashWriteProtected(3) (this means it is internally locked by software because the system is not in the state of accepting new flash data). If the flash memory is smaller than 8 MB ( flashTooSmall(4) ), no transfer is possible, too. It is possible to delete an inactive software image from the shadow flash area by setting deleteFlashNow (5).")
octoLoadLevel = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoLoadLevel.setStatus('current')
if mibBuilder.loadTexts: octoLoadLevel.setDescription('The actual CPU load level (per cent).')
octoTrapRepetitions = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoTrapRepetitions.setStatus('current')
if mibBuilder.loadTexts: octoTrapRepetitions.setDescription('The number of trap repetitions for error events marked as very important (log-and-multiple-trap).')
octoCdrBufferState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accounting", 1), ("deleteBufferNow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrBufferState.setStatus('current')
if mibBuilder.loadTexts: octoCdrBufferState.setDescription('Use this object to delete the CDR buffer.')
octoLogBufferState = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("logging", 1), ("deleteBufferNow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoLogBufferState.setStatus('current')
if mibBuilder.loadTexts: octoLogBufferState.setDescription('Use this object to delete the log data.')
numberOfErrorHistoryEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numberOfErrorHistoryEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfErrorHistoryEntries.setDescription('Contains the number of errors to be found in the error history table. This value can be used to delete the last x entries (reduce value by x) or to delete all entries (value = 0).')
octoErrorHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2), )
if mibBuilder.loadTexts: octoErrorHistoryTable.setStatus('current')
if mibBuilder.loadTexts: octoErrorHistoryTable.setDescription('This table contains information about the errors that occured.')
octoErrorHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1), ).setIndexNames((0, "OCTOPUSE-MIB", "octoErrorIndex"))
if mibBuilder.loadTexts: octoErrorHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: octoErrorHistoryEntry.setDescription('The trap history table entries.')
octoErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoErrorIndex.setStatus('current')
if mibBuilder.loadTexts: octoErrorIndex.setDescription('Identification of an table entry enabled by this index.')
octoErrorDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoErrorDateTime.setStatus('current')
if mibBuilder.loadTexts: octoErrorDateTime.setDescription('Time, when the error occurred.')
octoErrorClass = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoErrorClass.setStatus('current')
if mibBuilder.loadTexts: octoErrorClass.setDescription('Contains the error class number (type of trap).')
octoErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoErrorCode.setStatus('current')
if mibBuilder.loadTexts: octoErrorCode.setDescription('Contains the error code.')
octoAccessSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoAccessSlot.setStatus('current')
if mibBuilder.loadTexts: octoAccessSlot.setDescription('Contains the access slot for the error.')
octoAccessPort = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoAccessPort.setStatus('current')
if mibBuilder.loadTexts: octoAccessPort.setDescription('Contains the local access port of the error. Local means that port numbering starts with 0 for each card.')
octoErrorDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoErrorDescription.setStatus('current')
if mibBuilder.loadTexts: octoErrorDescription.setDescription('Detailed information about errors.')
octoErrorSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoErrorSeverity.setStatus('current')
if mibBuilder.loadTexts: octoErrorSeverity.setDescription('Contains the severity of the specific error.')
sysHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysHardwareVersion.setDescription('Contains the version string of the system hardware.')
sysSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysSoftwareVersion.setDescription('Contains the version string of the system software.')
sysCodeNumber = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCodeNumber.setStatus('current')
if mibBuilder.loadTexts: sysCodeNumber.setDescription('Contains the code number of the system software.')
sysSoftwareLocation = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lower", 1), ("upper", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSoftwareLocation.setStatus('current')
if mibBuilder.loadTexts: sysSoftwareLocation.setDescription('Contains location (address space) where the system software is currently running.')
numberOfSlotTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfSlotTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfSlotTableEntries.setDescription('Contains the number of entries in the slot table.')
octoSlotTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6), )
if mibBuilder.loadTexts: octoSlotTable.setStatus('current')
if mibBuilder.loadTexts: octoSlotTable.setDescription('This table contains information about the system slots.')
octoSlotTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1), ).setIndexNames((0, "OCTOPUSE-MIB", "cardIndex"))
if mibBuilder.loadTexts: octoSlotTableEntry.setStatus('current')
if mibBuilder.loadTexts: octoSlotTableEntry.setDescription('The slot table entries.')
cardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardIndex.setStatus('current')
if mibBuilder.loadTexts: cardIndex.setDescription('Identification of an table entry enabled by this index.')
cardBoxNum = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBoxNum.setStatus('current')
if mibBuilder.loadTexts: cardBoxNum.setDescription('Index of the box where the card is placed.')
cardSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardSlotNum.setStatus('current')
if mibBuilder.loadTexts: cardSlotNum.setDescription('Index of the slot where the card is placed.')
cardType = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardType.setStatus('current')
if mibBuilder.loadTexts: cardType.setDescription('Code for the type of the card.')
cardDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardDescription.setStatus('current')
if mibBuilder.loadTexts: cardDescription.setDescription('Textual card description.')
cardCodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardCodeNumber.setStatus('current')
if mibBuilder.loadTexts: cardCodeNumber.setDescription('Contains the code number of the card software.')
cardState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("minor", 3), ("major", 4), ("critical", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardState.setStatus('current')
if mibBuilder.loadTexts: cardState.setDescription('Contains the state of the card.')
numberOfPortTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfPortTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfPortTableEntries.setDescription('Contains the number of entries in the port table.')
octoPortTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8), )
if mibBuilder.loadTexts: octoPortTable.setStatus('current')
if mibBuilder.loadTexts: octoPortTable.setDescription('This table contains information about the system ports.')
octoPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1), ).setIndexNames((0, "OCTOPUSE-MIB", "portIndex"))
if mibBuilder.loadTexts: octoPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: octoPortTableEntry.setDescription('The port table entries.')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('current')
if mibBuilder.loadTexts: portIndex.setDescription('Identification of an table entry enabled by this index.')
portCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCardIndex.setStatus('current')
if mibBuilder.loadTexts: portCardIndex.setDescription('Reference to the card the port is assigned to.')
portType = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portType.setStatus('current')
if mibBuilder.loadTexts: portType.setDescription('Contains the type of the port.')
portState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portState.setStatus('current')
if mibBuilder.loadTexts: portState.setDescription('Contains the general state of the port.')
portLock = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unlocked", 1), ("lockedBySoftware", 2), ("lockedByHardware", 3), ("lockedBySoftAndHardware", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLock.setStatus('current')
if mibBuilder.loadTexts: portLock.setDescription('This object contains the lock state of the port. A software lock can be enabled / disabled. Possible state transitions: unlocked -> lockedBySoftware lockedByHardware -> lockedBySoftAndHardware lockedBySoftware -> unlocked lockedBySoftAndHardware -> lockedByHardware')
numberOfExtensionTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfExtensionTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfExtensionTableEntries.setDescription('Contains the number of entries in the hardware extension table.')
octoExtensionTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10), )
if mibBuilder.loadTexts: octoExtensionTable.setStatus('current')
if mibBuilder.loadTexts: octoExtensionTable.setDescription('This table contains information about the hardware extensions.')
octoExtensionTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10, 1), ).setIndexNames((0, "OCTOPUSE-MIB", "extensionIndex"))
if mibBuilder.loadTexts: octoExtensionTableEntry.setStatus('current')
if mibBuilder.loadTexts: octoExtensionTableEntry.setDescription('The extension table entries.')
extensionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extensionIndex.setStatus('current')
if mibBuilder.loadTexts: extensionIndex.setDescription('Identification of an table entry enabled by this index.')
extensionDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extensionDescription.setStatus('current')
if mibBuilder.loadTexts: extensionDescription.setDescription('Contains a textual desription of the hardware extension.')
extensionCodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extensionCodeNumber.setStatus('current')
if mibBuilder.loadTexts: extensionCodeNumber.setDescription('Contains the code number of the hardware extension.')
numberOfLanConnTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfLanConnTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfLanConnTableEntries.setDescription('Contains the number of entries in the LAN connection table.')
octoLanConnTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12), )
if mibBuilder.loadTexts: octoLanConnTable.setStatus('current')
if mibBuilder.loadTexts: octoLanConnTable.setDescription('This table contains information about the interfaces available for LAN access of the device or its cards.')
octoLanConnTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1), ).setIndexNames((0, "OCTOPUSE-MIB", "lanConnIndex"))
if mibBuilder.loadTexts: octoLanConnTableEntry.setStatus('current')
if mibBuilder.loadTexts: octoLanConnTableEntry.setDescription('The LAN connection table entries.')
lanConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnIndex.setStatus('current')
if mibBuilder.loadTexts: lanConnIndex.setDescription('Identification of an table entry enabled by this index.')
lanConnDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnDescription.setStatus('current')
if mibBuilder.loadTexts: lanConnDescription.setDescription('Textual desription on the LAN connection.')
lanConnIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnIpAddress.setStatus('current')
if mibBuilder.loadTexts: lanConnIpAddress.setDescription('IP address of the LAN connection.')
lanConnSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnSubnetMask.setStatus('current')
if mibBuilder.loadTexts: lanConnSubnetMask.setDescription('Subnet mask of the LAN connection.')
lanConnStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lanConnStatus.setStatus('current')
if mibBuilder.loadTexts: lanConnStatus.setDescription('Status of the LAN Connection.')
hiPathAllServeServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hiPathAllServeServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: hiPathAllServeServerIpAddress.setDescription('IP address of the HiPath AllServe (Venus) server.')
indexOfLastPortStatusNotificationTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: indexOfLastPortStatusNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: indexOfLastPortStatusNotificationTrap.setDescription("Index of last 'port status change' notification trap sent by the device. Note: only reset possible (0)")
sysSnmpAgentVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 3, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSnmpAgentVersion.setStatus('current')
if mibBuilder.loadTexts: sysSnmpAgentVersion.setDescription('Version number of the systems SNMP agent (formatting: x.y.z.)')
numberOfFeatureStatTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: numberOfFeatureStatTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfFeatureStatTableEntries.setDescription('Contains the number of feature counters to be found in the table.')
octoFeatureStatTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2), )
if mibBuilder.loadTexts: octoFeatureStatTable.setStatus('current')
if mibBuilder.loadTexts: octoFeatureStatTable.setDescription('This table contains information about the usage of specific system features. It is designed to monitor the use of these features for a limited time only, because each counter is limited to one byte.')
octoFeatureStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2, 1), ).setIndexNames((0, "OCTOPUSE-MIB", "featureIndex"))
if mibBuilder.loadTexts: octoFeatureStatEntry.setStatus('current')
if mibBuilder.loadTexts: octoFeatureStatEntry.setDescription('The feature statistics table entries.')
featureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: featureIndex.setStatus('current')
if mibBuilder.loadTexts: featureIndex.setDescription('Identification of an table entry enabled by this index.')
featureDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: featureDescription.setStatus('current')
if mibBuilder.loadTexts: featureDescription.setDescription('Description of the feature.')
featureCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: featureCounter.setStatus('current')
if mibBuilder.loadTexts: featureCounter.setDescription('This Counter indicates how often the feature was used since last system reload')
featureStatTableReset = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("counting", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: featureStatTableReset.setStatus('current')
if mibBuilder.loadTexts: featureStatTableReset.setDescription('Enables reset (2) of all counters of the featureStatTable.')
octoCdrSeparator = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dosMode", 1), ("unixMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrSeparator.setStatus('current')
if mibBuilder.loadTexts: octoCdrSeparator.setDescription('Separator between following CDRs: DOS mode (1): CRLF UNIX mode (2): LF')
octoCdrElementSeparator = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(124, 59, 32))).clone(namedValues=NamedValues(("pipe", 124), ("semicolon", 59), ("blank", 32)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrElementSeparator.setStatus('current')
if mibBuilder.loadTexts: octoCdrElementSeparator.setDescription("Separator between the different elements of one CDR: pipe (0x7c): '|' semicolon (0x3b): ';' blank (0x20): ' ' NOTE: no write access for blank")
octoCdrThresholdValue = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrThresholdValue.setStatus('current')
if mibBuilder.loadTexts: octoCdrThresholdValue.setDescription('CDR buffer limit (only relevant for TFTP server mode): threshold value (in percent) for sending a CDR data notification trap recommended values: 0 to 80')
octoCdrTftpFileCounter = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrTftpFileCounter.setStatus('current')
if mibBuilder.loadTexts: octoCdrTftpFileCounter.setDescription(" CDR <FileCounter> (only relevant for TFTP client mode): For each transferred CDR-file a new filename is necassary filename: 'GDS<IPAdr>.c<FileCounter>'")
octoCdrTftpServerDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrTftpServerDestAddress.setStatus('current')
if mibBuilder.loadTexts: octoCdrTftpServerDestAddress.setDescription('Destination IP addresse of CDR TFTP server (only relevant for TFTP client mode)')
octoCdrTftpServerAlternateDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrTftpServerAlternateDestAddress.setStatus('current')
if mibBuilder.loadTexts: octoCdrTftpServerAlternateDestAddress.setDescription('Alternate destination IP addresse of CDR TFTP server (only relevant for TFTP client mode): is the CDR TFTP Server not reachable the switch transfers CDR data to this alternative server')
octoCdrTftpClientTimer = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrTftpClientTimer.setStatus('current')
if mibBuilder.loadTexts: octoCdrTftpClientTimer.setDescription('cycle time in minutes for initiating CDR output, max value 1439 minutes (23hours,59minutes) (only relevant for TFTP client mode)')
octoCdrTcpServerDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrTcpServerDestAddress.setStatus('current')
if mibBuilder.loadTexts: octoCdrTcpServerDestAddress.setDescription('Destination IP addresse of CDR TCP server (only relevant for TCP client mode)')
octoCdrTcpServerDestPort = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrTcpServerDestPort.setStatus('current')
if mibBuilder.loadTexts: octoCdrTcpServerDestPort.setDescription('Destination TCP port of CDR TCP server (only relevant for TCP client mode)')
octoCdrOutputMode = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("v24port", 1), ("uPNport", 2), ("pCVPLport", 3), ("tftpClient", 4), ("tftpServer", 5), ("tcpClient", 6), ("noOutput", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoCdrOutputMode.setStatus('current')
if mibBuilder.loadTexts: octoCdrOutputMode.setDescription('CDR (Call Detailed Record) output mode: V24-Port (1): the device is permanently connected over a V.24 connection to an extern application and sends each CDR immidiatly NOTE: no write access UPN-Port (2): the device is permanently connected over terminal adapter (PPM) connection to an extern application and sends each CDR immidiatly NOTE: no write access PCVPL-Port (3): the device is permanently connected over a CorNet TS connection to an extern application (PCVPL) and sends each CDR immidiatly NOTE: no write access TFTP-Client (4): the device sends the collected CDRs to the administrated TFTP-Server TFTP-Server (5): an extern TFTP client can request the collected CDRs TCP-Client (6): the device is permanently connected to an extern TCP server and sends each CDR immidiatly NoOutput (7): no output for CDR')
octoIndexOfLastCdrNotificationTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: octoIndexOfLastCdrNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: octoIndexOfLastCdrNotificationTrap.setDescription('Index of last CDR notification trap sent by the device Note: only reset possible (0)')
octoTypeOfLastCdrNotificationTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoTypeOfLastCdrNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: octoTypeOfLastCdrNotificationTrap.setDescription('Type of last CDR notification trap sent by the device: (1) : error - CDR buffer overflow (2) : warning - CDR buffer is filled up over 80% (3) : notification - administrateable CDR buffer threshold is reached -> extern TFTP client has to get the collected CDRs (4) : warning - TCP Client couldnt reach administrated server (5) : warning - TFTP Client couldnt reach administrated server (6) : warning - TFTP Client couldnt reach administrated alternative server')
octoDescriptionOfLastCdrNotificationTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 5, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: octoDescriptionOfLastCdrNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: octoDescriptionOfLastCdrNotificationTrap.setDescription('Textual description of last CDR notification trap sent by the device')
sendAlarm = NotificationType((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6, 1)).setObjects(("OCTOPUSE-MIB", "octoErrorIndex"), ("OCTOPUSE-MIB", "octoErrorDateTime"), ("OCTOPUSE-MIB", "octoErrorClass"), ("OCTOPUSE-MIB", "octoErrorCode"), ("OCTOPUSE-MIB", "octoAccessSlot"), ("OCTOPUSE-MIB", "octoAccessPort"), ("OCTOPUSE-MIB", "octoErrorDescription"), ("OCTOPUSE-MIB", "octoSysState"), ("OCTOPUSE-MIB", "octoErrorSeverity"))
if mibBuilder.loadTexts: sendAlarm.setStatus('current')
if mibBuilder.loadTexts: sendAlarm.setDescription('If an error occurs, there will be checked if the errorClass is configured to trigger an immediate signalling. If so, a trap will be send to the management station containing the information shown above.')
sendCdrNotification = NotificationType((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6, 2)).setObjects(("OCTOPUSE-MIB", "octoIndexOfLastCdrNotificationTrap"), ("OCTOPUSE-MIB", "octoTypeOfLastCdrNotificationTrap"), ("OCTOPUSE-MIB", "octoDescriptionOfLastCdrNotificationTrap"))
if mibBuilder.loadTexts: sendCdrNotification.setStatus('current')
if mibBuilder.loadTexts: sendCdrNotification.setDescription('The CDR notification trap is sent to trigger further actions by the management station, for instance download of CDR data.')
sendPortStatusNotification = NotificationType((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 6, 3)).setObjects(("OCTOPUSE-MIB", "indexOfLastPortStatusNotificationTrap"))
if mibBuilder.loadTexts: sendPortStatusNotification.setStatus('current')
if mibBuilder.loadTexts: sendPortStatusNotification.setDescription("The 'port status change' notification trap is sent to trigger a polling of the port table by a management station. It indicates one or more changes in port states.")
numberOfIpConnControlTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numberOfIpConnControlTableEntries.setStatus('current')
if mibBuilder.loadTexts: numberOfIpConnControlTableEntries.setDescription('Contains the number of ip connection control entries to be found in the table. Set this value to 0 to remove all connection control entries.')
ipConnControlTable = MibTable((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2), )
if mibBuilder.loadTexts: ipConnControlTable.setStatus('current')
if mibBuilder.loadTexts: ipConnControlTable.setDescription("This table can be used to control manual or automatic (periodical) checks of important ip connections from the device to a limited number of ip counterparts using the feature 'local ping'. It also contains the result of this connection control service.")
ipConnControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2, 1), ).setIndexNames((0, "OCTOPUSE-MIB", "connControlIndex"))
if mibBuilder.loadTexts: ipConnControlEntry.setStatus('current')
if mibBuilder.loadTexts: ipConnControlEntry.setDescription('The ip connection control table entries.')
connControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connControlIndex.setStatus('current')
if mibBuilder.loadTexts: connControlIndex.setDescription('Identification of an table entry enabled by this index.')
connPartnerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connPartnerIpAddress.setStatus('current')
if mibBuilder.loadTexts: connPartnerIpAddress.setDescription('This is a partner ip address of a ip connection to be supervised.')
connTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connTimeout.setStatus('current')
if mibBuilder.loadTexts: connTimeout.setDescription("Timeout (in ms) for the 'local ping' mechanism which is used to supervise ip connections.")
connRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connRetries.setStatus('current')
if mibBuilder.loadTexts: connRetries.setDescription("Number of retries for the 'local ping' mechanism which is used to supervise ip connections.")
connRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483187))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connRetryTimer.setStatus('current')
if mibBuilder.loadTexts: connRetryTimer.setDescription("Retry timer (in ms) for the 'local ping' mechanism which is used to supervise ip connections.")
connResult = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disconnected", 1), ("connected", 2), ("notActivated", 3), ("activated", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connResult.setStatus('current')
if mibBuilder.loadTexts: connResult.setDescription("The result of the supervision of the given ip connection. disonnected vs. connected is the result of the last check, if supervision has been started. not_activated means that the supervision has not been started. The result is activated, if the check has started, but there's no result yet.")
connControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 7, 2, 9, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("singleTest", 1), ("periodicalTest", 2), ("noTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: connControlState.setStatus('current')
if mibBuilder.loadTexts: connControlState.setDescription('This object is used to start/stop the supervision of ip connections.')
mibBuilder.exportSymbols("OCTOPUSE-MIB", ipConnControlEntry=ipConnControlEntry, octoCdrBufferState=octoCdrBufferState, numberOfExtensionTableEntries=numberOfExtensionTableEntries, sendAlarm=sendAlarm, portLock=portLock, numberOfLanConnTableEntries=numberOfLanConnTableEntries, connResult=connResult, ReadWrite=ReadWrite, cardIndex=cardIndex, octoCdrTftpServerAlternateDestAddress=octoCdrTftpServerAlternateDestAddress, tftpDownloadAction=tftpDownloadAction, octoPortTable=octoPortTable, octoCdrTftpClientTimer=octoCdrTftpClientTimer, octoStatisticsGroup=octoStatisticsGroup, octoErrorCode=octoErrorCode, octoErrorHistoryGroup=octoErrorHistoryGroup, cardState=cardState, octoShadowFlashState=octoShadowFlashState, featureDescription=featureDescription, octoTrapRepetitions=octoTrapRepetitions, DateAndTime=DateAndTime, octoAccessSlot=octoAccessSlot, octoFeatureStatEntry=octoFeatureStatEntry, connControlState=connControlState, connTimeout=connTimeout, lanConnStatus=lanConnStatus, portCardIndex=portCardIndex, octoExtensionTable=octoExtensionTable, numberOfFeatureStatTableEntries=numberOfFeatureStatTableEntries, octoCdrConfigGroup=octoCdrConfigGroup, cardType=cardType, PYSNMP_MODULE_ID=octopusE, numberOfIpConnControlTableEntries=numberOfIpConnControlTableEntries, octoErrorSeverity=octoErrorSeverity, siemensUnits=siemensUnits, sysHardwareVersion=sysHardwareVersion, octoCdrTftpServerDestAddress=octoCdrTftpServerDestAddress, hiPathAllServeServerIpAddress=hiPathAllServeServerIpAddress, extensionIndex=extensionIndex, portType=portType, ipConnControlTable=ipConnControlTable, octoFeatureStatTable=octoFeatureStatTable, octoLanConnTable=octoLanConnTable, extensionDescription=extensionDescription, octoSysState=octoSysState, octoDescriptionOfLastCdrNotificationTrap=octoDescriptionOfLastCdrNotificationTrap, octoLoadLevel=octoLoadLevel, octoErrorDateTime=octoErrorDateTime, connRetries=connRetries, octoErrorHistoryEntry=octoErrorHistoryEntry, octoLogBufferState=octoLogBufferState, octoCdrThresholdValue=octoCdrThresholdValue, octoSlotTableEntry=octoSlotTableEntry, octoLanConnTableEntry=octoLanConnTableEntry, octoAccessPort=octoAccessPort, cardCodeNumber=cardCodeNumber, featureStatTableReset=featureStatTableReset, lanConnSubnetMask=lanConnSubnetMask, octoTrapSpecifications=octoTrapSpecifications, octoSwitchoverState=octoSwitchoverState, featureCounter=featureCounter, extensionCodeNumber=extensionCodeNumber, numberOfSlotTableEntries=numberOfSlotTableEntries, octoCdrElementSeparator=octoCdrElementSeparator, octoCdrTcpServerDestAddress=octoCdrTcpServerDestAddress, connPartnerIpAddress=connPartnerIpAddress, sysSoftwareLocation=sysSoftwareLocation, connControlIndex=connControlIndex, featureIndex=featureIndex, pn=pn, octoErrorIndex=octoErrorIndex, portState=portState, octoCdrOutputMode=octoCdrOutputMode, sysCodeNumber=sysCodeNumber, indexOfLastPortStatusNotificationTrap=indexOfLastPortStatusNotificationTrap, lanConnDescription=lanConnDescription, tftpSwitchoverDateTime=tftpSwitchoverDateTime, lanConnIpAddress=lanConnIpAddress, sysSnmpAgentVersion=sysSnmpAgentVersion, octoControlGroup=octoControlGroup, octoCdrTftpFileCounter=octoCdrTftpFileCounter, cardDescription=cardDescription, octoIndexOfLastCdrNotificationTrap=octoIndexOfLastCdrNotificationTrap, numberOfErrorHistoryEntries=numberOfErrorHistoryEntries, portIndex=portIndex, cardBoxNum=cardBoxNum, octoSlotTable=octoSlotTable, octoExtensionTableEntry=octoExtensionTableEntry, octoTypeOfLastCdrNotificationTrap=octoTypeOfLastCdrNotificationTrap, sendCdrNotification=sendCdrNotification, octoSystemInfoGroup=octoSystemInfoGroup, octoCdrTcpServerDestPort=octoCdrTcpServerDestPort, cardSlotNum=cardSlotNum, octoCdrSeparator=octoCdrSeparator, octoResetControl=octoResetControl, sysSoftwareVersion=sysSoftwareVersion, DisplayString=DisplayString, sni=sni, octopusE=octopusE, sendPortStatusNotification=sendPortStatusNotification, octoErrorClass=octoErrorClass, octoErrorDescription=octoErrorDescription, octoPortTableEntry=octoPortTableEntry, lanConnIndex=lanConnIndex, octoErrorHistoryTable=octoErrorHistoryTable, numberOfPortTableEntries=numberOfPortTableEntries, connRetryTimer=connRetryTimer, octoNetworkGroup=octoNetworkGroup)

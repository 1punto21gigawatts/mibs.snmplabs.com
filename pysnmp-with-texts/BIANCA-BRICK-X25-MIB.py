#
# PySNMP MIB module BIANCA-BRICK-X25-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BRICK-X25-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:38:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Counter32, ModuleIdentity, MibIdentifier, NotificationType, Integer32, Counter64, ObjectIdentity, IpAddress, iso, Gauge32, Unsigned32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Counter32", "ModuleIdentity", "MibIdentifier", "NotificationType", "Integer32", "Counter64", "ObjectIdentity", "IpAddress", "iso", "Gauge32", "Unsigned32", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
x25 = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 6))
class HexValue(Integer32):
    pass

class Date(Integer32):
    pass

x25LinkTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 6, 1), )
if mibBuilder.loadTexts: x25LinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25LinkTable.setDescription('This table contains an entry for each active link. There may be mutiple active links per interface. For point-to- multipoint interfaces, the field x25LkAddr specifies the (MAC-) address of the partner, the link leads to. There may be also multiple links for a point-to-point interface in a multilink environment without a multilink- protocol joining the multiple links to a singe logical link.')
x25LinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1), ).setIndexNames((0, "BIANCA-BRICK-X25-MIB", "x25LkIfIndex"))
if mibBuilder.loadTexts: x25LinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25LinkEntry.setDescription('The x25LinkEntry is created automatically, when a link becomes active. The entry is also removed automatically, if a link becomes disconnected. It may be removed manually by setting the field x25LinkState to delete, which causes the related link to be disconnected.')
x25LkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkIfIndex.setDescription('The index of the interface the link is running on. See ifTable.')
x25LkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkAddr.setDescription('On point-to-multipoint interfaces, this field contains the (MAC-)address of the partner, the link is leading to. It is empty for point-to-point interfaces, because there is only one partner at the other side.')
x25LkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkMode.setDescription('This field indicates wheter the Layer 3 on top of the link is operated in DTE or DCE mode. The difference is in the order of VC-assignment, the handling of a call collision and the range of allowed values of the cause field.')
x25LkModulo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mod8", 1), ("mod128", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkModulo.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkModulo.setDescription('This field indicates whether the layer 3 on top of the link is in modulo 8 or in modulo 128 mode.')
x25LkLIC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkLIC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkLIC.setDescription('Lowest Incoming Channel as seen from the DTE. Zero means no incoming channels.')
x25LkHIC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkHIC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkHIC.setDescription('Highest Incoming Channel as seen from the DTE. Zero means no incoming channels.')
x25LkLTC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkLTC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkLTC.setDescription('Lowest Twoway Channel as seen from the DTE. Zero means no twoway channels.')
x25LkHTC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkHTC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkHTC.setDescription('Highest Twoway Channel as seen from the DTE. Zero means no twoway channels.')
x25LkLOC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkLOC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkLOC.setDescription('Lowest Outgoing Channel as seen from the DTE. Zero means no outgoing channels.')
x25LkHOC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkHOC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkHOC.setDescription('Highest Outgoing Channel as seen from the DTE. Zero means no outgoing channels.')
x25LkDefPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkDefPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkDefPktSize.setDescription('The default layer 3 packet size for this link.')
x25LkDefWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkDefWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkDefWinSize.setDescription('The default window size. This is always less than 8, if the layer 3 is operated in modulo 8 mode.')
x25LkMaxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unrestricted", 1), ("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkMaxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkMaxPktSize.setDescription('The maximum allowable packet size for this link during X.25 packet size negotiation. If this field is set to unrestricted, the packet size will only be limited by the Mtu size of the interface, which is always the upper bound for the packet size.')
x25LkMaxWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkMaxWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkMaxWinSize.setDescription('The maximum allowable window size for this link during window size negotiation.')
x25LkL2WinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkL2WinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkL2WinSize.setDescription('The layer 2 window size for this link.')
x25LkL2RetrTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkL2RetrTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkL2RetrTimer.setDescription('The retransmission timeout in milliseconds for the layer 2 of this link. If a frame is not acknowledged within this timeout, it will be retransmitted.')
x25LkL2RetrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkL2RetrCounter.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkL2RetrCounter.setDescription('The retransmission counter for the layer 2 of this link. If a frame has been retransmitted more often than indicated by this object, the link will be reset or disconnected,')
x25LkL2SupervTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkL2SupervTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkL2SupervTimer.setDescription('The link-supervision timeout in milliseconds for the layer 2 of this link. This timer is started, when the link gets idle. An RR poll-sequence will be initiated, when this timeout expires.')
x25LkL2IdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 30000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkL2IdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkL2IdleTimer.setDescription('The idle timer in milliseconds for the layer 2 of this link. If no VCs are established and the the link has been idle for the time specified by this object, the link will be disconnected. The value 0 means, the link should not be disconnected after the last VC has been cleared. A value of -1 means, that the link shall be kept up even if it get disconnected from the partner on the other end.')
x25LkState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("restart-pending", 1), ("restart-collision", 2), ("ready", 3), ("disc-pending", 4), ("reset-pending", 5), ("sabm-pending", 6), ("xid-pending", 7), ("sabm-wait", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkState.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkState.setDescription('This object contains the current state of the link. The link may be manually disconnected by setting this object to the value delete.')
x25LkNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("when-necessary", 1), ("always", 2), ("never", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkNegotiation.setDescription('This object determines whether packet-size and windows-size parameters are negotiated for outgoing calls. When set to never, outgoing calls are cleared if the call parameters differ from the default-settings. When set to when-necessary, negotiation is only performed if the call parameters differ from the default settings. When set to always, negotiation is always performed.')
x25LkDiscDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkDiscDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkDiscDelayTimer.setDescription('The disc delay timer in milliseconds for the layer 2 of this link (only outgoing links). This timer specifies the time interval between receiving of layer 2 disconnect and actual disconnect of link. If the partner want to disconnect the layer 2 and the time specified by this object expired, the link will be disconnected. The value 0 means, the link will be disconnected immediately after receiving of disconnect.')
x25LkCallDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkCallDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkCallDelayTimer.setDescription('The call delay timer in milliseconds for the layer 3 of this link (only outgoing link). This timer specifies the time interval between restart procedure completion and virtual call setup. If restart procedure is completed and the time specified by this object expired, call packet will be sent. The value 0 means, call packet should be sent immediately after completion of restart procedure.')
x25LkRestDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LkRestDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkRestDelayTimer.setDescription('The Restart delay timer in milliseconds for this link. This timer specifies the time interval between establishment of layer 2 and sending of restart packet. If layer 2 is established and the time specified by this object expired, restart packet will be sent. The value 0 means, restart packet should be sent immediately after establishment of layer 2.')
x25LinkPresetTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 6, 2), )
if mibBuilder.loadTexts: x25LinkPresetTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25LinkPresetTable.setDescription('This table predefines the link-parameters to be used, when a link is created. If no entry is contained in this table for a particular link, it will be setup with the default values. In any case, the parameters finally choosen for a link are displayed in the x25LinkTable. For point-to-multipoint interfaces, the parameters for the link may be set for all connected partners (x25LkPrAddr is empty) of for the specific partners individually (x25LkPrAddr is the MAC-address of the partner).')
x25LinkPresetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1), ).setIndexNames((0, "BIANCA-BRICK-X25-MIB", "x25LkPrIfIndex"))
if mibBuilder.loadTexts: x25LinkPresetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25LinkPresetEntry.setDescription('Entries in this table are created by defining a new value for the field x25LkPrIfIndex. Entries may be deleted by setting the field x25LkPrMode to the value delete. Please note, that changing the entries dont have influence on links being already established. To take effekt the according links have to be cleared either manually (see x25LinkTable) or by other means.')
x25LkPrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrIfIndex.setDescription('The interface index of the link to be predefined. This object identifies a row in the ifTable.')
x25LkPrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrAddr.setDescription('On point-to-point links, this field must be empty. On point-to-multipoint links, this field may be empty or set to a partners (MAC-) address. In the first case, the definition is valid for all links on the interface except for those having a specific predefiniton. In the second case the definition defines the link parameters for a specific partner.')
x25LkPrMode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrMode.setDescription('This field indicates, whether the link is initially operated in DTE or DCE mode. If a misconfiguration is detected, (DTE<->DTE od DCE<->DCE) the DTE/DCE assignement is done be means of the procedure defined in ISOxxxx.')
x25LkPrModulo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mod8", 1), ("mod128", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrModulo.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrModulo.setDescription('This object indicates, whether the link should be operated in modulo 8 or modulo 128 mode.')
x25LkPrLIC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrLIC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrLIC.setDescription('Lowest Incoming Channel as seen from the DTE. Zero means no incoming channels.')
x25LkPrHIC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrHIC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrHIC.setDescription('Highest Incoming Channel as seen from the DTE. Zero means no incoming channels.')
x25LkPrLTC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrLTC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrLTC.setDescription('Lowest Twoway Channel as seen from the DTE. Zero means no twoway channels.')
x25LkPrHTC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrHTC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrHTC.setDescription('Highest Twoway Channel as seen from the DTE. Zero means no twoway channels.')
x25LkPrLOC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrLOC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrLOC.setDescription('Lowest Outgoing Channel as seen from the DTE. Zero means no outgoing channels.')
x25LkPrHOC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrHOC.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrHOC.setDescription('Highest Outgoing Channel as seen from the DTE. Zero means no outgoing channels.')
x25LkPrDefPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrDefPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrDefPktSize.setDescription('The Layer 3 packet size for this link.')
x25LkPrDefWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrDefWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrDefWinSize.setDescription('The default window size. This must be less than 8, if the layer 3 is operated in modulo 8 mode.')
x25LkPrMaxPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unrestricted", 1), ("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrMaxPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrMaxPktSize.setDescription('The maximum allowable packet size for this link during X.25 packet size negotiation. If this field is set to unrestricted, the packet size will only be limited by the Mtu size of the interface, which is always the upper bound for the packet size.')
x25LkPrMaxWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrMaxWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrMaxWinSize.setDescription('The maximum allowable window size for this link during window size negotiation.')
x25LkPrL2WinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrL2WinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrL2WinSize.setDescription('The layer 2 window size for this link.')
x25LkPrL2RetrTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrL2RetrTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrL2RetrTimer.setDescription('The retransmission timeout in milliseconds for the layer 2 of this link. If a frame is not acknowledged within this timeout, it will be retransmitted.')
x25LkPrL2RetrCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrL2RetrCounter.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrL2RetrCounter.setDescription('The retransmission counter for the layer 2 of this link. If a frame has been retransmitted more often than indicated by this object, the link will be reset or disconnected.')
x25LkPrL2SupervTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 30000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrL2SupervTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrL2SupervTimer.setDescription('The link-supervision timeout in milliseconds for the layer 2 of this link. This timer is started, when the link gets idle. An RR poll-sequence will be initiated, when this timeout expires.')
x25LkPrL2IdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 30000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrL2IdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrL2IdleTimer.setDescription('The idle timer in milliseconds for the layer 2 of this link. If no VCs are established and the the link has been idle for the time specified by this object, the link will be disconnected. The value 0 means, the link should not be disconnected after the last VC has been cleared. A value of -1 means, that the link shall be kept up even if it get disconnected from the partner on the other end.')
x25LkPrNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("when-necessary", 1), ("always", 2), ("never", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrNegotiation.setDescription('This object determines whether packet-size and windows-size parameters are negotiated for outgoing calls. When set to never, outgoing calls are cleared if the call parameters differ from the default-settings. When set to when-necessary, negotiation is only performed if the call parameters differ from the default settings. When set to always, negotiation is always performed.')
x25LkPrDiscDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrDiscDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrDiscDelayTimer.setDescription('The disc delay timer in milliseconds for the layer 2 of this link (only outgoing links). This timer specifies the time interval between receiving of layer 2 disconnect and actual disconnect of link. If the partner want to disconnect the layer 2 and the time specified by this object expired, the link will be disconnected. The value 0 means, the link will be disconnected immediately after receiving of disconnect.')
x25LkPrCallDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrCallDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrCallDelayTimer.setDescription('The call delay timer in milliseconds for the layer 3 of this link (only outgoing link). This timer specifies the time interval between restart procedure completion and virtual call setup. If restart procedure is completed and the time specified by this object expired, call packet will be sent. The value 0 means, call packet should be sent immediately after completion of restart procedure.')
x25LkPrRestDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LkPrRestDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25LkPrRestDelayTimer.setDescription('The Restart delay timer in milliseconds for this link. This timer specifies the time interval between establishment of layer 2 and sending of restart packet. If layer 2 is established and the time specified by this object expired, restart packet will be sent. The value 0 means, restart packet should be sent immediately after establishment of layer 2.')
x25CallTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 6, 3), )
if mibBuilder.loadTexts: x25CallTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallTable.setDescription('This table contains an entry for each active X25-call. Calls always lead from a source-link to a destination-link. An interface index of 1 denotates a pseudo interfaces corresponding to all locally terminated calls.')
x25CallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1), ).setIndexNames((0, "BIANCA-BRICK-X25-MIB", "x25CallSrcIfIndex"), (0, "BIANCA-BRICK-X25-MIB", "x25CallSrcVCNumber"), (0, "BIANCA-BRICK-X25-MIB", "x25CallDstIfIndex"), (0, "BIANCA-BRICK-X25-MIB", "x25CallDstVCNumber"))
if mibBuilder.loadTexts: x25CallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallEntry.setDescription('The entries are created automatically, as soon as a call gets active. They are removed automatically as soon as a call gets completely cleared. A call may also be cleared manually by setting the x25CallState field of an entry to the value delete, which would also force the call to be cleared. The call data of a cleared call is copied to the x25CallHistoryTable.')
x25CallSrcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallSrcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallSrcIfIndex.setDescription('The interface index of the link, the call comes from. This object contains the value 1, when the call is originated locally.')
x25CallSrcLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallSrcLinkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallSrcLinkAddr.setDescription('The (MAC-)address of the link, the call comes from (if any)')
x25CallSrcVCNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallSrcVCNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallSrcVCNumber.setDescription('The virtual curcuit number of the call on the link, the call comes from.')
x25CallDstIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallDstIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallDstIfIndex.setDescription('The interface index of the link, the call leads to. This object contains the value 1, when the link is terminated locally.')
x25CallDstLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallDstLinkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallDstLinkAddr.setDescription('The (MAC-)address of the link, the call leads to.')
x25CallDstVCNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallDstVCNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallDstVCNumber.setDescription('The virtual curcuit number of the call on the target link.')
x25CallSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallSrcAddr.setDescription('The calling address of the call as received on the source link.')
x25CallDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallDstAddr.setDescription('The called address of the call as received on the source link.')
x25CallProtocolId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallProtocolId.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallProtocolId.setDescription('The protocol id (the first four byte of the call user data) of the call as received from the source link.')
x25CallFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallFacilities.setDescription('The facilities of the call as received from the source link.')
x25CallUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallUserData.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallUserData.setDescription('The user data (whithout the protocol id) of the call as received from the source link.')
x25CallAge = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallAge.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallAge.setDescription('The age of the call since received from the source link.')
x25CallState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("routing", 1), ("call-pending", 2), ("dataxfer", 3), ("out-reset-pending", 4), ("in-reset-pending", 5), ("out-clear-pending", 6), ("in-clear-pending", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CallState.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallState.setDescription('The current state of the call. A call may be cleared manually by setting this object to the value delete.')
x25CallInPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("p2", 1), ("p4", 2), ("p8", 3), ("p16", 4), ("p32", 5), ("p64", 6), ("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12), ("p8192", 13), ("p16384", 14), ("p32768", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallInPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallInPktSize.setDescription('The packet size of packets being received by the caller, as negotiated by the negotiation procedure.')
x25CallOutPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("p2", 1), ("p4", 2), ("p8", 3), ("p16", 4), ("p32", 5), ("p64", 6), ("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12), ("p8192", 13), ("p16384", 14), ("p32768", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallOutPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallOutPktSize.setDescription('The packet size of packets being sent by the caller, as negotiated by the negotiation procedure.')
x25CallInWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallInWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallInWinSize.setDescription('The window size of packets being received by the caller, as negotiated by the negotiation procedure.')
x25CallOutWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallOutWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallOutWinSize.setDescription('The window size of packets being sent by the caller, as negotiated by the negotiation procedure.')
x25CallPktsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallPktsSent.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallPktsSent.setDescription('The number of all layer 3 packets (including RR/RNR/REJ) sent by the caller.')
x25CallBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallBytesSent.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallBytesSent.setDescription('The number of data bytes sent in DATA and INTERRUPT packets by the caller.')
x25CallPktsRecvd = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallPktsRecvd.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallPktsRecvd.setDescription('The number of all layer 3 packets (including RR/RNR/REJ) received by the caller.')
x25CallBytesRecvd = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallBytesRecvd.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallBytesRecvd.setDescription('The number of data bytes received in DATA and INTERRUPT packets by the caller.')
x25CallHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 6, 4), )
if mibBuilder.loadTexts: x25CallHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryTable.setDescription('This table provides call information for the last 10 calls after they have been cleared. Active call are not contained in the x25CallHistoryTable.')
x25CallHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1), ).setIndexNames((0, "BIANCA-BRICK-X25-MIB", "x25CallHistorySrcIfIndex"), (0, "BIANCA-BRICK-X25-MIB", "x25CallHistoryDstIfIndex"))
if mibBuilder.loadTexts: x25CallHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryEntry.setDescription('Entries are created automatically, when a call is cleared completely. The first entry is deleted automatcally, if a new entry would be the 11th entry in the table.')
x25CallHistoryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 1), Date()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryTime.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryTime.setDescription('Date and time, when the call was received.')
x25CallHistoryDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryDuration.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryDuration.setDescription('Duration of the call in seconds.')
x25CallHistorySrcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistorySrcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistorySrcIfIndex.setDescription('Interface index of the link, the call came from.')
x25CallHistorySrcLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistorySrcLinkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistorySrcLinkAddr.setDescription('(MAC-)address of the link, the call came from.')
x25CallHistorySrcVCNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistorySrcVCNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistorySrcVCNumber.setDescription('Virtual Curcuit Number on the link, the call came from.')
x25CallHistoryDstIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryDstIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryDstIfIndex.setDescription('Interface index of the link, the call leads to.')
x25CallHistoryDstLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryDstLinkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryDstLinkAddr.setDescription('(MAC-)address of the link, the call leads to.')
x25CallHistoryDstVCNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryDstVCNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryDstVCNumber.setDescription('Virtual Curcuit Number on the link, the call leads to.')
x25CallHistorySrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistorySrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistorySrcAddr.setDescription('The calling party number as received from the source link.')
x25CallHistoryDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryDstAddr.setDescription('The called party number as received from the source link.')
x25CallHistoryProtocolId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryProtocolId.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryProtocolId.setDescription('The Protocol ID of the call (first four bytes of the call user data field) as received from the source link.')
x25CallHistoryFacilities = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryFacilities.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryFacilities.setDescription('The facility field of the call as received from the source link.')
x25CallHistoryUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryUserData.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryUserData.setDescription('The call user data behind the protocol ID as received from the source link')
x25CallHistoryInPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("p2", 1), ("p4", 2), ("p8", 3), ("p16", 4), ("p32", 5), ("p64", 6), ("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12), ("p8192", 13), ("p16384", 14), ("p32768", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryInPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryInPktSize.setDescription('The packet size of packets being received by the caller, as negotiated by the negotiation procedure.')
x25CallHistoryOutPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("p2", 1), ("p4", 2), ("p8", 3), ("p16", 4), ("p32", 5), ("p64", 6), ("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12), ("p8192", 13), ("p16384", 14), ("p32768", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryOutPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryOutPktSize.setDescription('The packet size of packets being sent by the caller, as negotiated by the negotiation procedure.')
x25CallHistoryInWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryInWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryInWinSize.setDescription('The window size of packets being received by the caller, as negotiated by the negotiation procedure.')
x25CallHistoryOutWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryOutWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryOutWinSize.setDescription('The window size of packets being sent by the caller, as negotiated by the negotiation procedure.')
x25CallHistoryPktsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryPktsSent.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryPktsSent.setDescription('The number of all layer 3 packets (including RR/RNR/REJ) sent by the caller.')
x25CallHistoryBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryBytesSent.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryBytesSent.setDescription('The number of data bytes sent in DATA and INTERRUPT packets by the caller.')
x25CallHistoryPktsRecvd = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryPktsRecvd.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryPktsRecvd.setDescription('The number of all layer 3 packets (including RR/RNR/REJ) received by the caller.')
x25CallHistoryBytesRecvd = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryBytesRecvd.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryBytesRecvd.setDescription('The number of data bytes received in DATA and INTERRUPT packets by the caller.')
x25CallHistoryClearCause = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryClearCause.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryClearCause.setDescription('The clearing cause of the call as received in the first clear packet. A value of -1 means, no cause was received.')
x25CallHistoryClearDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 4, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CallHistoryClearDiag.setStatus('mandatory')
if mibBuilder.loadTexts: x25CallHistoryClearDiag.setDescription('The clearing diagnostics of the call as received in the first clear packet. A value of -1 means, no diagnostics was received.')
x25RouteTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 6, 5), )
if mibBuilder.loadTexts: x25RouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteTable.setDescription('The X.25 Routing Table specifies the target link for different call parameters. For each incoming call the route table will be searched for a matching entry. If multiple entries match the call parameters, a metric defines which of them to use. A route is only used, if the state of the target interface is up or dormant (see mib2). Also the state of the link is used to determine wether to use the route or not. With this mechanism, a rerouting scheme can be implemented.')
x25RouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1), ).setIndexNames((0, "BIANCA-BRICK-X25-MIB", "x25RtSrcIfIndex"), (0, "BIANCA-BRICK-X25-MIB", "x25RtDstIfIndex"))
if mibBuilder.loadTexts: x25RouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteEntry.setDescription('Entries can only be created and deleted manually.')
x25RtSrcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtSrcIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtSrcIfIndex.setDescription('The originating interface index of the call. If this object is set to zero, the originating interface index will not be checked for the matching process. If this field is set to one, the route is only valid for call originating locally.')
x25RtSrcLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtSrcLinkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtSrcLinkAddr.setDescription('The originating (MAC-)address of the call. If this object is a zero length string, the originating address will not be checked for the matching process.')
x25RtDstIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtDstIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtDstIfIndex.setDescription('The interface index the call has to be sent to. If this value is set to one, the call will be used locally. If the value is set to zero, the call will be refused. The routing entry will only be used if the destination interface status is up or dormant. Additionally the target link must be in the state ready, if it is permanently activated, i.e. the x25LkL2IdleTimer is set to -1.')
x25RtDstLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtDstLinkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtDstLinkAddr.setDescription('The (MAC-)address of the station, the call has to be sent to. This object is ignored for point-to-point interfaces.')
x25RtDstLinkAddrMode = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("default", 1), ("direct", 2), ("delete", 3), ("rule", 4), ("auto", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtDstLinkAddrMode.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtDstLinkAddrMode.setDescription('This object specifies the way, the destination link address is generated. Default will use the default method for the target interface. When direct is selected, the destination address is taken from the route entry. Set to rule(4), the the address is generated according the rule defined in the x25RwDstLinkAddr entry of the X25RwTable. Other methods will be developed in the future.')
x25RtSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtSrcAddr.setDescription("The source X.121 address in the X25 call packet. If empty, the source address will not be matched. Extended Adresses are indicated by a leading '@'. The wildcards '*', '?', '[', ']', '{', '}' may be used.")
x25RtSrcNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtSrcNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtSrcNSAP.setDescription("The source NSAP in the X25 call packet. If empty, the source NSAP will not be matched. The NSAP is preceeded by an 'X' if it is an OSI compatible NSAP or by a 'N' if the NSAP is in a not OSI compatible format. The wildcards '*', '?', '[', ']', '{', '}' may be used.")
x25RtDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtDstAddr.setDescription("The target X.121 address in the X25 call packet. If empty, the source address will not be matched. Extended Adresses are indicated by a leading '@'. The wildcards '*', '?', '[', ']', '{', '}' may be used.")
x25RtDstNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtDstNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtDstNSAP.setDescription("The target NSAP in the X25 call packet. If empty, the source address will not be matched. The NSAP is preceeded by an 'X' if it is an OSI compatible NSAP or by a 'N' if the NSAP is in a not OSI compatible format. The wildcards '*', '?', '[', ']', '{', '}' may be used.")
x25RtProtocolId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtProtocolId.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtProtocolId.setDescription('The protocol id of the X25 call packet. The protocol id will not be used for the matching process, when this object is set to -1')
x25RtCallUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtCallUserData.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtCallUserData.setDescription('The call user data field of the X25 call packet behind the protocol id. If empty, the call user data field will not be used for matching.')
x25RtRPOA = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtRPOA.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtRPOA.setDescription('This object will be compared to the first value in the list of RPOAs in the X25 call packet, if not set to -1.')
x25RtNUI = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtNUI.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtNUI.setDescription('This object will be compared to the NUI facility supplied with the call. If this object is an empty string, the NUI facility will not be used for the matching process.')
x25RtRewritingRule = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtRewritingRule.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtRewritingRule.setDescription('This Object specifies a rewriting rule in the X25 Rewriting Rule table. The call packed will be processed according to this rewriting rule before the call is being delivered. If this value is set to zero, no rewriting will take place.')
x25RtMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtMetric.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtMetric.setDescription('This object specifies a metric similar to the metric of an IP routing entry. If a call matches multiple entries in the X25 routing table, the routing entry with the lowest value of Metric will be used to route the call.')
x25RtCug = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtCug.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtCug.setDescription('This object will be compared to the CUG facility supplied with the call, if not set to -1.')
x25RtCugOutgoing = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtCugOutgoing.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtCugOutgoing.setDescription('This object will be compared to the Outgoing CUG facility supplied with the call, if not set to -1.')
x25RtCugBilateral = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 5, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RtCugBilateral.setStatus('mandatory')
if mibBuilder.loadTexts: x25RtCugBilateral.setDescription('This object will be compared to the Bilateral CUG facility supplied with the call, if not set to -1.')
x25RewriteTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 6, 6), )
if mibBuilder.loadTexts: x25RewriteTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25RewriteTable.setDescription('This Table contains entries, that describe different rules of rewriting the call parameters before delivering a call. Which entry in this table is used, will be determined by the route table.')
x25RewriteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1), ).setIndexNames((0, "BIANCA-BRICK-X25-MIB", "x25RwRewritingRule"))
if mibBuilder.loadTexts: x25RewriteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25RewriteEntry.setDescription('')
x25RwRewritingRule = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwRewritingRule.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwRewritingRule.setDescription('The unique number of the rewriting rule.')
x25RwReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dont-change", 1), ("set", 2), ("clear", 3), ("delete", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwReverseCharging.setDescription('This object describes what to do with the reverse charging facility.')
x25RwRPOA = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dont-change", 1), ("remove-first", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwRPOA.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwRPOA.setDescription('This object describes what to do with the rpoa facility.')
x25RwNUI = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwNUI.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwNUI.setDescription('This object contains the new value of the NUI facility. If this object is an empty string, the NUI facility will not be changed.')
x25RwSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwSrcAddr.setDescription("Specifies how to rewrite the source address. Digits will be set directly to the new address. A '.' will move a digit from the old address to the new address. A '*' will move all remaining digits from the old address to the new address. A '%' will delete a digit from the old address. Please note that the eventually leading '@' (indicating extended adressing) is handled execatly like digits. If this object is empty, the source address will not be changed.")
x25RwSrcNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwSrcNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwSrcNSAP.setDescription("Specifies how to rewrite the source NSAP. Digits will be set directly to the new NSAP. A '.' will move a digit from the old NSAP to the new NSAP. A '*' will move all remaining digits from the old NSAP to the new NSAP. A '%' will delete a digit from the old NSAP. Please note that the eventually leading '@' (indicating extended adressing) is handled execatly like digits. If this object is empty, the source NSAP will not be changed.")
x25RwDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwDstAddr.setDescription("Specifies how to rewrite the destination address. Digits will be set directly to the new address. A '.' will move a digit from the old address to the new address. A '*' will move all remaining digits from the old address to the new address. A '%' will delete a digit from the old address. Please note that the eventually leading '@' (indicating extended adressing) is handled execatly like digits. If this object is empty, the destination address will not be changed.")
x25RwDstNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwDstNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwDstNSAP.setDescription("Specifies how to rewrite the destination NSAP. Digits will be set directly to the new NSAP. A '.' will move a digit from the old NSAP to the new NSAP. A '*' will move all remaining digits from the old NSAP to the new NSAP. A '%' will delete a digit from the old NSAP. Please note that the eventually leading '@' (indicating extended adressing) is handled execatly like digits. If this object is empty, the destination NSAP will not be changed.")
x25RwProtocolId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwProtocolId.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwProtocolId.setDescription('This object specifies the new value of the protocol id field. The protocol id field will not be changed, if this object is set to -1')
x25RwCallUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwCallUserData.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwCallUserData.setDescription("The new value of the call user data field. The call user data field will not be changed, if this object is an empty string. A leading '%' will be ignored. This allows to delete the call user data portion of a call packet by setting this object to a single '%'.")
x25RwRespSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwRespSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwRespSrcAddr.setDescription("Specifies how to rewrite the source address of the call accepted packet. Digits will be set directly to the new address. A '.' will move a digit from the old address to the new address. A '*' will move all remaining digits from the old address to the new address. A '%' will delete a digit from the old address. Please note that the eventually leading '@' (indicating extended adressing) is handled execatly like digits. If this object is empty, the source address will not be changed.")
x25RwRespSrcNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwRespSrcNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwRespSrcNSAP.setDescription("Specifies how to rewrite the source NSAP in the call accepted packet. Digits will be set directly to the new NSAP. A '.' will move a digit from the old NSAP to the new NSAP. A '*' will move all remaining digits from the old NSAP to the new NSAP. A '%' will delete a digit from the old NSAP. Please note that the eventually leading '@' (indicating extended adressing) is handled execatly like digits. If this object is empty, the source NSAP will not be changed.")
x25RwRespDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwRespDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwRespDstAddr.setDescription("Specifies how to rewrite the destination address of the call accepted packet. Digits will be set directly to the new address. A '.' will move a digit from the old address to the new address. A '*' will move all remaining digits from the old address to the new address. A '%' will delete a digit from the old address. Please note that the eventually leading '@' (indicating extended adressing) is handled execatly like digits. If this object is empty, the destination address will not be changed.")
x25RwRespDstNSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwRespDstNSAP.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwRespDstNSAP.setDescription("Specifies how to rewrite the destination NSAP in the call accepted packet. Digits will be set directly to the new NSAP. A '.' will move a digit from the old NSAP to the new NSAP. A '*' will move all remaining digits from the old NSAP to the new NSAP. A '%' will delete a digit from the old NSAP. Please note that the eventually leading '@' (indicating extended adressing) is handled execatly like digits. If this object is empty, the destination NSAP will not be changed.")
x25RwRespProtocolId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwRespProtocolId.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwRespProtocolId.setDescription('This object contains the new value of the ProtocolID field of the call accepted packet. The ProtocolID will not be changed, if this object is set to -1.')
x25RwRespCallUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwRespCallUserData.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwRespCallUserData.setDescription("The new value of the call user data field of the call accepted packet. The call user data field will not be changed, if this object is an empty string. A leading '%' will be ignored. This allows to delete the call user data portion of a call accepted packet by setting this object to a single '%'.")
x25RwCug = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwCug.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwCug.setDescription('This object contains the new value of the CUG facility. If this object is set to -1, the CUG facility will not be changed. The CUG facility will be removed, if this object is set to -2.')
x25RwCugOutgoing = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwCugOutgoing.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwCugOutgoing.setDescription('This object contains the new value of the Outgoing CUG facility. If this object is set to -1, the Outgoing CUG facility will not be changed. The Outgoing CUG facility will be removed, if this object is set to -2.')
x25RwCugBilateral = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwCugBilateral.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwCugBilateral.setDescription('This object contains the new value of the Bilateral CUG facility. If this object is set to -1, the Bilateral CUG facility will not be changed. The Bilateral CUG facility will be removed, if this object is set to -2.')
x25RwDstLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 6, 1, 20), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RwDstLinkAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25RwDstLinkAddr.setDescription("Specifies a rule how to generate a destination link address from destination X.25 address or destination NSAP. Digits will be set directly to the new address. A '.' will move a digit from the old address to the new address. A '*' will move all remaining digits from the old address to the new address. A '%' will delete a digit from the old address. The optional leading digit specifies the protocol to be used for the Layer 1 or the type of destination address to be generated (IP or MAC), this is followed by a mandatory character 'X' (use X.25 address for conversion) or 'N' (use NSAP).")
x25MprTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 6, 7), )
if mibBuilder.loadTexts: x25MprTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprTable.setDescription('This table contains an entry for each partner reachable via X.25 for Multiprotocol over X.25 according to RFC 1356. Entries in this table are created manually and will result to the creation of a multiprotocol routing interface in the ifTable. This interface can than be used by higher level protocols like ip, ipx and bridging. The object x25MprIfIndex shall be set to 0 for creation of new entries. The BRICK will allocate the next free interface index and assign it ti x25MprIfIndex. Rows of this table can be deleted by setting the object x25MprEncapsulation to the value delete. ')
x25MprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1), ).setIndexNames((0, "BIANCA-BRICK-X25-MIB", "x25MprIfIndex"))
if mibBuilder.loadTexts: x25MprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprEntry.setDescription('')
x25MprIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprIfIndex.setDescription('This object contains an interface index and assigns the row to an entry in ifTable. When creating new entries in the table, the value of this object shall be set to 0. The next free ifIndex value is than allocated by the BRICK and assigned to the object. At the same time a new interface is created in the IfTable.')
x25MprMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(576, 8180))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprMtu.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprMtu.setDescription('The Maximum transfer unit to be used with the interface, the row is describing.')
x25MprEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ip-rfc877", 1), ("ip", 2), ("ipx", 3), ("mpr", 4), ("delete", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprEncapsulation.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprEncapsulation.setDescription('This object specifies the encapsulation method to be used. If this object is set to ip_rfc877, the RFC877 compatible encapsulation is selected. The relating interface is only capabable of transferring IP datagrams. All other protocols are not supported. Virtual channels are established only with the CUD field set to CC. If this object is set to ip, the relating interface is also only capable of forwarding IP datagrams. However, the virtual channels are setup with the CUD field set to 80 00 00 00 08 00. The encapsulation ipx allows only forwarding of IPX datagrams. VCs are established using a CUD field of 80 00 00 00 81 37. If this object is set to mpr, the corresponding corresponding interface is capable of IP, IPX and BRIDGING. The different protocols are multiplexed over the same VC. The CUD field is set to 00.')
x25MprNumVC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprNumVC.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprNumVC.setDescription('This object specifies the number of VCs used with the corresponding interface. The BRICK will always try to have that many VCs available for the relating interface.')
x25MprMaxVC = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprMaxVC.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprMaxVC.setDescription('This object specifies the maximum number of VCs used with the corresponding interface. It shall be greater or equal to x25MprNumVC.')
x25MprWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprWinSize.setDescription('This object describes the window size to be used for outgoing X.25 virtual calls.')
x25MprPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("p128", 7), ("p256", 8), ("p512", 9), ("p1024", 10), ("p2048", 11), ("p4096", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprPktSize.setDescription('This object describes the packet size, to be used for outgoing X.25 calls. Please note that this parameter is independant of the x25MprMtu parameter.')
x25MprShortHold = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprShortHold.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprShortHold.setDescription('This object specifies the time of inactivity in seconds, after which the VCs are disconnected automatically.')
x25MprMaxRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprMaxRetries.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprMaxRetries.setDescription('This object specifies the maximum number of tries for X.25 call establishement. If the BRICK has tried to establish the call for this many times, the interface is in the blocked state for a time specified by x25MprBlockTime. During the blocked state, no more tries are made.')
x25MprBlockTime = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprBlockTime.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprBlockTime.setDescription('This object describes the amount of time, the corresponding interface remains in the blocked state after too many tries to establish the X.25 call.')
x25MprAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 6, 7, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25MprAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25MprAddr.setDescription('The X.25 address to be used with this interface. A leading @ indicates extended adressing.')
x25LocalPadCall = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 6, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("accept", 1), ("dont-accept", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LocalPadCall.setStatus('mandatory')
if mibBuilder.loadTexts: x25LocalPadCall.setDescription('This object specifies wether a PAD Call (PID=1) routed to the local X.25 entity (ifIndex=1) should be accepted to allow for a remote login via X.25. This may be disabled for security reasons by setting this object do dont-accept.')
x25LocalAddr = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 6, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: x25LocalAddr.setDescription('The X.25 address to be used as originating address for outgoing X.25 call from this BRICK. A leading @ indicates extended adressing.')
x25Rerouting = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 6, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allow", 1), ("disallow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25Rerouting.setStatus('mandatory')
if mibBuilder.loadTexts: x25Rerouting.setDescription('This object specifies whether a rerouting request should be accepted to establish connection to another server. This is only relevant for x29 rerouting.')
x25HistoryMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 6, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25HistoryMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: x25HistoryMaxEntries.setDescription('Maximum number of x25CallHistory entries in memory.')
x25AccountingTemplate = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 6, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25AccountingTemplate.setStatus('mandatory')
if mibBuilder.loadTexts: x25AccountingTemplate.setDescription('Specifies the format of accounting messages sent by the syslog protocol. The format can consist of any order of the following variables. Tag Meaning %S Date and Time the connection was established; in DD.MM.YY/HH:MM:SS format. %d The duration of the connection in seconds. %z The X25 source address. %Z The X25 destination address. %y Total number of bytes received over the connection. %Y Total number of bytes sent over the connection. %g Total packets received over the connection. %G Total packets sent over the connection. %c The X25 clear cause. %C The X25 clear diagnostic. %f The source interface. %F The destination interface. %v The source virtual channel number. %V The destination virtual channel number. The default accounting template setting contains the following tags: %S,%d,%z,%Z,%y,%Y,%g,%G,%c,%C.')
mibBuilder.exportSymbols("BIANCA-BRICK-X25-MIB", x25CallHistoryDstVCNumber=x25CallHistoryDstVCNumber, x25LkPrL2RetrCounter=x25LkPrL2RetrCounter, HexValue=HexValue, x25CallHistoryDstAddr=x25CallHistoryDstAddr, x25MprWinSize=x25MprWinSize, x25=x25, x25MprMaxRetries=x25MprMaxRetries, x25RwRespDstNSAP=x25RwRespDstNSAP, x25CallHistoryBytesSent=x25CallHistoryBytesSent, x25MprBlockTime=x25MprBlockTime, x25RtProtocolId=x25RtProtocolId, x25LkPrModulo=x25LkPrModulo, x25CallHistoryInWinSize=x25CallHistoryInWinSize, x25RwDstNSAP=x25RwDstNSAP, x25LkDiscDelayTimer=x25LkDiscDelayTimer, x25CallSrcVCNumber=x25CallSrcVCNumber, x25RwCugBilateral=x25RwCugBilateral, x25MprEntry=x25MprEntry, x25LkPrAddr=x25LkPrAddr, x25RtNUI=x25RtNUI, x25LkPrNegotiation=x25LkPrNegotiation, x25LkNegotiation=x25LkNegotiation, x25LkPrCallDelayTimer=x25LkPrCallDelayTimer, x25LkAddr=x25LkAddr, x25MprNumVC=x25MprNumVC, bintec=bintec, x25LkPrDiscDelayTimer=x25LkPrDiscDelayTimer, x25LkLIC=x25LkLIC, x25LocalPadCall=x25LocalPadCall, x25LkState=x25LkState, x25LkHOC=x25LkHOC, x25CallHistoryClearCause=x25CallHistoryClearCause, x25CallHistorySrcAddr=x25CallHistorySrcAddr, x25LkL2WinSize=x25LkL2WinSize, x25CallSrcAddr=x25CallSrcAddr, x25LkDefPktSize=x25LkDefPktSize, x25CallHistoryPktsRecvd=x25CallHistoryPktsRecvd, x25MprEncapsulation=x25MprEncapsulation, x25CallHistoryBytesRecvd=x25CallHistoryBytesRecvd, x25LkPrL2SupervTimer=x25LkPrL2SupervTimer, x25LkPrHTC=x25LkPrHTC, x25CallInPktSize=x25CallInPktSize, x25LkCallDelayTimer=x25LkCallDelayTimer, x25CallOutPktSize=x25CallOutPktSize, x25CallDstAddr=x25CallDstAddr, x25RwDstAddr=x25RwDstAddr, x25LkDefWinSize=x25LkDefWinSize, x25CallDstVCNumber=x25CallDstVCNumber, x25CallHistoryEntry=x25CallHistoryEntry, x25LkHTC=x25LkHTC, x25LkPrMaxPktSize=x25LkPrMaxPktSize, x25CallHistoryTime=x25CallHistoryTime, x25RtSrcAddr=x25RtSrcAddr, x25RwDstLinkAddr=x25RwDstLinkAddr, x25Rerouting=x25Rerouting, x25RtDstLinkAddr=x25RtDstLinkAddr, x25RwCug=x25RwCug, x25MprPktSize=x25MprPktSize, x25RwRespProtocolId=x25RwRespProtocolId, x25RtDstAddr=x25RtDstAddr, x25LinkTable=x25LinkTable, x25RwNUI=x25RwNUI, x25CallUserData=x25CallUserData, x25RtCugOutgoing=x25RtCugOutgoing, x25RewriteEntry=x25RewriteEntry, x25LkLOC=x25LkLOC, x25LkPrLOC=x25LkPrLOC, x25MprAddr=x25MprAddr, x25RwRespCallUserData=x25RwRespCallUserData, x25CallBytesSent=x25CallBytesSent, x25RouteTable=x25RouteTable, x25LkRestDelayTimer=x25LkRestDelayTimer, x25RwRPOA=x25RwRPOA, x25LinkPresetTable=x25LinkPresetTable, x25LkMaxPktSize=x25LkMaxPktSize, x25RtRPOA=x25RtRPOA, x25RtCug=x25RtCug, x25CallHistoryInPktSize=x25CallHistoryInPktSize, x25LkPrLIC=x25LkPrLIC, x25RtRewritingRule=x25RtRewritingRule, x25HistoryMaxEntries=x25HistoryMaxEntries, x25CallSrcIfIndex=x25CallSrcIfIndex, x25LkPrL2IdleTimer=x25LkPrL2IdleTimer, x25CallHistoryPktsSent=x25CallHistoryPktsSent, x25RtDstLinkAddrMode=x25RtDstLinkAddrMode, x25LkPrL2WinSize=x25LkPrL2WinSize, x25RtSrcNSAP=x25RtSrcNSAP, x25CallHistoryDstIfIndex=x25CallHistoryDstIfIndex, org=org, x25RwSrcNSAP=x25RwSrcNSAP, x25LkPrHOC=x25LkPrHOC, x25MprMaxVC=x25MprMaxVC, x25LkPrRestDelayTimer=x25LkPrRestDelayTimer, x25CallHistorySrcLinkAddr=x25CallHistorySrcLinkAddr, x25RtMetric=x25RtMetric, x25MprIfIndex=x25MprIfIndex, x25LkMode=x25LkMode, x25LkPrHIC=x25LkPrHIC, x25CallTable=x25CallTable, x25CallOutWinSize=x25CallOutWinSize, x25CallPktsSent=x25CallPktsSent, x25CallPktsRecvd=x25CallPktsRecvd, x25RwCallUserData=x25RwCallUserData, x25LkPrDefPktSize=x25LkPrDefPktSize, x25CallInWinSize=x25CallInWinSize, dod=dod, x25LkModulo=x25LkModulo, x25RtDstIfIndex=x25RtDstIfIndex, Date=Date, x25LinkPresetEntry=x25LinkPresetEntry, x25LkPrIfIndex=x25LkPrIfIndex, x25CallHistoryOutPktSize=x25CallHistoryOutPktSize, x25AccountingTemplate=x25AccountingTemplate, x25LkIfIndex=x25LkIfIndex, x25LkL2SupervTimer=x25LkL2SupervTimer, x25CallHistoryUserData=x25CallHistoryUserData, x25LkL2IdleTimer=x25LkL2IdleTimer, x25MprMtu=x25MprMtu, x25LkLTC=x25LkLTC, x25MprShortHold=x25MprShortHold, x25CallHistoryFacilities=x25CallHistoryFacilities, x25RwSrcAddr=x25RwSrcAddr, x25RwProtocolId=x25RwProtocolId, x25RtCugBilateral=x25RtCugBilateral, x25RwCugOutgoing=x25RwCugOutgoing, x25RouteEntry=x25RouteEntry, x25RwRewritingRule=x25RwRewritingRule, x25LocalAddr=x25LocalAddr, x25LkL2RetrCounter=x25LkL2RetrCounter, x25CallEntry=x25CallEntry, enterprises=enterprises, x25CallHistoryTable=x25CallHistoryTable, x25RtSrcLinkAddr=x25RtSrcLinkAddr, x25LkMaxWinSize=x25LkMaxWinSize, private=private, x25CallHistoryClearDiag=x25CallHistoryClearDiag, x25LkPrDefWinSize=x25LkPrDefWinSize, x25CallHistoryOutWinSize=x25CallHistoryOutWinSize, x25MprTable=x25MprTable, x25RtDstNSAP=x25RtDstNSAP, x25RtCallUserData=x25RtCallUserData, x25CallAge=x25CallAge, x25LkPrMaxWinSize=x25LkPrMaxWinSize, x25RwReverseCharging=x25RwReverseCharging, x25CallDstLinkAddr=x25CallDstLinkAddr, x25RwRespSrcNSAP=x25RwRespSrcNSAP, x25RewriteTable=x25RewriteTable, x25CallHistoryDstLinkAddr=x25CallHistoryDstLinkAddr, x25CallProtocolId=x25CallProtocolId, x25CallBytesRecvd=x25CallBytesRecvd, x25CallHistorySrcIfIndex=x25CallHistorySrcIfIndex, x25CallDstIfIndex=x25CallDstIfIndex, x25LkPrL2RetrTimer=x25LkPrL2RetrTimer, x25CallFacilities=x25CallFacilities, x25RtSrcIfIndex=x25RtSrcIfIndex, x25RwRespDstAddr=x25RwRespDstAddr, x25CallHistoryDuration=x25CallHistoryDuration, x25LkPrLTC=x25LkPrLTC, x25LinkEntry=x25LinkEntry, bibo=bibo, x25CallState=x25CallState, x25LkHIC=x25LkHIC, x25LkL2RetrTimer=x25LkL2RetrTimer, x25CallSrcLinkAddr=x25CallSrcLinkAddr, x25CallHistoryProtocolId=x25CallHistoryProtocolId, internet=internet, x25CallHistorySrcVCNumber=x25CallHistorySrcVCNumber, x25RwRespSrcAddr=x25RwRespSrcAddr, x25LkPrMode=x25LkPrMode)

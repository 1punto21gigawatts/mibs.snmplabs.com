#
# PySNMP MIB module IPOA-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPOA-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:56:16 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
ipAdEntAddr, ipNetToMediaNetAddress, ipNetToMediaPhysAddress, ipNetToMediaIfIndex = mibBuilder.importSymbols("IP-MIB", "ipAdEntAddr", "ipNetToMediaNetAddress", "ipNetToMediaPhysAddress", "ipNetToMediaIfIndex")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
IpAddress, Counter32, ObjectIdentity, Integer32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, NotificationType, Gauge32, Bits, iso, TimeTicks, transmission, Unsigned32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter32", "ObjectIdentity", "Integer32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "NotificationType", "Gauge32", "Bits", "iso", "TimeTicks", "transmission", "Unsigned32", "MibIdentifier")
TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString")
ipoaMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 46))
if mibBuilder.loadTexts: ipoaMIB.setLastUpdated('9802090000Z')
if mibBuilder.loadTexts: ipoaMIB.setOrganization('IETF Internetworking Over NBMA Working Group (ion)')
if mibBuilder.loadTexts: ipoaMIB.setContactInfo('Maria Greene (greene@xedia.com) Xedia Corp. Jim Luciani (jluciani@BayNetworks.com) Bay Networks Kenneth White (kennethw@vnet.ibm.com) IBM Corp. Ted Kuo (tkuo@eos.ncsu.edu) Bay Networks')
if mibBuilder.loadTexts: ipoaMIB.setDescription('This module defines a portion of the management information base (MIB) for managing Classical IP and ARP over ATM entities.')
class IpoaEncapsType(TextualConvention, Integer32):
    description = 'The encapsulation type used on a VC.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("llcSnap", 1), ("vcMuxed", 2), ("other", 3))

class IpoaVpiInteger(TextualConvention, Integer32):
    description = 'An integer large enough to contain the value of a VPI.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class IpoaVciInteger(TextualConvention, Integer32):
    description = 'An integer large enough to contain the value of a VCI.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class IpoaAtmAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity. The semantics are implied by the length. The address types are: - no address (0 octets) - E.164 (8 octets) - NSAP (20 octets) In addition, when subaddresses are used IpoaAtmAddr may represent the concatenation of address and subaddress. The associated address types are: - E.164, E.164 (16 octets) - E.164, NSAP (28 octets) - NSAP, NSAP (40 octets) Address lengths other than defined in this definition imply address types defined elsewhere. Note: The E.164 address is encoded in BCD format.'
    status = 'current'
    displayHint = '1x'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 40)

class IpoaAtmConnKind(TextualConvention, Integer32):
    description = 'The use of call control. The use is as follows: pvc(1) Virtual link of a PVC. Should not be used in a PVC/SVC (i.e., SPVC) crossconnect. svcIncoming(2) Virtual link established after a received signaling request to setup an SVC. svcOutgoing(3) Virtual link established after a transmitted or forwarded signaling request to setup an SVC. spvcInitiator(4) Virtual link at the PVC side of an SVC/PVC crossconnect, where the switch is the initiator of the SPVC setup. spvcTarget(5) Virtual link at the PVC side of an SVC/PVC crossconnect, where the switch is the target of the SPVC setup. An spvcInitiator is always cross-connected to an svcOutgoing, and an spvcTarget is always cross-connected to an svcIncoming.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("pvc", 1), ("svcIncoming", 2), ("svcOutgoing", 3), ("spvcInitiator", 4), ("spvcTarget", 5))

ipoaObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 46, 1))
ipoaNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 46, 2))
ipoaConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 46, 3))
ipoaLisTrapEnable = MibScalar((1, 3, 6, 1, 2, 1, 10, 46, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipoaLisTrapEnable.setStatus('current')
if mibBuilder.loadTexts: ipoaLisTrapEnable.setDescription('Indicates whether ipoaLisCreate and ipoaLisDelete traps should be generated by this system. By default, this object should have the value enabled(1) for systems where ATMARP Servers are present and disabled(2) on systems where only clients reside.')
ipoaLisTable = MibTable((1, 3, 6, 1, 2, 1, 10, 46, 1, 2), )
if mibBuilder.loadTexts: ipoaLisTable.setStatus('current')
if mibBuilder.loadTexts: ipoaLisTable.setDescription('There is one entry in this table for every Logical IP Subnet (LIS) of which this system is a member. The bulk of the objects in an ipoaLisEntry exists to control ATMARP for a particular LIS. In a PVC only environment it is implementation dependent as to whether this table should be supported.')
ipoaLisEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1), ).setIndexNames((0, "IPOA-MIB", "ipoaLisSubnetAddr"))
if mibBuilder.loadTexts: ipoaLisEntry.setStatus('current')
if mibBuilder.loadTexts: ipoaLisEntry.setDescription('Information about a single LIS of which this system is a member. Membership in a LIS is independent of the actual ATM interfaces being used. The ipoaLisTable defines all LISs that a system is a member of. The ipAddrTable and the ipoaClientTable provides the mapping from local IP address to ATM interface. The ipoaLisIfMappingTable provides the mappings between Logical IP Subnets and interfaces. The ipoaLisTable is indexed by ipoaLisSubnetAddr (IP subnet address). An entry in the ipoaLisTable should exist for each ipAddrEntry that is associated with an ATM related interface used for Classical IP and ARP over ATM traffic. Its ipAdEntAddr and ipAdEntNetMask when ANDed together should equal the ipoaLisSubnetAddr of the corresponding ipoaLisEntry.')
ipoaLisSubnetAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaLisSubnetAddr.setStatus('current')
if mibBuilder.loadTexts: ipoaLisSubnetAddr.setDescription('The IP subnet address associated with this LIS.')
ipoaLisDefaultMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(9180)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisDefaultMtu.setStatus('current')
if mibBuilder.loadTexts: ipoaLisDefaultMtu.setDescription('The default MTU used within this LIS. Note that the actual MTU used for a VC between two members of the LIS may be negotiated during connection setup and may be different than this value. The ipoaVcNegotiatedMtu object indicates the actual MTU in use for a particular VC.')
ipoaLisDefaultEncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 3), IpoaEncapsType().clone('llcSnap')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisDefaultEncapsType.setStatus('current')
if mibBuilder.loadTexts: ipoaLisDefaultEncapsType.setDescription('The default encapsulation to use on VCs created for this LIS. Note that the actual encapsulation type may be negotiated during connection setup and may be different than this value. The ipoaVcNegotiatedEncapsType object indicates the actual encapsulation in use for a particular VC.')
ipoaLisInactivityTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 4), Integer32().clone(1200)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisInactivityTimer.setReference('RFC 1755, Sec. 3.4 VC Teardown')
if mibBuilder.loadTexts: ipoaLisInactivityTimer.setStatus('current')
if mibBuilder.loadTexts: ipoaLisInactivityTimer.setDescription('The time, in seconds, before a call established for an ipNetToMediaEntry on a client will timeout due to no traffic being passed on the VC. A value of 0 implies no time out.')
ipoaLisMinHoldingTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisMinHoldingTime.setReference('RFC 1755, Sec. 3.4 VC Teardown')
if mibBuilder.loadTexts: ipoaLisMinHoldingTime.setStatus('current')
if mibBuilder.loadTexts: ipoaLisMinHoldingTime.setDescription('The minimum amount of time, in seconds, that a call will remain open. If 0 then ipoaInactivityTimer will completely determine when a call is terminated.')
ipoaLisQDepth = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setUnits('packets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisQDepth.setStatus('current')
if mibBuilder.loadTexts: ipoaLisQDepth.setDescription('The maximum number of outstanding requests that are allowed while waiting for ATMARP replies and InATMARP replies for this LIS.')
ipoaLisMaxCalls = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(500)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisMaxCalls.setStatus('current')
if mibBuilder.loadTexts: ipoaLisMaxCalls.setDescription('The maximum number of SVCs that can be established simultaneously for this LIS.')
ipoaLisCacheEntryAge = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 1200)).clone(900)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisCacheEntryAge.setStatus('current')
if mibBuilder.loadTexts: ipoaLisCacheEntryAge.setDescription('The time, in seconds, before an ipNetToMediaEntry will age out of the table. Note that the default value will be different for a client and a server. An ATMARP Server should use a default of 1200 and a client should use 900.')
ipoaLisRetries = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisRetries.setStatus('current')
if mibBuilder.loadTexts: ipoaLisRetries.setDescription('The number of times the ATMARP request will be retried when no response is received in the timeout interval indicated by ipoaLisTimeout.')
ipoaLisTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisTimeout.setStatus('current')
if mibBuilder.loadTexts: ipoaLisTimeout.setDescription('The time to wait, in seconds, before retransmission of an ARP request.')
ipoaLisDefaultPeakCellRate = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisDefaultPeakCellRate.setStatus('current')
if mibBuilder.loadTexts: ipoaLisDefaultPeakCellRate.setDescription("This object is the signalling parameter that should be used when setting up all best effort VCCs (Virtual Channel Connections). This parameter applies to the forward and backward direction on a per best effort VCC basis. A value of zero implies that no configured default exists and that local policy should be used to determine the actual default to used during call setup. ATM Signaling Support for IP over ATM (RFC 1755) recommends 1/10th of the ATM interface's speed.")
ipoaLisActiveVcs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaLisActiveVcs.setStatus('current')
if mibBuilder.loadTexts: ipoaLisActiveVcs.setDescription('Number of active SVCs for this LIS.')
ipoaLisRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 2, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisRowStatus.setReference("RFC 1903, 'Textual Conventions for Version 2 of the Simple Network Management Protocol (SNMPv2).'")
if mibBuilder.loadTexts: ipoaLisRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipoaLisRowStatus.setDescription("This object allows entries to be created and deleted in the ipoaLisTable. When the ipoaLisRowStatus deleted (by setting this object to destroy(6)), this has the side-effect of removing all entries from the ipNetToMediaTable that are associated with this LIS (in other words, it flushes the entity's ATMARP cache). It also removes the ipoaVcTable entries that were associated with those ipNetToMediaTable entries. Destroying the row also removes the corresponding entries in the ipoaArpSrvrTable, ipoaArpClientTable, ipoaLisIfMappingTable, and ipoaArpRemoteSrvrTable. Entries in both the ipNetToMediaTable and the ipoaVcTable that are associated with a ipoaConfigPvcEntry are not affected by changes to ipoaLisRowStatus.")
ipoaLisIfMappingTable = MibTable((1, 3, 6, 1, 2, 1, 10, 46, 1, 3), )
if mibBuilder.loadTexts: ipoaLisIfMappingTable.setStatus('current')
if mibBuilder.loadTexts: ipoaLisIfMappingTable.setDescription('There is one entry in this table for every combination of ipoaLisEntry and IP over ATM interface.')
ipoaLisIfMappingEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 46, 1, 3, 1), ).setIndexNames((0, "IPOA-MIB", "ipoaLisSubnetAddr"), (0, "IPOA-MIB", "ipoaLisIfMappingIfIndex"))
if mibBuilder.loadTexts: ipoaLisIfMappingEntry.setStatus('current')
if mibBuilder.loadTexts: ipoaLisIfMappingEntry.setDescription('Defines an entry in the ipoaLisIfMappingTable.')
ipoaLisIfMappingIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 3, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ipoaLisIfMappingIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipoaLisIfMappingIfIndex.setDescription('The ipAdEntIfIndex object from an ipAddrEntry is used as an index to this table when its ipAdEntAddr is in the subnet implied by ipoaLisSubnetAddr.')
ipoaLisIfMappingRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaLisIfMappingRowStatus.setReference("RFC 1903, 'Textual Conventions for Version 2 of the Simple Network Management Protocol (SNMPv2).'")
if mibBuilder.loadTexts: ipoaLisIfMappingRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipoaLisIfMappingRowStatus.setDescription('This object allows entries to be created and deleted in the ipoaLisIfMappingTable.')
ipoaArpClientTable = MibTable((1, 3, 6, 1, 2, 1, 10, 46, 1, 4), )
if mibBuilder.loadTexts: ipoaArpClientTable.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientTable.setDescription('The ATMARP clients running on this system.')
ipoaArpClientEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"))
if mibBuilder.loadTexts: ipoaArpClientEntry.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientEntry.setDescription("Information about a single ATMARP Client. Clients can be started and stopped by adding and removing entries from this table. An entry in the ipoaArpClientTable has a corresponding entry in the ipAddrTable. Both are indexed by ipAdEntAddr. The ifIndex and subnet mask of a client entry are the ipAddrEntry's ipAdEntIfIndex and ipAdEntNetMask, respectively. Note that adding and removing entries from this table may have the same effect on the corresponding ipAddrTable entry. Row creation of an entry in this table requires that either the corresponding ipAddrTable entry exists or that ipAdEntIfIndex and ipAdEntNetMask be specified in the creation of an ipoaArpClientEntry at a minimum in order to create the corresponding ipAddrEntry. Specification of ipAdEntBcastAddr and ipAdEntReasmMaxSize to complete an ipAddrEntry is implementation dependent. Whether a corresponding ipAddrEntry is deleted during the deletion of an ipoaArpClientEntry is considered implementation dependent.")
ipoaArpClientAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 1), IpoaAtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaArpClientAtmAddr.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientAtmAddr.setDescription('The ATM address of the client.')
ipoaArpClientSrvrInUse = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 2), IpoaAtmAddr().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientSrvrInUse.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientSrvrInUse.setDescription('The ATM address of the ATMARP Server, ipoaArpRemoteSrvrAtmAddr, in use by this client. A zero length octet string implies that communication with a Remote ATMARP Server is not in effect.')
ipoaArpClientInArpInReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientInArpInReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientInArpInReqs.setDescription('The number of InATMARP requests received by this client.')
ipoaArpClientInArpOutReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientInArpOutReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientInArpOutReqs.setDescription('The number of InATMARP requests sent by this client.')
ipoaArpClientInArpInReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientInArpInReplies.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientInArpInReplies.setDescription('The number of InATMARP replies received by this client.')
ipoaArpClientInArpOutReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientInArpOutReplies.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientInArpOutReplies.setDescription('Total number of InATMARP replies sent by this client.')
ipoaArpClientInArpInvalidInReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientInArpInvalidInReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientInArpInvalidInReqs.setDescription('The number of times that this client detected an invalid InATMARP request.')
ipoaArpClientInArpInvalidOutReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientInArpInvalidOutReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientInArpInvalidOutReqs.setDescription('The number of times that this client did not receive an InATMARP reply.')
ipoaArpClientArpInReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientArpInReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientArpInReqs.setDescription('Total number of ATMARP requests received by this client.')
ipoaArpClientArpOutReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientArpOutReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientArpOutReqs.setDescription('Total number of ATMARP requests sent by this client.')
ipoaArpClientArpInReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientArpInReplies.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientArpInReplies.setDescription('Total number of ATMARP replies received by this client.')
ipoaArpClientArpOutReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientArpOutReplies.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientArpOutReplies.setDescription('Total number of ATMARP replies sent by this client.')
ipoaArpClientArpInNaks = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientArpInNaks.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientArpInNaks.setDescription('Total number of negative ATMARP replies received by this client.')
ipoaArpClientArpOutNaks = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientArpOutNaks.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientArpOutNaks.setDescription('Total number of negative ATMARP replies sent by this client. Classic IP and ARP over ATM does not require an ATMARP client to transmit an ATMARP_NAK upon receipt of an ATMARP request from another ATMARP client. However, implementation experience has shown that this error condition is somewhat easy to create inadvertently by configuring one ATMARP client with an ipoaArpRemoteSrvrTable entry containing an ipoaArpRemoteSrvrAtmAddr value which is the ATM address of another ATMARP client-only system. If an ATMARP client supports the transmission of ATMARP_NAKs, then it should increment ipoaArpClientArpOutNaks each time it transmits an ATMARP_NAK. Otherwise, support of this object is considered optional.')
ipoaArpClientArpUnknownOps = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientArpUnknownOps.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientArpUnknownOps.setDescription('The number of times that this client received an ATMARP message with an operation code for which it is not coded to support.')
ipoaArpClientArpNoSrvrResps = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpClientArpNoSrvrResps.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientArpNoSrvrResps.setDescription('The number of times this client failed to receive a response from a ATMARP Server within the ipoaLisTimeout value for ipoaLisRetries times. This may imply that the client will re-elect a new primary ATMARP Server for this LIS from the ipoaArpRemoteSrvrTable.')
ipoaArpClientRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 4, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaArpClientRowStatus.setReference("RFC 1903, 'Textual Conventions for Version 2 of the Simple Network Management Protocol (SNMPv2).'")
if mibBuilder.loadTexts: ipoaArpClientRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipoaArpClientRowStatus.setDescription('This object allows entries to be created and deleted from the ipoaArpClientTable.')
ipoaArpSrvrTable = MibTable((1, 3, 6, 1, 2, 1, 10, 46, 1, 5), )
if mibBuilder.loadTexts: ipoaArpSrvrTable.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrTable.setDescription('The ATMARP Servers running on this system.')
ipoaArpSrvrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPOA-MIB", "ipoaArpSrvrAddr"))
if mibBuilder.loadTexts: ipoaArpSrvrEntry.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrEntry.setDescription("Information about an ATMARP Server within a LIS. An entry in this table has two indexes: first ipAdEntAddr, which is the IP address that this system uses as a member of the LIS, and then ipoaArpSrvrAddr, which is the ATM address of the ATMARP Server. Entries may be created by a management application using the ipoaArpSrvrRowStatus object. Entries in this table may also be created by the system and not by a management application, for example via ILMI. Entries in this table may be deleted by setting the ipoaArpSrvrRowStatus object to 'destroy(6)'. This includes entries that were added by the system and not by a management application.")
ipoaArpSrvrAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 1), IpoaAtmAddr())
if mibBuilder.loadTexts: ipoaArpSrvrAddr.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrAddr.setDescription('The ATM address of the ATMARP Server.')
ipoaArpSrvrLis = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaArpSrvrLis.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrLis.setDescription('The subnet address that identifies the LIS with which this server is associated.')
ipoaArpSrvrInArpInReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrInArpInReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrInArpInReqs.setDescription('The number of InATMARP requests received by this ATMARP Server.')
ipoaArpSrvrInArpOutReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrInArpOutReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrInArpOutReqs.setDescription('The number of InATMARP requests sent by this ATMARP Server.')
ipoaArpSrvrInArpInReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrInArpInReplies.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrInArpInReplies.setDescription('The number of InATMARP replies received by this ATMARP Server.')
ipoaArpSrvrInArpOutReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrInArpOutReplies.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrInArpOutReplies.setDescription('The number of InATMARP replies sent by this ATMARP Server.')
ipoaArpSrvrInArpInvalidInReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrInArpInvalidInReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrInArpInvalidInReqs.setDescription('The number of invalid InATMARP requests received by this ATMARP Server.')
ipoaArpSrvrInArpInvalidOutReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrInArpInvalidOutReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrInArpInvalidOutReqs.setDescription('The number of times that this server did not receive an InATMARP reply.')
ipoaArpSrvrArpInReqs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrArpInReqs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrArpInReqs.setDescription('Total number of ATMARP requests received by this ATMARP Server.')
ipoaArpSrvrArpOutReplies = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrArpOutReplies.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrArpOutReplies.setDescription('Total number of ATMARP replies sent by this ATMARP Server.')
ipoaArpSrvrArpOutNaks = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrArpOutNaks.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrArpOutNaks.setDescription('Total number of negative ATMARP replies sent by this ATMARP Server.')
ipoaArpSrvrArpDupIpAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrArpDupIpAddrs.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrArpDupIpAddrs.setDescription('The number of times that a duplicate IP address was detected by this ATMARP Server.')
ipoaArpSrvrArpUnknownOps = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpSrvrArpUnknownOps.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrArpUnknownOps.setDescription('The number of times that this ATMARP Server received an ATMARP message with an operation code for which it is not coded to support.')
ipoaArpSrvrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 5, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaArpSrvrRowStatus.setReference("RFC 1903, 'Textual Conventions for Version 2 of the Simple Network Management Protocol (SNMPv2).'")
if mibBuilder.loadTexts: ipoaArpSrvrRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipoaArpSrvrRowStatus.setDescription('This object allows entries to be created and deleted from the ipoaArpSrvrTable.')
ipoaArpRemoteSrvrTable = MibTable((1, 3, 6, 1, 2, 1, 10, 46, 1, 6), )
if mibBuilder.loadTexts: ipoaArpRemoteSrvrTable.setStatus('current')
if mibBuilder.loadTexts: ipoaArpRemoteSrvrTable.setDescription('A table of non-local ATMARP Servers associated with a LIS. An entry in this table has three indexes: first the ipoaLisSubnetAddr of the LIS for which the corresponding ATMARP Server provides ATMARP services, then the ipoaArpRemoteSrvrAtmAddr, which is the ATM address of the remote ATMARP Server, and finally the ifIndex of the interface on which the VC to the ATMARP Remote Server will be opened. An ifIndex value of 0 should be used when a single VC is to be shared for ATMARP purposes by multiple interfaces.')
ipoaArpRemoteSrvrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 46, 1, 6, 1), ).setIndexNames((0, "IPOA-MIB", "ipoaLisSubnetAddr"), (0, "IPOA-MIB", "ipoaArpRemoteSrvrAtmAddr"), (0, "IPOA-MIB", "ipoaArpRemoteSrvrIfIndex"))
if mibBuilder.loadTexts: ipoaArpRemoteSrvrEntry.setStatus('current')
if mibBuilder.loadTexts: ipoaArpRemoteSrvrEntry.setDescription('Information about one non-local ATMARP Server.')
ipoaArpRemoteSrvrAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 6, 1, 1), IpoaAtmAddr())
if mibBuilder.loadTexts: ipoaArpRemoteSrvrAtmAddr.setStatus('current')
if mibBuilder.loadTexts: ipoaArpRemoteSrvrAtmAddr.setDescription('The ATM address of the remote ATMARP Server.')
ipoaArpRemoteSrvrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaArpRemoteSrvrRowStatus.setReference("RFC 1903, 'Textual Conventions for Version 2 of the Simple Network Management Protocol (SNMPv2).'")
if mibBuilder.loadTexts: ipoaArpRemoteSrvrRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipoaArpRemoteSrvrRowStatus.setDescription('This object allows entries to be created and deleted from the ipoaArpRemoteSrvrTable. Deleting an ipoaArpRemoteSrvrEntry (by setting this object to destroy(6)) may affect ipoaArpClientTable entries. The object ipoaArpClientSrvrInUse in an ipoaArpClientSrvrEntry may contain the ATM address of an ATMARP Remote Server whose entry in the ipoaArpRemoteSrvrTable is being removed. In this case, any corresponding ipoaArpClientSrvrInUse objects should be at a minimum invalidated by setting their values to that of a zero length OCTET STRING. The value of ipoaArpRemoteSrvrOperStatus should be consistent with that of ipoaArpRemoteSrvrRowStatus. For example, successfully setting the value of this object to notInService(2) after its being in the up(1) state should result in ipoaArpRemoteSrvrOperStatus being set to down(2) if currently up(1).')
ipoaArpRemoteSrvrIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 6, 1, 3), InterfaceIndexOrZero())
if mibBuilder.loadTexts: ipoaArpRemoteSrvrIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipoaArpRemoteSrvrIfIndex.setDescription('The ifIndex of the interface that the VC to the Remote ATMARP Server is associated with.')
ipoaArpRemoteSrvrIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 6, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpRemoteSrvrIpAddr.setStatus('current')
if mibBuilder.loadTexts: ipoaArpRemoteSrvrIpAddr.setDescription("The IP Address of the Remote ATMARP Server. A value of 0.0.0.0 implies that this address isn't known.")
ipoaArpRemoteSrvrAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaArpRemoteSrvrAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ipoaArpRemoteSrvrAdminStatus.setDescription('The desired state for use of the ATMARP Server represented by an entry in this table. ipoaArpRemoteSrvrAdminStatus values: up(1) - Attempt to activate use of the ATMARP Server represented by this entry in the ipoaArpRemoteSrvrTable. down(2) - Deactivate use of this ATMARP Server. When a managed system creates an entry in this table ipoaArpRemoteSrvrAdminStatus and ipoaArpRemoteSrvrOperStatus are initialized as down(2) by default.')
ipoaArpRemoteSrvrOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaArpRemoteSrvrOperStatus.setStatus('current')
if mibBuilder.loadTexts: ipoaArpRemoteSrvrOperStatus.setDescription('The current operational state for use of a Remote ATMARP Server. An up(1) entry has a VC established to the respective Remote ATMARP Server: up(1) - A VC exists to Remote ATMARP Server whose IP Address is stored in ipoaArpRemoteSrvrIpAddr. This VC can be determined by searching the ipoaVcTable using ipoaArpRemoteSrvrIfIndex (if not 0, otherwise ignore ipNetToMediaIfIndex index) and ipoaArpRemoteSrvrIpAddr. An ipoaArpClientEntry should exist with its ipoaArpClientSrvrInUse object having the same value as ipoaArpRemoteSrvrAtmAddr. down(2) - Entry exists without an active VC to the Remote ATMARP Server. Transition from up(1) to down(2) status may affect ipoaArpClientTable entries. The object ipoaArpClientSrvrInUse in an ipoaArpClientSrvrEntry may contain the ATM address of an ATMARP Remote Server whose entry in the ipoaArpRemoteSrvrTable is being deactivated. In this case, any corresponding ipoaArpClientSrvrInUse objects should be at a minimum invalidated by setting their values to that of a zero length OCTET STRING. If ipoaArpRemoteSrvrAdminStatus is down(2) then ipoaArpRemoteSrvrOperStatus should be down(2). If ipoaArpRemoteSrvrAdminStatus is changed to up(1) then ipoaArpRemoteSrvrOperStatus should change to up(1) if the Remote ATMARP Server entry can be activated.')
ipoaVcTable = MibTable((1, 3, 6, 1, 2, 1, 10, 46, 1, 7), )
if mibBuilder.loadTexts: ipoaVcTable.setStatus('current')
if mibBuilder.loadTexts: ipoaVcTable.setDescription("A system that supports IP over ATM is an IP system and therefore MUST support all of the appropriate tables in the SNMPv2-MIB (RFC 1907), the IF-MIB (RFC 2233), the IP-MIB (RFC 2011), the TCP-MIB (RFC 2012), and the UDP-MIB (RFC 2013). This includes the ipNetToMediaTable (the ARP cache) that is defined within the IP-MIB (RFC 2011). The ipoaVcTable keeps a set of VCs for each entry in the ARP cache that was put there by an IP over ATM system acting as either a host or server. The ipoaVcTable doesn't augment the ipNetToMediaTable (ARP Cache) since the the correspondence between tables is not necessarily one-to-one. An ipNetToMediaPhysAddress object should contain the content as defined by the IpoaAtmAddr textual convention when used to hold an IPOA-MIB ATM Address.")
ipoaVcEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 46, 1, 7, 1), ).setIndexNames((0, "IP-MIB", "ipNetToMediaIfIndex"), (0, "IP-MIB", "ipNetToMediaNetAddress"), (0, "IPOA-MIB", "ipoaVcVpi"), (0, "IPOA-MIB", "ipoaVcVci"))
if mibBuilder.loadTexts: ipoaVcEntry.setStatus('current')
if mibBuilder.loadTexts: ipoaVcEntry.setDescription('A VC (permanent or switched) that this host or server has opened with another member of a LIS. Additional information can be determined about the VC from the ATM-MIB. Entries in this table cannot be created by management applications. In an SVC environment, an entry is automatically added by the system as the result of ATMARP processing. In a PVC environment, an entry is automatically added to this table when an entry is created in the ipoaConfigPvcTable and the IP Address at the remote end of the PVC is discovered using InATMARP. An entry also is added to the ipNetToMediaTable.')
ipoaVcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 7, 1, 1), IpoaVpiInteger())
if mibBuilder.loadTexts: ipoaVcVpi.setStatus('current')
if mibBuilder.loadTexts: ipoaVcVpi.setDescription('The VPI value for the Virtual Circuit.')
ipoaVcVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 7, 1, 2), IpoaVciInteger())
if mibBuilder.loadTexts: ipoaVcVci.setStatus('current')
if mibBuilder.loadTexts: ipoaVcVci.setDescription('The VCI value for the Virtual Circuit.')
ipoaVcType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 7, 1, 3), IpoaAtmConnKind()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaVcType.setStatus('current')
if mibBuilder.loadTexts: ipoaVcType.setDescription('The type of the Virtual Circuit.')
ipoaVcNegotiatedEncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 7, 1, 4), IpoaEncapsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaVcNegotiatedEncapsType.setStatus('current')
if mibBuilder.loadTexts: ipoaVcNegotiatedEncapsType.setDescription('The encapsulation type used when communicating over this circuit.')
ipoaVcNegotiatedMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipoaVcNegotiatedMtu.setStatus('current')
if mibBuilder.loadTexts: ipoaVcNegotiatedMtu.setDescription('The MTU used when communicating over this circuit.')
ipoaConfigPvcTable = MibTable((1, 3, 6, 1, 2, 1, 10, 46, 1, 8), )
if mibBuilder.loadTexts: ipoaConfigPvcTable.setStatus('current')
if mibBuilder.loadTexts: ipoaConfigPvcTable.setDescription('This table MUST be supported when PVCs are intended to be supported in order to enable the setup of PVCs for use by IP.')
ipoaConfigPvcEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 46, 1, 8, 1), ).setIndexNames((0, "IPOA-MIB", "ipoaConfigPvcIfIndex"), (0, "IPOA-MIB", "ipoaConfigPvcVpi"), (0, "IPOA-MIB", "ipoaConfigPvcVci"))
if mibBuilder.loadTexts: ipoaConfigPvcEntry.setStatus('current')
if mibBuilder.loadTexts: ipoaConfigPvcEntry.setDescription('Defines a single PVC that exists at this host for use by IP.')
ipoaConfigPvcIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 8, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ipoaConfigPvcIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipoaConfigPvcIfIndex.setDescription('The ifIndex of the ATM Interface that this PVC is associated with.')
ipoaConfigPvcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 8, 1, 2), IpoaVpiInteger())
if mibBuilder.loadTexts: ipoaConfigPvcVpi.setStatus('current')
if mibBuilder.loadTexts: ipoaConfigPvcVpi.setDescription('The VPI value for the Virtual Circuit.')
ipoaConfigPvcVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 8, 1, 3), IpoaVciInteger())
if mibBuilder.loadTexts: ipoaConfigPvcVci.setStatus('current')
if mibBuilder.loadTexts: ipoaConfigPvcVci.setDescription('The VCI value for the Virtual Circuit.')
ipoaConfigPvcDefaultMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(9180)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaConfigPvcDefaultMtu.setStatus('current')
if mibBuilder.loadTexts: ipoaConfigPvcDefaultMtu.setDescription('Classical IP and ARP over ATM allows use of other MTU values for PVCs but considers how a value other than 9180 could be selected to be out of scope. ipoaConfigPvcDefaultMtu can be used to configure the MTU to be used for the PVC. Both ends MUST have the same value configured.')
ipoaConfigPvcRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 46, 1, 8, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipoaConfigPvcRowStatus.setReference("RFC 1903, 'Textual Conventions for Version 2 of the Simple Network Management Protocol (SNMPv2).'")
if mibBuilder.loadTexts: ipoaConfigPvcRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipoaConfigPvcRowStatus.setDescription('This object allows rows to be created and deleted in the ipoaConfigPvcTable. Creation of an entry in this table should eventually result in the creation of an ipNetToMediaEntry and a corresponding ipoaVcEntry after InATMARP has determined the destination address of the remote system that the PVC is connected to. Setting this object to destroy(6) should remove the corresponding ipNetToMediaTable and ipoaVcTable entries.')
ipoaTrapPrefix = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 46, 2, 0))
ipoaMtuExceeded = NotificationType((1, 3, 6, 1, 2, 1, 10, 46, 2, 0, 1)).setObjects(("IPOA-MIB", "ipoaVcNegotiatedMtu"))
if mibBuilder.loadTexts: ipoaMtuExceeded.setStatus('current')
if mibBuilder.loadTexts: ipoaMtuExceeded.setDescription('A frame was received that exceeds the negotiated MTU size. The VPI and VCI of the VC for which this condition was detected can be determined from the index values for ipoaVcNegotiatedMtu. In addition, the ifIndex and IP Address can be determined as well (refer to the ipoaVcTable).')
ipoaDuplicateIpAddress = NotificationType((1, 3, 6, 1, 2, 1, 10, 46, 2, 0, 2)).setObjects(("IP-MIB", "ipNetToMediaIfIndex"), ("IP-MIB", "ipNetToMediaNetAddress"), ("IP-MIB", "ipNetToMediaPhysAddress"), ("IP-MIB", "ipNetToMediaPhysAddress"))
if mibBuilder.loadTexts: ipoaDuplicateIpAddress.setStatus('current')
if mibBuilder.loadTexts: ipoaDuplicateIpAddress.setDescription('The ATMARP Server has detected more than one ATM end point attempting to associate the same IP address with different ATM addresses.')
ipoaLisCreate = NotificationType((1, 3, 6, 1, 2, 1, 10, 46, 2, 0, 3)).setObjects(("IPOA-MIB", "ipoaLisSubnetAddr"))
if mibBuilder.loadTexts: ipoaLisCreate.setStatus('current')
if mibBuilder.loadTexts: ipoaLisCreate.setDescription('Generation of this trap occurs when an ipoaLisEntry is created while the ipoaLisTrapEnable.0 object has the value enabled(1).')
ipoaLisDelete = NotificationType((1, 3, 6, 1, 2, 1, 10, 46, 2, 0, 4)).setObjects(("IPOA-MIB", "ipoaLisSubnetAddr"))
if mibBuilder.loadTexts: ipoaLisDelete.setStatus('current')
if mibBuilder.loadTexts: ipoaLisDelete.setDescription('Generation of this trap occurs when an ipoaLisEntry is deleted while the ipoaLisTrapEnable.0 object has the value enabled(1).')
ipoaGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 46, 3, 1))
ipoaCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 46, 3, 2))
ipoaCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 46, 3, 2, 1)).setObjects(("IPOA-MIB", "ipoaGeneralGroup"), ("IPOA-MIB", "ipoaBasicNotificationsGroup"), ("IPOA-MIB", "ipoaClientGroup"), ("IPOA-MIB", "ipoaSrvrGroup"), ("IPOA-MIB", "ipoaSrvrNotificationsGroup"), ("IPOA-MIB", "ipoaLisNotificationsGroup"), ("IPOA-MIB", "ipoaLisTableGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipoaCompliance = ipoaCompliance.setStatus('current')
if mibBuilder.loadTexts: ipoaCompliance.setDescription('The compliance statement for agents that support the IPOA-MIB.')
ipoaGeneralGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 46, 3, 1, 1)).setObjects(("IPOA-MIB", "ipoaVcType"), ("IPOA-MIB", "ipoaVcNegotiatedEncapsType"), ("IPOA-MIB", "ipoaVcNegotiatedMtu"), ("IPOA-MIB", "ipoaConfigPvcDefaultMtu"), ("IPOA-MIB", "ipoaConfigPvcRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipoaGeneralGroup = ipoaGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: ipoaGeneralGroup.setDescription('This group is mandatory for all IP over ATM entities.')
ipoaClientGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 46, 3, 1, 2)).setObjects(("IPOA-MIB", "ipoaArpClientAtmAddr"), ("IPOA-MIB", "ipoaArpClientSrvrInUse"), ("IPOA-MIB", "ipoaArpClientInArpInReqs"), ("IPOA-MIB", "ipoaArpClientInArpOutReqs"), ("IPOA-MIB", "ipoaArpClientInArpInReplies"), ("IPOA-MIB", "ipoaArpClientInArpOutReplies"), ("IPOA-MIB", "ipoaArpClientInArpInvalidInReqs"), ("IPOA-MIB", "ipoaArpClientInArpInvalidOutReqs"), ("IPOA-MIB", "ipoaArpClientArpInReqs"), ("IPOA-MIB", "ipoaArpClientArpOutReqs"), ("IPOA-MIB", "ipoaArpClientArpInReplies"), ("IPOA-MIB", "ipoaArpClientArpOutReplies"), ("IPOA-MIB", "ipoaArpClientArpInNaks"), ("IPOA-MIB", "ipoaArpClientArpOutNaks"), ("IPOA-MIB", "ipoaArpClientArpUnknownOps"), ("IPOA-MIB", "ipoaArpClientArpNoSrvrResps"), ("IPOA-MIB", "ipoaArpClientRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipoaClientGroup = ipoaClientGroup.setStatus('current')
if mibBuilder.loadTexts: ipoaClientGroup.setDescription('This group is mandatory for all hosts where an IP over ATM client is present.')
ipoaSrvrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 46, 3, 1, 3)).setObjects(("IPOA-MIB", "ipoaArpSrvrLis"), ("IPOA-MIB", "ipoaArpSrvrInArpInReqs"), ("IPOA-MIB", "ipoaArpSrvrInArpOutReqs"), ("IPOA-MIB", "ipoaArpSrvrInArpInReplies"), ("IPOA-MIB", "ipoaArpSrvrInArpOutReplies"), ("IPOA-MIB", "ipoaArpSrvrInArpInvalidInReqs"), ("IPOA-MIB", "ipoaArpSrvrInArpInvalidOutReqs"), ("IPOA-MIB", "ipoaArpSrvrArpInReqs"), ("IPOA-MIB", "ipoaArpSrvrArpOutReplies"), ("IPOA-MIB", "ipoaArpSrvrArpOutNaks"), ("IPOA-MIB", "ipoaArpSrvrArpDupIpAddrs"), ("IPOA-MIB", "ipoaArpSrvrArpUnknownOps"), ("IPOA-MIB", "ipoaArpSrvrRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipoaSrvrGroup = ipoaSrvrGroup.setStatus('current')
if mibBuilder.loadTexts: ipoaSrvrGroup.setDescription('This group is mandatory for all hosts where ATMARP Servers are present.')
ipoaBasicNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 46, 3, 1, 4)).setObjects(("IPOA-MIB", "ipoaMtuExceeded"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipoaBasicNotificationsGroup = ipoaBasicNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: ipoaBasicNotificationsGroup.setDescription('The notification which an IP over ATM entity is required to implement.')
ipoaSrvrNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 46, 3, 1, 5)).setObjects(("IPOA-MIB", "ipoaDuplicateIpAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipoaSrvrNotificationsGroup = ipoaSrvrNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: ipoaSrvrNotificationsGroup.setDescription('The notification which an IP over ATM ATMARP Server is required to implement.')
ipoaLisNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 46, 3, 1, 6)).setObjects(("IPOA-MIB", "ipoaLisCreate"), ("IPOA-MIB", "ipoaLisDelete"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipoaLisNotificationsGroup = ipoaLisNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: ipoaLisNotificationsGroup.setDescription('The LIS-related notifications which are required to be implemented by an IP over ATM ATMARP server, as well as by any IP over ATM client which allows ipoaLisTrapEnable to be set to enabled(1).')
ipoaLisTableGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 46, 3, 1, 7)).setObjects(("IPOA-MIB", "ipoaLisTrapEnable"), ("IPOA-MIB", "ipoaLisSubnetAddr"), ("IPOA-MIB", "ipoaLisDefaultMtu"), ("IPOA-MIB", "ipoaLisDefaultEncapsType"), ("IPOA-MIB", "ipoaLisInactivityTimer"), ("IPOA-MIB", "ipoaLisMinHoldingTime"), ("IPOA-MIB", "ipoaLisQDepth"), ("IPOA-MIB", "ipoaLisMaxCalls"), ("IPOA-MIB", "ipoaLisCacheEntryAge"), ("IPOA-MIB", "ipoaLisRetries"), ("IPOA-MIB", "ipoaLisTimeout"), ("IPOA-MIB", "ipoaLisDefaultPeakCellRate"), ("IPOA-MIB", "ipoaLisActiveVcs"), ("IPOA-MIB", "ipoaLisRowStatus"), ("IPOA-MIB", "ipoaLisIfMappingRowStatus"), ("IPOA-MIB", "ipoaArpRemoteSrvrRowStatus"), ("IPOA-MIB", "ipoaArpRemoteSrvrIpAddr"), ("IPOA-MIB", "ipoaArpRemoteSrvrAdminStatus"), ("IPOA-MIB", "ipoaArpRemoteSrvrOperStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipoaLisTableGroup = ipoaLisTableGroup.setStatus('current')
if mibBuilder.loadTexts: ipoaLisTableGroup.setDescription('This group is mandatory for all entities which support IP over ATM SVCs. Support of objects in this group by IP over ATM clients which only support IP over ATM PVCs is optional.')
mibBuilder.exportSymbols("IPOA-MIB", ipoaArpSrvrArpUnknownOps=ipoaArpSrvrArpUnknownOps, ipoaLisDefaultPeakCellRate=ipoaLisDefaultPeakCellRate, ipoaLisInactivityTimer=ipoaLisInactivityTimer, IpoaVpiInteger=IpoaVpiInteger, ipoaLisActiveVcs=ipoaLisActiveVcs, ipoaLisTrapEnable=ipoaLisTrapEnable, ipoaVcNegotiatedEncapsType=ipoaVcNegotiatedEncapsType, ipoaLisCreate=ipoaLisCreate, ipoaLisMinHoldingTime=ipoaLisMinHoldingTime, ipoaConfigPvcDefaultMtu=ipoaConfigPvcDefaultMtu, ipoaArpSrvrArpDupIpAddrs=ipoaArpSrvrArpDupIpAddrs, ipoaConfigPvcEntry=ipoaConfigPvcEntry, ipoaGroups=ipoaGroups, ipoaTrapPrefix=ipoaTrapPrefix, ipoaLisDelete=ipoaLisDelete, ipoaArpClientAtmAddr=ipoaArpClientAtmAddr, ipoaConfigPvcIfIndex=ipoaConfigPvcIfIndex, ipoaClientGroup=ipoaClientGroup, ipoaArpRemoteSrvrTable=ipoaArpRemoteSrvrTable, ipoaArpSrvrInArpOutReplies=ipoaArpSrvrInArpOutReplies, ipoaArpSrvrInArpInvalidInReqs=ipoaArpSrvrInArpInvalidInReqs, ipoaArpClientArpUnknownOps=ipoaArpClientArpUnknownOps, ipoaConfigPvcTable=ipoaConfigPvcTable, IpoaAtmAddr=IpoaAtmAddr, ipoaArpClientArpInNaks=ipoaArpClientArpInNaks, ipoaMIB=ipoaMIB, IpoaEncapsType=IpoaEncapsType, ipoaLisEntry=ipoaLisEntry, ipoaLisRowStatus=ipoaLisRowStatus, ipoaArpSrvrRowStatus=ipoaArpSrvrRowStatus, ipoaArpClientEntry=ipoaArpClientEntry, ipoaArpRemoteSrvrAdminStatus=ipoaArpRemoteSrvrAdminStatus, ipoaMtuExceeded=ipoaMtuExceeded, PYSNMP_MODULE_ID=ipoaMIB, ipoaLisQDepth=ipoaLisQDepth, ipoaArpSrvrAddr=ipoaArpSrvrAddr, ipoaVcTable=ipoaVcTable, ipoaDuplicateIpAddress=ipoaDuplicateIpAddress, ipoaConfigPvcVci=ipoaConfigPvcVci, ipoaArpSrvrInArpInvalidOutReqs=ipoaArpSrvrInArpInvalidOutReqs, ipoaArpClientInArpOutReplies=ipoaArpClientInArpOutReplies, ipoaArpRemoteSrvrIfIndex=ipoaArpRemoteSrvrIfIndex, ipoaArpRemoteSrvrRowStatus=ipoaArpRemoteSrvrRowStatus, ipoaArpSrvrArpOutNaks=ipoaArpSrvrArpOutNaks, ipoaArpClientSrvrInUse=ipoaArpClientSrvrInUse, ipoaVcEntry=ipoaVcEntry, ipoaLisSubnetAddr=ipoaLisSubnetAddr, ipoaArpRemoteSrvrIpAddr=ipoaArpRemoteSrvrIpAddr, ipoaArpSrvrLis=ipoaArpSrvrLis, ipoaConfigPvcVpi=ipoaConfigPvcVpi, ipoaArpClientInArpOutReqs=ipoaArpClientInArpOutReqs, ipoaLisRetries=ipoaLisRetries, ipoaArpSrvrInArpInReqs=ipoaArpSrvrInArpInReqs, ipoaArpSrvrTable=ipoaArpSrvrTable, ipoaLisNotificationsGroup=ipoaLisNotificationsGroup, ipoaArpClientArpInReplies=ipoaArpClientArpInReplies, ipoaArpSrvrInArpInReplies=ipoaArpSrvrInArpInReplies, ipoaArpClientInArpInvalidInReqs=ipoaArpClientInArpInvalidInReqs, ipoaBasicNotificationsGroup=ipoaBasicNotificationsGroup, ipoaLisTableGroup=ipoaLisTableGroup, ipoaArpClientRowStatus=ipoaArpClientRowStatus, ipoaConfigPvcRowStatus=ipoaConfigPvcRowStatus, ipoaArpClientArpOutReqs=ipoaArpClientArpOutReqs, ipoaLisIfMappingEntry=ipoaLisIfMappingEntry, ipoaSrvrNotificationsGroup=ipoaSrvrNotificationsGroup, ipoaVcVpi=ipoaVcVpi, ipoaArpSrvrArpInReqs=ipoaArpSrvrArpInReqs, ipoaArpClientInArpInvalidOutReqs=ipoaArpClientInArpInvalidOutReqs, ipoaLisIfMappingRowStatus=ipoaLisIfMappingRowStatus, ipoaVcNegotiatedMtu=ipoaVcNegotiatedMtu, IpoaAtmConnKind=IpoaAtmConnKind, ipoaSrvrGroup=ipoaSrvrGroup, ipoaLisIfMappingTable=ipoaLisIfMappingTable, ipoaArpClientInArpInReqs=ipoaArpClientInArpInReqs, ipoaArpClientArpOutNaks=ipoaArpClientArpOutNaks, ipoaGeneralGroup=ipoaGeneralGroup, ipoaArpClientArpOutReplies=ipoaArpClientArpOutReplies, ipoaLisTimeout=ipoaLisTimeout, ipoaArpClientTable=ipoaArpClientTable, ipoaArpSrvrInArpOutReqs=ipoaArpSrvrInArpOutReqs, ipoaArpRemoteSrvrOperStatus=ipoaArpRemoteSrvrOperStatus, ipoaArpSrvrEntry=ipoaArpSrvrEntry, ipoaLisCacheEntryAge=ipoaLisCacheEntryAge, ipoaArpClientInArpInReplies=ipoaArpClientInArpInReplies, ipoaArpRemoteSrvrAtmAddr=ipoaArpRemoteSrvrAtmAddr, ipoaLisIfMappingIfIndex=ipoaLisIfMappingIfIndex, ipoaArpSrvrArpOutReplies=ipoaArpSrvrArpOutReplies, ipoaLisDefaultMtu=ipoaLisDefaultMtu, ipoaCompliance=ipoaCompliance, ipoaConformance=ipoaConformance, ipoaArpRemoteSrvrEntry=ipoaArpRemoteSrvrEntry, ipoaArpClientArpInReqs=ipoaArpClientArpInReqs, ipoaLisDefaultEncapsType=ipoaLisDefaultEncapsType, ipoaLisMaxCalls=ipoaLisMaxCalls, ipoaVcVci=ipoaVcVci, IpoaVciInteger=IpoaVciInteger, ipoaObjects=ipoaObjects, ipoaNotifications=ipoaNotifications, ipoaArpClientArpNoSrvrResps=ipoaArpClientArpNoSrvrResps, ipoaLisTable=ipoaLisTable, ipoaVcType=ipoaVcType, ipoaCompliances=ipoaCompliances)

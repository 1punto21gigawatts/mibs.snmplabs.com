#
# PySNMP MIB module DGS3427-L3MGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DGS3427-L3MGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:46:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Counter32, Integer32, NotificationType, IpAddress, ModuleIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Counter64, Gauge32, Unsigned32, Bits, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter32", "Integer32", "NotificationType", "IpAddress", "ModuleIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Counter64", "Gauge32", "Unsigned32", "Bits", "ObjectIdentity")
RowStatus, DisplayString, MacAddress, PhysAddress, TimeStamp, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "MacAddress", "PhysAddress", "TimeStamp", "TruthValue", "TextualConvention")
dgs3427, = mibBuilder.importSymbols("SW34XXPRIMGMT-MIB", "dgs3427")
swL3MgmtMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3))
if mibBuilder.loadTexts: swL3MgmtMIB.setLastUpdated('201203020000Z')
if mibBuilder.loadTexts: swL3MgmtMIB.setOrganization(' ')
if mibBuilder.loadTexts: swL3MgmtMIB.setContactInfo(' ')
if mibBuilder.loadTexts: swL3MgmtMIB.setDescription('The Structure of Layer 3 Network Management Information for the proprietary enterprise.')
swL3DevMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 1))
swL3IpMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2))
swL3RelayMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3))
swL3IpCtrlMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1))
swL3IpFdbMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 2))
swL3RelayDnsMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2))
class Ipv6Address(TextualConvention, OctetString):
    description = 'This data type is used to model IPv6 addresses. This is a binary string of 16 octets in network byte-order.'
    status = 'current'
    displayHint = '2x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(16, 16)
    fixedLength = 16

swL3DevCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 1, 1))
swL3DevCtrlRIPState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DevCtrlRIPState.setStatus('current')
if mibBuilder.loadTexts: swL3DevCtrlRIPState.setDescription('This object indicates Routing Information Protocol (RIP) version 2 function is enabled or disabled.')
swL3IpCtrlAllIpIfState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlAllIpIfState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlAllIpIfState.setDescription('This object indicates all interface function state of the device.')
swL3IpCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3), )
if mibBuilder.loadTexts: swL3IpCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlTable.setDescription('This table contain IP interface information.')
swL3IpCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3IpCtrlInterfaceName"))
if mibBuilder.loadTexts: swL3IpCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlEntry.setDescription('A list of information about a specific IP interface.')
swL3IpCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlInterfaceName.setDescription('This object indicates the name of the IP interface.')
swL3IpCtrlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlIfIndex.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIfIndex.setDescription('This object uniquely identifies the IP interface number in the swL3IpCtrlTable.')
swL3IpCtrlIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpAddr.setDescription('The IP address of the interface. This object only can take the value of the unicast IP address.')
swL3IpCtrlIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpSubnetMask.setDescription('The IP net mask for this interface.')
swL3IpCtrlVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlVlanName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlVlanName.setDescription("This object indicates the IP control entry's VLAN name. The VLAN name in each entry must be unique in the IP Control Table.")
swL3IpCtrlProxyArp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlProxyArp.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlProxyArp.setDescription('This object indicates enable/disable of the proxy ARP function for IPv4.')
swL3IpCtrlSecondary = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlSecondary.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlSecondary.setDescription('When this is true(1), the IP address is the secondary IP. When false(2), the IP address is the primary IP.')
swL3IpCtrlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("bootp", 3), ("dhcp", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlMode.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlMode.setDescription('This object indicates the IP operation mode. other(1) - This entry is currently in use but the conditions under which it will remain are determined by each of the following values. bootp(3) - The IP address will be set automatically from a BOOTP server. dhcp(4) - The IP address will be set automatically from a DHCP server.')
swL3IpCtrlAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlAdminState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlAdminState.setDescription('The state of the IP interface.')
swL3IpCtrlIpv6LinkLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 14), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalAddress.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalAddress.setDescription('The IPv6 link local address for this interface.')
swL3IpCtrlIpv6LinkLocalPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalPrefixLen.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalPrefixLen.setDescription('The IPv6 prefix length for this IPv6 link local address.')
swL3IpCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlState.setDescription('This variable displays the status of the entry. The status is used for creating, modifying, and deleting instances of the objects in this table.')
swL3IpCtrlIpv6LinkLocalAutoState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalAutoState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpv6LinkLocalAutoState.setDescription('The state of the IPv6 link local auto.')
swL3IpCtrlLocalProxyArp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpCtrlLocalProxyArp.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlLocalProxyArp.setDescription('If the state is enabled, the switch will be allowed to respond to the proxy ARP proxy ARP when the source IP and destination IP are on the same interface.')
swL3IpCtrlDhcpv6ClientState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientState.setDescription('The state of the Dhcpv6 Client.')
swL3IpCtrlIpDirectedBroadcastState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpDirectedBroadcastState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpDirectedBroadcastState.setDescription('The state of the IP Directed Broadcast.')
swL3IpCtrlIpDhcpOption12State = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpDhcpOption12State.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpDhcpOption12State.setDescription('Enable or disable insertion of option 12 in the DHCPDISCOVER and DHCPREQUEST message.')
swL3IpCtrlIpDhcpOption12HostName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlIpDhcpOption12HostName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlIpDhcpOption12HostName.setDescription('Specify the host name to be inserted in the DHCPDISCOVER and DHCPREQUEST message. The specified host name must start with a letter, end with a letter or digit, and have only letters, digits, and hyphen as interior characters; the maximal length is 63. By default, the host name is empty. When set an empty host name, means to clear the host name setting and use the default value to encode option 12.')
swL3IpCtrlDhcpv6ClientPDState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDState.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDState.setDescription('The state of the Dhcpv6 Client PD.')
swL3IpCtrlDhcpv6ClientPDPrefixName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefixName.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefixName.setDescription("This object indicates the name for the DHCPv6 Client PD. If the swL3IpCtrlDhcpv6ClientPDState is disabled, this object will be clear and can't write.")
swL3IpCtrlDhcpv6ClientPDPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 26), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefix.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefix.setDescription('The IPv6 prefix obtained form delegation router.')
swL3IpCtrlDhcpv6ClientPDPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 3, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefixLen.setStatus('current')
if mibBuilder.loadTexts: swL3IpCtrlDhcpv6ClientPDPrefixLen.setDescription('The IPv6 prefix length for the prefix obtained from delegation router.')
swL3Ipv6CtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4), )
if mibBuilder.loadTexts: swL3Ipv6CtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlTable.setDescription('This table contains IPv6 information of an IP interface.')
swL3Ipv6CtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3Ipv6CtrlInterfaceName"))
if mibBuilder.loadTexts: swL3Ipv6CtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlEntry.setDescription('A list of IPv6 information about a specific IP interface.')
swL3Ipv6CtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6CtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlInterfaceName.setDescription('This object indicates the name of the IP interface.')
swL3Ipv6CtrlMaxReassmblySize = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6CtrlMaxReassmblySize.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlMaxReassmblySize.setDescription('Maximum Reassembly Size of the IP interface.')
swL3Ipv6CtrlNsRetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlNsRetransTimer.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlNsRetransTimer.setDescription("Neighbor solicitation's retransmit timer. The unit is set in milliseconds.")
swL3Ipv6CtrlRaState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaState.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaState.setDescription('Neighbor solicited state.')
swL3Ipv6CtrlRaMinRtrAdvInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1350))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaMinRtrAdvInterval.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaMinRtrAdvInterval.setDescription('The minimum time allowed between sending unsolicited multicast Router Advertisements from the interface. The unit is set in seconds. It must be no less than 3 seconds and no greater than .75 * MaxRtrAdvInterval. Default value: 0.33 * MaxRtrAdvInterval')
swL3Ipv6CtrlRaMaxRtrAdvInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 1800)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaMaxRtrAdvInterval.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaMaxRtrAdvInterval.setDescription('The maximum time allowed between sending unsolicited multicast Router Advertisements from the interface. The unit is set in seconds.')
swL3Ipv6CtrlRaLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaLifeTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaLifeTime.setDescription('Indicates the lifetime of the router as the default router.')
swL3Ipv6CtrlRaReachableTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaReachableTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaReachableTime.setDescription('Indicates the amount of time that a node can consider a neighboring node reachable after receiving a reachability confirmation.')
swL3Ipv6CtrlRaRetransTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaRetransTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaRetransTime.setDescription('Indicates the amount of time between retransmissions of neighbor solicited messages. The unit is set in millisecond.')
swL3Ipv6CtrlRaHopLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaHopLimit.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaHopLimit.setDescription('Indicates the default value of the hop limit field in the IPv6 header for packets sent by hosts that receive this RA message.')
swL3Ipv6CtrlRaManagedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaManagedFlag.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaManagedFlag.setDescription('When enabled, it indicates that hosts receiving this RA must use a stateful address configuration protocol to obtain an address in the addition to the addresses derived from the stateless address configuration.')
swL3Ipv6CtrlRaOtherConfigFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6CtrlRaOtherConfigFlag.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6CtrlRaOtherConfigFlag.setDescription('When enabled, it indicates that hosts receiving this RA must use a stateful address configuration protocol to obtain an on-link address configuration information.')
swL3Ipv6AddressCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5), )
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlTable.setDescription('This table contain IPv6 address information for each IP interface.')
swL3Ipv6AddressCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3Ipv6AddressCtrlInterfaceName"), (0, "DGS3427-L3MGMT-MIB", "swL3Ipv6Address"), (0, "DGS3427-L3MGMT-MIB", "swL3Ipv6AddressCtrlPrefixLen"))
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlEntry.setDescription('A list of information about a specific IPv6 address.')
swL3Ipv6AddressCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlInterfaceName.setDescription('This object indicates the name of the IP interface. ')
swL3Ipv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 2), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6Address.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6Address.setDescription('Specify the IPv6 address.')
swL3Ipv6AddressCtrlPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlPrefixLen.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlPrefixLen.setDescription('Indicates the prefix length of this IPv6 address.')
swL3Ipv6AddressCtrlPreferredLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlPreferredLifeTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlPreferredLifeTime.setDescription('Indicates the number of seconds that an address, based on the specified prefix, using the stateless address configuration, remains in preferred state. For an infinite valid lifetime, the value can be set to 0xffffffff.')
swL3Ipv6AddressCtrlValidLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlValidLifeTime.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlValidLifeTime.setDescription('Indicates the number of seconds that an address, based on the specified prefix, using the stateless address configuration, remains valid. For an infinite valid lifetime, the value can be set to 0xffffffff.')
swL3Ipv6AddressCtrlOnLinkFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlOnLinkFlag.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlOnLinkFlag.setDescription('When enabled, the address implied by the specified prefix is available on the link where the RA message is received.')
swL3Ipv6AddressCtrlAutonomousFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlAutonomousFlag.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlAutonomousFlag.setDescription('When enabled, the specified prefix will be used to create an autonomous address configuration.')
swL3Ipv6AddressCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlState.setDescription('This variable displays the status of the entry. The status is used for creating, modifying, and deleting instances of the objects in this table.')
swL3Ipv6AddressCtrlAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("manual", 1), ("dhcpv6", 2), ("stateless", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlAddressType.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6AddressCtrlAddressType.setDescription('This object indicates the type of the IPv6 address. manual(1): the IPv6 address is configured by user. dhcpv6(2): the IPv6 address is assigned by DHCPv6 server. stateless(3): the IPv6 address is assigned by router advertisement.')
swL3Ipv6DHCPv6CPDAddrCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 6), )
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlTable.setDescription('This table contain the information of the IPv6 address which based on DHCPv6 client PD.')
swL3Ipv6DHCPv6CPDAddrCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 6, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName"), (0, "DGS3427-L3MGMT-MIB", "swL3Ipv6DHCPv6CPDAddrCtrlPrefixName"), (0, "DGS3427-L3MGMT-MIB", "swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr"), (0, "DGS3427-L3MGMT-MIB", "swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen"))
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlEntry.setDescription('A list of information about a specific DHCPv6 Client PD IPv6 address.')
swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName.setDescription('This object indicates the name of the IP interface. ')
swL3Ipv6DHCPv6CPDAddrCtrlPrefixName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlPrefixName.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlPrefixName.setDescription('This object indicates the name of the prefix based on which the IPv6 address will be generate. ')
swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 6, 1, 3), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr.setDescription('Specify the suffix of the IPv6 address.')
swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen.setDescription('Indicates the prefix length of this IPv6 address.')
swL3Ipv6DHCPv6CPDAddrCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 1, 6, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3Ipv6DHCPv6CPDAddrCtrlState.setDescription('This variable displays the status of the entry. The status is used for creating and deleting instances of the objects in this table.')
swL3IpFdbInfoTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 2, 1), )
if mibBuilder.loadTexts: swL3IpFdbInfoTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoTable.setDescription('A table that contains forwarding and/or filtering information. This information is used by the switch in determining how to propagate the received IP packets.')
swL3IpFdbInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 2, 1, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3IpFdbInfoIpAddr"))
if mibBuilder.loadTexts: swL3IpFdbInfoEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoEntry.setDescription('Information about a specific IP address for which the bridge has some forwarding and/or filtering information.')
swL3IpFdbInfoIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoIpAddr.setDescription('A IP address for which switch has forwarding and/or filtering information.')
swL3IpFdbInfoIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 2, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoIpSubnetMask.setDescription('A IP net mask for this interface.for which switch has forwarding and/or filtering information.')
swL3IpFdbInfoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoPort.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoPort.setDescription("Either the value '0', or the port number of the port on which packet having a IP address equal to the value of the corresponding instance of swL3IpFdbInfoIpAddr has been seen. A value of '0' indicates that the port number has not been learned but that switch does have some forwarding/filtering information about this address.")
swL3IpFdbInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("static", 2), ("dynamic", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpFdbInfoType.setStatus('current')
if mibBuilder.loadTexts: swL3IpFdbInfoType.setDescription('The status of this entry.')
swL3IpArpAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3IpArpAgingTime.setStatus('current')
if mibBuilder.loadTexts: swL3IpArpAgingTime.setDescription('The timeout period in minutes for aging out dynamically learned arp information.')
swL3IpStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 5), )
if mibBuilder.loadTexts: swL3IpStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteTable.setDescription("This entity's IP static Routing table.")
swL3IpStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 5, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3IpStaticRouteDest"), (0, "DGS3427-L3MGMT-MIB", "swL3IpStaticRouteMask"), (0, "DGS3427-L3MGMT-MIB", "swL3IpStaticRouteNextHop"))
if mibBuilder.loadTexts: swL3IpStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteEntry.setDescription("A particular route to a particular destination, under a particular policy. Once an entry be built,it shouldn't be modified.That is,it just support create and delete action.")
swL3IpStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteDest.setDescription('The destination IP address of this route. This object may not take a Multicast (Class D) address value. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the swL3IpStaticRouteMask object is not equal to x.')
swL3IpStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the swL3IpStaticRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the swL3IpStaticRouteMask by reference to the IP Address Class. Any assignment (implicit or otherwise) of an instance of this object to a value x must be rejected if the bitwise logical-AND of x with the value of the corresponding instance of the swL3IpStaticRouteDest object is not equal to swL3IpStaticRouteDest.')
swL3IpStaticRouteBkupState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("backup", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3IpStaticRouteBkupState.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteBkupState.setDescription('The routing state for this route.The value SHOULD be primary(1) or backup(2).')
swL3IpStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 5, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteNextHop.setDescription('On remote routes, the address of the next sys- tem en route; Otherwise, 0.0.0.0.')
swL3IpStaticRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteMetric.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteMetric.setDescription('The routing metric for this route.')
swL3IpStaticRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3), ("active", 4), ("inActive", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3IpStaticRouteStatus.setStatus('current')
if mibBuilder.loadTexts: swL3IpStaticRouteStatus.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry resides in the table. active(4) - the nextHop of this entry exists in the ARP table. inActive(5) - the next hop of this entry does not exist in the ARP table.')
swL3RelayDhcpMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1))
swL3RelayDhcpState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDhcpState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpState.setDescription('This object indicates Dhcp Relay function is enabled or disabled.')
swL3RelayDhcpHopCount = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDhcpHopCount.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpHopCount.setDescription('This object indicates the maximum number of router hops that the BOOTP packets can cross.')
swL3RelayDhcpTimeThreshold = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDhcpTimeThreshold.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpTimeThreshold.setDescription('This object indicates the minimum time in seconds within which the switch must relay the Dhcp request. If this time is exceeded, the switch will drop the Dhcp packet.')
swL3RelayDhcpCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 4), )
if mibBuilder.loadTexts: swL3RelayDhcpCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpCtrlTable.setDescription('This table specifys the IP address as a destination to forward (relay) DHCP packets to.')
swL3RelayDhcpCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 4, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3RelayDhcpCtrlInterfaceName"), (0, "DGS3427-L3MGMT-MIB", "swL3RelayDhcpCtrlServer"))
if mibBuilder.loadTexts: swL3RelayDhcpCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpCtrlEntry.setDescription('A list of information specifies the IP address as a destination to forward (relay) DHCP packets to.')
swL3RelayDhcpCtrlInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayDhcpCtrlInterfaceName.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpCtrlInterfaceName.setDescription('The name of the IP interface.')
swL3RelayDhcpCtrlServer = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayDhcpCtrlServer.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpCtrlServer.setDescription('The DHCP server IP address.')
swL3RelayDhcpCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDhcpCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpCtrlState.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
swL3RelayDhcpOption82State = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDhcpOption82State.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpOption82State.setDescription('This object indicates DHCP Relay Option 82 function is enabled or disabled.')
swL3RelayDhcpOption82CheckState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDhcpOption82CheckState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpOption82CheckState.setDescription('This object indicates DHCP Relay Option 82 Check function is enabled or disabled.')
swL3RelayDhcpOption82Policy = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("replace", 0), ("drop", 1), ("keep", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDhcpOption82Policy.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDhcpOption82Policy.setDescription('This object indicates DHCP Relay Option 82 Policy.')
swL3RelayDnsState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsState.setDescription('This object indicates DNS Relay function is enabled or disabled.')
swL3RelayDnsPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsPrimaryServer.setDescription('This object indicates the address of the primary DNS server.')
swL3RelayDnsSecondaryServer = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsSecondaryServer.setDescription('This object indicates the address of the secondary DNS server.')
swL3RelayDnsCacheState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsCacheState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCacheState.setDescription('This object indicates DNS Relay cache is enabled or disabled.')
swL3RelayDnsStaticTableState = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsStaticTableState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsStaticTableState.setDescription('This object indicates DNS Relay static table is enabled or disabled.')
swL3RelayDnsCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 6), )
if mibBuilder.loadTexts: swL3RelayDnsCtrlTable.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlTable.setDescription('This table display the current DNS relay static table.')
swL3RelayDnsCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 6, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3RelayDnsCtrlDomainName"), (0, "DGS3427-L3MGMT-MIB", "swL3RelayDnsCtrlIpAddr"))
if mibBuilder.loadTexts: swL3RelayDnsCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlEntry.setDescription('A list of information display the current DNS relay static table.')
swL3RelayDnsCtrlDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayDnsCtrlDomainName.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlDomainName.setDescription('The domain name of the entry.')
swL3RelayDnsCtrlIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RelayDnsCtrlIpAddr.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlIpAddr.setDescription('The IP address of the entry.')
swL3RelayDnsCtrlState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("valid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RelayDnsCtrlState.setStatus('current')
if mibBuilder.loadTexts: swL3RelayDnsCtrlState.setDescription('This object indicates the status of this entry. other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object, and then the corresponding entry will be removed from the table. valid(3) - this entry is reside in the table.')
swL3DHCPRelayOption60 = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8))
swL3DHCPRelayOption60State = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DHCPRelayOption60State.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60State.setDescription('This object indicates DHCP relay option 60 function is enabled or disabled. ')
swL3DHCPRelayOption60DefMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("relay", 1), ("drop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefMode.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefMode.setDescription('This object indicates default mode that has no option 60 mathcing rules. relay(1): means to relay the packet to the IP address which is specified by swL3DHCPRelayOption60DefRelayIp. drop(2): means to drop the packet. ')
swL3DHCPRelayOption60DefTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 3), )
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefTable.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefTable.setDescription('This table indicates the default relay servers for the packet that has no option 60 mathcing rules. ')
swL3DHCPRelayOption60DefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 3, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3DHCPRelayOption60DefRelayIp"))
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefEntry.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefEntry.setDescription('A list of information indicates the default relay servers for the packet that has no option 60 mathcing rules. ')
swL3DHCPRelayOption60DefRelayIp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefRelayIp.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefRelayIp.setDescription('This object indicates the IP address of default relay server.')
swL3DHCPRelayOption60DefRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefRowStatus.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60DefRowStatus.setDescription('This object indicates the status of this entry.')
swL3DHCPRelayOption60Table = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 4), )
if mibBuilder.loadTexts: swL3DHCPRelayOption60Table.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60Table.setDescription('This table indicates the relay servers for the packet at option 60 rules.')
swL3DHCPRelayOption60Entry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 4, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3DHCPRelayOption60String"), (0, "DGS3427-L3MGMT-MIB", "swL3DHCPRelayOption60RelayIp"))
if mibBuilder.loadTexts: swL3DHCPRelayOption60Entry.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60Entry.setDescription('A list of information indicates the relay servers for the packet at option 60 rules.')
swL3DHCPRelayOption60String = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 4, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3DHCPRelayOption60String.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60String.setDescription('This object indicates string of this entry. Note that it is theoretically possible for a valid string to exceed the allowed length of an SNMP object identifier, and thus be impossible to represent in tables in this MIB that are indexed by string.')
swL3DHCPRelayOption60RelayIp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3DHCPRelayOption60RelayIp.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60RelayIp.setDescription('This object indicates the IP address of relay server.')
swL3DHCPRelayOption60MatchType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("exact", 1), ("partial", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3DHCPRelayOption60MatchType.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60MatchType.setDescription('This object indicates match state of this entry. exact(1): means the option 60 string in the packet must full match with the specified string. partial(2): means the option 60 string in the packet only need partial match with the specified string. ')
swL3DHCPRelayOption60RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 8, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3DHCPRelayOption60RowStatus.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption60RowStatus.setDescription('This object indicates the status of this entry.')
swL3DHCPRelayOption61 = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9))
swL3DHCPRelayOption61State = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DHCPRelayOption61State.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61State.setDescription('This object indicates DHCP relay option 61 function is enabled or disabled. ')
swL3DHCPRelayOption61DefMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("relay", 1), ("drop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DHCPRelayOption61DefMode.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61DefMode.setDescription('This object indicates default mode that has no option 61 mathcing rules. relay(1): means to relay the packet to the IP address which is specified by swL3DHCPRelayOption61DefRelayIp. drop(2): means to drop the packet. ')
swL3DHCPRelayOption61DefRelayIp = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3DHCPRelayOption61DefRelayIp.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61DefRelayIp.setDescription("This object indicates the IP address of default relay server that has no option 61 mathcing rules. Pay attention to when swL3DHCPRelayOption61Mode is: relay(1): this object must be set together. drop(2): this object can not be set, and it always returns '0.0.0.0'. ")
swL3DHCPRelayOption61Table = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 4), )
if mibBuilder.loadTexts: swL3DHCPRelayOption61Table.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61Table.setDescription('This table indicates the relay servers for the packet at option 61 rules.')
swL3DHCPRelayOption61Entry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 4, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3DHCPRelayOption61ClientType"), (0, "DGS3427-L3MGMT-MIB", "swL3DHCPRelayOption61ClientID"))
if mibBuilder.loadTexts: swL3DHCPRelayOption61Entry.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61Entry.setDescription('A list of information indicates the relay servers for the packet at option 61 rules. ')
swL3DHCPRelayOption61ClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mac", 1), ("string", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3DHCPRelayOption61ClientType.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61ClientType.setDescription('This object indicates client type of this entry. mac(1): means the client-ID which is the MAC address of client. string(2): means the client-ID which is specified string by administrator. ')
swL3DHCPRelayOption61ClientID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3DHCPRelayOption61ClientID.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61ClientID.setDescription('This object indicates string of this entry. When swL3DHCPRelayOption61ClientType is mac(1), the format of this object should be XX-XX-XX-XX-XX-XX (MAC address). Note that it is theoretically possible for a valid string to exceed the allowed length of an SNMP object identifier, and thus be impossible to represent in tables in this MIB that are indexed by string. ')
swL3DHCPRelayOption61Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("relay", 1), ("drop", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3DHCPRelayOption61Mode.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61Mode.setDescription('This object indicates mode of this entry. relay(1): means to relay the packet to the IP address which is specified by swL3DHCPRelayOption61RelayIp. drop(2): means to drop the packet. ')
swL3DHCPRelayOption61RelayIp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 4, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3DHCPRelayOption61RelayIp.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61RelayIp.setDescription("This object indicates the IP address of relay server. Pay attention to when swL3DHCPRelayOption61Mode is: relay(1): this object must be set together. drop(2): this object can not be set, and it always returns '0.0.0.0'. ")
swL3DHCPRelayOption61RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 3, 1, 9, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3DHCPRelayOption61RowStatus.setStatus('current')
if mibBuilder.loadTexts: swL3DHCPRelayOption61RowStatus.setDescription('This object indicates the status of this entry.')
swL3RouteRedistriTable = MibTable((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 5), )
if mibBuilder.loadTexts: swL3RouteRedistriTable.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriTable.setDescription("Route redistribution allows routers on the network that are running different routing protocols to exchange routing information. This is accomplished by comparing the routes stored in the varios routers' routing tables and assigning appropriate metrics. This information is then exchanged among the various routers according to the individual routers current routing protocol.")
swL3RouteRedistriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 5, 1), ).setIndexNames((0, "DGS3427-L3MGMT-MIB", "swL3RouteRedistriSrcProtocol"), (0, "DGS3427-L3MGMT-MIB", "swL3RouteRedistriDstProtocol"))
if mibBuilder.loadTexts: swL3RouteRedistriEntry.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriEntry.setDescription('A list of information displaying the route redistribution table.')
swL3RouteRedistriSrcProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("static", 4), ("local", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RouteRedistriSrcProtocol.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriSrcProtocol.setDescription('Allows the selection of the protocol of the source device.')
swL3RouteRedistriDstProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("rip", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RouteRedistriDstProtocol.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriDstProtocol.setDescription('Allows the selection of the protocol of the destination device.')
swL3RouteRedistriMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3RouteRedistriMetric.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriMetric.setDescription("Allows the entry of an OSPF interface cost. This is analogous to a Hop Count in the RIP routing protocol. The value '0' indicates default value.")
swL3RouteRedistriRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: swL3RouteRedistriRowStatus.setStatus('current')
if mibBuilder.loadTexts: swL3RouteRedistriRowStatus.setDescription('This object indicates the status of this entry.')
swL3RoutePreference = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 9))
swL3RoutePreferenceRIP = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RoutePreferenceRIP.setStatus('current')
if mibBuilder.loadTexts: swL3RoutePreferenceRIP.setDescription('Used to configure the route preference of RIP.')
swL3RoutePreferenceStatic = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 9, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RoutePreferenceStatic.setStatus('current')
if mibBuilder.loadTexts: swL3RoutePreferenceStatic.setDescription('Used to configure the route preference of Static.')
swL3RoutePreferenceLocal = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 9, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: swL3RoutePreferenceLocal.setStatus('current')
if mibBuilder.loadTexts: swL3RoutePreferenceLocal.setDescription('Used to read the route preference of Local.')
swL3RoutePreferenceDefault = MibScalar((1, 3, 6, 1, 4, 1, 171, 11, 70, 2, 3, 9, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swL3RoutePreferenceDefault.setStatus('current')
if mibBuilder.loadTexts: swL3RoutePreferenceDefault.setDescription('Used to configure the route preference of Default.')
mibBuilder.exportSymbols("DGS3427-L3MGMT-MIB", swL3Ipv6CtrlTable=swL3Ipv6CtrlTable, swL3Ipv6AddressCtrlTable=swL3Ipv6AddressCtrlTable, swL3RelayDhcpHopCount=swL3RelayDhcpHopCount, swL3RoutePreference=swL3RoutePreference, swL3Ipv6AddressCtrlAutonomousFlag=swL3Ipv6AddressCtrlAutonomousFlag, swL3IpCtrlSecondary=swL3IpCtrlSecondary, swL3RelayDhcpMgmt=swL3RelayDhcpMgmt, swL3IpArpAgingTime=swL3IpArpAgingTime, swL3DHCPRelayOption60=swL3DHCPRelayOption60, swL3DHCPRelayOption60String=swL3DHCPRelayOption60String, swL3DHCPRelayOption61Entry=swL3DHCPRelayOption61Entry, swL3IpFdbInfoEntry=swL3IpFdbInfoEntry, swL3RoutePreferenceStatic=swL3RoutePreferenceStatic, swL3DHCPRelayOption61Mode=swL3DHCPRelayOption61Mode, swL3IpFdbInfoTable=swL3IpFdbInfoTable, swL3DHCPRelayOption60DefEntry=swL3DHCPRelayOption60DefEntry, swL3DHCPRelayOption60RelayIp=swL3DHCPRelayOption60RelayIp, swL3RelayMgmt=swL3RelayMgmt, swL3DHCPRelayOption60Table=swL3DHCPRelayOption60Table, swL3MgmtMIB=swL3MgmtMIB, swL3IpCtrlProxyArp=swL3IpCtrlProxyArp, swL3Ipv6AddressCtrlAddressType=swL3Ipv6AddressCtrlAddressType, swL3DevCtrlRIPState=swL3DevCtrlRIPState, swL3Ipv6AddressCtrlPreferredLifeTime=swL3Ipv6AddressCtrlPreferredLifeTime, swL3IpCtrlState=swL3IpCtrlState, swL3RelayDnsState=swL3RelayDnsState, swL3IpCtrlIpSubnetMask=swL3IpCtrlIpSubnetMask, swL3IpCtrlDhcpv6ClientPDState=swL3IpCtrlDhcpv6ClientPDState, swL3RoutePreferenceRIP=swL3RoutePreferenceRIP, swL3IpMgmt=swL3IpMgmt, swL3Ipv6DHCPv6CPDAddrCtrlState=swL3Ipv6DHCPv6CPDAddrCtrlState, swL3Ipv6CtrlEntry=swL3Ipv6CtrlEntry, swL3Ipv6CtrlRaMinRtrAdvInterval=swL3Ipv6CtrlRaMinRtrAdvInterval, swL3Ipv6AddressCtrlValidLifeTime=swL3Ipv6AddressCtrlValidLifeTime, swL3IpCtrlAllIpIfState=swL3IpCtrlAllIpIfState, swL3IpCtrlDhcpv6ClientPDPrefix=swL3IpCtrlDhcpv6ClientPDPrefix, swL3IpStaticRouteDest=swL3IpStaticRouteDest, swL3RelayDhcpCtrlInterfaceName=swL3RelayDhcpCtrlInterfaceName, swL3RelayDhcpTimeThreshold=swL3RelayDhcpTimeThreshold, PYSNMP_MODULE_ID=swL3MgmtMIB, swL3RouteRedistriMetric=swL3RouteRedistriMetric, swL3IpFdbInfoIpAddr=swL3IpFdbInfoIpAddr, swL3RelayDhcpCtrlTable=swL3RelayDhcpCtrlTable, swL3RelayDhcpCtrlEntry=swL3RelayDhcpCtrlEntry, swL3RoutePreferenceDefault=swL3RoutePreferenceDefault, swL3Ipv6CtrlNsRetransTimer=swL3Ipv6CtrlNsRetransTimer, swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName=swL3Ipv6DHCPv6CPDAddrCtrlInterfaceName, swL3Ipv6CtrlRaRetransTime=swL3Ipv6CtrlRaRetransTime, swL3IpCtrlEntry=swL3IpCtrlEntry, swL3RouteRedistriEntry=swL3RouteRedistriEntry, swL3RelayDnsPrimaryServer=swL3RelayDnsPrimaryServer, swL3RouteRedistriRowStatus=swL3RouteRedistriRowStatus, swL3DHCPRelayOption60DefMode=swL3DHCPRelayOption60DefMode, swL3IpStaticRouteTable=swL3IpStaticRouteTable, swL3Ipv6CtrlRaState=swL3Ipv6CtrlRaState, swL3DHCPRelayOption60DefRelayIp=swL3DHCPRelayOption60DefRelayIp, swL3DHCPRelayOption60RowStatus=swL3DHCPRelayOption60RowStatus, swL3IpStaticRouteMask=swL3IpStaticRouteMask, swL3RelayDnsCtrlIpAddr=swL3RelayDnsCtrlIpAddr, swL3DHCPRelayOption60DefTable=swL3DHCPRelayOption60DefTable, swL3IpCtrlIpDhcpOption12HostName=swL3IpCtrlIpDhcpOption12HostName, swL3IpCtrlMode=swL3IpCtrlMode, swL3IpCtrlIpv6LinkLocalAddress=swL3IpCtrlIpv6LinkLocalAddress, swL3RelayDhcpCtrlState=swL3RelayDhcpCtrlState, swL3IpCtrlIpDhcpOption12State=swL3IpCtrlIpDhcpOption12State, swL3IpCtrlIpDirectedBroadcastState=swL3IpCtrlIpDirectedBroadcastState, swL3RelayDhcpCtrlServer=swL3RelayDhcpCtrlServer, swL3DHCPRelayOption61RowStatus=swL3DHCPRelayOption61RowStatus, swL3IpFdbInfoIpSubnetMask=swL3IpFdbInfoIpSubnetMask, swL3DHCPRelayOption61=swL3DHCPRelayOption61, swL3Ipv6AddressCtrlInterfaceName=swL3Ipv6AddressCtrlInterfaceName, swL3IpStaticRouteNextHop=swL3IpStaticRouteNextHop, swL3IpCtrlMgmt=swL3IpCtrlMgmt, swL3Ipv6CtrlRaHopLimit=swL3Ipv6CtrlRaHopLimit, swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen=swL3Ipv6DHCPv6CPDAddrCtrlPrefixLen, swL3Ipv6CtrlRaMaxRtrAdvInterval=swL3Ipv6CtrlRaMaxRtrAdvInterval, swL3RelayDnsCacheState=swL3RelayDnsCacheState, swL3Ipv6CtrlRaManagedFlag=swL3Ipv6CtrlRaManagedFlag, swL3IpFdbInfoType=swL3IpFdbInfoType, swL3Ipv6CtrlInterfaceName=swL3Ipv6CtrlInterfaceName, swL3Ipv6AddressCtrlEntry=swL3Ipv6AddressCtrlEntry, swL3IpFdbInfoPort=swL3IpFdbInfoPort, swL3IpStaticRouteMetric=swL3IpStaticRouteMetric, swL3IpCtrlIpAddr=swL3IpCtrlIpAddr, swL3Ipv6CtrlMaxReassmblySize=swL3Ipv6CtrlMaxReassmblySize, swL3IpStaticRouteEntry=swL3IpStaticRouteEntry, swL3RouteRedistriTable=swL3RouteRedistriTable, swL3DHCPRelayOption60Entry=swL3DHCPRelayOption60Entry, swL3IpCtrlDhcpv6ClientPDPrefixLen=swL3IpCtrlDhcpv6ClientPDPrefixLen, Ipv6Address=Ipv6Address, swL3RelayDnsMgmt=swL3RelayDnsMgmt, swL3DHCPRelayOption61ClientID=swL3DHCPRelayOption61ClientID, swL3IpFdbMgmt=swL3IpFdbMgmt, swL3Ipv6CtrlRaOtherConfigFlag=swL3Ipv6CtrlRaOtherConfigFlag, swL3RelayDnsStaticTableState=swL3RelayDnsStaticTableState, swL3IpCtrlIpv6LinkLocalAutoState=swL3IpCtrlIpv6LinkLocalAutoState, swL3IpCtrlIfIndex=swL3IpCtrlIfIndex, swL3Ipv6CtrlRaReachableTime=swL3Ipv6CtrlRaReachableTime, swL3IpStaticRouteBkupState=swL3IpStaticRouteBkupState, swL3RouteRedistriSrcProtocol=swL3RouteRedistriSrcProtocol, swL3IpCtrlDhcpv6ClientPDPrefixName=swL3IpCtrlDhcpv6ClientPDPrefixName, swL3IpStaticRouteStatus=swL3IpStaticRouteStatus, swL3RelayDnsCtrlState=swL3RelayDnsCtrlState, swL3Ipv6DHCPv6CPDAddrCtrlTable=swL3Ipv6DHCPv6CPDAddrCtrlTable, swL3RelayDnsCtrlDomainName=swL3RelayDnsCtrlDomainName, swL3IpCtrlAdminState=swL3IpCtrlAdminState, swL3DHCPRelayOption61DefRelayIp=swL3DHCPRelayOption61DefRelayIp, swL3IpCtrlInterfaceName=swL3IpCtrlInterfaceName, swL3Ipv6AddressCtrlPrefixLen=swL3Ipv6AddressCtrlPrefixLen, swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr=swL3Ipv6DHCPv6CPDAddrCtrlIPv6addr, swL3DHCPRelayOption60State=swL3DHCPRelayOption60State, swL3DHCPRelayOption61Table=swL3DHCPRelayOption61Table, swL3IpCtrlTable=swL3IpCtrlTable, swL3RelayDhcpOption82CheckState=swL3RelayDhcpOption82CheckState, swL3Ipv6Address=swL3Ipv6Address, swL3DHCPRelayOption60DefRowStatus=swL3DHCPRelayOption60DefRowStatus, swL3IpCtrlVlanName=swL3IpCtrlVlanName, swL3DHCPRelayOption60MatchType=swL3DHCPRelayOption60MatchType, swL3RelayDnsSecondaryServer=swL3RelayDnsSecondaryServer, swL3DevMgmt=swL3DevMgmt, swL3IpCtrlLocalProxyArp=swL3IpCtrlLocalProxyArp, swL3Ipv6CtrlRaLifeTime=swL3Ipv6CtrlRaLifeTime, swL3DHCPRelayOption61ClientType=swL3DHCPRelayOption61ClientType, swL3DevCtrl=swL3DevCtrl, swL3RoutePreferenceLocal=swL3RoutePreferenceLocal, swL3RouteRedistriDstProtocol=swL3RouteRedistriDstProtocol, swL3RelayDnsCtrlEntry=swL3RelayDnsCtrlEntry, swL3RelayDhcpOption82State=swL3RelayDhcpOption82State, swL3RelayDhcpState=swL3RelayDhcpState, swL3DHCPRelayOption61RelayIp=swL3DHCPRelayOption61RelayIp, swL3Ipv6AddressCtrlState=swL3Ipv6AddressCtrlState, swL3DHCPRelayOption61DefMode=swL3DHCPRelayOption61DefMode, swL3Ipv6DHCPv6CPDAddrCtrlPrefixName=swL3Ipv6DHCPv6CPDAddrCtrlPrefixName, swL3IpCtrlDhcpv6ClientState=swL3IpCtrlDhcpv6ClientState, swL3RelayDhcpOption82Policy=swL3RelayDhcpOption82Policy, swL3RelayDnsCtrlTable=swL3RelayDnsCtrlTable, swL3Ipv6DHCPv6CPDAddrCtrlEntry=swL3Ipv6DHCPv6CPDAddrCtrlEntry, swL3DHCPRelayOption61State=swL3DHCPRelayOption61State, swL3IpCtrlIpv6LinkLocalPrefixLen=swL3IpCtrlIpv6LinkLocalPrefixLen, swL3Ipv6AddressCtrlOnLinkFlag=swL3Ipv6AddressCtrlOnLinkFlag)

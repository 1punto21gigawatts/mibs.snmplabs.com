#
# PySNMP MIB module DECHUB900-ERPTR-MIB-V3-0 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DECHUB900-ERPTR-MIB-V3-0
# Produced by pysmi-0.3.4 at Wed May  1 12:37:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, iso, TimeTicks, NotificationType, ObjectIdentity, IpAddress, Counter64, MibIdentifier, Counter32, Bits, Gauge32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "iso", "TimeTicks", "NotificationType", "ObjectIdentity", "IpAddress", "Counter64", "MibIdentifier", "Counter32", "Bits", "Gauge32", "Integer32")
DisplayString, PhysAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "PhysAddress", "TextualConvention")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
decHub900 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11))
repeater = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5))
rptrVersion1 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1))
rptrExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1))
erptrBasicPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1))
erptrAddrDBPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2))
erptrDprPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3))
erptrSecurityPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4))
erptrMauPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5))
erptrAddrLearnPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6))
erptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7))
erptrRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1))
erptrGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 2))
erptrPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3))
erptrAddrDBRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 1))
erptrAddrDBGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 2))
erptrAddrDBPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 3))
erptrDprRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 1))
erptrDprGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 2))
erptrDprPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3))
erptrSecurityRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1))
erptrSecurityGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 2))
erptrSecurityPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3))
erptrMauRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 1))
erptrMauGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 2))
erptrMauPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3))
erptrAddrLearnRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 1))
erptrAddrLearnGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 2))
erptrAddrLearnPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3))
erptrMonitorRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 1))
erptrMonitorGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 2))
erptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 3))
erptrAutoPartitionAlg = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("enhanced", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrAutoPartitionAlg.setReference('Reference IEEE 802.3 Std, 9.6.6 Auto-Partitioning/Reconnection.')
if mibBuilder.loadTexts: erptrAutoPartitionAlg.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAutoPartitionAlg.setDescription('The auto-partition algorithm protects the network from certain fault conditions which can halt all LAN communications. A media short or break, a faulty connector, or faulty or missing media termination, are examples of such conditions. If a repeater detects such faults on any of its ports, it isolates the faulty segment from the network. A repeater does not respond to input received from an auto-partitioned port, except to determine if the fault condition has been removed. A repeater continues to transmit data to an auto-partitioned port. Setting this object to standard(1) causes the repeater to implement the IEEE 802.3 standard auto-partitioning algorithm. If the repeater detects any of the following conditions on a given port, this algorithm isolates that port from the network. 1. Excessive length collision 2. Excessive number of consecutive collisions Setting this object to enhanced(2) causes the repeater to implement an augmented auto-partitioning algorithm. This option protects the LAN from a greater range of fault conditions. If the repeater detects any of the following conditions on a given port, this algorithm isolates that port from the network. 1. Excessive length collision 2. Excessive number of consecutive collisions 3. No receive activity during transmission (no carrier loop back) 4. Excessive length input message (jabber) 5. Transmit carrier drop (one or more lapses in the input message during a single output message without a collision) 6. Internal detectable port failures Some implementations may not support setting this object to all defined enumerated values. A badValue error is returned if an attempt is made to set this object to an unsupported value. Note: The state of this object is preserved when the repeater undergoes a power-up reset.')
erptrAutoPartitionReconnectAlg = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("txOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrAutoPartitionReconnectAlg.setReference('Reference IEEE 802.3 Std, 9.6.6 Auto-Partitioning/Reconnection')
if mibBuilder.loadTexts: erptrAutoPartitionReconnectAlg.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAutoPartitionReconnectAlg.setDescription("The auto-partition reconnection algorithm defines the criteria for determining that a malfunction on an auto-partitioned port has been cleared. The auto-partitioned port reconnects and becomes a fully functional repeater port when these conditions are met. Reconnection criteria vary depending upon the auto-partition reason and reconnection algorithm. Setting this object to standard(1) causes the repeater to implement the IEEE 802.3 standard auto-partition reconnection algorithm. This algorithm reconnects a port auto-partitioned due to excessive length collisions or excessive number of consecutive collisions when the port transmits or receives a packet without detecting a collision. Setting this object to tx_only(2) causes the repeater to implement a more stringent auto-partition reconnection algorithm. This algorithm reconnects a port auto-partitioned due to excessive length collisions or excessive number of consecutive collisions only when the port transmits a packet without detecting a collision. This algorithm provides a higher level of confidence that all faults have been removed, resulting in a more robust fault isolation mechanism. Some implementations may not support setting this object to all defined enumerated values. A badValue error is returned if an attempt is made to set this object to an unsupported value. The reconnection criteria for ports auto-partitioned due to no receive activity during transmission, excessive length input message, transmit carrier drop, and internal detectable port failures are not affected by this object's value. Note: The state of this object is preserved when the repeater undergoes a power-up reset.")
erptrJamBits = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("jb96", 1), ("jb128", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrJamBits.setReference('Reference IEEE 802.3 Std, 9.5.6 Collision Handling')
if mibBuilder.loadTexts: erptrJamBits.setStatus('mandatory')
if mibBuilder.loadTexts: erptrJamBits.setDescription('When a repeater detects a collision on any of the ports to which it is transmitting, it transmits a jam signal to all of the ports to which it is connected. This object specifies the minimum amount of time a repeater transmits a jam signal after it detects a collision. See the IEEE 802.3 standard for more details regarding collision detection and handling. Setting this object to jb96(1) causes the repeater to transmit jam for at least 96 bit times after it detects a collision. This setting complies with the IEEE 802.3 standard specification for the minimum jam time. Setting this object to jb128(1) causes the repeater to transmit jam for at least 128 bits times after it detects a collision. Some repeaters, designed prior to the development of the IEEE 802.3 specification, jam for a minimum of 128 bit times after they detect collisions. It may be desirable for all the repeaters on the LAN to perform the same collision handling function. This setting provides a backwards compatibility mode when older repeaters are present in the network. Some implementations may not support setting this object to all defined enumerated values. A badValue error is returned if an attempt is made to set this object to an unsupported value. Note: If an implementation supports multiple minimum jam time settings, the default value for this object is jb96(1). Note: The state of this object is preserved when the repeater undergoes a power-up reset.')
erptrHealthTextChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrHealthTextChanges.setReference('Reference RFC 1516 repeater MIB')
if mibBuilder.loadTexts: erptrHealthTextChanges.setStatus('mandatory')
if mibBuilder.loadTexts: erptrHealthTextChanges.setDescription('This counter increments each time the rptrHealthText object defined in RFC 1516 is modified.')
erptrTotalPortEvents = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrTotalPortEvents.setReference('Reference RFC 1516 repeater MIB')
if mibBuilder.loadTexts: erptrTotalPortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: erptrTotalPortEvents.setDescription("The total number of times any port in the repeater became not operational or auto-partitioned, or the media for any ports' MAUs became unavailable. This object is a summation of the erptrPortPartitions and erptrMauMediaAvailableChanges counters of all the ports and MAUs in the repeater.")
erptrTotalRptrErrors = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrTotalRptrErrors.setReference('Reference RFC 1516 repeater MIB')
if mibBuilder.loadTexts: erptrTotalRptrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: erptrTotalRptrErrors.setDescription('The total number of errors which have occured on all the groups in a repeater. This object is a summation of the values of the rptMonitorGroupTotalErrors as defined in RFC 1516 for all of the groups in a repeater.')
erptrJabberProtectionAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrJabberProtectionAdminStatus.setReference('Reference RFC 1516 repeater MIB')
if mibBuilder.loadTexts: erptrJabberProtectionAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrJabberProtectionAdminStatus.setDescription("The jabber protection function automatically disables a port whenever it detects a very long input event (or jabber) on that port. Once disabled, the port will neither transmit nor receive data. The rptrOperStatus object for such a port will report notOperational(2). The erptrPortPartitionReason for such a port will report jabberAndMgmtPart(7). The port will remain in this state until the port's rptrPortAdminStatus object is set to enabled(1). Setting this object to enabled(1) enables the jabber protection function on all manageable repeater ports. Setting this object to disabled(2) disables the jabber protection function on all manageable repeater ports. Some implementations may not support setting this object to all defined enumerated values. A badValue error is returned if an attempt is made to set this object to an unsupported value. Note: The state of this object is preserved when the repeater undergoes a power-up reset.")
erptrTotalPorts = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrTotalPorts.setStatus('mandatory')
if mibBuilder.loadTexts: erptrTotalPorts.setDescription('The total number of front panel ports in the repeater. This object is summation of rptrPortCapacity as defined in RFC1516 for each group. This does not include the thinwire port for the repeater')
erptrPMDCarrierCardType = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unknown", 1), ("type10Base", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrPMDCarrierCardType.setReference('Reference. IEEE 802.3 Std, sections 8, 9.9, 10, 14, 16, 17, 18.')
if mibBuilder.loadTexts: erptrPMDCarrierCardType.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPMDCarrierCardType.setDescription('The value unknown(1) indicates card that connects to MOD-PMDs are not present. The value type10Base (2) indicates card that connects to MOD-PMDs are present and the PMDS that can be connected to this card are of type 10base T and belongs to the family of IEEE 802.3 (Ethernet-like) repeater products.')
erptrGroupTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 2, 1), )
if mibBuilder.loadTexts: erptrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrGroupTable.setDescription('Table of descriptive and status information about the groups of ports.')
erptrGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 2, 1, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrGroupIndex"))
if mibBuilder.loadTexts: erptrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrGroupEntry.setDescription('An entry in the table containing information about a single group of ports.')
erptrGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrGroupIndex.setReference('Reference RFC 1516 repeater MIB')
if mibBuilder.loadTexts: erptrGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrGroupIndex.setDescription('This object identifies the group within the repeater for which this entry contains information. This value is never greater than the rptrGroupCapacity object defined in RFC 1516.')
erptrGroupTransmitCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrGroupTransmitCollisions.setReference('Reference IEEE 802.3 Std, Figure 9-2 Repeater Unit State Machine. Reference IETF Repeater MIB, RFC 1516.')
if mibBuilder.loadTexts: erptrGroupTransmitCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: erptrGroupTransmitCollisions.setDescription("This counter increments every time the port-group's repeater state machine enters the TRANSMIT COLLISION state from any state other than ONE PORT LEFT. See Figure 9-2 in [3]. This object is similar to the rptrMonitorTransmitCollisions object defined in the IETF repeater MIB [6]. This counter is useful when a repeater module's port-groups are configured to operate as independent repeater units. The minimum rollover time of this counter is approximately 16 hours.")
erptrGroupReset = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrGroupReset.setReference('Reference IEEE 802.3 Std, Figure 9-2 Repeater Unit State Machine. Reference IETF Repeater MIB, RFC 1516.')
if mibBuilder.loadTexts: erptrGroupReset.setStatus('mandatory')
if mibBuilder.loadTexts: erptrGroupReset.setDescription("Setting this object to reset(2) causes the port-group's repeater unit state machine to transition to the START state of Fig 9-2 in section 9 [3]. Setting this object to noReset(1) has no effect. The agent always returns the value noReset(1) when this object is read. This action does not reset management counters defined in either RFC 1516 or this document nor does is affect the portAdminStatus parameters defined in RFC 1516. This object is similar to the rptrReset object defined in RFC 1516 except that it affects only a single group instance. As a result of this action a rptrResetEvent trap is sent.")
erptrGroupLanTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrGroupLanTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: erptrGroupLanTotalOctets.setDescription("This object counts the total number of octets contained in non-collision packets transmitted by all the ports in this group. This counter increments by the same amount for all groups configured to operate in concert as a single repeater unit. This counter is the aggregate of traffic received from all external and internal ports in this group, including unmanaged internal ports which do not appear in this group's port table. This object may report a different value than the rptrMonitorGroupTotalOctets counter defined in the IETF repeater MIB [6], which is defined as the summation of the values of the rptrMonitorPortReadableOctets counters for all of the ports appearing in this group's port table. This statistic provides an indication of the total data transferred. The minimum rollover time of this counter is approximately 58 minutes.")
erptrPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1), )
if mibBuilder.loadTexts: erptrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortTable.setDescription('Table of descriptive and status information about the ports.')
erptrPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrPortGroupIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrPortIndex"))
if mibBuilder.loadTexts: erptrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortEntry.setDescription('An entry in the table, containing information about a single port.')
erptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information. This value is never greater than the rptrGroupCapacity object defined in RFC 1516')
erptrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value is never greater than the rptrGroupPortCapacity object defined in RFC 1516 for the associated group.')
erptrPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrPortName.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortName.setDescription('An administratively-assigned name for this repeater port. Note: The state of this object is preserved when the repeater undergoes a power-up reset.')
erptrPortPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrPortPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortPartitions.setDescription('This counter increments by one each time the repeater auto-partitions this port or the port becomes disabled or otherwise not operational.')
erptrPortPartitionReason = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("unknown", 1), ("notPartitioned", 2), ("managementPartitioned", 3), ("excessiveCollision", 4), ("excessiveCollisionAndMgmtPart", 5), ("consecutiveCollisions", 6), ("consecutiveCollisionsAndMgmtPart", 7), ("jabber", 8), ("jabberAndMgmtPart", 9), ("noCarrierLoopback", 10), ("noCarrierLoopbackandMgmtPart", 11), ("transmitCarrierDropout", 12), ("transmitCarrierDropoutAndMgmtPart", 13), ("forcedReconnection", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrPortPartitionReason.setReference('Reference IEEE 802.3 Std, 9.6.6 Auto-Partitioning/Reconnection.')
if mibBuilder.loadTexts: erptrPortPartitionReason.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortPartitionReason.setDescription("This object describes the reason why a port is currently auto-partitioned or otherwise disabled. A value of unknown(1) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of operational(1), as defined in RFC 1516, but the implementation cannot determine the exact reason why the port has auto-partitioned. A value of notPartitioned(2) indicates that the port currently has a rptrAutoPartitionState of notAutoPartitioned(1) and a rptrPortOperStatus of operational(1), as defined in RFC 1516. A value of managementPartitioned(3) indicates that the port currently has a rptrPortAdminStatus of disabled(2) (or is otherwise not operational) and a rptrAutoPartitionState of notAutoPartitioned(1), as defined in RFC 1516. However, if the port currently has a rptrPortAdminStatus of disabled(2) and a rptrAutoPartitionState of autoPartitioned(2), but the implementation cannot determine the exact reason why the port has auto-partitioned, then a value of managementPartitioned(3) is returned. A value of excessiveCollision(4) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of operational(1), as defined in RFC 1516. The repeater auto-partitioned this port because it detected an 'excessive length collision' condition. A value of excessiveCollisionAndMgmtPart(5) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of notOperational(2), as defined in RFC 1516. The repeater auto-partitioned this port because it detected an 'excessive length collision' condition. A value of consecutiveCollisions(6) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of operational(1), as defined in RFC 1516. The repeater auto-partitioned this port because it detected an 'excessive number of consecutive collisions' condition. A value of consecutiveCollisionsandMgmtPart(7) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of notOperational(2), as defined in RFC 1516. The repeater auto-partitioned this port because it detected an 'excessive number of consecutive collisions' condition. A value of jabber(8) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of operational(1), as defined in RFC 1516. The repeater auto-partitioned this port because it detected an 'excessive length input message' condition. A value of jabberAndMgmtPart(9) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of notOperational(2), as defined in RFC 1516. The repeater auto-partitioned this port because it detected an 'excessive length input message' condition. A value of noCarrierLoopback(10) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of operational(1), as defined in RFC 1516. The repeater auto-partitioned this port because it detected a 'no receive activity during transmission' condition. A value of noCarrierLoopbackAndMgmtPart(11) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of notOperational(2), as defined in RFC 1516. The repeater auto-partitioned this port because it detected a 'no receive activity during transmission' condition. A value of transmitCarrierDropout(12) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of operational(1), as defined in RFC 1516. The repeater auto-partitioned this port because it detected a 'transmit carrier drop' condition. A value of transmitCarrierDropoutAndMgmtPart(13) indicates that the port currently has a rptrAutoPartitionState of autoPartitioned(2) and a rptrPortOperStatus of notOperational(2), as defined in RFC 1516. The repeater auto-partitioned this port because it detected a 'transmit carrier drop' condition.")
erptrPortMAUType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 1), ("typeAUI", 2), ("type10Base5", 3), ("typeFoirl", 4), ("type10Base2", 5), ("type10BaseT", 6), ("type10BaseFP", 7), ("type10BaseFB", 8), ("type10BaseFL", 9), ("typeTelco10BaseT", 10), ("typeBackplaneThinwire", 11), ("typeRAUI", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrPortMAUType.setReference('Reference. IEEE 802.3 Std, sections 8, 9.9, 10, 14, 16, 17, 18.')
if mibBuilder.loadTexts: erptrPortMAUType.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortMAUType.setDescription("This object indicates the type of Medium Attachment Unit (MAU) associated with this port. unknown(1) - cannot determine MAU type. typeAUI(2) - no internal MAU, view from AUI. type10Base5(3) - thick coax MAU (per IEEE 802.3 Std, section 8) typeFoirl(4) - FOIRL MAU (per IEEE 802.3 Std, section 9.9) type10Base2(5) - thin coax MAU (per IEEE 802.3 Std, section 10) type10BaseT(6) - UTP Mau (per IEEE 802.3 Std, section 14) with - a RJ45 style physical connector. type10BaseFP(7) - passive fiber MAU (per IEEE 802.3 Std, section 16) type10BaseFB(8) - sync fiber MAU (per IEEE 802.3 Std, section 17) type10BaseFL(9) - asynch fiber MAU (per IEEE 802.3 Std, section 18) typeTelco10BaseT(10) - UTP Mau (per IEEE 802.3 Std, section 14) with a 50-pin Telco/champ style physical connector. typeBackplaneThinwire(11) - internal connection to the DEChub 90's, DEChub 900MS, or MS600's dedicated Ethernet LAN segment. typeRAUI(12) - no internal MAU, view from RAUI.")
erptrPortSQETestError = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("sqeTestDetected", 2), ("sqeTestNotDetected", 3), ("sqeTestMasked", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrPortSQETestError.setReference('Reference IEEE 802.3 Std., sections 7.2.1.2.3 and 9.4.1.')
if mibBuilder.loadTexts: erptrPortSQETestError.setStatus('mandatory')
if mibBuilder.loadTexts: erptrPortSQETestError.setDescription('This object indicates whether or not a port has detected SQE Test messages from its attached MAU. The value of this object persists between packets. This object is useful in detecting configuration errors which could seriously impact network performance. According to the IEEE 802.3 standard, MAUs associated with repeaters must not implement the signal_quality_error (SQE) message Test function. MAUs implementing this function generate a short collision announcement to their attachment unit interfaces (AUIs) following the transmission of every packet. Repeaters may interpret this test message as an actual collision event and attempt to propagate the collision by transmitting a jam signal to all of its other ports. A value of unknown(1) indicates that an implementation does not have the ability to determine if it is receiving SQE Test messages. A value of sqeTestDetected(2) indicates that a SQE Test message was detected after the transmission of the last packet out this port. This message was interpreted as a collision, extended to a full Jam pattern and transmitted out every other repeater port. A value of sqeTestNotDetected(3) indicates that a SQE Test message was not detected after the transmission of the last packet out this port. A value of sqeTestMasked(4) indicates that a SQE Test message was detected after the transmission of the last packet out this port but this message was ignored and not interpreted as a collision. This value is used by those implementations which offer SQE Test Masking functions.')
erptrAddrDBTableCapacity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrDBTableCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrDBTableCapacity.setDescription('This object specifies the maximum number of MAC addresses which can be stored in erptrAddrDBPortAddrTable.')
erptrAddrDBPortAddrTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 3, 1), )
if mibBuilder.loadTexts: erptrAddrDBPortAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrDBPortAddrTable.setDescription('A table of port-mapping information about MAC addresses detected by the repeater.')
erptrAddrDBPortAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 3, 1, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrAddrDBPortPhyAddr"))
if mibBuilder.loadTexts: erptrAddrDBPortAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrDBPortAddrEntry.setDescription('An entry in the table containing port-mapping information about a single MAC address.')
erptrAddrDBPortPhyAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 3, 1, 1, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrDBPortPhyAddr.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrDBPortPhyAddr.setDescription('This object identifies the source address of a readable frame received from a port in the agents port table.')
erptrAddrDBPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrDBPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrDBPortGroupIndex.setDescription("This object identifies the group containing the port on which this entry's MAC address was seen.")
erptrAddrDBPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrDBPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrDBPortIndex.setDescription("This object identifies the port within the group on which this entry's MAC address was seen.")
erptrDprTotalStateChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrDprTotalStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprTotalStateChanges.setDescription('This counter increments whenever the erptrDprLinkStateChanges counter for any entry in erptrDprLinkTable increments. This object is not necessarily the sum of the current values of the erptrDprLinkStateChanges objects for all entries in erptrDprLinkTable.')
erptrDprLinkTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1), )
if mibBuilder.loadTexts: erptrDprLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkTable.setDescription('Table of redundant link configuration and status information.')
erptrDprLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrDprLinkGroupIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrDprLinkPortIndex"))
if mibBuilder.loadTexts: erptrDprLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkEntry.setDescription("An entry in the table containing information describing a single redundant link's configuration and status.")
erptrDprLinkGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrDprLinkGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkGroupIndex.setDescription('This object identifies the group containing the port which is a member of the dual-redundant link for which this entry contains information. This value is never greater than rptrGroupCapacity.')
erptrDprLinkPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrDprLinkPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkPortIndex.setDescription('This object identifies the port within the group which is a member of the dual-redundant link for which this entry contains information. If erptrDprLinkType is set to redundantMaster(1) this port is the master primary port of the redundant link. If erptrDprLinkType is set to redundantResponder(2) this port is a responder port which may be connected to either the primary or secondary link. This value is never greater than rptrGroupPortCapacity for the associated group.')
erptrDprLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("redundantMaster", 1), ("redundantResponder", 2))).clone('redundantResponder')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrDprLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkType.setDescription("Setting this object to redundantMaster(1) causes the repeater to configure the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex as a Master port on the primary segment of a dual-redundant link. This also implies that an additional port on this repeater module is configured as a Master port on the secondary segment of the dual-redundant link (as specified by erptrDprSecondaryGroupIndex and erptrDprSecondaryPortIndex). This port is in the active state by default following a reset or re-initialization. Setting this object to redundantResponder(2) causes the repeater to configure the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex as a responder port in a dual-redundant link. This port may be connected to either the primary or secondary link. This port is in the active state by default following a reset or re-initialization. Note: Once this table entry has been validated (i.e. erptrDprLinkEntryStatus is set to valid(1)), the agent does not allow this object to be set to any value other than the present setting. Any attempt to do otherwise results in a badValue error. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrDprLinkEntryStatus is set to valid(1).")
erptrDprLinkToggle = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noToggle", 1), ("toggle", 2))).clone('noToggle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrDprLinkToggle.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkToggle.setDescription('If erptrDprLinkType equals redundantMaster, setting this object to toggle(2) causes a redundant link specified by this table entry to undergo a state change. That is, the repeater forces the previously active link segment into the standby state and the previously inactive link segment into the active state. If erptrDprLinkType equals redundantResponder, setting this object to toggle(2) has no effect. Setting this object to noToggle(1) has no effect. The agent always returns a value of noToggle(1) when this object is read.')
erptrDprLinkOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("redundancyNotOperational", 1), ("masterPrimaryActive", 2), ("masterPrimaryStandby", 3), ("masterPrimaryLinkFailure", 4), ("responderOk", 5), ("responderLinkFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrDprLinkOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkOperStatus.setDescription('This object reports the operational status of either the redundant master primary port or the redundant responder port associated with this entry (as specified by erptrDprLinkType). A value of redundancyNotOperational(1) indicates that redundancy is not operational on the link associated with this entry. A value of masterPrimaryActive(2) indicates: - redundancy is operational on the link associated with this entry. - the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex is configured as a master port on the primary segment of the redundant link associated with this entry. - the primary segment of the dual-redundant link is currently the active link. - No link failures are currently detected on the primary link. A value of masterPrimaryStandby(3) indicates: - redundancy is operational on the link associated with this entry. - the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex is configured as a master port on the primary segment of the redundant link associated with this entry. - the primary segment of the dual-redundant link is currently the standby link. - No link failures are currently detected on the primary link. A value of masterPrimaryLinkFailure(4) indicates: - redundancy is operational on the link associated with this entry. - the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex is configured as a master port on the primary segment of the redundant link associated with this entry. - a link failure condition exists on the primary segment of the dual-redundant link (which may have caused a fail-over to the secondary link). A value of responderOk(5) indicates: - redundancy is operational on the link associated with this entry. - the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex is configured as a redundant responder port which may be connected to either the primary or the secondary segment of the redundant link associated with this entry. - the redundant responder port has not detected any link failures on the segment to which it is connected. A value of responderLinkFailure(6) indicates: - redundancy is operational on the link associated with this entry. - the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex is configured as a redundant responder port which may be connected to either the primary or the secondary segment of the redundant link associated with this entry. - the redundant responder port has detected a link failure on the segment to which it is connected.')
erptrDprSecondaryGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrDprSecondaryGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprSecondaryGroupIndex.setDescription("This object identifies the group containing the master redundant port on the secondary segment of the redundant link associated with this entry. This secondary redundant port acts in concert with the primary redundant port specified in erptrDprLinkGroupIndex and erptrDprLinkPortIndex to provide a fault-tolerant dual-redundant link when erptrDprLinkType is set to redundantMaster(1). The value of this object is irrelevant when erptrDprLinkType is set to any other value. When erptrDprLinkType is set to redundantMaster(1), the value of this object must be between 1 and rptrGroupCapacity for redundancy to be operational. Note: Once this table entry has been validated (i.e. erptrDprLinkEntryStatus is set to valid(1)), the agent does not allow this object to be set to any value other than the present setting. Any attempt to do otherwise results in a badValue error. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrDprLinkEntryStatus is set to valid(1).")
erptrDprSecondaryPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrDprSecondaryPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprSecondaryPortIndex.setDescription("This object identifies the master redundant port (within the group) on the secondary segment of the redundant link associated with this entry. This secondary redundant port acts in concert with the primary redundant port specified in erptrDprLinkGroupIndex and erptrDprLinkPortIndex to provide a fault-tolerant dual-redundant link when erptrDprLinkType is set to redundantMaster(1). The value of this object is irrelevant when erptrDprLinkType is set to any other value. When erptrDprLinkType is set to redundantMaster(1), the value of this object must be between 1 and rptrPortCapacity for this group for redundancy to be operational. Note: Once this table entry has been validated (i.e. erptrDprLinkEntryStatus is set to valid(1)), the agent does not allow this object to be set to any value other than the present setting. Any attempt to do otherwise results in a badValue error. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrDprLinkEntryStatus is set to valid(1).")
erptrDprSecondaryOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("redundancyNotOperational", 1), ("masterSecondaryActive", 2), ("masterSecondaryStandby", 3), ("masterSecondaryLinkFailure", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrDprSecondaryOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprSecondaryOperStatus.setDescription('This object reports the operational status of the master redundant secondary port associated with this entry (as specified by erptrDprSecondaryGroupIndex and erptrDprSecondaryPortIndex). A value of redundancyNotOperational(1) indicates: - redundancy is not operational on the link associated with this entry. - this table entry is associated with a responder redundant port which makes the specification of a master secondary redundant port irrelevant. A value of masterSecondaryActive(2) indicates: - redundancy is operational on the link associated with this entry. - the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex is configured as a master port on the primary segment of the redundant link associated with this entry. - the secondary segment of the dual-redundant link is currently the active link. - No link failures are detected on the secondary link. A value of masterSecondaryStandby(3) indicates: - redundancy is operational on the link associated with this entry. - the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex is configured as a master port on the primary segment of the redundant link associated with this entry. - the secondary segment of the dual-redundant link is currently the standby link. - No link failures are detected on the secondary link. A value of masterSecondaryLinkFailure(4) indicates: - redundancy is operational on the link associated with this entry. - the port specified by erptrDprLinkGroupIndex and erptrDprLinkPortIndex is configured as a master port on the primary segment of the redundant link associated with this entry. - a link failure condition exists on the secondary segment of the dual-redundant link (which may have caused a fail-over to the primary link).')
erptrDprLinkName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrDprLinkName.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkName.setDescription("An administratively-assigned name for this dual-redundant link. The default value for this object is a zero-length string. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrDprLinkEntryStatus is set to valid(1).")
erptrDprLinkStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrDprLinkStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkStateChanges.setDescription('This counter increments by one whenever the value of erptrDprLinkOperStatus or erptrDprSecondaryOperStatus changes.')
erptrDprLinkEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 3, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrDprLinkEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrDprLinkEntryStatus.setDescription("The status of this table entry. Setting this object to createRequest(2) adds a new entry in this table. Immediately after completing the create operation, the agent sets this object to underCreation(3). An existing instance of this object cannot be set to createRequest(2). Entries exist in the underCreation(3) state until the management station sets this object to valid(1) or aborts, setting this object to invalid(4). The repeater does not use the information in this entry to enforce redundancy unless this object is set to valid (1). Setting this object to invalid(4) has the effect of deleting this entry from the table. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrDprLinkEntryStatus is set to valid(1).")
erptrSecurityRptrSecurityViolations = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityRptrSecurityViolations.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrSecurityViolations.setDescription('This counter increments by one each time the repeater detects an intrusion security violation on any repeater port. This counter is the summation of the erptrSecurityPortCtrlViolations counters for all the ports in all the groups of the repeater.')
erptrSecurityRptrLogTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 2), )
if mibBuilder.loadTexts: erptrSecurityRptrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrLogTable.setDescription('A table of intrusion security violations. The maximum number of entries saved in the log table is implementation-specific.')
erptrSecurityRptrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 2, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrSecurityRptrLogIndex"))
if mibBuilder.loadTexts: erptrSecurityRptrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrLogEntry.setDescription('An entry in the table containing information describing a single intrusion security violation.')
erptrSecurityRptrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityRptrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrLogIndex.setDescription('An index that uniquely identifies an entry in the log table.')
erptrSecurityRptrLogGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityRptrLogGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrLogGroupIndex.setDescription('This object identifies the group containing the port on which the intrusion security violation occurred.')
erptrSecurityRptrLogPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityRptrLogPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrLogPortIndex.setDescription('This object identifies the port within the group on which this intrusion security violation occurred.')
erptrSecurityRptrLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityRptrLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrLogTime.setDescription('This object identifies the value of sysUpTime at the time the repeater detected the intrusion security violation.')
erptrSecurityRptrLogPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 2, 1, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityRptrLogPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrLogPhysAddress.setDescription("An intrusion security violation occurs when a repeater port receives a data packet with a source address not found in that port's authorized address list. This object identifies the unauthorized MAC address which caused the intrusion security violation.")
erptrSecurityRptrLogCapacity = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityRptrLogCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityRptrLogCapacity.setDescription('This object specifies the maximum number of intrusion security violation log entries which can appear in erptrSecurityRptrLogTable at any one time.')
erptrSecurityPortCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 1), )
if mibBuilder.loadTexts: erptrSecurityPortCtrlTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortCtrlTable.setDescription('A table of security configuration, control and status information.')
erptrSecurityPortCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 1, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrSecurityPortCtrlGroupIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrSecurityPortCtrlPortIndex"))
if mibBuilder.loadTexts: erptrSecurityPortCtrlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortCtrlEntry.setDescription('An entry in the table containing information describing the security configuration and status of a single port.')
erptrSecurityPortCtrlGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityPortCtrlGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortCtrlGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information. This value is never greater than rptrGroupCapacity.')
erptrSecurityPortCtrlPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityPortCtrlPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortCtrlPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value is never greater than rptrGroupPortCapacity for the associated group.')
erptrSecurityPortCtrlEavesdropMode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrSecurityPortCtrlEavesdropMode.setReference('Reference RFC 1516 repeater MIB')
if mibBuilder.loadTexts: erptrSecurityPortCtrlEavesdropMode.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortCtrlEavesdropMode.setDescription("Setting this object to enabled (1) enables eavesdrop prevention on this port. When eavesdrop prevention is active, the repeater compares unicast destination addresses of packets being transmitting out this port with the port's authorized address list. The repeater jams/garbles those packets whose destination addresses do not appear in the port's authorized address list. The length of the garbled packet is the same as the length of the original packet. Packets with multicast or broadcast destination addresses are not affected by eavesdrop prevention. If no authorized addresses are assigned to this port in erptrSecurityPortAddrTable when this object equals enabled(1), an implementation may optionally enforce eavesdrop prevention based upon the (dynamically changing) last source address seen (as indicated by rptrAddrTrackLastSourceAddr or rptrAddrTrackNewLastSrcAddress). Otherwise, an implementation may simply not actively enforce eavesdrop prevention on a port with no assigned authorized addresses. Setting this object to disabled (2) disables eavesdrop prevention on this port. Note: The default value for this object is disabled (2). Note: The state of this object is preserved when the repeater undergoes a power-up reset.")
erptrSecurityPortCtrlIntrusionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("notifyOnly", 2), ("jamUnauthPackets", 3), ("disablePort", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrSecurityPortCtrlIntrusionMode.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortCtrlIntrusionMode.setDescription("To detect intrusion security violations, the repeater compares source addresses of packets received from this port with the addresses in the port's authorized address list (as specified in erptrSecurityPortAddrTable). If the addresses do not match, the intrusion is counted, logged in erptrSecurityRptrLogTable, and and the security rule specified by this object is enforced. Intrusion protection is not active unless authorized addresses are assigned to this port in erptrSecurityPortAddrTable. Setting this object to disabled (1) disables intrusion detection/prevention on this port. Setting this object to notifyOnly (2) causes the repeater to take no action, other than logging entries in erptrSecurityRptrLogTable, when it detects intrusion violations. Setting this object to jamUnauthPackets (3) causes the repeater to jam/garble unauthorized packets before they are repeated to all other repeater ports. Setting this object to disablePort (4) causes the repeater to disable this port if it detects intrusion security violations on this port. The port may be re-enabled by setting rptrPortAdminStatus to enabled. Some implementations may not support setting this object to all defined enumerated values. A badValue error is returned if an attempt is made to set this object to an unsupported value. Note: The default value for this object is disabled (1). Note: The state of this object is preserved when the repeater undergoes a power-up reset.")
erptrSecurityPortCtrlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("securityOperational", 1), ("securityNotOperational", 2), ("violationPortDisabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityPortCtrlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortCtrlOperStatus.setDescription('The value securityOperational(1) indicates that eavesdrop prevention and/or intrusion detection/protection are enabled and actively functioning on this port. The value securityNotOperational(2) indicates that neither eavesdrop prevention nor intrusion detection/protection are actively functioning on this port. Intrusion detection/protection may be enabled on this port but it will not be operational unless an authorized address is assigned to this port in erptrSecurityPortAddrTable. The value violationPortDisabled (3) indicates that the port is disabled due to an intrusion security violation. The port may be re-enabled by setting rptrPortAdminStatus to enabled.')
erptrSecurityPortCtrlViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrSecurityPortCtrlViolations.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortCtrlViolations.setDescription('A count of the number intrusion security violations detected on this port.')
erptrSecurityPortAddrTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 2), )
if mibBuilder.loadTexts: erptrSecurityPortAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortAddrTable.setDescription('A table of authorized MAC addresses mapped to repeater ports. The repeater uses these addresses to enforce security.')
erptrSecurityPortAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 2, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrSecurityPortAddrGroupIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrSecurityPortAddrPortIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrSecurityPortAddrPhysAddress"))
if mibBuilder.loadTexts: erptrSecurityPortAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortAddrEntry.setDescription('An entry in the table containing information to assign a single authorized MAC address to a single repeater port.')
erptrSecurityPortAddrGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrSecurityPortAddrGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortAddrGroupIndex.setDescription("This object identifies the group containing the port for which this entry contains information. This value is never greater than rptrGroupCapacity. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrSecurityPortAddrStatus is valid (1).")
erptrSecurityPortAddrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrSecurityPortAddrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortAddrPortIndex.setDescription("This object identifies the port within the group for which this entry contains information. This value can never be greater than rptrGroupPortCapacity for the associated group. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrSecurityPortAddrStatus is valid (1).")
erptrSecurityPortAddrPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 2, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrSecurityPortAddrPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortAddrPhysAddress.setDescription("This object identifies an authorized MAC address assigned to this repeater port for use in enforcing eavesdrop prevention and intrusion detection/protection. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrSecurityPortAddrStatus is valid (1).")
erptrSecurityPortAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 4, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrSecurityPortAddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrSecurityPortAddrStatus.setDescription("The status of this table entry. Setting this object to createRequest(2) adds a new entry in this table mapping the authorized MAC address specified by this entry to the port specified by this entry. Immediately after completing the create operation, the agent sets this object to underCreation(3). An existing instance of this object cannot be set to createRequest(2). Entries exist in the underCreation(3) state until the management station sets this object to valid(1) or aborts, setting this object to invalid(4). The repeater does not use the information in this entry to enforce security unless this object is set to valid (1). Setting this object to invalid(4) has the effect of deleting this entry from the table. Note: The state of this object is preserved when the repeater undergoes a power-up reset if the value of this entry's erptrSecurityPortAddrStatus is valid (1).")
erptrMauTotalMediaUnavailable = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMauTotalMediaUnavailable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauTotalMediaUnavailable.setDescription('This object returns the total number of MAUs in the repeater whose erptrMauMediaAvailable objects are equal to notAvailable(4), remoteFault(5), or invalidSignal(6).')
erptrMauTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1), )
if mibBuilder.loadTexts: erptrMauTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauTable.setDescription('Table of descriptive and status information about MAU(s) attached to the ports of a repeater.')
erptrMauEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrMauGroupIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrMauPortIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrMauIndex"))
if mibBuilder.loadTexts: erptrMauEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauEntry.setDescription('An entry in the table containing information about a single MAU.')
erptrMauGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMauGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauGroupIndex.setDescription('This object identifies the group containing the port to which the MAU described by this entry is connected.')
erptrMauPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMauPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauPortIndex.setDescription('This object identifies the port within group to which the MAU described by this entry is connected.')
erptrMauIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMauIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauIndex.setDescription('The object uniquely identifies a MAU connected to a port within the group that is described by this entry.')
erptrMauLinkTestAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrMauLinkTestAdminStatus.setReference('Reference IEEE 802.3 Std., sections 9.9.2.1 and 14.2.1.7.')
if mibBuilder.loadTexts: erptrMauLinkTestAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauLinkTestAdminStatus.setDescription("Link test functions detect certain types of media faults on point-to-point link segments connecting pairs of link-type MAUs (e.g. 10BASE-T, 10BASE-F, FOIRL). This object controls the link test function implemented by some link-type MAUs. Setting this object to enabled(1) causes the MAU to enable its link test function. Setting this object to disabled(2) causes the MAU to disable its link test function. Disabling a MAU's link test function can be useful for compatibility to link-type MAUs which do not implement a link test function. Link-type MAUs which implement link test functions but do not support software control of the functions allow this object to be set to enabled(1). A badValue error is returned if this object is set to any other value. Coax type MAUs (e.g. 10BASE5, 10BASE2) or any other MAUs which do not implement link test functions return disabled(2) when this object is read. These MAUs allow this object to be set to disabled(2) but return a badValue error if the object is set to any other value. Note: The state of this object is preserved when the repeater undergoes a power-up reset.")
erptrMauMediaPolarityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("polarityNotReversed", 1), ("polarityReversed", 2), ("polarityCorrected", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMauMediaPolarityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauMediaPolarityStatus.setDescription('A value of polarityNotReversed(1) indicates that the MAU senses that received data packet waveform polarity is correct. A value of polarityReversed(2) indicates that the MAU senses that received data packet waveform polarity is incorrect (i.e. reversed). Reversed polarity may indicate a wiring error, especially on 10Base-T links. A value of polarityCorrected(3) indicates that the MAU senses that received data packet waveform polarity is incorrect (i.e reversed, perhaps due to a wiring error) but the MAU has automatically corrected the polarity error. A value of unknown(4) indicates that the MAU does not have the ability to detect whether or not received data packet waveform polarity is correct.')
erptrMauMediaAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("available", 3), ("notAvailable", 4), ("remoteFault", 5), ("invalidSignal", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMauMediaAvailable.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, aMediaAvailable.')
if mibBuilder.loadTexts: erptrMauMediaAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauMediaAvailable.setDescription("If the MAU is link-type (FOIRL, 10BASE-T, 10BASE-F) then this object is equivalent to the link test fail state/low light function. For an AUI or a coax MAU this indicates whether or not loopback is detected on the DI circuit. The value of this attribute persists between packets for MAU types AUI, 10BASE5, 10BASE2, and 10BASE-FP. The value other(1) is returned if the mediaAvailable state is not one of 2 through 6. The value unknown(2) is returned when the MAU's true state is unknown; for example, when it is being initialized. At power-up or following a reset, the value of this attribute is unknown for AUI, coax, and 10BASE-FP MAUs. For these MAUs, loopback will be tested on each transmission during which no collision is detected. If DI is receiving input when DO returns to IDL after a transmission and there has been no collision during the transmission then loopback will be detected. The value of this attribute will only change during non-collided transmissions for AUI, coax, and 10BASE-FP MAUs. The value available(3) indicates that the link, light, or loopback is normal. The value notAvailable(4) indicates link loss, low light, or no loopback. The value remoteFault(5) indicates that a fault has been detected at the remote end of the link. The value invalidSignal(6) indicates that an invalid signal has been received from the other end of the link. Both remoteFault(5) and invalidSignal(6) apply only to MAUs of type 10BASE-FB.")
erptrMauMediaAvailableChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMauMediaAvailableChanges.setReference('Reference IEEE 802.3 MAU Mgt, 20.2.3.2, lostMediaCount.')
if mibBuilder.loadTexts: erptrMauMediaAvailableChanges.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauMediaAvailableChanges.setDescription('A count of the number of times that erptrMauMediaAvailable for this MAU instance leaves the state available(3).')
erptrMauMaxLinkLength = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 5, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("extended", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrMauMaxLinkLength.setReference('Reference IEEE 802.3 Std.')
if mibBuilder.loadTexts: erptrMauMaxLinkLength.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMauMaxLinkLength.setDescription('Link-type MAU (e.g. 10BASE-T, 10BASE-FL, FOIRL) standards define the maximum length of any one point-to-point link segment. Some MAUs may support a mode of operation that allows them to reliably communicate over longer link segments. This object configures the MAU to run it its standard max link length mode of operation or its extended max link length mode of operation. The mechanisms employed to achieve longer link segments is implementation-specific. The existence of configuration restrictions surrounding using a MAUs extended link length mode is implementation-specific. Setting this object to standard(1) causes the MAU to support only standard max link length configurations. Setting this object to extended(2) causes the MAU to support extended maximum link length configurations. The maximum link length supported by a MAU operating in this mode is implementation-specific. Any MAUs (including non-link, coax type MAUs) that do not support extended maximum link length configurations allow this object to be set to standard(1). A badValue error is returned if this object is set to any other value. Note: The state of this object is preserved when the repeater undergoes a power-up reset.')
erptrAddrLearnPortCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 1), )
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlTable.setDescription('A table of configuration, control and status information to manage the learning of the first N distinct MAC source addresses seen per port.')
erptrAddrLearnPortCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 1, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrAddrLearnPortCtrlGroupIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrAddrLearnPortCtrlPortIndex"))
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlEntry.setDescription('An entry in the table containing information describing the control and status first N distinct MAC source address learning of a single port.')
erptrAddrLearnPortCtrlGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information. This value is never greater than rptrGroupCapacity.')
erptrAddrLearnPortCtrlPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value is never greater than rptrGroupPortCapacity for the associated group.')
erptrAddrLearnPortCtrlCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlCapacity.setDescription('This object specifies the maximum number of distinct MAC source addresses the repeater can learn and save on this port.')
erptrAddrLearnPortCtrlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("enableLearning", 2), ("disableLearning", 3), ("clearLearnedAddresses", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlAdminStatus.setDescription('Setting this object to enableLearning(2) causes the agent to learn MAC source addresses from readable frames received on this port. The agent records distinct addresses (along with addresses previously learned on this port) in erptrAddrLearnAddressTable. The agent actively learns addresses on this port until one of the following events occurs: - The maximum allowable number of distinct addresses have been learned on this port, as specified by erptrAddrLearnPortCtrlCapacity. - The learning process is disabled by setting this object to disableLearning(3). The agent remembers learned addresses until this object is set to clearLearnedAddresses(4) or the module undergoes a power-up reset. Setting this object to disableLearning(3) causes the agent to stop learning addresses on this port, regardless of the number of addresses already learned and saved. Learning can be restarted on the port by setting this object to enableLearning(2). Setting this object to clearLearnedAddresses(4) causes the agent to delete any entries in erptrAddrLearnAddressTable associated with this port. If the value of erptrAddrLearnPortCtrlOperStatus for this port is learningEnabledAndActive(1) or learningEnabledAndStopped(2) when this object is set to clearLearnedAddresses(4), the agent will immediately begin learning new addresses on this port. Setting this object to other(1) has no effect. The agent always returns the value other(1) when this object is read.')
erptrAddrLearnPortCtrlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("learningEnabledAndActive", 1), ("learningEnabledAndStopped", 2), ("learningDisabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortCtrlOperStatus.setDescription('A value of learningEnabledAndActive(1) indicates that the agent is actively learning MAC source addresses from readable frames received on this port and recording them in erptrAddrLearnAddrTable. It implies that erptrAddrLearnPortCtrlAdminStatus had previously been set to enableLearning(2) and the port has not yet learned and saved the maximum allowable number of distinct addresses (as specified by erptrAddrLearnPortCtrlCapacity). A value of learningEnabledAndStopped(2) indicates that the agent is NOT currently actively learning MAC source addresses from readable frames received on this port. It implies that erptrAddrLearnPortCtrlAdminStatus had previously been set to enableLearning(2) but the port has learned and saved the maximum allowable number of distinct addresses (as specified by erptrAddrLearnPortCtrlCapacity). A value of learningDisabled(3) indicates that the agent is NOT actively learning distinct MAC source addresses from readable frames received on this port. It implies that erptrAddrLearnPortCtrlAdminStatus had previously been set to disableLearning(3).')
erptrAddrLearnPortAddressTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 2), )
if mibBuilder.loadTexts: erptrAddrLearnPortAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortAddressTable.setDescription("This table records the first N distinct MAC source addresses detected on readable frames received on each of the repeater's ports since address learning was last initiated. If a given port has not learned any addresses then no entries exist in the table for that port.")
erptrAddrLearnPortAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 2, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrAddrLearnPortAddressGroupIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrAddrLearnPortAddressPortIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrAddrLearnPortAddressIndex"))
if mibBuilder.loadTexts: erptrAddrLearnPortAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortAddressEntry.setDescription('An entry in the table containing information regarding a single MAC address learned on one repeater port.')
erptrAddrLearnPortAddressGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrLearnPortAddressGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortAddressGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information. This value is never greater than rptrGroupCapacity.')
erptrAddrLearnPortAddressPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrLearnPortAddressPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortAddressPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value can never be greater than rptrGroupPortCapacity for the associated group.')
erptrAddrLearnPortAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrLearnPortAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortAddressIndex.setDescription('This object identifies an index corresponding to a distinct MAC source address for which this entry contains information. This value can never be greater than erptrAddrLearnPortCtrlCapacity for the associated port.')
erptrAddrLearnPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 6, 3, 2, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrAddrLearnPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: erptrAddrLearnPortAddress.setDescription('This object identifies a distinct MAC source address of a readable frame received on the port associated with this entry.')
erptrMonitorPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 3, 1), )
if mibBuilder.loadTexts: erptrMonitorPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMonitorPortTable.setDescription('A table of extended performance and error statistics for the ports.')
erptrMonitorPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 3, 1, 1), ).setIndexNames((0, "DECHUB900-ERPTR-MIB-V3-0", "erptrMonitorPortGroupIndex"), (0, "DECHUB900-ERPTR-MIB-V3-0", "erptrMonitorPortIndex"))
if mibBuilder.loadTexts: erptrMonitorPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMonitorPortEntry.setDescription('An entry in the table containing extended performance and error statistics for a single port.')
erptrMonitorPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMonitorPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMonitorPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information. This value is never greater than rptrGroupCapacity.')
erptrMonitorPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMonitorPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMonitorPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value is never greater than rptrGroupPortCapacity for the associated group.')
erptrMonitorPortMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMonitorPortMulticastFrames.setReference('Reference IEEE 802.3 Std, 3.2.3.1 and 4.4.2.1')
if mibBuilder.loadTexts: erptrMonitorPortMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMonitorPortMulticastFrames.setDescription('This object is the number of valid multicast frames that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize, whose MAC-layer destination address field contains a multicast-group address, and for which the FCSError and CollisionEvent signals are not asserted. The approximate minimum time for rollover of this counter is 80 hours.')
erptrMonitorPortBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 11, 5, 1, 1, 7, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erptrMonitorPortBroadcastFrames.setReference('Reference IEEE 802.3 Std, 3.2.3.1 and 4.4.2.1')
if mibBuilder.loadTexts: erptrMonitorPortBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: erptrMonitorPortBroadcastFrames.setDescription('This object is the number of valid broadcast frames that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize, whose MAC-layer destination address field contains a broadcast address, and for which the FCSError and CollisionEvent signals are not asserted. The approximate minimum time for rollover of this counter is 80 hours.')
mibBuilder.exportSymbols("DECHUB900-ERPTR-MIB-V3-0", erptrGroupInfo=erptrGroupInfo, erptrRptrInfo=erptrRptrInfo, erptrSecurityPortCtrlViolations=erptrSecurityPortCtrlViolations, erptrMauPortInfo=erptrMauPortInfo, erptrAutoPartitionAlg=erptrAutoPartitionAlg, erptrSecurityPortCtrlEntry=erptrSecurityPortCtrlEntry, ema=ema, erptrGroupTable=erptrGroupTable, erptrDprLinkGroupIndex=erptrDprLinkGroupIndex, erptrMauLinkTestAdminStatus=erptrMauLinkTestAdminStatus, erptrDprRptrInfo=erptrDprRptrInfo, erptrSecurityPortCtrlTable=erptrSecurityPortCtrlTable, erptrSecurityPackage=erptrSecurityPackage, erptrDprLinkEntry=erptrDprLinkEntry, erptrSecurityPortCtrlPortIndex=erptrSecurityPortCtrlPortIndex, erptrMauGroupIndex=erptrMauGroupIndex, erptrMauEntry=erptrMauEntry, erptrAddrDBPortInfo=erptrAddrDBPortInfo, erptrDprPackage=erptrDprPackage, erptrTotalRptrErrors=erptrTotalRptrErrors, erptrTotalPorts=erptrTotalPorts, erptrSecurityRptrLogTable=erptrSecurityRptrLogTable, erptrSecurityPortAddrEntry=erptrSecurityPortAddrEntry, erptrAddrLearnPortCtrlPortIndex=erptrAddrLearnPortCtrlPortIndex, erptrPMDCarrierCardType=erptrPMDCarrierCardType, erptrBasicPackage=erptrBasicPackage, erptrAddrLearnRptrInfo=erptrAddrLearnRptrInfo, erptrSecurityPortCtrlEavesdropMode=erptrSecurityPortCtrlEavesdropMode, erptrPortName=erptrPortName, erptrDprPortInfo=erptrDprPortInfo, erptrSecurityRptrLogCapacity=erptrSecurityRptrLogCapacity, erptrSecurityRptrInfo=erptrSecurityRptrInfo, erptrAddrDBPortAddrTable=erptrAddrDBPortAddrTable, erptrDprLinkPortIndex=erptrDprLinkPortIndex, erptrHealthTextChanges=erptrHealthTextChanges, erptrAddrDBTableCapacity=erptrAddrDBTableCapacity, erptrDprSecondaryGroupIndex=erptrDprSecondaryGroupIndex, erptrAddrDBRptrInfo=erptrAddrDBRptrInfo, erptrPortTable=erptrPortTable, erptrPortInfo=erptrPortInfo, erptrDprLinkTable=erptrDprLinkTable, erptrAddrLearnPortCtrlEntry=erptrAddrLearnPortCtrlEntry, erptrDprSecondaryPortIndex=erptrDprSecondaryPortIndex, rptrExtensions=rptrExtensions, erptrSecurityRptrLogEntry=erptrSecurityRptrLogEntry, erptrDprTotalStateChanges=erptrDprTotalStateChanges, erptrSecurityGroupInfo=erptrSecurityGroupInfo, erptrSecurityPortCtrlIntrusionMode=erptrSecurityPortCtrlIntrusionMode, erptrGroupEntry=erptrGroupEntry, dec=dec, erptrAddrLearnPortAddressTable=erptrAddrLearnPortAddressTable, erptrAddrDBPortIndex=erptrAddrDBPortIndex, erptrMonitorPortIndex=erptrMonitorPortIndex, erptrAddrLearnPortAddressPortIndex=erptrAddrLearnPortAddressPortIndex, erptrMonitorPortGroupIndex=erptrMonitorPortGroupIndex, erptrMonitorPortInfo=erptrMonitorPortInfo, erptrAutoPartitionReconnectAlg=erptrAutoPartitionReconnectAlg, erptrAddrLearnPortCtrlCapacity=erptrAddrLearnPortCtrlCapacity, erptrMonitorPortTable=erptrMonitorPortTable, erptrMonitorPackage=erptrMonitorPackage, erptrAddrLearnPortAddressEntry=erptrAddrLearnPortAddressEntry, erptrJamBits=erptrJamBits, erptrSecurityPortInfo=erptrSecurityPortInfo, erptrAddrLearnPortCtrlGroupIndex=erptrAddrLearnPortCtrlGroupIndex, erptrJabberProtectionAdminStatus=erptrJabberProtectionAdminStatus, erptrGroupTransmitCollisions=erptrGroupTransmitCollisions, erptrAddrLearnPortCtrlTable=erptrAddrLearnPortCtrlTable, erptrAddrDBGroupInfo=erptrAddrDBGroupInfo, erptrSecurityPortAddrGroupIndex=erptrSecurityPortAddrGroupIndex, erptrSecurityPortAddrTable=erptrSecurityPortAddrTable, erptrSecurityRptrLogIndex=erptrSecurityRptrLogIndex, erptrDprLinkToggle=erptrDprLinkToggle, erptrSecurityPortAddrPhysAddress=erptrSecurityPortAddrPhysAddress, erptrMauRptrInfo=erptrMauRptrInfo, decHub900=decHub900, erptrSecurityPortAddrPortIndex=erptrSecurityPortAddrPortIndex, erptrPortPartitions=erptrPortPartitions, erptrDprLinkType=erptrDprLinkType, erptrSecurityPortCtrlGroupIndex=erptrSecurityPortCtrlGroupIndex, erptrGroupLanTotalOctets=erptrGroupLanTotalOctets, erptrDprGroupInfo=erptrDprGroupInfo, erptrPortIndex=erptrPortIndex, erptrMauTable=erptrMauTable, erptrMauIndex=erptrMauIndex, erptrSecurityRptrLogPortIndex=erptrSecurityRptrLogPortIndex, erptrMonitorRptrInfo=erptrMonitorRptrInfo, erptrAddrDBPortPhyAddr=erptrAddrDBPortPhyAddr, erptrDprLinkEntryStatus=erptrDprLinkEntryStatus, erptrTotalPortEvents=erptrTotalPortEvents, erptrPortEntry=erptrPortEntry, erptrMonitorPortMulticastFrames=erptrMonitorPortMulticastFrames, erptrDprLinkOperStatus=erptrDprLinkOperStatus, erptrGroupIndex=erptrGroupIndex, erptrMauTotalMediaUnavailable=erptrMauTotalMediaUnavailable, erptrMauPortIndex=erptrMauPortIndex, erptrMonitorPortEntry=erptrMonitorPortEntry, repeater=repeater, erptrPortGroupIndex=erptrPortGroupIndex, erptrAddrDBPortAddrEntry=erptrAddrDBPortAddrEntry, erptrMonitorGroupInfo=erptrMonitorGroupInfo, erptrDprSecondaryOperStatus=erptrDprSecondaryOperStatus, erptrSecurityRptrSecurityViolations=erptrSecurityRptrSecurityViolations, erptrGroupReset=erptrGroupReset, erptrMauMediaAvailable=erptrMauMediaAvailable, erptrDprLinkStateChanges=erptrDprLinkStateChanges, erptrPortPartitionReason=erptrPortPartitionReason, erptrSecurityPortCtrlOperStatus=erptrSecurityPortCtrlOperStatus, erptrDprLinkName=erptrDprLinkName, erptrAddrDBPortGroupIndex=erptrAddrDBPortGroupIndex, erptrSecurityRptrLogGroupIndex=erptrSecurityRptrLogGroupIndex, erptrAddrLearnPortInfo=erptrAddrLearnPortInfo, erptrAddrLearnPortAddressIndex=erptrAddrLearnPortAddressIndex, erptrMauMediaAvailableChanges=erptrMauMediaAvailableChanges, erptrMauGroupInfo=erptrMauGroupInfo, erptrAddrLearnPortAddressGroupIndex=erptrAddrLearnPortAddressGroupIndex, decMIBextension=decMIBextension, erptrAddrLearnPortCtrlAdminStatus=erptrAddrLearnPortCtrlAdminStatus, erptrMonitorPortBroadcastFrames=erptrMonitorPortBroadcastFrames, erptrPortMAUType=erptrPortMAUType, erptrAddrDBPackage=erptrAddrDBPackage, erptrAddrLearnPortCtrlOperStatus=erptrAddrLearnPortCtrlOperStatus, erptrPortSQETestError=erptrPortSQETestError, rptrVersion1=rptrVersion1, erptrMauPackage=erptrMauPackage, erptrSecurityPortAddrStatus=erptrSecurityPortAddrStatus, erptrMauMaxLinkLength=erptrMauMaxLinkLength, erptrAddrLearnGroupInfo=erptrAddrLearnGroupInfo, erptrAddrLearnPackage=erptrAddrLearnPackage, erptrMauMediaPolarityStatus=erptrMauMediaPolarityStatus, erptrSecurityRptrLogPhysAddress=erptrSecurityRptrLogPhysAddress, erptrSecurityRptrLogTime=erptrSecurityRptrLogTime, erptrAddrLearnPortAddress=erptrAddrLearnPortAddress)

#
# PySNMP MIB module BASIS-GENERIC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BASIS-GENERIC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:34:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
cardGeneric, = mibBuilder.importSymbols("BASIS-MIB", "cardGeneric")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, iso, Unsigned32, ModuleIdentity, Integer32, Bits, NotificationType, ObjectIdentity, TimeTicks, Counter64, Gauge32, MibIdentifier, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "iso", "Unsigned32", "ModuleIdentity", "Integer32", "Bits", "NotificationType", "ObjectIdentity", "TimeTicks", "Counter64", "Gauge32", "MibIdentifier", "IpAddress")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cardInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 2, 1))
cardInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 2, 2))
cardSelfTest = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 2, 3))
moduleSlotNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: moduleSlotNumber.setDescription('Slot number this card is present ')
functionModuleType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 12, 20, 21, 22, 23, 24, 25, 30, 31, 32, 33, 34, 35, 36, 37, 40, 41, 50, 51, 52, 53, 60, 61, 70, 71, 72, 73, 80, 90, 91, 100, 101, 110, 111, 120, 121, 130, 131, 132, 133, 134, 135, 136, 137, 140, 141, 150, 151, 563, 564, 787, 1000, 1001, 1002, 1003, 2000, 2001))).clone(namedValues=NamedValues(("other", 1), ("asc", 2), ("bnm-T3", 10), ("bnm-E3", 11), ("bnm-155", 12), ("srm-4T1E1", 20), ("srm-3T3", 21), ("srme-1OC3", 22), ("srme-1STS3", 23), ("srme-NOBC", 24), ("srm-3T3-NOBC", 25), ("frsm-4T1", 30), ("frsm-4E1", 31), ("frsm-4T1-C", 32), ("frsm-4E1-C", 33), ("frsm-hs1", 34), ("frsm-8T1", 35), ("frsm-8E1", 36), ("frsm-hs1b", 37), ("ausm-4T1", 40), ("ausm-4E1", 41), ("ausm-8T1", 50), ("ausm-8E1", 51), ("ausmB-8T1", 52), ("ausmB-8E1", 53), ("cesm-4T1", 60), ("cesm-4E1", 61), ("imatm-T3T1", 70), ("imatm-E3E1", 71), ("imatmB-8T1", 72), ("imatmB-8E1", 73), ("frasm-8T1", 80), ("cesm-8T1", 90), ("cesm-8E1", 91), ("bscsm-2", 100), ("bscsm-4", 101), ("atmt-8T1", 110), ("atmt-8E1", 111), ("frt-8T1", 120), ("frt-8E1", 121), ("frsm-2ct3", 130), ("frsm-2t3", 131), ("frsm-2e3", 132), ("frsm-hs2", 133), ("frsm-2t3b", 134), ("frsm-2e3b", 135), ("frsm-hs2b-hssi", 136), ("frsm-hs2b-12In1", 137), ("cesm-T3", 140), ("cesm-E3", 141), ("vism-8T1", 150), ("vism-8E1", 151), ("vism-pr-8T1", 563), ("vism-pr-8E1", 564), ("cesmB-8T1", 787), ("pxm1", 1000), ("pxm1-2t3e3", 1001), ("pxm1-4oc3", 1002), ("pxm1-oc12", 1003), ("rpm", 2000), ("rpm-pr", 2001))).clone('other')).setMaxAccess("readonly")
if mibBuilder.loadTexts: functionModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: functionModuleType.setDescription('This object holds the type of the card. The card can type is for Processor module as well as service module. ')
functionModuleDescription = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: functionModuleDescription.setStatus('mandatory')
if mibBuilder.loadTexts: functionModuleDescription.setDescription('Describes the card ')
functionModuleSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: functionModuleSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: functionModuleSerialNum.setDescription('Serial number of the function Module.')
functionModuleHWRev = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: functionModuleHWRev.setStatus('mandatory')
if mibBuilder.loadTexts: functionModuleHWRev.setDescription('Hardware revision number for function Module.')
functionModuleFWRev = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: functionModuleFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: functionModuleFWRev.setDescription('Firmware revision number of the function Module.')
functionModuleState = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 17))).clone(namedValues=NamedValues(("nocard", 1), ("standby", 2), ("active", 3), ("failed", 4), ("selfTest", 5), ("heldInReset", 6), ("boot", 7), ("mismatch", 8), ("unknown", 9), ("coreCardMisMatch", 10), ("blocked", 11), ("reserved", 12), ("hold", 13), ("notResponding", 14), ("cardinit", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: functionModuleState.setStatus('mandatory')
if mibBuilder.loadTexts: functionModuleState.setDescription("This object holds the status of a card in a particular shelf-slot. The possible values are : nocard(1) : card not present. standby(2) : card in standby state. The card is in ready state and will be ready to take over the service if the corresponding active card(redundant) fails. active(3) : card in active state. The card is providing the service. failed(4) : card in failed state. The card can come out of this state only after user intervention (Reset or running some CLI commands). selfTest(5) : online diagnostics is being run in card. heldInReset(6) : The card configuration is being cleared. No requests can be serviced. boot(7) : card in boot state. mismatch(8) : card is not compatible with the current configuration. Card was correctly provisioned earlier, however the card was replaced by an incompatible card. This state can be resolved by clearing the configuration, or replacing with the appropriate card. unknown(9) : could not determine the state coreCardMisMatch(10) : Controller Card(PXM/ASC etc) and SRM(Service Resource Module) combination does not match. blocked(11) : In case of 1:N redundancy configuration the secondary card(backup card) is covering one of the primary card and can not cover any other card in the group if there is a failure. Redundancy is blocked. hold(13) : The standby controller card assumes the hold state during PXM upgrades. In this state, the standby PXM will be running a different software but will be receiving all standby updates(BRAM and Database). This state is applicable only for MGX8250 Platform. notResponding(14): Response from the Service Module has become slow probably due to overloading of CPU. No recovery action is required on user part. At present, this state is applicable only for Router Blade(RPM). cardinit(17) : When the physical presence of card has been detected but the communication hasn't yet been established between the controller card (PXM) and Service Module. ")
functionModuleResetReason = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("powerUp", 1), ("parityError", 2), ("watchDog", 3), ("resourceOverflow", 4), ("clrAllCnf", 5), ("missingTask", 6), ("pxmLowVoltage", 7), ("resetByEventLogTask", 8), ("resetFromShell", 9), ("unknown", 10), ("resetFromPXM", 11), ("resetSys", 12), ("switchCC", 13), ("sCacheError", 14), ("swError", 15), ("upgrade", 16), ("restoreAllCnf", 17), ("driverError", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: functionModuleResetReason.setStatus('mandatory')
if mibBuilder.loadTexts: functionModuleResetReason.setDescription('Last reason for card to reset. The possible values are : powerUp(1) : power up parityError(2) : parity error watchDog(3) : watchdog resourceOverflow (4) : resource overflow clrAllCnf (5) : configuration of the shelf is cleared. missingTask (6) : task is missing pxmLowVoltage(7): low voltage detected on PXM resetByEventLogTask(8): resetFromShell(9): command is run from command shell unknown(10) : resetFromPXM(11) : Controller Card(PXM) reset the card. resetSys(12) : due to resetsys CLI Command. switchCC(13) : due to switch over CLI command. sCacheError(14) : swError(15) : software error. upgrade(16) : upgrade restoreAllCnf(17): restore configuration. driverError(18) : driver error. Valid values for VISM: powerUp, watchDog, resetFromShell and resetFromPXM. ')
lineModuleType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 48, 49, 50, 51, 60, 61, 62, 63, 70, 71, 80, 81, 500, 501, 502, 503, 504, 505, 506, 507, 511, 512, 513, 514, 515, 1006, 1050, 1051, 1052))).clone(namedValues=NamedValues(("other", 1), ("lm-ASC", 2), ("lm-DB15-4T1", 16), ("lm-DB15-4E1", 17), ("lm-BNC-4E1", 18), ("lm-DB15-4T1-R", 19), ("lm-DB15-4E1-R", 20), ("lm-BNC-4E1-R", 21), ("lm-RJ48-8T1", 22), ("lm-RJ48-8E1", 23), ("lm-SMB-8E1", 24), ("lm-RJ48-T3T1", 25), ("lm-RJ48-E3E1", 26), ("lm-RJ48-T3E1", 27), ("lm-SMB-E3E1", 28), ("lm-RJ48-E3T1", 29), ("lm-SMB-T3E1", 30), ("lm-T3E3-D", 32), ("lm-T3E3-B", 33), ("lm-155-SMF", 34), ("lm-155-UTP", 35), ("lm-RJ48-8T1-R", 48), ("lm-RJ48-8E1-R", 49), ("lm-SMB-8E1-R", 50), ("lm-3T3-B", 51), ("lm-HS1-4X21", 60), ("lm-HS1-3HSSI", 61), ("lm-HS1-4V35", 62), ("lm-12In1-8s", 63), ("lm-BSCSM-2", 70), ("lm-BSCSM-4", 71), ("lm-BNC-2T3", 80), ("lm-BNC-2E3", 81), ("pxm-ui", 500), ("smfir-1-622", 501), ("smflr-1-622", 502), ("smfir15-1-622", 503), ("smflr15-1-622", 504), ("mmf-4-155", 505), ("smfir-4-155", 506), ("smflr-4-155", 507), ("rj45-fe", 511), ("mmf-fe", 512), ("mmf-fddi", 513), ("smf-fddi", 514), ("rj45-4e", 515), ("pxm-ui-s3", 1006), ("lm-srme-1OC3-smlr", 1050), ("lm-srme-1OC3-smir", 1051), ("lm-srme-1OC3-smb", 1052))).clone('other')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: lineModuleType.setDescription('This object contains the Line Module(back card) type. Physically it is behind the backplane, normally with connectors for physical devices. These are specific to the front or functional modules. ')
lineModuleDescription = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineModuleDescription.setStatus('mandatory')
if mibBuilder.loadTexts: lineModuleDescription.setDescription('This object contains description of the line module.')
lineModuleSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineModuleSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: lineModuleSerialNum.setDescription('This object contains Serial number of the line module.')
lineModuleHWRev = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineModuleHWRev.setStatus('mandatory')
if mibBuilder.loadTexts: lineModuleHWRev.setDescription('This object contains Hardware revision for line module.')
lineModuleFWRev = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineModuleFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: lineModuleFWRev.setDescription('Firmware revision for line module. The current version does not have any firmware, hence will always contains zero length octet string.')
lineModuleState = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2), ("invalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineModuleState.setStatus('mandatory')
if mibBuilder.loadTexts: lineModuleState.setDescription('line module status.')
moduleTrapAlarmSeverity = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("minor", 1), ("major", 2), ("dontCare", 3), ("critical", 4), ("error", 5), ("warning", 6), ("notice", 7), ("info", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleTrapAlarmSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: moduleTrapAlarmSeverity.setDescription('This object is sent to managers as part of all Trap PDUs, to determine the module alarm severity. An implementation may not support all the possible values. The Possible values are : major (1) : Major Service has been impacted minor (2) : Minor Service has been lost dontCare (3) : severity is not applicable critical (4) : affects existing data traffic error (5) : error has occurred warning (6) : a threshold has been reached notice (7) : a normal but significant event has occurred info (8) : informational ')
mibVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 16), Integer32().clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mibVersionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mibVersionNumber.setDescription('MIB version number. Updated when any part of the MIB changes. ')
configChangeTypeBitMap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configChangeTypeBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: configChangeTypeBitMap.setDescription('Configuration change Type BitMap bit 0 set = Card Configuration Change bit 1 set = Line Configuration Change bit 2 set = Port Configuration Change bit 3 set = Chan Configuration Change bit 4 set = STUN protocol group configuration Change bit 5 set = STUN port configuration Change bit 6 set = STUN route configuration Change bit 7 set = BSTUN protocol configuration Change bit 8 set = BSTUN port configuration Change bit 9 set = BSTUN route configuration Change bit 10 set = FRASBNN route configuration Change bit 11 set = FRASBAN route configuration Change bit 12 set = SDLC port configuration Change bit 13 set = SDLC LS configuration Change bit 14 set = BSC port configuration Change bit 15 set = LLC port configuration Change bit 16 set = card LCN partition change (controller based only) bit 17 set = port resource partition change (under any partition type) bit 18 set = VISM Endpoint Configuration Change bit 19 set = Egress Q configuration change default value is 0, no change This object makes sense only in traps. A GET on this may not return a Useful result. Bit 19 is not applicable for MGX 8850 Release 1.x.x and MGX 8220 ')
configChangeObjectIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configChangeObjectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configChangeObjectIndex.setDescription("Configuration change object index, could be line number or port number or channel number depends on the type bitmap, for port resouce partition change (bit 17), this index is actually constructed by (portNum << 16 | controller) because the table has two indices. When the 'Line Configuration Change' bit is set, the configChangeObjectIndex has the following special meanings in IMATM and FRSM-2CT3 cards: IMATM - configChangeObjectIndex range between 1..8 indicates that the configuration change refers to the DS1 line index. A value of 9 indicates that the configuration change refers to the DS3 line index. FRSM-2CT3 - configChangeObjectIndex range between 1..56 indicates that the configuration change refers to the DS1 line index. A value of (128 + n) refers to DS3 line index numbered 'n'. This object makes sense only in traps. A GET on this may not return a Useful result. ")
configChangeStatus = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configChangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configChangeStatus.setDescription('This object is applicable only for traps. The SNMP operation may not be meaningful. The value contained in this object is same as the value of the other objects which are used for adding/deleting/modifying the row. The possible values are 0 - No meaning and is not applicable. 1 - add [ Row added ] 2 - delete [ Row deleted ] 3 - mod [ Row modified ] This value and value contained in configChangeTypeBitMap represent the configuration change operation. The default value is 0 and it does not represent any status.')
cardIntegratedAlarmBitMap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardIntegratedAlarmBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: cardIntegratedAlarmBitMap.setDescription('Bit position represents the different types of alarm for ASC: bit 0: ShelfFunctionModuleState (BNM only) (failed/boot/mismatch/heldinReset) bit 1: LineModuleState (BNM only) (notPresent/invalid) bit 2: ASMPhysicalAlarmState (BNM only) bit 3: ATMLMIFailure (ASC only) bit 4: LineAlarmState (BNM only) bit 5: LineStatisticalAlarmState (BNM only) bit 6: PLCPAlarmState (BNM only) bit 7: PLCPStatisticalAlarmState (BNM only) bit 8: SmConnectionFailureAlarm for SM: bit 0: ShelfFunctionModuleState (failed/boot/mismatch/heldinReset) bit 1: LineModuleState (notPresent/invalid) bit 2: PortLMIFailure bit 3: LineAlarmState bit 4: LineStatisticalAlarmState bit 5: FrameRelayPortState (RemoteLoopback/ FailedDueToLine/ FailedDueToSig) bit 6: ChannelState for PXM/SRM Only (MGX8850 Platfrom): Only those marked with SRM are valid for both PXM/SRM. The rest are valid only for PXM. bit 0 : ShelfFunctionModuleState bit 1 : Backcard Line Module (SRM/PXM) This Alarm is generated when the Line Module (Trunk Backcard) is removed or goes to a mismatch state(or backcard type is unknown). bit 2 : Backcard UIModule This Alarm is generated when the UI backcard is removed or goes to a mismatch state (or backcard type is unknown). bit 3 : ASM Physical Alarm This specifies whether any of the environmental monitoring components like Temperature, Voltage Supply, Fan Speed have gone into alarm. bit 4 : ATM LMI Failure bit 5 : Line Alarm (SRM/PXM) bit 6 : Line Statistical Alarm (SRM/PXM) bit 7 : Lines Alarm (SRM/PXM) bit 8 : PLCP Alarm bit 9 : PLCP Statistical Alarm bit 10 : Connections exist on removed SM bit 11 : Disk related Failure on first PXM slot bit 12 : Disk related Failure on second PXM slot The Disk Alarms are generated when any of the file operations on Disk like open,read,write, lseek etc fail. VSM Alarms bit 13 : Port LMI Failure bit 14 : Port State Alarm bit 15 : Channel Shelf Alarm bit 16 : Taskmon Task Suspended bit 17 : Excess Power Consumption bit 30 : bit set(1) major alarm, else (0) minor alarm ')
cleiCode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cleiCode.setStatus('mandatory')
if mibBuilder.loadTexts: cleiCode.setDescription('Common Language Equipment(CLEI) Code. ')
macAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 22), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macAddress.setStatus('mandatory')
if mibBuilder.loadTexts: macAddress.setDescription('Ethernet address (base address) stored in NVRAM, entered by manfacturing. ')
macAddrBlkSize = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macAddrBlkSize.setStatus('mandatory')
if mibBuilder.loadTexts: macAddrBlkSize.setDescription('The MAC address block size, entered by manufacturing. ')
finalTestTechnician = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: finalTestTechnician.setStatus('mandatory')
if mibBuilder.loadTexts: finalTestTechnician.setDescription('The Final Test Technician Employee Identification Number. ')
hwFailures = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwFailures.setStatus('mandatory')
if mibBuilder.loadTexts: hwFailures.setDescription('Hardware failure code.')
hwHistory = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwHistory.setStatus('mandatory')
if mibBuilder.loadTexts: hwHistory.setDescription('RMA Test History - RMA Failure Code.')
secLineModuleType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 48, 49, 50, 51, 60, 61, 62, 63, 70, 71, 80, 81, 500, 501, 502, 503, 504, 505, 506, 507, 511, 512, 513, 514, 515, 1006))).clone(namedValues=NamedValues(("other", 1), ("lm-ASC", 2), ("lm-DB15-4T1", 16), ("lm-DB15-4E1", 17), ("lm-BNC-4E1", 18), ("lm-DB15-4T1-R", 19), ("lm-DB15-4E1-R", 20), ("lm-BNC-4E1-R", 21), ("lm-RJ48-8T1", 22), ("lm-RJ48-8E1", 23), ("lm-SMB-8E1", 24), ("lm-RJ48-T3T1", 25), ("lm-RJ48-E3E1", 26), ("lm-RJ48-T3E1", 27), ("lm-SMB-E3E1", 28), ("lm-RJ48-E3T1", 29), ("lm-SMB-T3E1", 30), ("lm-T3E3-D", 32), ("lm-T3E3-B", 33), ("lm-155-SMF", 34), ("lm-155-UTP", 35), ("lm-RJ48-8T1-R", 48), ("lm-RJ48-8E1-R", 49), ("lm-SMB-8E1-R", 50), ("lm-3T3-B", 51), ("lm-HS1-4X21", 60), ("lm-HS1-3HSSI", 61), ("lm-HS1-4V35", 62), ("lm-12In1-8s", 63), ("lm-BSCSM-2", 70), ("lm-BSCSM-4", 71), ("lm-BNC-2T3", 80), ("lm-BNC-2E3", 81), ("pxm-ui", 500), ("smfir-1-622", 501), ("smflr-1-622", 502), ("smfir15-1-622", 503), ("smflr15-1-622", 504), ("mmf-4-155", 505), ("smfir-4-155", 506), ("smflr-4-155", 507), ("rj45-fe", 511), ("mmf-fe", 512), ("mmf-fddi", 513), ("smf-fddi", 514), ("rj45-4e", 515), ("pxm-ui-s3", 1006))).clone('other')).setMaxAccess("readonly")
if mibBuilder.loadTexts: secLineModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: secLineModuleType.setDescription('This object contains the type of secondary line module(back card). Physically it is the bottom card behind the backplane. Normally with connectors for physical devices. These are specific to the front or function modules. This Object is applicable only to selected MGX switches. ')
secLineModuleDescription = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 28), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secLineModuleDescription.setStatus('mandatory')
if mibBuilder.loadTexts: secLineModuleDescription.setDescription('Description of the Secondary line module. This Object is applicable only to selected MGX switches. ')
secLineModuleSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secLineModuleSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: secLineModuleSerialNum.setDescription('Serial number of the secondary(bottom) line module. This object is applicable only to selected MGX switches. ')
secLineModuleHWRev = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secLineModuleHWRev.setStatus('mandatory')
if mibBuilder.loadTexts: secLineModuleHWRev.setDescription('Hardware revision for secondary (bottom) line module This object is applicable only to selected MGX switches. ')
secLineModuleFWRev = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secLineModuleFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: secLineModuleFWRev.setDescription('Firmware revision for Secondary line module This object is applicable only to selected MGX switches. If there is no Firmware revision, then this object returns 0. ')
secLineModuleState = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2), ("invalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secLineModuleState.setStatus('mandatory')
if mibBuilder.loadTexts: secLineModuleState.setDescription('line module status of secondary (bottom) back card. This object is applicable only to selected MGX switches.')
configChangeParentObjectIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configChangeParentObjectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configChangeParentObjectIndex.setDescription(" Parent object index, could be - line index - port index This object will indicate the index of the immediate higher level object (line or port) of configChangeObjectIndex. This object is applicable only when configChangeObjectIndex represents a channel, port, egress Q or resource partition index. Following specifies the mapping between the configChangeObjectIndex and its corresponding configChangeParentObjectIndex. configChangeObjectIndex configChangeParentObjectIndex ----------------------- ----------------------------- Port Index Line Index Egress Q Index Port Index Resource Partition Index Port Index Channel Index Port Index When the 'Port Configuration Change' bit is set, the configChangeParentObjectIndex will represent a 'Line Index' which in turn has the following special meaning in FRSM-2CT3 cards. - configChangeParentObjectIndex range between 1..56 indicates that the configuration change refers to the DS1 line index. A value of (128 + n) refers to DS3 line index numbered 'n'. This object object is applicable only in traps. A GET on this may not return a useful result. This object Object is not applicable to MGX 8850 Release 1.x.x and MGX8220 ")
configChangeGrandParentObjectIndex = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configChangeGrandParentObjectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configChangeGrandParentObjectIndex.setDescription(" Grand Parent object index, could be - line index This object will indicate the index of the immediate higher level object (line) of configChangeParentObjectIndex. This object is applicable only when configChangeParentObjectIndex represents a port index. Following specifies the mapping between the configChangeParentObjectIndex and its corresponding configChangeGrandParentObjectIndex. When the 'Port Configuration Change' bit is set the configChangeGrandParentObjectIndex will represent a 'Line Index' which in turn has the following special meaning in FRSM-2CT3 cards. - configChangeParentObjectIndex range between 1..56 indicates that the configuration change refers to the DS1 line index. A value of (128 + n) refers to DS3 line index numbered 'n'. This object is applicable only in traps. A GET on this may not return a useful result. This object is not applicable to MGX 8850 release 1.x.x and MGX8220.")
configChangeSMSpecificObject = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configChangeSMSpecificObject.setStatus('mandatory')
if mibBuilder.loadTexts: configChangeSMSpecificObject.setDescription(' configChangeSMSpecificObject is a generic object which is Service Module Specific. It can be used for different purposes in different cards. The usage of the same with regard to very card type is listed below. FRSM-8T1E1 - used to store portDs0ConfigBitMap FRSM-VHS - used to store portDs0ConfigBitMap CESM-8T1E1 - used to store cesPortDs0ConfigBitMap CESM-T3E3 - not used AUSM-8T1E1 - not used This object is not applicable to MGX 8850 Release 1.x.x and MGX8220.')
transId = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transId.setStatus('mandatory')
if mibBuilder.loadTexts: transId.setDescription('Per card transaction ID. This object is used to keep track of configuration change on the card. The transId will be incremented by one for every configuration change on the card.')
interfaceNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceNumOfValidEntries.setDescription('Number of rows in interface Table The number represents the physcial interfaces the module has. ')
interfaceLineTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 1), )
if mibBuilder.loadTexts: interfaceLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceLineTable.setDescription('This table has list of the physical interfaces and the services available on this module. ')
interfaceLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 1, 1), ).setIndexNames((0, "BASIS-GENERIC-MIB", "interfaceLineNum"))
if mibBuilder.loadTexts: interfaceLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceLineEntry.setDescription('An entry for physical interface ')
interfaceLineNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceLineNum.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceLineNum.setDescription('An index to uniquely indentify the physical interface and service. Indices 1..8 are used for VISM-8T1/E1. ')
interfaceLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 18, 19, 26, 30, 33, 45, 46))).clone(namedValues=NamedValues(("other", 1), ("ds1", 18), ("e1", 19), ("ethernet-3Mbit", 26), ("ds3", 30), ("rs232", 33), ("v35", 45), ("hssi", 46)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceLineType.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceLineType.setDescription('This object indicates the type of interfaces provided by this Module. These numbers are from RFC1700.')
interfaceNumOfPortsPerLine = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(672)).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceNumOfPortsPerLine.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceNumOfPortsPerLine.setDescription('The number of physical ports of the line type. VISM has a port, but is not linked to these physical lines, hence value=0 is returned. ')
interfaceServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 26, 28, 32, 37, 42))).clone(namedValues=NamedValues(("other", 1), ("ethernet-3Mbit", 26), ("slip", 28), ("frameRelay", 32), ("atm", 37), ("voice", 42)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceServiceType.setDescription('The services available on the interfaceLineType object ')
interfaceNumOfPVC = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceNumOfPVC.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceNumOfPVC.setDescription('The Max number of Permanent Virtual Channels available per physical line (line as defined in interfaceLineType). VISM has a PVC but is not linked to the lines, hence value=0 is returned. ')
interfaceNumOfEgressQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceNumOfEgressQueue.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceNumOfEgressQueue.setDescription('The Max number of Queues per port. Value=0 is returned for VISM card. ')
selfTestEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selfTestEnable.setStatus('mandatory')
if mibBuilder.loadTexts: selfTestEnable.setDescription('This object indicates the self test state 1 ==> self test enabled 2 ==> self test disabled ')
selfTestPeriod = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selfTestPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: selfTestPeriod.setDescription('Interval (in minutes) for self test. ')
selfTestState = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("passed", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfTestState.setStatus('mandatory')
if mibBuilder.loadTexts: selfTestState.setDescription('Self test results for the module. ')
selfTestResultDescription = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 3, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfTestResultDescription.setStatus('mandatory')
if mibBuilder.loadTexts: selfTestResultDescription.setDescription('Self test Result description ')
selfTestClrResultButton = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selfTestClrResultButton.setStatus('mandatory')
if mibBuilder.loadTexts: selfTestClrResultButton.setDescription('This object is used for clearing the result of an online diagnostics(or other self tests).')
controlMsgCounter = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 2, 4))
riscXmtCtrlMsg = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riscXmtCtrlMsg.setStatus('mandatory')
if mibBuilder.loadTexts: riscXmtCtrlMsg.setDescription('The number of control Frames transmitted to SAR (from RISC) maintained by RISC ')
riscRcvCtrlMsg = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riscRcvCtrlMsg.setStatus('mandatory')
if mibBuilder.loadTexts: riscRcvCtrlMsg.setDescription('The number of control Frames received from SAR (to RISC) maintained by RISC ')
sarXmtCtrlMsg = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarXmtCtrlMsg.setStatus('mandatory')
if mibBuilder.loadTexts: sarXmtCtrlMsg.setDescription('The number of control Frames transmitted to RISC from SAR maintained by SAR (should be equal to (riscRcvCtrlMsg) ')
sarRcvCtrlMsg = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarRcvCtrlMsg.setStatus('mandatory')
if mibBuilder.loadTexts: sarRcvCtrlMsg.setDescription('The number of control Frames received to SAR from RISC maintained by SAR (should be equal to (riscXmtCtrlMsg) ')
sarCtrlMsgDiscLenErr = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarCtrlMsgDiscLenErr.setStatus('mandatory')
if mibBuilder.loadTexts: sarCtrlMsgDiscLenErr.setDescription('Total control (management) frames (for MGX8800) or cells(for MGX8220) discarded due to illegal length error ')
sarCtrlMsgDiscCRCErr = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarCtrlMsgDiscCRCErr.setStatus('mandatory')
if mibBuilder.loadTexts: sarCtrlMsgDiscCRCErr.setDescription('Total control (management) frames (MGX8800) or cells(MGX8220) discard due to illegal CRC error. ')
sarCtrlMsgDiscUnknownChan = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarCtrlMsgDiscUnknownChan.setStatus('mandatory')
if mibBuilder.loadTexts: sarCtrlMsgDiscUnknownChan.setDescription('Count of discarded control message due to unknown channel error.')
sarCtrlMsgLastUnkownChan = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarCtrlMsgLastUnkownChan.setStatus('mandatory')
if mibBuilder.loadTexts: sarCtrlMsgLastUnkownChan.setDescription('The control cell header Rcvd of the last unknown channel.')
ctrlMsgClrButton = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctrlMsgClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: ctrlMsgClrButton.setDescription('This object is used for clearing the messages in controlMsgCounter group.')
sarChannelCounter = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 2, 5))
chanNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chanNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: chanNumOfValidEntries.setDescription('Number of entries in the sar channel table ')
sarChannelCounterTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1), )
if mibBuilder.loadTexts: sarChannelCounterTable.setStatus('mandatory')
if mibBuilder.loadTexts: sarChannelCounterTable.setDescription('The table is for logical channels This table contains the counters for cells transmitted on each channel.')
sarChannelCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1), ).setIndexNames((0, "BASIS-GENERIC-MIB", "sarShelfNum"), (0, "BASIS-GENERIC-MIB", "sarSlotNum"), (0, "BASIS-GENERIC-MIB", "sarChanNum"))
if mibBuilder.loadTexts: sarChannelCounterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sarChannelCounterEntry.setDescription(' An entry for logical channel ')
sarShelfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarShelfNum.setStatus('mandatory')
if mibBuilder.loadTexts: sarShelfNum.setDescription('Shelf number ')
sarSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: sarSlotNum.setDescription('Slot number, the slot and shelf info is required here because BSC sends the OAM cells for the FRSM cards that have failed BSC could have upto 4000 connections in this table.')
sarChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4015))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sarChanNum.setStatus('mandatory')
if mibBuilder.loadTexts: sarChanNum.setDescription(' BSC could have upto 4000 connections in this table ')
xmtCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtCells.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCells.setDescription('The number of cells transmitted on this channel. ')
xmtCellsCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtCellsCLP.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCellsCLP.setDescription('The total number of CLP cells that were transmitted on this channel.')
xmtCellsAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtCellsAIS.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCellsAIS.setDescription('The number of AIS cells that were transmitted on this channel. ')
xmtCellsFERF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtCellsFERF.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCellsFERF.setDescription('The number of FERF cells that were transmitted on this channel. ')
xmtCellsBCM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtCellsBCM.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCellsBCM.setDescription('The number of BCM cells that were transmitted on this channel.')
xmtCellsEnd2EndLpBk = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtCellsEnd2EndLpBk.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCellsEnd2EndLpBk.setDescription('The number of End2End loop cells that were transmitted on this channel.')
xmtCellsSegmentLpBk = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtCellsSegmentLpBk.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCellsSegmentLpBk.setDescription('The number of segment loop cells that were transmitted on this channel.')
xmtCellsDiscShelfAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xmtCellsDiscShelfAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: xmtCellsDiscShelfAlarm.setDescription('The number of cells discard due to Shelfalarm on this channel. ')
rcvCells = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCells.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCells.setDescription('The number of cells that were received on this channel. ')
rcvCellsCLP = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCellsCLP.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCellsCLP.setDescription('The number of CLP cells that were received on this channel. ')
rcvCellsAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCellsAIS.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCellsAIS.setDescription('The number of AIS cells that were received on this channel. ')
rcvCellsFERF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCellsFERF.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCellsFERF.setDescription('The number of FERF cells that were received on this channel. ')
rcvCellsBCM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCellsBCM.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCellsBCM.setDescription('The number of BCM cells that were received on this channel. ')
rcvCellsEnd2EndLpBk = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCellsEnd2EndLpBk.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCellsEnd2EndLpBk.setDescription('The number of End2End loop cells that were received on this channel.')
rcvCellsSegmentLpBk = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCellsSegmentLpBk.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCellsSegmentLpBk.setDescription('The number of segment loop cells that were received on this channel. ')
rcvCellsDiscOAM = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcvCellsDiscOAM.setStatus('mandatory')
if mibBuilder.loadTexts: rcvCellsDiscOAM.setDescription('The number of cells that had CRC error on OAM cells ')
sarClrButton = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 2, 5, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sarClrButton.setStatus('mandatory')
if mibBuilder.loadTexts: sarClrButton.setDescription('clear the counters in the table ')
mibBuilder.exportSymbols("BASIS-GENERIC-MIB", configChangeObjectIndex=configChangeObjectIndex, functionModuleFWRev=functionModuleFWRev, interfaceLineNum=interfaceLineNum, cardSelfTest=cardSelfTest, rcvCellsCLP=rcvCellsCLP, sarCtrlMsgDiscLenErr=sarCtrlMsgDiscLenErr, ctrlMsgClrButton=ctrlMsgClrButton, xmtCellsSegmentLpBk=xmtCellsSegmentLpBk, macAddrBlkSize=macAddrBlkSize, interfaceNumOfEgressQueue=interfaceNumOfEgressQueue, moduleTrapAlarmSeverity=moduleTrapAlarmSeverity, chanNumOfValidEntries=chanNumOfValidEntries, interfaceLineType=interfaceLineType, interfaceServiceType=interfaceServiceType, interfaceNumOfPortsPerLine=interfaceNumOfPortsPerLine, lineModuleDescription=lineModuleDescription, lineModuleFWRev=lineModuleFWRev, secLineModuleSerialNum=secLineModuleSerialNum, xmtCellsAIS=xmtCellsAIS, xmtCellsEnd2EndLpBk=xmtCellsEnd2EndLpBk, selfTestResultDescription=selfTestResultDescription, sarSlotNum=sarSlotNum, functionModuleState=functionModuleState, selfTestEnable=selfTestEnable, functionModuleDescription=functionModuleDescription, interfaceLineTable=interfaceLineTable, sarChannelCounterEntry=sarChannelCounterEntry, selfTestPeriod=selfTestPeriod, sarChanNum=sarChanNum, rcvCellsDiscOAM=rcvCellsDiscOAM, sarCtrlMsgDiscUnknownChan=sarCtrlMsgDiscUnknownChan, sarRcvCtrlMsg=sarRcvCtrlMsg, riscXmtCtrlMsg=riscXmtCtrlMsg, functionModuleSerialNum=functionModuleSerialNum, configChangeGrandParentObjectIndex=configChangeGrandParentObjectIndex, xmtCellsCLP=xmtCellsCLP, lineModuleHWRev=lineModuleHWRev, selfTestClrResultButton=selfTestClrResultButton, hwHistory=hwHistory, xmtCells=xmtCells, functionModuleType=functionModuleType, functionModuleResetReason=functionModuleResetReason, selfTestState=selfTestState, xmtCellsBCM=xmtCellsBCM, secLineModuleHWRev=secLineModuleHWRev, interfaceNumOfPVC=interfaceNumOfPVC, rcvCellsEnd2EndLpBk=rcvCellsEnd2EndLpBk, secLineModuleFWRev=secLineModuleFWRev, rcvCells=rcvCells, sarXmtCtrlMsg=sarXmtCtrlMsg, riscRcvCtrlMsg=riscRcvCtrlMsg, cardInformation=cardInformation, controlMsgCounter=controlMsgCounter, sarChannelCounter=sarChannelCounter, configChangeStatus=configChangeStatus, rcvCellsSegmentLpBk=rcvCellsSegmentLpBk, rcvCellsBCM=rcvCellsBCM, cleiCode=cleiCode, secLineModuleState=secLineModuleState, mibVersionNumber=mibVersionNumber, sarCtrlMsgLastUnkownChan=sarCtrlMsgLastUnkownChan, secLineModuleType=secLineModuleType, configChangeParentObjectIndex=configChangeParentObjectIndex, transId=transId, lineModuleState=lineModuleState, rcvCellsFERF=rcvCellsFERF, sarChannelCounterTable=sarChannelCounterTable, functionModuleHWRev=functionModuleHWRev, hwFailures=hwFailures, configChangeSMSpecificObject=configChangeSMSpecificObject, xmtCellsDiscShelfAlarm=xmtCellsDiscShelfAlarm, configChangeTypeBitMap=configChangeTypeBitMap, lineModuleType=lineModuleType, interfaceNumOfValidEntries=interfaceNumOfValidEntries, interfaceLineEntry=interfaceLineEntry, cardInterface=cardInterface, sarClrButton=sarClrButton, lineModuleSerialNum=lineModuleSerialNum, macAddress=macAddress, cardIntegratedAlarmBitMap=cardIntegratedAlarmBitMap, sarCtrlMsgDiscCRCErr=sarCtrlMsgDiscCRCErr, rcvCellsAIS=rcvCellsAIS, sarShelfNum=sarShelfNum, moduleSlotNumber=moduleSlotNumber, secLineModuleDescription=secLineModuleDescription, xmtCellsFERF=xmtCellsFERF, finalTestTechnician=finalTestTechnician)

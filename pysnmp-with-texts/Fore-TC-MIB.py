#
# PySNMP MIB module Fore-TC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Fore-TC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:17:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
asx, = mibBuilder.importSymbols("Fore-Common-MIB", "asx")
trapLogIndex, = mibBuilder.importSymbols("Fore-TrapLog-MIB", "trapLogIndex")
ifName, ifIndex = mibBuilder.importSymbols("IF-MIB", "ifName", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, Counter64, Counter32, ObjectIdentity, Gauge32, Integer32, NotificationType, iso, Unsigned32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, ModuleIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter64", "Counter32", "ObjectIdentity", "Gauge32", "Integer32", "NotificationType", "iso", "Unsigned32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "ModuleIdentity", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
foreTcMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12))
if mibBuilder.loadTexts: foreTcMib.setLastUpdated('9911050000Z')
if mibBuilder.loadTexts: foreTcMib.setOrganization('FORE')
if mibBuilder.loadTexts: foreTcMib.setContactInfo(' Postal: FORE Systems Inc. 1000 FORE Drive Warrendale, PA 15086-7502 Tel: +1 724 742 6900 Email: nm_mibs@fore.com Web: http://www.fore.com')
if mibBuilder.loadTexts: foreTcMib.setDescription(' This mib implements management information for the ATM traffic convergence layer in an atm interface.')
foreTcConfigTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 1), )
if mibBuilder.loadTexts: foreTcConfigTable.setStatus('current')
if mibBuilder.loadTexts: foreTcConfigTable.setDescription('A table of ATM Cell Convergence Layer configuration parameters.')
foreTcConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: foreTcConfigEntry.setStatus('current')
if mibBuilder.loadTexts: foreTcConfigEntry.setDescription('A table entry containing ATM Cell convergence layer configuration information for each atm interface.')
foreTcConfigCellScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("scrambling", 1), ("noScrambling", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foreTcConfigCellScrambling.setStatus('current')
if mibBuilder.loadTexts: foreTcConfigCellScrambling.setDescription('This variable indicates if cell payload scrambling is enabled. If enabled, all outgoing cell payloads are scrambled via the X**43+1 generator polynomial as defined in ITU I.432.1 and all incoming cell payloads are descrambled by the same mechanism.')
foreTcConfigEmptyCell = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("unassigned", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foreTcConfigEmptyCell.setStatus('current')
if mibBuilder.loadTexts: foreTcConfigEmptyCell.setDescription('This variable indicates the type of ATM cells inserted into the outgoing data stream when there is no real data to send. There are two choices: idle -> All bits 0 except that CLP is set to 1 unassigned -> All bits 0 The default value is to send unassigned cells.')
foreTcConfigLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tcNoLoop", 1), ("tcDiagLoop", 2), ("tcPayloadLoop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foreTcConfigLoopback.setStatus('current')
if mibBuilder.loadTexts: foreTcConfigLoopback.setDescription('This variable indicates if cell loopback is enabled at the TC layer. There are three choices: tcNoLoop - Normal operating mode, cells are passed through. tcDiagLoop - Diagnostic mode. Transmitted cells are looped back to the ATM interface. tcPayloadLoop - Payload Loopback. Received cells are looped back to the Phy port.')
foreTcConfigFramingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tcFramingDirect", 1), ("tcFramingPlcp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: foreTcConfigFramingMode.setStatus('current')
if mibBuilder.loadTexts: foreTcConfigFramingMode.setDescription('This variable configures and indicates the method used to encapsulate ATM cells in the data stream. There are two choices: tcFramingDirect - Direct insertion of cells into the data stream. tcFramingPlcp - Use PLCP framing. Typically this is used on T1/E1 and T3/E3 lines. Not all interfaces may support all modes. It is possible on some interfaces, for example Sonet, that this is implemented as a read-only variable set to tcFramingDirect.')
foreTcConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 1, 1, 5), Integer32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcConfigStatus.setStatus('current')
if mibBuilder.loadTexts: foreTcConfigStatus.setDescription("This variable indicates the ATM Status of the interface. The variable is a bit map represented as a sum, therefore it can represent multiple defects simultaneously. The sonetAtmNoDefect should be set if and only if no other flag is set. The various bit mask values are: 1 sonetAtmNoDefect 2 sonetAtmLCD Loss of Cell Delineation was detected. LCD is declared when a 'normal pointer value' is not found for eight consecutive frames. 4 sonetAtmPlcpLOF Valid PLCP frames were not detected at the interface. 8 sonetAtmPlcpYellow Plcp Yellow alarm was detected in the incoming PLCP frame stream.")
foreTcTotalTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 2), )
if mibBuilder.loadTexts: foreTcTotalTable.setStatus('current')
if mibBuilder.loadTexts: foreTcTotalTable.setDescription('A table of ATM Cell Convergence Layer statistics.')
foreTcTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: foreTcTotalEntry.setStatus('current')
if mibBuilder.loadTexts: foreTcTotalEntry.setDescription('A table entry containing ATM Cell convergence layer statistics for each atm interface.')
foreTcTotalLcdSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcTotalLcdSeconds.setStatus('current')
if mibBuilder.loadTexts: foreTcTotalLcdSeconds.setDescription('The number of seconds in which the LCD (loss of cell delineation) defect occured. An LCD defect is detected when an out of cell delineation state has persisted for 4ms. The defect is cleared when sync state has been maintained for 4ms.')
foreTcTotalCorrectableHcs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcTotalCorrectableHcs.setStatus('current')
if mibBuilder.loadTexts: foreTcTotalCorrectableHcs.setDescription('The number of correctable Header Check Sequence (HCS) error events that have occured since the port has been reset.')
foreTcTotalUncorrectableHcs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcTotalUncorrectableHcs.setStatus('current')
if mibBuilder.loadTexts: foreTcTotalUncorrectableHcs.setDescription('The number of uncorrectable Header Check Sequence (HCS) error events that have occured since the port has been reset.')
foreTcTotalTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcTotalTxCells.setStatus('current')
if mibBuilder.loadTexts: foreTcTotalTxCells.setDescription('The number of cells that were transmitted for this atm interface.')
foreTcTotalRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcTotalRxCells.setStatus('current')
if mibBuilder.loadTexts: foreTcTotalRxCells.setDescription('The number of cells that were received on this atm interface.')
foreTcCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 4), )
if mibBuilder.loadTexts: foreTcCurrentTable.setStatus('current')
if mibBuilder.loadTexts: foreTcCurrentTable.setDescription('A table of ATM Cell Convergence Layer statistics.')
foreTcCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: foreTcCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: foreTcCurrentEntry.setDescription('A table entry containing ATM Cell convergence layer statistics for each atm interface.')
foreTcCurrentErrSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcCurrentErrSeconds.setStatus('current')
if mibBuilder.loadTexts: foreTcCurrentErrSeconds.setDescription('Number of Errored Seconds')
foreTcCurrentSevErrSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcCurrentSevErrSeconds.setStatus('current')
if mibBuilder.loadTexts: foreTcCurrentSevErrSeconds.setDescription('Number of Severely Errored Seconds')
foreTcCurrentUnavailSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcCurrentUnavailSeconds.setStatus('current')
if mibBuilder.loadTexts: foreTcCurrentUnavailSeconds.setDescription('Number of Unavailable Seconds')
foreTcCurrentCorrectableHcs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcCurrentCorrectableHcs.setStatus('current')
if mibBuilder.loadTexts: foreTcCurrentCorrectableHcs.setDescription('The number of correctable Header Check Sequence (HCS) error events that have occured since the port has been reset.')
foreTcCurrentUncorrectableHcs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcCurrentUncorrectableHcs.setStatus('current')
if mibBuilder.loadTexts: foreTcCurrentUncorrectableHcs.setDescription('The number of uncorrectable Header Check Sequence (HCS) error events that have occured since the port has been reset.')
foreTcIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 5), )
if mibBuilder.loadTexts: foreTcIntervalTable.setStatus('current')
if mibBuilder.loadTexts: foreTcIntervalTable.setDescription('A table of ATM Cell Convergence Layer statistics.')
foreTcIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "Fore-TC-MIB", "foreTcInterval"))
if mibBuilder.loadTexts: foreTcIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: foreTcIntervalEntry.setDescription('A table entry containing ATM Cell convergence layer statistics for each atm interface.')
foreTcInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcInterval.setStatus('current')
if mibBuilder.loadTexts: foreTcInterval.setDescription('Interval number')
foreTcIntervalErrSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcIntervalErrSeconds.setStatus('current')
if mibBuilder.loadTexts: foreTcIntervalErrSeconds.setDescription('Number of Errored Seconds')
foreTcIntervalSevErrSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcIntervalSevErrSeconds.setStatus('current')
if mibBuilder.loadTexts: foreTcIntervalSevErrSeconds.setDescription('Number of Severely Errored Seconds')
foreTcIntervalUnavailSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcIntervalUnavailSeconds.setStatus('current')
if mibBuilder.loadTexts: foreTcIntervalUnavailSeconds.setDescription('Number of Unavailable Seconds')
foreTcIntervalCorrectableHcs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcIntervalCorrectableHcs.setStatus('current')
if mibBuilder.loadTexts: foreTcIntervalCorrectableHcs.setDescription('The number of correctable Header Check Sequence (HCS) error events that have occured since the port has been reset.')
foreTcIntervalUncorrectableHcs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: foreTcIntervalUncorrectableHcs.setStatus('current')
if mibBuilder.loadTexts: foreTcIntervalUncorrectableHcs.setDescription('The number of uncorrectable Header Check Sequence (HCS) error events that have occured since the port has been reset.')
foreTcLCDDetected = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 0, 1)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: foreTcLCDDetected.setStatus('current')
if mibBuilder.loadTexts: foreTcLCDDetected.setDescription('This trap indicates that the specified SONET port is experiencing Loss of Cell Deliniation (LCD). A LCD failure is declared when the LCD defect persists for a period of 2.5 +/- 0.5 seconds.')
foreTcLCDCleared = NotificationType((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 12, 0, 2)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifName"), ("Fore-TrapLog-MIB", "trapLogIndex"))
if mibBuilder.loadTexts: foreTcLCDCleared.setStatus('current')
if mibBuilder.loadTexts: foreTcLCDCleared.setDescription('This trap indicates that the LCD failure identified by trap asxSonetAtmLCDDetected has been cleared. A LCD failure is cleared when the LCD defect is absent for 10 +/- 0.5 seconds.')
mibBuilder.exportSymbols("Fore-TC-MIB", foreTcTotalCorrectableHcs=foreTcTotalCorrectableHcs, foreTcIntervalUncorrectableHcs=foreTcIntervalUncorrectableHcs, foreTcIntervalEntry=foreTcIntervalEntry, foreTcConfigCellScrambling=foreTcConfigCellScrambling, foreTcCurrentUncorrectableHcs=foreTcCurrentUncorrectableHcs, foreTcIntervalErrSeconds=foreTcIntervalErrSeconds, foreTcMib=foreTcMib, foreTcCurrentEntry=foreTcCurrentEntry, foreTcCurrentSevErrSeconds=foreTcCurrentSevErrSeconds, foreTcInterval=foreTcInterval, foreTcIntervalCorrectableHcs=foreTcIntervalCorrectableHcs, foreTcTotalLcdSeconds=foreTcTotalLcdSeconds, foreTcTotalTxCells=foreTcTotalTxCells, foreTcCurrentErrSeconds=foreTcCurrentErrSeconds, foreTcIntervalSevErrSeconds=foreTcIntervalSevErrSeconds, foreTcTotalEntry=foreTcTotalEntry, foreTcIntervalTable=foreTcIntervalTable, foreTcConfigFramingMode=foreTcConfigFramingMode, foreTcConfigTable=foreTcConfigTable, foreTcIntervalUnavailSeconds=foreTcIntervalUnavailSeconds, foreTcLCDDetected=foreTcLCDDetected, foreTcTotalTable=foreTcTotalTable, foreTcCurrentCorrectableHcs=foreTcCurrentCorrectableHcs, foreTcTotalUncorrectableHcs=foreTcTotalUncorrectableHcs, foreTcCurrentTable=foreTcCurrentTable, foreTcCurrentUnavailSeconds=foreTcCurrentUnavailSeconds, foreTcLCDCleared=foreTcLCDCleared, foreTcConfigLoopback=foreTcConfigLoopback, foreTcConfigEmptyCell=foreTcConfigEmptyCell, foreTcConfigStatus=foreTcConfigStatus, foreTcTotalRxCells=foreTcTotalRxCells, PYSNMP_MODULE_ID=foreTcMib, foreTcConfigEntry=foreTcConfigEntry)

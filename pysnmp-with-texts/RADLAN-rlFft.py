#
# PySNMP MIB module RADLAN-rlFft (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RADLAN-rlFft
# Produced by pysmi-0.3.4 at Wed May  1 14:50:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, Counter64, MibIdentifier, Unsigned32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Bits, TimeTicks, iso, ModuleIdentity, ObjectIdentity, Counter32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Counter64", "MibIdentifier", "Unsigned32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Bits", "TimeTicks", "iso", "ModuleIdentity", "ObjectIdentity", "Counter32", "IpAddress")
TruthValue, DisplayString, TextualConvention, RowStatus, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention", "RowStatus", "PhysAddress")
class Percents(TextualConvention, Integer32):
    description = 'Specifies percents.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 100)

class NetNumber(TextualConvention, OctetString):
    description = 'Specifies the network identification.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

rlFFT = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 47))
rlFFT.setRevisions(('2004-06-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlFFT.setRevisionsDescriptions(('Initial version of this MIB.',))
if mibBuilder.loadTexts: rlFFT.setLastUpdated('200406010000Z')
if mibBuilder.loadTexts: rlFFT.setOrganization('')
if mibBuilder.loadTexts: rlFFT.setContactInfo('')
if mibBuilder.loadTexts: rlFFT.setDescription('The private MIB module definition for Fast Forwarding Tables.')
rlIpFFT = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 47, 1))
rlIpFftMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlIpFftMibVersion.setDescription("MIB's version, the current version is 1.")
rlIpMaxFftNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpMaxFftNumber.setStatus('current')
if mibBuilder.loadTexts: rlIpMaxFftNumber.setDescription('The maximum number of IP FFTs.')
rlIpFftDynamicSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftDynamicSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpFftDynamicSupported.setDescription('Specifies whether dynamic IP FFTs are supported.')
rlIpFftSubnetSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubnetSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubnetSupported.setDescription('Specifies whether subtable per IP subnet is supported.')
rlIpFftUnknownAddrMsgUsed = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("used", 1), ("unused", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftUnknownAddrMsgUsed.setStatus('current')
if mibBuilder.loadTexts: rlIpFftUnknownAddrMsgUsed.setDescription('Specifies whether the 3SW uses the unknown address message.')
rlIpFftAgingTimeSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftAgingTimeSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpFftAgingTimeSupported.setDescription('Specifies whether aging time is supported.')
rlIpFftSrcAddrSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSrcAddrSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSrcAddrSupported.setDescription('Specifies whether an IP subtable per station contains source IP address.')
rlIpFftAgingTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpFftAgingTimeout.setStatus('current')
if mibBuilder.loadTexts: rlIpFftAgingTimeout.setDescription('The aging timeout in seconds.')
rlIpFftRedBoundary = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 9), Percents()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpFftRedBoundary.setStatus('current')
if mibBuilder.loadTexts: rlIpFftRedBoundary.setDescription('The red boundary in percents.')
rlIpFftYellowBoundary = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 1, 10), Percents()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpFftYellowBoundary.setStatus('current')
if mibBuilder.loadTexts: rlIpFftYellowBoundary.setDescription('The yellow boundary in percents.')
rlIpFftNumTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 1, 12), )
if mibBuilder.loadTexts: rlIpFftNumTable.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNumTable.setDescription("The (conceptual) table containing routes' numbers of the IP SFFTs and IP NFFTs. ")
rlIpFftNumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 1, 12, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpFftNumIndex"))
if mibBuilder.loadTexts: rlIpFftNumEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNumEntry.setDescription("An entry (conceptual row) containing the containing routes' numbers of IP SFFT and IP NFFT ")
rlIpFftNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNumIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNumIndex.setDescription('The value of the index of the IP FFT. ')
rlIpFftNumStnRoutesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNumStnRoutesNumber.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNumStnRoutesNumber.setDescription('The number of routes that are contained in the IP SFFT. ')
rlIpFftNumSubRoutesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNumSubRoutesNumber.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNumSubRoutesNumber.setDescription('The number of routes that are contained in the IP NFFT. ')
rlIpFftStnTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 1, 13), )
if mibBuilder.loadTexts: rlIpFftStnTable.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnTable.setDescription('The (conceptual) table contains IP Fast Forwarding information per station for IP datagrams. ')
rlIpFftStnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpFftStnIndex"), (0, "RADLAN-rlFft", "rlIpFftStnMrid"), (0, "RADLAN-rlFft", "rlIpFftStnDstIpAddress"))
if mibBuilder.loadTexts: rlIpFftStnEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnEntry.setDescription('An entry (conceptual row) contains the IP fast forwarding information for IP datagrams from a particular source and destination addresses.')
rlIpFftStnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnIndex.setDescription('The value of the index of the IP FFT. ')
rlIpFftStnMrid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnMrid.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnMrid.setDescription("The router's Instance Identifier in the SFFT. ")
rlIpFftStnDstIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnDstIpAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnDstIpAddress.setDescription('The IP destination address for which this entry contains IP forwarding information.')
rlIpFftStnDstRouteIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnDstRouteIpMask.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnDstRouteIpMask.setDescription('The IP destination mask for which this entry contains IP forwarding information.')
rlIpFftStnDstIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnDstIpAddrType.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnDstIpAddrType.setDescription('The IP destination address type. ')
rlIpFftStnDstMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnDstMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnDstMacAddress.setDescription('The MAC destination address.')
rlIpFftStnSrcMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 7), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnSrcMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnSrcMacAddress.setDescription('The MAC source address.')
rlIpFftStnOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnOutIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnOutIfIndex.setDescription('The value of ifIndex of output physical port.')
rlIpFftStnVid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnVid.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnVid.setDescription('The vid of the output port.')
rlIpFftStnTaggedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("untagged", 1), ("tagged", 2), ("basedPortConfig", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnTaggedMode.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnTaggedMode.setDescription('The tagged value of the port. When the Tagged field is not a part of the FFT table in the ASIC, the Tagged field gets the BasedPortConfig value ')
rlIpFftStnAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 13, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftStnAge.setStatus('current')
if mibBuilder.loadTexts: rlIpFftStnAge.setDescription('The age of the entry in seconds from the inserting.')
rlIpFftSubTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 1, 14), )
if mibBuilder.loadTexts: rlIpFftSubTable.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubTable.setDescription('The (conceptual) table containing IP Fast Forwarding information per subnet for IP datagrams. ')
rlIpFftSubEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpFftSubMrid"), (0, "RADLAN-rlFft", "rlIpFftSubDstIpSubnet"), (0, "RADLAN-rlFft", "rlIpFftSubDstIpMask"))
if mibBuilder.loadTexts: rlIpFftSubEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubEntry.setDescription('An entry (conceptual row) containing the IP fast forwarding information for IP datagrams from a particular source and destination addresses.')
rlIpFftSubMrid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubMrid.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubMrid.setDescription("The router's Instance Identifier in the NFFT. ")
rlIpFftSubDstIpSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubDstIpSubnet.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubDstIpSubnet.setDescription('The IP destination subnet for which this entry contains IP forwarding information.')
rlIpFftSubDstIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubDstIpMask.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubDstIpMask.setDescription('The IP destination mask for which this entry contains IP forwarding information.')
rlIpFftSubAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubAge.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubAge.setDescription('The age of the entry in seconds from the inserting.')
rlIpFftSubNextHopSetRefCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopSetRefCount.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopSetRefCount.setDescription('The number of NFFT entries that used the given NextHop set (ECMP path). ')
rlIpFftSubNextHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopCount.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopCount.setDescription('The number of used NextHops in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIfindex1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex1.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex1.setDescription('The first NextHop Ifindex in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIpAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr1.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr1.setDescription('The first NextHop IP address in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIfindex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex2.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex2.setDescription('The second NextHop Ifindex in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIpAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr2.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr2.setDescription('The second NextHop IP address in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIfindex3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex3.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex3.setDescription('The third NextHop Ifindex in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIpAddr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr3.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr3.setDescription('The third NextHop IP address in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIfindex4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex4.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex4.setDescription('The fourth NextHop Ifindex in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIpAddr4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr4.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr4.setDescription('The fourth NextHop IP address in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIfindex5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex5.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex5.setDescription('The fifth NextHop Ifindex in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIpAddr5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr5.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr5.setDescription('The fifth NextHop IP address in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIfindex6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex6.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex6.setDescription('The six NextHop Ifindex in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIpAddr6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 18), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr6.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr6.setDescription('The six NextHop IP address in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIfindex7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex7.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex7.setDescription('The seven NextHop Ifindex in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIpAddr7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 20), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr7.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr7.setDescription('The seven NextHop IP address in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIfindex8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex8.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIfindex8.setDescription('The eight NextHop Ifindex in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftSubNextHopIpAddr8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 14, 1, 22), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr8.setStatus('current')
if mibBuilder.loadTexts: rlIpFftSubNextHopIpAddr8.setDescription('The eight NextHop IP address in the given NextHop set (ECMP path) for the NFFT entry. ')
rlIpFftCountersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 1, 15), )
if mibBuilder.loadTexts: rlIpFftCountersTable.setStatus('current')
if mibBuilder.loadTexts: rlIpFftCountersTable.setDescription('The (conceptual) table containing IP Counters information per one IP FFT.')
rlIpFftCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 1, 15, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpFftCountersIndex"))
if mibBuilder.loadTexts: rlIpFftCountersEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpFftCountersEntry.setDescription('An entry (conceptual row) containing the IP Counters information containing amount of IP datagrams passed by certain IP FFT.')
rlIpFftCountersIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftCountersIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpFftCountersIndex.setDescription('The value of the index of the IP FFT.')
rlIpFftInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftInReceives.setStatus('current')
if mibBuilder.loadTexts: rlIpFftInReceives.setDescription('The amount of received IP datagrams ')
rlIpFftForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 15, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftForwDatagrams.setStatus('current')
if mibBuilder.loadTexts: rlIpFftForwDatagrams.setDescription('The amount of forwarded IP datagrams ')
rlIpFftInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 15, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftInDiscards.setStatus('current')
if mibBuilder.loadTexts: rlIpFftInDiscards.setDescription('The amount of discarded IP datagrams ')
rlIpFftNextHopTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 1, 16), )
if mibBuilder.loadTexts: rlIpFftNextHopTable.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopTable.setDescription('The (conceptual) table contains NextHop information used for routing IP datagrams. ')
rlIpFftNextHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpFftNextHopifindex"), (0, "RADLAN-rlFft", "rlIpFftNextHopIpAddress"))
if mibBuilder.loadTexts: rlIpFftNextHopEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopEntry.setDescription('An entry (conceptual row) contains the NextHop info information for routing IP datagrams.')
rlIpFftNextHopifindex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopifindex.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopifindex.setDescription('The value of the IP Interface index of the NextHop. ')
rlIpFftNextHopIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopIpAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopIpAddress.setDescription('The IP address of a NextHop for which an entry contains IP forwarding information. ')
rlIpFftNextHopValid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopValid.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopValid.setDescription('The NextHop Valid bit. When L2 info is missing, a NextHop has Invalid value. ')
rlIpFftNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("local", 1), ("remote", 2), ("reject", 3), ("drop", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopType.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopType.setDescription('The NextHop type. ')
rlIpFftNextHopReferenceCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopReferenceCount.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopReferenceCount.setDescription('IF LPM is supported: If ecmp supported: the field NextHop_ref_count used to save number of NextHop SETs that use the NextHop. Otherwise, NextHop_ref_count used to save number of NFFT entries that use the NextHop. IF LPM is NOT supported: NextHop_ref_count used to save number of Remote SFFT entries that use the NextHop. ')
rlIpFftNextHopNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopNetAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopNetAddress.setDescription('The NextHop Physical Address.')
rlIpFftNextHopVid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopVid.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopVid.setDescription('The vid of the output port.')
rlIpFftNextHopMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 8), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopMacAddress.setDescription('The MAC destination address.')
rlIpFftNextHopOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 16, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftNextHopOutIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpFftNextHopOutIfIndex.setDescription('The value of ifIndex of output physical port.')
rlIpFftL2InfoTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 1, 17), )
if mibBuilder.loadTexts: rlIpFftL2InfoTable.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoTable.setDescription('The (conceptual) table contains L2 information used for routing IP datagrams. ')
rlIpFftL2InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpFftL2InfoIfindex"), (0, "RADLAN-rlFft", "rlIpFftL2InfoDstMacAddress"))
if mibBuilder.loadTexts: rlIpFftL2InfoEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoEntry.setDescription('An entry (conceptual row) contains the L2 info information for routing IP datagrams.')
rlIpFftL2InfoIfindex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoIfindex.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoIfindex.setDescription('The VLAN Ifindex of the destination port. ')
rlIpFftL2InfoDstMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoDstMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoDstMacAddress.setDescription('The MAC destination address.')
rlIpFftL2InfoValid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoValid.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoValid.setDescription('The L2 info entry valid bit. When L2 info is missing some information, an L2 info has Invalid value. ')
rlIpFftL2InfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("vlan", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoType.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoType.setDescription('The L2 info type. With Enthernet media l2 info type is vlan. WIth Tunneling feature, l2 info type will be expanded. ')
rlIpFftL2InfoReferenceCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoReferenceCount.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoReferenceCount.setDescription('The reference count contains a number of NextHop entries that use this L2 info.')
rlIpFftL2InfoVid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoVid.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoVid.setDescription('The vid of the destination port. ')
rlIpFftL2InfoSrcMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 7), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoSrcMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoSrcMacAddress.setDescription('The MAC source address placed to Ehernet Header of IP forwarded packet.')
rlIpFftL2InfoOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoOutIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoOutIfIndex.setDescription('The value of ifIndex of output physical port the packet is forwarded through.')
rlIpFftL2InfoTaggedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 1, 17, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("untagged", 1), ("tagged", 2), ("basedPortConfig", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpFftL2InfoTaggedMode.setStatus('current')
if mibBuilder.loadTexts: rlIpFftL2InfoTaggedMode.setDescription('The tagged value of the port. When the Tagged field is not a part of the FFT table in the ASIC, the Tagged field get the BasedPortConfig value.')
rlIpxFFT = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 47, 2))
rlIpxFftMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftMibVersion.setDescription("MIB's version, the current version is 1.")
rlIpxMaxFftNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxMaxFftNumber.setStatus('current')
if mibBuilder.loadTexts: rlIpxMaxFftNumber.setDescription('The maximun number of IPX FFTs. An IPX FFT gets a number from 1 until rlIpxMaxFftSetNumber.')
rlIpxFftDynamicSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftDynamicSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftDynamicSupported.setDescription('Specifies whether dynamic IPX FFTs are supported.')
rlIpxFftNetworkSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftNetworkSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftNetworkSupported.setDescription('Specifies whether subtable per IPX network is supported.')
rlIpxFftUnknownAddrMsgUsed = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("used", 1), ("unused", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftUnknownAddrMsgUsed.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftUnknownAddrMsgUsed.setDescription('Specifies whether the 3SW uses the unknown address message.')
rlIpxFftAgingTimeSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftAgingTimeSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftAgingTimeSupported.setDescription('Specifies whether aging time is supported for subtable per station.')
rlIpxFftSrcAddrSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSrcAddrSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSrcAddrSupported.setDescription('Specifies whether an IPX subtable per station contains source IPX address.')
rlIpxFftAgingTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpxFftAgingTimeout.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftAgingTimeout.setDescription('The aging timeout in seconds.')
rlIpxFftRedBoundary = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpxFftRedBoundary.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftRedBoundary.setDescription('The red boundary in percents.')
rlIpxFftYellowBoundary = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 2, 10), Percents()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpxFftYellowBoundary.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftYellowBoundary.setDescription('The yellow boundary in percents.')
rlIpxFftNumTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 2, 12), )
if mibBuilder.loadTexts: rlIpxFftNumTable.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftNumTable.setDescription('The (conceptual) table containing number routes of the IPX Fast Forwarding Table. ')
rlIpxFftNumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 2, 12, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpxFftNumIndex"))
if mibBuilder.loadTexts: rlIpxFftNumEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftNumEntry.setDescription('An entry (conceptual row) containing the containing number routes of of IPX SFFT and IPX NFFT ')
rlIpxFftNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftNumIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftNumIndex.setDescription('The value of the index of the IPX FFT. ')
rlIpxFftNumStnRoutesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftNumStnRoutesNumber.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftNumStnRoutesNumber.setDescription('The number of routes containing in the IPX SFFT. ')
rlIpxFftNumSubRoutesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftNumSubRoutesNumber.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftNumSubRoutesNumber.setDescription('The number of routes containing in the IPX NFFT. ')
rlIpxFftStnTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 2, 13), )
if mibBuilder.loadTexts: rlIpxFftStnTable.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnTable.setDescription('The (conceptual) table containing IPX Fast Forwarding information per station for IPX. ')
rlIpxFftStnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpxFftStnIndex"), (0, "RADLAN-rlFft", "rlIpxFftStnDstNetid"), (0, "RADLAN-rlFft", "rlIpxFftStnDstNode"), (0, "RADLAN-rlFft", "rlIpxFftStnSrcNetid"), (0, "RADLAN-rlFft", "rlIpxFftStnSrcNode"))
if mibBuilder.loadTexts: rlIpxFftStnEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnEntry.setDescription('An entry (conceptual row) containing the IP fast forwarding information for IP datagrams from a particular source and destination addresses.')
rlIpxFftStnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnIndex.setDescription('The value of the index of the IPX FFT. ')
rlIpxFftStnDstNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 2), NetNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnDstNetid.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnDstNetid.setDescription('The destination network for which this entry contains IPX forwarding information.')
rlIpxFftStnDstNode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnDstNode.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnDstNode.setDescription('The destination node for which this entry contains IPX forwarding information.')
rlIpxFftStnSrcNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 4), NetNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnSrcNetid.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnSrcNetid.setDescription('The source network for which this entry contains IPX forwarding information.')
rlIpxFftStnSrcNode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnSrcNode.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnSrcNode.setDescription('The destination node for which this entry contains IPX forwarding information.')
rlIpxFftStnDstIpxAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnDstIpxAddrType.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnDstIpxAddrType.setDescription('The destination address type. ')
rlIpxFftStnEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("novell", 1), ("ethernet", 2), ("llc", 3), ("snap", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnEncapsulation.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnEncapsulation.setDescription('The encapsulation method associated with this route.')
rlIpxFftStnDstMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 8), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnDstMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnDstMacAddress.setDescription('The MAC destination address.')
rlIpxFftStnSrcMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 9), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnSrcMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnSrcMacAddress.setDescription('The MAC source address.')
rlIpxFftStnOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnOutIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnOutIfIndex.setDescription('The value of ifIndex of output physical port.')
rlIpxFftStnTci = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnTci.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnTci.setDescription('The value of TCI or 0.')
rlIpxFftStnFacsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnFacsIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnFacsIndex.setDescription('The value of index of the FACS Table.')
rlIpxFftStnAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 13, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftStnAge.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftStnAge.setDescription('The age of the entry in seconds.')
rlIpxFftSubTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 2, 14), )
if mibBuilder.loadTexts: rlIpxFftSubTable.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubTable.setDescription('The (conceptual) table containing IPX Fast Forwarding information per network for IPX . ')
rlIpxFftSubEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpxFftSubIndex"), (0, "RADLAN-rlFft", "rlIpxFftSubDstNetid"))
if mibBuilder.loadTexts: rlIpxFftSubEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubEntry.setDescription('An entry (conceptual row) containing the IP fast forwarding information for IP datagrams from a particular source and destination addresses.')
rlIpxFftSubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubIndex.setDescription('The value of the index of the IPX FFT. ')
rlIpxFftSubDstNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 2), NetNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubDstNetid.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubDstNetid.setDescription('The destination network for which this entry contains IPX forwarding information.')
rlIpxFftSubEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("novell", 1), ("ethernet", 2), ("llc", 3), ("snap", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubEncapsulation.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubEncapsulation.setDescription('The encapsulation method associated with this route.')
rlIpxFftSubDstMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubDstMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubDstMacAddress.setDescription('The MAC destination address.')
rlIpxFftSubSrcMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubSrcMacAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubSrcMacAddress.setDescription('The MAC source address.')
rlIpxFftSubOutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubOutIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubOutIfIndex.setDescription('The value of ifIndex of output physical port.')
rlIpxFftSubTci = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubTci.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubTci.setDescription('The value of TCI or 0.')
rlIpxFftSubFacsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubFacsIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubFacsIndex.setDescription('The value of index of the FACS Table.')
rlIpxFftSubAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 14, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftSubAge.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftSubAge.setDescription('The age of the entry in seconds.')
rlIpxFftCountersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 2, 15), )
if mibBuilder.loadTexts: rlIpxFftCountersTable.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftCountersTable.setDescription('The (conceptual) table containing IPX Counters information per one IPX FFT.')
rlIpxFftCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 2, 15, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpxFftCountersIndex"))
if mibBuilder.loadTexts: rlIpxFftCountersEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftCountersEntry.setDescription('An entry (conceptual row) containing the IP Counters information containing amount of IPX datagrams passed by certain IPX FFT.')
rlIpxFftCountersIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftCountersIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftCountersIndex.setDescription('The value of the index of the IPX FFT.')
rlIpxFftInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftInReceives.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftInReceives.setDescription('The amount of received IPX datagrams ')
rlIpxFftForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 15, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftForwDatagrams.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftForwDatagrams.setDescription('The amount of forwarded IPX datagrams ')
rlIpxFftInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 2, 15, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpxFftInDiscards.setStatus('current')
if mibBuilder.loadTexts: rlIpxFftInDiscards.setDescription('The amount of discarded IPX datagrams ')
rlIpmFFT = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 47, 3))
rlIpmFftMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftMibVersion.setDescription("MIB's version, the current version is 1.")
rlIpmMaxFftNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmMaxFftNumber.setStatus('current')
if mibBuilder.loadTexts: rlIpmMaxFftNumber.setDescription('The maximun number of IPM FFTs. NT_IPM gets a number from Host Parameters')
rlIpmFftDynamicSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftDynamicSupported.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftDynamicSupported.setDescription('Specifies whether dynamic IPM FFTs are supported. An NT_IPM gets a number from Host Parameters')
rlIpmFftUnknownAddrMsgUsed = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("used", 1), ("unused", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftUnknownAddrMsgUsed.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftUnknownAddrMsgUsed.setDescription('Specifies whether the 3SW uses the unknown address message. An NT_IPM gets a number from Host Parameters')
rlIpmFftUserAgingTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 3, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpmFftUserAgingTimeout.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftUserAgingTimeout.setDescription('The aging timeout in seconds. SNMP user writes. There is a default value of aging timeout.')
rlIpmFftRouterAgingTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 47, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftRouterAgingTimeout.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftRouterAgingTimeout.setDescription('The aging timeout in seconds. NT_IPM keeps value that Router level gave. This is high priority value for aging timeout.')
rlIpmFftNumTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 3, 8), )
if mibBuilder.loadTexts: rlIpmFftNumTable.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftNumTable.setDescription('The (conceptual) table containing number routes of the IPM Fast Forwarding Table. ')
rlIpmFftNumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 3, 8, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpmFftNumIndex"))
if mibBuilder.loadTexts: rlIpmFftNumEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftNumEntry.setDescription('An entry (conceptual row) containing the containing number routes of an IPM FFT.')
rlIpmFftNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftNumIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftNumIndex.setDescription('The value of the index of the IPM FFT.')
rlIpmFftNumRoutesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftNumRoutesNumber.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftNumRoutesNumber.setDescription('The number of routes containing in the IPM FFT.')
rlIpmFftTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 3, 9), )
if mibBuilder.loadTexts: rlIpmFftTable.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftTable.setDescription('The (conceptual) table containing IPM Fast Forwarding information for IPM datagrams.')
rlIpmFftEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpmFftIndex"), (0, "RADLAN-rlFft", "rlIpmFftSrcIpAddress"), (0, "RADLAN-rlFft", "rlIpmFftDstIpAddress"))
if mibBuilder.loadTexts: rlIpmFftEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftEntry.setDescription('An entry (conceptual row) containing the IPM fast forwarding information for IP datagrams from a particular source and destination addresses.')
rlIpmFftIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftIndex.setDescription('The value of the index of the IPM FFT. ')
rlIpmFftSrcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftSrcIpAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftSrcIpAddress.setDescription('The IP source address for which this entry contains IPM forwarding information.')
rlIpmFftDstIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftDstIpAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftDstIpAddress.setDescription('The IPM destination address for which this entry contains IPM forwarding information.')
rlIpmFftSrcIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftSrcIpMask.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftSrcIpMask.setDescription('The IP source mask for which this entry contains IP forwarding information.')
rlIpmFftInputIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftInputIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftInputIfIndex.setDescription('The input ifIndex for which this entry contains IPM forwarding information.')
rlIpmFftInputVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftInputVlanTag.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftInputVlanTag.setDescription('The input Vlan tag together with input ifIndex defines pair (ifIndex, tag)')
rlIpmFftForwardAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftForwardAction.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftForwardAction.setDescription('The IPM forward action.')
rlIpmFftInportAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sentToCPU", 1), ("discard", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftInportAction.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftInportAction.setDescription('The IPM illegal input port action.')
rlIpmFftAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 9, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftAge.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftAge.setDescription('The age of the entry in seconds from the moment of inserting. ')
rlIpmFftPortTagTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 3, 10), )
if mibBuilder.loadTexts: rlIpmFftPortTagTable.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftPortTagTable.setDescription('The (conceptual) table containing IPM FFT output port tag information for IPM datagrams.')
rlIpmFftPortTagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 3, 10, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpmFftPortIndex"), (0, "RADLAN-rlFft", "rlIpmFftPortSrcIpAddress"), (0, "RADLAN-rlFft", "rlIpmFftPortDstIpAddress"), (0, "RADLAN-rlFft", "rlIpmFftPortOutputifIndex"), (0, "RADLAN-rlFft", "rlIpmFftPortOutputTag"))
if mibBuilder.loadTexts: rlIpmFftPortTagEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftPortTagEntry.setDescription('An entry (conceptual row) containing the IPM FFT output port tag information for IP datagrams from a particular source and destination addresses.')
rlIpmFftPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftPortIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftPortIndex.setDescription('The value of the index of the IPM FFT. ')
rlIpmFftPortSrcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 10, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftPortSrcIpAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftPortSrcIpAddress.setDescription('The IP source address for which this entry contains IPM output port tag information.')
rlIpmFftPortDstIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 10, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftPortDstIpAddress.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftPortDstIpAddress.setDescription('The IPM destination address for which this entry contains IPM port tag information.')
rlIpmFftPortOutputifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftPortOutputifIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftPortOutputifIndex.setDescription('The output ifIndex ')
rlIpmFftPortOutputTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftPortOutputTag.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftPortOutputTag.setDescription('The output Vlan tag together with output ifIndex defines pair (ifIndex, tag)')
rlIpmFftCountersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 47, 3, 11), )
if mibBuilder.loadTexts: rlIpmFftCountersTable.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftCountersTable.setDescription('The (conceptual) table containing IPM Counters information per FFT number. ')
rlIpmFftCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 47, 3, 11, 1), ).setIndexNames((0, "RADLAN-rlFft", "rlIpmFftCountersIndex"))
if mibBuilder.loadTexts: rlIpmFftCountersEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftCountersEntry.setDescription('An entry (conceptual row) containing the IPM Counters information containing amount of IPM datagrams passed by certain FFT.')
rlIpmFftCountersIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftCountersIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftCountersIndex.setDescription('The value of the index of the IPM FFT. ')
rlIpmFftInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftInReceives.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftInReceives.setDescription('The amount of received IPM datagrams ')
rlIpmFftForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftForwDatagrams.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftForwDatagrams.setDescription('The amount of forwarded IPM datagrams ')
rlIpmFftInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 47, 3, 11, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpmFftInDiscards.setStatus('current')
if mibBuilder.loadTexts: rlIpmFftInDiscards.setDescription('The amount of discarded IPM datagrams ')
mibBuilder.exportSymbols("RADLAN-rlFft", rlIpFftStnDstRouteIpMask=rlIpFftStnDstRouteIpMask, rlIpFftSubNextHopIpAddr6=rlIpFftSubNextHopIpAddr6, rlIpxFftYellowBoundary=rlIpxFftYellowBoundary, NetNumber=NetNumber, rlIpFftNumEntry=rlIpFftNumEntry, rlIpxFftSrcAddrSupported=rlIpxFftSrcAddrSupported, rlIpFftSubNextHopCount=rlIpFftSubNextHopCount, rlIpFftNextHopOutIfIndex=rlIpFftNextHopOutIfIndex, rlIpFftL2InfoValid=rlIpFftL2InfoValid, rlIpxFftSubTci=rlIpxFftSubTci, rlIpxFftSubSrcMacAddress=rlIpxFftSubSrcMacAddress, rlIpFftSubDstIpMask=rlIpFftSubDstIpMask, rlIpxFftDynamicSupported=rlIpxFftDynamicSupported, rlIpFftL2InfoTaggedMode=rlIpFftL2InfoTaggedMode, rlIpFftStnMrid=rlIpFftStnMrid, rlIpmFftUnknownAddrMsgUsed=rlIpmFftUnknownAddrMsgUsed, rlIpFftSubNextHopIfindex5=rlIpFftSubNextHopIfindex5, rlIpxFftStnAge=rlIpxFftStnAge, rlIpxMaxFftNumber=rlIpxMaxFftNumber, rlIpFftL2InfoEntry=rlIpFftL2InfoEntry, rlIpFftStnOutIfIndex=rlIpFftStnOutIfIndex, rlIpFftInDiscards=rlIpFftInDiscards, rlIpFftRedBoundary=rlIpFftRedBoundary, rlIpxFftNetworkSupported=rlIpxFftNetworkSupported, rlIpFftNextHopType=rlIpFftNextHopType, rlIpmFftRouterAgingTimeout=rlIpmFftRouterAgingTimeout, rlIpFftSubEntry=rlIpFftSubEntry, rlIpFftNextHopValid=rlIpFftNextHopValid, rlIpFftNextHopEntry=rlIpFftNextHopEntry, rlIpFftNextHopifindex=rlIpFftNextHopifindex, rlIpFftNumIndex=rlIpFftNumIndex, rlIpFftL2InfoOutIfIndex=rlIpFftL2InfoOutIfIndex, rlIpxFftStnFacsIndex=rlIpxFftStnFacsIndex, rlIpxFftRedBoundary=rlIpxFftRedBoundary, rlIpxFftNumSubRoutesNumber=rlIpxFftNumSubRoutesNumber, rlIpFftSubNextHopIpAddr5=rlIpFftSubNextHopIpAddr5, rlIpxFftSubDstNetid=rlIpxFftSubDstNetid, rlIpxFftAgingTimeSupported=rlIpxFftAgingTimeSupported, rlFFT=rlFFT, rlIpxFftStnEntry=rlIpxFftStnEntry, rlIpmFftCountersEntry=rlIpmFftCountersEntry, rlIpFFT=rlIpFFT, rlIpxFftStnSrcMacAddress=rlIpxFftStnSrcMacAddress, rlIpFftUnknownAddrMsgUsed=rlIpFftUnknownAddrMsgUsed, rlIpFftForwDatagrams=rlIpFftForwDatagrams, rlIpmFftForwDatagrams=rlIpmFftForwDatagrams, rlIpmFftDstIpAddress=rlIpmFftDstIpAddress, rlIpmFftNumIndex=rlIpmFftNumIndex, rlIpmFftInportAction=rlIpmFftInportAction, rlIpFftSubNextHopIpAddr2=rlIpFftSubNextHopIpAddr2, rlIpmFftPortSrcIpAddress=rlIpmFftPortSrcIpAddress, rlIpFftStnDstIpAddrType=rlIpFftStnDstIpAddrType, rlIpFftNumTable=rlIpFftNumTable, rlIpFftDynamicSupported=rlIpFftDynamicSupported, rlIpFftSubMrid=rlIpFftSubMrid, rlIpmFftPortTagTable=rlIpmFftPortTagTable, rlIpxFftCountersTable=rlIpxFftCountersTable, rlIpxFFT=rlIpxFFT, rlIpxFftStnDstNetid=rlIpxFftStnDstNetid, rlIpFftNextHopTable=rlIpFftNextHopTable, rlIpFftSubTable=rlIpFftSubTable, rlIpmFftSrcIpAddress=rlIpmFftSrcIpAddress, rlIpFftSubNextHopIpAddr7=rlIpFftSubNextHopIpAddr7, rlIpFftL2InfoDstMacAddress=rlIpFftL2InfoDstMacAddress, rlIpFftStnIndex=rlIpFftStnIndex, rlIpxFftInReceives=rlIpxFftInReceives, rlIpxFftStnDstNode=rlIpxFftStnDstNode, rlIpmFftNumTable=rlIpmFftNumTable, rlIpFftCountersTable=rlIpFftCountersTable, rlIpxFftNumTable=rlIpxFftNumTable, rlIpFftL2InfoIfindex=rlIpFftL2InfoIfindex, rlIpmFftEntry=rlIpmFftEntry, rlIpmFftCountersTable=rlIpmFftCountersTable, rlIpFftL2InfoSrcMacAddress=rlIpFftL2InfoSrcMacAddress, rlIpFftL2InfoReferenceCount=rlIpFftL2InfoReferenceCount, rlIpFftSubNextHopIfindex4=rlIpFftSubNextHopIfindex4, rlIpFftSubNextHopIfindex1=rlIpFftSubNextHopIfindex1, rlIpxFftInDiscards=rlIpxFftInDiscards, rlIpFftSubNextHopSetRefCount=rlIpFftSubNextHopSetRefCount, rlIpmFftPortOutputTag=rlIpmFftPortOutputTag, rlIpFftSubNextHopIpAddr4=rlIpFftSubNextHopIpAddr4, rlIpmFftPortDstIpAddress=rlIpmFftPortDstIpAddress, rlIpxFftCountersEntry=rlIpxFftCountersEntry, rlIpFftAgingTimeout=rlIpFftAgingTimeout, rlIpFftSrcAddrSupported=rlIpFftSrcAddrSupported, rlIpxFftSubEntry=rlIpxFftSubEntry, rlIpmFftInDiscards=rlIpmFftInDiscards, rlIpFftStnDstIpAddress=rlIpFftStnDstIpAddress, rlIpxFftSubOutIfIndex=rlIpxFftSubOutIfIndex, rlIpxFftStnSrcNode=rlIpxFftStnSrcNode, rlIpxFftForwDatagrams=rlIpxFftForwDatagrams, rlIpFftNextHopIpAddress=rlIpFftNextHopIpAddress, rlIpxFftAgingTimeout=rlIpxFftAgingTimeout, rlIpFftStnTable=rlIpFftStnTable, rlIpxFftSubAge=rlIpxFftSubAge, rlIpFftL2InfoTable=rlIpFftL2InfoTable, rlIpFftNumSubRoutesNumber=rlIpFftNumSubRoutesNumber, rlIpFftSubNextHopIpAddr1=rlIpFftSubNextHopIpAddr1, rlIpxFftSubIndex=rlIpxFftSubIndex, rlIpFftNextHopNetAddress=rlIpFftNextHopNetAddress, rlIpxFftNumEntry=rlIpxFftNumEntry, rlIpxFftCountersIndex=rlIpxFftCountersIndex, rlIpFftNumStnRoutesNumber=rlIpFftNumStnRoutesNumber, rlIpmFftTable=rlIpmFftTable, rlIpmFftForwardAction=rlIpmFftForwardAction, rlIpFftStnDstMacAddress=rlIpFftStnDstMacAddress, rlIpxFftNumIndex=rlIpxFftNumIndex, rlIpxFftSubFacsIndex=rlIpxFftSubFacsIndex, rlIpmFftNumRoutesNumber=rlIpmFftNumRoutesNumber, rlIpmFftInputIfIndex=rlIpmFftInputIfIndex, rlIpFftStnEntry=rlIpFftStnEntry, rlIpFftCountersIndex=rlIpFftCountersIndex, rlIpmFftPortTagEntry=rlIpmFftPortTagEntry, rlIpMaxFftNumber=rlIpMaxFftNumber, rlIpFftStnTaggedMode=rlIpFftStnTaggedMode, rlIpmMaxFftNumber=rlIpmMaxFftNumber, rlIpFftSubNextHopIfindex7=rlIpFftSubNextHopIfindex7, rlIpxFftSubDstMacAddress=rlIpxFftSubDstMacAddress, rlIpFftSubNextHopIfindex8=rlIpFftSubNextHopIfindex8, rlIpxFftStnOutIfIndex=rlIpxFftStnOutIfIndex, rlIpxFftStnSrcNetid=rlIpxFftStnSrcNetid, rlIpFftSubnetSupported=rlIpFftSubnetSupported, rlIpmFFT=rlIpmFFT, rlIpFftInReceives=rlIpFftInReceives, rlIpxFftSubTable=rlIpxFftSubTable, rlIpmFftInputVlanTag=rlIpmFftInputVlanTag, rlIpFftYellowBoundary=rlIpFftYellowBoundary, rlIpxFftSubEncapsulation=rlIpxFftSubEncapsulation, rlIpFftStnSrcMacAddress=rlIpFftStnSrcMacAddress, rlIpFftStnVid=rlIpFftStnVid, rlIpmFftSrcIpMask=rlIpmFftSrcIpMask, rlIpmFftIndex=rlIpmFftIndex, rlIpFftNextHopVid=rlIpFftNextHopVid, rlIpxFftNumStnRoutesNumber=rlIpxFftNumStnRoutesNumber, rlIpmFftMibVersion=rlIpmFftMibVersion, rlIpmFftNumEntry=rlIpmFftNumEntry, rlIpxFftMibVersion=rlIpxFftMibVersion, rlIpFftL2InfoVid=rlIpFftL2InfoVid, rlIpxFftStnEncapsulation=rlIpxFftStnEncapsulation, rlIpmFftDynamicSupported=rlIpmFftDynamicSupported, rlIpmFftUserAgingTimeout=rlIpmFftUserAgingTimeout, rlIpmFftInReceives=rlIpmFftInReceives, rlIpFftStnAge=rlIpFftStnAge, rlIpFftCountersEntry=rlIpFftCountersEntry, rlIpFftSubNextHopIpAddr8=rlIpFftSubNextHopIpAddr8, rlIpFftNextHopMacAddress=rlIpFftNextHopMacAddress, rlIpmFftPortIndex=rlIpmFftPortIndex, rlIpFftSubDstIpSubnet=rlIpFftSubDstIpSubnet, rlIpxFftStnTable=rlIpxFftStnTable, rlIpFftMibVersion=rlIpFftMibVersion, Percents=Percents, rlIpxFftUnknownAddrMsgUsed=rlIpxFftUnknownAddrMsgUsed, rlIpFftSubNextHopIfindex6=rlIpFftSubNextHopIfindex6, rlIpFftL2InfoType=rlIpFftL2InfoType, rlIpxFftStnDstIpxAddrType=rlIpxFftStnDstIpxAddrType, rlIpFftAgingTimeSupported=rlIpFftAgingTimeSupported, rlIpmFftCountersIndex=rlIpmFftCountersIndex, rlIpmFftAge=rlIpmFftAge, rlIpFftSubNextHopIfindex2=rlIpFftSubNextHopIfindex2, rlIpmFftPortOutputifIndex=rlIpmFftPortOutputifIndex, rlIpFftNextHopReferenceCount=rlIpFftNextHopReferenceCount, rlIpxFftStnTci=rlIpxFftStnTci, PYSNMP_MODULE_ID=rlFFT, rlIpFftSubAge=rlIpFftSubAge, rlIpxFftStnIndex=rlIpxFftStnIndex, rlIpxFftStnDstMacAddress=rlIpxFftStnDstMacAddress, rlIpFftSubNextHopIfindex3=rlIpFftSubNextHopIfindex3, rlIpFftSubNextHopIpAddr3=rlIpFftSubNextHopIpAddr3)

#
# PySNMP MIB module PROBE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PROBE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:42:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion")
EntryStatus, OwnerString = mibBuilder.importSymbols("RMON-MIB", "EntryStatus", "OwnerString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, ModuleIdentity, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Bits, Unsigned32, NotificationType, Gauge32, Counter64, enterprises, iso, MibIdentifier, Integer32, ObjectIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "ModuleIdentity", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Bits", "Unsigned32", "NotificationType", "Gauge32", "Counter64", "enterprises", "iso", "MibIdentifier", "Integer32", "ObjectIdentity", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class AccessLevel(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4))

class ControlString(DisplayString):
    pass

hp = MibIdentifier((1, 3, 6, 1, 4, 1, 11))
nm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2))
hpExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 1))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3))
interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 4))
snmp = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13))
netElement = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7))
ntd = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 1, 5))
trap = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 1))
community = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 5))
lanprobe = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6))
general = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1))
lp1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 2))
lpEther = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 3))
lp2EtherV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 3, 1))
lp2EtherV2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 3, 2))
lp3Ether = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 3, 3))
pview = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 4))
lp2TokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 5))
lp2TokenRingV2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 5, 2))
lpFDDI = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 6))
lpFDDIV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 6, 1))
lpFDDIV2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 6, 2))
lpQ = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 7))
lpQuadEther = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 7, 2))
lpQuadEtherV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 7, 2, 1))
lpFE = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 9))
lpFastEther = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 9, 1))
lpFastEtherV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 9, 1, 1))
lpMultiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 10))
lpMultiportTokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 10, 1))
lpMultiportTokenRingV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 10, 1, 1))
lpMultiportEther = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 10, 2))
lpMultiportEtherV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 10, 2, 1))
lpT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 11))
lpT1Multiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 11, 1))
lpT1MultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 11, 1, 1))
lpE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 12))
lpE1Multiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 12, 1))
lpE1MultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 12, 1, 1))
lpVSeries = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 13))
lpVSeriesMultiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 13, 1))
lpVSeriesMultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 13, 1, 1))
lpHSSerial = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 14))
lpHSSI = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 14, 1))
lpHSSIV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 14, 1, 1))
lpT3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 15))
lpT3Multiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 15, 1))
lpT3MultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 15, 1, 1))
lpATMUTP = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 16))
lpATMUTPMultiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 16, 1))
lpATMUTPMultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 16, 1, 1))
lpATMOC3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 17))
lpATMOC3Multiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 17, 1))
lpATMOC3MultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 17, 1, 1))
lpATMT3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 18))
lpATMT3Multiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 18, 1))
lpATMT3MultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 18, 1, 1))
lpATME3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 19))
lpATME3Multiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 19, 1))
lpATME3MultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 19, 1, 1))
lpATMOC12 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 20))
lpATMOC12Multiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 20, 1))
lpATMOC12MultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 20, 1, 1))
lpATMGigabit = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 21))
lpATMGigabitMultiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 21, 1))
lpATMGigabitMultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 21, 1, 1))
lpE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 22))
lpE3Multiport = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 22, 1))
lpE3MultiportV1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 22, 1, 1))
probeAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1))
cableTest = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 2))
nodeLocation = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 3))
probeView = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 4))
rmonExtension = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5))
echoTest = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6))
cable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 7))
nodeLocatorII = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 8))
statsExtension = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1))
hostsExtension = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4))
filterExtension = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 7))
ethernet = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 4, 4))
serial = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 4, 5))
net = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 4, 6))
tokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 4, 7))
accessControl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1))
delivery = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3))
slip = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 15))
probeIdentification = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeIdentification.setStatus('mandatory')
if mibBuilder.loadTexts: probeIdentification.setDescription('A string uniquely identifying this device.')
probeFirmwareRev = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: probeFirmwareRev.setDescription('The firmware revision of this device.')
probeHardwareRev = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeHardwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: probeHardwareRev.setDescription('The hardware revision of this device.')
probeDateTime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(26, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: probeDateTime.setDescription("Probe's current date and time in the format: WWW MMM DD HH:MM:SS TTT YYYY (eg: 'Wed Jan 02 02:03:55 PST 1980'). The length of the timezone field can be from 1 to 15 octets. The timezone is stored for the convenience of the manager and is not used by the probe to adjust the probe's clock. If and when the timezone and clock changes, the manager must update probeDateTime. The timezone field has the default value of 'PST', Pacific Standard Time.")
probeResetControl = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("running", 1), ("warmBoot", 2), ("coldBoot", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeResetControl.setStatus('mandatory')
if mibBuilder.loadTexts: probeResetControl.setDescription('Setting this object to warmBoot(2) causes the device to restart the application software with current configuration parameters saved in non-volatile memory. Setting this object to coldBoot(3) causes the device to reinitialize configuration parameters in non-volatile memory to default values and restart the application software. When the device is running normally, this variable has a value of running(1).')
probeDownloadFile = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeDownloadFile.setStatus('mandatory')
if mibBuilder.loadTexts: probeDownloadFile.setDescription('The file name to be downloaded from the TFTP server.')
probeDownloadTFTPServer = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeDownloadTFTPServer.setStatus('mandatory')
if mibBuilder.loadTexts: probeDownloadTFTPServer.setDescription('The IP address of the TFTP server that contains the boot image to load.')
probeDownloadAction = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("imageValid", 1), ("downloadToPROM", 2), ("downloadToRAM", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeDownloadAction.setStatus('mandatory')
if mibBuilder.loadTexts: probeDownloadAction.setDescription('When this object is set to downloadToRAM(2) or downloadToPROM(3), the device will discontinue its normal operation and begin download of the image specified by probeDownLoadFile from the server specifed by probeDownLoadTFTPServer using the TFTP protocol. If downloadToRAM(2) is specified, the new image is copied to RAM only (the old image remains unaltered in the flash EPROM). If downloadToPROM(3) is specified (supported only by LanProbe-II), the new image is written to the flash EPROM memory after its checksum has been verified to be correct. When the download process is completed, the device will warm boot to restart the newly loaded application. When the device is not downloading, this object will have a value of imageValid(1).')
probeDownloadStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("downloadSuccess", 1), ("downloadFailed", 2), ("downloadStatusUnknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeDownloadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: probeDownloadStatus.setDescription('The status of the last download procedure, if any. This object will have a value of downloadStatusUnknown(3) if no download process has been performed.')
probeEchoInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 10), Integer32().clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: probeEchoInterval.setStatus('mandatory')
if mibBuilder.loadTexts: probeEchoInterval.setDescription('The probe will send an ICMP echo request (ping) to the default gateway every probeEchoInterval seconds. To force the probe not to send any echo requests, set probeEchoInterval to 0.')
probeFeatureDeactivate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: probeFeatureDeactivate.setStatus('mandatory')
if mibBuilder.loadTexts: probeFeatureDeactivate.setDescription('This integer represents ORed bit fields which can be set to deactivate certain features of a probe. Currently defined bit fields: Bit Feature To Deactivate --- --------------------- 0 Packet Capture 1 TFTP Firmware Download 2 Packet generation capability 3 Duplicate IP/changed IP processing ')
serialConfigTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1), )
if mibBuilder.loadTexts: serialConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: serialConfigTable.setDescription('A table of Serial interface configuration entries.')
serialConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1), ).setIndexNames((0, "PROBE-MIB", "serialIfIndex"))
if mibBuilder.loadTexts: serialConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: serialConfigEntry.setDescription('A set of configuration parameters for a particular serial interface on this device.')
serialIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfIndex.setDescription('The value of this object uniquely identifies the serial interface on this device for which this entry contains configuration parameters. The interface identified by a particular value of this object is the same interface as identified by the same value of the ifIndex object, defined in RFC 1213.')
serialIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: serialIpAddress.setDescription('The IP address of this serial interface.')
serialSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: serialSubnetMask.setDescription('The IP subnet mask of this serial interface.')
serialMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("modem", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialMode.setStatus('mandatory')
if mibBuilder.loadTexts: serialMode.setDescription('The type of incoming connection to expect on this serial interface.')
serialProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("slip", 1))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: serialProtocol.setDescription('The type of data link encapsulation to be used on this serial interface.')
serialSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("speed-300bps", 1), ("speed-1200bps", 2), ("speed-2400bps", 3), ("speed-4800bps", 4), ("speed-9600bps", 5), ("speed-14400bps", 6), ("speed-19200bps", 7), ("speed-38400bps", 8))).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: serialSpeed.setDescription('The data rate to configure this serial interface to on startup as well as after each serial connection.')
serialTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: serialTimeout.setDescription('This timeout value is used when the Management Station has initiated the conversation over the serial link. This variable represents the number of seconds of inactivity allowed before terminating the connection on this serial interface. Use the serialTrapTimeout in the case where the probe has initiated the connection for the purpose of sending a trap.')
serialModemInitString = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 8), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('^s^MATE0Q0V1X4 S0=1 S2=43^M')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialModemInitString.setStatus('mandatory')
if mibBuilder.loadTexts: serialModemInitString.setDescription('A control string which controls how a modem attached to this serial interface should be initialized. The initialization is performed once during startup and again after each connection is terminated if the associated serialMode has the value of modem(2).')
serialModemHangUpString = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 9), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('^d2^s+++^d2^sATH0^M^d2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialModemHangUpString.setStatus('mandatory')
if mibBuilder.loadTexts: serialModemHangUpString.setDescription('A control string which specifies how to disconnect a modem connection on this serial interface. This object is only meaningful if the associated serialMode has the value of modem(2).')
serialModemConnectResp = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('/CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n              CONNECT 4800/4800/CONNECT 9600/9600/CONNECT 14400/14400/\n              CONNECT 19200/19200/CONNECT 38400/38400/')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialModemConnectResp.setStatus('mandatory')
if mibBuilder.loadTexts: serialModemConnectResp.setDescription('An ASCII string conntaining substrings that desribe the expected modem connection response code and associated bps rate. The substrings are delimited by the first character in the string, for example: /CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/ CONNECT 4800/4800/CONNECT 9600/9600 will be interpreted as: response code bps rate CONNECT 300 CONNECT 1200 1200 CONNECT 2400 2400 CONNECT 4800 4800 CONNECT 9600 9600 The agent will use the information in this string to adjust the bps rate of this serial interface once a modem connection is established.')
serialModemNoConnectResp = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone('/NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialModemNoConnectResp.setStatus('mandatory')
if mibBuilder.loadTexts: serialModemNoConnectResp.setDescription('An ASCII string containing response codes that may be generated by a modem to report the reason why a connection attempt has failed. The response codes are delimited by the first character in the string, for example: /NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/ If one of these response codes is received via this serial interface while attempting to make a modem connection, the agent will issue the hang up command as specified by modemHangUpString.')
serialFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noFlowControl", 1), ("hardwareFlowControl", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: serialFlowControl.setDescription('The type of flow control to use on this serial interface.')
serialTrapTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialTrapTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: serialTrapTimeout.setDescription('This timeout value is used when the probe initiates the serial connection with the intention of sending a trap. This variable represents the number of seconds of inactivity allowed before terminating the connection on this serial interface.')
netConfigTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1), )
if mibBuilder.loadTexts: netConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigTable.setDescription('A table of network configuration entries.')
netConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1), ).setIndexNames((0, "PROBE-MIB", "netConfigIfIndex"))
if mibBuilder.loadTexts: netConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigEntry.setDescription('A set of configuration parameters for a particular network interface on this device.')
netConfigIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netConfigIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigIfIndex.setDescription('The value of this object uniquely identifies the physical interface on this device for which this entry contains configuration parameters. The interface identified by a particular value of this object is the same interface as identified by the same value of the ifIndex object, defined in RFC 1213.')
netConfigIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183))).clone(namedValues=NamedValues(("ifsp-1Mb", 1), ("ifsp-10Mb", 2), ("ifsp-100Mb", 3), ("ifsp-4Mb", 4), ("ifsp-16Mb", 5), ("ifsp-unspecified", 6), ("ifsp-20Mb", 7), ("ifsp-200Mb", 8), ("ifsp-1Gb", 9), ("ifsp-64000bps", 10), ("ifsp-128000bps", 11), ("ifsp-192000bps", 12), ("ifsp-256000bps", 13), ("ifsp-320000bps", 14), ("ifsp-384000bps", 15), ("ifsp-448000bps", 16), ("ifsp-512000bps", 17), ("ifsp-576000bps", 18), ("ifsp-640000bps", 19), ("ifsp-704000bps", 20), ("ifsp-768000bps", 21), ("ifsp-832000bps", 22), ("ifsp-896000bps", 23), ("ifsp-960000bps", 24), ("ifsp-1024000bps", 25), ("ifsp-1088000bps", 26), ("ifsp-1152000bps", 27), ("ifsp-1216000bps", 28), ("ifsp-1280000bps", 29), ("ifsp-1344000bps", 30), ("ifsp-1408000bps", 31), ("ifsp-1472000bps", 32), ("ifsp-1536000bps", 33), ("ifsp-1600000bps", 34), ("ifsp-1664000bps", 35), ("ifsp-1728000bps", 36), ("ifsp-1792000bps", 37), ("ifsp-1856000bps", 38), ("ifsp-1920000bps", 39), ("ifsp-1984000bps", 40), ("ifsp-56000bps", 41), ("ifsp-112000bps", 42), ("ifsp-168000bps", 43), ("ifsp-224000bps", 44), ("ifsp-280000bps", 45), ("ifsp-336000bps", 46), ("ifsp-392000bps", 47), ("ifsp-504000bps", 48), ("ifsp-560000bps", 49), ("ifsp-616000bps", 50), ("ifsp-672000bps", 51), ("ifsp-728000bps", 52), ("ifsp-784000bps", 53), ("ifsp-840000bps", 54), ("ifsp-952000bps", 55), ("ifsp-1008000bps", 56), ("ifsp-1064000bps", 57), ("ifsp-1120000bps", 58), ("ifsp-1176000bps", 59), ("ifsp-1232000bps", 60), ("ifsp-1288000bps", 61), ("ifsp-300bps", 62), ("ifsp-1200bps", 63), ("ifsp-2400bps", 64), ("ifsp-4800bps", 65), ("ifsp-7200bps", 66), ("ifsp-9600bps", 67), ("ifsp-12000bps", 68), ("ifsp-14400bps", 69), ("ifsp-19200bps", 70), ("ifsp-38400bps", 71), ("ifsp-57600bps", 72), ("ifsp-115200bps", 73), ("ifsp-34368kbps", 74), ("ifsp-44736kbps", 75), ("ifsp-155520kbps", 76), ("ifsp-622000kbps", 77), ("ifsp-2048000bps", 78), ("ifsp-1000kbps", 79), ("ifsp-1500kbps", 80), ("ifsp-2000kbps", 81), ("ifsp-2500kbps", 82), ("ifsp-3000kbps", 83), ("ifsp-3500kbps", 84), ("ifsp-4000kbps", 85), ("ifsp-4500kbps", 86), ("ifsp-5000kbps", 87), ("ifsp-5500kbps", 88), ("ifsp-6000kbps", 89), ("ifsp-6500kbps", 90), ("ifsp-7000kbps", 91), ("ifsp-7500kbps", 92), ("ifsp-8000kbps", 93), ("ifsp-8500kbps", 94), ("ifsp-9000kbps", 95), ("ifsp-9500kbps", 96), ("ifsp-10000kbps", 97), ("ifsp-10500kbps", 98), ("ifsp-11000kbps", 99), ("ifsp-11500kbps", 100), ("ifsp-12000kbps", 101), ("ifsp-12500kbps", 102), ("ifsp-13000kbps", 103), ("ifsp-13500kbps", 104), ("ifsp-14000kbps", 105), ("ifsp-14500kbps", 106), ("ifsp-15000kbps", 107), ("ifsp-15500kbps", 108), ("ifsp-16000kbps", 109), ("ifsp-16500kbps", 110), ("ifsp-17000kbps", 111), ("ifsp-17500kbps", 112), ("ifsp-18000kbps", 113), ("ifsp-18500kbps", 114), ("ifsp-19000kbps", 115), ("ifsp-19500kbps", 116), ("ifsp-20000kbps", 117), ("ifsp-20500kbps", 118), ("ifsp-21000kbps", 119), ("ifsp-21500kbps", 120), ("ifsp-22000kbps", 121), ("ifsp-22500kbps", 122), ("ifsp-23000kbps", 123), ("ifsp-23500kbps", 124), ("ifsp-24000kbps", 125), ("ifsp-24500kbps", 126), ("ifsp-25000kbps", 127), ("ifsp-25500kbps", 128), ("ifsp-26000kbps", 129), ("ifsp-26500kbps", 130), ("ifsp-27000kbps", 131), ("ifsp-27500kbps", 132), ("ifsp-28000kbps", 133), ("ifsp-28500kbps", 134), ("ifsp-29000kbps", 135), ("ifsp-29500kbps", 136), ("ifsp-30000kbps", 137), ("ifsp-30500kbps", 138), ("ifsp-31000kbps", 139), ("ifsp-31500kbps", 140), ("ifsp-32000kbps", 141), ("ifsp-32500kbps", 142), ("ifsp-33000kbps", 143), ("ifsp-33500kbps", 144), ("ifsp-34000kbps", 145), ("ifsp-34100kbps", 146), ("ifsp-34500kbps", 147), ("ifsp-35000kbps", 148), ("ifsp-35500kbps", 149), ("ifsp-36000kbps", 150), ("ifsp-36500kbps", 151), ("ifsp-37000kbps", 152), ("ifsp-37500kbps", 153), ("ifsp-38000kbps", 154), ("ifsp-38500kbps", 155), ("ifsp-39000kbps", 156), ("ifsp-39500kbps", 157), ("ifsp-40000kbps", 158), ("ifsp-40500kbps", 159), ("ifsp-41000kbps", 160), ("ifsp-41500kbps", 161), ("ifsp-42000kbps", 162), ("ifsp-42500kbps", 163), ("ifsp-43000kbps", 164), ("ifsp-43500kbps", 165), ("ifsp-44000kbps", 166), ("ifsp-44210kbps", 167), ("ifsp-44500kbps", 168), ("ifsp-45000kbps", 169), ("ifsp-45500kbps", 170), ("ifsp-46000kbps", 171), ("ifsp-46500kbps", 172), ("ifsp-47000kbps", 173), ("ifsp-47500kbps", 174), ("ifsp-48000kbps", 175), ("ifsp-48500kbps", 176), ("ifsp-49000kbps", 177), ("ifsp-49500kbps", 178), ("ifsp-50000kbps", 179), ("ifsp-50500kbps", 180), ("ifsp-51000kbps", 181), ("ifsp-51500kbps", 182), ("ifsp-52000kbps", 183)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: netConfigIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigIfSpeed.setDescription('The value of this object indicates the speed of the media. This is equivalent to the MIB-2 object ifSpeed.')
netConfigIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigIPAddress.setDescription('The IP address of this Net interface. The default value for this object is 0.0.0.0. If either the netConfigIPAddress or netConfigSubnetMask are 0.0.0.0, then when the device boots, it will use BOOTP to try to figure out what these values should be. Otherwise, if BOOTP fails, before the device can talk on the network, this value must be configured through a terminal attached to the device.')
netConfigSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigSubnetMask.setDescription('The subnet mask of this Net interface. The default value for this object is 0.0.0.0. If either the netConfigIPAddress or netConfigSubnetMask are 0.0.0.0, then when the device boots, it will use BOOTP to try to figure out what these values should be. Otherwise, if BOOTP fails, before the device can talk on the network, this value must be configured through a terminal attached to the device.')
netConfigRingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4095)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigRingNumber.setDescription("The value of this object uniquely identifies the physical ring number on which the probe resides. This variable is only meaningful on a Token Ring probe. If the user sets this value to -1, the probe will attempt to 'auto-discover' the ring number by sending a packet to the Ring Parameter Server. Setting this variable to any value other than -1 indicates that the user wants to explicitly set the ring number to the given value. This value will take effect the next time the probe is rebooted, or the next time a sourceRoutingTable entry is created.")
netConfigPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("monitorOnly", 1), ("telemetry", 2), ("monitorTransmit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigPortType.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigPortType.setDescription("This object indicates whether or not the port for this row (indicated in netConfigIfIndex) is monitor only or can transmit as well. If this port is monitorOnly the values of netConfigIpAddress and netConfigSubnetMask for this row are in reality don't cares.")
netConfigDefaultGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigDefaultGateway.setDescription('The IP Address of the default gateway for this Net interface.')
netConfigPhysicalConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("rj-45", 1), ("aui", 2), ("fiber", 3), ("bnc", 4), ("db-9", 5), ("db-25", 6), ("mini-bantam", 7), ("rj-48c", 8), ("db-37", 9), ("br-2", 10), ("hssi", 11), ("unknown", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigPhysicalConnector.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigPhysicalConnector.setDescription('The value of this object indicates the type of physical connector which is currently being used to connect the interface to the network.')
netConfigLinkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183))).clone(namedValues=NamedValues(("lksp-1Mb", 1), ("lksp-10Mb", 2), ("lksp-100Mb", 3), ("lksp-4Mb", 4), ("lksp-16Mb", 5), ("lksp-auto-negotiate", 6), ("lksp-20Mb", 7), ("lksp-200Mb", 8), ("lksp-1Gb", 9), ("lksp-64000bps", 10), ("lksp-128000bps", 11), ("lksp-192000bps", 12), ("lksp-256000bps", 13), ("lksp-320000bps", 14), ("lksp-384000bps", 15), ("lksp-448000bps", 16), ("lksp-512000bps", 17), ("lksp-576000bps", 18), ("lksp-640000bps", 19), ("lksp-704000bps", 20), ("lksp-768000bps", 21), ("lksp-832000bps", 22), ("lksp-896000bps", 23), ("lksp-960000bps", 24), ("lksp-1024000bps", 25), ("lksp-1088000bps", 26), ("lksp-1152000bps", 27), ("lksp-1216000bps", 28), ("lksp-1280000bps", 29), ("lksp-1344000bps", 30), ("lksp-1408000bps", 31), ("lksp-1472000bps", 32), ("lksp-1536000bps", 33), ("lksp-1600000bps", 34), ("lksp-1664000bps", 35), ("lksp-1728000bps", 36), ("lksp-1792000bps", 37), ("lksp-1856000bps", 38), ("lksp-1920000bps", 39), ("lksp-1984000bps", 40), ("lksp-56000bps", 41), ("lksp-112000bps", 42), ("lksp-168000bps", 43), ("lksp-224000bps", 44), ("lksp-280000bps", 45), ("lksp-336000bps", 46), ("lksp-392000bps", 47), ("lksp-504000bps", 48), ("lksp-560000bps", 49), ("lksp-616000bps", 50), ("lksp-672000bps", 51), ("lksp-728000bps", 52), ("lksp-784000bps", 53), ("lksp-840000bps", 54), ("lksp-952000bps", 55), ("lksp-1008000bps", 56), ("lksp-1064000bps", 57), ("lksp-1120000bps", 58), ("lksp-1176000bps", 59), ("lksp-1232000bps", 60), ("lksp-1288000bps", 61), ("lksp-300bps", 62), ("lksp-1200bps", 63), ("lksp-2400bps", 64), ("lksp-4800bps", 65), ("lksp-7200bps", 66), ("lksp-9600bps", 67), ("lksp-12000bps", 68), ("lksp-14400bps", 69), ("lksp-19200bps", 70), ("lksp-38400bps", 71), ("lksp-57600bps", 72), ("lksp-115200bps", 73), ("lksp-34368kbps", 74), ("lksp-44736kbps", 75), ("lksp-155520kbps", 76), ("lksp-622000kbps", 77), ("lksp-2048000bps", 78), ("lksp-1000kbps", 79), ("lksp-1500kbps", 80), ("lksp-2000kbps", 81), ("lksp-2500kbps", 82), ("lksp-3000kbps", 83), ("lksp-3500kbps", 84), ("lksp-4000kbps", 85), ("lksp-4500kbps", 86), ("lksp-5000kbps", 87), ("lksp-5500kbps", 88), ("lksp-6000kbps", 89), ("lksp-6500kbps", 90), ("lksp-7000kbps", 91), ("lksp-7500kbps", 92), ("lksp-8000kbps", 93), ("lksp-8500kbps", 94), ("lksp-9000kbps", 95), ("lksp-9500kbps", 96), ("lksp-10000kbps", 97), ("lksp-10500kbps", 98), ("lksp-11000kbps", 99), ("lksp-11500kbps", 100), ("lksp-12000kbps", 101), ("lksp-12500kbps", 102), ("lksp-13000kbps", 103), ("lksp-13500kbps", 104), ("lksp-14000kbps", 105), ("lksp-14500kbps", 106), ("lksp-15000kbps", 107), ("lksp-15500kbps", 108), ("lksp-16000kbps", 109), ("lksp-16500kbps", 110), ("lksp-17000kbps", 111), ("lksp-17500kbps", 112), ("lksp-18000kbps", 113), ("lksp-18500kbps", 114), ("lksp-19000kbps", 115), ("lksp-19500kbps", 116), ("lksp-20000kbps", 117), ("lksp-20500kbps", 118), ("lksp-21000kbps", 119), ("lksp-21500kbps", 120), ("lksp-22000kbps", 121), ("lksp-22500kbps", 122), ("lksp-23000kbps", 123), ("lksp-23500kbps", 124), ("lksp-24000kbps", 125), ("lksp-24500kbps", 126), ("lksp-25000kbps", 127), ("lksp-25500kbps", 128), ("lksp-26000kbps", 129), ("lksp-26500kbps", 130), ("lksp-27000kbps", 131), ("lksp-27500kbps", 132), ("lksp-28000kbps", 133), ("lksp-28500kbps", 134), ("lksp-29000kbps", 135), ("lksp-29500kbps", 136), ("lksp-30000kbps", 137), ("lksp-30500kbps", 138), ("lksp-31000kbps", 139), ("lksp-31500kbps", 140), ("lksp-32000kbps", 141), ("lksp-32500kbps", 142), ("lksp-33000kbps", 143), ("lksp-33500kbps", 144), ("lksp-34000kbps", 145), ("lksp-34100kbps", 146), ("lksp-34500kbps", 147), ("lksp-35000kbps", 148), ("lksp-35500kbps", 149), ("lksp-36000kbps", 150), ("lksp-36500kbps", 151), ("lksp-37000kbps", 152), ("lksp-37500kbps", 153), ("lksp-38000kbps", 154), ("lksp-38500kbps", 155), ("lksp-39000kbps", 156), ("lksp-39500kbps", 157), ("lksp-40000kbps", 158), ("lksp-40500kbps", 159), ("lksp-41000kbps", 160), ("lksp-41500kbps", 161), ("lksp-42000kbps", 162), ("lksp-42500kbps", 163), ("lksp-43000kbps", 164), ("lksp-43500kbps", 165), ("lksp-44000kbps", 166), ("lksp-44210kbps", 167), ("lksp-44500kbps", 168), ("lksp-45000kbps", 169), ("lksp-45500kbps", 170), ("lksp-46000kbps", 171), ("lksp-46500kbps", 172), ("lksp-47000kbps", 173), ("lksp-47500kbps", 174), ("lksp-48000kbps", 175), ("lksp-48500kbps", 176), ("lksp-49000kbps", 177), ("lksp-49500kbps", 178), ("lksp-50000kbps", 179), ("lksp-50500kbps", 180), ("lksp-51000kbps", 181), ("lksp-51500kbps", 182), ("lksp-52000kbps", 183)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigLinkSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigLinkSpeed.setDescription('Indicates the speed of the media (in one direction). For Fast Ethernet auto-negotiation and Token-Ring speed auto-detection, this value should be set to auto-negotiate. For Token-Ring, the default value should be 16Mb. For Fast Ethernet, the default value should be auto-negotiate. For V-Series WAN, the speed must be selected for the interface. For ATM, the speed can be determined by the interface card type. For T1 and E1, the speed should be calculated from the data channels and channel speed.')
netConfigDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half-duplex", 1), ("full-duplex", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigDuplex.setDescription('Indicates whether the interface supports half or full duplex mode. When LinkSpeed is set to auto-negotiate, this field has no effect. It will be set to the negotiated mode.')
netConfigLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("b8zs", 1), ("ami", 2), ("hdb3", 3), ("b3zs", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigLineCode.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigLineCode.setDescription('Line coding. The choices for this field are: B8ZS - Binary 8 Zeros Suppress. Used with more recent ESF T1 framing. Commonly used in 64 Kbps, fractional T1 and Primary Rate ISDN lines. Valid for T1. AMI - Alternate Mark Inversion. Usually the choice with D4 framing. Common in existing 56 Kbps DDS type circuits. Valid for T1 and E1. HDB3 - High Density Bipolar, 3 zeros. Valid for E1 and E3. B3ZS - Binary 3 Zeros Suppress. Valid for T3. This field applies only to the T1, E1 and T3/DS-3 WanProbes.')
netConfigFramingType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("esf", 1), ("d4", 2), ("withCRC4", 3), ("withoutCRC4", 4), ("m13", 5), ("cbitParity", 6), ("g804", 7), ("g751", 8), ("t1dm", 9), ("slic96", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigFramingType.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigFramingType.setDescription('Framing type. The choices for this field are: ESF - Extended Super Frame (24 frames/ESF). Valid for T1. D4 - Conventional Super Frame (12 frames/SF). Valid for T1. with CRC-4 - Cyclic Redundancy Check, 4 bits. Valid for E1. without CRC-4 - CRC not checked. Valid for E1. M13 - A DS-3 framing fromat. See C-Bit parity. Valid for T3. C-Bit Parity - The synchronous DS-3 C-Bit Parity is a structure that can be used to multiplex 28 DS-1 signals to the DS-3 signal level. In C-Bit Parity, the X-Bit channel is used to transmit failure conditions from the far end to the near end of a system. Valid for T3. G.832/G.804 - Valid with PLCP cell synchronization only. Valid for ATM E3. G.751 - Valid with HEC cell synchronization only. Valid for ATM E3. T1DM (DDS) - A.T&T. DDS Framing using D4 and time slot 24. Not Implemented at this time. SLIC-96 - Special version of D4 framing. Useds 4-D4 frames but changes some of the framing bits. Not Implemented at this time. This field applies only to the T1, E1, T3/DS-3 WanProbes and DS-3 and E3 ATMProbes.')
netConfigChannelRate = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("chnrt-56K", 1), ("chnrt-64K", 2), ("chnrt-1536000bps", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigChannelRate.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigChannelRate.setDescription('Channel Rate. The choices for this field are: 56K - Valid for T1. 64K - Valid for T1/E1. 1536bps - Valid for Channelized T3. This field applies only to the T1, E1 and T3/DS-3 WanProbes.')
netConfigDataChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigDataChannel.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigDataChannel.setDescription('This integer represents the ORed bit fields which can be set to indicate that the probe should monitor the specified channel on the incoming data line. A value of 1 in the bit position indicates that the channel is to be monitored. Channel 1 is in the least significant bit position. T1: 1 - 24 data channels. E1: 1 - 31 data channels. T3: 1 - 28 data channels. This field applies only to the T1, E1 and T3/DS-3 WanProbes.')
netConfigDataSense = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("inverted", 2), ("nrzi", 3))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigDataSense.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigDataSense.setDescription('Indicates whether the bits on the channel(s) being tested are inverted. A Mark is a signal pulse on the line. A Space is a bit time with no pulse. The choices for this field are: Normal - Indicates that the bits are not inverted; therefore a Mark is represented by a binary 1. Inverted - A Mark is represented by a binary 0. NRZI - Non-Return to Zero Invert (on zeros), bit timing follows derived line timing. Successive Marks or Spaces represent binary 1. Changes from Mark to Space or from Space to Mark represent a binary 0. This field applies only to the T1, E1, V-Series, T3/DS-3 WanProbes.')
netConfigLinkLayerType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("frameRelay", 1), ("x25", 2), ("hdlc", 3), ("sdlc", 4), ("aal5", 5), ("ppp", 6))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigLinkLayerType.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigLinkLayerType.setDescription('Indicates the type of link layer analysis to be performed on the incoming data. This field applies only to WanProbes and ATMProbes')
netConfigNetworkInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uni", 1), ("nni", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigNetworkInterface.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigNetworkInterface.setDescription('ATM network interface addressing mode. Valid values for this field are: NNI - Network to Network Interface. The Network to Network Interface (or Network to Node Interface) is similar to UNI but these is no 4-bit GFC field. The 4 extra bits are used as part of the VPI. UNI - User Network Interface. This field applies only to ATMProbes')
netConfigCellSynchronization = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hec", 1), ("plcp", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigCellSynchronization.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigCellSynchronization.setDescription('ATM network interface addressing mode. Valid values for this field are: HEC - The Header Error Control (DEC) is an 8-bit field and the fifth byte in the header of an ATM cell. The HEC value is calculated from the first four bytes of the cell header. If an error occurs in an ATM cell header, it will be detected in the HEC field. Cells with HEC errors that can not be corrected are discarded by the receiving node. The HEC field can also be used to determine the boundaries of a packet for cell delineation. Valid for ATM OC-3, ATM UTP, ATM T3, ATM E3 with G.832/G.804 framing. PLCP - Physical Layer Convergence Protocol. Each cell is preceded by a 2-byte framing pattern (A1, A2) to enable the receiver to synchronize to the cells. Valid for ATM OC-3, ATM UTP, ATM T3, ATM E3 with G.751 framing. This field applies only to ATMProbes')
netConfigReceiverMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("line", 1), ("monitor-jack", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigReceiverMode.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigReceiverMode.setDescription('Line: When monitoring, the selected challes are presented as the line and equipment signals for decoding and statistics. All changes are regenerated and passed through unaltered. Monitor_jack: Expect the lower amplitude, isolated T1 test point signal (increased receiver gain). Expect the higher ampliture E1 test point signal (-20dB) This field applies only to the T1, E1 and T3/DS-3 WanProbes.')
netConfigMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 1, 1, 20), Integer32().clone(8192)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netConfigMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: netConfigMaximumFrameSize.setDescription('The size of the buffer to be allocated at the physical layer for the reception of a frame from the network. Any frames which are longer than the maximum frame size will be reported as a errored frame. The number of buffers available to receive frames is (POOL SIZE / maximum frame size). Overallocation of this maximum frame size decreases the number of available buffers which could result in dropped frames during periods of heavy network utilization. The minimum accepted value is 1024. The maximum accepted value is 65535.')
netDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 4, 6, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: netDefaultGateway.setDescription('NOTE: Because, this variable has been obsoleted by the variable netConfigDefaultGateway, it will be deprecated in a future firmware release. Applications should migrate to the new MIB variable as soon as possible. The IP Address of the default gateway. This entry should be equal to the value of netConfigDefaultGateway.1 for multi-port probes.')
tokenRingSpeed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 4, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoDetect", 1), ("ringsp-4Mbps", 2), ("ringsp-16Mbps", 3))).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tokenRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: tokenRingSpeed.setDescription('NOTE: Because, this variable has been obsoleted by the netConfigLinkSpeed and netConfigIfSpeed, it will be deprecated in a future firmware release. Applications should migrate to the new MIB variables as soon as possible. This object specifies the speed of the token ring that is being connected to. If autoDetect(1) is selected, the correct value will be filled in in this object by the hardware after some ammount of time. This variable does not apply to Token-Ring interfaces on a multi-interface probe. Refer to netConfigLinkSpeed and netConfigIfSpeed in the netConfigTable.')
commAccessTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 1), )
if mibBuilder.loadTexts: commAccessTable.setStatus('mandatory')
if mibBuilder.loadTexts: commAccessTable.setDescription('A list of community access entries')
commAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 1, 1), ).setIndexNames((0, "PROBE-MIB", "commAccessIndex"))
if mibBuilder.loadTexts: commAccessEntry.setStatus('mandatory')
if mibBuilder.loadTexts: commAccessEntry.setDescription('A mapping of community name to access rights.')
commAccessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commAccessIndex.setStatus('mandatory')
if mibBuilder.loadTexts: commAccessIndex.setDescription('A unique index for this entry.')
commAccessCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commAccessCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: commAccessCommunity.setDescription('The community string to which this entry grants access. This string must be unique among the community strings defined in all entries of this table. This object may not be modifed if the associated commAccessStatus object is equal to valid(1).')
commAccessLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 1, 1, 3), AccessLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commAccessLevel.setStatus('mandatory')
if mibBuilder.loadTexts: commAccessLevel.setDescription('The access level for this community string. This object may not be modifed if the associated commAccessStatus object is equal to valid(1).')
commAccessOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 1, 1, 4), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commAccessOwner.setStatus('mandatory')
if mibBuilder.loadTexts: commAccessOwner.setDescription('The owner of this serial connection entry.')
commAccessStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 1, 1, 5), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commAccessStatus.setStatus('mandatory')
if mibBuilder.loadTexts: commAccessStatus.setDescription('The status of this community access entry. When this object is set to valid(1), if the commAccessCommunity for this row is not unique among commAccessCommunity objects for all valid rows, the set request will be rejected with badValue(3).')
clientTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 2), )
if mibBuilder.loadTexts: clientTable.setStatus('mandatory')
if mibBuilder.loadTexts: clientTable.setDescription('A list of client entries.')
clientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 2, 1), ).setIndexNames((0, "PROBE-MIB", "clientIndex"))
if mibBuilder.loadTexts: clientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: clientEntry.setDescription('A configuration that allows an SNMP community to send packets from a particular IP address.')
clientIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clientIndex.setStatus('mandatory')
if mibBuilder.loadTexts: clientIndex.setDescription('A value that uniquely identifies this client entry.')
clientIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: clientIpAddress.setDescription("An IP Address (or portion thereof) from which this device will accept SNMP packets with the associated community. The requesting entity's IP address is ANDed with the clientIpMask before being compared to the clientIpAddress. Note that if the clientIpMask is set to 0.0.0.0, a clientIpAddress of 0.0.0.0 matches all IP addresses. This object may not be modifed if the associated clientStatus object is equal to valid(1).")
clientIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: clientIpMask.setDescription("A mask to be ANDed with the requesting entity's IP address before comparison with clientIpAddress. If the result matches with clientIpAddress, then the address is authenticated. This object may not be modifed if the associated clientStatus object is equal to valid(1).")
clientCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: clientCommunity.setDescription('The community that can be used by the client represented by the associated IP Address. This object may not be modifed if the associated clientStatus object is equal to valid(1).')
clientOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 2, 1, 5), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientOwner.setStatus('mandatory')
if mibBuilder.loadTexts: clientOwner.setDescription('The owner of this client entry.')
clientStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 5, 1, 2, 1, 6), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clientStatus.setStatus('mandatory')
if mibBuilder.loadTexts: clientStatus.setDescription('The status of this client entry.')
trapDestTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3), )
if mibBuilder.loadTexts: trapDestTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestTable.setDescription('A list of trap destination entries.')
trapDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3, 1), ).setIndexNames((0, "PROBE-MIB", "trapDestIndex"))
if mibBuilder.loadTexts: trapDestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestEntry.setDescription('This entry includes a destination IP address to which to send traps for this community. It also includes a backup address in case the primary address does not acknowledge the trap.')
trapDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestIndex.setDescription('A value that uniquely identifies this trapDestEntry.')
trapDestCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestCommunity.setDescription('A community to which these destination IP addresses belong. This entry is associated with any eventEntries in the RMON MIB whose value of eventCommunity is equal to the value of this object. Every time an associated event entry sends a trap due to an event, that trap will be sent according to the addresses specified in this entry. This object may not be modifed if the associated trapDestStatus object is equal to valid(1).')
trapDestDeliveryType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("one-shot", 1))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestDeliveryType.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestDeliveryType.setDescription('If this object has the value one-shot(1), then the trap will be sent only once to the primary address without requiring acknowledgement. If this object has the value acknowleged(2), then the trap will be sent to the primary address expecting an acknowledgement. If the trap is not acknowledged within the time specified by trapMaxTimeOut, then the trap is retransmitted (with the same sequence number) to the primary address. The trap is retransmitted at most trapMaxRetries times until acknowledged. If the trap is still not acknowleged and the alternate address is not 0.0.0.0, then it is sent to the alternate address at most trapMaxRetries plus one times until acknowledged. This object may not be modifed if the associated trapDestStatus object is equal to valid(1).')
trapDestPrimaryIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestPrimaryIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestPrimaryIpAddress.setDescription('The primary IP address to which to send traps. This object may not be modifed if the associated trapDestStatus object is equal to valid(1).')
trapDestPrimaryIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestPrimaryIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestPrimaryIfIndex.setDescription('The value of this object uniquely identifies the interface on this device through which the host at trapPrimaryIpAddress can be reached. The interface identified by a particular value of this object is the same interface as identified by the same value of the ifIndex object, defined in RFC 1213. This object may not be modifed if the associated trapDestStatus object is equal to valid(1).')
trapDestOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3, 1, 8), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestOwner.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestOwner.setDescription('The owner of this trap destination entry.')
trapDestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 3, 3, 1, 9), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestStatus.setDescription('The status of this trap destination entry.')
serialConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 15, 5), )
if mibBuilder.loadTexts: serialConnectionTable.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectionTable.setDescription('A list of serial connection entries.')
serialConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1), ).setIndexNames((0, "PROBE-MIB", "serialConnectIndex"))
if mibBuilder.loadTexts: serialConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectionEntry.setDescription('Configuration for a SLIP link over a serial line.')
serialConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialConnectIndex.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectIndex.setDescription('A value that uniquely identifies this serialConnection entry.')
serialConnectDestIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialConnectDestIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectDestIpAddress.setDescription('The IP Address that can be reached at the other end of this serial connection. This object may not be modifed if the associated serialConnectStatus object is equal to valid(1).')
serialConnectType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("direct", 1), ("modem", 2), ("switch", 3), ("modem-switch", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialConnectType.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectType.setDescription('The type of outgoing connection to make. If this object has the value direct(1), then a direct serial connection is assumed. If this object has the value modem(2), then serialConnectDialString will be used to make a modem connection. If this object has the value switch(3), then serialConnectSwitchConnectSeq will be used to establish the connection over a serial data switch, and serialConnectSwitchDisconnectSeq will be used to terminate the connection. If this object has the value modem-switch(4), then a modem connection will be made first followed by the switch connection. This object may not be modifed if the associated serialConnectStatus object is equal to valid(1).')
serialConnectDialString = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 4), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialConnectDialString.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectDialString.setDescription("A control string which specifies how to dial the phone number in order to establish a modem connection. The string should include dialing prefix and suffix. For example: ``^s^MATD9,888-1234^M'' will instruct the Probe to send a carriage return followed by the dialing prefix ``ATD'', the phone number ``9,888-1234'', and a carriage return as the dialing suffix. This object may not be modifed if the associated serialConnectStatus object is equal to valid(1).")
serialConnectSwitchConnectSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 5), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialConnectSwitchConnectSeq.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectSwitchConnectSeq.setDescription('A control string which specifies how to establish a data switch connection. This object may not be modifed if the associated serialConnectStatus object is equal to valid(1).')
serialConnectSwitchDisconnectSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 6), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialConnectSwitchDisconnectSeq.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectSwitchDisconnectSeq.setDescription('A control string which specifies how to terminate a data switch connection. This object may not be modifed if the associated serialConnectStatus object is equal to valid(1).')
serialConnectSwitchResetSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 7), ControlString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialConnectSwitchResetSeq.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectSwitchResetSeq.setDescription('A control string which specifies how to reset a data switch in the event of a timeout. This object may not be modifed if the associated serialConnectStatus object is equal to valid(1).')
serialConnectOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 8), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialConnectOwner.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectOwner.setDescription('The owner of this serial connection entry.')
serialConnectStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 15, 5, 1, 9), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialConnectStatus.setStatus('mandatory')
if mibBuilder.loadTexts: serialConnectStatus.setDescription('The status of this serial connection entry. If the manager attempts to set this object to valid(1) when the serialConnectType is set to modem(2) or modem-switch(4) and the serialConnectDialString is a zero-length string or cannot be correctly parsed as a ConnectString, the set request will be rejected with badValue(3). If the manager attempts to set this object to valid(1) when the serialConnectType is set to switch(3) or modem-switch(4) and the serialConnectSwitchConnectSeq, the serialConnectSwitchDisconnectSeq, or the serialConnectSwitchResetSeq cannot be correctly parsed as ConnectStrings, the set request will be rejected with badValue(3). Note that in these cases, zero-length strings should be considered to be valid and parsable strings. Thus, a set request should not be rejected in the case where any of the three serialConnectSwitchxxxxxSeq strings are of 0 length. The set should only be rejected if a non-zero length string cannot be correctly parsed.')
currentUtilizationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: currentUtilizationPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: currentUtilizationPeriod.setDescription("The number of seconds over which the currentUtilization object is calculated. Any change to this variable causes the value of currentUtilization to be set to all 1's. On a multi-interface probe, this parameter applies only to interface index 1. Refer to currentUtilizationTable in this document for the current utilization parameters for the other interfaces on a multi- interface probe.")
currentUtilization = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: currentUtilization.setDescription("NOTE: Because, this variable has been obsoleted by the currentUtilizationTable, it will be deprecated in a future firmware release. Applications should migrate to the new MIB variable as soon as possible. The best estimate of the mean physical layer network utilization on the monitor's physical interface during the previous number of seconds defined by currentUtilizationPeriod. The units of this object are hundredths of a percent. Its value will normally be in the range (0..10000). A value of all 1's means that a full currentUtilizationPeriod has not passed since either monitor startup or the last time currentUtilizationPeriod was changed. On a multi-interface probe, this value applies only to interface index 1. Refer to currentUtilizationTable in this document for the current utilization value for the other interfaces on a multi- interface probe.")
currentUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 7), )
if mibBuilder.loadTexts: currentUtilizationTable.setStatus('mandatory')
if mibBuilder.loadTexts: currentUtilizationTable.setDescription('A table of current utilizations for multi-port probes.')
currentUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 7, 1), ).setIndexNames((0, "PROBE-MIB", "curUtilIfIndex"))
if mibBuilder.loadTexts: currentUtilizationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: currentUtilizationEntry.setDescription('The current utilization period and current utilization for a particular interface on a multi-interface probe.')
curUtilIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: curUtilIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: curUtilIfIndex.setDescription('The value of this object uniquely identifies the physical interface on this device for which this entry contains current utilization parameters. The interface identified by a particular value of this object is the same interface as identified by the same value of the ifIndex object, defined in RFC 1213.')
curUtilPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 7, 1, 2), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: curUtilPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: curUtilPeriod.setDescription("The number of seconds over which the current utilization object for this entry in the table is calculated. Any change to this variable causes the value of curUtil for this entry to be set to all 1's")
curUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: curUtil.setStatus('mandatory')
if mibBuilder.loadTexts: curUtil.setDescription("The best estimate of the mean physical layer network utilization on the monitor's physical interface during the previous number of seconds defined by curUtilPeriod for this entry in the table. The units of this object are hundredths of a percent. Its value will normally be in the range (0..10000). A value of all 1's means that a full curUtilPeriod for this entry in the table has not passed since either monitor startup or the last time curUtilPeriod was changed. For probes which support full-duplex media, this variable should reflect the mean physical layer network utilization for both directions combined. For example, if the two directions of a Fast Ethernet full duplex connection are 90% and 50%, this variable should reflect a value of 70%.")
curUtilReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: curUtilReceive.setStatus('mandatory')
if mibBuilder.loadTexts: curUtilReceive.setDescription("The best estimate of the mean physical layer network utilization on the monitor's physical interface during the previous number of seconds defined by curUtilPeriod for this entry in the table. The units of this object are hundredths of a percent. Its value will normally be in the range (0..10000). A value of all 1's means that a full curUtilPeriod for this entry in the table has not passed since either monitor startup or the last time curUtilPeriod was changed. For a LAN interface with the exception of the Fast Ethernet LanProbe option 201, this value should be zero. For the Fast Ethernet LanProbe option 201, a WanProbe or ATMProbe, this value should reflect the network traffic on the receive wires/cable.")
curUtilTransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 1, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: curUtilTransmit.setStatus('mandatory')
if mibBuilder.loadTexts: curUtilTransmit.setDescription("The best estimate of the mean physical layer network utilization on the monitor's physical interface during the previous number of seconds defined by curUtilPeriod for this entry in the table. The units of this object are hundredths of a percent. Its value will normally be in the range (0..10000). A value of all 1's means that a full curUtilPeriod for this entry in the table has not passed since either monitor startup or the last time curUtilPeriod was changed. For a LAN interface with the exception of the Fast Ethernet LanProbe option 201, this value should be zero. For the Fast Ethernet LanProbe option 201, a WanProbe or ATMProbe, this value should reflect the network traffic on the receive wires/cable.")
hostExtDuplicateNetAddresses = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtDuplicateNetAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtDuplicateNetAddresses.setDescription('This counter is incremented every time the monitor detects a second host using the same network address as another host. This object can be the target of an RMON alarm, for the purpose of discovering duplicate network addresses.')
hostExtDuplicateNetEvent = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostExtDuplicateNetEvent.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtDuplicateNetEvent.setDescription('The index of the eventEntry in the RMON MIB that is used whenever the value of hostExtDuplicateNetAddresses changes. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index.')
hostExtLastDuplicateNetAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtLastDuplicateNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtLastDuplicateNetAddress.setDescription('The network address that was being used by two different hosts (represented by hostExtLastDuplicateHost1 and hostExtLasDuplicateHost2). The value of this object will correspond with the detection event that caused the latest increment of the hostExtDuplicateNetAddresses object.')
hostExtLastDuplicateHost1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtLastDuplicateHost1.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtLastDuplicateHost1.setDescription('The MAC address of one of the two last hosts to be detected using a duplicate network level address. The value of this object will correspond with the detection event that caused the latest increment of the hostExtDuplicateNetAddresses object.')
hostExtLastDuplicateHost2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtLastDuplicateHost2.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtLastDuplicateHost2.setDescription('The MAC address of the other of the two last hosts to be detected using a duplicate network level address. The value of this object will correspond with the detection event that caused the latest increment of the hostExtDuplicateNetAddresses object.')
hostExtChangedNetAddresses = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtChangedNetAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtChangedNetAddresses.setDescription("This counter is incremented every time the monitor detects that a host has changed the network address it is using. It is not incremented by detection of a host's initial use of a network address. This object can be the target of an RMON alarm.")
hostExtChangedNetEvent = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostExtChangedNetEvent.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtChangedNetEvent.setDescription('The index of the eventEntry in the RMON MIB that is used whenever the value of hostExtChangedNetAddresses changes. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index.')
hostExtLastChangedHost = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtLastChangedHost.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtLastChangedHost.setDescription('The MAC address of the last host which was detected to have changed the network address it was using. The value of this object will correspond with the detection event that caused the latest increment of the hostExtChangedNetAddresses object.')
hostExtLastOldNetAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtLastOldNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtLastOldNetAddress.setDescription('The network address that the host represented by hostExtLastChangedHost was previously using. The value of this object will correspond with the detection event that caused the latest increment of the hostExtChangedNetAddresses object.')
hostExtLastNewNetAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtLastNewNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtLastNewNetAddress.setDescription('The network address that the host represented by hostExtLastChangedHost is currently using. The value of this object will correspond with the detection event that caused the latest increment of the hostExtChangedNetAddresses object.')
hostExtTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11), )
if mibBuilder.loadTexts: hostExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtTable.setDescription('A list of extensions to the RMON MIB Host Table')
hostExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11, 1), ).setIndexNames((0, "PROBE-MIB", "hostExtIndex"), (0, "PROBE-MIB", "hostExtMacAddress"))
if mibBuilder.loadTexts: hostExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtEntry.setDescription('A collection of additional statistics for a particular host that has been discovered on an interface of this device.')
hostExtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtIndex.setDescription('The set of collected host statistics of which this entry is a part. The set of hosts identified by a particular value of this index is associated with the hostControlEntry as identified by the same value of hostControlIndex.')
hostExtMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtMacAddress.setDescription('The physical address of this host.')
hostExtNetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ip", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtNetAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtNetAddrType.setDescription('The type of network address used in packets sent by this host.')
hostExtNetAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("known", 2), ("changedOnce", 3), ("multipleChanges", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtNetAddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtNetAddrStatus.setDescription('The level of knowledge the monitor has of the network address used by this host. Values greater than known(2) indicate that this host has used more than one network address since the last time the monitor restarted. A value of multipleChanges(4) might indicate that this host is acting as a router.')
hostExtNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtNetAddress.setDescription('The network address for this host. The expected length of this object is dependent on the value of hostExtNetAddrType. If hostExtNetAddrStatus == multipleChanges(4), and hostExtNetAddrType == ip(1), the value of this object is undefined.')
hostExtCreationOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtCreationOrder.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtCreationOrder.setDescription("An Index that defines the relative ordering of the creation time of hosts caputed for a particular hostControlEntry. This index shall be between 1 and N, where N is the value of the associated hostControlTableSize. The ordering of the indexes is based on the order of each entry's insertion into the table, in which entries added earlier have a lower index value than entries added later. Basically, this variable is exactly the same as the hostCreationOrder variable in the RMON MIB definition.")
hostExtLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 11, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostExtLastUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: hostExtLastUpdateTime.setDescription('The value of the SysUptime variable the last time that the corresponding hostEntry was updated.')
hostTimeExtTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12), )
if mibBuilder.loadTexts: hostTimeExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtTable.setDescription('A list of extensions to the RMON MIB Host Time Table')
hostTimeExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12, 1), ).setIndexNames((0, "PROBE-MIB", "hostTimeExtIndex"), (0, "PROBE-MIB", "hostTimeExtCreationOrder"))
if mibBuilder.loadTexts: hostTimeExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtEntry.setDescription('A collection of additional statistics for a particular host that has been discovered on an interface of this device.')
hostTimeExtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeExtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtIndex.setDescription('The set of collected host statistics of which this entry is a part. The set of hosts identified by a particular value of this index is associated with the hostControlEntry as identified by the same value of hostControlIndex.')
hostTimeExtMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeExtMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtMacAddress.setDescription('The physical address of this host.')
hostTimeExtNetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ip", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeExtNetAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtNetAddrType.setDescription('The type of network address used in packets sent by this host.')
hostTimeExtNetAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("known", 2), ("changedOnce", 3), ("multipleChanges", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeExtNetAddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtNetAddrStatus.setDescription('The level of knowledge the monitor has of the network address used by this host. Values greater than known(2) indicate that this host has used more than one network address since the last time the monitor restarted. A value of multipleChanges(4) might indicate that this host is acting as a router.')
hostTimeExtNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeExtNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtNetAddress.setDescription('The network address for this host. The expected length of this object is dependent on the value of hostTimeExtNetAddrType. If hostTimeExtNetAddrStatus == multipleChanges(4), and hostTimeExtNetAddrType == ip(1), the value of this object is undefined.')
hostTimeExtCreationOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeExtCreationOrder.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtCreationOrder.setDescription("An Index that defines the relative ordering of the creation time of hosts caputed for a particular hostControlEntry. This index shall be between 1 and N, where N is the value of the associated hostControlTableSize. The ordering of the indexes is based on the order of each entry's insertion into the table, in which entries added earlier have a lower index value than entries added later. Basically, this variable is exactly the same as the hostCreationOrder variable in the RMON MIB definition.")
hostTimeExtLastUpdateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 4, 12, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostTimeExtLastUpdateTime.setStatus('mandatory')
if mibBuilder.loadTexts: hostTimeExtLastUpdateTime.setDescription('The value of the SysUptime variable the last time that the corresponding hostEntry was updated.')
channelExtTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 7, 2), )
if mibBuilder.loadTexts: channelExtTable.setStatus('mandatory')
if mibBuilder.loadTexts: channelExtTable.setDescription('A list of extensions to RMON packet channel entries.')
channelExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 7, 2, 1), ).setIndexNames((0, "PROBE-MIB", "channelExtIndex"))
if mibBuilder.loadTexts: channelExtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: channelExtEntry.setDescription('A set of additional parameters for a RMON packet channel applied on a particular interface.')
channelExtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelExtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: channelExtIndex.setDescription('An index that uniquely identifies an entry in the channel table. Each such entry defines one channel, a logical data and event stream. The channel identified by a particular value of this object is identical to one associated with a like value of the RMON object channelIndex.')
channelExtSelfPktCapture = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("captureMyOwn", 1), ("ignoreMyOwn", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: channelExtSelfPktCapture.setStatus('mandatory')
if mibBuilder.loadTexts: channelExtSelfPktCapture.setDescription('The value of this object indicates whether or not packets that are sent to or from the MAC address of the monitor should pass through this channel.')
channelExtDropEvents = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 5, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelExtDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: channelExtDropEvents.setDescription('The total number of events in which packets were dropped for all channels due to lack of resources in the probe. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected.')
echoTestSSTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1), )
if mibBuilder.loadTexts: echoTestSSTable.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSTable.setDescription('A table of instructions for and results of one-shot network connectivity tests')
echoTestSSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1), ).setIndexNames((0, "PROBE-MIB", "echoTestSSIndex"))
if mibBuilder.loadTexts: echoTestSSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSEntry.setDescription('A collection of objects that describe the form of and give the results of a one-shot connectivity test to a given host.')
echoTestSSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestSSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSIndex.setDescription('An index that uniquely identifies an entry in the echoTestSS table. Each such entry defines a single shot echo test to the node corresponding to either the mac address or net address objects.')
echoTestSSIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestSSIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSIfIndex.setDescription('The value of this object uniquely identifies the interface on this remote network monitoring device on which the echo test will be performed. The interface identified by a particular value of this object is the same interface as identified by the same value of the ifIndex object, defined in RFC 1156 and RFC 1213.')
echoTestSSMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestSSMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSMacAddress.setDescription('The MAC level address for this host.')
echoTestSSNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestSSNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSNetAddress.setDescription('The network level address for this host.')
echoTestSSProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("icmp-echo", 1), ("ieee-802-2", 2), ("ethernet-ctp", 3), ("novell-802-3", 4), ("novell-ethernet", 5), ("vines-datalink", 6), ("appleTalk", 7), ("novell-802-2", 8))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestSSProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSProtocol.setDescription('The type of echo test to perform.')
echoTestSSTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 6), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestSSTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSTimeout.setDescription('The number of milliseconds to wait for a reply before retransmitting the echo request packet. Note that a monitor may impose a lower bound on this object if its timing facilities are limited.')
echoTestSSRetryAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestSSRetryAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSRetryAttempts.setDescription('The number of times to retransmit the echo request packet should a response packet not be received before echoTestSSTimeout expires.')
echoTestSSLastEchoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-results-available", 1), ("response-received", 2), ("response-timed-out", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestSSLastEchoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSLastEchoStatus.setDescription('The result of this echo test.')
echoTestSSResponseNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestSSResponseNumber.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSResponseNumber.setDescription('The number of echo request packets sent before a successful response packet was received. The value of this object will be non-zero only when echoTestSSLastEchoStatus is equal to response_received(2)')
echoTestSSResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestSSResponseTime.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSResponseTime.setDescription('The number of milliseconds between the time the last echo request packet was transmitted and a response packet was received. The value of this object will be non-zero only when echoTestSSLastEchoStatus is equal to response_received(2)')
echoTestSSOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 11), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestSSOwner.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
echoTestSSStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 1, 1, 12), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestSSStatus.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestSSStatus.setDescription('The status of this row.')
echoTestPeriodicTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2), )
if mibBuilder.loadTexts: echoTestPeriodicTable.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicTable.setDescription('A table of instructions for and results of periodic network connectivity tests')
echoTestPeriodicEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1), ).setIndexNames((0, "PROBE-MIB", "echoTestPeriodicIndex"))
if mibBuilder.loadTexts: echoTestPeriodicEntry.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicEntry.setDescription('A collection of objects that describe the form of and give the results of periodic connectivity tests to a given host.')
echoTestPeriodicIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicIndex.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicIndex.setDescription('An index that uniquely identifies an entry in the echoTestPeriodic table. Each such entry defines a periodic echo test to the node corresponding to either the mac address or net address objects.')
echoTestPeriodicIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicIfIndex.setDescription('The value of this object uniquely identifies the interface on this remote network monitoring device on which the echo test will be performed. The interface identified by a particular value of this object is the same interface as identified by the same value of the ifIndex object, defined in RFC 1156 and RFC 1213.')
echoTestPeriodicMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicMacAddress.setDescription('The MAC level address of this host.')
echoTestPeriodicNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicNetAddress.setDescription('The network level address of this host.')
echoTestPeriodicProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("icmp-echo", 1), ("ieee-802-2", 2), ("ethernet-ctp", 3), ("novell-802-3", 4), ("novell-ethernet", 5), ("vines-datalink", 6), ("appleTalk", 7), ("novell-802-2", 8))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicProtocol.setDescription('The type of echo test to perform. Note that only one test can be selected at a time.')
echoTestPeriodicTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 6), Integer32().clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicTimeout.setDescription('The number of milliseconds to wait for a reply before retransmitting the echo request packet. Note that a monitor may impose a lower bound on this object if its timing facilities are limited.')
echoTestPeriodicRetryAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicRetryAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicRetryAttempts.setDescription('The number of times to retransmit the echo request packet should a response packet not be received before echoTestPeriodicTimeout expires.')
echoTestPeriodicNoResponseEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicNoResponseEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicNoResponseEventIndex.setDescription('The index of the eventEntry in the RMON MIB that is used whenever the value of echoTestPeriodicLastEchoStatus changes to response_timed_out(3). The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index.')
echoTestPeriodicRespondedEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicRespondedEventIndex.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicRespondedEventIndex.setDescription('The index of the eventEntry in the RMON MIB that is used whenever the value of echoTestPeriodicLastEchoStatus changes from response_timed_out(3) to response_received(2). The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index.')
echoTestPeriodicEchoState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("no-echo-sent", 1), ("waiting-for-initial-response", 2), ("waiting-to-echo", 3), ("waiting-for-subsequent-response", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicEchoState.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicEchoState.setDescription("The current state of testing for this echoTestPeriodicEntry. Once a successful response has been received, this object will alternate between waiting_to_echo(3) and waiting_for_subsequent_response(4). Whenever the value of echoTestPeriodicLastEchoStatus changes to response_timed_out(3), this object's value will revert to waiting_for_initial_response(2).")
echoTestPeriodicLastEchoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-results-available", 1), ("response-received", 2), ("response-timed-out", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicLastEchoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicLastEchoStatus.setDescription('The result of the last echo test for this entry.')
echoTestPeriodicTotalOperations = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicTotalOperations.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicTotalOperations.setDescription('The total number of times that echoTestPeriod has expired and an echo test has been initiated for this host.')
echoTestPeriodicSuccessfulOperations = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicSuccessfulOperations.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicSuccessfulOperations.setDescription('The total number of times that an echo test has completed successfully with the reception of a correct response packet. This number will always be less than or equal to echoTestPeriodicTotalOperations.')
echoTestPeriodicMinRespTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicMinRespTime.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicMinRespTime.setDescription('The shortest time (in milliseconds) between request and response for all of the periodic echo tests that have been attempted for this host.')
echoTestPeriodicMaxRespTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicMaxRespTime.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicMaxRespTime.setDescription('The longest time (in milliseconds) between request and response for all of the periodic echo tests that have been attempted for this host.')
echoTestPeriodicLastRespTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicLastRespTime.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicLastRespTime.setDescription('The time (in milliseconds) between request and response for the last echo test attempted for this host. If the value of echoTestPeriodicLastEchoStatus for this host is not response_received(2), the value returned will be -1.')
echoTestPeriodicTotalRespTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicTotalRespTime.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicTotalRespTime.setDescription('The sum of all the response times (in milliseconds) for all of the periodic echo tests that have been attempted for this host. This object and echoTestPeriodicSuccessfulOperations can be used to calculate an average response time for this host')
echoTestPeriodicOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 18), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicOwner.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
echoTestPeriodicStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 19), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicStatus.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicStatus.setDescription('The status of this row.')
echoTestPeriodicSumOfSquaresTimeLo = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicSumOfSquaresTimeLo.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicSumOfSquaresTimeLo.setDescription('The sum of the square of all the response times (in milliseconds) for all of the periodic tests analogous to targetTotalResponseTime. This object, targetTotalResponseTime, and targetSuccessfulOperations can be used to calculate a standard deviation of response time for this host. This is the low order unsigned long portion of the value.')
echoTestPeriodicSumOfSquaresTimeHi = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicSumOfSquaresTimeHi.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicSumOfSquaresTimeHi.setDescription('The sum of the square of all the response times (in milliseconds) for all of the periodic tests analogous to targetTotalResponseTime. This object, targetTotalResponseTime, and targetSuccessfulOperations can be used to calculate a standard deviation of response time for this host. This is the high order unsigned long portion of the value.')
echoTestPeriodicFailedAttemptCount = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicFailedAttemptCount.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicFailedAttemptCount.setDescription('The total count of failed attempts')
echoTestPeriodicMinRespTime30MinInt = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicMinRespTime30MinInt.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicMinRespTime30MinInt.setDescription("Minimum response time (in milliseconds) value for the last 30 minute interval. The agent must update this object every 30 minutes, aligning to the system clock at every hour and half hour. If there is no valid value available for this object because the test hasn't been running for 30 minutes, or there was no response received in the last 30 minutes, -1 will be returned.")
echoTestPeriodicMaxRespTime30MinInt = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicMaxRespTime30MinInt.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicMaxRespTime30MinInt.setDescription("Maximum response time (in milliseconds) value for the last 30 minute interval. The agent must update this object every 30 minutes, aligning to the system clock at every hour and half hour. If there is no valid value available for this object because the test hasn't been running for 30 minutes, or there was no response received in the last 30 minutes, -1 will be returned.")
echoTestPeriodicMinRespTime5MinInt = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicMinRespTime5MinInt.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicMinRespTime5MinInt.setDescription("Minimum response time (in milliseconds) value for the last 5 minute interval. The agent must update this object every 5 minutes, aligning to the system clock at every 5 minute interval. If there is no valid value available for this object because the test hasn't been running for 5 minutes, or there was no response received in the last 5 minutes, -1 will be returned.")
echoTestPeriodicMaxRespTime5MinInt = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicMaxRespTime5MinInt.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicMaxRespTime5MinInt.setDescription("Maximum response time (in milliseconds) value for the last 5 minute interval. The agent must update this object every 5 minutes, aligning to the system clock at every 5 minute interval. If there is no valid value available for this object because the test hasn't been running for 5 minutes, or there was no response received in the last 5 minutes, -1 will be returned.")
echoTestPeriod = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriod.setDescription('This object indicates how long to wait (in seconds) after completion of a pass through the echoTestPeriodic table before starting a new pass. Whenever this object is set to zero(0), the periodic echo list is disabled. Whenever it is set to a non-zero value, an initial round of tests will be scheduled immediately, and subsequent rounds will start after the specified period. Note that a monitor may impose a lower bound on this object if its timing facilities are limited.')
echoTestPeriodicCount = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicCount.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicCount.setDescription('This object indicates how many complete passes through the echoTestPeriodicTable have occurred since it was last restarted. Its value will be zero(0) until the first pass is complete.')
echoTestResetSSTable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("table-is-empty", 1), ("table-in-use", 2), ("reset-the-table", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestResetSSTable.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestResetSSTable.setDescription("This is a control/status object for the echoTestSSTable. When there are entries in the table, this object's value is table-in-use(3). When set to reset-the-table(3), all entries are deleted, and this object's value changes to table-is-empty(1).")
echoTestResetPeriodicTable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("table-is-empty", 1), ("table-in-use", 2), ("reset-the-table", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestResetPeriodicTable.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestResetPeriodicTable.setDescription("This is a control/status object for the echoTestListTable. When there are entries in the table, this object's value is table_in_use(3). When set to reset_the_table(3), all entries are deleted, and this object's value changes to table_is_empty(1).")
echoTestPeriodicTableLastEdit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: echoTestPeriodicTableLastEdit.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicTableLastEdit.setDescription('The value of sysUpTime at the time of the last edit (create, delete, or modify) to the echoTestPeriodicTable')
echoTestPeriodicTableStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("recoveryRequest", 2), ("underRecovery", 3), ("beingModified", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestPeriodicTableStatus.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestPeriodicTableStatus.setDescription("The status of the PeriodicTable. Only those communities with level4 access shall have access to this object. When the agent sets the status of a row in the echoTestPeriodicTable to underCreation, it must set this object to beingModified(4). This object must be reset to valid(1) after the row leaves the underCreation state (either by being set to valid or invalid). The agent should not allow the management station to modify this object when it's value is beingModified(4). The status for any row should be ignored by a manager that has successfully placed the table underRecovery(3). Managers trying to operate on row status during the recovery operation should fail. Management stations which start walking the table after ensuring the table status is valid should ensure the table has remained unchanged during the walk by checking the PeriodicTableLastEdit. A management station cannot set the state to underRecovery(3). To initiate a recovery operation, the management station must set this object to recoveryRequest(2). The agent must clear the table entries when setting this object to recoveryRequest. If successful, the management station may download the echo test table. If unsuccessful, then the contents of the PeriodicTable cannot be guaranteed. The table shall exist in the underRecovery state until the management station has finished downloading the table and sets this object back to valid(1). If the agent determines the table has been in the underRecovery(3) state for an abornmally long time, it may decide that the management station has crashed. The agent then can set the clear the table and set this object to valid(1).")
echoTestNovellDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6, 1, 6, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: echoTestNovellDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: echoTestNovellDefaultGateway.setDescription('The MAC level address of the router through which Novell Echo packets are to be forwarded, if the echo test is to be performed outside of the subnet on which this probe is placed.')
echotestStatus = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6) + (0,1)).setObjects(("PROBE-MIB", "echoTestPeriodicMacAddress"), ("PROBE-MIB", "echoTestPeriodicNetAddress"), ("PROBE-MIB", "echoTestPeriodicProtocol"), ("PROBE-MIB", "echoTestPeriodicEchoState"), ("PROBE-MIB", "echoTestPeriodicLastEchoStatus"))
if mibBuilder.loadTexts: echotestStatus.setDescription('The SNMP trap that is generated when a LanProbe echo test status has changed and generates an event that is configured for sending SNMP traps.')
duplicateIP = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6) + (0,2)).setObjects(("PROBE-MIB", "hostExtDuplicateNetAddresses"), ("PROBE-MIB", "hostExtLastDuplicateHost1"), ("PROBE-MIB", "hostExtLastDuplicateHost2"), ("PROBE-MIB", "hostExtLastDuplicateNetAddress"))
if mibBuilder.loadTexts: duplicateIP.setDescription('The SNMP trap that is generated when the monitor detects a network level address is being used by two different hosts.')
changedIP = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 6) + (0,3)).setObjects(("PROBE-MIB", "hostExtChangedNetAddresses"), ("PROBE-MIB", "hostExtLastChangedHost"), ("PROBE-MIB", "hostExtLastOldNetAddress"), ("PROBE-MIB", "hostExtLastNewNetAddress"))
if mibBuilder.loadTexts: changedIP.setDescription('The SNMP trap that is generated when the monitor detects a host has changed the network level address it is using.')
mibBuilder.exportSymbols("PROBE-MIB", serialTimeout=serialTimeout, hostTimeExtNetAddress=hostTimeExtNetAddress, lpVSeriesMultiportV1=lpVSeriesMultiportV1, lpATMUTP=lpATMUTP, community=community, hp=hp, clientTable=clientTable, trapDestCommunity=trapDestCommunity, echoTestPeriodicRespondedEventIndex=echoTestPeriodicRespondedEventIndex, serialConnectDialString=serialConnectDialString, echoTestPeriodicNoResponseEventIndex=echoTestPeriodicNoResponseEventIndex, echoTestPeriodicTotalOperations=echoTestPeriodicTotalOperations, curUtilIfIndex=curUtilIfIndex, netConfigLineCode=netConfigLineCode, echoTestPeriodicNetAddress=echoTestPeriodicNetAddress, echoTestPeriodicTotalRespTime=echoTestPeriodicTotalRespTime, curUtilPeriod=curUtilPeriod, echoTestSSResponseTime=echoTestSSResponseTime, lpQ=lpQ, echotestStatus=echotestStatus, lpT1MultiportV1=lpT1MultiportV1, netConfigRingNumber=netConfigRingNumber, echoTestPeriodicTableStatus=echoTestPeriodicTableStatus, hostTimeExtTable=hostTimeExtTable, echoTestPeriodicMaxRespTime5MinInt=echoTestPeriodicMaxRespTime5MinInt, tokenRing=tokenRing, lpQuadEtherV1=lpQuadEtherV1, serialMode=serialMode, curUtilReceive=curUtilReceive, lpVSeriesMultiport=lpVSeriesMultiport, netConfigTable=netConfigTable, cable=cable, lpFDDIV1=lpFDDIV1, trap=trap, netConfigMaximumFrameSize=netConfigMaximumFrameSize, probeDateTime=probeDateTime, serialModemHangUpString=serialModemHangUpString, echoTestSSIndex=echoTestSSIndex, accessControl=accessControl, lpATMT3Multiport=lpATMT3Multiport, echoTestSSResponseNumber=echoTestSSResponseNumber, lpFDDIV2=lpFDDIV2, lpATMOC12Multiport=lpATMOC12Multiport, echoTestPeriodicTable=echoTestPeriodicTable, netConfigLinkLayerType=netConfigLinkLayerType, lpE3MultiportV1=lpE3MultiportV1, echoTestPeriodicEntry=echoTestPeriodicEntry, netConfigSubnetMask=netConfigSubnetMask, echoTestPeriodicMinRespTime=echoTestPeriodicMinRespTime, serialConnectOwner=serialConnectOwner, serialModemInitString=serialModemInitString, hostTimeExtLastUpdateTime=hostTimeExtLastUpdateTime, probeIdentification=probeIdentification, channelExtSelfPktCapture=channelExtSelfPktCapture, lpATMGigabitMultiport=lpATMGigabitMultiport, serialSpeed=serialSpeed, serialModemConnectResp=serialModemConnectResp, lpMultiportEther=lpMultiportEther, pview=pview, lpE3Multiport=lpE3Multiport, netConfigPortType=netConfigPortType, hostExtCreationOrder=hostExtCreationOrder, lpHSSI=lpHSSI, serialConfigEntry=serialConfigEntry, echoTestSSIfIndex=echoTestSSIfIndex, lp2TokenRing=lp2TokenRing, probeResetControl=probeResetControl, hpExperimental=hpExperimental, lpE1MultiportV1=lpE1MultiportV1, lpATMOC3=lpATMOC3, commAccessIndex=commAccessIndex, echoTestPeriod=echoTestPeriod, curUtil=curUtil, probeEchoInterval=probeEchoInterval, netConfigDefaultGateway=netConfigDefaultGateway, clientEntry=clientEntry, lpVSeries=lpVSeries, echoTestPeriodicOwner=echoTestPeriodicOwner, echoTestSSRetryAttempts=echoTestSSRetryAttempts, lpT1=lpT1, lpE3=lpE3, echoTestNovellDefaultGateway=echoTestNovellDefaultGateway, echoTestSSOwner=echoTestSSOwner, lpT3MultiportV1=lpT3MultiportV1, probeDownloadAction=probeDownloadAction, serialProtocol=serialProtocol, serialFlowControl=serialFlowControl, ntd=ntd, netConfigPhysicalConnector=netConfigPhysicalConnector, lpATMT3MultiportV1=lpATMT3MultiportV1, netConfigIPAddress=netConfigIPAddress, hostExtTable=hostExtTable, echoTestSSTable=echoTestSSTable, echoTestPeriodicEchoState=echoTestPeriodicEchoState, lpMultiport=lpMultiport, echoTestPeriodicFailedAttemptCount=echoTestPeriodicFailedAttemptCount, hostExtChangedNetAddresses=hostExtChangedNetAddresses, hostExtIndex=hostExtIndex, netConfigChannelRate=netConfigChannelRate, lpATMOC3Multiport=lpATMOC3Multiport, echoTest=echoTest, hostExtDuplicateNetEvent=hostExtDuplicateNetEvent, netConfigIfSpeed=netConfigIfSpeed, echoTestSSTimeout=echoTestSSTimeout, probeFirmwareRev=probeFirmwareRev, trapDestPrimaryIpAddress=trapDestPrimaryIpAddress, echoTestPeriodicTableLastEdit=echoTestPeriodicTableLastEdit, echoTestSSEntry=echoTestSSEntry, channelExtEntry=channelExtEntry, delivery=delivery, lpATMOC3MultiportV1=lpATMOC3MultiportV1, trapDestOwner=trapDestOwner, netElement=netElement, nodeLocation=nodeLocation, trapDestIndex=trapDestIndex, serialConnectStatus=serialConnectStatus, hostExtNetAddrStatus=hostExtNetAddrStatus, commAccessEntry=commAccessEntry, lp2EtherV1=lp2EtherV1, lpT3=lpT3, lpATME3Multiport=lpATME3Multiport, echoTestPeriodicMacAddress=echoTestPeriodicMacAddress, lpATMOC12MultiportV1=lpATMOC12MultiportV1, commAccessLevel=commAccessLevel, serialConnectIndex=serialConnectIndex, echoTestSSStatus=echoTestSSStatus, lpT1Multiport=lpT1Multiport, serialIfIndex=serialIfIndex, netConfigDuplex=netConfigDuplex, echoTestPeriodicProtocol=echoTestPeriodicProtocol, nm=nm, probeDownloadFile=probeDownloadFile, hostExtChangedNetEvent=hostExtChangedNetEvent, lpATMT3=lpATMT3, filterExtension=filterExtension, lp1=lp1, cableTest=cableTest, serial=serial, netConfigDataChannel=netConfigDataChannel, hostExtLastDuplicateHost2=hostExtLastDuplicateHost2, echoTestPeriodicSuccessfulOperations=echoTestPeriodicSuccessfulOperations, clientIpMask=clientIpMask, netConfigDataSense=netConfigDataSense, serialConnectDestIpAddress=serialConnectDestIpAddress, serialModemNoConnectResp=serialModemNoConnectResp, echoTestPeriodicIfIndex=echoTestPeriodicIfIndex, echoTestPeriodicCount=echoTestPeriodicCount, echoTestSSMacAddress=echoTestSSMacAddress, channelExtTable=channelExtTable, echoTestResetPeriodicTable=echoTestResetPeriodicTable, probeAdmin=probeAdmin, lpQuadEther=lpQuadEther, trapDestEntry=trapDestEntry, commAccessCommunity=commAccessCommunity, currentUtilization=currentUtilization, hostTimeExtIndex=hostTimeExtIndex, channelExtDropEvents=channelExtDropEvents, echoTestPeriodicMaxRespTime=echoTestPeriodicMaxRespTime, hostTimeExtMacAddress=hostTimeExtMacAddress, hostExtLastDuplicateHost1=hostExtLastDuplicateHost1, hostExtEntry=hostExtEntry, echoTestPeriodicLastRespTime=echoTestPeriodicLastRespTime, netConfigCellSynchronization=netConfigCellSynchronization, echoTestPeriodicMinRespTime5MinInt=echoTestPeriodicMinRespTime5MinInt, serialIpAddress=serialIpAddress, lpFastEtherV1=lpFastEtherV1, ethernet=ethernet, trapDestStatus=trapDestStatus, lpATMUTPMultiport=lpATMUTPMultiport, hostsExtension=hostsExtension, lpATMGigabitMultiportV1=lpATMGigabitMultiportV1, netConfigFramingType=netConfigFramingType, echoTestPeriodicRetryAttempts=echoTestPeriodicRetryAttempts, serialTrapTimeout=serialTrapTimeout, hostTimeExtCreationOrder=hostTimeExtCreationOrder, lpMultiportEtherV1=lpMultiportEtherV1, commAccessTable=commAccessTable, hostExtLastDuplicateNetAddress=hostExtLastDuplicateNetAddress, hostExtNetAddrType=hostExtNetAddrType, echoTestPeriodicMinRespTime30MinInt=echoTestPeriodicMinRespTime30MinInt, ControlString=ControlString, netDefaultGateway=netDefaultGateway, system=system, net=net, clientOwner=clientOwner, echoTestPeriodicTimeout=echoTestPeriodicTimeout, echoTestPeriodicMaxRespTime30MinInt=echoTestPeriodicMaxRespTime30MinInt, hostTimeExtNetAddrType=hostTimeExtNetAddrType, echoTestPeriodicStatus=echoTestPeriodicStatus, lp2EtherV2=lp2EtherV2, serialSubnetMask=serialSubnetMask, serialConnectSwitchResetSeq=serialConnectSwitchResetSeq, lpATMGigabit=lpATMGigabit, commAccessOwner=commAccessOwner, channelExtIndex=channelExtIndex, serialConnectionEntry=serialConnectionEntry, serialConnectionTable=serialConnectionTable, curUtilTransmit=curUtilTransmit, hostExtLastOldNetAddress=hostExtLastOldNetAddress, netConfigNetworkInterface=netConfigNetworkInterface, currentUtilizationEntry=currentUtilizationEntry, hostExtLastNewNetAddress=hostExtLastNewNetAddress, snmp=snmp, probeFeatureDeactivate=probeFeatureDeactivate, lpMultiportTokenRingV1=lpMultiportTokenRingV1, serialConnectType=serialConnectType, currentUtilizationTable=currentUtilizationTable, probeDownloadStatus=probeDownloadStatus, serialConfigTable=serialConfigTable, interface=interface, lanprobe=lanprobe, rmonExtension=rmonExtension, hostExtLastUpdateTime=hostExtLastUpdateTime, echoTestSSNetAddress=echoTestSSNetAddress, lpATMUTPMultiportV1=lpATMUTPMultiportV1, clientIpAddress=clientIpAddress, lp2TokenRingV2=lp2TokenRingV2, probeDownloadTFTPServer=probeDownloadTFTPServer, netConfigIfIndex=netConfigIfIndex, echoTestPeriodicIndex=echoTestPeriodicIndex, serialConnectSwitchConnectSeq=serialConnectSwitchConnectSeq, lpMultiportTokenRing=lpMultiportTokenRing, netConfigLinkSpeed=netConfigLinkSpeed, clientStatus=clientStatus, currentUtilizationPeriod=currentUtilizationPeriod, echoTestResetSSTable=echoTestResetSSTable, echoTestPeriodicSumOfSquaresTimeLo=echoTestPeriodicSumOfSquaresTimeLo, slip=slip, lpATME3=lpATME3, lpATMOC12=lpATMOC12, changedIP=changedIP, lpEther=lpEther, hostTimeExtEntry=hostTimeExtEntry, lpE1Multiport=lpE1Multiport, hostExtMacAddress=hostExtMacAddress, lpATME3MultiportV1=lpATME3MultiportV1, clientCommunity=clientCommunity, hostExtLastChangedHost=hostExtLastChangedHost, echoTestPeriodicLastEchoStatus=echoTestPeriodicLastEchoStatus, lpHSSIV1=lpHSSIV1, lpT3Multiport=lpT3Multiport, commAccessStatus=commAccessStatus, trapDestPrimaryIfIndex=trapDestPrimaryIfIndex, AccessLevel=AccessLevel, netConfigReceiverMode=netConfigReceiverMode, lp3Ether=lp3Ether, serialConnectSwitchDisconnectSeq=serialConnectSwitchDisconnectSeq, echoTestSSProtocol=echoTestSSProtocol, lpFE=lpFE, clientIndex=clientIndex, echoTestSSLastEchoStatus=echoTestSSLastEchoStatus, tokenRingSpeed=tokenRingSpeed, trapDestTable=trapDestTable, duplicateIP=duplicateIP)
mibBuilder.exportSymbols("PROBE-MIB", lpFastEther=lpFastEther, general=general, lpHSSerial=lpHSSerial, lpFDDI=lpFDDI, netConfigEntry=netConfigEntry, echoTestPeriodicSumOfSquaresTimeHi=echoTestPeriodicSumOfSquaresTimeHi, probeView=probeView, nodeLocatorII=nodeLocatorII, probeHardwareRev=probeHardwareRev, hostExtDuplicateNetAddresses=hostExtDuplicateNetAddresses, statsExtension=statsExtension, hostTimeExtNetAddrStatus=hostTimeExtNetAddrStatus, hostExtNetAddress=hostExtNetAddress, lpE1=lpE1, trapDestDeliveryType=trapDestDeliveryType)

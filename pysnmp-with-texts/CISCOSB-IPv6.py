#
# PySNMP MIB module CISCOSB-IPv6 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCOSB-IPv6
# Produced by pysmi-0.3.4 at Wed May  1 12:22:47 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
ipSpec, = mibBuilder.importSymbols("CISCOSB-IP", "ipSpec")
switch001, = mibBuilder.importSymbols("CISCOSB-MIB", "switch001")
IANAipRouteProtocol, = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressPrefixLength, InetAddress, InetAddressType, InetAutonomousSystemNumber = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength", "InetAddress", "InetAddressType", "InetAutonomousSystemNumber")
inetCidrRouteEntry, = mibBuilder.importSymbols("IP-FORWARD-MIB", "inetCidrRouteEntry")
ipv6RouterAdvertEntry, ipv6InterfaceEntry, ipAddressEntry, ipNetToPhysicalEntry = mibBuilder.importSymbols("IP-MIB", "ipv6RouterAdvertEntry", "ipv6InterfaceEntry", "ipAddressEntry", "ipNetToPhysicalEntry")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
mib_2, Counter64, ObjectIdentity, Counter32, IpAddress, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, zeroDotZero, TimeTicks, NotificationType, Integer32, Bits, MibIdentifier, Unsigned32, iso, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "mib-2", "Counter64", "ObjectIdentity", "Counter32", "IpAddress", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "zeroDotZero", "TimeTicks", "NotificationType", "Integer32", "Bits", "MibIdentifier", "Unsigned32", "iso", "ModuleIdentity")
RowStatus, TimeInterval, TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TimeInterval", "TruthValue", "TextualConvention", "DisplayString")
rlIPv6 = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129))
rlIPv6.setRevisions(('2008-09-25 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlIPv6.setRevisionsDescriptions(('Initial version of this MIB.',))
if mibBuilder.loadTexts: rlIPv6.setLastUpdated('200809250000Z')
if mibBuilder.loadTexts: rlIPv6.setOrganization('Cisco Small Business')
if mibBuilder.loadTexts: rlIPv6.setContactInfo('Postal: 170 West Tasman Drive San Jose , CA 95134-1706 USA Website: Cisco Small Business Home http://www.cisco.com/smb>;, Cisco Small Business Support Community <http://www.cisco.com/go/smallbizsupport>')
if mibBuilder.loadTexts: rlIPv6.setDescription('The private MIB module definition for IPv6 MIB.')
rlIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 19), )
if mibBuilder.loadTexts: rlIpAddressTable.setStatus('current')
if mibBuilder.loadTexts: rlIpAddressTable.setDescription('This table is parallel to ipAddressTable, and is used to add/delete IPv6 entries to/from that table. It contains private objects.')
rlIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 19, 1), )
ipAddressEntry.registerAugmentions(("CISCOSB-IPv6", "rlIpAddressEntry"))
rlIpAddressEntry.setIndexNames(*ipAddressEntry.getIndexNames())
if mibBuilder.loadTexts: rlIpAddressEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpAddressEntry.setDescription('An address mapping for a particular interface.')
rlIpAddressPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 19, 1, 1), InetAddressPrefixLength().clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlIpAddressPrefixLength.setStatus('current')
if mibBuilder.loadTexts: rlIpAddressPrefixLength.setDescription('The prefix length of this address.')
rlIpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unicast", 1), ("anycast", 2), ("broadcast", 3), ("multicast", 4))).clone('unicast')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpAddressType.setStatus('current')
if mibBuilder.loadTexts: rlIpAddressType.setDescription('Extend standard field ipAddressType to multicast')
rlipv6InterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20), )
if mibBuilder.loadTexts: rlipv6InterfaceTable.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceTable.setDescription('This table is parallel to ipv6InterfaceTable, and is used to configure additional interface parameters.')
rlipv6InterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20, 1), )
ipv6InterfaceEntry.registerAugmentions(("CISCOSB-IPv6", "rlipv6InterfaceEntry"))
rlipv6InterfaceEntry.setIndexNames(*ipv6InterfaceEntry.getIndexNames())
if mibBuilder.loadTexts: rlipv6InterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceEntry.setDescription('Additional configuration parameters for a particular interface.')
rlipv6InterfaceNdDadAttemps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlipv6InterfaceNdDadAttemps.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceNdDadAttemps.setDescription('ND Duplicated address detection number of attempts.')
rlipv6InterfaceAutoconfigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlipv6InterfaceAutoconfigEnable.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceAutoconfigEnable.setDescription('Enables or disables Stateless Address Auto configuration on specific interface.')
rlipv6InterfaceIcmpUnreachSendEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlipv6InterfaceIcmpUnreachSendEnable.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceIcmpUnreachSendEnable.setDescription('Enables or disables sending of ICMP Destination Unreachable Error on specific interface.')
rlipv6InterfaceLinkMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1280, 65535)).clone(1500)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlipv6InterfaceLinkMTU.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceLinkMTU.setDescription('The maximum transmission unit (MTU) size of IPv6 packets sent on an interface in bytes.')
rlipv6InterfaceMLDVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlipv6InterfaceMLDVersion.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceMLDVersion.setDescription('Set version of MLD protocol on specific interface.')
rlipv6InterfaceRetransmitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1000, 3600000), ))).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlipv6InterfaceRetransmitTime.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceRetransmitTime.setDescription('This value will be included in all IPv6 router advertisements sent out this interface. Very short intervals are not recommended in normal IPv6 operation. When a nondefault value is configured, the configured time is both advertised and used by the router itself. When value 0 is configured, 0 seconds (unspecified) advertised in router advertisements and the value 1000 milliseconds is used for the neighbor discovery activity of the router itself.')
rlipv6InterfaceIcmpRedirectSendEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlipv6InterfaceIcmpRedirectSendEnable.setStatus('current')
if mibBuilder.loadTexts: rlipv6InterfaceIcmpRedirectSendEnable.setDescription('Enables or disables sending of ICMP IPv6 redirect messages to re-send a packet through the same interface on which the packet was received.')
rlinetCidrRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 21), )
if mibBuilder.loadTexts: rlinetCidrRouteTable.setStatus('current')
if mibBuilder.loadTexts: rlinetCidrRouteTable.setDescription('This table is parallel to inetCidrRouteTable, and is used to configure or display additional route parameters.')
rlinetCidrRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 21, 1), )
inetCidrRouteEntry.registerAugmentions(("CISCOSB-IPv6", "rlinetCidrRouteEntry"))
rlinetCidrRouteEntry.setIndexNames(*inetCidrRouteEntry.getIndexNames())
if mibBuilder.loadTexts: rlinetCidrRouteEntry.setStatus('current')
if mibBuilder.loadTexts: rlinetCidrRouteEntry.setDescription('Additional parameters for a particular route.')
rlinetCidrRouteLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 21, 1, 1), Unsigned32().clone(4294967295)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlinetCidrRouteLifetime.setStatus('current')
if mibBuilder.loadTexts: rlinetCidrRouteLifetime.setDescription('The remaining length of time, in seconds, that this route will continue to be valid, i.e., time until deprecation. A value of 4,294,967,295 represents infinity.')
rlinetCidrRouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("ospfIntraArea", 1), ("ospfInterArea", 2), ("ospfExternalType1", 3), ("ospfExternalType2", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlinetCidrRouteInfo.setStatus('current')
if mibBuilder.loadTexts: rlinetCidrRouteInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's inetCidrRouteProto value.")
rlipNetToPhysicalTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 22), )
if mibBuilder.loadTexts: rlipNetToPhysicalTable.setStatus('current')
if mibBuilder.loadTexts: rlipNetToPhysicalTable.setDescription('This table is parallel to ipNetToPhysicalTable, and is used to configure or display additional neighbor parameters.')
rlipNetToPhysicalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 22, 1), )
ipNetToPhysicalEntry.registerAugmentions(("CISCOSB-IPv6", "rlipNetToPhysicalEntry"))
rlipNetToPhysicalEntry.setIndexNames(*ipNetToPhysicalEntry.getIndexNames())
if mibBuilder.loadTexts: rlipNetToPhysicalEntry.setStatus('current')
if mibBuilder.loadTexts: rlipNetToPhysicalEntry.setDescription('Additional parameters for a neighbor')
rlipNetToPhysicalIsRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 22, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlipNetToPhysicalIsRouter.setStatus('current')
if mibBuilder.loadTexts: rlipNetToPhysicalIsRouter.setDescription("This object has the value 'true(1)', if the neighbor is router; otherwise, the value is 'false(2)'.")
rlipNetToPhysicalReachableConfirmed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 22, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlipNetToPhysicalReachableConfirmed.setStatus('current')
if mibBuilder.loadTexts: rlipNetToPhysicalReachableConfirmed.setDescription('Time (in seconds) since the address was confirmed to be reachable. Only, relevant for dynamic entries.')
rlipv6IcmpErrorRatelimitInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 1), TimeInterval().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlipv6IcmpErrorRatelimitInterval.setStatus('current')
if mibBuilder.loadTexts: rlipv6IcmpErrorRatelimitInterval.setDescription('The time interval between tokens being placed in the bucket, each token represents a single ICMP error message. The interval measured in milliseconds.')
rlipv6IcmpErrorRatelimitBucketSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlipv6IcmpErrorRatelimitBucketSize.setStatus('current')
if mibBuilder.loadTexts: rlipv6IcmpErrorRatelimitBucketSize.setDescription('The maximum number of tokens stored in the bucket, each token represents a single ICMP error message.')
rlipv6LLDefaultZone = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 3), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlipv6LLDefaultZone.setStatus('current')
if mibBuilder.loadTexts: rlipv6LLDefaultZone.setDescription("The interface which would be used as the egress interface for packets sent without a specified IPv6Z interface identifier or with the default '0' identifier. Zero value means no default interface specified.")
rlIpv6GeneralPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 4), )
if mibBuilder.loadTexts: rlIpv6GeneralPrefixTable.setStatus('current')
if mibBuilder.loadTexts: rlIpv6GeneralPrefixTable.setDescription('This table defines general prefix description, based on which a number of longer, more specific, prefixes can be defined.')
rlIpv6GeneralPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 4, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlIpv6GeneralPrefixName"))
if mibBuilder.loadTexts: rlIpv6GeneralPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpv6GeneralPrefixEntry.setDescription('Single entry in general prefix table.')
rlIpv6GeneralPrefixName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 4, 1, 1), DisplayString())
if mibBuilder.loadTexts: rlIpv6GeneralPrefixName.setStatus('current')
if mibBuilder.loadTexts: rlIpv6GeneralPrefixName.setDescription('The name assigned to the prefix.')
rlIpv6GeneralPrefixInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 4, 1, 2), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6GeneralPrefixInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlIpv6GeneralPrefixInetAddrType.setDescription('Prefix inet address type. Has to be IPv6.')
rlIpv6GeneralPrefixInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 4, 1, 3), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6GeneralPrefixInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlIpv6GeneralPrefixInetAddr.setDescription('The IPv6 network assigned to the general prefix. This argument must be in the form documented in RFC4293 where the address is specified in hexadecimal using 16-bit values between colons.')
rlIpv6GeneralPrefixInetAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 4, 1, 4), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6GeneralPrefixInetAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: rlIpv6GeneralPrefixInetAddrPrefixLength.setDescription('Indicates the number of leading one bits that form the mask to be logical-ANDed with the inet address before being compared to the value in the rlIpv6GeneralPrefixInetAddr field.')
rlIpv6GeneralPrefixInterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 4, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6GeneralPrefixInterfaceId.setStatus('current')
if mibBuilder.loadTexts: rlIpv6GeneralPrefixInterfaceId.setDescription('Interface id to use when creating prefix based on point-to-point interface.')
rlIpv6GeneralPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 4, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6GeneralPrefixRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlIpv6GeneralPrefixRowStatus.setDescription('Row status.')
rlipv6MaximumHopsNumber = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlipv6MaximumHopsNumber.setStatus('current')
if mibBuilder.loadTexts: rlipv6MaximumHopsNumber.setDescription('Maximum number of hops used in router advertisements and all IPv6 packets that are originated by the router.')
rlIpv6RouterAdvertPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6), )
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixTable.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixTable.setDescription('This table defines IPv6 prefixes which are included in IPv6 Neighbor Discovery (ND) router advertisements.')
rlIpv6RouterAdvertPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlIpv6RouterAdvertPrefixIfIndex"), (0, "CISCOSB-IPv6", "rlIpv6RouterAdvertPrefixIsDefault"), (0, "CISCOSB-IPv6", "rlIpv6RouterAdvertPrefixInetAddrType"), (0, "CISCOSB-IPv6", "rlIpv6RouterAdvertPrefixInetAddr"), (0, "CISCOSB-IPv6", "rlIpv6RouterAdvertPrefixInetAddrPrefixLength"))
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixEntry.setDescription('Single entry in Neighbor Discovery Prefix table.')
rlIpv6RouterAdvertPrefixIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixIfIndex.setDescription("The index value that uniquely identifies the interface on which this prefix is configured. The interface identified by a particular value of this index is the same interface as identified by the same value of the IF-MIB's ifIndex.")
rlIpv6RouterAdvertPrefixIsDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 2), TruthValue())
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixIsDefault.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixIsDefault.setDescription("Indicates whether this object belongs to 'default' entry. Default entry contains specifics about advertising prefixes which were created from local ipv6 addresses.")
rlIpv6RouterAdvertPrefixInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 3), InetAddressType())
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixInetAddrType.setDescription('Prefix inet address type. Has to be IPv6.')
rlIpv6RouterAdvertPrefixInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 4), InetAddress())
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixInetAddr.setDescription('The IPv6 network prefix to include in router advertisements. This argument must be in the form documented in RFC4293 where the address is specified in hexadecimal using 16-bit values between colons.')
rlIpv6RouterAdvertPrefixInetAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 5), InetAddressPrefixLength())
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixInetAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixInetAddrPrefixLength.setDescription('The length of the IPv6 prefix. A decimal value that indicates how many of the high-order contiguous bits of the address comprise the prefix (the network portion of the address).')
rlIpv6RouterAdvertPrefixAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAdminStatus.setDescription('Admin status of the entry. Relevant only for default entry.')
rlIpv6RouterAdvertPrefixAdvertise = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAdvertise.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAdvertise.setDescription('Whether the prefix is included in router advertisements.')
rlIpv6RouterAdvertPrefixOnLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("onlink", 1), ("not-onlink", 2), ("off-link", 3))).clone('onlink')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixOnLinkStatus.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixOnLinkStatus.setDescription("If object has the value 'onlink(1)', this prefix is confidered as on-link. This prefix will be advertised with the L-bit set and will be present in the Routing Table. If object has the value 'not-onlink(2)', this prefix will be advertised with the L-bit clear, but connected state of the prefix will not be changed. If object has the value 'offlink(3)', this prefix is confidered as on-link. This prefix will be advertised with the L-bit clear, and will be not present in the Routing Table.")
rlIpv6RouterAdvertPrefixAutonomousFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 9), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAutonomousFlag.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAutonomousFlag.setDescription("If object has the value 'true(1)', this prefix indicates to hosts on the local link that the specified prefix can be used for IPv6 autoconfiguration. The prefix will be advertised with the A-bit set.")
rlIpv6RouterAdvertPrefixAdvPreferredLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 10), Unsigned32().clone(604800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAdvPreferredLifetime.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAdvPreferredLifetime.setDescription('The amount of time (in seconds) that the specified IPv6 prefix is advertised as being preferred.')
rlIpv6RouterAdvertPrefixAdvValidLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 11), Unsigned32().clone(2592000)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAdvValidLifetime.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixAdvValidLifetime.setDescription('The amount of time (in seconds) that the specified IPv6 prefix is advertised as being valid.')
rlIpv6RouterAdvertPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 6, 1, 12), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertPrefixRowStatus.setDescription('Row status.')
rlIpv6RouterAdvertTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 7), )
if mibBuilder.loadTexts: rlIpv6RouterAdvertTable.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertTable.setDescription('This table is parallel to inetCidrRouteTable, and is used to configure or display additional route parameters.')
rlIpv6RouterAdvertEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 7, 1), )
ipv6RouterAdvertEntry.registerAugmentions(("CISCOSB-IPv6", "rlIpv6RouterAdvertEntry"))
rlIpv6RouterAdvertEntry.setIndexNames(*ipv6RouterAdvertEntry.getIndexNames())
if mibBuilder.loadTexts: rlIpv6RouterAdvertEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertEntry.setDescription('Additional parameters for a particular route.')
rlIpv6RouterAdvertAdvIntervalOption = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 7, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertAdvIntervalOption.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertAdvIntervalOption.setDescription('Indicates to a visiting mobile node the interval at which that node may expect to receive RAs. The node may use this information in its movement detection algorithm.')
rlIpv6RouterAdvertRouterPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3))).clone('medium')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlIpv6RouterAdvertRouterPreference.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertRouterPreference.setDescription('Configures a default router preference (DRP) for the router on a specific interface.')
rlIpv6RouterAdvertIsCurHopLimitUserConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 7, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpv6RouterAdvertIsCurHopLimitUserConfigured.setStatus('current')
if mibBuilder.loadTexts: rlIpv6RouterAdvertIsCurHopLimitUserConfigured.setDescription('Indicates that hop limit value used in router advertisement is an user configured value and not necessarily value that is used by router itself.')
rlipv6InetCidrTableClear = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlipv6InetCidrTableClear.setStatus('current')
if mibBuilder.loadTexts: rlipv6InetCidrTableClear.setDescription('This scalar indicates to clear all ipv6 routes from inetCidrTable.')
rlIpv6PathMtuTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 9), )
if mibBuilder.loadTexts: rlIpv6PathMtuTable.setStatus('current')
if mibBuilder.loadTexts: rlIpv6PathMtuTable.setDescription("This table used to represent all Path MTU changes to specific destination received from 'packet-too-big' messages.")
rlIpv6PathMtuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 9, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlIpv6PathMtuEntryInetDestAddrType"), (0, "CISCOSB-IPv6", "rlIpv6PathMtuEntryInetDestAddr"))
if mibBuilder.loadTexts: rlIpv6PathMtuEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpv6PathMtuEntry.setDescription('Single entry in Path MTU table.')
rlIpv6PathMtuEntryInetDestAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 9, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rlIpv6PathMtuEntryInetDestAddrType.setStatus('current')
if mibBuilder.loadTexts: rlIpv6PathMtuEntryInetDestAddrType.setDescription('Prefix inet address type. Has to be IPv6.')
rlIpv6PathMtuEntryInetDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 9, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlIpv6PathMtuEntryInetDestAddr.setStatus('current')
if mibBuilder.loadTexts: rlIpv6PathMtuEntryInetDestAddr.setDescription('The IPv6 destination address for which packet-too-big message was received. This argument must be in the form documented in RFC4293 where the address is specified in hexadecimal using 16-bit values between colons.')
rlIpv6PathMtuEntryMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 9, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpv6PathMtuEntryMtu.setStatus('current')
if mibBuilder.loadTexts: rlIpv6PathMtuEntryMtu.setDescription('The MTU value that was received in packet-too-bug message for specific destination.')
rlIpv6PathMtuEntryAge = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 9, 1, 4), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpv6PathMtuEntryAge.setStatus('current')
if mibBuilder.loadTexts: rlIpv6PathMtuEntryAge.setDescription("This entry's age (seconds)")
rlInetStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28), )
if mibBuilder.loadTexts: rlInetStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteTable.setDescription("This entity's static (user configured) Inet Routing table. Entries are MAX-ACCESSible even if not used for forwarding ")
rlInetStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlInetStaticRouteDestType"), (0, "CISCOSB-IPv6", "rlInetStaticRouteDest"), (0, "CISCOSB-IPv6", "rlInetStaticRoutePfxLen"), (0, "CISCOSB-IPv6", "rlInetStaticRouteNextHopType"), (0, "CISCOSB-IPv6", "rlInetStaticRouteNextHop"), (0, "CISCOSB-IPv6", "rlInetStaticRouteIfIndex"))
if mibBuilder.loadTexts: rlInetStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteEntry.setDescription('A particular Static(user configured) route to a particular destination.')
rlInetStaticRouteDestType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInetStaticRouteDestType.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteDestType.setDescription('The type of the address used as the destination internetwork address or subnet address.')
rlInetStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlInetStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteDest.setDescription('Destination internetwork address or subnet address. The destination prefix length is applied to this value, and to a particular destination address, to determine whether the route applies to the particular address. If the prefix length is L, then applying the length to an address means taking the first L bits of the address.')
rlInetStaticRoutePfxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: rlInetStaticRoutePfxLen.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRoutePfxLen.setDescription('Indicates the number of leading one bits that form the mask to be logical-ANDed with the destination address before being compared to the value in the rlInetStaticRouteDest field.')
rlInetStaticRouteNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 4), InetAddressType())
if mibBuilder.loadTexts: rlInetStaticRouteNextHopType.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteNextHopType.setDescription('The type of the address used as the next-hop address for this route.')
rlInetStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 5), InetAddress())
if mibBuilder.loadTexts: rlInetStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteNextHop.setDescription("The next-hop IP address, if any. If rlInetStaticRouteAction is 'forward', there may or may not be a next-hop IP address. A next-hop IP address is not required if an output interface index is specified (in other words, if rlInetStaticRouteIfIndex is non-zero). If rlInetStaticRouteAction is not 'forward', there is no next-hop IP address. If there is no next-hop IP address, the rlInetStaticRouteNextHop object is set to all zeroes.")
rlInetStaticRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 6), InterfaceIndexOrZero())
if mibBuilder.loadTexts: rlInetStaticRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached. A value of 0 is valid and represents the scenario where no interface is specified.')
rlInetStaticRoutePathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 7), Unsigned32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInetStaticRoutePathCost.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRoutePathCost.setDescription('Path cost for this static route.')
rlInetStaticRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("reject", 2), ("local", 3), ("remote", 4), ("blackhole", 5), ("nd", 6))).clone('remote')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInetStaticRouteType.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteType.setDescription("Same as inetCidrRouteType MIB (excluded 'other' route type)")
rlInetStaticRouteOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("default", 3), ("icmp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInetStaticRouteOwner.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteOwner.setDescription('Static - The route is configured over Static IP. This route is written to configuration files. Dhcp - The route is Configured by DHCP (received as part of DHCP configuration) This route IS NOT written to configuration files Default - The route is Configured by default system config exists till any other configuration is applied. Icmp - The route is Configured by ICMP protocol either by router advertisements or to be advertised in router advertisements .')
rlInetStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 28, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInetStaticRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlInetStaticRouteRowStatus.setDescription('The row status variable, used according to row installation and removal conventions. A row entry cannot be modified when the status is marked as active(1).')
rlIpNetToPhysicalTableClearTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 10), )
if mibBuilder.loadTexts: rlIpNetToPhysicalTableClearTable.setStatus('current')
if mibBuilder.loadTexts: rlIpNetToPhysicalTableClearTable.setDescription('This entity is used to clear all or specific-type entries from ipNetToPhysicalTable.')
rlIpNetToPhysicalTableClearEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 10, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlIpNetToPhysicalTableClearIfIndex"))
if mibBuilder.loadTexts: rlIpNetToPhysicalTableClearEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpNetToPhysicalTableClearEntry.setDescription('A particular entry in this table.')
rlIpNetToPhysicalTableClearIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 10, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: rlIpNetToPhysicalTableClearIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpNetToPhysicalTableClearIfIndex.setDescription('Interface index of to clear or zero in case of whole table.')
rlIpNetToPhysicalTableClearScope = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("dynamicOnly", 2), ("staticOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpNetToPhysicalTableClearScope.setStatus('current')
if mibBuilder.loadTexts: rlIpNetToPhysicalTableClearScope.setDescription('Scope of the action - type of entries to delete.')
rlInetRoutingDistanceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 29), )
if mibBuilder.loadTexts: rlInetRoutingDistanceTable.setStatus('current')
if mibBuilder.loadTexts: rlInetRoutingDistanceTable.setDescription('This table defines administrative distances for different protocol routes that are inserted into the routing table.')
rlInetRoutingDistanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 29, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlInetRoutingDistanceType"))
if mibBuilder.loadTexts: rlInetRoutingDistanceEntry.setStatus('current')
if mibBuilder.loadTexts: rlInetRoutingDistanceEntry.setDescription('A set of distances per inet address type.')
rlInetRoutingDistanceType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 29, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInetRoutingDistanceType.setStatus('current')
if mibBuilder.loadTexts: rlInetRoutingDistanceType.setDescription('The inet address type for distance definitions set, either IPv4 or IPv6.')
rlInetRoutingDistanceConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 29, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInetRoutingDistanceConnected.setStatus('current')
if mibBuilder.loadTexts: rlInetRoutingDistanceConnected.setDescription('The administrative distance used for directly connected routes.')
rlInetRoutingDistanceStatic = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 29, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInetRoutingDistanceStatic.setStatus('current')
if mibBuilder.loadTexts: rlInetRoutingDistanceStatic.setDescription('The administrative distance used for static routes.')
rlInetRoutingDistanceRip = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 29, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInetRoutingDistanceRip.setStatus('current')
if mibBuilder.loadTexts: rlInetRoutingDistanceRip.setDescription('The administrative distance used for RIP routes.')
rlInetRoutingDistanceOspfInternal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 29, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInetRoutingDistanceOspfInternal.setStatus('current')
if mibBuilder.loadTexts: rlInetRoutingDistanceOspfInternal.setDescription('The administrative distance used for OSPF internal routes.')
rlInetRoutingDistanceOspfExternal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 29, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInetRoutingDistanceOspfExternal.setStatus('current')
if mibBuilder.loadTexts: rlInetRoutingDistanceOspfExternal.setDescription('The administrative distance used for OSPF Autonomous System external routes.')
rlInternInetCidrRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30), )
if mibBuilder.loadTexts: rlInternInetCidrRouteTable.setReference('RFC 1213 Section 6.6, The IP Group')
if mibBuilder.loadTexts: rlInternInetCidrRouteTable.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteTable.setDescription("Internal inetCidrRouteTable - this entity's IP Routing table.")
rlInternInetCidrRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlInternInetCidrRouteDestType"), (0, "CISCOSB-IPv6", "rlInternInetCidrRouteDest"), (0, "CISCOSB-IPv6", "rlInternInetCidrRoutePfxLen"), (0, "CISCOSB-IPv6", "rlInternInetCidrRoutePolicy"), (0, "CISCOSB-IPv6", "rlInternInetCidrRouteNextHopType"), (0, "CISCOSB-IPv6", "rlInternInetCidrRouteNextHop"))
if mibBuilder.loadTexts: rlInternInetCidrRouteEntry.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteEntry.setDescription('A particular route to a particular destination, under a particular policy (as reflected in the rlInternInetCidrRoutePolicy object). Dynamically created rows will survive an agent reboot. Implementers need to be aware that if the total number of elements (octets or sub-identifiers) in rlInternInetCidrRouteDest, rlInternInetCidrRoutePolicy, and rlInternInetCidrRouteNextHop exceeds 111, then OIDs of column instances in this table will have more than 128 sub- identifiers and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
rlInternInetCidrRouteDestType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rlInternInetCidrRouteDestType.setReference('RFC 4001')
if mibBuilder.loadTexts: rlInternInetCidrRouteDestType.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteDestType.setDescription('The type of the rlInternInetCidrRouteDest address, as defined in the InetAddress MIB. Only those address types that may appear in an actual routing table are allowed as values of this object.')
rlInternInetCidrRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlInternInetCidrRouteDest.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteDest.setDescription('The destination IP address of this route. The type of this address is determined by the value of the rlInternInetCidrRouteDestType object. The values for the index objects rlInternInetCidrRouteDest and rlInternInetCidrRoutePfxLen must be consistent. When the value of rlInternInetCidrRouteDest (excluding the zone index, if one is present) is x, then the bitwise logical-AND of x with the value of the mask formed from the corresponding index object rlInternInetCidrRoutePfxLen MUST be equal to x. If not, then the index pair is not consistent and an inconsistentName error must be returned on SET or CREATE requests.')
rlInternInetCidrRoutePfxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: rlInternInetCidrRoutePfxLen.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRoutePfxLen.setDescription('Indicates the number of leading one bits that form the mask to be logical-ANDed with the destination address before being compared to the value in the rlInternInetCidrRouteDest field. The values for the index objects rlInternInetCidrRouteDest and rlInternInetCidrRoutePfxLen must be consistent. When the value of rlInternInetCidrRouteDest (excluding the zone index, if one is present) is x, then the bitwise logical-AND of x with the value of the mask formed from the corresponding index object rlInternInetCidrRoutePfxLen MUST be equal to x. If not, then the index pair is not consistent and an inconsistentName error must be returned on SET or CREATE requests.')
rlInternInetCidrRoutePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 4), ObjectIdentifier())
if mibBuilder.loadTexts: rlInternInetCidrRoutePolicy.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRoutePolicy.setDescription('This object is an opaque object without any defined semantics. Its purpose is to serve as an additional index that may delineate between multiple entries to the same destination. The value { 0 0 } shall be used as the default value for this object.')
rlInternInetCidrRouteNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 5), InetAddressType())
if mibBuilder.loadTexts: rlInternInetCidrRouteNextHopType.setReference('RFC 4001')
if mibBuilder.loadTexts: rlInternInetCidrRouteNextHopType.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteNextHopType.setDescription('The type of the rlInternInetCidrRouteNextHop address, as defined in the InetAddress MIB. Value should be set to unknown(0) for non-remote routes. Only those address types that may appear in an actual routing table are allowed as values of this object.')
rlInternInetCidrRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 6), InetAddress())
if mibBuilder.loadTexts: rlInternInetCidrRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteNextHop.setDescription('On remote routes, the address of the next system en route. For non-remote routes, a zero length string. The type of this address is determined by the value of the rlInternInetCidrRouteNextHopType object.')
rlInternInetCidrRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 7), InterfaceIndexOrZero())
if mibBuilder.loadTexts: rlInternInetCidrRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached. A value of 0 is valid and represents the scenario where no interface is specified.')
rlInternInetCidrRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4), ("blackhole", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteType.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteType.setDescription('The type of route. Note that local(3) refers to a route for which the next hop is the final destination; remote(4) refers to a route for which the next hop is not the final destination. Routes that do not result in traffic forwarding or rejection should not be displayed, even if the implementation keeps them stored internally. reject(2) refers to a route that, if matched, discards the message as unreachable and returns a notification (e.g., ICMP error) to the message sender. This is used in some protocols as a means of correctly aggregating routes. blackhole(5) refers to a route that, if matched, discards the message silently.')
rlInternInetCidrRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 9), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteProto.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
rlInternInetCidrRouteAge = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteAge.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of 'too old' can be implied, except through knowledge of the routing protocol by which the route was learned.")
rlInternInetCidrRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 11), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteNextHopAS.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop. The semantics of this object are determined by the routing- protocol specified in the route's rlInternInetCidrRouteProto value. When this object is unknown or not relevant, its value should be set to zero.")
rlInternInetCidrRouteMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 12), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric1.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's rlInternInetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
rlInternInetCidrRouteMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 13), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric2.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's rlInternInetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
rlInternInetCidrRouteMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 14), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric3.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's rlInternInetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
rlInternInetCidrRouteMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 15), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric4.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's rlInternInetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
rlInternInetCidrRouteMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 16), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric5.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing- protocol specified in the route's rlInternInetCidrRouteProto value. If this metric is not used, its value should be set to -1.")
rlInternInetCidrRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 17), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteStatus.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteStatus.setDescription('The row status variable, used according to row installation and removal conventions. A row entry cannot be modified when the status is marked as active(1).')
rlInternInetCidrRouteLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 18), Unsigned32().clone(4294967295)).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteLifetime.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteLifetime.setDescription('The remaining length of time, in seconds, that this route will continue to be valid, i.e., time until deprecation. A value of 4,294,967,295 represents infinity.')
rlInternInetCidrRouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 30, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("ospfIntraArea", 1), ("ospfInterArea", 2), ("ospfExternalType1", 3), ("ospfExternalType2", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetCidrRouteInfo.setStatus('current')
if mibBuilder.loadTexts: rlInternInetCidrRouteInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's inetCidrRouteProto value.")
rlInternInetStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31), )
if mibBuilder.loadTexts: rlInternInetStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteTable.setDescription("This entity's static (user configured) Inet Routing table. Entries are MAX-ACCESSible even if not used for forwarding ")
rlInternInetStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlInternInetStaticRouteDestType"), (0, "CISCOSB-IPv6", "rlInternInetStaticRouteDest"), (0, "CISCOSB-IPv6", "rlInternInetStaticRoutePfxLen"), (0, "CISCOSB-IPv6", "rlInternInetStaticRouteNextHopType"), (0, "CISCOSB-IPv6", "rlInternInetStaticRouteNextHop"), (0, "CISCOSB-IPv6", "rlInternInetStaticRouteIfIndex"))
if mibBuilder.loadTexts: rlInternInetStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteEntry.setDescription('A particular Static(user configured) route to a particular destination.')
rlInternInetStaticRouteDestType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetStaticRouteDestType.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteDestType.setDescription('The type of the address used as the destination internetwork address or subnet address.')
rlInternInetStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlInternInetStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteDest.setDescription('Destination internetwork address or subnet address. The destination prefix length is applied to this value, and to a particular destination address, to determine whether the route applies to the particular address. If the prefix length is L, then applying the length to an address means taking the first L bits of the address.')
rlInternInetStaticRoutePfxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: rlInternInetStaticRoutePfxLen.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRoutePfxLen.setDescription('Indicates the number of leading one bits that form the mask to be logical-ANDed with the destination address before being compared to the value in the rlInternInetStaticRouteDest field.')
rlInternInetStaticRouteNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 4), InetAddressType())
if mibBuilder.loadTexts: rlInternInetStaticRouteNextHopType.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteNextHopType.setDescription('The type of the address used as the next-hop address for this route.')
rlInternInetStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 5), InetAddress())
if mibBuilder.loadTexts: rlInternInetStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteNextHop.setDescription("The next-hop IP address, if any. If rlInternInetStaticRouteAction is 'forward', there may or may not be a next-hop IP address. A next-hop IP address is not required if an output interface index is specified (in other words, if rlInternInetStaticRouteIfIndex is non-zero). If rlInternInetStaticRouteAction is not 'forward', there is no next-hop IP address. If there is no next-hop IP address, the rlInternInetStaticRouteNextHop object is set to all zeroes.")
rlInternInetStaticRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 6), InterfaceIndexOrZero())
if mibBuilder.loadTexts: rlInternInetStaticRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached. A value of 0 is valid and represents the scenario where no interface is specified.')
rlInternInetStaticRoutePathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 7), Unsigned32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInternInetStaticRoutePathCost.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRoutePathCost.setDescription('Path cost for this static route.')
rlInternInetStaticRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("reject", 2), ("local", 3), ("remote", 4), ("blackhole", 5), ("nd", 6))).clone('remote')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInternInetStaticRouteType.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteType.setDescription("Same as inetCidrRouteType MIB (excluded 'other' route type)")
rlInternInetStaticRouteOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("default", 3), ("icmp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlInternInetStaticRouteOwner.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteOwner.setDescription('Static - The route is configured over Static IP. This route is written to configuration files. Dhcp - The route is Configured by DHCP (received as part of DHCP configuration) This route IS NOT written to configuration files Default - The route is Configured by default system config exists till any other configuration is applied. Icmp - The route is Configured by ICMP protocol either by router advertisements or to be advertised in router advertisements .')
rlInternInetStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 26, 31, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlInternInetStaticRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlInternInetStaticRouteRowStatus.setDescription('The row status variable, used according to row installation and removal conventions. A row entry cannot be modified when the status is marked as active(1).')
rlIpv6HostForwardingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11), )
if mibBuilder.loadTexts: rlIpv6HostForwardingTable.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingTable.setDescription("This entity's IPv6 host forwarding table.")
rlIpv6HostForwardingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1), ).setIndexNames((0, "CISCOSB-IPv6", "rlIpv6HostForwardingDestType"), (0, "CISCOSB-IPv6", "rlIpv6HostForwardingDest"), (0, "CISCOSB-IPv6", "rlIpv6HostForwardingPfxLen"), (0, "CISCOSB-IPv6", "rlIpv6HostForwardingNextHopType"), (0, "CISCOSB-IPv6", "rlIpv6HostForwardingNextHop"), (0, "CISCOSB-IPv6", "rlIpv6HostForwardingIfIndex"), (0, "CISCOSB-IPv6", "rlIpv6HostForwardingType"))
if mibBuilder.loadTexts: rlIpv6HostForwardingEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingEntry.setDescription('A particular Static(user configured) route to a particular destination.')
rlIpv6HostForwardingDestType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpv6HostForwardingDestType.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingDestType.setDescription('The type of the address used as the destination internetwork address or subnet address.')
rlIpv6HostForwardingDest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlIpv6HostForwardingDest.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingDest.setDescription('Destination internetwork address or subnet address.')
rlIpv6HostForwardingPfxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: rlIpv6HostForwardingPfxLen.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingPfxLen.setDescription('Indicates the number of leading one bits that form the mask to be logical-ANDed with the destination address before being compared to the value in the rlIpv6HostForwardingDest field.')
rlIpv6HostForwardingNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1, 4), InetAddressType())
if mibBuilder.loadTexts: rlIpv6HostForwardingNextHopType.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingNextHopType.setDescription('The type of the address used as the next-hop address for this route.')
rlIpv6HostForwardingNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1, 5), InetAddress())
if mibBuilder.loadTexts: rlIpv6HostForwardingNextHop.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingNextHop.setDescription('The next-hop IP address, if any. A next-hop IP address is not required if an output interface index is specified (in other words, if rlIpv6HostForwardingIfIndex is non-zero). If there is no next-hop IP address, the rlIpv6HostForwardingNextHop object is set to all zeroes.')
rlIpv6HostForwardingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1, 6), InterfaceIndexOrZero())
if mibBuilder.loadTexts: rlIpv6HostForwardingIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingIfIndex.setDescription('The ifIndex value that identifies the local interface through which the next hop of this route should be reached. A value of 0 is valid and represents the scenario where no interface is specified.')
rlIpv6HostForwardingType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("redirect", 1), ("local", 2), ("nd", 3), ("remote-static", 4), ("remote-dynamic", 5))))
if mibBuilder.loadTexts: rlIpv6HostForwardingType.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingType.setDescription('Forwarding type')
rlIpv6HostForwardingPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 11, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpv6HostForwardingPathCost.setStatus('current')
if mibBuilder.loadTexts: rlIpv6HostForwardingPathCost.setDescription('Path cost for this route.')
rlipv6EnabledByDefaultRemovedIfindex = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlipv6EnabledByDefaultRemovedIfindex.setStatus('current')
if mibBuilder.loadTexts: rlipv6EnabledByDefaultRemovedIfindex.setDescription('the MIB is relevant when mtsc parameter DHCPv6_client_enabled_by_default is TRUE. If the MIB has non zero value the meaning is that ipv6 interface has removed from configuration by the user on the interface and signs to application not to add ipv6 interface. Otherwise (zero value) - the meaning is that Ipv6 interface must be added. ')
rlManagementIpv6 = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 13), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlManagementIpv6.setStatus('current')
if mibBuilder.loadTexts: rlManagementIpv6.setDescription('The system management IPv6 address which is kept between system mode changes')
rlManagementIpv6Action = MibScalar((1, 3, 6, 1, 4, 1, 9, 6, 1, 101, 129, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlManagementIpv6Action.setStatus('current')
if mibBuilder.loadTexts: rlManagementIpv6Action.setDescription('The system management IPv6 action: clear - delete all ipv6 interfaces from startup configuration database except rlManagementIpv6')
mibBuilder.exportSymbols("CISCOSB-IPv6", rlInternInetCidrRouteTable=rlInternInetCidrRouteTable, rlInetRoutingDistanceOspfInternal=rlInetRoutingDistanceOspfInternal, rlIpv6RouterAdvertPrefixInetAddrPrefixLength=rlIpv6RouterAdvertPrefixInetAddrPrefixLength, rlInternInetCidrRoutePfxLen=rlInternInetCidrRoutePfxLen, rlIpv6RouterAdvertPrefixIsDefault=rlIpv6RouterAdvertPrefixIsDefault, PYSNMP_MODULE_ID=rlIPv6, rlInetRoutingDistanceType=rlInetRoutingDistanceType, rlManagementIpv6Action=rlManagementIpv6Action, rlIpNetToPhysicalTableClearIfIndex=rlIpNetToPhysicalTableClearIfIndex, rlIpv6PathMtuTable=rlIpv6PathMtuTable, rlInternInetCidrRoutePolicy=rlInternInetCidrRoutePolicy, rlIpv6GeneralPrefixName=rlIpv6GeneralPrefixName, rlInternInetStaticRouteTable=rlInternInetStaticRouteTable, rlInetStaticRouteNextHopType=rlInetStaticRouteNextHopType, rlIPv6=rlIPv6, rlInetStaticRouteRowStatus=rlInetStaticRouteRowStatus, rlInternInetStaticRoutePathCost=rlInternInetStaticRoutePathCost, rlInetRoutingDistanceEntry=rlInetRoutingDistanceEntry, rlIpv6HostForwardingDest=rlIpv6HostForwardingDest, rlInetStaticRouteIfIndex=rlInetStaticRouteIfIndex, rlInternInetCidrRouteNextHopType=rlInternInetCidrRouteNextHopType, rlipv6EnabledByDefaultRemovedIfindex=rlipv6EnabledByDefaultRemovedIfindex, rlIpv6RouterAdvertRouterPreference=rlIpv6RouterAdvertRouterPreference, rlInternInetStaticRouteOwner=rlInternInetStaticRouteOwner, rlInetStaticRoutePfxLen=rlInetStaticRoutePfxLen, rlInetStaticRoutePathCost=rlInetStaticRoutePathCost, rlInternInetStaticRouteNextHopType=rlInternInetStaticRouteNextHopType, rlInternInetCidrRouteAge=rlInternInetCidrRouteAge, rlInternInetCidrRouteProto=rlInternInetCidrRouteProto, rlInternInetCidrRouteDestType=rlInternInetCidrRouteDestType, rlInternInetCidrRouteMetric5=rlInternInetCidrRouteMetric5, rlInternInetCidrRouteLifetime=rlInternInetCidrRouteLifetime, rlipv6LLDefaultZone=rlipv6LLDefaultZone, rlInetStaticRouteType=rlInetStaticRouteType, rlipv6InterfaceLinkMTU=rlipv6InterfaceLinkMTU, rlIpAddressType=rlIpAddressType, rlIpv6RouterAdvertTable=rlIpv6RouterAdvertTable, rlIpv6PathMtuEntryInetDestAddr=rlIpv6PathMtuEntryInetDestAddr, rlInternInetCidrRouteNextHopAS=rlInternInetCidrRouteNextHopAS, rlipNetToPhysicalEntry=rlipNetToPhysicalEntry, rlIpv6PathMtuEntryAge=rlIpv6PathMtuEntryAge, rlIpNetToPhysicalTableClearTable=rlIpNetToPhysicalTableClearTable, rlIpv6RouterAdvertPrefixAutonomousFlag=rlIpv6RouterAdvertPrefixAutonomousFlag, rlipv6InterfaceTable=rlipv6InterfaceTable, rlInternInetStaticRouteIfIndex=rlInternInetStaticRouteIfIndex, rlInternInetCidrRouteDest=rlInternInetCidrRouteDest, rlInetStaticRouteDestType=rlInetStaticRouteDestType, rlIpv6RouterAdvertPrefixAdvPreferredLifetime=rlIpv6RouterAdvertPrefixAdvPreferredLifetime, rlipv6MaximumHopsNumber=rlipv6MaximumHopsNumber, rlIpv6HostForwardingIfIndex=rlIpv6HostForwardingIfIndex, rlIpv6GeneralPrefixInetAddrPrefixLength=rlIpv6GeneralPrefixInetAddrPrefixLength, rlInetStaticRouteTable=rlInetStaticRouteTable, rlipv6InterfaceAutoconfigEnable=rlipv6InterfaceAutoconfigEnable, rlInetStaticRouteEntry=rlInetStaticRouteEntry, rlipv6InterfaceMLDVersion=rlipv6InterfaceMLDVersion, rlInetStaticRouteOwner=rlInetStaticRouteOwner, rlIpv6RouterAdvertPrefixRowStatus=rlIpv6RouterAdvertPrefixRowStatus, rlInternInetCidrRouteMetric3=rlInternInetCidrRouteMetric3, rlManagementIpv6=rlManagementIpv6, rlinetCidrRouteLifetime=rlinetCidrRouteLifetime, rlIpv6RouterAdvertPrefixOnLinkStatus=rlIpv6RouterAdvertPrefixOnLinkStatus, rlinetCidrRouteTable=rlinetCidrRouteTable, rlipNetToPhysicalIsRouter=rlipNetToPhysicalIsRouter, rlInternInetCidrRouteNextHop=rlInternInetCidrRouteNextHop, rlInternInetCidrRouteEntry=rlInternInetCidrRouteEntry, rlInternInetStaticRouteDestType=rlInternInetStaticRouteDestType, rlIpv6RouterAdvertAdvIntervalOption=rlIpv6RouterAdvertAdvIntervalOption, rlIpv6PathMtuEntry=rlIpv6PathMtuEntry, rlIpv6RouterAdvertPrefixIfIndex=rlIpv6RouterAdvertPrefixIfIndex, rlinetCidrRouteEntry=rlinetCidrRouteEntry, rlIpv6RouterAdvertPrefixInetAddr=rlIpv6RouterAdvertPrefixInetAddr, rlIpNetToPhysicalTableClearScope=rlIpNetToPhysicalTableClearScope, rlipv6IcmpErrorRatelimitBucketSize=rlipv6IcmpErrorRatelimitBucketSize, rlInetRoutingDistanceTable=rlInetRoutingDistanceTable, rlInetRoutingDistanceOspfExternal=rlInetRoutingDistanceOspfExternal, rlipv6InetCidrTableClear=rlipv6InetCidrTableClear, rlInternInetCidrRouteType=rlInternInetCidrRouteType, rlipv6InterfaceIcmpRedirectSendEnable=rlipv6InterfaceIcmpRedirectSendEnable, rlIpv6HostForwardingNextHop=rlIpv6HostForwardingNextHop, rlInetRoutingDistanceConnected=rlInetRoutingDistanceConnected, rlIpv6GeneralPrefixTable=rlIpv6GeneralPrefixTable, rlIpv6GeneralPrefixEntry=rlIpv6GeneralPrefixEntry, rlInetStaticRouteNextHop=rlInetStaticRouteNextHop, rlinetCidrRouteInfo=rlinetCidrRouteInfo, rlIpv6RouterAdvertEntry=rlIpv6RouterAdvertEntry, rlipv6InterfaceNdDadAttemps=rlipv6InterfaceNdDadAttemps, rlInternInetStaticRoutePfxLen=rlInternInetStaticRoutePfxLen, rlIpv6RouterAdvertPrefixAdvertise=rlIpv6RouterAdvertPrefixAdvertise, rlIpAddressEntry=rlIpAddressEntry, rlIpv6HostForwardingPfxLen=rlIpv6HostForwardingPfxLen, rlipv6InterfaceIcmpUnreachSendEnable=rlipv6InterfaceIcmpUnreachSendEnable, rlipNetToPhysicalTable=rlipNetToPhysicalTable, rlInternInetStaticRouteEntry=rlInternInetStaticRouteEntry, rlIpv6GeneralPrefixInterfaceId=rlIpv6GeneralPrefixInterfaceId, rlIpv6HostForwardingEntry=rlIpv6HostForwardingEntry, rlInternInetCidrRouteMetric4=rlInternInetCidrRouteMetric4, rlIpv6PathMtuEntryMtu=rlIpv6PathMtuEntryMtu, rlInetRoutingDistanceStatic=rlInetRoutingDistanceStatic, rlIpv6RouterAdvertPrefixAdvValidLifetime=rlIpv6RouterAdvertPrefixAdvValidLifetime, rlIpv6HostForwardingType=rlIpv6HostForwardingType, rlIpv6HostForwardingPathCost=rlIpv6HostForwardingPathCost, rlInetRoutingDistanceRip=rlInetRoutingDistanceRip, rlInternInetCidrRouteIfIndex=rlInternInetCidrRouteIfIndex, rlIpv6RouterAdvertPrefixEntry=rlIpv6RouterAdvertPrefixEntry, rlInternInetStaticRouteRowStatus=rlInternInetStaticRouteRowStatus, rlipv6InterfaceRetransmitTime=rlipv6InterfaceRetransmitTime, rlInternInetStaticRouteDest=rlInternInetStaticRouteDest, rlIpv6GeneralPrefixInetAddr=rlIpv6GeneralPrefixInetAddr, rlIpv6RouterAdvertIsCurHopLimitUserConfigured=rlIpv6RouterAdvertIsCurHopLimitUserConfigured, rlInetStaticRouteDest=rlInetStaticRouteDest, rlIpAddressTable=rlIpAddressTable, rlIpv6RouterAdvertPrefixInetAddrType=rlIpv6RouterAdvertPrefixInetAddrType, rlIpAddressPrefixLength=rlIpAddressPrefixLength, rlipNetToPhysicalReachableConfirmed=rlipNetToPhysicalReachableConfirmed, rlInternInetStaticRouteType=rlInternInetStaticRouteType, rlIpv6HostForwardingDestType=rlIpv6HostForwardingDestType, rlIpv6HostForwardingNextHopType=rlIpv6HostForwardingNextHopType, rlInternInetCidrRouteStatus=rlInternInetCidrRouteStatus, rlIpv6GeneralPrefixInetAddrType=rlIpv6GeneralPrefixInetAddrType, rlIpNetToPhysicalTableClearEntry=rlIpNetToPhysicalTableClearEntry, rlIpv6RouterAdvertPrefixTable=rlIpv6RouterAdvertPrefixTable, rlInternInetCidrRouteMetric1=rlInternInetCidrRouteMetric1, rlInternInetStaticRouteNextHop=rlInternInetStaticRouteNextHop, rlIpv6HostForwardingTable=rlIpv6HostForwardingTable, rlipv6IcmpErrorRatelimitInterval=rlipv6IcmpErrorRatelimitInterval, rlIpv6RouterAdvertPrefixAdminStatus=rlIpv6RouterAdvertPrefixAdminStatus, rlInternInetCidrRouteMetric2=rlInternInetCidrRouteMetric2, rlIpv6PathMtuEntryInetDestAddrType=rlIpv6PathMtuEntryInetDestAddrType, rlIpv6GeneralPrefixRowStatus=rlIpv6GeneralPrefixRowStatus, rlipv6InterfaceEntry=rlipv6InterfaceEntry, rlInternInetCidrRouteInfo=rlInternInetCidrRouteInfo)

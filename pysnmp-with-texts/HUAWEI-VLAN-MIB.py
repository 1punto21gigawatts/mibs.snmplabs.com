#
# PySNMP MIB module HUAWEI-VLAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HUAWEI-VLAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:49:21 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
hwSlotIndex, hwFrameIndex, hwConfigChangeIP = mibBuilder.importSymbols("HUAWEI-DEVICE-MIB", "hwSlotIndex", "hwFrameIndex", "hwConfigChangeIP")
huaweiMgmt, = mibBuilder.importSymbols("HUAWEI-MIB", "huaweiMgmt")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, TimeTicks, IpAddress, ModuleIdentity, MibIdentifier, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, NotificationType, Unsigned32, Bits, iso, Gauge32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "TimeTicks", "IpAddress", "ModuleIdentity", "MibIdentifier", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "NotificationType", "Unsigned32", "Bits", "iso", "Gauge32", "Counter64")
DisplayString, RowStatus, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TruthValue", "TextualConvention")
hwVlan = ModuleIdentity((1, 3, 6, 1, 4, 1, 2011, 5, 6))
hwVlan.setRevisions(('2015-08-07 10:00', '2015-04-13 00:00', '2015-01-22 10:00', '2014-12-24 10:00', '2014-12-23 10:00', '2014-11-24 10:00', '2014-11-13 10:00', '2014-09-26 10:00', '2014-08-30 10:00', '2014-08-15 10:00', '2014-07-20 10:00', '2014-06-23 10:00', '2014-05-08 10:00', '2014-04-22 10:00', '2014-01-15 10:00', '2013-12-13 10:00', '2013-10-29 10:00', '2013-08-02 10:00', '2013-09-14 10:00', '2013-02-01 10:00', '2013-01-18 10:00', '2012-11-13 10:00', '2012-10-29 10:00', '2012-08-13 10:00', '2012-06-15 10:00', '2012-03-07 00:00', '2012-01-30 10:00', '2011-09-21 00:00', '2011-07-15 10:00', '2011-04-01 10:00', '2011-03-25 10:00', '2011-02-11 10:00', '2011-01-24 10:00', '2010-12-13 00:00', '2010-11-24 10:00', '2010-11-19 10:00', '2010-07-03 10:00', '2010-06-21 10:00', '2010-06-20 10:00', '2010-06-10 10:00', '2010-06-07 10:00', '2010-05-18 10:00', '2010-04-26 10:00', '2010-03-22 10:00', '2010-03-18 10:00', '2010-02-11 10:00', '2010-01-25 10:00', '2010-01-11 10:00', '2010-01-08 10:00', '2009-12-03 00:00', '2009-11-16 00:00', '2009-02-20 00:00', '2007-12-20 00:00', '2007-04-23 00:00', '2005-12-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hwVlan.setRevisionsDescriptions(('V3.83, modified the value range and description of hwIPv6MTU.', 'V3.82, modify the description of hwUpFlowAccountByte, hwDownFlowAccountByte, hwUpFlowAccountPacket, hwDownFlowAccountPacket, hwUpStreamPacket, hwDownStreamPacket, hwUpFlowAccountDiscardPacket, hwDownFlowAccountDiscardPacket.', 'V3.81, Added hwCableIPv6SourceVerify in hwVlanSrvProfTable.', 'V3.80, Added hwMethNativeVlan in hwVlanMngObject.', 'V3.79, modified the description of hwRegionPVCRowStatus, hwProfileRowStatus, hwVlanConnectRowStatus and hwDocsSrvVlanRowStatus.', 'V3.78, modified the description of hwVlanMethL2Forward.', 'V3.77, Added hwVlanMethL2Forward in hwVlanSrvProfTable.', 'V3.76, Added hwRouterRedirectReverse in hwVlanSrvProfTable and. modified the description of hwVlanInterfaceLinkStatus.', 'V3.75, modified the value range and description of hwVlanIndex.', 'V3.74, modified the description of hwVlanifUpTrap and hwVlanifDownTrap.', 'V3.73, added hwIPv4MTU.', 'V3.72, modified the option of hwUserBridging, hwDhcpMode and hwDhcpv6Mode. added hwIpv4ArpUnicastSwitch, hwIpv4ArpUnicastunkonwnpolicy, hwIpv6NsUnicastSwitch and hwIpv6NsUnicastunkonwnpolicy in hwVlanSrvProfTable.', 'V3.71, Added hwIgmpUserMaxVlanTag in hwVlanSrvProfTable.', 'V3.70, modified the value range of hwStackingVlanInnerEthernetType.', 'V3.69, modified the description of leaves.', 'V3.68, Added hwVlanAggregationSubVlanNdProxyStatus in hwVlanAggregationTable.', 'V3.67, added layer3option16 option to hwDhcpv6Mode. Added hwRipngTunnelSwitch in hwVlanSrvProfTable.', 'V3.66, added hwVOIPDhcpQosTable. Added hwVOIPIPAddressSrc in hwVOIPAddressTable. Added hwVOIPQosIPAddressSrc in hwVOIPQosTable.', 'V3.65, modified hwVlanDescription to hwVlanName. modified hwVlanDescriptionChangeInfoTrap to hwVlanNameChangeInfoTrap. added hwCableSourceVerify.', 'V3.64, added hwDocsSrvVlanIDTable.', 'V3.63, modified the description of hwVOIPAddressIndex in hwVOIPAddressTable.', 'V3.62, added hwDocsDefaultSrvVlanID.', 'V3.61, modified hwVlanName to hwVlanDescription. modified hwVlanNameChangeInfoTrap to hwVlanDescriptionChangeInfoTrap.', 'V3.60, modified the description of some leaves in hwVlanSrvProfTable.', 'V3.59, added hwPolicyMulticastFabric. modified the description of hwVlanAndVlanSrvProfOperInfoTrap.', 'V3.58, added hwIPv6MTU.', 'V3.57, added hwVlanAddInfoTrap, hwVlanDelInfoTrap, hwVlanAttrChangedInfoTrap and hwPortVlanChangedInfoTrap.', 'V3.56, added hwDoubleTagTunnelConfig. added hwDoubleTagTunnelIgmp, hwDoubleTagTunnelRip and hwDoubleTagTunnelDhcp in hwDoubleTagTunnelConfig.', 'V3.55, added hwVlanConnectTable. added hwVlanTrafficSuppressUnknowncastNetwork in hwVlanMIBTable. added hwDhcpRelayInterfaceRelayAgentSwitch in hwVlanSrvProfTable.', ' V3.54, Add hwVOIPAddressObtainMode and hwVOIPPPPOEClientName based on V3.52', ' V3.53, Add hwVOIPAddressObtainMode, hwVOIPPPPOEClientName.', 'V3.52, modified the description of hwVlanNameChangeInfoTrap, hwVlanSrvProfOperType, hwVlanForwardingModeInfoTrap.', 'V3.51, added hwVmacIPoESubStatus, hwVmacPPPoESubStatus, hwVmacPPPoASubStatus, hwPPPoAMacMode, hwAntiIpv6SpoofingSwitch, hwIpv6DadProxySwitch, hwIpv6BindRouteAndNdSwitch, hwIpv6NsReplySwitch, hwIpv4ArpReplySwitch. ', 'V3.50, added hwVlanBindRaioProfileName.', 'V3.49, added hwDhcpv6Mode, hwDhcpv6OptionSwitch, and modify the description of leaves. Modified the description of hwVlanType, hwVlanMacFilter, hwifSVLANVlanListTable, hwRegionVLanTable, hwSmartVLanTable, hwMuxVlanEnable, hwMuxVlanPortConfTable, hwMuxVlanSlotConfTable, hwMultiVLanTable, hwVlanUpCarTable, hwVlanDownCarTable, hwVlanParaTable, hwLocalVlanTable, hwVlanIpAwareTable, hwMplsVlanTable. ', 'V3.48, modified the description of hwifSVLANVlanListTable, hwifPVLANMappingTable, hwRegionVLanTable, hwSmartVLanTable, hwMuxVlanPortConfTable, hwMuxVlanSlotConfTable, hwMultiVLanTable, hwVlanUpCarTable, hwVlanDownCarTable, hwVlanParaTable, hwLocalVlanTable, hwVlanIpAwareTable, hwMplsVlanTable, hwVlanType, hwVlanStatus, hwVlanAttrib. ', 'V3.47, added hwMplsVlanTable in hwVlanMngObject. Modified the description of hwVlanList,hwVlanSrvProfOperType,hwVlanNameChangeInfoTrap, hwVlanForwardingModeInfoTrap,hwVlanSrvProfChageInfoTrap and hwVlanAndVlanSrvProfOperInfoTrap. ', 'V3.46, added OBJECT-TYPE node for notification including hwVlanList and hwVlanSrvProfOperType. Added NOTIFICATION-TYPE node including hwVlanNameChangeInfoTrap,hwVlanForwardingModeInfoTrap, hwVlanSrvProfChageInfoTrap and hwVlanAndVlanSrvProfOperInfoTrap.', 'V3.45, modified the index of hwVlanTrafficOccupiedTable from hwVlanIndex to hwVlanIndex and hwInnerVlanID.', 'V3.44, deleted the Chinese characters in this file.', 'V3.43, added hwVlanIfDHCPSStatus in hwVlanInterfaceEntry', 'V3.42, added notConfig option to hwPPPoEMacMode, hwVmacStatus, hwRipTunnelSwitch, hwVtpCdpTunnelSwitch, hwBpduTunnelSwitch, hwForwardingMode, hwPolicyBroadcast, hwPolicyMulticast, hwPolicyUnknowncast, hwAntiMacSpoofingSwitch.', 'V3.41, modified the description of leaves.', 'V3.40, added hwOspfTunnelSwitch, hwL3ProtocolTunnelSwitch, and modify the description of leaves.', 'V3.39, added hwFabricMacLearningSwitch', 'V3.38, modified format of this file', 'V3.37, added hwVmacAgingMode', 'V3.36, modified the datatype definition,description of objects. Integrated the huawei-VlanFluxStatistic-mib.mib and HUAWEI-VLAN-MIB.mib into HUAWEI-VLAN-MIB.mib', 'V3.35, added hwVlanIpAwareSrcIPMode, and hwVlanIpAwareArpSendPeriod', 'V3.34, added hwVlanIfDhcpClientOption60', 'V3.33, added hwVlanIpAwareTable, hwIpAwareVirtualIPTable, and hwIpAwareRouteTable', 'V3.23, added hwDot1adTpid, and hwPortOuterEthernetTypeTable', 'V3.13, added hwVlanForwarding, hwVlanPolicyBroadcast, and hwVlanPolicyUnknowncast in hwVlanMIBTable.', 'V1.02, integrated HUAWEI-PACKET-TUNNEL-MIB.mib, HUAWEI-VLAN-IF-MIB.mib,HUAWEI-VMIF-MIB.mib and HUAWEI-VLAN-MIB.mib into HUAWEI-VLAN-MIB.mib', 'V1.00, first draft.',))
if mibBuilder.loadTexts: hwVlan.setLastUpdated('201508071000Z')
if mibBuilder.loadTexts: hwVlan.setOrganization('Huawei Technologies Co.,Ltd.')
if mibBuilder.loadTexts: hwVlan.setContactInfo("Huawei Industrial Base Bantian, Longgang Shenzhen 518129 People's Republic of China Website: http://www.huawei.com Email: support@huawei.com ")
if mibBuilder.loadTexts: hwVlan.setDescription('The mib is used for configuring the information of the VLAN, including VLAN management,VLAN interface,VLAN aggregation and so on.')
class VlanIndex(TextualConvention, Unsigned32):
    description = 'A value used to index per-VLAN tables: values of 0 and 4095 are not permitted; if the value is between 1 and 4094 inclusive, it represents an IEEE 802.1Q VLAN-ID with global scope within a given bridged domain (see VlanId textual convention). If the value is greater than 4095 then it represents a VLAN with scope local to the particular agent, i.e. one without a global VLAN-ID assigned to it. Such VLANs are outside the scope of IEEE 802.1Q but it is convenient to be able to manage them in the same way using this MIB.'
    status = 'current'

class SnmpAdminString(TextualConvention, OctetString):
    description = 'An octet string containing administrative information, preferably in human-readable form. To facilitate internationalization, this information is represented using the ISO/IEC IS 10646-1 character set, encoded as an octet string using the UTF-8 transformation format described in [RFC2279]. Since additional code points are added by amendments to the 10646 standard from time to time, implementations must be prepared to encounter any code point from 0x00000000 to 0x7fffffff. Byte sequences that do not correspond to the valid UTF-8 encoding of a code point or are outside this range are prohibited. The use of control codes should be avoided. When it is necessary to represent a newline, the control code sequence CR LF should be used. The use of leading or trailing white space should be avoided. For code points not directly supported by user interface hardware or software, an alternative means of entry and display, such as hexadecimal, may be provided. For information encoded in 7-bit US-ASCII, the UTF-8 encoding is identical to the US-ASCII encoding. UTF-8 may require multiple bytes to represent a single character / code point; thus the length of this object in octets may be different from the number of characters encoded. Similarly, size constraints refer to the number of encoded octets, not the number of characters represented by an encoding. Note that when this TC is used for an object that is used or envisioned to be used as an index, then a SIZE restriction MUST be specified so that the number of sub-identifiers for any object instance does not exceed the limit of 128, as defined by [RFC1905]. Note that the size of an SnmpAdminString object is measured in octets, not characters. '
    status = 'current'
    displayHint = '255a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class PortList(TextualConvention, OctetString):
    description = "Each octet within this value specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'."
    status = 'current'

hwVlanMngObject = ObjectIdentity((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1))
if mibBuilder.loadTexts: hwVlanMngObject.setStatus('current')
if mibBuilder.loadTexts: hwVlanMngObject.setDescription('Vlan Object ')
hwVlanMIBTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1), )
if mibBuilder.loadTexts: hwVlanMIBTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanMIBTable.setDescription('Describes the VLAN basic attributes, used for managing a VLAN, including creating, modifying, querying, and deleting a VLAN, and configuring standard ports of a VLAN. The index of this table is hwVlanIndex. ')
hwVlanMIBEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIndex"))
if mibBuilder.loadTexts: hwVlanMIBEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanMIBEntry.setDescription('Describes the VLAN basic attributes, used for managing a VLAN, including creating, modifying, querying, and deleting a VLAN, and configuring standard ports of a VLAN. The index of this entry is hwVlanIndex. ')
hwVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hwVlanIndex.setDescription('Indicates the VLAN ID. Range: 1-4093. VLAN 1 is the native VLAN. It cannot be deleted, but its attributes can be modified. ')
hwVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanName.setStatus('current')
if mibBuilder.loadTexts: hwVlanName.setDescription('Indicates the VLAN tag. Identifying the VLAN is like naming the VLAN, which facilitates management. Range: a string of 0-32 characters Default: null character string ')
hwVlanPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanPorts.setStatus('current')
if mibBuilder.loadTexts: hwVlanPorts.setDescription('Indicates the list of the standard ports in the VLAN. If the VLAN contains a port, the corresponding bit of the port is set to 1. The value of hwVlanPorts is an octet string. One bit in each octet indicates one port, so the octet string can indicate eight ports. When a bit is set to 0, it indicates that the corresponding port does not belong to this VLAN. When a bit is set to 1, it indicates that the corresponding port belongs to this VLAN. The order is as follows: The maximum number of ports in a slot is 64, so the ports need to occupy eight octets. The order, from left to right, is presented as eight groups, 0-7, 8-15, 16-23, 24-31, 32-39, 40-47, 48-55, and 56-63. In each octet, the port IDs in ascending order are presented from low bit to high bit. For example, ports 0/11/2 and 0/11/3 need to added to VLAN 2. The values of hwVlanPorts of the upstream ports (ports 0/11/2 and 0/11/3) to be added is calculated as follows: For ports 0-7 in slot 11, their corresponding character string positions are 76543210, and after ports 0/11/2 and 0/11/3 are added, the bitmap is 00001100 00000000 00000000 00000000, and the string is 0c 00 00 00 00 00 00 00. Assuming that the other slots do not have any port that is added to the VLAN, the character string of each of these slots is 0x0000000000000000. According to the ascending order of slot from left to right, the character strings of ports 0/11/2 and 0/11/3 are as follows: 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0c00000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 ')
hwVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("superVlan", 1), ("commonVlan", 2), ("subVlan", 3), ("primaryVlan", 4), ("secondaryVlan", 5), ("regionVlan", 6), ("smartVlan", 7), ("muxVlan", 8), ("multiVlan", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanType.setStatus('current')
if mibBuilder.loadTexts: hwVlanType.setDescription('Indicates the VLAN type. Options: 1. superVlan(1) -indicates super VLAN. 2. commonVlan(2) -indicates common VLAN. 3. subVlan(3) -indicates sub VLAN, the value is not supported. 4. primaryVlan(4) -indicates primary VLAN, the value is not supported. 5. secondaryVlan(5) -indicates secondary VLAN, the value is not supported. 6. regionVlan(6) -indicates region VLAN, the value is not supported. 7. smartVlan(7) -indicates smart VLAN. 8. muxVlan(8) -indicates MUX VLAN. 9. multiVlan(9) -indicates multi VLAN. VLAN 1 supports the modify operation on hwVlanType. For other VLANs, during the creation of a VLAN, hwVlanType must be specified. ')
hwVlanMacFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanMacFilter.setStatus('current')
if mibBuilder.loadTexts: hwVlanMacFilter.setDescription('The flag indicates whether to use mac filter. 1. true(1): use mac filter 2. false(2): not use mac filter ')
hwVlanMcastUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanMcastUnknownProtos.setStatus('current')
if mibBuilder.loadTexts: hwVlanMcastUnknownProtos.setDescription('multicast unknown protocals flag in the VLAN field ')
hwExistInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwExistInterface.setStatus('current')
if mibBuilder.loadTexts: hwExistInterface.setDescription('The virtual interface used by VLAN ')
hwVlanInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceIndex.setDescription('The index of the VLAN interface. ')
hwVlanMacLearn = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanMacLearn.setStatus('current')
if mibBuilder.loadTexts: hwVlanMacLearn.setDescription('The flag indicates whether to open mac learning. ')
hwVlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("permanent", 2), ("dynamicGvrp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanStatus.setDescription('Status of VLAN. Options: 1. other(1) -The following enumerated values is not supported. 2. permanent(2) -The following enumerated values is not supported. 3. dynamicGvrp(3) -The following enumerated values is not supported. ')
hwVlanCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanCreationTime.setStatus('current')
if mibBuilder.loadTexts: hwVlanCreationTime.setDescription('The time of creating VLAN. ')
hwVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(255, 255), )).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hwVlanPriority.setDescription('Indicates the 802.1p priority of a VLAN. Range: 0-7, 255 The larger the value, the higher the priority. If the query operation is performed before hwVlanPriority is configured, the query result is 255, which is invalid. The meaning of each value is as follows: best-effort: Best-effort priority(0) background: Background priority(1) spare: Spare priority(2) excellent-effort: Excellent-effort priority(3) controlled-load: Controlled-load priority(4) video: Video priority(5) voice: Voice priority(6) network-management: Network-management priority(7) ')
hwVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanRowStatus.setDescription('Indicates the row status, used for creating or deleting a VLAN. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) To create a VLAN, you must specify hwVlanType and set hwVlanRowStatus to createAndGo(4) to perform the set operation. Other attributes of the VLAN are optional. However, hwVlanPorts cannot be configured at the same time. To delete a VLAN, set hwVlanRowStatus to destroy(6) to perform the set operation. During query, the value of this leaf is the fixed active(1). ')
hwVlanAttrib = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("common", 1), ("qinq", 2), ("stacking", 3), ("subVlan", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanAttrib.setStatus('current')
if mibBuilder.loadTexts: hwVlanAttrib.setDescription('Indicates the VLAN attribute. The following enumerated values are supported: Options: 1. common(1) -indicates common VLAN. 2. qinq(2) -indicates QinQ VLAN. 3. stacking(3) -indicates stacking VLAN. 4. subVlan(4) -indicates sub VLAN. During the creation of a VLAN, if this leaf is not specified, common(1) is adopted by default. You can perform the set operation on this leaf to modify the VLAN attribute. The value of hwVlanAttrib must not be subvlan(4). The value can be subvlan(4) only in the read operation. Adding a VLAN to or deleting a VLAN from a super VLAN must be performed through hwVlanAggregationTable. ')
hwVlanSuperID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(2, 4093), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanSuperID.setStatus('current')
if mibBuilder.loadTexts: hwVlanSuperID.setDescription('Indicates the ID of the super VLAN corresponding to the sub VLAN. Range: -1, 2-4093 This leaf is read-only. When the VLAN is not a sub VLAN, -1 is returned. ')
hwVlanForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vlanMac", 1), ("vlanConnect", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanForwarding.setStatus('current')
if mibBuilder.loadTexts: hwVlanForwarding.setDescription('Indicates the VLAN forwarding policy. Options: 1. vlanMac(1) -indicates forwarding based on the VLAN+MAC. 2. vlanConnect(2) -indicates forwarding based on the SVLAN+CVLAN. During the creation of a VLAN, if this leaf is not specified, vlanMac(1) is adopted by default. You can perform the set operation on this leaf to modify the VLAN forwarding policy. The VLAN forwarding policy can also be configured in hwForwardingMode of hwVlanSrvProfTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwVlanPolicyBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanPolicyBroadcast.setStatus('current')
if mibBuilder.loadTexts: hwVlanPolicyBroadcast.setDescription('Indicates the VLAN-based forwarding policy for the broadcast packets. Options: 1. forward(1) -indicates that the broadcast packets are transparently transmitted. 2. discard(2) -indicates that the broadcast packets are discarded. During the creation of a VLAN, if this leaf is not specified, forward(1) is adopted by default. You can perform the set operation on this leaf to modify the VLAN-based forwarding policy for the broadcast packets. The VLAN-based forwarding policy for the broadcast packets can also be configured in hwPolicyBroadcast of hwVlanSrvProfTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwVlanPolicyMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanPolicyMulticast.setStatus('current')
if mibBuilder.loadTexts: hwVlanPolicyMulticast.setDescription('Indicates the VLAN-based forwarding policy for the unknown multicast packets. Options: 1. forward(1) -indicates that the unknown multicast packets are transparently transmitted. 2. discard(2) -indicates that the unknown multicast packets are discarded. During the creation of a VLAN, if this leaf is not specified, forward(1) is adopted by default. You can perform the set operation on this leaf to modify the VLAN-based forwarding policy for the unknown multicast packets. The VLAN-based forwarding policy for the unknown multicast packets can also be configured in hwPolicyMulticast of hwVlanSrvProfTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwVlanPolicyUnknowncast = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanPolicyUnknowncast.setStatus('current')
if mibBuilder.loadTexts: hwVlanPolicyUnknowncast.setDescription('Indicates the VLAN-based forwarding policy for the unknown unicast packets. Options: 1. forward(1) -indicates that the unknown unicast packets are transparently transmitted. 2. discard(2) -indicates that the unknown unicast packets are discarded. During the creation of a VLAN, if this leaf is not specified, forward(1) is adopted by default. You can perform the set operation on this leaf to modify the VLAN-based forwarding policy for the unknown unicast packets. The VLAN-based forwarding policy for the unknown unicast packets can also be configured in hwPolicyUnknowncast of hwVlanSrvProfTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwVlanOuterTpid = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535)).clone(33024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanOuterTpid.setStatus('current')
if mibBuilder.loadTexts: hwVlanOuterTpid.setDescription('Indicates the Ethernet protocol type of a VLAN. Range: 1536-65535 (0x0600-0xFFFF) Default: 0x8100 ')
hwVlanBindSrvProfName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanBindSrvProfName.setStatus('current')
if mibBuilder.loadTexts: hwVlanBindSrvProfName.setDescription('Indicates the name of the VLAN service profile bound to a VLAN. Range: a string of 0-32 characters This leaf identifies a VLAN service profile, which must be created in hwVlanSrvProfTable. The null character string indicates that the binding relation between a VLAN and a VLAN service profile is deleted. ')
hwVlanChangeEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("addPort", 1), ("removePort", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanChangeEnable.setStatus('current')
if mibBuilder.loadTexts: hwVlanChangeEnable.setDescription('Indicates the operation type of whether a standard port list maps a VLAN. Options: 1. idle(0) -indicates invalid mapping. 2. addPort(1) -indicates that a port is added to the VLAN. 3. removePort(2) -indicates that a port is deleted from the VLAN. This leaf must work with hwVlanPorts. ')
hwVlanBindRaioProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanBindRaioProfileName.setStatus('current')
if mibBuilder.loadTexts: hwVlanBindRaioProfileName.setDescription('Indicates the name of the RAIO profile bound to a VLAN. Range: a string of 0-32 characters This leaf identifies a RAIO profile, which must be created in hwDslamRAIOProfileTable. The null character string indicates that the binding relation between a VLAN and a RAIO profile is deleted. ')
hwVlanTrafficSuppressUnknowncastNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanTrafficSuppressUnknowncastNetwork.setStatus('current')
if mibBuilder.loadTexts: hwVlanTrafficSuppressUnknowncastNetwork.setDescription('Indicates the unknown unicast traffic suppression on a VLAN. Range: 0-13 Default: 0 13 indicates full-suppression of traffic, and 0 indicates no traffic suppression. The suppression levels and corresponding bandwidth ranges are listed as follows: --------------------------------------------------------------- NO. Min bandwidth(kbps) Max bandwidth(kbps) Package number(pps) --------------------------------------------------------------- 0 Not suppressed Not suppressed Not suppressed 1 6 145 12 2 12 291 24 3 24 582 48 4 48 1153 95 5 97 2319 191 6 195 4639 382 7 390 9265 763 8 781 18531 1526 9 1562 37063 3052 10 3125 74126 6104 11 6249 148241 12207 12 12499 296483 24414 13 0 0 0 --------------------------------------------------------------- ')
hwVlanMethL2Forward = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanMethL2Forward.setStatus('current')
if mibBuilder.loadTexts: hwVlanMethL2Forward.setDescription('Indicates the switch of MEth l2 forwarding on a VLAN. Options: 1. enable(1) -Enable MEth l2 forwarding on a VLAN. 2. disable(2) -Disable MEth l2 forwarding on a VLAN. The default value is disable(2). ')
hwifSVLANVlanListTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 3), )
if mibBuilder.loadTexts: hwifSVLANVlanListTable.setStatus('current')
if mibBuilder.loadTexts: hwifSVLANVlanListTable.setDescription('Indicates the super VLAN list, shows the sub VLANs in the super VLAN. The index of this table is hwifSvlanVlanID. ')
hwifSVLANVlanListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 3, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwifSvlanVlanID"))
if mibBuilder.loadTexts: hwifSVLANVlanListEntry.setStatus('current')
if mibBuilder.loadTexts: hwifSVLANVlanListEntry.setDescription('Indicates the super VLAN list, shows the sub VLANs in the super VLAN. The index of this entry is hwifSvlanVlanID. ')
hwifSvlanVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 3, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwifSvlanVlanID.setStatus('current')
if mibBuilder.loadTexts: hwifSvlanVlanID.setDescription('The index of the table, indicates the super VLAN ID ')
hwifSvlanSubVlanlistLow = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwifSvlanSubVlanlistLow.setStatus('current')
if mibBuilder.loadTexts: hwifSvlanSubVlanlistLow.setDescription('The low oct string for sub VLAN list of Primary VLANs, Each bit is one VLAN. All bits be 2048(256 * 8) VLAN. Sub VLAN will be added to super VLAN. ')
hwifSvlanSubVlanlisHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwifSvlanSubVlanlisHigh.setStatus('current')
if mibBuilder.loadTexts: hwifSvlanSubVlanlisHigh.setDescription('The high oct string for sub VLAN list of Primary VLANs, Each bit is one VLAN. All bits be 2048(256 * 8) VLAN Sub VLAN will be added to super VLAN. ')
hwifSvlanOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwifSvlanOperStatus.setStatus('current')
if mibBuilder.loadTexts: hwifSvlanOperStatus.setDescription('VLAN operational status, now support createAndGo(4),destroy(6) ')
hwifPVLANMappingTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 4), )
if mibBuilder.loadTexts: hwifPVLANMappingTable.setStatus('current')
if mibBuilder.loadTexts: hwifPVLANMappingTable.setDescription('Secondary VLAN lists of Primary VLANs. The index of this table is hwifPvlanPrimaryVlanID. ')
hwifPVLANMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 4, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwifPvlanPrimaryVlanID"))
if mibBuilder.loadTexts: hwifPVLANMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hwifPVLANMappingEntry.setDescription('Secondary VLAN lists of Primary VLANs. The index of this entry is hwifPvlanPrimaryVlanID. ')
hwifPvlanPrimaryVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 4, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwifPvlanPrimaryVlanID.setStatus('current')
if mibBuilder.loadTexts: hwifPvlanPrimaryVlanID.setDescription('Primary VLAN ID ')
hwifPvlanSecondaryVlanlistLow = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwifPvlanSecondaryVlanlistLow.setStatus('current')
if mibBuilder.loadTexts: hwifPvlanSecondaryVlanlistLow.setDescription('The second low oct string for sub VLAN list of Primary VLANs, Each bit is one VLAN. All bits be 2048(256 * 8) VLAN Secondary VLAN will be added to primary VLAN. ')
hwifPvlanSecondaryVlanlistHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwifPvlanSecondaryVlanlistHigh.setStatus('current')
if mibBuilder.loadTexts: hwifPvlanSecondaryVlanlistHigh.setDescription('The second low oct string for sub VLAN list of Primary VLANs, Each bit is one VLAN. All bits be 2048(256 * 8) VLAN Secondary VLAN will be added to primary VLAN. ')
hwifPvlanOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwifPvlanOperStatus.setStatus('current')
if mibBuilder.loadTexts: hwifPvlanOperStatus.setDescription('vlan operational status, now support createAndGo(4),destroy(6) ')
hwRegionVLanTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 5), )
if mibBuilder.loadTexts: hwRegionVLanTable.setStatus('current')
if mibBuilder.loadTexts: hwRegionVLanTable.setDescription('Indicates the region VLAN, it is used to configure the region VLAN. The index of this table is hwVlanIndex. ')
hwRegionVLanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 5, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIndex"))
if mibBuilder.loadTexts: hwRegionVLanEntry.setStatus('current')
if mibBuilder.loadTexts: hwRegionVLanEntry.setDescription('Indicates the region VLAN, it is used to configure the region VLAN. The index of this entry is hwVlanIndex. ')
hwRegionVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 5, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwRegionVpi.setStatus('current')
if mibBuilder.loadTexts: hwRegionVpi.setDescription('THE atm vpi of the VLAN. ')
hwRegionVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwRegionVci.setStatus('current')
if mibBuilder.loadTexts: hwRegionVci.setDescription('The atm vci of the VLAN. ')
hwRegionPVCRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 5, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwRegionPVCRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwRegionPVCRowStatus.setDescription('Row status,now support createAndGo(4),destroy(6). 4 is used for creating group pvc for region VLAN, 6 is used for deleting group pvc for region VLAN. ')
hwSmartVLanTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 6), )
if mibBuilder.loadTexts: hwSmartVLanTable.setStatus('current')
if mibBuilder.loadTexts: hwSmartVLanTable.setDescription('Indicates the smart VLAN, it is used to configure the smart VLAN. The index of this table is hwSmartVlanID. ')
hwSmartVLanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 6, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwSmartVlanID"))
if mibBuilder.loadTexts: hwSmartVLanEntry.setStatus('current')
if mibBuilder.loadTexts: hwSmartVLanEntry.setDescription('Indicates the smart VLAN, it is used to configure the smart VLAN. The index of this entry is hwSmartVlanID. ')
hwSmartVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 6, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwSmartVlanID.setStatus('current')
if mibBuilder.loadTexts: hwSmartVlanID.setDescription('The index of the table, indicates a smart VLAN ID. ')
hwSmartVlanUplinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 6, 1, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwSmartVlanUplinkPort.setStatus('current')
if mibBuilder.loadTexts: hwSmartVlanUplinkPort.setDescription('smart VLAN uplink ports ')
hwSmartVlanDownlinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 6, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwSmartVlanDownlinkPort.setStatus('current')
if mibBuilder.loadTexts: hwSmartVlanDownlinkPort.setDescription('smart VLAN downlink ports ')
hwSmartVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 6, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwSmartVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwSmartVlanRowStatus.setDescription('Row status, now support createAndGo(4),destroy(6) ')
hwMuxVlanEnable = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMuxVlanEnable.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanEnable.setDescription('Enable/disable MUX VLAN. Options: 1. enabled(1) -Enable MUX VLAN. 2. disabled(2) -Disable MUX VLAN. ')
hwMuxVlanPortConfTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 8), )
if mibBuilder.loadTexts: hwMuxVlanPortConfTable.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanPortConfTable.setDescription('Indicates the Mux VLAN port configuration, it is used to configure the Mux VLAN port. The index of this table is ifIndex. ')
hwMuxVlanPortConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hwMuxVlanPortConfEntry.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanPortConfEntry.setDescription('Indicates the Mux VLAN port configuration, it is used to configure the Mux VLAN port. The index of this entry is ifIndex. ')
hwMuxVlanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uplinkPort", 1), ("cascadingPort", 2))).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMuxVlanPortType.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanPortType.setDescription('Configure the uplink-port or cascading-port for the MUX VLAN. Options: 1. uplinkPort(1) -uplink port 2. cascadingPort(2) -cascading port ')
hwMuxVlanStartVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 8, 1, 2), Integer32().clone(128)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMuxVlanStartVlanId.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanStartVlanId.setDescription('The start VLAN ID of Mux VLAN. ')
hwMuxVlanGroupNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 8, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMuxVlanGroupNum.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanGroupNum.setDescription('The VLAN group number. ')
hwMuxVlanPortConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 8, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMuxVlanPortConfRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanPortConfRowStatus.setDescription('Row status, now support createAndGo(4),destroy(6). ')
hwMuxVlanUplinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 8, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMuxVlanUplinkPort.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanUplinkPort.setDescription('Uplink port for mux VLAN configuration.(for UA 5000) ')
hwMuxVlanDownlinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 8, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMuxVlanDownlinkPort.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanDownlinkPort.setDescription('Downlink port for mux VLAN configuration. If the value is -1, use inner port instead(Only used for UA5000). ')
hwMuxVlanSlotConfTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 9), )
if mibBuilder.loadTexts: hwMuxVlanSlotConfTable.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanSlotConfTable.setDescription('Indicates the I/O board MUX VLAN configure, it is used to configure the I/O board MUX VLAN. The index of this table is hwSlotIndex. ')
hwMuxVlanSlotConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 9, 1), ).setIndexNames((0, "HUAWEI-DEVICE-MIB", "hwSlotIndex"))
if mibBuilder.loadTexts: hwMuxVlanSlotConfEntry.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanSlotConfEntry.setDescription('Indicates the I/O board MUX VLAN configure, it is used to configure the I/O board MUX VLAN. The index of this entry is hwSlotIndex. ')
hwMuxVlanSlotStartVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 9, 1, 1), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMuxVlanSlotStartVlanId.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanSlotStartVlanId.setDescription('The start VLAN ID for the I/O board. ')
hwMuxVlanSlotRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 9, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMuxVlanSlotRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMuxVlanSlotRowStatus.setDescription('Row status, now support createAndGo(4),destroy(6). ')
hwMultiVLanTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 10), )
if mibBuilder.loadTexts: hwMultiVLanTable.setStatus('current')
if mibBuilder.loadTexts: hwMultiVLanTable.setDescription('Indicates the Multi VLAN, it is used to configure the multi VLAN. The index of this table is hwMultiVlanID. ')
hwMultiVLanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 10, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwMultiVlanID"))
if mibBuilder.loadTexts: hwMultiVLanEntry.setStatus('current')
if mibBuilder.loadTexts: hwMultiVLanEntry.setDescription('Indicates the Multi VLAN, it is used to configure the multi VLAN. The index of this entry is hwMultiVlanID. ')
hwMultiVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 10, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwMultiVlanID.setStatus('current')
if mibBuilder.loadTexts: hwMultiVlanID.setDescription('The index of the table, indicates a Multi VLAN ID. ')
hwMultiVlanUplinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 10, 1, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMultiVlanUplinkPort.setStatus('current')
if mibBuilder.loadTexts: hwMultiVlanUplinkPort.setDescription('Multi VLAN uplink ports. ')
hwMultiVlanDownlinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 10, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMultiVlanDownlinkPort.setStatus('current')
if mibBuilder.loadTexts: hwMultiVlanDownlinkPort.setDescription('Multi VLAN downlink ports. ')
hwMultiVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 10, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwMultiVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwMultiVlanRowStatus.setDescription('Row status, now support createAndGo(4),destroy(6). ')
hwVlanAggregationTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 11), )
if mibBuilder.loadTexts: hwVlanAggregationTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanAggregationTable.setDescription('Describes the relation between the super VLAN and the sub VLAN in a VLAN aggregation. The indexes of this table are hwVlanAggregationSuperVlanId and hwVlanAggregationSubVlanId. ')
hwVlanAggregationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 11, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanAggregationSuperVlanId"), (0, "HUAWEI-VLAN-MIB", "hwVlanAggregationSubVlanId"))
if mibBuilder.loadTexts: hwVlanAggregationEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanAggregationEntry.setDescription('Describes the relation between the super VLAN and the sub VLAN in a VLAN aggregation. The indexes of this entry are hwVlanAggregationSuperVlanId and hwVlanAggregationSubVlanId. ')
hwVlanAggregationSuperVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4093))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanAggregationSuperVlanId.setStatus('current')
if mibBuilder.loadTexts: hwVlanAggregationSuperVlanId.setDescription('Indicates the super VLAN ID in a VLAN aggregation. Range: 2-4093 ')
hwVlanAggregationSubVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4093))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanAggregationSubVlanId.setStatus('current')
if mibBuilder.loadTexts: hwVlanAggregationSubVlanId.setDescription('Indicates the sub VLAN ID in a VLAN aggregation. Range: 2-4093 ')
hwVlanAggregationSubVlanArpProxyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanAggregationSubVlanArpProxyStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanAggregationSubVlanArpProxyStatus.setDescription('Indicates the status of ARP proxy in a sub VLAN. Options: 1. enabled(1) -Enable ARP proxy in a sub VLAN. 2. disabled(2) -Disable ARP proxy in a sub VLAN. Default: disabled(2) ')
hwVlanAggregationRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 11, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVlanAggregationRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanAggregationRowStatus.setDescription('Indicates the row status, used for creating or deleting a VLAN aggregation. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) To create a VLAN aggregation, specify the indexes, and set hwVlanAggregationRowStatus to createAndGo(4) to perform the set operation. To delete a VLAN aggregation, specify the indexes, and set hwVlanAggregationRowStatus to destroy(6) to perform the set operation. During query, the value of this leaf is the fixed active(1). ')
hwVlanAggregationSubVlanNdProxyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanAggregationSubVlanNdProxyStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanAggregationSubVlanNdProxyStatus.setDescription('Indicates the status of ND proxy in a sub VLAN. Options: 1. enabled(1) -Enable ND proxy in a sub VLAN. 2. disabled(2) -Disable ND proxy in a sub VLAN. Default: disabled(2) ')
hwStackingVlanInnerEthernetType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwStackingVlanInnerEthernetType.setStatus('current')
if mibBuilder.loadTexts: hwStackingVlanInnerEthernetType.setDescription('Indicates the Ethernet protocol type of the inner VLAN tag supported by VLAN stacking. Range: 0-65535 Default: 0x8100 ')
hwVlanUpCarTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 15), )
if mibBuilder.loadTexts: hwVlanUpCarTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpCarTable.setDescription('Indicates the VLAN up direct CAR. The index of this table is hwVlanUpCarId. ')
hwVlanUpCarEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 15, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanUpCarId"))
if mibBuilder.loadTexts: hwVlanUpCarEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpCarEntry.setDescription('Indicates the VLAN up direct CAR. The index of this entry is hwVlanUpCarId. ')
hwVlanUpCarId = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanUpCarId.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpCarId.setDescription('The index of the table, indicates a up direct Carid. ')
hwVlanUpCarName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 15, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanUpCarName.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpCarName.setDescription('Up direct car name. ')
hwVlanUpCarBandValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1048512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanUpCarBandValue.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpCarBandValue.setDescription('Car band value,The car value is multiple of 64kbps. Unit :kbps ')
hwVlanUpCarBurstValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 15, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanUpCarBurstValue.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpCarBurstValue.setDescription('Car burst value. Unit:kbps ')
hwVlanUpCarIsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("used", 1), ("noUsed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanUpCarIsUsed.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpCarIsUsed.setDescription('The flag indicates whether the carid is used. Options: 1. used(1) -The carid is used. 2. noUsed(2) -The carid is no-used. ')
hwVlanUpCarRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 15, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVlanUpCarRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpCarRowStatus.setDescription('Row status, now support createAndGo(4),destroy(6). ')
hwVlanDownCarTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 16), )
if mibBuilder.loadTexts: hwVlanDownCarTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownCarTable.setDescription('Indicates the VLAN down direct CAR. The index of this table is hwVlanDownCarId. ')
hwVlanDownCarEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 16, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanDownCarId"))
if mibBuilder.loadTexts: hwVlanDownCarEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownCarEntry.setDescription('Indicates the VLAN down direct CAR. The index of this entry is hwVlanDownCarId. ')
hwVlanDownCarId = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanDownCarId.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownCarId.setDescription('The index of the table, indicates a down direct carid. ')
hwVlanDownCarName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 16, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanDownCarName.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownCarName.setDescription('Down direct car name. ')
hwVlanDownCarBandValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1048512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanDownCarBandValue.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownCarBandValue.setDescription('Car band value,The car value is multiple of 64kbps. Unit: kbps ')
hwVlanDownCarBurstValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 16, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanDownCarBurstValue.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownCarBurstValue.setDescription('Car burst value. Unit: kbps ')
hwVlanDownCarIsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("used", 1), ("noUsed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanDownCarIsUsed.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownCarIsUsed.setDescription('The flag indicates whether the carid is used. Options: 1. used(1) -The carid is used. 2. noUsed(2) -The carid is no-used. ')
hwVlanDownCarRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 16, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVlanDownCarRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownCarRowStatus.setDescription('Row status, now support createAndGo(4),destroy(6). ')
hwVlanParaTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 17), )
if mibBuilder.loadTexts: hwVlanParaTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanParaTable.setDescription('Indicates the VLAN parameters, include hwVlanParaIndex, hwVlanMacLearnCpability, hwVlanMaxMacLearnNum, hwVlanUpdirectCar, hwVlanDownDirectCar, it is used to configure the VLAN param. The index of this table is hwVlanParamIndex. ')
hwVlanParaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 17, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanParaIndex"))
if mibBuilder.loadTexts: hwVlanParaEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanParaEntry.setDescription('Indicates the VLAN parameters, include hwVlanParaIndex, hwVlanMacLearnCpability, hwVlanMaxMacLearnNum, hwVlanUpdirectCar, hwVlanDownDirectCar, it is used to configure the VLAN param. The index of this entry is hwVlanParamIndex. ')
hwVlanParaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 17, 1, 1), VlanIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanParaIndex.setStatus('current')
if mibBuilder.loadTexts: hwVlanParaIndex.setDescription('The index of the table,the VLAN index means Vlan Id. ')
hwVlanMacLearnCpability = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanMacLearnCpability.setStatus('current')
if mibBuilder.loadTexts: hwVlanMacLearnCpability.setDescription('MAC learning or not flag by VLAN. Options: 1. enabled(1) -Enable MAC learning by VLAN. 2. disabled(2) -Disable MAC learning by VLAN. ')
hwVlanMaxMacLearnNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanMaxMacLearnNum.setStatus('current')
if mibBuilder.loadTexts: hwVlanMaxMacLearnNum.setDescription('The VLAN max mac learn number. ')
hwVlanUpDirectCarID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 17, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanUpDirectCarID.setStatus('current')
if mibBuilder.loadTexts: hwVlanUpDirectCarID.setDescription('The VLAN up direct carID. ')
hwVlanDownDirectCarID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 17, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanDownDirectCarID.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownDirectCarID.setDescription('The VLAN down direct carID. ')
hwMethL2Vlan = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMethL2Vlan.setStatus('current')
if mibBuilder.loadTexts: hwMethL2Vlan.setDescription('set the Meth L2 function of the VLAN. ')
hwDocsDefaultSrvVlanID = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4093))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDocsDefaultSrvVlanID.setStatus('current')
if mibBuilder.loadTexts: hwDocsDefaultSrvVlanID.setDescription('Indicates the service svlan of DOCSIS service. The default value is 1. ')
hwStackingVlanOuterEthernetType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65000), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwStackingVlanOuterEthernetType.setStatus('current')
if mibBuilder.loadTexts: hwStackingVlanOuterEthernetType.setDescription('Describes the Ethernet protocol type of the outer VLAN tag supported by VLAN stacking. Range: 0x600-0xffff Default: 0x8100 ')
hwDot1adTpid = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65001), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1536, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDot1adTpid.setStatus('current')
if mibBuilder.loadTexts: hwDot1adTpid.setDescription('Describes the value of the 802.1ad Ethernet protocol type. The Ethernet protocol type of the outer VLAN tag of a port can be configured to dot1q or dot1ad. The value of dot1q is invariably 0x8100; the value of dot1ad is configurable, but cannot be the values of other standard protocols, such as 0x0806. The default value of dot1ad is 0x88a8. Range: 0x600-0xffff ')
hwPortOuterEthernetTypeTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65002), )
if mibBuilder.loadTexts: hwPortOuterEthernetTypeTable.setStatus('current')
if mibBuilder.loadTexts: hwPortOuterEthernetTypeTable.setDescription('Describes the Ethernet protocol type of the outer VLAN tag of a port. The index of this table is ifIndex (for details about how to calculate the value of ifIndex, see the MA5600T ifIndex MIB Encoding Rules). ')
hwPortOuterEthernetTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65002, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hwPortOuterEthernetTypeEntry.setStatus('current')
if mibBuilder.loadTexts: hwPortOuterEthernetTypeEntry.setDescription('Describes the Ethernet protocol type of the outer VLAN tag of a port. The index of this entry is ifIndex (for details about how to calculate the value of ifIndex, see the MA5600T ifIndex MIB Encoding Rules). ')
hwPortOuterEthernetType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65002, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 1, 2))).clone(namedValues=NamedValues(("invalid", -1), ("dot1qTpid", 1), ("dot1adTpid", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPortOuterEthernetType.setStatus('current')
if mibBuilder.loadTexts: hwPortOuterEthernetType.setDescription('Indicates the Ethernet protocol type of the outer VLAN tag of a port. Options: 1. invalid(-1) -it indicates that the port does not support the Ethernet protocol type of the outer VLAN. During the query, the invalid value -1 is fixedly returned. 2. dot1qTpid(1) -it is valid for all service streams on the port. 3. dot1adTpid(2) -it is valid for only switching-oriented and connection-oriented service streams with two VLAN tags on the port. Default: dot1qTpid(1) ')
hwVlanLocalSwitch = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65003), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanLocalSwitch.setStatus('current')
if mibBuilder.loadTexts: hwVlanLocalSwitch.setDescription('Set the global Local VLAN switch. Options: 1. enable(1) -the switch is enable. 2. disable(2) -the switch is disabled. Default: disable(2) ')
hwLocalVlanTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65004), )
if mibBuilder.loadTexts: hwLocalVlanTable.setStatus('current')
if mibBuilder.loadTexts: hwLocalVlanTable.setDescription('Indicates the Local VLAN, it is used to configure the Local VLAN. The index of this table is hwVlanIndex. ')
hwLocalVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65004, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIndex"))
if mibBuilder.loadTexts: hwLocalVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hwLocalVlanEntry.setDescription('Indicates the Local VLAN, it is used to configure the Local VLAN. The index of this entry is hwVlanIndex. ')
hwLocalVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65004, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwLocalVlan.setStatus('current')
if mibBuilder.loadTexts: hwLocalVlan.setDescription('The flag indicates whether to set the Local VLAN. Options: 1. enable(1) -Enable local VLAN. 2. disable(2) -Disable local VLAN. ')
hwVlanInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2), )
if mibBuilder.loadTexts: hwVlanInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceTable.setDescription('Describes VLAN interface management, including IP address management, enabling and disabling of the DHCP client, and DHCP client option 60. The index of this table is hwVlanInterfaceID. ')
hwVlanInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanInterfaceID"))
if mibBuilder.loadTexts: hwVlanInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceEntry.setDescription('Describes VLAN interface management, including IP address management, enabling and disabling of the DHCP client, and DHCP client option 60. The index of this entry is hwVlanInterfaceID. ')
hwVlanInterfaceID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanInterfaceID.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceID.setDescription('Indicates the index of a VLAN interface, which maps a VLAN ID. For example, the index of VLAN interface 3 is 3. ')
hwVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanID.setStatus('current')
if mibBuilder.loadTexts: hwVlanID.setDescription('Indicates the corresponding VLAN ID of a VLAN interface. ')
hwVlanIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIpAddress.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAddress.setDescription('Indicates the IP address of a VLAN interface. Default: 0.0.0.0. ')
hwVlanIpAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIpAddressMask.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAddressMask.setDescription('Indicates the IP address subnet mask. ')
hwVlanInterfaceAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanInterfaceAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceAdminStatus.setDescription('Indicates the management status of a VLAN interface. Options: 1. up(1) -indicates up status. 2. down(2) -indicates down status. Default: up(1) ')
hwVlanInterfaceFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetii", 1), ("ethernetsnap", 2), ("ethernet8022", 3), ("ethernet8023", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanInterfaceFrameType.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceFrameType.setDescription('Indicates the type of the frame that can be received by a VLAN interface. Options: 1. ethernetii(1) -For the frame format of ethernetii(1), see RFC894. 2. ethernetsnap(2) -The value is not supported. 3. ethernet8022(3) -The value is not supported. 4. ethernet8023(4) -The value is not supported. Currently, only ethernetii(1) is supported. ')
hwInterfaceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwInterfaceRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwInterfaceRowStatus.setDescription('Indicates the row status. It is used for create, delete and modify operations. Options: 1. createAndGo(4) 2. destroy(6) 3. active(1) ')
hwVlanInterfaceLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanInterfaceLinkStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceLinkStatus.setDescription('Indicates the protocol status of a link that is contained in a VLAN interface. Options: 1. up(1) -The protocol status of a link that is contained in a VLAN interface is up. 2. down(2) -The protocol status of a link that is contained in a VLAN interface is down. ')
hwVlanIfIPMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIfIPMode.setStatus('current')
if mibBuilder.loadTexts: hwVlanIfIPMode.setDescription('Indicates the mode of obtaining an IP address. Options: 1. static(1) -Configured statically. 2. dhcp(2) -Obtained through DHCP. ')
hwVlanIfDhcpClientOption60 = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIfDhcpClientOption60.setStatus('current')
if mibBuilder.loadTexts: hwVlanIfDhcpClientOption60.setDescription('Indicates the option 60 information carried in DHCP packets that are sent by a L3 interface when obtaining an IP address in the DHCP mode. Range: 0-32 characters ')
hwVlanIfVlanEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("singleTag", 1), ("doubleTag", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIfVlanEncapMode.setStatus('current')
if mibBuilder.loadTexts: hwVlanIfVlanEncapMode.setDescription('Used to configure the VLAN encapsulation mode of a VLAN interface. Options: 1. singleTag(1) -Single tag VLAN encapsulation mode. 2. doubleTag(2) -Double tag VLAN encapsulation mode. Default: singleTag(1) ')
hwVlanIfVlanInnerLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIfVlanInnerLabel.setStatus('current')
if mibBuilder.loadTexts: hwVlanIfVlanInnerLabel.setDescription('Used to configure the inner VLAN ID when the VLAN encapsulation mode of a VLAN interface is double-tag mode. Range: 1-4095 Default: 1 ')
hwVlanIfDHCPSStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIfDHCPSStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanIfDHCPSStatus.setDescription('Describes the mode of dhcp server on this interface. Options: 1. disable(1) -disable dhcp server. 2. enable(2) -enable dhcp server. Default: disable(1) ')
hwIPv6MTU = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1280, 1499), ValueRangeConstraint(1501, 1560), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIPv6MTU.setStatus('current')
if mibBuilder.loadTexts: hwIPv6MTU.setDescription('Used to configure the maximum transmission unit of vlanif.If you set it on one vlanif,all the vlanif will be configured. For P300 device, the node can take effect on IPV4 and IPV6. For Saturn device, it only takes effect on IPV6. Range: -1,1280-1499,1501-1560. For P300 device, the range is -1,1501-1560. For Saturn device, the range is -1,1280-1499,1501-1560. Deafult:-1,this value means the MTU of vlanif is the default value(for example: 1500). ')
hwIPv4MTU = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1501, 1560), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIPv4MTU.setStatus('current')
if mibBuilder.loadTexts: hwIPv4MTU.setDescription('Used to configure the maximum transmission unit of vlanif. The node is only supported on Saturn device. It only takes effect on IPV4. Range: -1,1501-1560 Deafult:-1,this value means the MTU of vlanif is the default value(for example: 1500). ')
hwVlanInterfaceSubIpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 22), )
if mibBuilder.loadTexts: hwVlanInterfaceSubIpAddrTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceSubIpAddrTable.setDescription('Describes management of the secondary IP addresses of a VLAN interface. The indexes of this table are hwVlanInterfaceIDWithSub, hwVlanSubIpAddress and hwVlanSubIpAddressMask. ')
hwVlanInterfaceSubIpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 22, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanInterfaceIDWithSub"), (0, "HUAWEI-VLAN-MIB", "hwVlanSubIpAddress"), (0, "HUAWEI-VLAN-MIB", "hwVlanSubIpAddressMask"))
if mibBuilder.loadTexts: hwVlanInterfaceSubIpAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceSubIpAddrEntry.setDescription('Describes management of the secondary IP addresses of a VLAN interface. The indexes of this entry are hwVlanInterfaceIDWithSub, hwVlanSubIpAddress and hwVlanSubIpAddressMask. ')
hwVlanInterfaceIDWithSub = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 22, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanInterfaceIDWithSub.setStatus('current')
if mibBuilder.loadTexts: hwVlanInterfaceIDWithSub.setDescription('Indicates the index of a VLAN interface, which maps a VLAN ID. For example, the index of VLAN interface 3 is 3. ')
hwVlanSubIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 22, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanSubIpAddress.setStatus('current')
if mibBuilder.loadTexts: hwVlanSubIpAddress.setDescription('Indicates the secondary IP address of a VLAN interface. ')
hwVlanSubIpAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 22, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanSubIpAddressMask.setStatus('current')
if mibBuilder.loadTexts: hwVlanSubIpAddressMask.setDescription('Indicates the subnet mask of the secondary IP address of a VLAN interface. ')
hwInterfaceSubIpAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 22, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwInterfaceSubIpAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwInterfaceSubIpAddrRowStatus.setDescription('Indicates the row status. It is used for create, modify and delete operations. Options: 1. createAndGo(4) 2. destroy(6) 3. active(1) ')
hwPacketTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 21), )
if mibBuilder.loadTexts: hwPacketTunnelTable.setStatus('current')
if mibBuilder.loadTexts: hwPacketTunnelTable.setDescription('Used for setting and querying the status of the L2 transparent transmission of RIP packets and VTP/CDP packets in a VLAN. The index of this table is hwVlanIndex. ')
hwPacketTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 21, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIndex"))
if mibBuilder.loadTexts: hwPacketTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: hwPacketTunnelEntry.setDescription('Used for setting and querying the status of the L2 transparent transmission of RIP packets and VTP/CDP packets in a VLAN. The index of this entry is hwVlanIndex. ')
hwPacketTunnelRip = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 21, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPacketTunnelRip.setStatus('current')
if mibBuilder.loadTexts: hwPacketTunnelRip.setDescription('Indicates the transparent transmission of RIP packets in a VLAN. Options: 1. enable(1) -Enable transparent transmission of RIP packets in a VLAN. 2. disable(2) -Disable transparent transmission of RIP packets in a VLAN. Default: disable(2) ')
hwPacketTunnelVTPCDP = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwPacketTunnelVTPCDP.setStatus('current')
if mibBuilder.loadTexts: hwPacketTunnelVTPCDP.setDescription('Indicates the transparent transmission of VTP/CDP packets in a VLAN. Options: 1. enable(1) -Enable transparent transmission of VTP/CDP packets in a VLAN. 2. disable(2) -Disable transparent transmission of VTP/CDP packets in a VLAN. Default: disable(2) ')
hwBpduTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 18), )
if mibBuilder.loadTexts: hwBpduTunnelTable.setStatus('current')
if mibBuilder.loadTexts: hwBpduTunnelTable.setDescription('Used for setting and querying the status of the L2 transparent transmission of BPDU packets. The index of this table is hwVlanIndex. ')
hwBpduTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 18, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIndex"))
if mibBuilder.loadTexts: hwBpduTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: hwBpduTunnelEntry.setDescription('Used for setting and querying the status of the L2 transparent transmission of BPDU packets. The index of this entry is hwVlanIndex. ')
hwBpduTunnel = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwBpduTunnel.setStatus('current')
if mibBuilder.loadTexts: hwBpduTunnel.setDescription('Indicates the status of the L2 transparent transmission of BDPU packets in a VLAN. Options: 1. enable(1) -Enable transparent transmission of BDPU packets in a VLAN. 2. disable(2) -Disable transparent transmission of BDPU packets in a VLAN. Default: disable(2) ')
hwVOIPAddressTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19), )
if mibBuilder.loadTexts: hwVOIPAddressTable.setStatus('current')
if mibBuilder.loadTexts: hwVOIPAddressTable.setDescription('VOIP multiply IP table. The index of this table is hwVOIPAddressIndex ')
hwVOIPAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVOIPAddressIndex"))
if mibBuilder.loadTexts: hwVOIPAddressEntry.setStatus('current')
if mibBuilder.loadTexts: hwVOIPAddressEntry.setDescription('VOIP multiply IP table. The index of this entry is hwVOIPAddressIndex ')
hwVOIPAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: hwVOIPAddressIndex.setStatus('current')
if mibBuilder.loadTexts: hwVOIPAddressIndex.setDescription('the index scope is 0-63 ')
hwVOIPIPType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("media", 1), ("signaling", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVOIPIPType.setStatus('current')
if mibBuilder.loadTexts: hwVOIPIPType.setDescription('Indicates the type of VOIP IP. Options: 1. media(1) -indicates that the type of VOIP IP is media. 2. signaling(2) -indicates that the type of VOIP IP is signaling. ')
hwVOIPIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVOIPIPAddress.setStatus('current')
if mibBuilder.loadTexts: hwVOIPIPAddress.setDescription('IP address')
hwVOIPSubMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVOIPSubMask.setStatus('current')
if mibBuilder.loadTexts: hwVOIPSubMask.setDescription('subMask of VAG ')
hwVOIPGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVOIPGateway.setStatus('current')
if mibBuilder.loadTexts: hwVOIPGateway.setDescription('gateway of VAG')
hwVOIPMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVOIPMACAddress.setStatus('current')
if mibBuilder.loadTexts: hwVOIPMACAddress.setDescription('MAC address')
hwVOIPVlanTagIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVOIPVlanTagIdentifier.setStatus('current')
if mibBuilder.loadTexts: hwVOIPVlanTagIdentifier.setDescription('vlanid of VAG')
hwVOIPQosIPStrategy = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tos", 1), ("dscp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVOIPQosIPStrategy.setStatus('current')
if mibBuilder.loadTexts: hwVOIPQosIPStrategy.setDescription('Indicates the qos ip strategy Options: 1. tos(1) -indicates that the qos ip strategy is tos. 2. dscp(2) -indicates that the qos ip strategy is dscp.')
hwVOIPAddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVOIPAddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwVOIPAddressRowStatus.setDescription("Indicates the status of this conceptual row. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the hwAddressRowStatus column is 'notReady'. ")
hwVOIPAddressObtainMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("pppoe", 2), ("dhcp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVOIPAddressObtainMode.setStatus('current')
if mibBuilder.loadTexts: hwVOIPAddressObtainMode.setDescription('ip address obtain mode: Options: 1. static(1) -static config 2. pppoe(2) -pppoe dynamic obtain 3. dhcp(3) -dhcp dynamic obtain ')
hwVOIPPPPOEClientName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVOIPPPPOEClientName.setStatus('current')
if mibBuilder.loadTexts: hwVOIPPPPOEClientName.setDescription('ip address name of pppoe dynamic obtain, the same as pppoe client name')
hwVOIPIPAddressSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 19, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("static", 0), ("dhcp", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVOIPIPAddressSrc.setStatus('current')
if mibBuilder.loadTexts: hwVOIPIPAddressSrc.setDescription('Indicates the source type of IP. Options: 1. static(0) -indicates that the source type of IP is static. 2. dhcp(1) -indicates that the source type of IP is dhcp. ')
hwVOIPQosTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 20), )
if mibBuilder.loadTexts: hwVOIPQosTable.setStatus('current')
if mibBuilder.loadTexts: hwVOIPQosTable.setDescription('Describes the Qos IP tos and VLAN priority The index of this table is hwVOIPAddressIndex ')
hwVOIPQosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 20, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVOIPAddressIndex"))
if mibBuilder.loadTexts: hwVOIPQosEntry.setStatus('current')
if mibBuilder.loadTexts: hwVOIPQosEntry.setDescription('Describes the Qos IP tos and VLAN priority The index of this entry is hwVOIPAddressIndex ')
hwVOIPQosIPTosValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVOIPQosIPTosValue.setStatus('current')
if mibBuilder.loadTexts: hwVOIPQosIPTosValue.setDescription('Qos value of tos')
hwVOIPQosIPDscpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 20, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVOIPQosIPDscpValue.setStatus('current')
if mibBuilder.loadTexts: hwVOIPQosIPDscpValue.setDescription('Qos value of dscp')
hwVOIPQosVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 20, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVOIPQosVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hwVOIPQosVlanPriority.setDescription('Qos VLAN priority')
hwVOIPQosIPAddressSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 20, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("static", 0), ("dhcp", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVOIPQosIPAddressSrc.setStatus('current')
if mibBuilder.loadTexts: hwVOIPQosIPAddressSrc.setDescription('Indicates the source type of IP. Options: 1. static(0) -indicates that the source type of IP is static. 2. dhcp(1) -indicates that the source type of IP is dhcp. ')
hwVlanSrvProfTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25), )
if mibBuilder.loadTexts: hwVlanSrvProfTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanSrvProfTable.setDescription('Describes the attributes of a VLAN service profile, used for adding or deleting a VLAN service profile, or modifying the status of the attributes in an existing VLAN service profile. The index of this table is hwVlanSrvProfName. ')
hwVlanSrvProfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanSrvProfName"))
if mibBuilder.loadTexts: hwVlanSrvProfEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanSrvProfEntry.setDescription('Describes the attributes of a VLAN service profile, used for adding or deleting a VLAN service profile, or modifying the status of the attributes in an existing VLAN service profile. The index of this entry is hwVlanSrvProfName. ')
hwVlanSrvProfName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanSrvProfName.setStatus('current')
if mibBuilder.loadTexts: hwVlanSrvProfName.setDescription('Indicates the name of the VLAN service profile. Range: a string of 1-32 characters The input index consists of the VLAN service profile name and the length of the VLAN service profile name. The input VLAN service profile name must be ASCII codes. Assume that you need to create a huawei VLAN service profile. Because the ASCII value of huawei is 104.117.97.119.101.105 and the length of huawei is 6, the index is 6.104.117.97.119.101.105. ')
hwForwardingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("vlanMac", 1), ("vlanConnect", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwForwardingMode.setStatus('current')
if mibBuilder.loadTexts: hwForwardingMode.setDescription('Indicates the VLAN forwarding policy. Options: 1. vlanMac(1) -indicates forwarding based on the VLAN+MAC. 2. vlanConnect(2) -indicates forwarding based on the SVLAN+CVLAN. 3. notConfig(3) -indicates forwarding based on VLAN single switch. This leaf is optional for creating a VLAN service profile. The VLAN forwarding policy can also be configured in hwVlanForwarding of hwVlanMIBTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwAntiIpSpoofingSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwAntiIpSpoofingSwitch.setStatus('current')
if mibBuilder.loadTexts: hwAntiIpSpoofingSwitch.setDescription('Indicates the VLAN-based anti-IP-spoofing function. Options: 1. enable(1) -indicates that the anti-IP-spoofing function is enabled. 2. disable(2) -indicates that the anti-IP-spoofing function is disabled. This leaf is optional for creating a VLAN service profile. The anti-IP spoofing function in the global mode can be set in hwIpDslamIpAddrDynamicBindingStatus of HUAWEI-IPDSLAM-SECURITY-MIB. The final status of the anti-IP-spoofing function is determined by its global-level switch and VLAN-level switch. The anti-IP-spoofing function of a VLAN is enabled only when the switches at both levels are enabled. ')
hwAntiMacSpoofingSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwAntiMacSpoofingSwitch.setStatus('current')
if mibBuilder.loadTexts: hwAntiMacSpoofingSwitch.setDescription('Indicates the VLAN-based anti-MAC-spoofing function. Options: 1. enable(1) -indicates that the anti-MAC-spoofing function is enabled. 2. disable(2)-indicates that the anti-MAC spoofing function is disabled. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The anti-MAC spoofing function in the global mode can be set in hwIpDslamAntiMacSpoofingStatus of HUAWEI-IPDSLAM-SECURITY-MIB. The VLAN-based anti-MAC-spoofing function can also be configured in hwIpDslamL2pVlanCtrlMacSpoofing of hwIpDslamL2pVlanCtrlTable in HUAWEI-IPDSLAM-L2PPORTCONFIG-MIB. The final status of the anti-MAC-spoofing function is determined by its global-level switch and VLAN-level switch. The anti-MAC spoofing function of a VLAN is enabled only when the switches at both levels are enabled. If a VLAN service profile is bound to the VLAN, the configuration of the VLAN-based anti-MAC-spoofing function in the VLAN service profile takes effect. ')
hwPPPoEMacMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("multiMac", 1), ("singleMac", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPPPoEMacMode.setStatus('current')
if mibBuilder.loadTexts: hwPPPoEMacMode.setDescription('Indicates the VLAN-based PPPoE single-MAC function. Options: 1. multiMac(1) -indicates that the multi-MAC mode is adopted. 2. singleMac(2) -indicates that the single-MAC mode is adopted. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The PPPoE single-MAC function in the global mode can be set in hwIpDslamPPPoEMacMode of HUAWEI-IPDSLAM-PPPOE-MIB. The VLAN-based PPPoE single-MAC function can also be configured in hwIpDslamL2pVlanCtrlPppoeMacMode of hwIpDslamL2pVlanCtrlTable in HUAWEI-IPDSLAM-L2PPORTCONFIG-MIB. The final status of the PPPoE single-MAC function is determined by its global-level switch and VLAN-level switch. The PPPoE single-MAC function of a VLAN is enabled only when the switches at both levels are enabled. If a VLAN service profile is bound to the VLAN, the configuration of the VLAN-based PPPoE single-MAC function in the VLAN service profile takes effect. ')
hwBpduTunnelSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwBpduTunnelSwitch.setStatus('current')
if mibBuilder.loadTexts: hwBpduTunnelSwitch.setDescription('Indicates the VLAN-based BPDU transparent transmission function. Options: 1. enable(1) -indicates that the BPDU transparent transmission function is enabled. 2. disable(2) -indicates that the BPDU transparent transmission function is disabled. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The BPDU transparent transmission function can also be configured in hwBpduTunnel of hwBpduTunnelTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwRipTunnelSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwRipTunnelSwitch.setStatus('current')
if mibBuilder.loadTexts: hwRipTunnelSwitch.setDescription('Indicates the VLAN-based RIP transparent transmission function. Options: 1. enable(1) -indicates that the RIP transparent transmission function is enabled. 2. disable(2) -indicates that the RIP transparent transmission function is disabled. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The RIP transparent transmission function can also be configured in hwPacketTunnelRip of hwPacketTunnelTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwVtpCdpTunnelSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVtpCdpTunnelSwitch.setStatus('current')
if mibBuilder.loadTexts: hwVtpCdpTunnelSwitch.setDescription('Indicates the VLAN-based VTP/CDP transparent transmission function. Options: 1. enable(1) -indicates that the VTP/CDP transparent transmission function is enabled. 2. disable(2) -indicates that the VTP/CDP transparent transmission function is disabled. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The VTP/CDP transparent transmission function can also be configured in hwPacketTunnelVTPCDP of hwPacketTunnelTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwDhcpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notConfig", 1), ("layer2", 2), ("l3Standard", 3), ("l3Option60", 4), ("l3MacRange", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDhcpMode.setStatus('current')
if mibBuilder.loadTexts: hwDhcpMode.setDescription('Indicates the VLAN-based DHCP L2/L3 mode switch. Options: 1. notConfig(1) -indicates that if the VLAN configuration exists, the VLAN configuration takes effect. Otherwise, the configuration in global mode takes effect. 2. layer2(2) -indicates the DHCP L2 forwarding mode. In this mode, the device only transparently transmits packets and does not process the packets. 3. l3Standard(3) -indicates the standard mode of the DHCP L3 forwarding mode. In this mode, packets select the DHCP server through the VLAN L3 interface that is used for forwarding the DHCP packets. 4. l3Option60(4) -indicates the DHCP option 60 mode of the DHCP L3 forwarding mode. In this mode, packets select the DHCP server according to the option 60 field. Option 60 is an option with code 60 in the DHCP packet. It can identify the terminal type. That is, packets can select the DHCP server according to terminal types. 5. l3MacRange(5) -indicates the MAC address segment mode of the DHCP L3 forwarding mode. In this mode, packets select the DHCP server according to the MAC address segment to which the source MAC address of the DHCP packets belong. This leaf is optional for creating a VLAN service profile. The DHCP L2/L3 mode in the global mode can also be set in hwDhcpRelayMode and hwDhcpServerSelectMode of HUAWEI-DHCP-Proxy-MIB. The DHCP L2/L3 mode at the VLAN level can also be set in hwDhcpServerSelectModeByVlanTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. The global DHCP L2/L3 mode, however, is not changed. If no VLAN service profile is bound to the VLAN, but hwDhcpServerSelectModeByVlanTable is configured, the configuration of hwDhcpServerSelectModeByVlanTable takes effect; if hwDhcpServerSelectModeByVlanTable is not configured, the configuration in the global mode takes effect. ')
hwDhcpProxySwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDhcpProxySwitch.setStatus('current')
if mibBuilder.loadTexts: hwDhcpProxySwitch.setDescription('Indicates the VLAN-based DHCP proxy function. Options: 1. enable(1) -indicates that the DHCP proxy is enabled. 2. disable(2) -indicates that the DHCP proxy is disabled. This leaf is optional for creating a VLAN service profile. The global DHCP proxy function can be configured in hwDhcpProxyStatus of HUAWEI-DHCP-Proxy-MIB. The final status of the DHCP proxy function is determined by its global-level switch and VLAN-level switch. The DHCP proxy function of a VLAN is enabled only when the switches at both levels are enabled. When the DHCP mode of the VLAN is configured to L2 mode, the configuration data can be saved, but the configuration of the DHCP proxy function does not take effect. ')
hwDhcpOption82Switch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDhcpOption82Switch.setStatus('current')
if mibBuilder.loadTexts: hwDhcpOption82Switch.setDescription('Indicates the VLAN-based DHCP option 82 function. Options: 1. enable(1) -indicates that the DHCP option 82 function is enabled. 2. disable(2) -indicates that the DHCP option 82 function is disabled. This leaf is optional for creating a VLAN service profile. The global DHCP option 82 function can be configured in hwDhcpOption82Status of HUAWEI-DHCP-Proxy-MIB. The final status of the DHCP option 82 function is determined by its global-level switch and VLAN-level switch. The DHCP option 82 function of a VLAN is enabled only when the switches at both levels are enabled. ')
hwPitpSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPitpSwitch.setStatus('current')
if mibBuilder.loadTexts: hwPitpSwitch.setDescription('Indicates the PITP switch based on VLAN. Options: 1. enable(1) -indicates enabling the PITP switch. 2. disable(2) -indicates disabling the PITP switch. This leaf is optional for creating a VLAN service profile. Leaf hwDslamPITPStatus in HUAWEI-DSLAM-PITP-MIB can be used for configuring the global PITP switch. The final status of the PITP switch is determined by both the global-level PITP switch and the VLAN-level PITP switch. The PITP function is enabled on the VLAN only when the switches at both levels are enabled. ')
hwPolicyBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPolicyBroadcast.setStatus('current')
if mibBuilder.loadTexts: hwPolicyBroadcast.setDescription('Indicates the VLAN-based forwarding policy for the broadcast packets. Options: 1. forward(1) -indicates that the broadcast packets are transparently transmitted. 2. discard(2) -indicates that the broadcast packets are discarded. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. You can perform the set operation on this leaf to modify the VLAN-based forwarding policy for the broadcast packets. The VLAN-based forwarding policy for the broadcast packets can also be configured in hwVlanPolicyBroadcast of hwVlanMIBTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwPolicyMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPolicyMulticast.setStatus('current')
if mibBuilder.loadTexts: hwPolicyMulticast.setDescription('Indicates the VLAN-based forwarding policy for the unknown multicast packets. Options: 1. forward(1) -indicates that the unknown multicast packets are transparently transmitted. 2. discard(2) -indicates that the unknown multicast packets are discarded. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. You can perform the set operation on this leaf to modify the VLAN-based forwarding policy for the unknown multicast packets. The VLAN-based forwarding policy for the unknown multicast packets can also be configured in hwVlanPolicyMulticast of hwVlanMIBTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwPolicyUnknowncast = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPolicyUnknowncast.setStatus('current')
if mibBuilder.loadTexts: hwPolicyUnknowncast.setDescription('Indicates the VLAN-based forwarding policy for the unknown unicast packets. Options: 1. forward(1) -indicates that the unknown unicast packets are transparently transmitted. 2. discard(2) -indicates that the unknown unicast packets are discarded. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. You can perform the set operation on this leaf to modify the VLAN-based forwarding policy for the unknown unicast packets. The VLAN-based forwarding policy for the unknown unicast packets can also be configured in hwVlanPolicyUnknowncast of hwVlanMIBTable. If a VLAN service profile is bound to the VLAN, the configuration in the VLAN service profile takes effect. ')
hwUserBridging = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwUserBridging.setStatus('current')
if mibBuilder.loadTexts: hwUserBridging.setDescription('Indicates the VLAN-based bridging function. Options: 1. enable(1) -indicates bridging in a VLAN. 2. disable(2) -indicates L2 isolation in a VLAN. This leaf is optional for creating a VLAN service profile. ')
hwDhcpSuppressSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDhcpSuppressSwitch.setStatus('current')
if mibBuilder.loadTexts: hwDhcpSuppressSwitch.setDescription('DHCP boardcast-suppress switch. Options: 1. enable(1) -Enable DHCP boardcast-suppress. 2. disable(2) -Disable DHCP boardcast-suppress. This leaf is optional for creating a VLAN service profile. ')
hwMismatchIgmpPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transparent", 1), ("discard", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMismatchIgmpPolicy.setStatus('current')
if mibBuilder.loadTexts: hwMismatchIgmpPolicy.setDescription('Indicates the VLAN-based forwarding policy for the mismatched IGMP packets. Options: 1. transparent(1) -indicates that the mismatched IGMP packets are transparently transmitted. 2. discard(2) -indicates that the mismatched IGMP packets are discarded. This leaf is optional for creating a VLAN service profile. ')
hwVmacStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVmacStatus.setStatus('current')
if mibBuilder.loadTexts: hwVmacStatus.setDescription('Indicates the VLAN-based VMAC function. Options: 1. enable(1) -indicates that the VMAC function is enabled. 2. disable(2) -indicates that the VMAC function is disabled. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The global VMAC function can be configured in hwIpDslamVmacStatus of HUAWEI-IPDSLAM-VMAC-MIB. The VLAN-based VMAC function can also be configured hwIpDslamL2pVlanCtrlVmacStatus of HUAWEI-IPDSLAM-L2PPORTCONFIG-MIB. The final status of the VMAC function is determined by its global-level switch and VLAN-level switch. The VMAC function of a VLAN is enabled only when the switches at both levels are enabled. If a VLAN service profile is bound to the VLAN, the configuration of the VLAN-based VMAC function in the VLAN service profile takes effect. ')
hwIPoEMacMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("multiMac", 1), ("singleMac", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIPoEMacMode.setStatus('current')
if mibBuilder.loadTexts: hwIPoEMacMode.setDescription('Indicates the mode of allocating MAC addresses to DHCP users. Options: 1. multiMac(1) -indicates the multi-MAC mode. 2. singleMac(2) -indicates the single-MAC mode. This leaf is optional for creating a VLAN service profile. The global mode of allocating MAC addresses to DHCP users can be configured in hwIpDslamIPoEMacMode of HUAWEI-IPDSLAM-VMAC-MIB. The final status of the mode of allocating MAC addresses to DHCP users is determined by its global-level switch and VLAN-level switch. The single-MAC mode of a VLAN can be enabled only when the single-MAC mode is enabled at both levels. ')
hwVmacAgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("macLearning", 1), ("dhcp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVmacAgingMode.setStatus('current')
if mibBuilder.loadTexts: hwVmacAgingMode.setDescription('Indicates the time selection mode for reallocating VMAC addresses to users. Options: 1. macLearning(1) -indicates that the VMAC addresses are reallocated to users after the corresponding MAC address learning entry ages. 2. dhcp(2) -indicates that the VMAC addresses are reallocated to users after the corresponding IP addresses are released or the lease time of the IP address expires. This leaf is optional for creating a VLAN service profile. ')
hwFabricMacLearningSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwFabricMacLearningSwitch.setStatus('current')
if mibBuilder.loadTexts: hwFabricMacLearningSwitch.setDescription('Indicates the VLAN-based MAC address learning capability switch of the control board. Options: 1. enable(1) -indicates that the VLAN-based MAC address learning is enabled. 2. disable(2) -indicates that the VLAN-based MAC address learning is disabled. This leaf is optional for creating a VLAN service profile. ')
hwOspfTunnelSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwOspfTunnelSwitch.setStatus('current')
if mibBuilder.loadTexts: hwOspfTunnelSwitch.setDescription('Indicates the VLAN-based OSPF transparent transmission function. Options: 1. enable(1) -indicates that the OSPF transparent transmission function is enabled. 2. disable(2) -indicates that the OSPF transparent transmission function is disabled. This leaf is optional for creating a VLAN service profile. ')
hwL3ProtocolTunnelSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwL3ProtocolTunnelSwitch.setStatus('current')
if mibBuilder.loadTexts: hwL3ProtocolTunnelSwitch.setDescription('Indicates the VLAN-based L2 transparent transmission function of other L3 protocol packets except RIP and OSPF packets. Options: 1. enable(1) -indicates that the transparent transmission function is enabled. 2. disable(2) -indicates that the transparent transmission function is disabled. This leaf is optional for creating a VLAN service profile. ')
hwDhcpv6Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notConfig", 1), ("layer2", 2), ("layer3", 3), ("layer3option16", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDhcpv6Mode.setStatus('current')
if mibBuilder.loadTexts: hwDhcpv6Mode.setDescription('Indicates the VLAN-based DHCPv6 L2/L3 mode switch. Options: 1. notConfig(1) -indicates that the configuration in global mode takes effect. 2. layer2(2) -indicates the DHCPv6 L2 forwarding mode. In this mode, the device only transparently transmits packets and does not process the packets. 3. layer3(3) -indicates the standard mode of the DHCPv6 L3 forwarding mode. In this mode, packets select the DHCPv6 server through the VLAN L3 interface that is used for forwarding the DHCPv6 packets. 4. layer3option16(4) -indicates the option 16 mode of the DHCPv6 L3 forwarding mode. In this mode, packets select the DHCPv6 server according to the option 16 field. Option 16 is an option with code 16 in the DHCPv6 packets. It can identify the terminal type. That is, packets can select the DHCPv6 server according to terminal types. This leaf is optional for creating a VLAN service profile. The DHCPv6 L2/L3 mode in the global mode can also be set in hwDhcpv6RelayMode of HUAWEI-DHCPV6-RELAY-MIB. If a VLAN service profile is bound to the VLAN, and the hwDhcpv6Mode in VLAN service profile is not notConfig(1), the configuration in the VLAN service profile takes effect. The global DHCPv6 L2/L3 mode, however, is not changed. If no VLAN service profile is bound to the VLAN, or the hwDhcpv6Mode in VLAN service profile is notConfig(1), the configuration in the global mode takes effect. ')
hwDhcpv6OptionSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDhcpv6OptionSwitch.setStatus('current')
if mibBuilder.loadTexts: hwDhcpv6OptionSwitch.setDescription('Indicates the VLAN-based DHCPv6 option function. Options: 1. enable(1) -indicates that the DHCPv6 option 18 and optin 37 function are enabled. 2. disable(2) -indicates that the DHCPv6 option 18 and optin 37 function are disabled. This leaf is optional for creating a VLAN service profile. The global DHCPv6 option function can be configured in hwDhcpv6OptionStatus of HUAWEI-DHCPV6-RELAY-MIB. The final status of the DHCPv6 option function is determined by its global-level switch and VLAN-level switch. The DHCPv6 option function of a VLAN is enabled only when the switches at both levels are enabled. ')
hwVmacIPoESubStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVmacIPoESubStatus.setStatus('current')
if mibBuilder.loadTexts: hwVmacIPoESubStatus.setDescription('Indicates the VLAN-based IPoE VMAC function. Options: 1. enable(1) -indicates that the IPoE VMAC function is enabled. 2. disable(2) -indicates that the IPoE VMAC function is disabled. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The VLAN-based IPoE VMAC function can be configured in hwIpDslamL2pVlanCtrlVmacIPoESubStatus of HUAWEI-IPDSLAM-L2PPORTCONFIG-MIB. The status of the IPoE VMAC function is determined by its VLAN-level switch. The IPoE VMAC function of a VLAN is enabled only when the VLAN-level switch is enabled. If a VLAN service profile is bound to the VLAN, the configuration of the VLAN-based IPoE VMAC function in the VLAN service profile takes effect. ')
hwVmacPPPoESubStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVmacPPPoESubStatus.setStatus('current')
if mibBuilder.loadTexts: hwVmacPPPoESubStatus.setDescription('Indicates the VLAN-based PPPoE VMAC function. Options: 1. enable(1) -indicates that the PPPoE VMAC function is enabled. 2. disable(2) -indicates that the PPPoE VMAC function is disabled. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The VLAN-based PPPoE VMAC function can be configured in hwIpDslamL2pVlanCtrlVmacPPPoESubStatus of HUAWEI-IPDSLAM-L2PPORTCONFIG-MIB. The status of the PPPoE VMAC function is determined by its VLAN-level switch. The PPPoE VMAC function of a VLAN is enabled only when the VLAN-level switch is enabled. If a VLAN service profile is bound to the VLAN, the configuration of the VLAN-based PPPoE VMAC function in the VLAN service profile takes effect. ')
hwVmacPPPoASubStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVmacPPPoASubStatus.setStatus('current')
if mibBuilder.loadTexts: hwVmacPPPoASubStatus.setDescription('Indicates the VLAN-based PPPoA VMAC function. Options: 1. enable(1) -indicates that the PPPoA VMAC function is enabled. 2. disable(2) -indicates that the PPPoA VMAC function is disabled. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The VLAN-based PPPoA VMAC function can be configured in hwIpDslamL2pVlanCtrlVmacPPPoASubStatus of HUAWEI-IPDSLAM-L2PPORTCONFIG-MIB. The status of the PPPoA VMAC function is determined by its VLAN-level switch. The PPPoA VMAC function of a VLAN is enabled only when the VLAN-level switch is enabled. If a VLAN service profile is bound to the VLAN, the configuration of the VLAN-based PPPoA VMAC function in the VLAN service profile takes effect. ')
hwPPPoAMacMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("multiMac", 1), ("singleMac", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPPPoAMacMode.setStatus('current')
if mibBuilder.loadTexts: hwPPPoAMacMode.setDescription('Indicates the VLAN-based PPPoA single-MAC function. Options: 1. multiMac(1) -indicates that the multi-MAC mode is adopted. 2. singleMac(2) -indicates that the single-MAC mode is adopted. 3. notConfig(3) -indicate by VLAN single switch. This leaf is optional for creating a VLAN service profile. The PPPoA single-MAC function in the global mode can be set in hwIpDslamPPPoAMacMode of HUAWEI-IPDSLAM-PPPOE-MIB. The VLAN-based PPPoA single-MAC function can also be configured in hwIpDslamL2pVlanCtrlPppoaMacMode of hwIpDslamL2pVlanCtrlTable in HUAWEI-IPDSLAM-L2PPORTCONFIG-MIB. The final status of the PPPoA single-MAC function is determined by its global-level switch and VLAN-level switch. The PPPoA single-MAC function of a VLAN is enabled only when the switches at both levels are enabled. If a VLAN service profile is bound to the VLAN, the configuration of the VLAN-based PPPoA single-MAC function in the VLAN service profile takes effect. ')
hwAntiIpv6SpoofingSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwAntiIpv6SpoofingSwitch.setStatus('current')
if mibBuilder.loadTexts: hwAntiIpv6SpoofingSwitch.setDescription('Indicates the VLAN-based anti-IPv6-spoofing function. Options: 1. enable(1) -indicates that the anti-IPv6-spoofing function is enabled. 2. disable(2) -indicates that the anti-IPv6-spoofing function is disabled. This leaf is optional for creating a VLAN service profile. The anti-IPv6-spoofing function in the global mode can be set in hwIpDslamAntiIpv6SpoofingStatus of HUAWEI-IPDSLAM-SECURITY-MIB. The final status of the anti-IPv6-spoofing function is determined by its global-level switch and VLAN-level switch. The anti-IPv6-spoofing function of a VLAN is enabled only when the switches at both levels are enabled. ')
hwIpv6DadProxySwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpv6DadProxySwitch.setStatus('current')
if mibBuilder.loadTexts: hwIpv6DadProxySwitch.setDescription('Indicates the VLAN-based IPv6 dad proxy function. Options: 1. enable(1) -indicates that the IPv6 dad proxy function is enabled. 2. disable(2) -indicates that the IPv6 dad proxy function is disabled. This leaf is optional for creating a VLAN service profile. The IPv6 dad proxy function in the global mode can be set in hwIpDslamIpv6DadProxySwitch of HUAWEI-IPDSLAM-SECURITY-MIB. The final status of the IPv6 dad proxy function is determined by its global-level switch and VLAN-level switch. The IPv6 dad proxy function of a VLAN is enabled only when the switches at both levels are enabled. ')
hwIpv6BindRouteAndNdSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpv6BindRouteAndNdSwitch.setStatus('current')
if mibBuilder.loadTexts: hwIpv6BindRouteAndNdSwitch.setDescription('Indicates the VLAN-based bind-route-nd function. Options: 1. enable(1) -indicates that the bind-route-nd function is enabled. 2. disable(2) -indicates that the bind-route-nd function is disabled. This leaf is optional for creating a VLAN service profile. The bind-route-nd function in the global mode can be set in hwIpDslamIpv6BindRouteAndNdSwitch of HUAWEI-IPDSLAM-SECURITY-MIB. The final status of the bind-route-nd function is determined by its global-level switch and VLAN-level switch. The bind-route-nd function of a VLAN is enabled only when the switches at both levels are enabled. ')
hwIpv6NsReplySwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpv6NsReplySwitch.setStatus('current')
if mibBuilder.loadTexts: hwIpv6NsReplySwitch.setDescription('Indicates the VLAN-based ns reply function. Options: 1. enable(1) -indicates that the ns reply function is enabled. 2. disable(2) -indicates that the ns reply function is disabled. This leaf is optional for creating a VLAN service profile. The ns reply function in the global mode can be set in hwIpDslamIpv6NsReplySwitch of HUAWEI-IPDSLAM-SECURITY-MIB. The final status of the ns reply function is determined by its global-level switch and VLAN-level switch. The ns reply function of a VLAN is enabled only when the switches at both levels are enabled. ')
hwIpv4ArpReplySwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpv4ArpReplySwitch.setStatus('current')
if mibBuilder.loadTexts: hwIpv4ArpReplySwitch.setDescription('Indicates the VLAN-based arp reply function. Options: 1. enable(1) -indicates that the arp reply function is enabled. 2. disable(2) -indicates that the arp reply function is disabled. This leaf is optional for creating a VLAN service profile. The arp reply function in the global mode can be set in hwIpDslamIpv4ArpReplySwitch of HUAWEI-IPDSLAM-SECURITY-MIB. The final status of the arp reply function is determined by its global-level switch and VLAN-level switch. The arp replyd function of a VLAN is enabled only when the switches at both levels are enabled. ')
hwDhcpRelayInterfaceRelayAgentSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("receive", 1), ("send", 2), ("notConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDhcpRelayInterfaceRelayAgentSwitch.setStatus('current')
if mibBuilder.loadTexts: hwDhcpRelayInterfaceRelayAgentSwitch.setDescription('Indicates the VLAN-based filling mode of the GIADDR field of the current DHCP-relay upstream packet. Options: 1. receive(1) -indicates that in the DHCP packet sent from the DHCP relay agent to the server, the gateway IP address is set to the IP address of the Rx interface (user-side interface). 2. send(2) -indicates that in the DHCP packet sent from the DHCP relay agent to the server, the gateway IP address is set to the IP address of the Tx interface (network-side interface). 3. notConfig(3) -indicates that the configuration in the global mode takes effect. This leaf is optional for creating a VLAN service profile. The filling mode of the GIADDR field of the current DHCP-relay upstream packet in the global mode can be set in hwDhcpRelayInterfaceRelayAgent of HUAWEI-DHCP-PROXY-MIB. The final status of the configuration is determined by its global-level switch and VLAN-level switch. If a VLAN service profile is bound to the VLAN, and the hwDhcpRelayInterfaceRelayAgentSwitch in VLAN service profile is not notConfig(3), the configuration in the VLAN service profile takes effect. If no VLAN service profile is bound to the VLAN, or the hwDhcpRelayInterfaceRelayAgentSwitch in VLAN service profile is notConfig(3), the configuration in the global mode takes effect. ')
hwPolicyMulticastFabric = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwPolicyMulticastFabric.setStatus('current')
if mibBuilder.loadTexts: hwPolicyMulticastFabric.setDescription('Indicates the VLAN-based forwarding policy for the control board unknown multicast packets. Options: 1. forward(1) -indicates that the control board unknown multicast packets are transparently transmitted. 2. discard(2) -indicates that the control board unknown multicast packets are discarded. This leaf is optional for creating a VLAN service profile. ')
hwCableSourceVerify = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwCableSourceVerify.setStatus('current')
if mibBuilder.loadTexts: hwCableSourceVerify.setDescription('Indicates VLAN-based Source Address Verification (SAV) function for CM configured policies. Options: 1. enable(1) -indicates that the VLAN-based Source Address Verification for CM configured policies are enabled. 2. disable(2) -indicates that the VLAN-based Source Address Verification for CM configured policies are ignored. ')
hwRipngTunnelSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwRipngTunnelSwitch.setStatus('current')
if mibBuilder.loadTexts: hwRipngTunnelSwitch.setDescription('Indicates the VLAN-based RIPng transparent transmission function. Options: 1. enable(1) -indicates that the RIPng transparent transmission function is enabled. 2. disable(2) -indicates that the RIPng transparent transmission function is disabled. This leaf is optional for creating a VLAN service profile. ')
hwIpv4ArpUnicastSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpv4ArpUnicastSwitch.setStatus('current')
if mibBuilder.loadTexts: hwIpv4ArpUnicastSwitch.setDescription('Indicates the VLAN-based ARP unicast function. Options: 1. enable(1) -indicates that the ARP unicast function is enabled. 2. disable(2) -indicates that the ARP unicast function is disabled. This leaf is optional for creating a VLAN service profile. Default: disable(2) ')
hwIpv4ArpUnicastunkonwnpolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpv4ArpUnicastunkonwnpolicy.setStatus('current')
if mibBuilder.loadTexts: hwIpv4ArpUnicastunkonwnpolicy.setDescription('Used for setting whether to forward or discard ARP packets received from the network side when the user is offline. It takes effect only when the ARP unicast function is enabled. Options: 1. forward(1) -indicates that ARP packets are broadcast to ports inside the VLAN on the user, cascading, and network sides. 2. discard(2) -indicates that ARP packets are discarded on the user side, and only broadcast to ports inside the VLAN on the cascading and network sides. Default: forward(1) ')
hwIpv6NsUnicastSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpv6NsUnicastSwitch.setStatus('current')
if mibBuilder.loadTexts: hwIpv6NsUnicastSwitch.setDescription('Indicates the VLAN-based NS unicast function. Options: 1. enable(1) -indicates that the NS unicast function is enabled. 2. disable(2) -indicates that the NS unicast function is disabled. This leaf is optional for creating a VLAN service profile. Default: disable(2) ')
hwIpv6NsUnicastunkonwnpolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpv6NsUnicastunkonwnpolicy.setStatus('current')
if mibBuilder.loadTexts: hwIpv6NsUnicastunkonwnpolicy.setDescription('Used for setting whether to forward or discard NS packets received from the network side when the user is offline. It takes effect only when the NS unicast function is enabled. Options: 1. forward(1) -indicates that NS packets are broadcast to ports inside the VLAN on the user, cascading, and network sides. 2. discard(2) -indicates that NS packets are discarded on the user side, and only broadcast to ports inside the VLAN on the cascading and network sides. Default: forward(1) ')
hwIgmpUserMaxVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unaware", 1), ("untag", 2), ("single", 3), ("double", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIgmpUserMaxVlanTag.setStatus('current')
if mibBuilder.loadTexts: hwIgmpUserMaxVlanTag.setDescription('Indicates the VLAN-based IGMP user max VLAN tag mode. Options: 1. unaware(1) -indicates that the maximum number of VLAN tags for the IGMP user is not concerned. 2. untag(2) -indicates that the maximum number of VLAN tags for the IGMP user is untag. 3. single(3) -indicates that the maximum number of VLAN tags for the IGMP user is one tag. 4. double(4) -indicates that the maximum number of VLAN tags for the IGMP user is two tags. Default: unaware(1) This leaf is optional for creating a VLAN service profile. ')
hwRouterRedirectReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwRouterRedirectReverse.setStatus('current')
if mibBuilder.loadTexts: hwRouterRedirectReverse.setDescription('Indicates the Layer 2 forwarding function of reverse Router-Redirect packets. Options: 1. enable(1) -indicates that the Layer 2 forwarding function of reverse Router-Redirect packets is enabled. 2. disable(2) -indicates that the Layer 2 forwarding function of reverse Router-Redirect packets is disabled. This leaf is optional for creating a VLAN service profile. ')
hwCableIPv6SourceVerify = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwCableIPv6SourceVerify.setStatus('current')
if mibBuilder.loadTexts: hwCableIPv6SourceVerify.setDescription('Indicates VLAN-based IPv6 Source Address Verification (SAV) function for CM configured policies. Options: 1. enable(1) -indicates that the VLAN-based IPv6 Source Address Verification for CM configured policies are enabled. 2. disable(2) -indicates that the VLAN-based IPv6 Source Address Verification for CM configured policies are ignored. This leaf is optional for creating a VLAN service profile. Default: enable(1) ')
hwProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 25, 1, 255), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwProfileRowStatus.setDescription('Indicates the row status, used for creating or deleting a VLAN profile. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) To create a VLAN service profile, set hwProfileRowStatus to createAndGo(4) to perform the set operation. The other leaves are optional. To delete a VLAN service profile, set hwProfileRowStatus to destroy(6) to perform the set operation. To modify a VLAN service profile, you need not specify hwProfileRowStatus, but perform the set operation directly on the leaf of the corresponding attribute to be modified. During query, the value of this leaf is the fixed active(1). ')
hwSmartVlanIsolateSwitch = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwSmartVlanIsolateSwitch.setStatus('current')
if mibBuilder.loadTexts: hwSmartVlanIsolateSwitch.setDescription('Enable/Disable smart VLAN isolate-configuration. During the creation of a VLAN service profile, if this leaf is not specified. Options: 1. enabled(1) -indicates smart VLAN isolate-config is enabled. 2. disabled(2) -indicates smart VLAN isolate-config is disabled. Default: enabled(1) ')
hwVlanIpAwareTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 27), )
if mibBuilder.loadTexts: hwVlanIpAwareTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAwareTable.setDescription('Enables or disables the IP aware function of a VLAN. After the IP aware function is enabled, the destination IP address of the IP packets forwarded in the VLAN will be perceived and the packets will be forwarded to different gateways according to different destination IP addresses. The index of this table is hwVlanIpAwareVlanID. ')
hwVlanIpAwareEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 27, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIpAwareVlanID"))
if mibBuilder.loadTexts: hwVlanIpAwareEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAwareEntry.setDescription('Enables or disables the IP aware function of a VLAN. After the IP aware function is enabled, the destination IP address of the IP packets forwarded in the VLAN will be perceived and the packets will be forwarded to different gateways according to different destination IP addresses. The index of this entry is hwVlanIpAwareVlanID. ')
hwVlanIpAwareVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 27, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanIpAwareVlanID.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAwareVlanID.setDescription('Indicates the ID of the VLAN that needs enabling the IP aware service. Range: 1-4093 ')
hwVlanIpAwareVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 27, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIpAwareVrfName.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAwareVrfName.setDescription('Sets the name of the VPN instance bound to a VLAN. The default value is public network. It is a character string and the length range is 1-31. ')
hwVlanIpAwareRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 27, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVlanIpAwareRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAwareRowStatus.setDescription('Indicates the row status. It is used to enable or disable the IP aware function. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) Only options createAndGo(4) and destroy(6) support the set operation. During query, active(1) is always returned for this leaf. ')
hwVlanIpAwareSrcIPMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 27, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clientIp", 1), ("virtualIp", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIpAwareSrcIPMode.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAwareSrcIPMode.setDescription('Indicates the source IP address obtaining mode of the ARP request. Options: 1. clientIp(1) -The source IP address obtaining mode is client IP. 2. virtualIp(2) -The source IP address obtaining mode is virtual IP. Default: clientIp(1) ')
hwVlanIpAwareArpSendPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 27, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 3600)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanIpAwareArpSendPeriod.setStatus('current')
if mibBuilder.loadTexts: hwVlanIpAwareArpSendPeriod.setDescription('Indicates the period for sending ARP requests. Range: 5-3600 Unit: second Default: 180s ')
hwIpAwareVirtualIPTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 28), )
if mibBuilder.loadTexts: hwIpAwareVirtualIPTable.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareVirtualIPTable.setDescription('Configures the virtual IP address of a VLAN. After the IP aware function of a VLAN is enabled, the VLAN needs to obtain the gateway MAC address through the ARP request and use the configured virtual IP address as the source IP address of the ARP request. The indexes of this table are hwIpAwareVirtualIPVlanID,hwIpAwareVirtualIP, and hwIpAwareVirtualIPMask. ')
hwIpAwareVirtualIPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 28, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwIpAwareVirtualIPVlanID"), (0, "HUAWEI-VLAN-MIB", "hwIpAwareVirtualIP"), (0, "HUAWEI-VLAN-MIB", "hwIpAwareVirtualIPMask"))
if mibBuilder.loadTexts: hwIpAwareVirtualIPEntry.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareVirtualIPEntry.setDescription('Configures the virtual IP address of a VLAN. After the IP aware function of a VLAN is enabled, the VLAN needs to obtain the gateway MAC address through the ARP request and use the configured virtual IP address as the source IP address of the ARP request. The indexes of this entry are hwIpAwareVirtualIPVlanID, hwIpAwareVirtualIP, and hwIpAwareVirtualIPMask. ')
hwIpAwareVirtualIPVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 28, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwIpAwareVirtualIPVlanID.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareVirtualIPVlanID.setDescription('Indicates the table index. It is the ID of the VLAN that needs configuring a virtual IP address. ')
hwIpAwareVirtualIP = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 28, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwIpAwareVirtualIP.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareVirtualIP.setDescription('Indicates the virtual IP address. ')
hwIpAwareVirtualIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 28, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwIpAwareVirtualIPMask.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareVirtualIPMask.setDescription('Indicates the mask of the virtual IP address. ')
hwIpAwareVirtualIPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 28, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwIpAwareVirtualIPRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareVirtualIPRowStatus.setDescription('Indicates the row status and is used for creating or deleting an IP address. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) Only options createAndGo(4) and destroy(6) support the set operation. During query, active(1) is always returned for this leaf. ')
hwIpAwareRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 29), )
if mibBuilder.loadTexts: hwIpAwareRouteTable.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareRouteTable.setDescription('Configures the dedicated static route of the IP aware service. When a VLAN whose IP aware function is enabled is used to forward IP packets, a static route is required so that packets with different IP address segments can be forwarded to the gateway. The indexes of this table are hwIpAwareRouteDstIP, hwIpAwareRouteMask and hwIpAwareRouteVlanID. ')
hwIpAwareRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 29, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwIpAwareRouteDstIP"), (0, "HUAWEI-VLAN-MIB", "hwIpAwareRouteMask"), (0, "HUAWEI-VLAN-MIB", "hwIpAwareRouteVlanID"))
if mibBuilder.loadTexts: hwIpAwareRouteEntry.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareRouteEntry.setDescription('Configures the dedicated static route of the IP aware service. When a VLAN whose IP aware function is enabled is used to forward IP packets, a static route is required so that packets with different IP address segments can be forwarded to the gateway. The indexes of this entry are hwIpAwareRouteDstIP, hwIpAwareRouteMask and hwIpAwareRouteVlanID. ')
hwIpAwareRouteDstIP = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 29, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpAwareRouteDstIP.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareRouteDstIP.setDescription('Indicates the destination IP address of the static route. It is a table index. ')
hwIpAwareRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 29, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpAwareRouteMask.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareRouteMask.setDescription('Indicates the static route mask. It is a table index.')
hwIpAwareRouteVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 29, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpAwareRouteVlanID.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareRouteVlanID.setDescription('Indicates the VLAN of the static route. It is a table index. ')
hwIpAwareRouteNexthopIP = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 29, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwIpAwareRouteNexthopIP.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareRouteNexthopIP.setDescription('Indicates the gateway IP address of the static route. ')
hwIpAwareRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 29, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwIpAwareRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwIpAwareRouteRowStatus.setDescription('Indicates the row status and is used for creating or deleting a static route. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) Only options createAndGo(4) and destroy(6) are supported the set operation. During query, active(1) is always returned for this leaf. ')
hwVlanFlowAccountTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14), )
if mibBuilder.loadTexts: hwVlanFlowAccountTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanFlowAccountTable.setDescription('Describes the VLAN-based traffic statistics, including the numbers of the upstream bytes, downstream bytes, upstream packets, downstream packets, upstream and downstream packets in the ACL-based traffic statistics collection, discarded upstream packets, and discarded downstream packets. The indexes of this table are hwVlanIndex (outer VLAN ID) and hwInnerVlanID (inner VLAN ID). hwVlanIndex references the leaf in hwVlanMIBTable. If hwInnerVlanID is -1, that means the InnerVLAN-based traffic statistics is not supported. If hwVlanTrafficOccupiedTable is being used to query the traffic and bandwidth occupancy of a VLAN, querying hwVlanFlowAccountTable fails. ')
hwVlanFlowAccountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIndex"), (0, "HUAWEI-VLAN-MIB", "hwInnerVlanID"))
if mibBuilder.loadTexts: hwVlanFlowAccountEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanFlowAccountEntry.setDescription('Describes the VLAN-based traffic statistics, including the numbers of the upstream bytes, downstream bytes, upstream packets, downstream packets, upstream and downstream packets in the ACL-based traffic statistics collection, discarded upstream packets, and discarded downstream packets. The indexes of this entry are hwVlanIndex (outer VLAN ID) and hwInnerVlanID (inner VLAN ID). hwVlanIndex references the leaf in hwVlanMIBTable. If hwInnerVlanID is -1, that means the InnerVLAN-based traffic statistics is not supported. If hwVlanTrafficOccupiedTable is being used to query the traffic and bandwidth occupancy of a VLAN, querying hwVlanFlowAccountTable fails. ')
hwInnerVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwInnerVlanID.setStatus('current')
if mibBuilder.loadTexts: hwInnerVlanID.setDescription("Indicates the inner VLAN tag in a stacking VLAN. If the VLAN is not of the stacking attribute or you perform the query operation only by the outer VLAN, this leaf must be set to -1. Currently, ACL-based VLAN traffic statistics of only the outer VLAN can be collected. Therefore, this value of this leaf is not useful, and you'd better set the value to -1. 0 is not supported. ")
hwUpFlowAccountByte = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwUpFlowAccountByte.setStatus('current')
if mibBuilder.loadTexts: hwUpFlowAccountByte.setDescription("Indicates the number of upstream bytes of a VLAN. '18446744073709551615' means invalid value.")
hwDownFlowAccountByte = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwDownFlowAccountByte.setStatus('current')
if mibBuilder.loadTexts: hwDownFlowAccountByte.setDescription("Indicates the number of downstream bytes of a VLAN. '18446744073709551615' means invalid value.")
hwUpFlowAccountPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwUpFlowAccountPacket.setStatus('current')
if mibBuilder.loadTexts: hwUpFlowAccountPacket.setDescription("Indicates the number of upstream packets of a VLAN. '18446744073709551615' means invalid value.")
hwDownFlowAccountPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwDownFlowAccountPacket.setStatus('current')
if mibBuilder.loadTexts: hwDownFlowAccountPacket.setDescription("Indicates the number of downstream packets of a VLAN. '18446744073709551615' means invalid value.")
hwUpStreamPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwUpStreamPacket.setStatus('current')
if mibBuilder.loadTexts: hwUpStreamPacket.setDescription("Indicates the number of upstream packets in the ACL-based VLAN traffic statistics collection. After the first query, 0 is fixedly returned. After the second query, traffic statistics of the VLAN between the two queries are returned. If the query or delete operation is not performed on the traffic statistics of this VLAN within 10 minutes, the traffic statistics collection of the VLAN is invalid. If a new index is specified in the second query, the traffic statistics of the new VLAN are collected. The system can collect the traffic statistics of a maximum of 64 VLANs concurrently. '18446744073709551615' means invalid value.")
hwDownStreamPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwDownStreamPacket.setStatus('current')
if mibBuilder.loadTexts: hwDownStreamPacket.setDescription("Indicates the number of downstream packets in the ACL-based VLAN traffic statistics collection. After the first query, 0 is fixedly returned. After the second query, traffic statistics of the VLAN between the two queries are returned. If the query or delete operation is not performed on the traffic statistics of this VLAN within 10 minutes, the traffic statistics collection of the VLAN is invalid. If a new index is specified in the second query, the traffic statistics of the new VLAN are collected. The system can collect the traffic statistics of a maximum of 64 VLANs concurrently. '18446744073709551615' means invalid value.")
hwFlowAccountAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1))).clone(namedValues=NamedValues(("invalid", -1), ("reset", 0), ("resetAcl", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwFlowAccountAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hwFlowAccountAdminStatus.setDescription('Used to delete the VLAN traffic statistics. Options: 1. invalid(-1) -During the query, the invalid value -1 is fixedly returned. 2. reset(0) -indicates that the VLAN traffic statistics based on service board are deleted. 3. resetAcl(1) -indicates that the VLAN traffic statistics based on ACL are deleted. ')
hwUpFlowAccountDiscardPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwUpFlowAccountDiscardPacket.setStatus('current')
if mibBuilder.loadTexts: hwUpFlowAccountDiscardPacket.setDescription("Indicates the number of upstream discarded packets of a VLAN. '18446744073709551615' means invalid value.")
hwDownFlowAccountDiscardPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 14, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwDownFlowAccountDiscardPacket.setStatus('current')
if mibBuilder.loadTexts: hwDownFlowAccountDiscardPacket.setDescription("Indicates the number of downstream discarded packets of a VLAN. '18446744073709551615' means invalid value.")
hwVlanTrafficOccupiedTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65005), )
if mibBuilder.loadTexts: hwVlanTrafficOccupiedTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanTrafficOccupiedTable.setDescription('Describes the VLAN-based upstream/downstream rate statistics and bandwidth occupancy. The indexes of this table are hwVlanIndex and hwInnerVlanID. hwInnerVlanID must be -1, that means the InnerVLAN-based upstream/downstream rate statistics and bandwidth occupancy are not supported. If hwVlanFlowAccountTable is being used to query the network-side packet statistics of a VLAN, querying hwVlanTrafficOccupiedTable fails. ')
hwVlanTrafficOccupiedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65005, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIndex"), (0, "HUAWEI-VLAN-MIB", "hwInnerVlanID"))
if mibBuilder.loadTexts: hwVlanTrafficOccupiedEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanTrafficOccupiedEntry.setDescription('Describes the VLAN-based upstream/downstream rate statistics and bandwidth occupancy. The indexes of this entry are hwVlanIndex and hwInnerVlanID. hwInnerVlanID must be -1, that means the InnerVLAN-based upstream/downstream rate statistics and bandwidth occupancy are not supported. If hwVlanFlowAccountTable is being used to query the network-side packet statistics of a VLAN, querying hwVlanTrafficOccupiedTable fails. ')
hwVlanUplinkTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65005, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanUplinkTraffic.setStatus('current')
if mibBuilder.loadTexts: hwVlanUplinkTraffic.setDescription('Describes the network-side upstream rate of a VLAN. Unit: kbit/s ')
hwVlanDownTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65005, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanDownTraffic.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownTraffic.setDescription('Describes the network-side downstream rate of a VLAN. Unit: kbit/s ')
hwVlanUplinkBandwidthOccupancyRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65005, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanUplinkBandwidthOccupancyRate.setStatus('current')
if mibBuilder.loadTexts: hwVlanUplinkBandwidthOccupancyRate.setDescription('Describes the upstream bandwidth occupancy of a VLAN, indicated in percentage. ')
hwVlanDownBandwidthOccupancyRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65005, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hwVlanDownBandwidthOccupancyRate.setStatus('current')
if mibBuilder.loadTexts: hwVlanDownBandwidthOccupancyRate.setDescription('Describes the downstream bandwidth occupancy of a VLAN, indicated in percentage. ')
hwMplsVlanTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65006), )
if mibBuilder.loadTexts: hwMplsVlanTable.setStatus('current')
if mibBuilder.loadTexts: hwMplsVlanTable.setDescription('Indicates information for MPLS VLAN. The index of this table is hwVlanIndex. ')
hwMplsVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65006, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanIndex"))
if mibBuilder.loadTexts: hwMplsVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hwMplsVlanEntry.setDescription('Indicates information for MPLS VLAN. The index of this entry is hwVlanIndex. ')
hwMplsVlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65006, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMplsVlanEnable.setStatus('current')
if mibBuilder.loadTexts: hwMplsVlanEnable.setDescription('Indicates the MPLS function of a VLAN Options: 1. enable(1) - enable the MPLS function of a VLAN. 2. disable(2) - disable the MPLS function of a VLAN.')
hwVlanConnectTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007), )
if mibBuilder.loadTexts: hwVlanConnectTable.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectTable.setDescription('Configures the VLAN Connect table. The indexes of this table are hwVlanConnectOuterVlanID and hwVlanConnectInnerVlanID. ')
hwVlanConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVlanConnectOuterVlanID"), (0, "HUAWEI-VLAN-MIB", "hwVlanConnectInnerVlanID"))
if mibBuilder.loadTexts: hwVlanConnectEntry.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectEntry.setDescription('Configures the VLAN Connect table. The indexes of this entry are hwVlanConnectOuterVlanID and hwVlanConnectInnerVlanID. ')
hwVlanConnectOuterVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 4095), )))
if mibBuilder.loadTexts: hwVlanConnectOuterVlanID.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectOuterVlanID.setDescription('Indicates the outer VLAN of the VLAN-connect item. It is a table index. ')
hwVlanConnectInnerVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 4095), )))
if mibBuilder.loadTexts: hwVlanConnectInnerVlanID.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectInnerVlanID.setDescription('Indicates the inner VLAN of the VLAN-connect item. It is a table index. ')
hwVlanConnectSrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, -1))).clone(namedValues=NamedValues(("port", 1), ("invalid", -1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanConnectSrcType.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectSrcType.setDescription('Indicates the source point type of VLAN Connect table. Options: 1. port(1) -indicates that hwVlanConnectSrcPara is ifindex. 2. invalid(-1) -indicates that hwVlanConnectSrcPara is invalid. ')
hwVlanConnectSrcPara = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanConnectSrcPara.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectSrcPara.setDescription('Indicates the source point value of VLAN Connect table. If hwVlanConnectSrcType is equal to invalid(-1), this leaf indicates invalid. If hwVlanConnectSrcType is equal to port(1), this leaf indicates ifindex. ')
hwVlanConnectDstType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, -1))).clone(namedValues=NamedValues(("port", 1), ("flow", 2), ("bundle", 3), ("invalid", -1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanConnectDstType.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectDstType.setDescription('Indicates the source point type of VLAN-connect table. Options: 1. port(1) -indicates that hwVlanConnectDstPara is ifindex. 2. flow(2) -indicates that hwVlanConnectDstPara is flow index. 3. bundle(3) -indicates that hwVlanConnectDstPara is bundle index. 4. invalid(-1) -indicates that hwVlanConnectDstPara is invalid. ')
hwVlanConnectDstPara = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVlanConnectDstPara.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectDstPara.setDescription('Indicates the source point value of VLAN-connect table. If hwVlanConnectDstType is equal to invalid(-1), this leaf indicates invalid. If hwVlanConnectDstType is equal to port(1), this leaf indicates ifindex. If hwVlanConnectDstType is equal to flow(2), this leaf indicates flow index. If hwVlanConnectDstType is equal to bundle(3), this leaf indicates bundle index. ')
hwVlanConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65007, 1, 255), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVlanConnectRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwVlanConnectRowStatus.setDescription('Indicates the row status and is used for creating or deleting VLAN-connect item. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) Only options createAndGo(4) and destroy(6) are supported the set operation. During query, active(1) is always returned for this leaf. ')
hwDoubleTagTunnelConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65008))
hwDoubleTagTunnelIgmp = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65008, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDoubleTagTunnelIgmp.setStatus('current')
if mibBuilder.loadTexts: hwDoubleTagTunnelIgmp.setDescription('Switch the double tag tunnel function of IGMP packet. Options: 1. enable(1) -Enable the double-tag tunnel function of IGMP packet. 2. disable(2) -Disable the double-tag tunnel function of IGMP packet. The default value is disable(2). ')
hwDoubleTagTunnelRip = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65008, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDoubleTagTunnelRip.setStatus('current')
if mibBuilder.loadTexts: hwDoubleTagTunnelRip.setDescription('Switch the double tag tunnel function of RIP packet. Options: 1. enable(1) -Enable the double-tag tunnel function of RIP packet. 2. disable(2) -Disable the double-tag tunnel function of RIP packet. The default value is disable(2). ')
hwDoubleTagTunnelDhcp = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65008, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDoubleTagTunnelDhcp.setStatus('current')
if mibBuilder.loadTexts: hwDoubleTagTunnelDhcp.setDescription('Switch the double tag tunnel function of DHCP packet. Options: 1. enable(1) -Enable the double-tag tunnel function of DHCP packet. 2. disable(2) -Disable the double-tag tunnel function of DHCP packet. The default value is disable(2). ')
hwDocsSrvVlanIDTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65009), )
if mibBuilder.loadTexts: hwDocsSrvVlanIDTable.setStatus('current')
if mibBuilder.loadTexts: hwDocsSrvVlanIDTable.setDescription(' This is the service svlan of DOCSIS table. This table is used to configure the service svlan of DOCSIS service board. The indexes of this table are hwFrameIndex and hwSlotIndex. ')
hwDocsSrvVlanIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65009, 1), ).setIndexNames((0, "HUAWEI-DEVICE-MIB", "hwFrameIndex"), (0, "HUAWEI-DEVICE-MIB", "hwSlotIndex"))
if mibBuilder.loadTexts: hwDocsSrvVlanIDEntry.setStatus('current')
if mibBuilder.loadTexts: hwDocsSrvVlanIDEntry.setDescription(' This is the service svlan of DOCSIS table. This table is used to configure the service svlan of DOCSIS service board. The indexes of this entry are hwFrameIndex and hwSlotIndex. ')
hwDocsSrvVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65009, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 4093), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwDocsSrvVlanID.setStatus('current')
if mibBuilder.loadTexts: hwDocsSrvVlanID.setDescription(' Indicates the service svlan of DOCSIS service board. Range: 1-4093. -1 indicates that hwDocsSrvVlanID is invalid. ')
hwDocsSrvVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65009, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwDocsSrvVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwDocsSrvVlanRowStatus.setDescription(' Indicates the row status, used for creating or deleting a service VLAN of DOCSIS service board. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) To create a service VLAN, you must specify hwDocsSrvVlanID and set hwDocsSrvVlanRowStatus to createAndGo(4) to perform the set operation. To delete a VLAN, set hwDocsSrvVlanRowStatus to destroy(6) to perform the set operation. During query, the value of this leaf is the fixed active(1). ')
hwVOIPDhcpQosTable = MibTable((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 35), )
if mibBuilder.loadTexts: hwVOIPDhcpQosTable.setStatus('current')
if mibBuilder.loadTexts: hwVOIPDhcpQosTable.setDescription(' Indicates the Qos IP tos and VLAN priority. The indexes of this table are hwVOIPDhcpVlanID and hwVOIPDhcpQosType. ')
hwVOIPDhcpQosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 35, 1), ).setIndexNames((0, "HUAWEI-VLAN-MIB", "hwVOIPDhcpVlanID"), (0, "HUAWEI-VLAN-MIB", "hwVOIPDhcpQosType"))
if mibBuilder.loadTexts: hwVOIPDhcpQosEntry.setStatus('current')
if mibBuilder.loadTexts: hwVOIPDhcpQosEntry.setDescription(' Indicates the Qos IP tos and VLAN priority. The indexes of this entry are hwVOIPDhcpVlanID and hwVOIPDhcpQosType. ')
hwVOIPDhcpVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 35, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4093)))
if mibBuilder.loadTexts: hwVOIPDhcpVlanID.setStatus('current')
if mibBuilder.loadTexts: hwVOIPDhcpVlanID.setDescription(' Indicates the service VLAN. Range: 1-4093. ')
hwVOIPDhcpQosType = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 35, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: hwVOIPDhcpQosType.setStatus('current')
if mibBuilder.loadTexts: hwVOIPDhcpQosType.setDescription(' Indicates the type of QOS. The value 0 indicates that the type of QOS is signaling. The value 1 indicates that the type of QOS is media. ')
hwVOIPDhcpQosIPTos = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 35, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 255), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVOIPDhcpQosIPTos.setStatus('current')
if mibBuilder.loadTexts: hwVOIPDhcpQosIPTos.setDescription(' Indicates the Qos value of tos. Range: -1, 0-255. -1 indicates that the Qos value is invalid. ')
hwVOIPDhcpQosIPDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 35, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 255), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVOIPDhcpQosIPDscp.setStatus('current')
if mibBuilder.loadTexts: hwVOIPDhcpQosIPDscp.setDescription(' Indicates the Qos value of dscp. Range: -1, 0-255. -1 indicates that the Qos value is invalid. ')
hwVOIPDhcpQosVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 35, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwVOIPDhcpQosVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hwVOIPDhcpQosVlanPriority.setDescription(' Indicates the Qos VLAN priority. Range: 0-7. ')
hwVOIPDhcpQosRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 35, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hwVOIPDhcpQosRowStatus.setStatus('current')
if mibBuilder.loadTexts: hwVOIPDhcpQosRowStatus.setDescription('Indicates the status of this conceptual row. Options: 1. active(1) 2. createAndGo(4) 3. destroy(6) ')
hwMethNativeVlan = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 65010), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(2, 4093), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwMethNativeVlan.setStatus('current')
if mibBuilder.loadTexts: hwMethNativeVlan.setDescription('Indicates the MEth native VLAN. Range: -1, 2-4093 In the set case, -1 indicates delete the MEth native VLAN, 2-4093 indicates set the MEth native VLAN. In the get case, when the MEth native VLAN is not set, -1 is returned, otherwise the MEth native VLAN is returned. Default: -1 ')
hwVlanInterfaceTrapsVbOids = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 30))
hwL3InterfaceType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 30, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vlanif", 1), ("meth", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwL3InterfaceType.setStatus('current')
if mibBuilder.loadTexts: hwL3InterfaceType.setDescription('Describes layer 3 interface type. Options: 1. vlanif(1) -VLAN interface. 2. meth(2) -Meth interface. ')
hwVlanifTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 31))
hwVlanifCommonTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 31, 1))
hwVlanifAlarmTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 31, 2))
hwVlanifAlarmTrapsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 31, 2, 0))
hwVlanifUpTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 31, 2, 0, 1)).setObjects(("HUAWEI-VLAN-MIB", "hwL3InterfaceType"), ("HUAWEI-VLAN-MIB", "hwVlanID"))
if mibBuilder.loadTexts: hwVlanifUpTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanifUpTrap.setDescription('This notification is generated when the Layer-3 interface link is in the up state. ')
hwVlanifDownTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 31, 2, 0, 2)).setObjects(("HUAWEI-VLAN-MIB", "hwL3InterfaceType"), ("HUAWEI-VLAN-MIB", "hwVlanID"))
if mibBuilder.loadTexts: hwVlanifDownTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanifDownTrap.setDescription('This notification is generated when the Layer-3 interface link is in the down state. ')
hwVlanCfgTrapsVbOids = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 32))
hwVlanList = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 32, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwVlanList.setStatus('current')
if mibBuilder.loadTexts: hwVlanList.setDescription('Related VLAN ID list information of the VLAN profile.')
hwVlanSrvProfOperType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 32, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("modify", 2), ("delete", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwVlanSrvProfOperType.setStatus('current')
if mibBuilder.loadTexts: hwVlanSrvProfOperType.setDescription('The operate type of the VLAN service profile. Options: 1. add(1) -Add a VLAN service profile. 2. modify(2) -Modify a VLAN service profile. 3. delete(3) -Delete a VLAN service profile. ')
hwVlanListType = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 32, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("superVlan", 1), ("commonVlan", 2), ("subVlan", 3), ("primaryVlan", 4), ("secondaryVlan", 5), ("regionVlan", 6), ("smartVlan", 7), ("muxVlan", 8), ("multiVlan", 9)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwVlanListType.setStatus('current')
if mibBuilder.loadTexts: hwVlanListType.setDescription('Indicates the type of VLAN list. Options: 1. superVlan(1) -indicates super VLAN. 2. commonVlan(2) -indicates common VLAN. 3. subVlan(3) -indicates sub VLAN, the value is not supported. 4. primaryVlan(4) -indicates primary VLAN, the value is not supported. 5. secondaryVlan(5) -indicates secondary VLAN, the value is not supported. 6. regionVlan(6) -indicates region VLAN, the value is not supported. 7. smartVlan(7) -indicates smart VLAN. 8. muxVlan(8) -indicates MUX VLAN. 9. multiVlan(9) -indicates multi VLAN. ')
hwVlanListAttrib = MibScalar((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 32, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("common", 1), ("qinq", 2), ("stacking", 3), ("subVlan", 4)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hwVlanListAttrib.setStatus('current')
if mibBuilder.loadTexts: hwVlanListAttrib.setDescription('Indicates the attribute of VLAN list. Options: 1. common(1) -indicates common VLAN. 2. qinq(2) -indicates QinQ VLAN. 3. stacking(3) -indicates stacking VLAN. 4. subVlan(4) -indicates sub VLAN. ')
hwVlanCfgTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33))
hwVlanCfgCommonTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1))
hwVlanCfgCommonTrapsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0))
hwVlanNameChangeInfoTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0, 1)).setObjects(("HUAWEI-DEVICE-MIB", "hwConfigChangeIP"), ("HUAWEI-VLAN-MIB", "hwVlanIndex"), ("HUAWEI-VLAN-MIB", "hwVlanName"))
if mibBuilder.loadTexts: hwVlanNameChangeInfoTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanNameChangeInfoTrap.setDescription('The trap to be sent when the VLAN description is changed.')
hwVlanForwardingModeInfoTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0, 2)).setObjects(("HUAWEI-DEVICE-MIB", "hwConfigChangeIP"), ("HUAWEI-VLAN-MIB", "hwVlanIndex"), ("HUAWEI-VLAN-MIB", "hwVlanForwarding"))
if mibBuilder.loadTexts: hwVlanForwardingModeInfoTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanForwardingModeInfoTrap.setDescription('The trap to be sent when the VLAN forwarding mode is changed.')
hwVlanSrvProfChageInfoTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0, 3)).setObjects(("HUAWEI-DEVICE-MIB", "hwConfigChangeIP"), ("HUAWEI-VLAN-MIB", "hwVlanSrvProfName"), ("HUAWEI-VLAN-MIB", "hwVlanSrvProfOperType"))
if mibBuilder.loadTexts: hwVlanSrvProfChageInfoTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanSrvProfChageInfoTrap.setDescription('The trap to be sent when the VLAN profile is configured.')
hwVlanAndVlanSrvProfOperInfoTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0, 4)).setObjects(("HUAWEI-DEVICE-MIB", "hwConfigChangeIP"), ("HUAWEI-VLAN-MIB", "hwVlanList"), ("HUAWEI-VLAN-MIB", "hwVlanSrvProfName"))
if mibBuilder.loadTexts: hwVlanAndVlanSrvProfOperInfoTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanAndVlanSrvProfOperInfoTrap.setDescription('The trap to be sent when a VLAN profile is bound to or unbound from a VLAN.')
hwVlanAddInfoTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0, 5)).setObjects(("HUAWEI-DEVICE-MIB", "hwConfigChangeIP"), ("HUAWEI-VLAN-MIB", "hwVlanList"), ("HUAWEI-VLAN-MIB", "hwVlanListType"), ("HUAWEI-VLAN-MIB", "hwVlanListAttrib"))
if mibBuilder.loadTexts: hwVlanAddInfoTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanAddInfoTrap.setDescription('The trap to be sent when VLANs are added.')
hwVlanDelInfoTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0, 6)).setObjects(("HUAWEI-DEVICE-MIB", "hwConfigChangeIP"), ("HUAWEI-VLAN-MIB", "hwVlanList"))
if mibBuilder.loadTexts: hwVlanDelInfoTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanDelInfoTrap.setDescription('The trap to be sent when VLANs are deleted.')
hwVlanAttrChangedInfoTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0, 7)).setObjects(("HUAWEI-DEVICE-MIB", "hwConfigChangeIP"), ("HUAWEI-VLAN-MIB", "hwVlanList"), ("HUAWEI-VLAN-MIB", "hwVlanListAttrib"))
if mibBuilder.loadTexts: hwVlanAttrChangedInfoTrap.setStatus('current')
if mibBuilder.loadTexts: hwVlanAttrChangedInfoTrap.setDescription('The trap to be sent when the attribute of VLANs are changed.')
hwPortVlanChangedInfoTrap = NotificationType((1, 3, 6, 1, 4, 1, 2011, 5, 6, 1, 33, 1, 0, 8)).setObjects(("HUAWEI-DEVICE-MIB", "hwConfigChangeIP"), ("HUAWEI-VLAN-MIB", "hwVlanList"))
if mibBuilder.loadTexts: hwPortVlanChangedInfoTrap.setStatus('current')
if mibBuilder.loadTexts: hwPortVlanChangedInfoTrap.setDescription('The trap to be sent when the list of the standard ports in VLANs are changed.')
mibBuilder.exportSymbols("HUAWEI-VLAN-MIB", hwVlanNameChangeInfoTrap=hwVlanNameChangeInfoTrap, hwifSvlanSubVlanlisHigh=hwifSvlanSubVlanlisHigh, hwVOIPQosIPStrategy=hwVOIPQosIPStrategy, hwVlanPolicyBroadcast=hwVlanPolicyBroadcast, hwIpAwareRouteTable=hwIpAwareRouteTable, hwMethL2Vlan=hwMethL2Vlan, hwDhcpv6OptionSwitch=hwDhcpv6OptionSwitch, hwRegionVci=hwRegionVci, hwVlanInterfaceEntry=hwVlanInterfaceEntry, hwExistInterface=hwExistInterface, hwPolicyMulticastFabric=hwPolicyMulticastFabric, hwMplsVlanTable=hwMplsVlanTable, hwVOIPQosVlanPriority=hwVOIPQosVlanPriority, hwVlanAggregationSubVlanArpProxyStatus=hwVlanAggregationSubVlanArpProxyStatus, hwVlanListAttrib=hwVlanListAttrib, hwVlanInterfaceLinkStatus=hwVlanInterfaceLinkStatus, hwVlanInterfaceAdminStatus=hwVlanInterfaceAdminStatus, hwPPPoEMacMode=hwPPPoEMacMode, hwVlanUpDirectCarID=hwVlanUpDirectCarID, hwLocalVlan=hwLocalVlan, hwVlanDownCarBurstValue=hwVlanDownCarBurstValue, hwIpv6BindRouteAndNdSwitch=hwIpv6BindRouteAndNdSwitch, hwVlanType=hwVlanType, hwFlowAccountAdminStatus=hwFlowAccountAdminStatus, hwifSvlanVlanID=hwifSvlanVlanID, hwVlanIpAddressMask=hwVlanIpAddressMask, hwVlanMIBEntry=hwVlanMIBEntry, VlanIndex=VlanIndex, hwVlanConnectOuterVlanID=hwVlanConnectOuterVlanID, hwIpv4ArpUnicastSwitch=hwIpv4ArpUnicastSwitch, hwIpv4ArpReplySwitch=hwIpv4ArpReplySwitch, hwVlanIfDhcpClientOption60=hwVlanIfDhcpClientOption60, hwIpv6NsUnicastunkonwnpolicy=hwIpv6NsUnicastunkonwnpolicy, hwIpv6NsUnicastSwitch=hwIpv6NsUnicastSwitch, hwVlanifUpTrap=hwVlanifUpTrap, hwDocsDefaultSrvVlanID=hwDocsDefaultSrvVlanID, hwVlanIpAwareArpSendPeriod=hwVlanIpAwareArpSendPeriod, hwDoubleTagTunnelRip=hwDoubleTagTunnelRip, hwVlanAggregationEntry=hwVlanAggregationEntry, hwVlanInterfaceIDWithSub=hwVlanInterfaceIDWithSub, hwDoubleTagTunnelIgmp=hwDoubleTagTunnelIgmp, hwIpAwareRouteMask=hwIpAwareRouteMask, hwVlanDownCarTable=hwVlanDownCarTable, hwVlanDownCarName=hwVlanDownCarName, hwMethNativeVlan=hwMethNativeVlan, hwDocsSrvVlanIDTable=hwDocsSrvVlanIDTable, hwVlanifAlarmTraps=hwVlanifAlarmTraps, hwLocalVlanEntry=hwLocalVlanEntry, hwIPv4MTU=hwIPv4MTU, hwVOIPQosIPDscpValue=hwVOIPQosIPDscpValue, hwVlanRowStatus=hwVlanRowStatus, hwVlanSrvProfOperType=hwVlanSrvProfOperType, hwifPvlanPrimaryVlanID=hwifPvlanPrimaryVlanID, hwVOIPQosIPAddressSrc=hwVOIPQosIPAddressSrc, hwifSvlanOperStatus=hwifSvlanOperStatus, hwDocsSrvVlanRowStatus=hwDocsSrvVlanRowStatus, hwVlanCfgCommonTraps=hwVlanCfgCommonTraps, hwVlanConnectRowStatus=hwVlanConnectRowStatus, hwUserBridging=hwUserBridging, hwVlanOuterTpid=hwVlanOuterTpid, hwVOIPAddressTable=hwVOIPAddressTable, hwVlanName=hwVlanName, hwAntiIpSpoofingSwitch=hwAntiIpSpoofingSwitch, hwVlanParaTable=hwVlanParaTable, hwOspfTunnelSwitch=hwOspfTunnelSwitch, hwVlanAggregationSuperVlanId=hwVlanAggregationSuperVlanId, hwIpv6NsReplySwitch=hwIpv6NsReplySwitch, hwMultiVlanUplinkPort=hwMultiVlanUplinkPort, hwVlanSuperID=hwVlanSuperID, hwCableSourceVerify=hwCableSourceVerify, hwVlanMacLearn=hwVlanMacLearn, hwMuxVlanSlotStartVlanId=hwMuxVlanSlotStartVlanId, hwVmacPPPoESubStatus=hwVmacPPPoESubStatus, hwVlanMethL2Forward=hwVlanMethL2Forward, hwIpAwareVirtualIPVlanID=hwIpAwareVirtualIPVlanID, hwRegionVLanEntry=hwRegionVLanEntry, hwVlanAggregationRowStatus=hwVlanAggregationRowStatus, hwVOIPAddressObtainMode=hwVOIPAddressObtainMode, hwVlanConnectSrcPara=hwVlanConnectSrcPara, hwInterfaceRowStatus=hwInterfaceRowStatus, hwIpAwareRouteDstIP=hwIpAwareRouteDstIP, hwVlanSrvProfName=hwVlanSrvProfName, hwUpStreamPacket=hwUpStreamPacket, hwVlanMacLearnCpability=hwVlanMacLearnCpability, hwPacketTunnelEntry=hwPacketTunnelEntry, hwSmartVlanIsolateSwitch=hwSmartVlanIsolateSwitch, hwBpduTunnelEntry=hwBpduTunnelEntry, hwBpduTunnelTable=hwBpduTunnelTable, hwMultiVLanEntry=hwMultiVLanEntry, hwVlanCfgCommonTrapsPrefix=hwVlanCfgCommonTrapsPrefix, hwUpFlowAccountByte=hwUpFlowAccountByte, hwPortOuterEthernetTypeTable=hwPortOuterEthernetTypeTable, hwPitpSwitch=hwPitpSwitch, hwVlanIpAddress=hwVlanIpAddress, hwVlanForwardingModeInfoTrap=hwVlanForwardingModeInfoTrap, hwAntiIpv6SpoofingSwitch=hwAntiIpv6SpoofingSwitch, SnmpAdminString=SnmpAdminString, hwVtpCdpTunnelSwitch=hwVtpCdpTunnelSwitch, hwUpFlowAccountPacket=hwUpFlowAccountPacket, hwMuxVlanPortConfRowStatus=hwMuxVlanPortConfRowStatus, hwMuxVlanSlotConfTable=hwMuxVlanSlotConfTable, hwRouterRedirectReverse=hwRouterRedirectReverse, hwVlanConnectTable=hwVlanConnectTable, hwVlanMngObject=hwVlanMngObject, hwifPVLANMappingTable=hwifPVLANMappingTable, hwifSVLANVlanListEntry=hwifSVLANVlanListEntry, hwVlanIfVlanEncapMode=hwVlanIfVlanEncapMode, hwifPvlanSecondaryVlanlistHigh=hwifPvlanSecondaryVlanlistHigh, hwMismatchIgmpPolicy=hwMismatchIgmpPolicy, hwDhcpSuppressSwitch=hwDhcpSuppressSwitch, PYSNMP_MODULE_ID=hwVlan, hwVlanMaxMacLearnNum=hwVlanMaxMacLearnNum, hwVOIPDhcpVlanID=hwVOIPDhcpVlanID, hwVOIPAddressIndex=hwVOIPAddressIndex, hwDoubleTagTunnelConfig=hwDoubleTagTunnelConfig, hwVlanSrvProfEntry=hwVlanSrvProfEntry, hwVlanSrvProfTable=hwVlanSrvProfTable, hwRegionVpi=hwRegionVpi, hwSmartVLanEntry=hwSmartVLanEntry, hwVmacPPPoASubStatus=hwVmacPPPoASubStatus, hwIpAwareRouteNexthopIP=hwIpAwareRouteNexthopIP, hwRipngTunnelSwitch=hwRipngTunnelSwitch, hwPortOuterEthernetType=hwPortOuterEthernetType, hwInnerVlanID=hwInnerVlanID, hwVlanAttrib=hwVlanAttrib, hwDownFlowAccountDiscardPacket=hwDownFlowAccountDiscardPacket, hwMplsVlanEnable=hwMplsVlanEnable, hwRegionPVCRowStatus=hwRegionPVCRowStatus, hwVOIPIPType=hwVOIPIPType, hwVlanIfDHCPSStatus=hwVlanIfDHCPSStatus, hwRipTunnelSwitch=hwRipTunnelSwitch, hwVmacAgingMode=hwVmacAgingMode, hwVlanUpCarName=hwVlanUpCarName, hwVlanIpAwareTable=hwVlanIpAwareTable, hwMultiVlanRowStatus=hwMultiVlanRowStatus, hwVlanifTraps=hwVlanifTraps, hwVlanBindSrvProfName=hwVlanBindSrvProfName, hwPacketTunnelTable=hwPacketTunnelTable, hwDoubleTagTunnelDhcp=hwDoubleTagTunnelDhcp, hwPolicyMulticast=hwPolicyMulticast, hwVlanIpAwareRowStatus=hwVlanIpAwareRowStatus, hwPacketTunnelRip=hwPacketTunnelRip, hwVOIPDhcpQosRowStatus=hwVOIPDhcpQosRowStatus, hwVlanListType=hwVlanListType, hwVOIPGateway=hwVOIPGateway, hwVlanUplinkBandwidthOccupancyRate=hwVlanUplinkBandwidthOccupancyRate, hwVlanUpCarRowStatus=hwVlanUpCarRowStatus, hwVOIPDhcpQosVlanPriority=hwVOIPDhcpQosVlanPriority, hwVlanDownCarRowStatus=hwVlanDownCarRowStatus, hwVlanSubIpAddress=hwVlanSubIpAddress, hwDocsSrvVlanID=hwDocsSrvVlanID, hwVlanAggregationSubVlanId=hwVlanAggregationSubVlanId, hwDownFlowAccountByte=hwDownFlowAccountByte, hwMuxVlanSlotRowStatus=hwMuxVlanSlotRowStatus, hwVlanDelInfoTrap=hwVlanDelInfoTrap, hwIpAwareVirtualIPRowStatus=hwIpAwareVirtualIPRowStatus, hwVlanLocalSwitch=hwVlanLocalSwitch, hwDhcpMode=hwDhcpMode, hwVlanDownTraffic=hwVlanDownTraffic, hwVlanDownCarIsUsed=hwVlanDownCarIsUsed, hwVOIPDhcpQosType=hwVOIPDhcpQosType, hwVlanUpCarIsUsed=hwVlanUpCarIsUsed, hwVlanConnectInnerVlanID=hwVlanConnectInnerVlanID, hwVlanDownBandwidthOccupancyRate=hwVlanDownBandwidthOccupancyRate, hwVlanUpCarEntry=hwVlanUpCarEntry, hwDhcpRelayInterfaceRelayAgentSwitch=hwDhcpRelayInterfaceRelayAgentSwitch, hwVlanFlowAccountEntry=hwVlanFlowAccountEntry, hwVlanTrafficOccupiedTable=hwVlanTrafficOccupiedTable, hwVlanTrafficSuppressUnknowncastNetwork=hwVlanTrafficSuppressUnknowncastNetwork, hwVlanifCommonTraps=hwVlanifCommonTraps, hwVlanPriority=hwVlanPriority, hwVlanInterfaceSubIpAddrTable=hwVlanInterfaceSubIpAddrTable, hwDocsSrvVlanIDEntry=hwDocsSrvVlanIDEntry, hwPPPoAMacMode=hwPPPoAMacMode, hwifPvlanOperStatus=hwifPvlanOperStatus, hwVlanAggregationTable=hwVlanAggregationTable, hwVOIPAddressRowStatus=hwVOIPAddressRowStatus, hwVOIPSubMask=hwVOIPSubMask, hwVlanChangeEnable=hwVlanChangeEnable, hwIpAwareRouteVlanID=hwIpAwareRouteVlanID, hwVlanUpCarBandValue=hwVlanUpCarBandValue, hwifPvlanSecondaryVlanlistLow=hwifPvlanSecondaryVlanlistLow, hwVlanUpCarTable=hwVlanUpCarTable, hwVmacStatus=hwVmacStatus, hwMuxVlanPortConfTable=hwMuxVlanPortConfTable, hwSmartVlanID=hwSmartVlanID, hwVlanPolicyMulticast=hwVlanPolicyMulticast, hwVlanParaEntry=hwVlanParaEntry, hwBpduTunnel=hwBpduTunnel, hwIpv4ArpUnicastunkonwnpolicy=hwIpv4ArpUnicastunkonwnpolicy, hwIpAwareVirtualIP=hwIpAwareVirtualIP, hwVlanParaIndex=hwVlanParaIndex, hwVlanDownCarBandValue=hwVlanDownCarBandValue, hwVlanForwarding=hwVlanForwarding, hwVlanUplinkTraffic=hwVlanUplinkTraffic, hwVlanMcastUnknownProtos=hwVlanMcastUnknownProtos, hwVlanifAlarmTrapsPrefix=hwVlanifAlarmTrapsPrefix, hwVlanifDownTrap=hwVlanifDownTrap, hwVlanCfgTrapsVbOids=hwVlanCfgTrapsVbOids, hwPortVlanChangedInfoTrap=hwPortVlanChangedInfoTrap, hwMuxVlanDownlinkPort=hwMuxVlanDownlinkPort, hwStackingVlanOuterEthernetType=hwStackingVlanOuterEthernetType, hwVlanIpAwareEntry=hwVlanIpAwareEntry, hwVlanUpCarId=hwVlanUpCarId, hwVOIPPPPOEClientName=hwVOIPPPPOEClientName, hwInterfaceSubIpAddrRowStatus=hwInterfaceSubIpAddrRowStatus, hwIpAwareVirtualIPTable=hwIpAwareVirtualIPTable, hwIpAwareVirtualIPMask=hwIpAwareVirtualIPMask, hwStackingVlanInnerEthernetType=hwStackingVlanInnerEthernetType, hwBpduTunnelSwitch=hwBpduTunnelSwitch, hwVlanInterfaceSubIpAddrEntry=hwVlanInterfaceSubIpAddrEntry, hwVlanIpAwareSrcIPMode=hwVlanIpAwareSrcIPMode, hwProfileRowStatus=hwProfileRowStatus, hwVlanConnectSrcType=hwVlanConnectSrcType, hwIgmpUserMaxVlanTag=hwIgmpUserMaxVlanTag, hwVOIPDhcpQosTable=hwVOIPDhcpQosTable, hwIPoEMacMode=hwIPoEMacMode, hwVOIPQosIPTosValue=hwVOIPQosIPTosValue, hwVOIPIPAddress=hwVOIPIPAddress, hwVlanInterfaceFrameType=hwVlanInterfaceFrameType, hwVlanUpCarBurstValue=hwVlanUpCarBurstValue, hwVlanMIBTable=hwVlanMIBTable, hwMultiVLanTable=hwMultiVLanTable, hwMuxVlanUplinkPort=hwMuxVlanUplinkPort, hwForwardingMode=hwForwardingMode, hwVlanAddInfoTrap=hwVlanAddInfoTrap, hwVOIPMACAddress=hwVOIPMACAddress, hwVlanDownCarId=hwVlanDownCarId, hwVOIPIPAddressSrc=hwVOIPIPAddressSrc, hwVlanCfgTraps=hwVlanCfgTraps, hwVlanSrvProfChageInfoTrap=hwVlanSrvProfChageInfoTrap, hwVlanInterfaceIndex=hwVlanInterfaceIndex, hwIpAwareRouteEntry=hwIpAwareRouteEntry, hwUpFlowAccountDiscardPacket=hwUpFlowAccountDiscardPacket, hwAntiMacSpoofingSwitch=hwAntiMacSpoofingSwitch, hwSmartVLanTable=hwSmartVLanTable, PortList=PortList, hwVlanFlowAccountTable=hwVlanFlowAccountTable, hwVlanDownCarEntry=hwVlanDownCarEntry, hwIpAwareVirtualIPEntry=hwIpAwareVirtualIPEntry, hwPortOuterEthernetTypeEntry=hwPortOuterEthernetTypeEntry, hwIpv6DadProxySwitch=hwIpv6DadProxySwitch, hwSmartVlanUplinkPort=hwSmartVlanUplinkPort, hwVlanIndex=hwVlanIndex, hwLocalVlanTable=hwLocalVlanTable, hwVlanSubIpAddressMask=hwVlanSubIpAddressMask, hwIPv6MTU=hwIPv6MTU, hwVlanID=hwVlanID, hwVmacIPoESubStatus=hwVmacIPoESubStatus, hwVOIPQosEntry=hwVOIPQosEntry, hwSmartVlanDownlinkPort=hwSmartVlanDownlinkPort, hwVlan=hwVlan, hwVlanTrafficOccupiedEntry=hwVlanTrafficOccupiedEntry, hwPacketTunnelVTPCDP=hwPacketTunnelVTPCDP)
mibBuilder.exportSymbols("HUAWEI-VLAN-MIB", hwMplsVlanEntry=hwMplsVlanEntry, hwCableIPv6SourceVerify=hwCableIPv6SourceVerify, hwifSVLANVlanListTable=hwifSVLANVlanListTable, hwVOIPAddressEntry=hwVOIPAddressEntry, hwVlanInterfaceID=hwVlanInterfaceID, hwMuxVlanEnable=hwMuxVlanEnable, hwVlanDownDirectCarID=hwVlanDownDirectCarID, hwMultiVlanDownlinkPort=hwMultiVlanDownlinkPort, hwDownStreamPacket=hwDownStreamPacket, hwMultiVlanID=hwMultiVlanID, hwVOIPVlanTagIdentifier=hwVOIPVlanTagIdentifier, hwVlanConnectEntry=hwVlanConnectEntry, hwPolicyUnknowncast=hwPolicyUnknowncast, hwVlanMacFilter=hwVlanMacFilter, hwSmartVlanRowStatus=hwSmartVlanRowStatus, hwL3ProtocolTunnelSwitch=hwL3ProtocolTunnelSwitch, hwifSvlanSubVlanlistLow=hwifSvlanSubVlanlistLow, hwMuxVlanStartVlanId=hwMuxVlanStartVlanId, hwFabricMacLearningSwitch=hwFabricMacLearningSwitch, hwVlanConnectDstPara=hwVlanConnectDstPara, hwVlanPorts=hwVlanPorts, hwVlanConnectDstType=hwVlanConnectDstType, hwVOIPQosTable=hwVOIPQosTable, hwVlanIpAwareVlanID=hwVlanIpAwareVlanID, hwVlanIfVlanInnerLabel=hwVlanIfVlanInnerLabel, hwPolicyBroadcast=hwPolicyBroadcast, hwVlanIpAwareVrfName=hwVlanIpAwareVrfName, hwL3InterfaceType=hwL3InterfaceType, hwIpAwareRouteRowStatus=hwIpAwareRouteRowStatus, hwVlanInterfaceTrapsVbOids=hwVlanInterfaceTrapsVbOids, hwVOIPDhcpQosIPDscp=hwVOIPDhcpQosIPDscp, hwVlanCreationTime=hwVlanCreationTime, hwDot1adTpid=hwDot1adTpid, hwMuxVlanPortType=hwMuxVlanPortType, hwDhcpv6Mode=hwDhcpv6Mode, hwVlanBindRaioProfileName=hwVlanBindRaioProfileName, hwVlanAndVlanSrvProfOperInfoTrap=hwVlanAndVlanSrvProfOperInfoTrap, hwDownFlowAccountPacket=hwDownFlowAccountPacket, hwDhcpProxySwitch=hwDhcpProxySwitch, hwRegionVLanTable=hwRegionVLanTable, hwVlanIfIPMode=hwVlanIfIPMode, hwMuxVlanPortConfEntry=hwMuxVlanPortConfEntry, hwVOIPDhcpQosEntry=hwVOIPDhcpQosEntry, hwVlanAttrChangedInfoTrap=hwVlanAttrChangedInfoTrap, hwVlanPolicyUnknowncast=hwVlanPolicyUnknowncast, hwMuxVlanSlotConfEntry=hwMuxVlanSlotConfEntry, hwVlanInterfaceTable=hwVlanInterfaceTable, hwifPVLANMappingEntry=hwifPVLANMappingEntry, hwVlanAggregationSubVlanNdProxyStatus=hwVlanAggregationSubVlanNdProxyStatus, hwVOIPDhcpQosIPTos=hwVOIPDhcpQosIPTos, hwVlanStatus=hwVlanStatus, hwDhcpOption82Switch=hwDhcpOption82Switch, hwMuxVlanGroupNum=hwMuxVlanGroupNum, hwVlanList=hwVlanList)

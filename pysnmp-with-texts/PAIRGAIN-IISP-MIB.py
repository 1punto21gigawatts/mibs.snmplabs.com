#
# PySNMP MIB module PAIRGAIN-IISP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PAIRGAIN-IISP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:36:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
AtmTrafficDescrParamIndex, = mibBuilder.importSymbols("ATM-MIB", "AtmTrafficDescrParamIndex")
AtmAddr, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmAddr")
ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndex")
pgIISPMIB, = mibBuilder.importSymbols("PAIRGAIN-COMMON-HD-MIB", "pgIISPMIB")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, IpAddress, Unsigned32, Integer32, Bits, iso, NotificationType, Counter64, ObjectIdentity, MibIdentifier, Gauge32, ModuleIdentity, enterprises, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "IpAddress", "Unsigned32", "Integer32", "Bits", "iso", "NotificationType", "Counter64", "ObjectIdentity", "MibIdentifier", "Gauge32", "ModuleIdentity", "enterprises", "TimeTicks")
TimeStamp, TextualConvention, DisplayString, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TextualConvention", "DisplayString", "TruthValue", "RowStatus")
pgIISP = ModuleIdentity((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1))
if mibBuilder.loadTexts: pgIISP.setLastUpdated('0002020000Z')
if mibBuilder.loadTexts: pgIISP.setOrganization('Pairgain Technologies Inc.')
if mibBuilder.loadTexts: pgIISP.setContactInfo(' 14402 Franklin Avenue Tustin, CA 92780 ')
if mibBuilder.loadTexts: pgIISP.setDescription('Initial version of the MIB for monitoring and controlling IISP routing.')
pgIISPMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1))
class PgAtmAddrPrefix(TextualConvention, OctetString):
    description = 'A prefix of one or more ATM End System Addresses. The significant portion of a prefix is padded with zeros on the right to fill 20 octets.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

class PgAtmPrefixLength(TextualConvention, Integer32):
    description = 'The number of bits that are significant in an ATM address .'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 152)

class NetPrefix(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(8, 8), ValueSizeConstraint(13, 13), )
pgIISPRouteAddrIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgIISPRouteAddrIndexNext.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrIndexNext.setDescription('This object contains an appropriate value to be used for pgIISPRouteAddrIndex when creating entries in the pgIISPRouteAddrTable. The value 0 indicates that no unassigned entries are available. To obtain the atmVcCrossConnectIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
pgIISPRouteAddrTable = MibTable((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2), )
if mibBuilder.loadTexts: pgIISPRouteAddrTable.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrTable.setDescription('A table containing all the attributes necessary to determine what the entity believes is reachable in terms of ATM End System Addresses and to determine which nodes are advertising this reachability. This table is also used to configure static routes to reachable address prefixes. The local node index that received the reachability information, reachable address, address prefix length, and an index that distinguishes between multiple listings of connectivity to a given address prefix from a given local node are combined to form an instance ID for this object..')
pgIISPRouteAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1), ).setIndexNames((0, "PAIRGAIN-IISP-MIB", "pgIISPRouteAddrIndex"), (0, "PAIRGAIN-IISP-MIB", "pgIISPRouteAddrAddress"), (0, "PAIRGAIN-IISP-MIB", "pgIISPRouteAddrPrefixLength"))
if mibBuilder.loadTexts: pgIISPRouteAddrEntry.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrEntry.setDescription('An entry in the table, containing information about a reachable address prefix.')
pgIISPRouteAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgIISPRouteAddrIndex.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrIndex.setDescription('An index into the set of listings of connectivity to a given route.')
pgIISPRouteAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pgIISPRouteAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrRowStatus.setDescription('To create, delete, activate and de-activate a reachable address prefix.')
pgIISPRouteAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 3), PgAtmAddrPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgIISPRouteAddrAddress.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrAddress.setDescription('The value of the ATM End System Address prefix.')
pgIISPRouteAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 4), PgAtmPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgIISPRouteAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrPrefixLength.setDescription('The prefix length to be applied to the ATM End System Address prefix.')
pgIISPRouteAddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 5), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPRouteAddrIfIndex.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrIfIndex.setDescription('The local interface over which the reachable address can be reached. The value zero indicates an unknown interface or reachability through a remote node.')
pgIISPRouteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("internal", 3), ("exterior", 4))).clone('exterior')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPRouteAddrType.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrType.setDescription('The type (e.g. internal or exterior) of reachability from the advertising node to the address prefix. Reject(2) refers to an address prefix which, if matched, indicates that the message should be discarded as unreachable. This is used in some protocols as a means of correctly aggregating routes.')
pgIISPRouteAddrAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPRouteAddrAdminStatus.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrAdminStatus.setDescription('Indicates whether the route is configured to be used.')
pgIISPRouteAddrOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("advertised", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPRouteAddrOperStatus.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrOperStatus.setDescription('Indicates whether the reachable address prefix is operationally valid and whether it is being advertised by this node.')
pgIISPRouteAddrTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 2, 1, 9), TimeStamp()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPRouteAddrTimeStamp.setStatus('current')
if mibBuilder.loadTexts: pgIISPRouteAddrTimeStamp.setDescription('Indicates when the connectivity from the advertising node to the reachable address prefix became known to the local node.')
pgIISPNetPrefixIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgIISPNetPrefixIndexNext.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixIndexNext.setDescription('This object contains an appropriate value to be used for pgIISPRouteAddrIndex when creating entries in the pgIISPRouteAddrTable. The value 0 indicates that no unassigned entries are available. To obtain the atmVcCrossConnectIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
pgIISPNetPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4), )
if mibBuilder.loadTexts: pgIISPNetPrefixTable.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixTable.setDescription('A table implemented by the user-side, containing the network-prefix(es) for ATM-layer addresses in effect on the user side of the UNI.')
pgIISPNetPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4, 1), ).setIndexNames((0, "PAIRGAIN-IISP-MIB", "pgIISPNetPrefixIndex"), (0, "PAIRGAIN-IISP-MIB", "pgIISPNetPrefixPort"), (0, "PAIRGAIN-IISP-MIB", "pgIISPNetPrefixPrefix"))
if mibBuilder.loadTexts: pgIISPNetPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixEntry.setDescription('Information about a single network-prefix for ATM-layer addresses in effect on the user-side. Note that the index variable atmNetPrefixPrefix is a variable-length string, and as such the rule for variable-length strings in section 4.1.6 of RFC 1212 applies.')
pgIISPNetPrefixIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgIISPNetPrefixIndex.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixIndex.setDescription('An index into the set of listings of connectivity to a given address prefix.')
pgIISPNetPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pgIISPNetPrefixRowStatus.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixRowStatus.setDescription('To create, delete, activate and de-activate a net prefix entry.')
pgIISPNetPrefixPort = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgIISPNetPrefixPort.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixPort.setDescription('A unique value which identifies the UNI port for which the network prefix for ATM addresses is in effect. The value of 0 has the special meaning of identifying the local UNI.')
pgIISPNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4, 1, 4), NetPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgIISPNetPrefixPrefix.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixPrefix.setDescription('The network prefix for ATM addresses which is in effect on the user side of the ATM UNI port.')
pgIISPNetPrefixFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dcc", 1), ("icd", 2), ("e164", 3))).clone('dcc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPNetPrefixFormat.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixFormat.setDescription('ATM address format.')
pgIISPNetPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 152))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPNetPrefixLength.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixLength.setDescription('The number of bits that are significant in an ATM address prefix used.')
pgIISPNetPrefixStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPNetPrefixStatus.setStatus('current')
if mibBuilder.loadTexts: pgIISPNetPrefixStatus.setDescription('An indication of the validity of the network prefix for ATM addresses on the user side of the UNI port. To configure a new network prefix in this table, the network-side must set the appropriate instance of this object to the value valid(1). To delete an existing network prefix in this table, the network-side must set the appropriate instance of this object to the value invalid(2). If circumstances occur on the user-side which cause a prefix to become invalid, the user-side modifies the value of the appropriate instance of this object to invalid(2). Whenever the value of this object for a particular prefix becomes invalid(2), the conceptual row for that prefix may be removed from the table at any time, either immediately or subsequently.')
pgIISPAtmAddrPrefix = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 9, 13, 1, 1, 5), AtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgIISPAtmAddrPrefix.setStatus('current')
if mibBuilder.loadTexts: pgIISPAtmAddrPrefix.setDescription('The identifier assigned by a service provider. This ATM address prefix is used by more than one line cards in the Avidia.')
mibBuilder.exportSymbols("PAIRGAIN-IISP-MIB", pgIISPNetPrefixIndexNext=pgIISPNetPrefixIndexNext, pgIISPNetPrefixPrefix=pgIISPNetPrefixPrefix, pgIISPNetPrefixFormat=pgIISPNetPrefixFormat, pgIISPMIBObjects=pgIISPMIBObjects, pgIISPRouteAddrTable=pgIISPRouteAddrTable, pgIISPNetPrefixLength=pgIISPNetPrefixLength, pgIISPRouteAddrIndex=pgIISPRouteAddrIndex, pgIISPNetPrefixStatus=pgIISPNetPrefixStatus, pgIISPNetPrefixTable=pgIISPNetPrefixTable, pgIISPNetPrefixEntry=pgIISPNetPrefixEntry, pgIISPRouteAddrIfIndex=pgIISPRouteAddrIfIndex, pgIISPRouteAddrTimeStamp=pgIISPRouteAddrTimeStamp, pgIISPRouteAddrAddress=pgIISPRouteAddrAddress, pgIISPRouteAddrPrefixLength=pgIISPRouteAddrPrefixLength, pgIISPNetPrefixPort=pgIISPNetPrefixPort, pgIISPRouteAddrEntry=pgIISPRouteAddrEntry, PYSNMP_MODULE_ID=pgIISP, NetPrefix=NetPrefix, PgAtmPrefixLength=PgAtmPrefixLength, PgAtmAddrPrefix=PgAtmAddrPrefix, pgIISPRouteAddrIndexNext=pgIISPRouteAddrIndexNext, pgIISPNetPrefixRowStatus=pgIISPNetPrefixRowStatus, pgIISP=pgIISP, pgIISPRouteAddrOperStatus=pgIISPRouteAddrOperStatus, pgIISPNetPrefixIndex=pgIISPNetPrefixIndex, pgIISPAtmAddrPrefix=pgIISPAtmAddrPrefix, pgIISPRouteAddrType=pgIISPRouteAddrType, pgIISPRouteAddrRowStatus=pgIISPRouteAddrRowStatus, pgIISPRouteAddrAdminStatus=pgIISPRouteAddrAdminStatus)

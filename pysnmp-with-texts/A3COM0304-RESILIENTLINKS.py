#
# PySNMP MIB module A3COM0304-RESILIENTLINKS (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM0304-RESILIENTLINKS
# Produced by pysmi-0.3.4 at Wed May  1 11:09:03 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, ModuleIdentity, Counter64, IpAddress, MibIdentifier, Bits, NotificationType, ObjectIdentity, TimeTicks, Gauge32, Integer32, enterprises, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "Counter64", "IpAddress", "MibIdentifier", "Bits", "NotificationType", "ObjectIdentity", "TimeTicks", "Gauge32", "Integer32", "enterprises", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
a3Com = MibIdentifier((1, 3, 6, 1, 4, 1, 43))
generic = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10))
mrmResilience = MibIdentifier((1, 3, 6, 1, 4, 1, 43, 10, 15))
resTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 15, 1), )
if mibBuilder.loadTexts: resTable.setStatus('mandatory')
if mibBuilder.loadTexts: resTable.setDescription('')
resTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1), ).setIndexNames((0, "A3COM0304-RESILIENTLINKS", "resRepeater"), (0, "A3COM0304-RESILIENTLINKS", "resMainSlot"), (0, "A3COM0304-RESILIENTLINKS", "resMainPort"))
if mibBuilder.loadTexts: resTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: resTableEntry.setDescription("An device may be configured to contain a number of 'resilient pairs'. These are to point connections, e.g. UTP, that allow two repeaters/switches to be connected together in a resilient configuration. In such a configuration one of the two ports is nominated the 'main' port while the other is the 'standby' port. One of these two ports is enabled and is the current active port. The other is present in case of failure of the active port. Such a failure is detected by the device and a switch performed. In the case of repeaters, there are a couple of rules that must apply to a resilient pair definition before that definition becomes a valid resilient pair. Firstly both ports must be on the same repeater. Secondly the standby port must be configured to be 'disabled on boot'. That is it must recover from a power failure in a disabled state. This prevents loops in the network. There are two modes of operation. These are defined by the resPairMode object. See that object for a full description. Several tables control the resilient configuration for the device. This is the first. This is the main table and allows the creation and deletion of pairs and provides status control and information. The information in this table is indexed on the repeater number, the slot (or unit) and the port location of the main port. To create a new resilient pair simply write any writeable object indexed on the main port. This will create a new entry in the table which has the state invalid(1) (read resPairState). Having created the row, write to the other parameters specifying valid information. When all the parameters are valid and 'resPairModificationStatus' is set to 'stable(2)', then resPairState will become operational(2). In this state the pair will correctly operate as a resilient pair. If any of the attributes in the table change so that the pair in no linger valid this will be reflected in the resPortState parameter. To delete a resilient pair, write delete(2) to resPairAction.")
resRepeater = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resRepeater.setStatus('mandatory')
if mibBuilder.loadTexts: resRepeater.setDescription('A resilient pair must be attached to one of the repeaters in the chassis. This is part of the index value required to access this table.')
resMainSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resMainSlot.setDescription('This is the second key in the index to this table. This is the slot number of the main port in this pair.')
resMainPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainPort.setStatus('mandatory')
if mibBuilder.loadTexts: resMainPort.setDescription('This is the final, key used to index entries in this table. It is the port number of the main port in the pair.')
resMainState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("failed", 1), ("ok", 2), ("ok-and-active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resMainState.setStatus('mandatory')
if mibBuilder.loadTexts: resMainState.setDescription('Each port in a pair is constantly monitored for signs of failure. Failure information is used to automatically change the active port from main to standby or vice-versa. Each port may be in one of three states. Failed(1) indicates there is a loss of signal on this port. A port in this state cannot be active. Secondly ok(2). This state indicates that the port is capable of carrying traffic but is at the moment acting in the role of backup link. The other port in this pair will be in the Ok-and-active(3) state. Ok-and-active(3) means what it says, this port is capable of carrying traffic and is so doing at the time this parameter has been read.')
resStandbySlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resStandbySlot.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbySlot.setDescription('This is the slot number of the standby port for this pair.')
resStandbyPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resStandbyPort.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyPort.setDescription('This is the port number of the standby port.')
resStandbyState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("failed", 1), ("ok", 2), ("ok-and-active", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resStandbyState.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyState.setDescription('Each port in a pair is constantly monitored for signs of failure. Failure information is used to automatically change the active port from main to standby or vice-versa. Each port may be in one of three states. Failed(1) indicates there is a loss of signal on this port. A port in this state cannot be active. Secondly ok(2). This state indicates that the port is capable of carrying traffic but is at the moment acting in the role of backup link. The other port in this pair will be in the Ok-and-active(3) state. Ok-and-active(3) means what it says, this port is capable of carrying traffic and is so doing at the time this parameter has been read.')
resPairState = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("operational", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resPairState.setStatus('mandatory')
if mibBuilder.loadTexts: resPairState.setDescription('Each row in the table is in one of two states, invalid(1) or operational(2). If the state is invalid(1), the resilient pair represented by this row is not active. There are several reasons why this may be the case. Firstly during the row creation process, not all information necessary may have been provided. Secondly an operational pair may become invalid because the resilient pair rules are no longer met because of a change in the device configuration. If the parameters in the row are all valid then the pair becomes operational(2).')
resPairModificationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("under-modification", 1), ("stable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairModificationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: resPairModificationStatus.setDescription('This parameter must be set to under-modification(1) before any changes are made to an existing configuration. Changes are not applied until this parameter is set to stable. ')
resPairAction = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("create", 1), ("delete", 2), ("togglePort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairAction.setStatus('mandatory')
if mibBuilder.loadTexts: resPairAction.setDescription('This is object allows the state of a resilient pair to be modified. The create(1) operation configures the resilient port from this table entry. The delete(2) operation removes the resilient definitions from this table and terminates operation of resilience on this pair of ports. The togglePort(3) operation allows the current active port to be changed to the other port. This second operation will only take affect if the state of the currently non- active port is ok(2).')
resPairEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairEnable.setStatus('mandatory')
if mibBuilder.loadTexts: resPairEnable.setDescription('This parameter controls whether the resilient pair is enabled or not. In the disable(2) state , both ports of the resilient pair are disabled. The default value of this parameter is enable(1).')
resPairMode = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-switch-back", 1), ("switch-back-to-main", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairMode.setStatus('mandatory')
if mibBuilder.loadTexts: resPairMode.setDescription('This parameter controls the rules that determine the operation of the resilient pair. The value no-switch-back(1) means that both ports are treated equally. The value switch-back-to-main(2) means that when it is operational, precedence is always given to the main port. If the main port has been stable for 1 minute, then the pair will automatically switch the active port to main. The default value of this parameter is no-switch-back(1).')
resPairName = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resPairName.setStatus('mandatory')
if mibBuilder.loadTexts: resPairName.setDescription("The textual name of the interface. The value of this object should be the name of the interface as assigned by the local device and should be suitable for use in commands entered at the device's `console'. The default value of this parameter is a zero length string.")
resStandbyMapTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 15, 2), )
if mibBuilder.loadTexts: resStandbyMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyMapTable.setDescription('')
resStandbyMapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1), ).setIndexNames((0, "A3COM0304-RESILIENTLINKS", "resSbRepeater"), (0, "A3COM0304-RESILIENTLINKS", "resSbSlot"), (0, "A3COM0304-RESILIENTLINKS", "resSbPort"))
if mibBuilder.loadTexts: resStandbyMapTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: resStandbyMapTableEntry.setDescription('This table is read-only. If provides shortcut information to allow for the translation of a port number to a corresponding main port number. This value can then be used to access the main resilience table. Each resilient pair has two entries in this table, one for the main port and one for the standby port. The entry for the main port returns the same port, the entry for the standby port returns the corresponding main port.')
resSbRepeater = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbRepeater.setStatus('mandatory')
if mibBuilder.loadTexts: resSbRepeater.setDescription('The repeater index of the port being accessed. This is the first of three indices on this table.')
resSbSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resSbSlot.setDescription('Second index on this table.')
resSbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbPort.setStatus('mandatory')
if mibBuilder.loadTexts: resSbPort.setDescription('Third index on this table.')
resSbType = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("standby", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbType.setStatus('mandatory')
if mibBuilder.loadTexts: resSbType.setDescription('This attribute specifies whether the port indexed is a main or standby port in the resilient pair table. If the port is neither then there will not be a row in this table indexed for that port.')
resSbMainSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbMainSlot.setStatus('mandatory')
if mibBuilder.loadTexts: resSbMainSlot.setDescription("This is the slot number of the main port for the pair in which the indexed port participates. NOTE if the index port is the main port of a pair (resSbType is 'main') this value will be the same as the index.")
resSbMainPort = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 15, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: resSbMainPort.setStatus('mandatory')
if mibBuilder.loadTexts: resSbMainPort.setDescription("This is the port number of the main port for the pair in which the indexed port participates. NOTE if the index port is the main port of a pair (resSbType is 'main') this value will be the same as the index.")
resFlushTable = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 15, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resFlushTable.setStatus('mandatory')
if mibBuilder.loadTexts: resFlushTable.setDescription('This parameter causes all entries in the resilience table to be flushed. Flushing the resilience table does not affect the state of any of the resilient links or ports. Once the table has been flushed , NO resilient links are configured. This parameter is used to ensure that the resilient link table is empty , before new resilient links are configured.')
resResilienceSwitch = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,43)).setObjects(("A3COM0304-RESILIENTLINKS", "resMainState"), ("A3COM0304-RESILIENTLINKS", "resStandbyState"))
if mibBuilder.loadTexts: resResilienceSwitch.setDescription('This trap is generated when a change of state of one of the ports in a resilient pair results in a switch of active port, or when there was no active port and a port has now become active.')
resStateChange = NotificationType((1, 3, 6, 1, 4, 1, 43) + (0,44)).setObjects(("A3COM0304-RESILIENTLINKS", "resMainState"), ("A3COM0304-RESILIENTLINKS", "resStandbyState"))
if mibBuilder.loadTexts: resStateChange.setDescription('This trap is generated when a change of state of one of the ports in a resilient pair does not result in a switch of active port. If such a switch were to occur the resResilienceSwitch would be generated.')
mibBuilder.exportSymbols("A3COM0304-RESILIENTLINKS", resFlushTable=resFlushTable, resMainState=resMainState, resStandbyState=resStandbyState, resPairEnable=resPairEnable, resSbMainSlot=resSbMainSlot, resResilienceSwitch=resResilienceSwitch, resStandbyMapTableEntry=resStandbyMapTableEntry, a3Com=a3Com, resSbPort=resSbPort, resPairModificationStatus=resPairModificationStatus, resPairName=resPairName, resStandbySlot=resStandbySlot, resStandbyPort=resStandbyPort, generic=generic, resStateChange=resStateChange, mrmResilience=mrmResilience, resTableEntry=resTableEntry, resMainPort=resMainPort, resSbRepeater=resSbRepeater, resRepeater=resRepeater, resTable=resTable, resSbSlot=resSbSlot, resPairAction=resPairAction, resSbType=resSbType, resPairState=resPairState, resStandbyMapTable=resStandbyMapTable, resMainSlot=resMainSlot, resPairMode=resPairMode, resSbMainPort=resSbMainPort)

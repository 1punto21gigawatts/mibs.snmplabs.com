#
# PySNMP MIB module IPATM-IPMC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPATM-IPMC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:55:52 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
AtmAddr, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmAddr")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
ipAdEntAddr, = mibBuilder.importSymbols("IP-MIB", "ipAdEntAddr")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Unsigned32, Integer32, ObjectIdentity, IpAddress, ModuleIdentity, snmpModules, MibIdentifier, Counter64, iso, Gauge32, mib_2, Counter32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Unsigned32", "Integer32", "ObjectIdentity", "IpAddress", "ModuleIdentity", "snmpModules", "MibIdentifier", "Counter64", "iso", "Gauge32", "mib-2", "Counter32", "Bits")
TextualConvention, RowStatus, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "TruthValue", "DisplayString")
marsMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 57))
marsMIB.setRevisions(('1998-09-01 00:00', '1998-04-15 01:45',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: marsMIB.setRevisionsDescriptions(('Published as RFC 2417. Changes/fixes: - reroot this MIB from snmpModules to mib-2 to be consistent with location of other MIBs. - obsoletes RFC2366.', 'Initial version, published as RFC 2366',))
if mibBuilder.loadTexts: marsMIB.setLastUpdated('9809010000Z')
if mibBuilder.loadTexts: marsMIB.setOrganization('Internetworking Over NBMA (ion) Working Group')
if mibBuilder.loadTexts: marsMIB.setContactInfo(' Chris Chung (chihschung@aol.com) Independent Consultant Editor: Maria Greene Postal: Independent Contractor E-mail: maria@xedia.com ')
if mibBuilder.loadTexts: marsMIB.setDescription('This module defines a portion of the managed information base (MIB) for managing classical IP multicast address resolution server (MARS) and related entities as described in the RFC2022. This MIB is meant to be used in conjunction with the ATM-MIB (RFC1695), MIB-II (RFC1213), and optionally the IF-MIB (RFC1573). ')
marsClientObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 1))
marsClientTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 1), )
if mibBuilder.loadTexts: marsClientTable.setStatus('current')
if mibBuilder.loadTexts: marsClientTable.setDescription('The objects defined in this table are used for the management of MARS clients, ATM attached endpoints.')
marsClientEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 1, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"))
if mibBuilder.loadTexts: marsClientEntry.setStatus('current')
if mibBuilder.loadTexts: marsClientEntry.setDescription('Each entry contains a MARS client and its associated attributes. An entry in the marsClientTable has a corresponding entry in the ipAddrTable defined in RFC1213. Association between the ipAddrTable and the marsClientTable is made through the index, ipAdEntAddr.')
marsClientIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: marsClientIndex.setStatus('current')
if mibBuilder.loadTexts: marsClientIndex.setDescription('The auxiliary variable used to identify instances of the columnar objects in the MARS MarsClientTable.')
marsClientAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 2), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientAddr.setStatus('current')
if mibBuilder.loadTexts: marsClientAddr.setDescription('The ATM address associated with the ATM Client.')
marsClientDefaultMarsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 3), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientDefaultMarsAddr.setStatus('current')
if mibBuilder.loadTexts: marsClientDefaultMarsAddr.setDescription('The default MARS ATM address which is needed to setup the initial signalling path between a MARS client and its associated MARS.')
marsClientHsn = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientHsn.setStatus('current')
if mibBuilder.loadTexts: marsClientHsn.setDescription('The cluster membership own 32 bit Host Sequence Number. When a new cluster member starts up, it is initialized to zero. When the cluster member sends the MARS_JOIN to register, the HSN will be correctly set to the current cluster sequence number (CSN) when the Client receives the copy of its MARS_JOIN from the MARS. It is is used to track the MARS sequence number.')
marsClientRegistration = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notRegistered", 1), ("registering", 2), ("registered", 3), ("reRegisteringFault", 4), ("reRegisteringRedirMap", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRegistration.setStatus('current')
if mibBuilder.loadTexts: marsClientRegistration.setDescription("An indication with regards to the registration status of this client. The registration codes of 'notRegistered (1)', 'registered (2)', and registered (3) are self-explanatory. The 'reRegisteringFault (4)' indicates the client is in the process of re-registering with a MARS due to some fault conditions. The 'reRegisteringRedMap (5)' status code shows that client is re-registering because it has received a MARS_REDIRECT_MAP message and was told to register with a different MARS from the current MARS.")
marsClientCmi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientCmi.setStatus('current')
if mibBuilder.loadTexts: marsClientCmi.setDescription("16 bit Cluster member identifier (CMI) assigned by the MARS which uniquely identifies each endpoint attached to the cluster. The value becomes valid after the 'marsClientRegistration' is set to the value of 'registered (1)'.")
marsClientDefaultMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(9180)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientDefaultMtu.setStatus('current')
if mibBuilder.loadTexts: marsClientDefaultMtu.setDescription('The default maximum transmission unit (MTU) used for this cluster. Note that the actual size used for a VC between two members of the cluster may be negotiated during connection setup and may be different than this value. Default value = 9180 bytes.')
marsClientFailureTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientFailureTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientFailureTimer.setDescription('A timer used to flag the failure of last MARS_MULTI to arrive. Default value = 10 seconds (recommended).')
marsClientRetranDelayTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRetranDelayTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientRetranDelayTimer.setDescription('The delay timer for sending out new MARS_REQUEST for the group after the client learned that there is no other group in the cluster. The timer must be set between 5 and 10 seconds inclusive.')
marsClientRdmMulReqAddRetrTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRdmMulReqAddRetrTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientRdmMulReqAddRetrTimer.setDescription('The initial random L_MULTI_RQ/ADD retransmit timer which can be set between 5 and 10 seconds inclusive.')
marsClientRdmVcRevalidateTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRdmVcRevalidateTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientRdmVcRevalidateTimer.setDescription('The random time to set VC_revalidate flag. The timer value ranges between 1 and 10 seconds inclusive.')
marsClientJoinLeaveRetrInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 2147483647)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientJoinLeaveRetrInterval.setStatus('current')
if mibBuilder.loadTexts: marsClientJoinLeaveRetrInterval.setDescription('MARS_JOIN/LEAVE retransmit interval. The minimum and recommended values are 5 and 10 seconds, respectively.')
marsClientJoinLeaveRetrLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientJoinLeaveRetrLimit.setStatus('current')
if mibBuilder.loadTexts: marsClientJoinLeaveRetrLimit.setDescription('MARS_JOIN/LEAVE retransmit limit. The maximum value is 5.')
marsClientRegWithMarsRdmTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRegWithMarsRdmTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientRegWithMarsRdmTimer.setDescription('Random time to register with MARS.')
marsClientForceWaitTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientForceWaitTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientForceWaitTimer.setDescription('Force wait if MARS re-registration is looping. The minimum value is 1 minute.')
marsClientLmtToMissRedirMapTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientLmtToMissRedirMapTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientLmtToMissRedirMapTimer.setDescription('Timer limit for client to miss MARS_REDIRECT_MAPS.')
marsClientIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientIdleTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientIdleTimer.setDescription('The configurable inactivity timer associated with a client. When a VC is created at this client, it gets the idle timer value from this configurable timer. The minimum suggested value is 1 minute and the recommended default value is 20 minutes.')
marsClientRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsClientRowStatus.setDescription("The object is used to create, delete or modify a row in this table. A row cannot be made 'active' until instances of all corresponding columns in the row of this table are appropriately configured and until the agent has also created a corresponding row in the marsClientStatTable. When this object has a value of 'active', the following columnar objects can not be modified: marsClientDefaultMarsAddr, marsClientHsn, marsClientRegstration, marsClientCmi, marsClientDefaultMtu while other objects in this conceptual row can be modified irrespective of the value of this object. Deletion of this row is allowed regardless of whether or not a row in any associated tables (i.e., marsClientVcTable) still exists or is in use. Once this row is deleted, it is recommended that the agent or the SNMP management station (if possible) through the set command deletes any stale rows that are associated with this row.")
marsClientMcGrpTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 2), )
if mibBuilder.loadTexts: marsClientMcGrpTable.setStatus('current')
if mibBuilder.loadTexts: marsClientMcGrpTable.setDescription('This table contains a list of IP multicast group address blocks associated with a MARS client. Entries in this table are used by the client that needs to receive or transmit packets from/to the specified range of multicast addresses. Each row can be created or deleted via configuration.')
marsClientMcGrpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 2, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"), (0, "IPATM-IPMC-MIB", "marsClientMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsClientMcMaxGrpAddr"))
if mibBuilder.loadTexts: marsClientMcGrpEntry.setStatus('current')
if mibBuilder.loadTexts: marsClientMcGrpEntry.setDescription('Each entry represents a consecutive block of multicast group addresses.')
marsClientMcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: marsClientMcMinGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsClientMcMinGrpAddr.setDescription('Minimum multicast group address - the min and max multicast forms multi-group block. If the MinGrpAddr and MaxGrpAddr are the same, it indicates that this block contains a single group address.')
marsClientMcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 2, 1, 2), IpAddress())
if mibBuilder.loadTexts: marsClientMcMaxGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsClientMcMaxGrpAddr.setDescription('Maximum multicast group address - the min and max multicast forms a multi-group block. If the MinGrpAddr and MaxGrpAddr are the same, it indicates that this block contains a single group address.')
marsClientMcGrpRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientMcGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsClientMcGrpRowStatus.setDescription("The object is used to create or delete a row in this table. Since other objects in this row are not-accessible 'index-objects', the value of this object has no effect on whether those objects in this conceptual row can be modified.")
marsClientBackupMarsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 3), )
if mibBuilder.loadTexts: marsClientBackupMarsTable.setStatus('current')
if mibBuilder.loadTexts: marsClientBackupMarsTable.setDescription('This table contains a list of backup MARS addresses that a client can connect to in case of failure for connecting to the primary server. The list of addresses is in descending order of preference. It should be noted that the backup list provided by the MARS to the client via the MARS_REDIRECT_MAP message has a higher preference than addresses that are manually configured into the client. When such a list is received from the MARS, this information should be inserted at the top of the list. Each row can be created or deleted via configuration.')
marsClientBackupMarsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 3, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"), (0, "IPATM-IPMC-MIB", "marsClientBackupMarsPriority"), (0, "IPATM-IPMC-MIB", "marsClientBackupMarsAddr"))
if mibBuilder.loadTexts: marsClientBackupMarsEntry.setStatus('current')
if mibBuilder.loadTexts: marsClientBackupMarsEntry.setDescription('Each entry represents an ATM address of a backup MARS.')
marsClientBackupMarsPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: marsClientBackupMarsPriority.setStatus('current')
if mibBuilder.loadTexts: marsClientBackupMarsPriority.setDescription('The priority associated with a backup MARS. A lower priority value inidcates a higher preference.')
marsClientBackupMarsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 3, 1, 2), AtmAddr())
if mibBuilder.loadTexts: marsClientBackupMarsAddr.setStatus('current')
if mibBuilder.loadTexts: marsClientBackupMarsAddr.setDescription('The ATM address associated with a backup MARS.')
marsClientBackupMarsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientBackupMarsRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsClientBackupMarsRowStatus.setDescription("The object is used to create or delete a row in this table. Since other objects in this row are not-accessible 'index-objects', the value of this object has no effect on whether those objects in this conceptual row can be modified.")
marsClientVcTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 4), )
if mibBuilder.loadTexts: marsClientVcTable.setStatus('current')
if mibBuilder.loadTexts: marsClientVcTable.setDescription('This table contains information about open virtual circuits (VCs) that a client has. For point to point circuit, each entry represents a single VC connection between this client ATM address to another party ATM address. In the case of point to multipoint connection where a single source address is associated with multiple destinations, several entries are used to represent the relationship. An example of point to multi-point VC represented in a table is shown below. Client VPI/VCI Grp Addr1/Addr2 Part Addr 1 0,1 g1,g2 p1 1 0,1 g1,g2 p2 1 0,1 g1,g2 p3 Note: This table assumes the IP multicast address groups (min, max) defined in each entry are always consecutive. In the case of that a client receives a JOIN/LEAVE with mars$flag.punched set, each pair of the IP groups will first be broken into several pairs of consecutive IP groups before each entry row corresponding to a pair of IP group is created.')
marsClientVcEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 4, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"), (0, "IPATM-IPMC-MIB", "marsClientVcVpi"), (0, "IPATM-IPMC-MIB", "marsClientVcVci"), (0, "IPATM-IPMC-MIB", "marsClientVcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsClientVcMaxGrpAddr"), (0, "IPATM-IPMC-MIB", "marsClientVcPartyAddr"))
if mibBuilder.loadTexts: marsClientVcEntry.setStatus('current')
if mibBuilder.loadTexts: marsClientVcEntry.setDescription('The objects contained in the entry are VC related attributes such as VC signalling type, control VC type, idle timer, negotiated MTU size, etc.')
marsClientVcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: marsClientVcVpi.setStatus('current')
if mibBuilder.loadTexts: marsClientVcVpi.setDescription('The value of virtual path identifier (VPI). Since a VPI can be numbered 0, this sub-index can take a value of 0.')
marsClientVcVci = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: marsClientVcVci.setStatus('current')
if mibBuilder.loadTexts: marsClientVcVci.setDescription('The value of virtual circuit identifier (VCI). Since a VCI can be numbered 0, this sub-index can take a value of 0.')
marsClientVcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 3), IpAddress())
if mibBuilder.loadTexts: marsClientVcMinGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsClientVcMinGrpAddr.setDescription('Minimum IP multicast group address - the min and max multicast forms a multi-group consecutive block which is associated with a table entry. if the MinGrpAddr and MaxGrpAddr are the same, it indicates that the size of multi-group block is 1, a single IP group.')
marsClientVcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 4), IpAddress())
if mibBuilder.loadTexts: marsClientVcMaxGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsClientVcMaxGrpAddr.setDescription('Maximum IP multicast group address - the min and max multicast forms a multi-group consecutive block which is associated with a table entry. if the MinGrpAddr and MaxGrpAddr are the same, it indicates that the size of multi-group block is 1, a single IP group.')
marsClientVcPartyAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 5), AtmAddr())
if mibBuilder.loadTexts: marsClientVcPartyAddr.setStatus('current')
if mibBuilder.loadTexts: marsClientVcPartyAddr.setDescription('An ATM party address in which this VC is linked. The party type is identified by the marsClientVcPartyAddrType.')
marsClientVcPartyAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("called", 1), ("calling", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcPartyAddrType.setStatus('current')
if mibBuilder.loadTexts: marsClientVcPartyAddrType.setDescription("The party type is associated with the party address. The 'called (1)' indicates that the party address is a destination address which implies that VC is originated from this client. The 'calling (2)' indicates the VC was initiated externally to this client. In this case, the party address is the source address.")
marsClientVcType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcType.setStatus('current')
if mibBuilder.loadTexts: marsClientVcType.setDescription('Circuit Connection type: permanent virtual circuit or switched virtual circuit.')
marsClientVcCtrlType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pointToPointVC", 1), ("clusterControlVC", 2), ("pointToMultiPointVC", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcCtrlType.setStatus('current')
if mibBuilder.loadTexts: marsClientVcCtrlType.setDescription('Control VC type used to specify a particular connection. pointToPointVC (1): used by the ATM Clients for the registration and queries. This VC or the initial signalling path is set up from the source Client to a MARS. It is bi-directional. clusterControlVC (2): used by a MARS to issue asynchronous updates to an ATM Client. This VC is established from the MARS to the ATM Client. pointToMultiPointVC (3): used by the client to transfer multicast data packets from layer 3. This VC is established from the source ATM Client to a destination ATM endpoint which can be a multicast group member or an MCS. The destination endpoint was obtained from the MARS.')
marsClientVcIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcIdleTimer.setStatus('current')
if mibBuilder.loadTexts: marsClientVcIdleTimer.setDescription('The idle timer associated with this VC. The minimum suggested value is 1 minute and the recommended default value is 20 minutes.')
marsClientVcRevalidate = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcRevalidate.setStatus('current')
if mibBuilder.loadTexts: marsClientVcRevalidate.setDescription('A flag associated with an open and active multipoint VC. It is checked every time a packet is queued for transmission on that VC. The object has the value of true (1) if revalidate is required and the value false (2) otherwise.')
marsClientVcEncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("llcSnap", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcEncapsType.setStatus('current')
if mibBuilder.loadTexts: marsClientVcEncapsType.setDescription('The encapsulation type used when communicating over this VC.')
marsClientVcNegotiatedMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcNegotiatedMtu.setStatus('current')
if mibBuilder.loadTexts: marsClientVcNegotiatedMtu.setDescription('The negotiated MTU when communicating over this VC.')
marsClientVcRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 4, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsClientVcRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsClientVcRowStatus.setDescription("The object is used to create, delete or modify a row in this table. A row cannot be made 'active' until instances of all corresponding columns in the row of this table are appropriately configured. While objects: marsClientVcIdleTimer and marsClientVcRevalidate in this conceptual row can be modified irrespective of the value of this object, all other objects in the row can not be modified when this object has a value of 'active'. It is possible for an SNMP management station to set the row to 'notInService' and modify the entry and then set it back to 'active' with the following exception. That is, rows for which the corresponding instance of marsClientVcType has a value of 'svc' can not be modified or deleted.")
marsClientStatTable = MibTable((1, 3, 6, 1, 2, 1, 57, 1, 5), )
if mibBuilder.loadTexts: marsClientStatTable.setStatus('current')
if mibBuilder.loadTexts: marsClientStatTable.setDescription('The table contains statistics collected at MARS clients.')
marsClientStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 1, 5, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"), (0, "IPATM-IPMC-MIB", "marsClientIndex"))
if mibBuilder.loadTexts: marsClientStatEntry.setStatus('current')
if mibBuilder.loadTexts: marsClientStatEntry.setDescription('Each entry contains statistics collected at one MARS client.')
marsClientStatTxReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatTxReqMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatTxReqMsgs.setDescription('Total number of MARS_REQUEST messages transmitted from a client.')
marsClientStatTxJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatTxJoinMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatTxJoinMsgs.setDescription('Total number of MARS_JOIN messages transmitted from a client.')
marsClientStatTxLeaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatTxLeaveMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatTxLeaveMsgs.setDescription('Total number of MARS_LEAVE messages transmitted from a client.')
marsClientStatTxGrpLstReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatTxGrpLstReqMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatTxGrpLstReqMsgs.setDescription('Total number of MARS_GROUPLIST_REQUEST messages transmitted from a client.')
marsClientStatRxJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxJoinMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatRxJoinMsgs.setDescription('Total number of MARS_JOIN messages received by a client.')
marsClientStatRxLeaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxLeaveMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatRxLeaveMsgs.setDescription('Total number of MARS_LEAVE messages received by a client.')
marsClientStatRxMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxMultiMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatRxMultiMsgs.setDescription('Total number of MARS_MULTI messages received by a client.')
marsClientStatRxNakMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxNakMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatRxNakMsgs.setDescription('Total number of MARS_NAK messages received by a client.')
marsClientStatRxMigrateMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxMigrateMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatRxMigrateMsgs.setDescription('Total number of MARS_MIGRATE messages received by a client.')
marsClientStatRxGrpLstRplyMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatRxGrpLstRplyMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatRxGrpLstRplyMsgs.setDescription('Total number of MARS_GROUPLIST_REPLY messages received by a client.')
marsClientStatFailMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 1, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsClientStatFailMultiMsgs.setStatus('current')
if mibBuilder.loadTexts: marsClientStatFailMultiMsgs.setDescription('Total number of timeouts occurred indicating failure of the last MARS_MULTI to arrive.')
marsObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 2))
marsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 1), )
if mibBuilder.loadTexts: marsTable.setStatus('current')
if mibBuilder.loadTexts: marsTable.setDescription('The objects defined in this table are used for the management of MARS servers.')
marsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 1, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"))
if mibBuilder.loadTexts: marsEntry.setStatus('current')
if mibBuilder.loadTexts: marsEntry.setDescription('Each entry contains a MARS and its associated attributes.')
marsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: marsIndex.setStatus('current')
if mibBuilder.loadTexts: marsIndex.setDescription('The auxiliary variable used to identify instances of the columnar objects in the MARS table.')
marsIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: marsIfIndex.setStatus('current')
if mibBuilder.loadTexts: marsIfIndex.setDescription('The ifIndex of the interface that the MARS is associated with.')
marsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 3), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsAddr.setStatus('current')
if mibBuilder.loadTexts: marsAddr.setDescription('The ATM address associated with the MARS.')
marsLocal = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 4), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsLocal.setStatus('current')
if mibBuilder.loadTexts: marsLocal.setDescription('A flag associated with a MARS entry. The object has the value of true (1) if the MARS whose interface is local to the machine that implements this MIB; otherwise the object has the value of false (2).')
marsServStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("faulted", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServStatus.setStatus('current')
if mibBuilder.loadTexts: marsServStatus.setDescription('The current status of MARS.')
marsServType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("backup", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServType.setStatus('current')
if mibBuilder.loadTexts: marsServType.setDescription('Types of MARS servers: primary or backup.')
marsServPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServPriority.setStatus('current')
if mibBuilder.loadTexts: marsServPriority.setDescription('Priority associated with a backup MARS server. A backup MARS server with lower priority value indicates a higher preference than other backup MARS servers to be used as the MARS server when the primary server fails.')
marsRedirMapMsgTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)).clone(1)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsRedirMapMsgTimer.setStatus('current')
if mibBuilder.loadTexts: marsRedirMapMsgTimer.setDescription('Periodic interval on which a multi-part MARS_REDIRECT_MAP is sent from this MARS.')
marsCsn = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsCsn.setStatus('current')
if mibBuilder.loadTexts: marsCsn.setDescription('Current cluster sequence number (CSN) which is global within the context of a given protocol. The CSN is incremented by the MARS on every transmission of a message on ClusterControlVC. A cluster member uses the CSN to track the message loss on ClusterControlVC or to monitor a membership change.')
marsSsn = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsSsn.setStatus('current')
if mibBuilder.loadTexts: marsSsn.setDescription('Current server sequence number (SSN) which is global within the context of a given protocol. The SSN is incremented by the MARS on every transmission of a message on ServerControlVC. A MCS uses the SSN to track the message loss on ServerControlVC or to monitor a membership change.')
marsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsRowStatus.setDescription("The object is used to create, delete or modify a row in this table. A row cannot be made 'active' until instances of all corresponding columns in the row of this table are appropriately configured and until the agent has also created a corresponding row in the marsStatTable. When this object has a value of 'active', the following columnar objects can not be modified: marsAddr, marsAddrLocal, marsServStatus, marsServType, marsCsn, marsSsn while other objects in this conceptual row can be modified irrespective of the value of this object. Deletion of this row is allowed regardless of whether or not a row in any associated tables (i.e., marsVcTable) still exists or is in use. Once this row is deleted, it is recommended that the agent or the SNMP management station (if possible) through the set command deletes any stale rows that are associated with this row.")
marsMcGrpTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 2), )
if mibBuilder.loadTexts: marsMcGrpTable.setStatus('current')
if mibBuilder.loadTexts: marsMcGrpTable.setDescription('This table contains a list of IP multicast address blocks associated with a MARS. Entries in this table are used by the MARS host map table and the server map table. They should be created prior to being referenced as indices by those tables. Each row can be created or deleted via configuration.')
marsMcGrpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 2, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcMaxGrpAddr"))
if mibBuilder.loadTexts: marsMcGrpEntry.setStatus('current')
if mibBuilder.loadTexts: marsMcGrpEntry.setDescription('Each entry represents a consecutive block of multicast group addresses.')
marsMcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: marsMcMinGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcMinGrpAddr.setDescription('Minimum multicast group address - the min and max multicast forms multi-group block. If the MinGrpAddr and MaxGrpAddr are the same, it indicates that this block contains a single group address.')
marsMcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 2), IpAddress())
if mibBuilder.loadTexts: marsMcMaxGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcMaxGrpAddr.setDescription('Maximum multicast group address - the min and max multicast forms a multi-group block. If The MinGrpAddr and MaxGrpAddr are the same, it indicates that this block contains a single group address.')
marsMcGrpAddrUsage = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("hostMap", 1), ("serverMap", 2), ("hostServerMap", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcGrpAddrUsage.setStatus('current')
if mibBuilder.loadTexts: marsMcGrpAddrUsage.setDescription('Usage of the multicast address block. The hostMap (1) indicates that the address block is only used in the MARS host map table. The serverMap (2) indicates that the address block is only used in the MARS server map table. The hostServerMap (3) indicates that the address block is used in both the host map and the server map tables.')
marsMcGrpRxLayer3GrpSets = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcGrpRxLayer3GrpSets.setStatus('current')
if mibBuilder.loadTexts: marsMcGrpRxLayer3GrpSets.setDescription('Number of MARS_JOIN messages received with mars$flags.layer3grp flag set.')
marsMcGrpRxLayer3GrpResets = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcGrpRxLayer3GrpResets.setStatus('current')
if mibBuilder.loadTexts: marsMcGrpRxLayer3GrpResets.setDescription('Number of MARS_JOIN messages received with mars$flags.layer3grp flag reset.')
marsMcGrpRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsMcGrpRowStatus.setDescription('The object is used to create, delete or modify a row in this table. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
marsHostMapTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 3), )
if mibBuilder.loadTexts: marsHostMapTable.setStatus('current')
if mibBuilder.loadTexts: marsHostMapTable.setDescription('This table caches mappings between IP multicast address to a list of ATM addresses that are configured or dynamically learned from the MARS. This address resolution is used for the host map. It supports the mapping of a block of multicast group addresses to a cluster member address. In the case where a group block is associated with multiple cluster members, several entries are used to representing the relationship.')
marsHostMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 3, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcMaxGrpAddr"), (0, "IPATM-IPMC-MIB", "marsHostMapAtmAddr"))
if mibBuilder.loadTexts: marsHostMapEntry.setStatus('current')
if mibBuilder.loadTexts: marsHostMapEntry.setDescription('Each entry row contains attributes associated with the mapping between a multicast group block and an ATM address.')
marsHostMapAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 3, 1, 1), AtmAddr())
if mibBuilder.loadTexts: marsHostMapAtmAddr.setStatus('current')
if mibBuilder.loadTexts: marsHostMapAtmAddr.setDescription('The mapped cluster member ATM address.')
marsHostMapRowType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsHostMapRowType.setStatus('current')
if mibBuilder.loadTexts: marsHostMapRowType.setDescription('Method in which this entry row is created. The static (1) indicates that this row is created through configuration. The dynamic (2) indicates that the row is created as the result of group address updates received at this MARS.')
marsHostMapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsHostMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsHostMapRowStatus.setDescription("The object is used to create, delete or modify a row in this table. This object must not be set to 'active' until instances of all corresponding columns in the row of this table are appropriately configured. It is possible for an SNMP management station to set the row to 'notInService' and modify the entry and then set it back to 'active' with the following exception. That is, rows for which the corresponding instance of marsHostMapRowType has a value of 'dynamic' can not be modified or deleted.")
marsServerMapTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 4), )
if mibBuilder.loadTexts: marsServerMapTable.setStatus('current')
if mibBuilder.loadTexts: marsServerMapTable.setDescription('This table caches mappings between IP multicast address to a list of MCS ATM addresses that are configured or dynamically learned from the MARS. This address resolution is used for the server map. It supports the mapping of a block of multicast group addresses to a MCS address. In the case where a group block is associated with multiple MCSs, several entries are used to representing the relationship.')
marsServerMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 4, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcMaxGrpAddr"), (0, "IPATM-IPMC-MIB", "marsServerMapAtmAddr"))
if mibBuilder.loadTexts: marsServerMapEntry.setStatus('current')
if mibBuilder.loadTexts: marsServerMapEntry.setDescription('Each entry row contains attributes associated with the mapping between a multicast group block and an MCS address.')
marsServerMapAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 4, 1, 1), AtmAddr())
if mibBuilder.loadTexts: marsServerMapAtmAddr.setStatus('current')
if mibBuilder.loadTexts: marsServerMapAtmAddr.setDescription('The mapped MCS ATM address.')
marsServerMapRowType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServerMapRowType.setStatus('current')
if mibBuilder.loadTexts: marsServerMapRowType.setDescription("Method in which this entry row is created. The 'static (1)' indicates that this row is created through configuration. The 'dynamic (2)' indicates that the row is created as the result of group address updates received at this MARS.")
marsServerMapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsServerMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsServerMapRowStatus.setDescription("The object is used to create, delete or modify a row in this table. This object must not be set to 'active' until instances of all corresponding columns in the row of this table are appropriately configured. It is possible for an SNMP management station to set the row to 'notInService' and modify the entry and then set it back to 'active' with the following exception. That is, rows for which the corresponding instance of marsServerMapRowType has a value of 'dynamic' can not be modified or deleted.")
marsVcTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 5), )
if mibBuilder.loadTexts: marsVcTable.setStatus('current')
if mibBuilder.loadTexts: marsVcTable.setDescription("This table contains information about open virtual circuits (VCs) that a MARS has. For point to point circuit, each entry represents a single VC connection between this MARS ATM address to another party's ATM address. In the case of point to multipoint connection where a ControlVc is attached with multiple leaf nodes, several entries are used to represent the relationship. An example of point to multi-point VC represented in a table is shown below. MARS VPI/VCI MARS Addr Party Addr 1 0,1 m1 p1 1 0,1 m1 p2 1 0,1 m1 p3")
marsVcEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 5, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsVcVpi"), (0, "IPATM-IPMC-MIB", "marsVcVci"), (0, "IPATM-IPMC-MIB", "marsVcPartyAddr"))
if mibBuilder.loadTexts: marsVcEntry.setStatus('current')
if mibBuilder.loadTexts: marsVcEntry.setDescription('The objects contained in the entry are VC related attributes such as VC signalling type, control VC type, idle timer, negotiated MTU size, etc.')
marsVcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: marsVcVpi.setStatus('current')
if mibBuilder.loadTexts: marsVcVpi.setDescription('The value of virtual path identifier (VPI). Since a VPI can be numbered 0, this sub-index can take a value of 0.')
marsVcVci = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: marsVcVci.setStatus('current')
if mibBuilder.loadTexts: marsVcVci.setDescription('The value of virtual circuit identifier (VCI). Since a VCI can be numbered 0, this sub-index can take a value of 0.')
marsVcPartyAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 5), AtmAddr())
if mibBuilder.loadTexts: marsVcPartyAddr.setStatus('current')
if mibBuilder.loadTexts: marsVcPartyAddr.setDescription('An ATM party address in which this VC is linked. The party type is identified by the marsVcPartyAddrType.')
marsVcPartyAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("called", 1), ("calling", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcPartyAddrType.setStatus('current')
if mibBuilder.loadTexts: marsVcPartyAddrType.setDescription("The party type is associated with the party address. The 'called (1)' indicates that the party address is a destination address which implies that VC is originated from this MARS. The 'calling (2)' indicates the VC was initiated externally to this MARS. The party address is the source address.")
marsVcType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcType.setStatus('current')
if mibBuilder.loadTexts: marsVcType.setDescription('Circuit Connection type: permanent virtual circuit or switched virtual circuit.')
marsVcCtrlType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pointToPointVC", 1), ("clusterControlVC", 2), ("serverControlVC", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcCtrlType.setStatus('current')
if mibBuilder.loadTexts: marsVcCtrlType.setDescription('Control VC type used to specify a particular connection. pointToPointVC (1): used by the ATM endpoints (clients) or the MCS for registration and queries. This VC is set up from a MARS client and MCS to this MARS. It is a bi-directional VC. clusterControlVC (2): used by MARS to issue asynchronous updates to ATM an ATM client. This VC is established from the MARs to the ATM client. serverControlVC (3): used by MARS to issue asynchronous update to ATM multicast servers. This type of VC exists when at least a MCS is being used.')
marsVcIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcIdleTimer.setStatus('current')
if mibBuilder.loadTexts: marsVcIdleTimer.setDescription('The idle timer associated with this VC. The minimum suggested value is 1 minute and the recommended default value is 20 minutes.')
marsVcCmi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcCmi.setStatus('current')
if mibBuilder.loadTexts: marsVcCmi.setDescription("Cluster member identifier (CMI) which uniquely identifies each endpoint attached to the cluster. This variable applies to each 'leaf node' of an outgoing control VC.")
marsVcEncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("llcSnap", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcEncapsType.setStatus('current')
if mibBuilder.loadTexts: marsVcEncapsType.setDescription('The encapsulation type used when communicating over this VC.')
marsVcNegotiatedMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcNegotiatedMtu.setStatus('current')
if mibBuilder.loadTexts: marsVcNegotiatedMtu.setDescription('The negotiated MTU when communicating over this VC.')
marsVcRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 5, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsVcRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsVcRowStatus.setDescription("The object is used to create, delete or modify a row in this table. A row cannot be made 'active' until instances of all corresponding columns in the row of this table are appropriately configured. While the marsVcIdleTimer in this conceptual row can be modified irrespective of the value of this object, all other objects in the row can not be modified when this object has a value of 'active'. It is possible for an SNMP management station to set the row to 'notInService' and modify the entry and then set it back to 'active' with the following exception. That is, rows for which the corresponding instance of marsVcType has a value of 'svc' can not be modified or deleted.")
marsRegClientTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 6), )
if mibBuilder.loadTexts: marsRegClientTable.setStatus('current')
if mibBuilder.loadTexts: marsRegClientTable.setDescription('This table contains ATM identities of all the currently registered cluster members at a MARS. Each entry represents one set of ATM identities associated with one cluster member or the MARS client.')
marsRegClientEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 6, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsRegClientCmi"))
if mibBuilder.loadTexts: marsRegClientEntry.setStatus('current')
if mibBuilder.loadTexts: marsRegClientEntry.setDescription('Each entry row contains attributes associated with one register cluster member.')
marsRegClientCmi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: marsRegClientCmi.setStatus('current')
if mibBuilder.loadTexts: marsRegClientCmi.setDescription('This cluster member identifier is used as an auxiliary index for the entry in this table.')
marsRegClientAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 6, 1, 2), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsRegClientAtmAddr.setStatus('current')
if mibBuilder.loadTexts: marsRegClientAtmAddr.setDescription("The registered client's ATM address.")
marsRegMcsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 7), )
if mibBuilder.loadTexts: marsRegMcsTable.setStatus('current')
if mibBuilder.loadTexts: marsRegMcsTable.setDescription('This table contains ATM identities of all the currently registered MCSs at a MARS. Each entry represents one set of ATM identities associated with one MCS.')
marsRegMcsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 7, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"), (0, "IPATM-IPMC-MIB", "marsRegMcsAtmAddr"))
if mibBuilder.loadTexts: marsRegMcsEntry.setStatus('current')
if mibBuilder.loadTexts: marsRegMcsEntry.setDescription('Each entry row contains attributes associated with one registered MCS.')
marsRegMcsAtmAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 7, 1, 1), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsRegMcsAtmAddr.setStatus('current')
if mibBuilder.loadTexts: marsRegMcsAtmAddr.setDescription("The registered MCS's ATM address.")
marsStatTable = MibTable((1, 3, 6, 1, 2, 1, 57, 2, 8), )
if mibBuilder.loadTexts: marsStatTable.setStatus('current')
if mibBuilder.loadTexts: marsStatTable.setDescription('The table contains statistics collected at MARS.')
marsStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 2, 8, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsIndex"), (0, "IPATM-IPMC-MIB", "marsIfIndex"))
if mibBuilder.loadTexts: marsStatEntry.setStatus('current')
if mibBuilder.loadTexts: marsStatEntry.setDescription('Each entry contains statistics collected at one MARS.')
marsStatTxMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxMultiMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxMultiMsgs.setDescription('Total number of MARS_MULTI transmitted by this MARS.')
marsStatTxGrpLstRplyMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxGrpLstRplyMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxGrpLstRplyMsgs.setDescription('Total number of MARS_GROUPLIST_REPLY messages transmitted by this MARS.')
marsStatTxRedirectMapMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxRedirectMapMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxRedirectMapMsgs.setDescription('Total number of MARS_REDIRECT_MAP messages transmitted by this MARS.')
marsStatTxMigrateMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxMigrateMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxMigrateMsgs.setDescription('Total number of MARS_MIGRATE messages transmitted by this MARS.')
marsStatTxNakMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxNakMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxNakMsgs.setDescription('Total number of MARS_NAK messages transmitted by this MARS.')
marsStatTxJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxJoinMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxJoinMsgs.setDescription('Total number of MARS_JOIN messages transmitted by this MARS.')
marsStatTxLeaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxLeaveMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxLeaveMsgs.setDescription('Total number of MARS_LEAVE messages transmitted by this MARS.')
marsStatTxSjoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxSjoinMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxSjoinMsgs.setDescription('Total number of MARS_SJOIN messages transmitted by this MARS.')
marsStatTxSleaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxSleaveMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxSleaveMsgs.setDescription('Total number of MARS_SLEAVE messages transmitted by this MARS.')
marsStatTxMservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxMservMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxMservMsgs.setDescription('Total number of MARS_MSERV messages transmitted by this MARS.')
marsStatTxUnservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatTxUnservMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatTxUnservMsgs.setDescription('Total number of MARS_UNSERV messages transmitted by this MARS.')
marsStatRxReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxReqMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatRxReqMsgs.setDescription('Total number of MARS_REQUEST messages received by this MARS.')
marsStatRxGrpLstReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxGrpLstReqMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatRxGrpLstReqMsgs.setDescription('Total number of MARS_GROUPLIST_REQUEST messages received by this MARS.')
marsStatRxJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxJoinMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatRxJoinMsgs.setDescription('Total number of MARS_JOINS messages received by this MARS.')
marsStatRxLeaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxLeaveMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatRxLeaveMsgs.setDescription('Total number of MARS_LEAVES messages received by this MARS.')
marsStatRxMservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxMservMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatRxMservMsgs.setDescription('Total number of MARS_MSERV messages received by this MARS.')
marsStatRxUnservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxUnservMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatRxUnservMsgs.setDescription('Total number of MARS_UNSERV messages received by this MARS.')
marsStatRxBlkJoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRxBlkJoinMsgs.setStatus('current')
if mibBuilder.loadTexts: marsStatRxBlkJoinMsgs.setDescription('Total number of block joins messages received by this MARS.')
marsStatRegMemGroups = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRegMemGroups.setStatus('current')
if mibBuilder.loadTexts: marsStatRegMemGroups.setDescription('Total number of IP multicast groups with 1 or more joined cluster members.')
marsStatRegMcsGroups = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 2, 8, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsStatRegMcsGroups.setStatus('current')
if mibBuilder.loadTexts: marsStatRegMcsGroups.setDescription('Total number of IP multicast groups with 1 or more joined MCSs.')
marsMcsObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 3))
marsMcsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 1), )
if mibBuilder.loadTexts: marsMcsTable.setStatus('current')
if mibBuilder.loadTexts: marsMcsTable.setDescription('The objects defined in this table are used for the management of a multicast server (MCS).')
marsMcsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 1, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"))
if mibBuilder.loadTexts: marsMcsEntry.setStatus('current')
if mibBuilder.loadTexts: marsMcsEntry.setDescription('Each entry contains a MCS and its associated attributes.')
marsMcsIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: marsMcsIndex.setStatus('current')
if mibBuilder.loadTexts: marsMcsIndex.setDescription('The auxiliary variable used to identify instances of the columnar objects in the MCS table.')
marsMcsIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: marsMcsIfIndex.setStatus('current')
if mibBuilder.loadTexts: marsMcsIfIndex.setDescription('The ifIndex of the interface that the MCS is associated with.')
marsMcsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 3), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcsAddr.setDescription('The ATM address associated with the MCS.')
marsMcsDefaultMarsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 4), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsDefaultMarsAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcsDefaultMarsAddr.setDescription('The default MARS ATM address which is needed to setup the initial signalling path between a MCS and its associated MARS.')
marsMcsRegistration = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notRegistered", 1), ("registering", 2), ("registered", 3), ("reRegisteringFault", 4), ("reRegisteringRedirMap", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRegistration.setStatus('current')
if mibBuilder.loadTexts: marsMcsRegistration.setDescription("An indication with regards to the registration STATUS of this MCS. The registration codes of 'notRegistered (1)', 'registered (2)', and registered (3) are self-explanatory. The 'reRegisteringFault (4)' indicates the MCS is in the process of re-registering with a MARS due to some fault conditions. The 'reRegisteringRedMap (5)' status code shows that MCS is re-registering because it has received a MARS_REDIRECT_MAP message and was told to register with a shift MARS.")
marsMcsSsn = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsSsn.setStatus('current')
if mibBuilder.loadTexts: marsMcsSsn.setDescription('The MCS own 32 bit Server Sequence Number. It is used to track the Mars sequence number.')
marsMcsDefaultMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(9180)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsDefaultMtu.setStatus('current')
if mibBuilder.loadTexts: marsMcsDefaultMtu.setDescription('The default maximum transmission unit (MTU) used for this cluster. Note that the actual size used for a VC between two members of the cluster may be negotiated during connection setup and may be different than this value. Default value = 9180 bytes.')
marsMcsFailureTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsFailureTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsFailureTimer.setDescription('A timer used to flag the failure of last MARS_MULTI to arrive. Default value = 10 seconds (recommended).')
marsMcsRetranDelayTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRetranDelayTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsRetranDelayTimer.setDescription('The delay timer for sending out new MARS_REQUEST for the group after the MCS learned that there is no other group in the cluster. The timer must be set between 5 and 10 seconds inclusive.')
marsMcsRdmMulReqAddRetrTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRdmMulReqAddRetrTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsRdmMulReqAddRetrTimer.setDescription('The initial random L_MULTI_RQ/ADD retransmit timer which can be set between 5 and 10 seconds inclusive.')
marsMcsRdmVcRevalidateTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRdmVcRevalidateTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsRdmVcRevalidateTimer.setDescription('The random time to set VC_revalidate flag. The timer value ranges between 1 and 10 seconds inclusive.')
marsMcsRegisterRetrInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 2147483647)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRegisterRetrInterval.setStatus('current')
if mibBuilder.loadTexts: marsMcsRegisterRetrInterval.setDescription('MARS_MSERV/UNSERV retransmit interval. The minimum and recommended values are 5 and 10 seconds, respectively.')
marsMcsRegisterRetrLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRegisterRetrLimit.setStatus('current')
if mibBuilder.loadTexts: marsMcsRegisterRetrLimit.setDescription('MARS_MSERV/UNSERV retransmit limit. The maximum value is 5.')
marsMcsRegWithMarsRdmTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRegWithMarsRdmTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsRegWithMarsRdmTimer.setDescription('Random time for a MCS to register with a MARS.')
marsMcsForceWaitTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsForceWaitTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsForceWaitTimer.setDescription('Force wait if MARS re-registration is looping. The minimum value is 1 minute.')
marsMcsLmtToMissRedirMapTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsLmtToMissRedirMapTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsLmtToMissRedirMapTimer.setDescription('Timer limit for MCS to miss MARS_REDIRECT_MAPS.')
marsMcsIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsIdleTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsIdleTimer.setDescription('The configurable inactivity timer associated with a MCS. When a VC is created at this MCS, it gets the idle timer value from this configurable timer. The minimum suggested value is 1 minute and the recommended default value is 20 minutes.')
marsMcsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsMcsRowStatus.setDescription("The object is used to create, delete or modify a row in this table. A row cannot be made 'active' until instances of all corresponding columns in the row of this table are appropriately configured and until the agent has also created a corresponding row in the marsMcsStatTable. When this object has a value of 'active', the following columnar objects can not be modified: marsMcsDefaultMarsAddr, marsMcsSsn, marsMcsRegstration, marsMcsDefaultMtu while other objects in this conceptual row can be modified irrespective of the value of this object. Deletion of this row is allowed regardless of whether or not a row in any associated tables (i.e., marsMcsVcTable) still exists or is in use. Once this row is deleted, it is recommended that the agent or the SNMP management station (if possible) through the set command deletes any stale rows that are associated with this row.")
marsMcsMcGrpTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 2), )
if mibBuilder.loadTexts: marsMcsMcGrpTable.setStatus('current')
if mibBuilder.loadTexts: marsMcsMcGrpTable.setDescription('This table contains a list of IP multicast group address blocks associated by a MARS MCS. The MCS uses the information contained in list to advertise its multicast group service to the MARS. Each row can be created or deleted via configuration.')
marsMcsMcGrpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 2, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcsMcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcsMcMaxGrpAddr"))
if mibBuilder.loadTexts: marsMcsMcGrpEntry.setStatus('current')
if mibBuilder.loadTexts: marsMcsMcGrpEntry.setDescription('Each entry represents a consecutive block of multicast group addresses.')
marsMcsMcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: marsMcsMcMinGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcsMcMinGrpAddr.setDescription('Minimum multicast group address - the min and max multicast forms multi-group block. If the MinGrpAddr and MaxGrpAddr are the same, it indicates that this block contains a single group address. Since the block joins are no allowed by a MCS as implied in the RFC2022, the MinGrpAddr and MaxGrpAddress should be set to the same value at this time when an entry row is created.')
marsMcsMcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 2, 1, 2), IpAddress())
if mibBuilder.loadTexts: marsMcsMcMaxGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcsMcMaxGrpAddr.setDescription('Maximum multicast group address - the min and max multicast forms a multi-group block. If the MinGrpAddr and MaxGrpAddr are the same, it indicates that this block contains a single group address. Since the block joins are no allowed by a MCS as implied in the RFC2022, the MinGrpAddr and MaxGrpAddress should be set to the same value at this time when an entry row is created.')
marsMcsMcGrpRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsMcGrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsMcsMcGrpRowStatus.setDescription("The object is used to create or delete a row in this table. Since other objects in this row are not-accessible 'index-objects', the value of this object has no effect on whether those objects in this conceptual row can be modified.")
marsMcsBackupMarsTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 3), )
if mibBuilder.loadTexts: marsMcsBackupMarsTable.setStatus('current')
if mibBuilder.loadTexts: marsMcsBackupMarsTable.setDescription('This table contains a list of backup MARS addresses that a MCS can make contact to in case of failure for connecting to the primary server. The list of addresses is in descending order of preference. It should be noted that the backup list provided by the MARS to the MCS via the MARS_REDIRECT_MAP message has a higher preference than addresses that are manually configured into the MCS. When such a list is received from the MARS, this information should be inserted at the top of the list. Each row can be created or deleted via configuration.')
marsMcsBackupMarsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 3, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcsBackupMarsPriority"), (0, "IPATM-IPMC-MIB", "marsMcsBackupMarsAddr"))
if mibBuilder.loadTexts: marsMcsBackupMarsEntry.setStatus('current')
if mibBuilder.loadTexts: marsMcsBackupMarsEntry.setDescription('Each entry represents an ATM address of a backup MARS.')
marsMcsBackupMarsPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: marsMcsBackupMarsPriority.setStatus('current')
if mibBuilder.loadTexts: marsMcsBackupMarsPriority.setDescription('The priority associated with a backup MARS. A lower priority value inidcates a higher preference.')
marsMcsBackupMarsAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 3, 1, 2), AtmAddr())
if mibBuilder.loadTexts: marsMcsBackupMarsAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcsBackupMarsAddr.setDescription('The ATM address associated with a backup MARS.')
marsMcsBackupMarsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsBackupMarsRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsMcsBackupMarsRowStatus.setDescription("The object is used to create or delete a row in this table. Since other objects in this row are not-accessible 'index-objects', the value of this object has no effect on whether those objects in this conceptual row can be modified.")
marsMcsVcTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 4), )
if mibBuilder.loadTexts: marsMcsVcTable.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcTable.setDescription('This table contains information about open virtual circuits (VCs) that a MCS has. For point to point circuit, each entry represents a single VC connection between this MCS ATM address to another party ATM address. In the case of point to multipoint connection where a single source address is associated with multiple destinations, several entries are used to represent the relationship. An example of point to multi-point VC represented in a table is shown below. MCS VPI/VCI Grp Addr1/Addr2 Part Addr 1 0,1 g1,g2 p1 1 0,1 g1,g2 p2 1 0,1 g1,g2 p3')
marsMcsVcEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 4, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"), (0, "IPATM-IPMC-MIB", "marsMcsVcVpi"), (0, "IPATM-IPMC-MIB", "marsMcsVcVci"), (0, "IPATM-IPMC-MIB", "marsMcsVcMinGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcsVcMaxGrpAddr"), (0, "IPATM-IPMC-MIB", "marsMcsVcPartyAddr"))
if mibBuilder.loadTexts: marsMcsVcEntry.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcEntry.setDescription('The objects contained in the entry are VC related attributes such as VC signalling type, control VC type, idle timer, negotiated MTU size, etc.')
marsMcsVcVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: marsMcsVcVpi.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcVpi.setDescription('The value of virtual path identifier (VPI). Since a VPI can be numbered 0, this sub-index can take a value of 0.')
marsMcsVcVci = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: marsMcsVcVci.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcVci.setDescription('The value of virtual circuit identifier (VCI). Since a VCI can be numbered 0, this sub-index can take a value of 0.')
marsMcsVcMinGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 3), IpAddress())
if mibBuilder.loadTexts: marsMcsVcMinGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcMinGrpAddr.setDescription('Minimum IP multicast group address - the min and max multicast forms a multi-group block which is associated with a VC. If the MinGrpAddr and MaxGrpAddr are the same, it indicates that the size of multi-group block is 1, a single IP group.')
marsMcsVcMaxGrpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 4), IpAddress())
if mibBuilder.loadTexts: marsMcsVcMaxGrpAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcMaxGrpAddr.setDescription('Maximum IP multicast group address - the min and max multicast forms a multi-group block which is associated with a VC. If the MinGrpAddr and MaxGrpAddr are the same, it indicates that the size of multi-group block is 1, a single IP group.')
marsMcsVcPartyAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 5), AtmAddr())
if mibBuilder.loadTexts: marsMcsVcPartyAddr.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcPartyAddr.setDescription('An ATM party address in which this VC is linked. The party type is identified by the marsMcsVcPartyAddrType.')
marsMcsVcPartyAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("called", 1), ("calling", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcPartyAddrType.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcPartyAddrType.setDescription('The party type is associated with the party address. The called (1) indicates that the party address is a destination address which implies that VC is originated from this MCS. The calling (2) indicates the VC was initiated externally to this MCS. In this case, the party address is the source address.')
marsMcsVcType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcType.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcType.setDescription('Circuit Connection type: permanent virtual circuit or switched virtual circuit.')
marsMcsVcCtrlType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pointToPointVC", 1), ("serverControlVC", 2), ("pointToMultiPointVC", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcCtrlType.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcCtrlType.setDescription('Control VC type used to specify a particular connection. pointToPointVC (1): used by the ATM Clients for the registration and queries. This VC or the initial signalling path is set up from the source MCS to a MARS. It is bi-directional. serverControlVC (2): used by a MARS to issue asynchronous updates to an ATM Client. This VC is established from the MARS to the MCS. pointToMultiPointVC (3): used by the client to transfer multicast data packets from layer 3. This VC is established from this VC to a cluster member.')
marsMcsVcIdleTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(20)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcIdleTimer.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcIdleTimer.setDescription('The idle timer associated with this VC. The minimum suggested value is 1 minute and the recommended default value is 20 minutes.')
marsMcsVcRevalidate = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcRevalidate.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcRevalidate.setDescription('A flag associated with an open and active multipoint VC. It is checked every time a packet is queued for transmission on that VC. The object has the value of true (1) if revalidate is required and the value false (2) otherwise.')
marsMcsVcEncapsType = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("llcSnap", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcEncapsType.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcEncapsType.setDescription('The encapsulation type used when communicating over this VC.')
marsMcsVcNegotiatedMtu = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcNegotiatedMtu.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcNegotiatedMtu.setDescription('The negotiated MTU when communicating over this VC.')
marsMcsVcRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 4, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: marsMcsVcRowStatus.setStatus('current')
if mibBuilder.loadTexts: marsMcsVcRowStatus.setDescription("The object is used to create, delete or modify a row in this table. A row cannot be made 'active' until instances of all corresponding columns in the row of this table are appropriately configured. While objects: marsMcsVcIdleTimer and marsMcsVcRevalidate in this conceptual row can be modified irrespective of the value of this object, all other objects in the row can not be modified when this object has a value of 'active'. It is possible for an SNMP management station to set the row to 'notInService' and modify the entry and then set it back to 'active' with the following exception. That is, rows for which the corresponding instance of marsMcsVcType has a value of 'svc' can not be modified or deleted.")
marsMcsStatTable = MibTable((1, 3, 6, 1, 2, 1, 57, 3, 5), )
if mibBuilder.loadTexts: marsMcsStatTable.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatTable.setDescription('The table contains statistics collected at MARS MCSs.')
marsMcsStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 57, 3, 5, 1), ).setIndexNames((0, "IPATM-IPMC-MIB", "marsMcsIndex"), (0, "IPATM-IPMC-MIB", "marsMcsIfIndex"))
if mibBuilder.loadTexts: marsMcsStatEntry.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatEntry.setDescription('Each entry contains statistics collected at one MARS MCS.')
marsMcsStatTxReqMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatTxReqMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatTxReqMsgs.setDescription('Total number of MARS_REQUEST messages transmitted from this MCS.')
marsMcsStatTxMservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatTxMservMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatTxMservMsgs.setDescription('Total number of MARS_MSERV messages transmitted from this MCS.')
marsMcsStatTxUnservMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatTxUnservMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatTxUnservMsgs.setDescription('Total number of MARS_UNSERV messages transmitted from this MCS.')
marsMcsStatRxMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxMultiMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatRxMultiMsgs.setDescription('Total number of MARS_MULTI messages received by this MCS.')
marsMcsStatRxSjoinMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxSjoinMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatRxSjoinMsgs.setDescription('Total number of MARS_SJOIN messages received by this MCS.')
marsMcsStatRxSleaveMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxSleaveMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatRxSleaveMsgs.setDescription('Total number of MARS_SLEAVE messages received by this MCS.')
marsMcsStatRxNakMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxNakMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatRxNakMsgs.setDescription('Total number of MARS_NAK messages received by this MCS.')
marsMcsStatRxMigrateMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatRxMigrateMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatRxMigrateMsgs.setDescription('Total number of MARS_MIGRATE messages received by this MCS.')
marsMcsStatFailMultiMsgs = MibTableColumn((1, 3, 6, 1, 2, 1, 57, 3, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: marsMcsStatFailMultiMsgs.setStatus('current')
if mibBuilder.loadTexts: marsMcsStatFailMultiMsgs.setDescription('Total number of timeouts occurred indicating failure of the last MARS_MULTI to arrive.')
marsTrapInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 0))
marsFaultTrap = NotificationType((1, 3, 6, 1, 2, 1, 57, 0, 1)).setObjects(("IPATM-IPMC-MIB", "marsAddr"), ("IPATM-IPMC-MIB", "marsServStatus"))
if mibBuilder.loadTexts: marsFaultTrap.setStatus('current')
if mibBuilder.loadTexts: marsFaultTrap.setDescription('This trap/inform is sent to the manager whenever there is a fault condition occurred on a MARS.')
marsConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4))
marsClientConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 1))
marsServerConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 2))
marsMcsConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 3))
marsClientCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 1, 1))
marsClientGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 1, 2))
marsServerCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 2, 1))
marsServerGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 2, 2))
marsMcsCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 3, 1))
marsMcsGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 57, 4, 3, 2))
marsClientCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 57, 4, 1, 1, 1)).setObjects(("IPATM-IPMC-MIB", "marsClientGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    marsClientCompliance = marsClientCompliance.setStatus('current')
if mibBuilder.loadTexts: marsClientCompliance.setDescription('The compliance statement for entities that are required for the management of MARS clients.')
marsClientGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 57, 4, 1, 2, 1)).setObjects(("IPATM-IPMC-MIB", "marsClientAddr"), ("IPATM-IPMC-MIB", "marsClientDefaultMarsAddr"), ("IPATM-IPMC-MIB", "marsClientHsn"), ("IPATM-IPMC-MIB", "marsClientRegistration"), ("IPATM-IPMC-MIB", "marsClientCmi"), ("IPATM-IPMC-MIB", "marsClientDefaultMtu"), ("IPATM-IPMC-MIB", "marsClientFailureTimer"), ("IPATM-IPMC-MIB", "marsClientRetranDelayTimer"), ("IPATM-IPMC-MIB", "marsClientRdmMulReqAddRetrTimer"), ("IPATM-IPMC-MIB", "marsClientRdmVcRevalidateTimer"), ("IPATM-IPMC-MIB", "marsClientJoinLeaveRetrInterval"), ("IPATM-IPMC-MIB", "marsClientJoinLeaveRetrLimit"), ("IPATM-IPMC-MIB", "marsClientRegWithMarsRdmTimer"), ("IPATM-IPMC-MIB", "marsClientForceWaitTimer"), ("IPATM-IPMC-MIB", "marsClientIdleTimer"), ("IPATM-IPMC-MIB", "marsClientLmtToMissRedirMapTimer"), ("IPATM-IPMC-MIB", "marsClientRowStatus"), ("IPATM-IPMC-MIB", "marsClientMcGrpRowStatus"), ("IPATM-IPMC-MIB", "marsClientBackupMarsRowStatus"), ("IPATM-IPMC-MIB", "marsClientVcPartyAddrType"), ("IPATM-IPMC-MIB", "marsClientVcType"), ("IPATM-IPMC-MIB", "marsClientVcCtrlType"), ("IPATM-IPMC-MIB", "marsClientVcIdleTimer"), ("IPATM-IPMC-MIB", "marsClientVcRevalidate"), ("IPATM-IPMC-MIB", "marsClientVcEncapsType"), ("IPATM-IPMC-MIB", "marsClientVcNegotiatedMtu"), ("IPATM-IPMC-MIB", "marsClientVcRowStatus"), ("IPATM-IPMC-MIB", "marsClientStatTxReqMsgs"), ("IPATM-IPMC-MIB", "marsClientStatTxJoinMsgs"), ("IPATM-IPMC-MIB", "marsClientStatTxLeaveMsgs"), ("IPATM-IPMC-MIB", "marsClientStatTxGrpLstReqMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxJoinMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxLeaveMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxMultiMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxNakMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxGrpLstRplyMsgs"), ("IPATM-IPMC-MIB", "marsClientStatRxMigrateMsgs"), ("IPATM-IPMC-MIB", "marsClientStatFailMultiMsgs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    marsClientGroup = marsClientGroup.setStatus('current')
if mibBuilder.loadTexts: marsClientGroup.setDescription('A collection of objects to be implemented in a MIB for the management of MARS clients.')
marsServerCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 57, 4, 2, 1, 1)).setObjects(("IPATM-IPMC-MIB", "marsServerGroup"), ("IPATM-IPMC-MIB", "marsServerEventGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    marsServerCompliance = marsServerCompliance.setStatus('current')
if mibBuilder.loadTexts: marsServerCompliance.setDescription('The compliance statement for entities that are required for the management of MARS servers.')
marsServerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 57, 4, 2, 2, 1)).setObjects(("IPATM-IPMC-MIB", "marsAddr"), ("IPATM-IPMC-MIB", "marsLocal"), ("IPATM-IPMC-MIB", "marsServStatus"), ("IPATM-IPMC-MIB", "marsServType"), ("IPATM-IPMC-MIB", "marsServPriority"), ("IPATM-IPMC-MIB", "marsRedirMapMsgTimer"), ("IPATM-IPMC-MIB", "marsCsn"), ("IPATM-IPMC-MIB", "marsSsn"), ("IPATM-IPMC-MIB", "marsRowStatus"), ("IPATM-IPMC-MIB", "marsMcGrpAddrUsage"), ("IPATM-IPMC-MIB", "marsMcGrpRxLayer3GrpSets"), ("IPATM-IPMC-MIB", "marsMcGrpRxLayer3GrpResets"), ("IPATM-IPMC-MIB", "marsMcGrpRowStatus"), ("IPATM-IPMC-MIB", "marsHostMapRowType"), ("IPATM-IPMC-MIB", "marsHostMapRowStatus"), ("IPATM-IPMC-MIB", "marsServerMapRowType"), ("IPATM-IPMC-MIB", "marsServerMapRowStatus"), ("IPATM-IPMC-MIB", "marsVcPartyAddrType"), ("IPATM-IPMC-MIB", "marsVcType"), ("IPATM-IPMC-MIB", "marsVcCtrlType"), ("IPATM-IPMC-MIB", "marsVcIdleTimer"), ("IPATM-IPMC-MIB", "marsVcCmi"), ("IPATM-IPMC-MIB", "marsVcEncapsType"), ("IPATM-IPMC-MIB", "marsVcNegotiatedMtu"), ("IPATM-IPMC-MIB", "marsVcRowStatus"), ("IPATM-IPMC-MIB", "marsRegClientAtmAddr"), ("IPATM-IPMC-MIB", "marsRegMcsAtmAddr"), ("IPATM-IPMC-MIB", "marsStatTxMultiMsgs"), ("IPATM-IPMC-MIB", "marsStatTxGrpLstRplyMsgs"), ("IPATM-IPMC-MIB", "marsStatTxRedirectMapMsgs"), ("IPATM-IPMC-MIB", "marsStatTxMigrateMsgs"), ("IPATM-IPMC-MIB", "marsStatTxNakMsgs"), ("IPATM-IPMC-MIB", "marsStatTxJoinMsgs"), ("IPATM-IPMC-MIB", "marsStatTxLeaveMsgs"), ("IPATM-IPMC-MIB", "marsStatTxSjoinMsgs"), ("IPATM-IPMC-MIB", "marsStatTxSleaveMsgs"), ("IPATM-IPMC-MIB", "marsStatTxMservMsgs"), ("IPATM-IPMC-MIB", "marsStatTxUnservMsgs"), ("IPATM-IPMC-MIB", "marsStatRxReqMsgs"), ("IPATM-IPMC-MIB", "marsStatRxGrpLstReqMsgs"), ("IPATM-IPMC-MIB", "marsStatRxJoinMsgs"), ("IPATM-IPMC-MIB", "marsStatRxLeaveMsgs"), ("IPATM-IPMC-MIB", "marsStatRxMservMsgs"), ("IPATM-IPMC-MIB", "marsStatRxUnservMsgs"), ("IPATM-IPMC-MIB", "marsStatRxBlkJoinMsgs"), ("IPATM-IPMC-MIB", "marsStatRegMemGroups"), ("IPATM-IPMC-MIB", "marsStatRegMcsGroups"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    marsServerGroup = marsServerGroup.setStatus('current')
if mibBuilder.loadTexts: marsServerGroup.setDescription('A collection of objects to be implemented in a MIB for the management of MARS servers.')
marsServerEventGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 57, 4, 2, 2, 2)).setObjects(("IPATM-IPMC-MIB", "marsFaultTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    marsServerEventGroup = marsServerEventGroup.setStatus('current')
if mibBuilder.loadTexts: marsServerEventGroup.setDescription('A collection of events that can be generated from a MARS server.')
marsMcsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 57, 4, 3, 1, 1)).setObjects(("IPATM-IPMC-MIB", "marsMcsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    marsMcsCompliance = marsMcsCompliance.setStatus('current')
if mibBuilder.loadTexts: marsMcsCompliance.setDescription('The compliance statement for entities that are required for the management of MARS multicast servers (MCS).')
marsMcsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 57, 4, 3, 2, 1)).setObjects(("IPATM-IPMC-MIB", "marsMcsAddr"), ("IPATM-IPMC-MIB", "marsMcsDefaultMarsAddr"), ("IPATM-IPMC-MIB", "marsMcsRegistration"), ("IPATM-IPMC-MIB", "marsMcsSsn"), ("IPATM-IPMC-MIB", "marsMcsDefaultMtu"), ("IPATM-IPMC-MIB", "marsMcsFailureTimer"), ("IPATM-IPMC-MIB", "marsMcsRetranDelayTimer"), ("IPATM-IPMC-MIB", "marsMcsRdmMulReqAddRetrTimer"), ("IPATM-IPMC-MIB", "marsMcsRdmVcRevalidateTimer"), ("IPATM-IPMC-MIB", "marsMcsRegisterRetrInterval"), ("IPATM-IPMC-MIB", "marsMcsRegisterRetrLimit"), ("IPATM-IPMC-MIB", "marsMcsRegWithMarsRdmTimer"), ("IPATM-IPMC-MIB", "marsMcsForceWaitTimer"), ("IPATM-IPMC-MIB", "marsMcsIdleTimer"), ("IPATM-IPMC-MIB", "marsMcsLmtToMissRedirMapTimer"), ("IPATM-IPMC-MIB", "marsMcsRowStatus"), ("IPATM-IPMC-MIB", "marsMcsMcGrpRowStatus"), ("IPATM-IPMC-MIB", "marsMcsVcPartyAddrType"), ("IPATM-IPMC-MIB", "marsMcsBackupMarsRowStatus"), ("IPATM-IPMC-MIB", "marsMcsVcType"), ("IPATM-IPMC-MIB", "marsMcsVcCtrlType"), ("IPATM-IPMC-MIB", "marsMcsVcIdleTimer"), ("IPATM-IPMC-MIB", "marsMcsVcRevalidate"), ("IPATM-IPMC-MIB", "marsMcsVcEncapsType"), ("IPATM-IPMC-MIB", "marsMcsVcNegotiatedMtu"), ("IPATM-IPMC-MIB", "marsMcsVcRowStatus"), ("IPATM-IPMC-MIB", "marsMcsStatTxReqMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatTxMservMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatTxUnservMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxMultiMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxSjoinMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxSleaveMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxNakMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatRxMigrateMsgs"), ("IPATM-IPMC-MIB", "marsMcsStatFailMultiMsgs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    marsMcsGroup = marsMcsGroup.setStatus('current')
if mibBuilder.loadTexts: marsMcsGroup.setDescription('A collection of objects to be implemented in a MIB for the management of MARS multicast servers (MCS).')
mibBuilder.exportSymbols("IPATM-IPMC-MIB", marsMcsMcGrpTable=marsMcsMcGrpTable, marsMcsVcMaxGrpAddr=marsMcsVcMaxGrpAddr, marsServerMapRowStatus=marsServerMapRowStatus, marsMcsStatTxUnservMsgs=marsMcsStatTxUnservMsgs, marsIndex=marsIndex, marsLocal=marsLocal, marsClientCompliances=marsClientCompliances, marsClientStatRxLeaveMsgs=marsClientStatRxLeaveMsgs, marsClientVcVpi=marsClientVcVpi, marsClientVcTable=marsClientVcTable, marsStatTable=marsStatTable, marsMcsVcRevalidate=marsMcsVcRevalidate, marsClientEntry=marsClientEntry, marsTrapInfo=marsTrapInfo, marsRegClientTable=marsRegClientTable, marsMcsVcIdleTimer=marsMcsVcIdleTimer, marsMcsCompliance=marsMcsCompliance, marsClientVcIdleTimer=marsClientVcIdleTimer, marsClientStatTxLeaveMsgs=marsClientStatTxLeaveMsgs, marsClientGroup=marsClientGroup, marsClientBackupMarsAddr=marsClientBackupMarsAddr, marsStatTxMigrateMsgs=marsStatTxMigrateMsgs, marsClientJoinLeaveRetrInterval=marsClientJoinLeaveRetrInterval, marsClientDefaultMarsAddr=marsClientDefaultMarsAddr, marsMcsMcGrpEntry=marsMcsMcGrpEntry, marsVcVci=marsVcVci, marsStatRxReqMsgs=marsStatRxReqMsgs, marsMcsVcTable=marsMcsVcTable, marsHostMapRowStatus=marsHostMapRowStatus, marsClientLmtToMissRedirMapTimer=marsClientLmtToMissRedirMapTimer, marsAddr=marsAddr, marsMcMaxGrpAddr=marsMcMaxGrpAddr, marsObjects=marsObjects, marsClientRdmVcRevalidateTimer=marsClientRdmVcRevalidateTimer, marsClientMcMaxGrpAddr=marsClientMcMaxGrpAddr, marsStatTxJoinMsgs=marsStatTxJoinMsgs, marsMcsRdmMulReqAddRetrTimer=marsMcsRdmMulReqAddRetrTimer, marsClientMcGrpRowStatus=marsClientMcGrpRowStatus, marsServerMapAtmAddr=marsServerMapAtmAddr, marsRegMcsEntry=marsRegMcsEntry, marsMcsFailureTimer=marsMcsFailureTimer, marsClientRegistration=marsClientRegistration, marsVcCtrlType=marsVcCtrlType, marsClientCompliance=marsClientCompliance, marsClientVcPartyAddrType=marsClientVcPartyAddrType, marsMcsVcRowStatus=marsMcsVcRowStatus, marsClientStatEntry=marsClientStatEntry, marsServerMapEntry=marsServerMapEntry, marsMcsStatRxMultiMsgs=marsMcsStatRxMultiMsgs, marsMcsTable=marsMcsTable, marsServerEventGroup=marsServerEventGroup, marsMIB=marsMIB, marsRowStatus=marsRowStatus, marsMcsEntry=marsMcsEntry, marsClientMcGrpEntry=marsClientMcGrpEntry, marsClientForceWaitTimer=marsClientForceWaitTimer, marsClientJoinLeaveRetrLimit=marsClientJoinLeaveRetrLimit, marsVcTable=marsVcTable, marsVcRowStatus=marsVcRowStatus, marsMcsStatRxSleaveMsgs=marsMcsStatRxSleaveMsgs, marsClientStatTxJoinMsgs=marsClientStatTxJoinMsgs, marsClientStatRxGrpLstRplyMsgs=marsClientStatRxGrpLstRplyMsgs, marsStatRegMemGroups=marsStatRegMemGroups, marsClientVcCtrlType=marsClientVcCtrlType, marsMcGrpTable=marsMcGrpTable, marsHostMapEntry=marsHostMapEntry, marsStatTxMservMsgs=marsStatTxMservMsgs, marsMcsVcCtrlType=marsMcsVcCtrlType, marsMcsConformance=marsMcsConformance, marsClientMcGrpTable=marsClientMcGrpTable, marsStatTxLeaveMsgs=marsStatTxLeaveMsgs, marsMcsIfIndex=marsMcsIfIndex, marsHostMapTable=marsHostMapTable, marsStatRegMcsGroups=marsStatRegMcsGroups, marsVcPartyAddrType=marsVcPartyAddrType, marsClientAddr=marsClientAddr, marsMcsBackupMarsAddr=marsMcsBackupMarsAddr, marsServerMapTable=marsServerMapTable, marsClientMcMinGrpAddr=marsClientMcMinGrpAddr, marsMcsObjects=marsMcsObjects, marsClientVcMaxGrpAddr=marsClientVcMaxGrpAddr, marsStatTxGrpLstRplyMsgs=marsStatTxGrpLstRplyMsgs, marsClientRowStatus=marsClientRowStatus, marsMcsVcVci=marsMcsVcVci, marsMcsMcMaxGrpAddr=marsMcsMcMaxGrpAddr, marsServPriority=marsServPriority, marsMcGrpAddrUsage=marsMcGrpAddrUsage, marsMcsVcPartyAddr=marsMcsVcPartyAddr, marsMcsMcGrpRowStatus=marsMcsMcGrpRowStatus, marsStatTxMultiMsgs=marsStatTxMultiMsgs, marsClientStatRxJoinMsgs=marsClientStatRxJoinMsgs, marsMcsBackupMarsPriority=marsMcsBackupMarsPriority, marsMcsVcNegotiatedMtu=marsMcsVcNegotiatedMtu, marsMcsBackupMarsTable=marsMcsBackupMarsTable, marsMcsStatEntry=marsMcsStatEntry, marsMcsStatFailMultiMsgs=marsMcsStatFailMultiMsgs, marsServStatus=marsServStatus, marsHostMapRowType=marsHostMapRowType, marsClientVcRowStatus=marsClientVcRowStatus, marsServerGroup=marsServerGroup, marsMcsStatTxReqMsgs=marsMcsStatTxReqMsgs, marsClientStatFailMultiMsgs=marsClientStatFailMultiMsgs, marsMcMinGrpAddr=marsMcMinGrpAddr, marsFaultTrap=marsFaultTrap, marsServerCompliance=marsServerCompliance, marsRegClientAtmAddr=marsRegClientAtmAddr, PYSNMP_MODULE_ID=marsMIB, marsClientBackupMarsTable=marsClientBackupMarsTable, marsClientVcVci=marsClientVcVci, marsMcsRegWithMarsRdmTimer=marsMcsRegWithMarsRdmTimer, marsClientGroups=marsClientGroups, marsMcsGroup=marsMcsGroup, marsStatTxUnservMsgs=marsStatTxUnservMsgs, marsMcsRdmVcRevalidateTimer=marsMcsRdmVcRevalidateTimer, marsTable=marsTable, marsVcPartyAddr=marsVcPartyAddr, marsMcsDefaultMtu=marsMcsDefaultMtu, marsClientStatRxNakMsgs=marsClientStatRxNakMsgs, marsClientRdmMulReqAddRetrTimer=marsClientRdmMulReqAddRetrTimer, marsStatEntry=marsStatEntry, marsMcsLmtToMissRedirMapTimer=marsMcsLmtToMissRedirMapTimer, marsClientStatRxMigrateMsgs=marsClientStatRxMigrateMsgs, marsMcGrpRxLayer3GrpSets=marsMcGrpRxLayer3GrpSets, marsStatTxSleaveMsgs=marsStatTxSleaveMsgs, marsClientVcType=marsClientVcType, marsStatRxBlkJoinMsgs=marsStatRxBlkJoinMsgs, marsServerConformance=marsServerConformance, marsVcNegotiatedMtu=marsVcNegotiatedMtu, marsMcsCompliances=marsMcsCompliances, marsClientFailureTimer=marsClientFailureTimer, marsClientHsn=marsClientHsn, marsHostMapAtmAddr=marsHostMapAtmAddr, marsStatRxLeaveMsgs=marsStatRxLeaveMsgs, marsClientRegWithMarsRdmTimer=marsClientRegWithMarsRdmTimer, marsMcsStatRxNakMsgs=marsMcsStatRxNakMsgs, marsMcsIdleTimer=marsMcsIdleTimer, marsMcsStatRxMigrateMsgs=marsMcsStatRxMigrateMsgs, marsVcType=marsVcType, marsMcsVcEncapsType=marsMcsVcEncapsType, marsMcsVcMinGrpAddr=marsMcsVcMinGrpAddr, marsStatRxUnservMsgs=marsStatRxUnservMsgs, marsMcsSsn=marsMcsSsn, marsRegClientCmi=marsRegClientCmi, marsRegMcsAtmAddr=marsRegMcsAtmAddr, marsEntry=marsEntry, marsStatTxNakMsgs=marsStatTxNakMsgs, marsStatRxGrpLstReqMsgs=marsStatRxGrpLstReqMsgs, marsClientTable=marsClientTable, marsServType=marsServType, marsMcsAddr=marsMcsAddr, marsMcsRegistration=marsMcsRegistration, marsVcIdleTimer=marsVcIdleTimer, marsConformance=marsConformance, marsVcEncapsType=marsVcEncapsType, marsStatRxJoinMsgs=marsStatRxJoinMsgs, marsVcCmi=marsVcCmi, marsClientStatTxReqMsgs=marsClientStatTxReqMsgs, marsServerCompliances=marsServerCompliances, marsClientVcMinGrpAddr=marsClientVcMinGrpAddr, marsClientVcRevalidate=marsClientVcRevalidate, marsMcsForceWaitTimer=marsMcsForceWaitTimer, marsStatRxMservMsgs=marsStatRxMservMsgs, marsMcsIndex=marsMcsIndex, marsClientObjects=marsClientObjects, marsMcsBackupMarsRowStatus=marsMcsBackupMarsRowStatus, marsClientStatRxMultiMsgs=marsClientStatRxMultiMsgs, marsClientDefaultMtu=marsClientDefaultMtu, marsMcsRowStatus=marsMcsRowStatus, marsMcsStatTxMservMsgs=marsMcsStatTxMservMsgs, marsClientConformance=marsClientConformance, marsVcVpi=marsVcVpi, marsClientBackupMarsRowStatus=marsClientBackupMarsRowStatus, marsClientIdleTimer=marsClientIdleTimer, marsStatTxRedirectMapMsgs=marsStatTxRedirectMapMsgs, marsClientBackupMarsEntry=marsClientBackupMarsEntry, marsClientStatTxGrpLstReqMsgs=marsClientStatTxGrpLstReqMsgs, marsMcsStatTable=marsMcsStatTable, marsClientVcNegotiatedMtu=marsClientVcNegotiatedMtu, marsVcEntry=marsVcEntry, marsMcGrpEntry=marsMcGrpEntry, marsMcsRegisterRetrLimit=marsMcsRegisterRetrLimit, marsMcsDefaultMarsAddr=marsMcsDefaultMarsAddr, marsClientCmi=marsClientCmi, marsMcGrpRowStatus=marsMcGrpRowStatus, marsMcsVcEntry=marsMcsVcEntry, marsMcsVcVpi=marsMcsVcVpi, marsMcsVcType=marsMcsVcType, marsRedirMapMsgTimer=marsRedirMapMsgTimer, marsIfIndex=marsIfIndex, marsClientVcEncapsType=marsClientVcEncapsType, marsMcsBackupMarsEntry=marsMcsBackupMarsEntry, marsServerGroups=marsServerGroups, marsMcsRegisterRetrInterval=marsMcsRegisterRetrInterval, marsClientBackupMarsPriority=marsClientBackupMarsPriority, marsMcsRetranDelayTimer=marsMcsRetranDelayTimer, marsMcGrpRxLayer3GrpResets=marsMcGrpRxLayer3GrpResets, marsRegClientEntry=marsRegClientEntry, marsServerMapRowType=marsServerMapRowType, marsClientVcEntry=marsClientVcEntry, marsStatTxSjoinMsgs=marsStatTxSjoinMsgs, marsClientRetranDelayTimer=marsClientRetranDelayTimer, marsSsn=marsSsn, marsMcsMcMinGrpAddr=marsMcsMcMinGrpAddr, marsMcsStatRxSjoinMsgs=marsMcsStatRxSjoinMsgs, marsMcsGroups=marsMcsGroups, marsClientStatTable=marsClientStatTable, marsCsn=marsCsn, marsClientIndex=marsClientIndex, marsRegMcsTable=marsRegMcsTable, marsClientVcPartyAddr=marsClientVcPartyAddr, marsMcsVcPartyAddrType=marsMcsVcPartyAddrType)

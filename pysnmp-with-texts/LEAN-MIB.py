#
# PySNMP MIB module LEAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LEAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ModuleIdentity, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, MibIdentifier, Unsigned32, Bits, ObjectIdentity, IpAddress, TimeTicks, Gauge32, Integer32, NotificationType, Counter32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "MibIdentifier", "Unsigned32", "Bits", "ObjectIdentity", "IpAddress", "TimeTicks", "Gauge32", "Integer32", "NotificationType", "Counter32", "Counter64")
RowStatus, TextualConvention, TimeStamp, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TimeStamp", "DisplayString", "PhysAddress")
tellabs = ModuleIdentity((1, 3, 6, 1, 4, 1, 42))
if mibBuilder.loadTexts: tellabs.setLastUpdated('Wed Oct 11 15:08:08 BST 1995')
if mibBuilder.loadTexts: tellabs.setOrganization('Tellabs Ltd., Shannon')
if mibBuilder.loadTexts: tellabs.setContactInfo(" Brian O'Sullivan Tellabs, Shannon Industrial Estate, County Clare, Ireland. Tel: +353-61-471433 ext. 2406 Fax: +353-61-471000/472004 E-mail: brianos@shannon.tellabs.com.")
if mibBuilder.loadTexts: tellabs.setDescription('The preliminary MIB module to describe generic objects for the Lean.')
class IfIndex(TextualConvention, Integer32):
    description = 'The value of this object identifies the interface for which this entry contains management information. The value of this object for a particular interface has the same value as the ifIndex object, defined in RFC 1213, for the same interface.'
    status = 'current'

leanMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1))
frnetservMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 1))
frnetservObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 1, 1))
frnetservTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 1, 2))
frLportTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1), )
if mibBuilder.loadTexts: frLportTable.setStatus('current')
if mibBuilder.loadTexts: frLportTable.setDescription('The Frame Relay Logical Port Information table.')
frLportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: frLportEntry.setStatus('current')
if mibBuilder.loadTexts: frLportEntry.setDescription('An entry in the Frame Relay Logical Port Information table.')
frLportNumPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("e164", 2), ("x121", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportNumPlan.setStatus('current')
if mibBuilder.loadTexts: frLportNumPlan.setDescription('The value of this object identifies the network address numbering plan for this UNI/NNI logical port. The network address is the object ifPhysAddress. The value none implies that there is no ifPhysAddress. The SNMP proxy-agent will return an octet string of zero length for ifPhysAddress. The value other means that an address has been assigned to this interface, but the numbering plan is not enumerated here.')
frLportContact = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportContact.setStatus('current')
if mibBuilder.loadTexts: frLportContact.setDescription('The value of this object identifies the network contact for this UNI/NNI logical port.')
frLportLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportLocation.setStatus('current')
if mibBuilder.loadTexts: frLportLocation.setDescription('The value of this object identifies the Frame Relay network location for this UNI/NNI logical port.')
frLportType = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uni", 1), ("nni", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportType.setStatus('current')
if mibBuilder.loadTexts: frLportType.setDescription('The value of this object identifies the type of network interface for this logical port.')
frLportAddrDLCILen = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("twoOctets10Bits", 1), ("threeOctets10Bits", 2), ("threeOctets16Bits", 3), ("fourOctets17Bits", 4), ("fourOctets23Bits", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportAddrDLCILen.setStatus('current')
if mibBuilder.loadTexts: frLportAddrDLCILen.setDescription('The value of this object identifies the Q.922 Address field length and DLCI length for this UNI/NNI logical port.')
frLportVCSigProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("lmi", 2), ("ansiT1617D", 3), ("ansiT1617B", 4), ("ccittQ933A", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportVCSigProtocol.setStatus('current')
if mibBuilder.loadTexts: frLportVCSigProtocol.setDescription('The value of this object identifies the Local In-Channel Signaling Protocol that is used for this frame relay UNI/NNI logical port.')
frLportVCSigPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 1, 1, 7), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frLportVCSigPointer.setStatus('current')
if mibBuilder.loadTexts: frLportVCSigPointer.setDescription('The value of this object is used as a pointer to the table that contains the Local In-Channel Signaling Protocol parameters and errors for this UNI/NNI logical port. See the Frame Relay Management VC Signaling Parameters and Errors Group.')
frMgtVCSigTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2), )
if mibBuilder.loadTexts: frMgtVCSigTable.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigTable.setDescription('The Frame Relay Management VC Signaling Parameters and Errors table.')
frMgtVCSigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: frMgtVCSigEntry.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigEntry.setDescription('An entry in the Frame Relay Management VC Signaling Parameters Errors table.')
frMgtVCSigProced = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("u2nnet", 1), ("bidirect", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigProced.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigProced.setDescription('The value of this object identifies the Local In-Channel Signaling Procedure that is used for this UNI/NNI logical port. The UNI/NNI logical port can be performing only user-to-network network-side procedures or bidirectional procedures.')
frMgtVCSigUserN391 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigUserN391.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigUserN391.setDescription('The value of this object identifies the User-side N391 full status polling cycle value for this UNI/NNI logical port. If the logical port is not performing user-side procedures, then this value is equal to noSuchName. This object applies to Q.933 Annex A and T1.617 Annex D.')
frMgtVCSigUserN392 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigUserN392.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigUserN392.setDescription('The value of this object identifies the User-side N392 error threshold value for this UNI/NNI logical port. If the logical port is not performing user-side procedures, then this value is equal to noSuchName. This object applies to Q.933 Annex A and T1.617 Annex D.')
frMgtVCSigUserN393 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigUserN393.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigUserN393.setDescription('The value of this object identifies the User-side N393 monitored events count value for this UNI/NNI logical port. If the logical port is not performing user-side procedures, then this value is equal to noSuchName. This object applies to Q.933 Annex A and T1.617 Annex D.')
frMgtVCSigUserT391 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigUserT391.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigUserT391.setDescription('The value of this object identifies the User-side T391 link integrity verification polling timer value for this UNI/NNI logical port. If the logical port is not performing user-side procedures, then this value is equal to noSuchName. This object applies to Q.933 Annex A and T1.617 Annex D.')
frMgtVCSigNetN392 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigNetN392.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigNetN392.setDescription('The value of this object identifies the Network- side N392 error threshold value (nN2 for LMI) for this UNI/NNI logical port. If the logical port is not performing network-side procedures, then this value is equal to noSuchName. This object applies to Q.933 Annex A, T1.617 Annex D and LMI.')
frMgtVCSigNetN393 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigNetN393.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigNetN393.setDescription('The value of this object identifies the Network- side N393 monitored events count value (nN3 for LMI) for this UNI/NNI logical port. If the logical port is not performing network-side procedures, then this value is equal to noSuchName. This object applies to Q.933 Annex A, T1.617 Annex D and LMI.')
frMgtVCSigNetT392 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigNetT392.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigNetT392.setDescription('The value of this object identifies the Network- side T392 polling verification timer value (nT2 for LMI) for this UNI/NNI logical port. If the logical port is not performing network-side procedures, then this value is equal to noSuchName. This object applies to Q.933 Annex A, T1.617 Annex D and LMI.')
frMgtVCSigNetnN4 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigNetnN4.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigNetnN4.setDescription('The value of this object identifies the Network- side nN4 maximum status enquires received value for this UNI/NNI logical port. If the logical port is not performing network-side procedures or is not performing LMI procedures, then this value is equal to noSuchName. This object applies only to LMI and always has a value of 5.')
frMgtVCSigNetnT3 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(15, 15), ValueRangeConstraint(20, 20), ValueRangeConstraint(25, 25), ValueRangeConstraint(30, 30), )).clone(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigNetnT3.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigNetnT3.setDescription('The value of this object identifies the Network- side nT3 timer (for nN4 status enquires received) value for this UNI/NNI logical port. If the logical port is not performing network-side procedures or is not performing LMI procedures, then this value is equal to noSuchName. This object applies only to LMI.')
frMgtVCSigUserLinkRelErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigUserLinkRelErrors.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigUserLinkRelErrors.setDescription('The number of user-side local in-channel signaling link reliability errors (i.e., non- receipt of Status/Status Enquiry messages or invalid sequence numbers in a Link Integrity Verification Information Element) for this UNI/NNI logical port. If the logical port is not performing user-side procedures, then this value is equal to noSuchName.')
frMgtVCSigUserProtErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigUserProtErrors.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigUserProtErrors.setDescription('The number of user-side local in-channel signaling protocol errors (i.e., protocol discriminator, message type, call reference, and mandatory information element errors) for this UNI/NNI logical port. If the logical port is not performing user-side procedures, then this value is equal to noSuchName.')
frMgtVCSigUserChanInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigUserChanInactive.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigUserChanInactive.setDescription('The number of times the user-side channel was declared inactive (i.e., N392 errors in N393 events) for this UNI/NNI logical port. If the logical port is not performing user-side procedures, then this value is equal to noSuchName.')
frMgtVCSigNetLinkRelErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigNetLinkRelErrors.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigNetLinkRelErrors.setDescription('The number of network-side local in-channel signaling link reliability errors (i.e., non- receipt of Status/Status Enquiry messages or invalid sequence numbers in a Link Integrity Verification Information Element) for this UNI/NNI logical port. If the logical port is not performing network-side procedures, then this value is equal to noSuchName.')
frMgtVCSigNetProtErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigNetProtErrors.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigNetProtErrors.setDescription('The number of network-side local in-channel signaling protocol errors (i.e., protocol discriminator, message type, call reference, and mandatory information element errors) for this UNI/NNI logical port. If the logical port is not performing network-side procedures, then this value is equal to noSuchName.')
frMgtVCSigNetChanInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frMgtVCSigNetChanInactive.setStatus('current')
if mibBuilder.loadTexts: frMgtVCSigNetChanInactive.setDescription('The number of times the network-side channel was declared inactive (i.e., N392 errors in N393 events) for this UNI/NNI logical port. If the logical port is not performing network-side procedures, then this value is equal to noSuchName.')
frPVCEndptTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3), )
if mibBuilder.loadTexts: frPVCEndptTable.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptTable.setDescription('The Frame Relay PVC End-Point table. This table is used to model a PVC end-point. This table contains the traffic parameters and statistics for a PVC end-point.')
frPVCEndptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "LEAN-MIB", "frPVCEndptDLCIIndex"))
if mibBuilder.loadTexts: frPVCEndptEntry.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptEntry.setDescription('An entry in the Frame Relay PVC Endpoint table.')
frPVCEndptDLCIIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: frPVCEndptDLCIIndex.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptDLCIIndex.setDescription('The value of this object is equal to the DLCI value for this PVC end-point.')
frPVCEndptInMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptInMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInMaxFrameSize.setDescription('The value of this object is the size in octets of the largest frame relay information field for this PVC end-point in the ingress direction (into the frame relay network). The value of frPVCEndptInMaxFrameSize must be less than or equal to the corresponding ifMtu for this Frame Relay UNI/NNI logical port.')
frPVCEndptInBc = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptInBc.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInBc.setDescription('The value of this object is equal to the committed burst size (Bc) parameter (measured in bits) for this PVC end-point in the ingress direction (into the frame relay network).')
frPVCEndptInBe = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptInBe.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInBe.setDescription('The value of this object is equal to the excess burst size (Be) parameter (measured in bits) for this PVC end-point in the ingress direction (into the frame relay network).')
frPVCEndptInCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptInCIR.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (measured in bits per second) for this PVC end- point in the ingress direction (into the frame relay network).')
frPVCEndptOutMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptOutMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptOutMaxFrameSize.setDescription('The value of this object is the size in octets of the largest frame relay information field for this PVC end-point in the egress direction (out of the frame relay network). The value of frPVCEndptOutMaxFrameSize must be less than or equal to the corresponding ifMtu for this Frame Relay UNI/NNI logical port.')
frPVCEndptOutBc = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptOutBc.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptOutBc.setDescription('The value of this object is equal to the committed burst size (Bc) parameter (measured in bits) for this PVC end-point in the egress direction (out of the frame relay network).')
frPVCEndptOutBe = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptOutBe.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptOutBe.setDescription('The value of this object is equal to the excess burst size (Be) parameter (measured in bits) for this PVC end-point in the egress direction (out of the frame relay network).')
frPVCEndptOutCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptOutCIR.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptOutCIR.setDescription('The value of this object is equal to the committed information rate (CIR) parameter (measured in bits per second) for this PVC end- point in the egress direction (out of the frame relay network).')
frPVCEndptConnectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptConnectIdentifier.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptConnectIdentifier.setDescription('This object is used to associate PVC end-points as being part of one PVC segment connection. This value of this object is equal to the value of frPVCConnectIndex, which is used as one of the indices into the frPVCConnectTable. The value of this object is provided by the agent, after the associated entries in the frPVCConnectTable have been created.')
frPVCEndptRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCEndptRowStatus.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptRowStatus.setDescription("This object is used to create new rows in this table, modify existing rows, and to delete existing rows. To create a new PVC, the entries for the PVC segment end-points in the frPVCEndptTable must first be created. Next, the frPVCConnectTable is used to associate the Frame Relay PVC segment end-points. In order for the manager to have the necessary error diagnostics, the frPVCEndptRowStatus object must initially be set to `createAndWait'. While the frPVCEndptRowStatus object is in the `createAndWait' state, the manager can set each columnar object and get the necessary error diagnostics. The frPVCEndptRowStatus object may not be set to `active' unless the following columnar objects exist in this row: frPVCEndptInMaxFrameSize, frPVCEndptInBc, frPVCEndptInBe, frPVCEndptInCIR, frPVCEndptOutMaxFrameSize, frPVCEndptOutBc, frPVCEndptOutBe, and frPVCEndptOutCIR.")
frPVCEndptRcvdSigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("deleted", 1), ("active", 2), ("inactive", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptRcvdSigStatus.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptRcvdSigStatus.setDescription('The value of this object identifies the PVC status received via the local in-channel signaling procedures for this PVC end-point. This object is only pertinent for interfaces that perform the bidirectional procedures. For user-to-network network side procedures, the value of this object should be none.')
frPVCEndptInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptInFrames.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInFrames.setDescription('The number of frames received by the network (ingress) for this PVC end-point. This includes any frames discarded by the network due to submitting more than Bc + Be data or due to any network congestion recovery procedures.')
frPVCEndptOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptOutFrames.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptOutFrames.setDescription('The number of frames sent by the network (egress) regardless of whether they are Bc or Be frames for this PVC end-point.')
frPVCEndptInDEFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptInDEFrames.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInDEFrames.setDescription('The number of frames received by the network (ingress) with the DE bit set to (1) for this PVC end-point.')
frPVCEndptInExcessFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptInExcessFrames.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInExcessFrames.setDescription('The number of frames received by the network (ingress) for this PVC end-point which were treated as excess traffic. Frames which are sent to the network with DE set to zero are treated as excess when more than Bc bits are submitted to the network during the Committed Information Rate Measurement Interval (Tc). Excess traffic may or may not be discarded at the ingress if more than Bc + Be bits are submitted to the network during Tc. Traffic discarded at the ingress is not recorded in frPVCEndptInExcessFrames. Frames which are sent to the network with DE set to one are also treated as excess traffic.')
frPVCEndptOutExcessFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptOutExcessFrames.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptOutExcessFrames.setDescription('The number of frames sent by the network (egress) for this PVC end-point which were treated as excess traffic. (The DE bit may be set to one.)')
frPVCEndptInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptInDiscards.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInDiscards.setDescription('The number of frames received by the the network (ingress) that were discarded due to traffic enforcement for this PVC end-point.')
frPVCEndptInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptInOctets.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptInOctets.setDescription('The number of octets received by the network (ingress) for this PVC end-point. This counter should only count octets from the beginning of the frame relay header field to the end of user data. If the network supporting Frame Relay can not count octets, then this count should be an approximation.')
frPVCEndptOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCEndptOutOctets.setStatus('current')
if mibBuilder.loadTexts: frPVCEndptOutOctets.setDescription('The number of octets sent by the network (egress) for this PVC end-point. This counter should only count octets from the beginning of the frame relay header field to the end of user data. If the network supporting Frame Relay can not count octets, then this count should be an approximation.')
frPVCConnectIndexValue = MibScalar((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCConnectIndexValue.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectIndexValue.setDescription('This object contains an appropriate value to be used for frPVCConnectIndex when creating entries in the frPVCConnectTable. The value 0 indicates that no unassigned entries are available. To obtain the frPVCConnectIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index.')
frPVCConnectTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5), )
if mibBuilder.loadTexts: frPVCConnectTable.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectTable.setDescription('The Frame Relay PVC Connect table. A bi- directional PVC segment is modeled as one entry in this table.')
frPVCConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1), ).setIndexNames((0, "LEAN-MIB", "frPVCConnectIndex"), (0, "LEAN-MIB", "frPVCConnectLowIfIndex"), (0, "LEAN-MIB", "frPVCConnectLowDLCIIndex"), (0, "LEAN-MIB", "frPVCConnectHighIfIndex"), (0, "LEAN-MIB", "frPVCConnectHighDLCIIndex"))
if mibBuilder.loadTexts: frPVCConnectEntry.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectEntry.setDescription('An entry in the Frame Relay PVC Connect table. This entry is used to model a PVC segment in two directions.')
frPVCConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: frPVCConnectIndex.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectIndex.setDescription('The value of this object is equal to the frPVCConnectIndexValue obtained to uniquely identify this PVC segment connection.')
frPVCConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 2), IfIndex())
if mibBuilder.loadTexts: frPVCConnectLowIfIndex.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectLowIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the UNI/NNI logical port for this PVC segment. The term low implies that this PVC segment end-point has the numerically lower ifIndex value than the connected/associated PVC segment end-point. If the value is equal to zero, then this logical port is not a Frame Relay UNI/NNI logical port.")
frPVCConnectLowDLCIIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 3), Integer32())
if mibBuilder.loadTexts: frPVCConnectLowDLCIIndex.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectLowDLCIIndex.setDescription('The value of this object is equal to the DLCI value for this end-point of the PVC segment. If the value is equal to zero, then this endpoint of the PVC segment is not a Frame Relay connection.')
frPVCConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 4), IfIndex())
if mibBuilder.loadTexts: frPVCConnectHighIfIndex.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectHighIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value for the UNI/NNI logical port for this PVC segment. The term high implies that this PVC segment end-point has the numerically higher ifIndex value than the connected/associated PVC segment end-point.")
frPVCConnectHighDLCIIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 5), Integer32())
if mibBuilder.loadTexts: frPVCConnectHighDLCIIndex.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectHighDLCIIndex.setDescription('The value of this object is equal to the egress DLCI value for this end-point of the PVC segment.')
frPVCConnectAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCConnectAdminStatus.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectAdminStatus.setDescription("The value of this object identifies the desired administrative status of this bi-directional PVC segment. The active state means the PVC segment is currently operational; the inactive state means the PVC segment is currently not operational; the testing state means the PVC segment is currently undergoing a test. This state is set by an administrative entity. This value affects the PVC status indicated across the ingress NNI/UNI of both end-points of the bi-directional PVC segment. When a PVC segment connection is created using this table, this object is initially set to `inactive'. After the frPVCConnectRowStatus object is set to `active' (and the corresponding/associated entries in the frPVCEndptTable have their frPVCEndptRowStatus object set to `active'), the frPVCConnectAdminStatus object may be set to `active' to turn on the PVC segment connection.")
frPVCConnectL2hOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("testing", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCConnectL2hOperStatus.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectL2hOperStatus.setDescription('The value of this object identifies the current operational status of the PVC segment connection in one direction; (i.e., in the low to high direction). The active state means it is currently operational; the inactive state means it is currently not operational; the testing state means it is currently undergoing a test; the unknown state means the status of it currently can not be determined. This value affects the PVC status indicated across the ingress NNI/UNI (low side) of the PVC segment.')
frPVCConnectH2lOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("testing", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCConnectH2lOperStatus.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectH2lOperStatus.setDescription('The value of this object identifies the current operational status of the PVC segment connection in one direction; (i.e., in the high to low direction). The active state means it is currently operational; the inactive state means it is currently not operational; the testing state means it is currently undergoing a test; the unknown state means the status of it currently can not be determined. This value affects the PVC status indicated across the ingress NNI/UNI (high side) of the PVC segment.')
frPVCConnectL2hLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCConnectL2hLastChange.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectL2hLastChange.setDescription("The value of MIB II's sysUpTime object at the time this PVC segment entered its current operational state in the low to high direction. If the current state was entered prior to the last re-initialization of the proxy-agent, then this object contains a zero value.")
frPVCConnectH2lLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frPVCConnectH2lLastChange.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectH2lLastChange.setDescription("The value of MIB II's sysUpTime object at the time this PVC segment entered its current operational state in the high to low direction. If the current state was entered prior to the last re-initialization of the proxy-agent, then this object contains a zero value.")
frPVCConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 5, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: frPVCConnectRowStatus.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectRowStatus.setDescription("The status of this entry in the frPVCConnectTable. This variable is used to create new connections for the PVC end-points and to change existing connections of the PVC end- points. This object must be initially set to `createAndWait'. In this state, the agent checks the parameters in the associated entries in the frPVCEndptTable to verify that the PVC end-points can be connected (i.e., the In parameters for one PVC end-point are equal to the Out parameters for the other PVC end-point). This object can not be set to `active' unless the following columnar object exist in this row: frPVCConnectAdminStatus. The agent also supplies the associated value of frPVCConnectIndex for the frPVCEndptConnectIdentifier instances. To turn on a PVC segment connection, the frPVCConnectAdminStatus is set to `active'.")
frAccountPVCTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 6), )
if mibBuilder.loadTexts: frAccountPVCTable.setStatus('current')
if mibBuilder.loadTexts: frAccountPVCTable.setDescription('The Frame Relay Accounting PVC table. This table is used to perform accounting on a PVC segment end-point basis.')
frAccountPVCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "LEAN-MIB", "frAccountPVCDLCIIndex"))
if mibBuilder.loadTexts: frAccountPVCEntry.setStatus('current')
if mibBuilder.loadTexts: frAccountPVCEntry.setDescription('An entry in the Frame Relay Accounting PVC table.')
frAccountPVCDLCIIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 6, 1, 1), Integer32())
if mibBuilder.loadTexts: frAccountPVCDLCIIndex.setStatus('current')
if mibBuilder.loadTexts: frAccountPVCDLCIIndex.setDescription('The value of this object is equal to the DLCI value for this PVC segment end-point.')
frAccountPVCSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frAccountPVCSegmentSize.setStatus('current')
if mibBuilder.loadTexts: frAccountPVCSegmentSize.setDescription('The value of this object is equal to the Segment Size for this PVC segment end-point.')
frAccountPVCInSegments = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frAccountPVCInSegments.setStatus('current')
if mibBuilder.loadTexts: frAccountPVCInSegments.setDescription('The value of this object is equal to the number of segments received by this PVC segment end- point.')
frAccountPVCOutSegments = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frAccountPVCOutSegments.setStatus('current')
if mibBuilder.loadTexts: frAccountPVCOutSegments.setDescription('The value of this object is equal to the number of segments sent by this PVC segment end-point.')
frAccountLportTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 7), )
if mibBuilder.loadTexts: frAccountLportTable.setStatus('current')
if mibBuilder.loadTexts: frAccountLportTable.setDescription('The Frame Relay Accounting Logical Port table. This table is used to perform accounting on a UNI/NNI Logical Port basis.')
frAccountLportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: frAccountLportEntry.setStatus('current')
if mibBuilder.loadTexts: frAccountLportEntry.setDescription('An entry in the Frame Relay Accounting Logical Port table.')
frAccountLportSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frAccountLportSegmentSize.setStatus('current')
if mibBuilder.loadTexts: frAccountLportSegmentSize.setDescription('The value of this object is equal to the Segment Size for this UNI/NNI logical port.')
frAccountLportInSegments = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frAccountLportInSegments.setStatus('current')
if mibBuilder.loadTexts: frAccountLportInSegments.setDescription('The value of this object is equal to the number of segments received by this UNI/NNI logical port.')
frAccountLportOutSegments = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 1, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frAccountLportOutSegments.setStatus('current')
if mibBuilder.loadTexts: frAccountLportOutSegments.setDescription('The value of this object is equal to the number of segments sent by this UNI/NNI logical port.')
frPVCConnectStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 42, 1, 1, 2, 1)).setObjects(("LEAN-MIB", "frPVCConnectIndex"), ("LEAN-MIB", "frPVCConnectLowIfIndex"), ("LEAN-MIB", "frPVCConnectLowDLCIIndex"), ("LEAN-MIB", "frPVCConnectHighIfIndex"), ("LEAN-MIB", "frPVCConnectHighDLCIIndex"), ("LEAN-MIB", "frPVCConnectL2hOperStatus"), ("LEAN-MIB", "frPVCConnectH2lOperStatus"), ("LEAN-MIB", "frPVCEndptRcvdSigStatus"))
if mibBuilder.loadTexts: frPVCConnectStatusChange.setStatus('current')
if mibBuilder.loadTexts: frPVCConnectStatusChange.setDescription('This trap indicates that the indicated PVC has changed state. This trap is not sent if an FR-UNI changes state; a linkDown or linkUp trap should be sent instead.')
frnetservConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 1, 3))
frnetservGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 1))
frnetservCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 2))
frnetservCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 2, 1)).setObjects(("LEAN-MIB", "frnetservLportGroup"), ("LEAN-MIB", "frnetservMgtVCSigGroup"), ("LEAN-MIB", "frnetservPVCEndptGroup"), ("LEAN-MIB", "frnetservPVCConnectGroup"), ("LEAN-MIB", "frnetservAccountPVCGroup"), ("LEAN-MIB", "frnetservAccountLportGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    frnetservCompliance = frnetservCompliance.setStatus('current')
if mibBuilder.loadTexts: frnetservCompliance.setDescription('The compliance statement for SNMPv2 entities which have Frame Relay Network Service Interfaces.')
frnetservLportGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 1, 1)).setObjects(("LEAN-MIB", "frLportNumPlan"), ("LEAN-MIB", "frLportContact"), ("LEAN-MIB", "frLportLocation"), ("LEAN-MIB", "frLportType"), ("LEAN-MIB", "frLportAddrDLCILen"), ("LEAN-MIB", "frLportVCSigProtocol"), ("LEAN-MIB", "frLportVCSigPointer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    frnetservLportGroup = frnetservLportGroup.setStatus('current')
if mibBuilder.loadTexts: frnetservLportGroup.setDescription('A collection of objects providing information applicable to a Frame Relay Logical Port.')
frnetservMgtVCSigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 1, 2)).setObjects(("LEAN-MIB", "frMgtVCSigProced"), ("LEAN-MIB", "frMgtVCSigUserN391"), ("LEAN-MIB", "frMgtVCSigUserN392"), ("LEAN-MIB", "frMgtVCSigUserN393"), ("LEAN-MIB", "frMgtVCSigUserT391"), ("LEAN-MIB", "frMgtVCSigNetN392"), ("LEAN-MIB", "frMgtVCSigNetN393"), ("LEAN-MIB", "frMgtVCSigNetT392"), ("LEAN-MIB", "frMgtVCSigNetnN4"), ("LEAN-MIB", "frMgtVCSigNetnT3"), ("LEAN-MIB", "frMgtVCSigUserLinkRelErrors"), ("LEAN-MIB", "frMgtVCSigUserProtErrors"), ("LEAN-MIB", "frMgtVCSigUserChanInactive"), ("LEAN-MIB", "frMgtVCSigNetLinkRelErrors"), ("LEAN-MIB", "frMgtVCSigNetProtErrors"), ("LEAN-MIB", "frMgtVCSigNetChanInactive"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    frnetservMgtVCSigGroup = frnetservMgtVCSigGroup.setStatus('current')
if mibBuilder.loadTexts: frnetservMgtVCSigGroup.setDescription('A collection of objects providing information applicable to the Local In-Channel Signaling Procedures used for a UNI/NNI logical port.')
frnetservPVCEndptGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 1, 3)).setObjects(("LEAN-MIB", "frPVCConnectIndexValue"), ("LEAN-MIB", "frPVCEndptInMaxFrameSize"), ("LEAN-MIB", "frPVCEndptInBc"), ("LEAN-MIB", "frPVCEndptInBe"), ("LEAN-MIB", "frPVCEndptInCIR"), ("LEAN-MIB", "frPVCEndptOutMaxFrameSize"), ("LEAN-MIB", "frPVCEndptOutBc"), ("LEAN-MIB", "frPVCEndptOutBe"), ("LEAN-MIB", "frPVCEndptOutCIR"), ("LEAN-MIB", "frPVCEndptConnectIdentifier"), ("LEAN-MIB", "frPVCEndptRowStatus"), ("LEAN-MIB", "frPVCEndptRcvdSigStatus"), ("LEAN-MIB", "frPVCEndptInFrames"), ("LEAN-MIB", "frPVCEndptOutFrames"), ("LEAN-MIB", "frPVCEndptInDEFrames"), ("LEAN-MIB", "frPVCEndptInExcessFrames"), ("LEAN-MIB", "frPVCEndptOutExcessFrames"), ("LEAN-MIB", "frPVCEndptInDiscards"), ("LEAN-MIB", "frPVCEndptInOctets"), ("LEAN-MIB", "frPVCEndptOutOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    frnetservPVCEndptGroup = frnetservPVCEndptGroup.setStatus('current')
if mibBuilder.loadTexts: frnetservPVCEndptGroup.setDescription('A collection of objects providing information application to a Frame Relay PVC end-point.')
frnetservPVCConnectGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 1, 4)).setObjects(("LEAN-MIB", "frPVCConnectAdminStatus"), ("LEAN-MIB", "frPVCConnectL2hOperStatus"), ("LEAN-MIB", "frPVCConnectH2lOperStatus"), ("LEAN-MIB", "frPVCConnectL2hLastChange"), ("LEAN-MIB", "frPVCConnectH2lLastChange"), ("LEAN-MIB", "frPVCConnectRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    frnetservPVCConnectGroup = frnetservPVCConnectGroup.setStatus('current')
if mibBuilder.loadTexts: frnetservPVCConnectGroup.setDescription('A collection of objects providing information applicable to a Frame Relay PVC connection.')
frnetservAccountPVCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 1, 5)).setObjects(("LEAN-MIB", "frAccountPVCSegmentSize"), ("LEAN-MIB", "frAccountPVCInSegments"), ("LEAN-MIB", "frAccountPVCOutSegments"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    frnetservAccountPVCGroup = frnetservAccountPVCGroup.setStatus('current')
if mibBuilder.loadTexts: frnetservAccountPVCGroup.setDescription('A collection of objects providing accounting information application to a Frame Relay PVC end-point.')
frnetservAccountLportGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 1, 3, 1, 6)).setObjects(("LEAN-MIB", "frAccountLportSegmentSize"), ("LEAN-MIB", "frAccountLportInSegments"), ("LEAN-MIB", "frAccountLportOutSegments"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    frnetservAccountLportGroup = frnetservAccountLportGroup.setStatus('current')
if mibBuilder.loadTexts: frnetservAccountLportGroup.setDescription('A collection of objects providing accounting information application to a Frame Relay logical port.')
atmMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 2))
atmMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 2, 1))
class AtmTrafficDescrParamIndex(TextualConvention, Integer32):
    description = 'The value of this object identifies the row in the atmTrafficDescrParamTable.'
    status = 'current'

atmTrafficDescriptorTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1))
atmNoTrafficDescriptor = ObjectIdentity((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1, 1))
if mibBuilder.loadTexts: atmNoTrafficDescriptor.setStatus('current')
if mibBuilder.loadTexts: atmNoTrafficDescriptor.setDescription('This identifies the no ATM traffic descriptor type. Parameters 1, 2, 3, 4, and 5 are not used. This traffic descriptor type can be used for best effort traffic.')
atmNoClpNoScr = ObjectIdentity((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1, 2))
if mibBuilder.loadTexts: atmNoClpNoScr.setStatus('current')
if mibBuilder.loadTexts: atmNoClpNoScr.setDescription('This traffic descriptor is for no CLP and no Sustained Cell Rate. The use of the parameter vector for this type: Parameter 1: CLP=0+1 peak cell rate in cells per second Parameter 2: not used Parameter 3: not used Parameter 4: not used Parameter 5: not used. This traffic descriptor type can be used for best effort traffic.')
atmClpNoTaggingNoScr = ObjectIdentity((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1, 3))
if mibBuilder.loadTexts: atmClpNoTaggingNoScr.setStatus('current')
if mibBuilder.loadTexts: atmClpNoTaggingNoScr.setDescription('This traffic descriptor is for no CLP without tagging and no Sustained Cell Rate. The use of the parameter vector for this type: Parameter 1: CLP=0+1 peak cell rate in cells per second Parameter 2: CLP=0 peak cell rate in cells per second Parameter 3: not used Parameter 4: not used Parameter 5: not used.')
atmClpTaggingNoScr = ObjectIdentity((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1, 4))
if mibBuilder.loadTexts: atmClpTaggingNoScr.setStatus('current')
if mibBuilder.loadTexts: atmClpTaggingNoScr.setDescription('This traffic descriptor is for CLP with tagging and no Sustained Cell Rate. The use of the parameter vector for this type: Parameter 1: CLP=0+1 peak cell rate in cells per second Parameter 2: CLP=0 peak cell rate in cells per second with excess traffic tagged as CLP=1 Parameter 3: not used Parameter 4: not used Parameter 5: not used.')
atmNoClpScr = ObjectIdentity((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1, 5))
if mibBuilder.loadTexts: atmNoClpScr.setStatus('current')
if mibBuilder.loadTexts: atmNoClpScr.setDescription('This traffic descriptor is for no CLP with Sustained Cell Rate. The use of the parameter vector for this type: Parameter 1: CLP=0+1 peak cell rate in cells per second Parameter 2: CLP=0+1 sustained cell rate in cells per second Parameter 3: CLP=0+1 maximum burst size in cells Parameter 4: not used Parameter 5: not used.')
atmClpNoTaggingScr = ObjectIdentity((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1, 6))
if mibBuilder.loadTexts: atmClpNoTaggingScr.setStatus('current')
if mibBuilder.loadTexts: atmClpNoTaggingScr.setDescription('This traffic descriptor is for CLP with Sustained Cell Rate and no tagging. The use of the parameter vector for this type: Parameter 1: CLP=0+1 peak cell rate in cells per second Parameter 2: CLP=0 sustained cell rate in cells per second Parameter 3: CLP=0 maximum burst size in cells Parameter 4: not used Parameter 5: not used.')
atmClpTaggingScr = ObjectIdentity((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1, 7))
if mibBuilder.loadTexts: atmClpTaggingScr.setStatus('current')
if mibBuilder.loadTexts: atmClpTaggingScr.setDescription('This traffic descriptor is for CLP with tagging and Sustained Cell Rate. The use of the parameter vector for this type: Parameter 1: CLP=0+1 peak cell rate in cells per second Parameter 2: CLP=0 sustained cell rate in cells per second with excess traffic tagged as CLP=1 Parameter 3: CLP=0 maximum burst size in cells Parameter 4: not used Parameter 5: not used.')
atmInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2), )
if mibBuilder.loadTexts: atmInterfaceConfTable.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfTable.setDescription('This table contains ATM local interface configuration parameters, one entry per ATM interface port.')
atmInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmInterfaceConfEntry.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfEntry.setDescription('This list contains ATM interface configuration parameters and state variables.')
atmInterfaceMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaxVpcs.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceMaxVpcs.setDescription('The maximum number of VPCs (PVCs and SVCs) supported at this ATM interface. At the ATM UNI, the maximum number of VPCs (PVCs and SVCs) ranges from 0 to 256 only.')
atmInterfaceMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaxVccs.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceMaxVccs.setDescription('The maximum number of VCCs (PVCs and SVCs) supported at this ATM interface.')
atmInterfaceConfVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceConfVpcs.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfVpcs.setDescription('The number of VPCs (PVCs and SVCs) configured for use at this ATM interface. At the ATM UNI, the configured number of VPCs (PVCs and SVCs) can range from 0 to 256 only.')
atmInterfaceConfVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceConfVccs.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfVccs.setDescription('The number of VCCs (PVCs and SVCs) configured for use at the ATM interface.')
atmInterfaceMaxActiveVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaxActiveVpiBits.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceMaxActiveVpiBits.setDescription('The maximum number of active VPI bits configured for use at the ATM interface. At the ATM UNI, the maximum number of active VPI bits configured for use ranges from 0 to 8 only.')
atmInterfaceMaxActiveVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMaxActiveVciBits.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceMaxActiveVciBits.setDescription('The maximum number of active VCI bits configured for use at this ATM interface.')
atmInterfaceIlmiVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceIlmiVpi.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceIlmiVpi.setDescription('The VPI value of the VCC supporting the ILMI at this ATM interface. If the values of atmInterfaceIlmiVpi and atmInterfaceIlmiVci are both equal to zero then the ILMI is not supported at this ATM interface.')
atmInterfaceIlmiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceIlmiVci.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceIlmiVci.setDescription('The VCI value of the VCC supporting the ILMI at this ATM interface. If the values of atmInterfaceIlmiVpi and atmInterfaceIlmiVci are both equal to zero then the ILMI is not supported at this ATM interface.')
atmInterfaceAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("private", 1), ("nsapE164", 2), ("nativeE164", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceAddressType.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceAddressType.setDescription('The type of primary ATM address configured for use at this ATM interface.')
atmInterfaceAdminAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceAdminAddress.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceAdminAddress.setDescription('An address assigned for administrative purposes, for example, an address associated with the service provider side of a public network UNI. If this interface has no assigned administrative address, or when the address used for administrative purposes is the same as that used for ifPhysAddress, then this is an octet string of zero length.')
atmInterfaceMyNeighborIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMyNeighborIpAddress.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceMyNeighborIpAddress.setDescription('The IP address of the neighbor system connected to the far end of this interface, to which a Network Management Station can send SNMP messages, as IP datagrams sent to UDP port 161, in order to access network management information concerning the operation of that system. Note that the value of this object may be obtained in different ways, e.g., by manual configuration, or through ILMI interaction with the neighbor system.')
atmInterfaceMyNeighborIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 2, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceMyNeighborIfName.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceMyNeighborIfName.setDescription('The textual name of the interface on the neighbor system on the far end of this interface, and to which this interface connects. If the neighbor system is manageable through SNMP and supports the object ifName, the value of this object must be identical with that of ifName for the ifEntry of the lowest level physical interface for this port. If this interface does not have a textual name, the value of this object is a zero length string. Note that the value of this object may be obtained in different ways, e.g., by manual configuration, or through ILMI interaction with the neighbor system.')
atmInterfaceDs3PlcpTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 3), )
if mibBuilder.loadTexts: atmInterfaceDs3PlcpTable.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceDs3PlcpTable.setDescription('This table contains ATM interface DS3 PLCP parameters and state variables, one entry per ATM interface port.')
atmInterfaceDs3PlcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmInterfaceDs3PlcpEntry.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceDs3PlcpEntry.setDescription('This list contains DS3 PLCP parameters and state variables at the ATM interface.')
atmInterfaceDs3PlcpSEFSs = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceDs3PlcpSEFSs.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceDs3PlcpSEFSs.setDescription('The number of DS3 PLCP Severely Errored Framing Second (SEFS). Each SEFS represents a one-second interval which contains one or more SEF event.')
atmInterfaceDs3PlcpAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAlarm", 1), ("receivedFarEndAlarm", 2), ("incomingLOF", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceDs3PlcpAlarmState.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceDs3PlcpAlarmState.setDescription('This variable indicates if there is an alarm present for the DS3 PLCP. The value receivedFarEndAlarm means that the DS3 PLCP has received an incoming Yellow Signal, the value incomingLOF means that the DS3 PLCP has declared a loss of frame (LOF) failure condition, and the value noAlarm means that there are no alarms present. Transition from the failure to the no alarm state occurs when no defects (e.g., LOF) are received for more than 10 seconds.')
atmInterfaceDs3PlcpUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceDs3PlcpUASs.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceDs3PlcpUASs.setDescription('The counter associated with the number of Unavailable Seconds encountered by the PLCP.')
atmInterfaceTCTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 4), )
if mibBuilder.loadTexts: atmInterfaceTCTable.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceTCTable.setDescription('This table contains ATM interface TC Sublayer parameters and state variables, one entry per ATM interface port.')
atmInterfaceTCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmInterfaceTCEntry.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceTCEntry.setDescription('This list contains TC Sublayer parameters and state variables at the ATM interface.')
atmInterfaceOCDEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceOCDEvents.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceOCDEvents.setDescription('The number of times the Out of Cell Delineation (OCD) events occur. If seven consecutive ATM cells have Header Error Control (HEC) violations, an OCD event occurs. A high number of OCD events may indicate a problem with the TC Sublayer.')
atmInterfaceTCAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAlarm", 1), ("lcdFailure", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterfaceTCAlarmState.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceTCAlarmState.setDescription('This variable indicates if there is an alarm present for the TC Sublayer. The value lcdFailure indicates that a Loss of Cell Delineation (LCD) failure state has been declared for the TC Sublayer. Transition from failure to the no alarm state occurs when 6 consecutive ATM cells are received with valid HEC, followed by about 10 seconds of acceptable working signal.')
atmTrafficDescrParamTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5), )
if mibBuilder.loadTexts: atmTrafficDescrParamTable.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParamTable.setDescription('This table contains information on ATM traffic descriptor type and the associated parameters.')
atmTrafficDescrParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1), ).setIndexNames((0, "LEAN-MIB", "atmTrafficDescrParamIndex"))
if mibBuilder.loadTexts: atmTrafficDescrParamEntry.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParamEntry.setDescription('This list contains ATM traffic descriptor type and the associated parameters.')
atmTrafficDescrParamIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 1), AtmTrafficDescrParamIndex())
if mibBuilder.loadTexts: atmTrafficDescrParamIndex.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParamIndex.setDescription('This object is used by the virtual link table (i.e., VPL or VCL table) to identify the row of this table.')
atmTrafficDescrType = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 2), ObjectIdentifier().clone((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 1, 1))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrType.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrType.setDescription('The value of this object identifies the type of ATM traffic descriptor. The type may indicate no traffic descriptor or traffic descriptor with one or more parameters. These parameters are specified as a parameter vector, in the corresponding instances of the objects: atmTrafficDescrParam1 atmTrafficDescrParam2 atmTrafficDescrParam3 atmTrafficDescrParam4 atmTrafficDescrParam5.')
atmTrafficDescrParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam1.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParam1.setDescription('The first parameter of the ATM traffic descriptor used according to the value of atmTrafficDescrType.')
atmTrafficDescrParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam2.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParam2.setDescription('The second parameter of the ATM traffic descriptor used according to the value of atmTrafficDescrType.')
atmTrafficDescrParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam3.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParam3.setDescription('The third parameter of the ATM traffic descriptor used according to the value of atmTrafficDescrType.')
atmTrafficDescrParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam4.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParam4.setDescription('The fourth parameter of the ATM traffic descriptor used according to the value of atmTrafficDescrType.')
atmTrafficDescrParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrParam5.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrParam5.setDescription('The fifth parameter of the ATM traffic descriptor used according to the value of atmTrafficDescrType.')
atmTrafficQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficQoSClass.setStatus('current')
if mibBuilder.loadTexts: atmTrafficQoSClass.setDescription("The value of this object identifies the QoS Class. Four Service classes have been specified in the ATM Forum UNI Specification: Service Class A: Constant bit rate video and Circuit emulation Service Class B: Variable bit rate video/audio Service Class C: Connection-oriented data Service Class D: Connectionless data Four QoS classes numbered 1, 2, 3, and 4 have been specified with the aim to support service classes A, B, C, and D respectively. An unspecified QoS Class numbered `0' is used for best effort traffic.")
atmTrafficDescrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 5, 1, 9), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmTrafficDescrRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrRowStatus.setDescription('This object is used to create a new row or modify or delete an existing row in this table.')
atmVplTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6), )
if mibBuilder.loadTexts: atmVplTable.setStatus('current')
if mibBuilder.loadTexts: atmVplTable.setDescription('The Virtual Path Link (VPL) table. A bi-directional VPL is modeled as one entry in this table.')
atmVplEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "LEAN-MIB", "atmVplVpi"))
if mibBuilder.loadTexts: atmVplEntry.setStatus('current')
if mibBuilder.loadTexts: atmVplEntry.setDescription("An entry in the VPL table. This entry is used to model a bi-directional VPL. To create a VPL at an ATM interface, either of the following procedures are used: Negotiated VPL establishment (1) The management application creates a VPL entry in the atmVplTable by setting atmVplRowStatus to createAndWait(5). This may fail for the following reasons: - The selected VPI value is unavailable, - The selected VPI value is in use. Otherwise, the agent creates a row and reserves the VPI value on that port. (2) The manager selects an existing row(s) in the atmTrafficDescrParamTable, thereby, selecting a set of self-consistent ATM traffic parameters and the QoS Class for receive and transmit directions of the VPL. (2a) If no suitable row(s) in the atmTrafficDescrParamTable exists, the manager must create a new row(s) in that table. (2b) The manager characterizes the VPL's traffic parameters through setting the atmVplReceiveTrafficDescrIndex and the atmVplTransmitTrafficDescrIndex values in the VPL table, which point to the rows containing desired ATM traffic parameter values in the atmTrafficDescrParamTable. The agent will check the availability of resources and may refuse the request. (3) The manager activates the VPL by setting the the atmVplRowStatus to active(1). If this set is successful, the agent has reserved the resources to satisfy the requested traffic parameter values and the QoS Class for that VPL. (4) If the VPL terminates a VPC in the ATM host or switch, the manager turns on the atmVplAdminStatus to up(1) to turn the VPL traffic flow on. Otherwise, the atmVpCrossConnectTable must be used to cross-connect the VPL to another VPL(s) in an ATM switch or network. One-Shot VPL Establishment A VPL may also be established in one step by a set-request with all necessary VPL parameter values and atmVplRowStatus set to createAndGo(4). In contrast to the negotiated VPL establishment which allows for detailed error checking (i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VPL establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VPL Retirement A VPL is released by setting atmVplRowStatus to destroy(6), and the agent may release all associated resources.")
atmVplVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: atmVplVpi.setStatus('current')
if mibBuilder.loadTexts: atmVplVpi.setDescription('The VPI value of the VPL. Note that the VPI=0 is not used for a VPL not associated with a VCL. The maximum VPI value cannot exceed the value allowable by the atmInterfaceMaxVpiBits.')
atmVplAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmVplAdminStatus.setDescription('This object is implemented only for a VPL which terminates a VPC (i.e., one which is NOT cross-connected to other VPLs). Its value specifies the desired administrative state of the VPL. The up and down states indicate that the traffic flow is enabled and disabled respectively for this VPL.')
atmVplOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmVplOperStatus.setDescription('This object indicates the current operational status of the VPL. The up and down states indicate that the VPL is currently operational, or not operational, respectively. The unknown state indicates that the status of this VPL cannot be determined.')
atmVplLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplLastChange.setStatus('current')
if mibBuilder.loadTexts: atmVplLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VPL entered its current operational state. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmVplReceiveTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1, 5), AtmTrafficDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplReceiveTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmVplReceiveTrafficDescrIndex.setDescription('The value of this object identifies the row in the atmTrafficDescrParamTable which applies to the receive direction of the VPL.')
atmVplTransmitTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1, 6), AtmTrafficDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplTransmitTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmVplTransmitTrafficDescrIndex.setDescription('The value of this object identifies the row in the atmTrafficDescrParamTable which applies to the transmit direction of the VPL.')
atmVplCrossConnectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVplCrossConnectIdentifier.setStatus('current')
if mibBuilder.loadTexts: atmVplCrossConnectIdentifier.setDescription('This object is implemented only for a VPL which is cross-connected to other VPLs that belong to the same VPC. All such associated VPLs have the same value of this object, and all their cross-connections are identified by entries in the atmVpCrossConnectTable for which atmVpCrossConnectIndex has the same value. The value of this object is initialized by the agent after the associated entries in the atmVpCrossConnectTable have been created.')
atmVplRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 6, 1, 8), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVplRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmVplRowStatus.setDescription("This object is used to create, delete or modify a row in this table. To create a new VCL, this object is initially set to 'createAndWait' or 'createAndGo'. This object must not be set to 'active' unless the following columnar objects exist in this row: atmVplReceiveTrafficDescrIndex and atmVplTransmitTrafficDescrIndex.")
atmVclTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7), )
if mibBuilder.loadTexts: atmVclTable.setStatus('current')
if mibBuilder.loadTexts: atmVclTable.setDescription('The Virtual Channel Link (VCL) table. A bi-directional VCL is modeled as one entry in this table.')
atmVclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "LEAN-MIB", "atmVclVpi"), (0, "LEAN-MIB", "atmVclVci"))
if mibBuilder.loadTexts: atmVclEntry.setStatus('current')
if mibBuilder.loadTexts: atmVclEntry.setDescription("An entry in the VCL table. This entry is used to model a bi-directional VCL. To create a VCL at an ATM interface, either of the following procedures are used: Negotiated VCL establishment (1) The management application creates a VCL entry in the atmVclTable by setting atmVclRowStatus to createAndWait(5). This may fail for the following reasons: - The selected VPI/VCI values are unavailable, - The selected VPI/VCI values are in use. Otherwise, the agent creates a row and reserves the VPI/VCI values on that port. (2) The manager selects an existing row(s) in the atmTrafficDescrParamTable, thereby, selecting a set of self-consistent ATM traffic parameters and the QoS Class for receive and transmit directions of the VCL. (2a) If no suitable row(s) in the atmTrafficDescrParamTable exists, the manager must create a new row(s) in that table. (2b) The manager characterizes the VCL's traffic parameters through setting the atmVclReceiveTrafficDescrIndex and the atmVclTransmitTrafficDescrIndex values in the VCL table, which point to the rows containing desired ATM traffic parameter values in the atmTrafficDescrParamTable. The agent will check the availability of resources and may refuse the request. (3) The manager activates the VCL by setting the the atmVclRowStatus to active(1). If this set is successful, the agent has reserved the resources to satisfy the requested traffic parameter values and the QoS Class for that VCL. (4) If the VCL terminates a VCC in the ATM host or switch, the manager turns on the atmVclAdminStatus to up(1) to turn the VCL traffic flow on. Otherwise, the atmVcCrossConnectTable must be used to cross-connect the VCL to another VCL(s) in an ATM switch or network. One-Shot VCL Establishment A VCL may also be established in one step by a set-request with all necessary VCL parameter values and atmVclRowStatus set to createAndGo(4). In contrast to the negotiated VCL establishment which allows for detailed error checking (i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VCL establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VCL Retirement A VCL is released by setting atmVclRowStatus to destroy(6), and the agent may release all associated resources.")
atmVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: atmVclVpi.setStatus('current')
if mibBuilder.loadTexts: atmVclVpi.setDescription('The VPI value of the VCL. The maximum VPI value cannot exceed the value allowable by the atmInterfaceMaxVpiBits.')
atmVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: atmVclVci.setStatus('current')
if mibBuilder.loadTexts: atmVclVci.setDescription('The VCI value of the VCL. The maximum VCI value cannot exceed the value allowable by the atmInterfaceMaxVciBits.')
atmVclAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmVclAdminStatus.setDescription('This object is implemented only for a VCL which terminates a VCC (i.e., one which is NOT cross-connected to other VCLs). Its value specifies the desired administrative state of the VCL. The up and down states indicate that the traffic flow is enabled and disabled respectively for this VCL.')
atmVclOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmVclOperStatus.setDescription('This object indicates the current operational status of the VCL. The up and down states indicate that the VCL is currently operational, or not operational, respectively. The unknown state indicates that the status of this VCL cannot be determined.')
atmVclLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclLastChange.setStatus('current')
if mibBuilder.loadTexts: atmVclLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VCL entered its current operational state. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmVclReceiveTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 6), AtmTrafficDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclReceiveTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmVclReceiveTrafficDescrIndex.setDescription('The value of this object identifies the row in the ATM Traffic Descriptor Table which applies to the receive direction of this VCL.')
atmVclTransmitTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 7), AtmTrafficDescrParamIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclTransmitTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: atmVclTransmitTrafficDescrIndex.setDescription('The value of this object identifies the row of the ATM Traffic Descriptor Table which applies to the transmit direction of this VCL.')
atmVccAalType = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("aal1", 1), ("aal34", 2), ("aal5", 3), ("other", 4), ("unknown", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVccAalType.setStatus('current')
if mibBuilder.loadTexts: atmVccAalType.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL is in use. The type of AAL used on this VCC. The AAL type includes AAL1, AAL3/4, and AAL5. The other(4) may be user-defined AAL type. The unknown type indicates that the AAL type cannot be determined.')
atmVccAal5CpcsTransmitSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(9188)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVccAal5CpcsTransmitSduSize.setStatus('current')
if mibBuilder.loadTexts: atmVccAal5CpcsTransmitSduSize.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL5 is in use. The maximum AAL5 CPCS SDU size in octets that is supported on the transmit direction of this VCC.')
atmVccAal5CpcsReceiveSduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(9188)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVccAal5CpcsReceiveSduSize.setStatus('current')
if mibBuilder.loadTexts: atmVccAal5CpcsReceiveSduSize.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL5 is in use. The maximum AAL5 CPCS SDU size in octets that is supported on the receive direction of this VCC.')
atmVccAal5EncapsType = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("vcMultiplexRoutedProtocol", 1), ("vcMultiplexBridgedProtocol8023", 2), ("vcMultiplexBridgedProtocol8025", 3), ("vcMultiplexBridgedProtocol8026", 4), ("vcMultiplexLANemulation8023", 5), ("vcMultiplexLANemulation8025", 6), ("llcEncapsulation", 7), ("multiprotocolFrameRelaySscs", 8), ("other", 9), ("unknown", 10))).clone('llcEncapsulation')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVccAal5EncapsType.setStatus('current')
if mibBuilder.loadTexts: atmVccAal5EncapsType.setDescription('An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL5 is in use. The type of data encapsulation used over the AAL5 SSCS layer. The definitions reference RFC 1483 Multiprotocol Encapsulation over ATM AAL5 and to the ATM Forum LAN Emulation specification.')
atmVclCrossConnectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVclCrossConnectIdentifier.setStatus('current')
if mibBuilder.loadTexts: atmVclCrossConnectIdentifier.setDescription('This object is implemented only for a VCL which is cross-connected to other VCLs that belong to the same VCC. All such associated VCLs have the same value of this object, and all their cross-connections are identified by entries in the atmVcCrossConnectTable for which atmVcCrossConnectIndex has the same value. The value of this object is initialized by the agent after the associated entries in the atmVcCrossConnectTable have been created.')
atmVclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 7, 1, 13), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVclRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmVclRowStatus.setDescription("This object is used to create, delete or modify a row in this table. To create a new VCL, this object is initially set to 'createAndWait' or 'createAndGo'. This object must not be set to 'active' unless the following columnar objects exist in this row: atmVclReceiveTrafficDescrIndex, atmVclTransmitTrafficDescrIndex. In addition, if the local VCL end-point is also the VCC end-point: atmVccAalType. In addition, for AAL5 connections only: atmVccAal5CpcsTransmitSduSize, atmVccAal5CpcsReceiveSduSize, and atmVccAal5EncapsType.")
atmVpCrossConnectIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectIndexNext.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectIndexNext.setDescription('This object contains an appropriate value to be used for atmVpCrossConnectIndex when creating entries in the atmVpCrossConnectTable. The value 0 indicates that no unassigned entries are available. To obtain the atmVpCrossConnectIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index.')
atmVpCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9), )
if mibBuilder.loadTexts: atmVpCrossConnectTable.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectTable.setDescription('The ATM VP Cross Connect table. A bi- directional VP cross-connect which cross-connects two VPLs is modeled as one entry in this table.')
atmVpCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1), ).setIndexNames((0, "LEAN-MIB", "atmVpCrossConnectIndex"), (0, "LEAN-MIB", "atmVpCrossConnectLowIfIndex"), (0, "LEAN-MIB", "atmVpCrossConnectLowVpi"), (0, "LEAN-MIB", "atmVpCrossConnectHighIfIndex"), (0, "LEAN-MIB", "atmVpCrossConnectHighVpi"))
if mibBuilder.loadTexts: atmVpCrossConnectEntry.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectEntry.setDescription('An entry in the ATM VP Cross Connect table. This entry is used to model a bi-directional ATM VP cross-connect which cross-connects two VPLs. Step-wise Procedures to set up a VP Cross-connect Once the entries in the atmVplTable are created, the following procedures are used to cross-connect the VPLs together. (1) The manager obtains a unique atmVpCrossConnectIndex by reading the atmVpCrossConnectIndexNext object. (2) Next, the manager creates a set of one or more rows in the ATM VP Cross Connect Table, one for each cross-connection between two VPLs. Each row is indexed by the ATM interface port numbers and VPI values of the two ends of that cross-connection. This set of rows specifies the topology of the VPC cross-connect and is identified by a single value of atmVpCrossConnectIndex. Negotiated VP Cross-Connect Establishment (2a) The manager creates a row in this table by setting atmVpCrossConnectRowStatus to createAndWait(5). The agent checks the requested topology and the mutual sanity of the ATM traffic parameters and QoS Classes, i.e., the row creation fails if: - the requested topology is not supported by the agent, - the traffic/QoS parameter values associated with the requested row are incompatible with those of already existing rows for this VP cross-connect. [For example, for setting up a point-to-point VP cross-connect, the ATM traffic parameters in the receive direction of a VPL at the low end of the cross-connect must equal to the traffic parameters in the transmit direction of the other VPL at the high end of the cross-connect, otherwise, the row creation fails.] The agent also checks for internal errors in building the cross-connect. The atmVpCrossConnectIndex values in the corresponding atmVplTable rows are filled in by the agent at this point. (2b) The manager promotes the row in the atmVpCrossConnectTable by setting atmVpCrossConnectRowStatus to active(1). If this set is successful, the agent has reserved the resources specified by the ATM traffic parameter and QoS Class values for each direction of the VP cross-connect in an ATM switch or network. (3) The manager sets the atmVpCrossConnectAdminStatus to up(1) in all rows of this VP cross-connect to turn the traffic flow on. One-Shot VP Cross-Connect Establishment A VP cross-connect may also be established in one step by a set-request with all necessary parameter values and atmVpCrossConnectRowStatus set to createAndGo(4). In contrast to the negotiated VP cross-connect establishment which allows for detailed error checking (i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VP cross-connect establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VP Cross-Connect Retirement A VP cross-connect identified by a particular value of atmVpCrossConnectIndex is released by: (1) Setting atmVpCrossConnectRowStatus of all rows identified by this value of atmVpCrossConnectIndex to destroy(6). The agent may release all associated resources, and the atmVpCrossConnectIndex values in the corresponding atmVplTable row are removed. Note that a situation when only a subset of the associated rows are deleted corresponds to a VP topology change. (2) After deletion of the appropriate atmVpCrossConnectEntries, the manager may set atmVplRowStatus to destroy(6) the associated VPLs. The agent releases the resources and removes the associated rows in the atmVplTable. VP Cross-connect Reconfiguration At the discretion of the agent, a VP cross-connect may be reconfigured by adding and/or deleting leafs to/from the VP topology as per the VP cross-connect establishment/retirement procedures. Reconfiguration of traffic/QoS parameter values requires release of the VP cross-connect before those parameter values may by changed for individual VPLs.')
atmVpCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmVpCrossConnectIndex.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectIndex.setDescription('A unique value to identify this VP cross-connect.')
atmVpCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 2), IfIndex())
if mibBuilder.loadTexts: atmVpCrossConnectLowIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectLowIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM interface port for this VP cross-connect. The term low implies that this ATM interface has the numerically lower ifIndex value than the other ATM interface identified in the same atmVpCrossConnectEntry.")
atmVpCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: atmVpCrossConnectLowVpi.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VP cross-connect that is identified by atmVpCrossConnectLowIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
atmVpCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 4), IfIndex())
if mibBuilder.loadTexts: atmVpCrossConnectHighIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectHighIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM interface port for this VP cross-connect. The term high implies that this ATM interface has the numerically higher ifIndex value than the other ATM interface identified in the same atmVpCrossConnectEntry.")
atmVpCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: atmVpCrossConnectHighVpi.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VP cross-connect that is identified by atmVpCrossConnectHighIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
atmVpCrossConnectAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectAdminStatus.setDescription('The value of this object identifies the desired administrative status of this bi-directional VP cross-connect. The up and down states indicate that the traffic flow is enabled and disabled respectively on this VP cross-connect.')
atmVpCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectL2HOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectL2HOperStatus.setDescription('The value of this object identifies the current operational status of the VP cross-connect in one direction; (i.e., from the low to high direction). The up and down states indicate that this ATM VP cross-connect from low to high direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
atmVpCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectH2LOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectH2LOperStatus.setDescription('The value of this object identifies the current operational status of the VP cross-connect in one direction; (i.e., from the high to low direction). The up and down states indicate that this ATM VP cross-connect from high to low direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
atmVpCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectL2HLastChange.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectL2HLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VP cross-connect entered its current operational state in the low to high direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmVpCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVpCrossConnectH2LLastChange.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectH2LLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VP cross-connect entered its current operational state in the high to low direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmVpCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 9, 1, 11), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVpCrossConnectRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectRowStatus.setDescription("The status of this entry in the atmVpCrossConnectTable. This object is used to create a cross-connect for cross-connecting VPLs which are created using the atmVplTable or to change or delete an existing cross-connect. This object must be initially set to `createAndWait' or 'createAndGo'. This object cannot be set to `active' unless the following columnar object exists in this row: atmVpCrossConnectAdminStatus. To turn on a VP cross-connect, the atmVpCrossConnectAdminStatus is set to `up'.")
atmVcCrossConnectIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectIndexNext.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectIndexNext.setDescription('This object contains an appropriate value to be used for atmVcCrossConnectIndex when creating entries in the atmVcCrossConnectTable. The value 0 indicates that no unassigned entries are available. To obtain the atmVpCrossConnectIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval, the agent should modify the value to the next unassigned index.')
atmVcCrossConnectTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11), )
if mibBuilder.loadTexts: atmVcCrossConnectTable.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectTable.setDescription('The ATM VC Cross Connect table. A bi- directional VC cross-connect which cross-connects two end points (i.e., VCLs) is modeled as one entry in this table.')
atmVcCrossConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1), ).setIndexNames((0, "LEAN-MIB", "atmVcCrossConnectIndex"), (0, "LEAN-MIB", "atmVcCrossConnectLowIfIndex"), (0, "LEAN-MIB", "atmVcCrossConnectLowVpi"), (0, "LEAN-MIB", "atmVcCrossConnectLowVci"), (0, "LEAN-MIB", "atmVcCrossConnectHighIfIndex"), (0, "LEAN-MIB", "atmVcCrossConnectHighVpi"), (0, "LEAN-MIB", "atmVcCrossConnectHighVci"))
if mibBuilder.loadTexts: atmVcCrossConnectEntry.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectEntry.setDescription('An entry in the ATM VC Cross Connect table. This entry is used to model a bi-directional ATM VC cross-connect cross-connecting two end points. Step-wise Procedures to set up a VC Cross-connect Once the entries in the atmVclTable are created, the following procedures are used to cross-connect the VCLs together to form a VCC segment. (1) The manager obtains a unique atmVcCrossConnectIndex by reading the atmVcCrossConnectIndexNext object. (2) Next, the manager creates a set of one or more rows in the ATM VC Cross Connect Table, one for each cross-connection between two VCLs. Each row is indexed by the ATM interface port numbers and VPI/VCI values of the two ends of that cross-connection. This set of rows specifies the topology of the VCC cross-connect and is identified by a single value of atmVcCrossConnectIndex. Negotiated VC Cross-Connect Establishment (2a) The manager creates a row in this table by setting atmVcCrossConnectRowStatus to createAndWait(5). The agent checks the requested topology and the mutual sanity of the ATM traffic parameters and QoS Classes, i.e., the row creation fails if: - the requested topology is not supported by the agent, - the traffic/QoS parameter values associated with the requested row are incompatible with those of already existing rows for this VC cross-connect. [For example, for setting up a point-to-point VC cross-connect, the ATM traffic parameters in the receive direction of a VCL at the low end of the cross-connect must equal to the traffic parameters in the transmit direction of the other VCL at the high end of the cross-connect, otherwise, the row creation fails.] The agent also checks for internal errors in building the cross-connect. The atmVcCrossConnectIndex values in the corresponding atmVclTable rows are filled in by the agent at this point. (2b) The manager promotes the row in the atmVcCrossConnectTable by setting atmVcCrossConnectRowStatus to active(1). If this set is successful, the agent has reserved the resources specified by the ATM traffic parameter and QoS Class values for each direction of the VC cross-connect in an ATM switch or network. (3) The manager sets the atmVcCrossConnectAdminStatus to up(1) in all rows of this VC cross-connect to turn the traffic flow on. One-Shot VC Cross-Connect Establishment A VC cross-connect may also be established in one step by a set-request with all necessary parameter values and atmVcCrossConnectRowStatus set to createAndGo(4). In contrast to the negotiated VC cross-connect establishment which allows for detailed error checking i.e., set errors are explicitly linked to particular resource acquisition failures), the one-shot VC cross-connect establishment performs the setup on one operation but does not have the advantage of step-wise error checking. VC Cross-Connect Retirement A VC cross-connect identified by a particular value of atmVcCrossConnectIndex is released by: (1) Setting atmVcCrossConnectRowStatus of all rows identified by this value of atmVcCrossConnectIndex to destroy(6). The agent may release all associated resources, and the atmVcCrossConnectIndex values in the corresponding atmVclTable row are removed. Note that a situation when only a subset of the associated rows are deleted corresponds to a VC topology change. (2) After deletion of the appropriate atmVcCrossConnectEntries, the manager may set atmVclRowStatus to destroy(6) the associated VCLs. The agent releases the resources and removes the associated rows in the atmVclTable. VC Cross-Connect Reconfiguration At the discretion of the agent, a VC cross-connect may be reconfigured by adding and/or deleting leafs to/from the VC topology as per the VC cross-connect establishment/retirement procedures. Reconfiguration of traffic/QoS parameter values requires release of the VC cross-connect before those parameter values may by changed for individual VCLs.')
atmVcCrossConnectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmVcCrossConnectIndex.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectIndex.setDescription('A unique value to identify this VC cross-connect.')
atmVcCrossConnectLowIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 2), IfIndex())
if mibBuilder.loadTexts: atmVcCrossConnectLowIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectLowIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value of the ATM interface port for this VC cross-connect. The term low implies that this ATM interface has the numerically lower ifIndex value than the other ATM interface identified in the same atmVcCrossConnectEntry.")
atmVcCrossConnectLowVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: atmVcCrossConnectLowVpi.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectLowVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VC cross-connect that is identified by atmVcCrossConnectLowIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the low ATM interface port.')
atmVcCrossConnectLowVci = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: atmVcCrossConnectLowVci.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectLowVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with this VC cross-connect that is identified by atmVcCrossConnectLowIfIndex. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the low ATM interface port.')
atmVcCrossConnectHighIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 5), IfIndex())
if mibBuilder.loadTexts: atmVcCrossConnectHighIfIndex.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectHighIfIndex.setDescription("The value of this object is equal to MIB II's ifIndex value for the ATM interface port for this VC cross-connect. The term high implies that this VC cross-connect that this ATM interface has the numerically higher ifIndex value than the other ATM interface identified in the same atmVcCrossConnectEntry.")
atmVcCrossConnectHighVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: atmVcCrossConnectHighVpi.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectHighVpi.setDescription('The value of this object is equal to the VPI value at the ATM interface associated with the VC cross-connect that is identified by atmVcCrossConnectHighIfIndex. The VPI value cannot exceed the number supported by the atmInterfaceMaxVpiBits at the high ATM interface port.')
atmVcCrossConnectHighVci = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: atmVcCrossConnectHighVci.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectHighVci.setDescription('The value of this object is equal to the VCI value at the ATM interface associated with the VC cross-connect that is identified by atmVcCrossConnectHighIfIndex. The VCI value cannot exceed the number supported by the atmInterfaceMaxVciBits at the high ATM interface port.')
atmVcCrossConnectAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectAdminStatus.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectAdminStatus.setDescription('The value of this object identifies the desired administrative status of this bi-directional VC cross-connect. The up and down states indicate that the traffic flow is enabled or disabled respectively on this VC cross-connect.')
atmVcCrossConnectL2HOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectL2HOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectL2HOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the low to high direction). The up and down states indicate that this ATM VC cross-connect from low to high direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
atmVcCrossConnectH2LOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectH2LOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectH2LOperStatus.setDescription('The value of this object identifies the current operational status of the VC cross-connect in one direction; (i.e., from the high to low direction). The up and down states indicate that this ATM VC cross-connect from high to low direction is operational or not operational respectively. The unknown state indicates that the state of it cannot be determined.')
atmVcCrossConnectL2HLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectL2HLastChange.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectL2HLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in low to high direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmVcCrossConnectH2LLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmVcCrossConnectH2LLastChange.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectH2LLastChange.setDescription("The value of MIB II's sysUpTime object at the time this VC cross-connect entered its current operational state in high to low direction. If the current state was entered prior to the last re-initialization of the agent, then this object contains a zero value.")
atmVcCrossConnectRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 11, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmVcCrossConnectRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectRowStatus.setDescription("The status of this entry in the atmVcCrossConnectTable. This object is used to create a new cross-connect for cross-connecting VCLs which are created using the atmVclTable or to change or delete existing cross-connect. This object must be initially set to `createAndWait' or 'createAndGo'. This object cannot be set to `active' unless the following columnar object exists in this row: atmVcCrossConnectAdminStatus. To turn on a VC cross-connect, the atmVcCrossConnectAdminStatus is set to `up'.")
aal5VccTable = MibTable((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 12), )
if mibBuilder.loadTexts: aal5VccTable.setStatus('current')
if mibBuilder.loadTexts: aal5VccTable.setDescription('This table contains AAL5 VCC performance parameters.')
aal5VccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 12, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "LEAN-MIB", "aal5VccVpi"), (0, "LEAN-MIB", "aal5VccVci"))
if mibBuilder.loadTexts: aal5VccEntry.setStatus('current')
if mibBuilder.loadTexts: aal5VccEntry.setDescription('This list contains the AAL5 VCC performance parameters.')
aal5VccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: aal5VccVpi.setStatus('current')
if mibBuilder.loadTexts: aal5VccVpi.setDescription('The VPI value of the AAL5 VCC at the interface identified by the ifIndex.')
aal5VccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: aal5VccVci.setStatus('current')
if mibBuilder.loadTexts: aal5VccVci.setDescription('The VCI value of the AAL5 VCC at the interface identified by the ifIndex.')
aal5VccCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5VccCrcErrors.setStatus('current')
if mibBuilder.loadTexts: aal5VccCrcErrors.setDescription('The number of AAL5 CPCS PDUs received with CRC-32 errors on this AAL5 VCC at the interface associated with an AAL5 entity.')
aal5VccSarTimeOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5VccSarTimeOuts.setStatus('current')
if mibBuilder.loadTexts: aal5VccSarTimeOuts.setDescription('The number of partially re-assembled AAL5 CPCS PDUs which were discarded on this AAL5 VCC at the interface associated with an AAL5 entity because they were not fully re-assembled within the required time period. If the re-assembly timer is not supported, then this object contains a zero value.')
aal5VccOverSizedSDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 42, 1, 2, 1, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5VccOverSizedSDUs.setStatus('current')
if mibBuilder.loadTexts: aal5VccOverSizedSDUs.setDescription('The number of AAL5 CPCS PDUs discarded on this AAL5 VCC at the interface associated with an AAL5 entity because the AAL5 SDUs were too large.')
atmMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 2, 2))
atmMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1))
atmMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 2))
atmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 2, 1)).setObjects(("LEAN-MIB", "atmInterfaceConfGroup"), ("LEAN-MIB", "atmTrafficDescrGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmMIBCompliance = atmMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: atmMIBCompliance.setDescription('The compliance statement for SNMP entities including networks which have ATM and AAL5 interfaces.')
atmInterfaceConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 1)).setObjects(("LEAN-MIB", "atmInterfaceMaxVpcs"), ("LEAN-MIB", "atmInterfaceMaxVccs"), ("LEAN-MIB", "atmInterfaceConfVpcs"), ("LEAN-MIB", "atmInterfaceConfVccs"), ("LEAN-MIB", "atmInterfaceMaxActiveVpiBits"), ("LEAN-MIB", "atmInterfaceMaxActiveVciBits"), ("LEAN-MIB", "atmInterfaceIlmiVpi"), ("LEAN-MIB", "atmInterfaceIlmiVci"), ("LEAN-MIB", "atmInterfaceAddressType"), ("LEAN-MIB", "atmInterfaceAdminAddress"), ("LEAN-MIB", "atmInterfaceMyNeighborIpAddress"), ("LEAN-MIB", "atmInterfaceMyNeighborIfName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmInterfaceConfGroup = atmInterfaceConfGroup.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceConfGroup.setDescription('A collection of objects providing configuration information about an ATM interface.')
atmTrafficDescrGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 2)).setObjects(("LEAN-MIB", "atmTrafficDescrType"), ("LEAN-MIB", "atmTrafficDescrParam1"), ("LEAN-MIB", "atmTrafficDescrParam2"), ("LEAN-MIB", "atmTrafficDescrParam3"), ("LEAN-MIB", "atmTrafficDescrParam4"), ("LEAN-MIB", "atmTrafficDescrParam5"), ("LEAN-MIB", "atmTrafficQoSClass"), ("LEAN-MIB", "atmTrafficDescrRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmTrafficDescrGroup = atmTrafficDescrGroup.setStatus('current')
if mibBuilder.loadTexts: atmTrafficDescrGroup.setDescription('A collection of objects providing information about ATM traffic descriptor type and the associated parameters.')
atmInterfaceDs3PlcpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 3)).setObjects(("LEAN-MIB", "atmInterfaceDs3PlcpSEFSs"), ("LEAN-MIB", "atmInterfaceDs3PlcpAlarmState"), ("LEAN-MIB", "atmInterfaceDs3PlcpUASs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmInterfaceDs3PlcpGroup = atmInterfaceDs3PlcpGroup.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceDs3PlcpGroup.setDescription('A collection of objects providing information about DS3 PLCP layer at an ATM interface.')
atmInterfaceTCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 4)).setObjects(("LEAN-MIB", "atmInterfaceOCDEvents"), ("LEAN-MIB", "atmInterfaceTCAlarmState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmInterfaceTCGroup = atmInterfaceTCGroup.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceTCGroup.setDescription('A collection of objects providing information about TC sublayer at an ATM interface.')
atmVpcTerminationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 5)).setObjects(("LEAN-MIB", "atmVplOperStatus"), ("LEAN-MIB", "atmVplAdminStatus"), ("LEAN-MIB", "atmVplLastChange"), ("LEAN-MIB", "atmVplReceiveTrafficDescrIndex"), ("LEAN-MIB", "atmVplTransmitTrafficDescrIndex"), ("LEAN-MIB", "atmVplRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmVpcTerminationGroup = atmVpcTerminationGroup.setStatus('current')
if mibBuilder.loadTexts: atmVpcTerminationGroup.setDescription('A collection of objects providing information about a VPL at an ATM interface which terminates a VPC (i.e., one which is NOT cross-connected to other VPLs).')
atmVccTerminationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 6)).setObjects(("LEAN-MIB", "atmVclOperStatus"), ("LEAN-MIB", "atmVclAdminStatus"), ("LEAN-MIB", "atmVclLastChange"), ("LEAN-MIB", "atmVclReceiveTrafficDescrIndex"), ("LEAN-MIB", "atmVclTransmitTrafficDescrIndex"), ("LEAN-MIB", "atmVccAalType"), ("LEAN-MIB", "atmVclRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmVccTerminationGroup = atmVccTerminationGroup.setStatus('current')
if mibBuilder.loadTexts: atmVccTerminationGroup.setDescription('A collection of objects providing information about a VCL at an ATM interface which terminates a VCC (i.e., one which is NOT cross-connected to other VCLs).')
atmVpCrossConnectGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 7)).setObjects(("LEAN-MIB", "atmVplReceiveTrafficDescrIndex"), ("LEAN-MIB", "atmVplTransmitTrafficDescrIndex"), ("LEAN-MIB", "atmVplOperStatus"), ("LEAN-MIB", "atmVplRowStatus"), ("LEAN-MIB", "atmVpCrossConnectAdminStatus"), ("LEAN-MIB", "atmVpCrossConnectL2HOperStatus"), ("LEAN-MIB", "atmVpCrossConnectH2LOperStatus"), ("LEAN-MIB", "atmVpCrossConnectL2HLastChange"), ("LEAN-MIB", "atmVpCrossConnectH2LLastChange"), ("LEAN-MIB", "atmVpCrossConnectRowStatus"), ("LEAN-MIB", "atmVplCrossConnectIdentifier"), ("LEAN-MIB", "atmVpCrossConnectIndexNext"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmVpCrossConnectGroup = atmVpCrossConnectGroup.setStatus('current')
if mibBuilder.loadTexts: atmVpCrossConnectGroup.setDescription('A collection of objects providing information about a VP cross-connect and the associated VPLs that are cross-connected together.')
atmVcCrossConnectGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 8)).setObjects(("LEAN-MIB", "atmVclReceiveTrafficDescrIndex"), ("LEAN-MIB", "atmVclTransmitTrafficDescrIndex"), ("LEAN-MIB", "atmVclOperStatus"), ("LEAN-MIB", "atmVclRowStatus"), ("LEAN-MIB", "atmVcCrossConnectAdminStatus"), ("LEAN-MIB", "atmVcCrossConnectL2HOperStatus"), ("LEAN-MIB", "atmVcCrossConnectH2LOperStatus"), ("LEAN-MIB", "atmVcCrossConnectL2HLastChange"), ("LEAN-MIB", "atmVcCrossConnectH2LLastChange"), ("LEAN-MIB", "atmVcCrossConnectRowStatus"), ("LEAN-MIB", "atmVclCrossConnectIdentifier"), ("LEAN-MIB", "atmVcCrossConnectIndexNext"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmVcCrossConnectGroup = atmVcCrossConnectGroup.setStatus('current')
if mibBuilder.loadTexts: atmVcCrossConnectGroup.setDescription('A collection of objects providing information about a VC cross-connect and the associated VCLs that are cross-connected together.')
aal5VccGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 42, 1, 2, 2, 1, 9)).setObjects(("LEAN-MIB", "atmVccAal5CpcsTransmitSduSize"), ("LEAN-MIB", "atmVccAal5CpcsReceiveSduSize"), ("LEAN-MIB", "atmVccAal5EncapsType"), ("LEAN-MIB", "aal5VccCrcErrors"), ("LEAN-MIB", "aal5VccSarTimeOuts"), ("LEAN-MIB", "aal5VccOverSizedSDUs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aal5VccGroup = aal5VccGroup.setStatus('current')
if mibBuilder.loadTexts: aal5VccGroup.setDescription('A collection of objects providing AAL5 configuration and performance statistics of a VCC.')
mibBuilder.exportSymbols("LEAN-MIB", frPVCEndptInDEFrames=frPVCEndptInDEFrames, frnetservGroups=frnetservGroups, frPVCConnectHighDLCIIndex=frPVCConnectHighDLCIIndex, frPVCEndptOutOctets=frPVCEndptOutOctets, frnetservTraps=frnetservTraps, atmVplLastChange=atmVplLastChange, frMgtVCSigNetnT3=frMgtVCSigNetnT3, atmVclLastChange=atmVclLastChange, atmVplOperStatus=atmVplOperStatus, atmTrafficDescrParam4=atmTrafficDescrParam4, atmInterfaceIlmiVpi=atmInterfaceIlmiVpi, atmTrafficDescrParamTable=atmTrafficDescrParamTable, atmMIBObjects=atmMIBObjects, atmVplRowStatus=atmVplRowStatus, atmMIB=atmMIB, frMgtVCSigNetN393=frMgtVCSigNetN393, atmInterfaceDs3PlcpEntry=atmInterfaceDs3PlcpEntry, frPVCConnectRowStatus=frPVCConnectRowStatus, atmVcCrossConnectL2HLastChange=atmVcCrossConnectL2HLastChange, atmVcCrossConnectHighVci=atmVcCrossConnectHighVci, frPVCConnectH2lLastChange=frPVCConnectH2lLastChange, atmClpNoTaggingScr=atmClpNoTaggingScr, atmVccAal5EncapsType=atmVccAal5EncapsType, frnetservAccountPVCGroup=frnetservAccountPVCGroup, atmInterfaceConfVccs=atmInterfaceConfVccs, atmVplReceiveTrafficDescrIndex=atmVplReceiveTrafficDescrIndex, atmVplEntry=atmVplEntry, atmVcCrossConnectIndexNext=atmVcCrossConnectIndexNext, atmVpCrossConnectAdminStatus=atmVpCrossConnectAdminStatus, frLportContact=frLportContact, atmVpCrossConnectHighIfIndex=atmVpCrossConnectHighIfIndex, atmVclReceiveTrafficDescrIndex=atmVclReceiveTrafficDescrIndex, frLportEntry=frLportEntry, atmInterfaceMaxActiveVciBits=atmInterfaceMaxActiveVciBits, atmInterfaceTCAlarmState=atmInterfaceTCAlarmState, PYSNMP_MODULE_ID=tellabs, frPVCEndptInMaxFrameSize=frPVCEndptInMaxFrameSize, frAccountPVCEntry=frAccountPVCEntry, frPVCConnectL2hLastChange=frPVCConnectL2hLastChange, atmNoTrafficDescriptor=atmNoTrafficDescriptor, frPVCEndptTable=frPVCEndptTable, atmInterfaceConfVpcs=atmInterfaceConfVpcs, atmMIBGroups=atmMIBGroups, atmTrafficDescrGroup=atmTrafficDescrGroup, frAccountPVCDLCIIndex=frAccountPVCDLCIIndex, aal5VccCrcErrors=aal5VccCrcErrors, atmVclTable=atmVclTable, atmInterfaceMyNeighborIfName=atmInterfaceMyNeighborIfName, atmVccTerminationGroup=atmVccTerminationGroup, IfIndex=IfIndex, atmVcCrossConnectL2HOperStatus=atmVcCrossConnectL2HOperStatus, frnetservPVCEndptGroup=frnetservPVCEndptGroup, frMgtVCSigNetProtErrors=frMgtVCSigNetProtErrors, frLportLocation=frLportLocation, atmVcCrossConnectHighVpi=atmVcCrossConnectHighVpi, atmVpCrossConnectL2HLastChange=atmVpCrossConnectL2HLastChange, frPVCConnectStatusChange=frPVCConnectStatusChange, aal5VccVpi=aal5VccVpi, frPVCEndptConnectIdentifier=frPVCEndptConnectIdentifier, frLportNumPlan=frLportNumPlan, frLportTable=frLportTable, frMgtVCSigNetN392=frMgtVCSigNetN392, frMgtVCSigUserChanInactive=frMgtVCSigUserChanInactive, frPVCEndptRcvdSigStatus=frPVCEndptRcvdSigStatus, atmTrafficDescrParam1=atmTrafficDescrParam1, atmVpCrossConnectIndex=atmVpCrossConnectIndex, atmMIBConformance=atmMIBConformance, frPVCEndptInFrames=frPVCEndptInFrames, atmTrafficDescrParamEntry=atmTrafficDescrParamEntry, atmVplVpi=atmVplVpi, atmVccAalType=atmVccAalType, atmVpCrossConnectEntry=atmVpCrossConnectEntry, frPVCConnectH2lOperStatus=frPVCConnectH2lOperStatus, atmVclVpi=atmVclVpi, frPVCEndptOutBe=frPVCEndptOutBe, atmInterfaceMyNeighborIpAddress=atmInterfaceMyNeighborIpAddress, frPVCConnectTable=frPVCConnectTable, atmVclAdminStatus=atmVclAdminStatus, frPVCEndptOutCIR=frPVCEndptOutCIR, frPVCEndptInOctets=frPVCEndptInOctets, frPVCConnectLowIfIndex=frPVCConnectLowIfIndex, frPVCEndptInCIR=frPVCEndptInCIR, aal5VccTable=aal5VccTable, atmVpcTerminationGroup=atmVpcTerminationGroup, frPVCEndptInBe=frPVCEndptInBe, frnetservCompliances=frnetservCompliances, atmClpNoTaggingNoScr=atmClpNoTaggingNoScr, frLportVCSigProtocol=frLportVCSigProtocol, frnetservMgtVCSigGroup=frnetservMgtVCSigGroup, atmClpTaggingScr=atmClpTaggingScr, atmVpCrossConnectRowStatus=atmVpCrossConnectRowStatus, frnetservObjects=frnetservObjects, atmVpCrossConnectGroup=atmVpCrossConnectGroup, atmMIBCompliance=atmMIBCompliance, frPVCEndptEntry=frPVCEndptEntry, frMgtVCSigTable=frMgtVCSigTable, frAccountLportSegmentSize=frAccountLportSegmentSize, atmInterfaceDs3PlcpSEFSs=atmInterfaceDs3PlcpSEFSs, atmVclTransmitTrafficDescrIndex=atmVclTransmitTrafficDescrIndex, atmVpCrossConnectL2HOperStatus=atmVpCrossConnectL2HOperStatus, leanMIB=leanMIB, frPVCEndptOutBc=frPVCEndptOutBc, atmClpTaggingNoScr=atmClpTaggingNoScr, atmVcCrossConnectTable=atmVcCrossConnectTable, atmVpCrossConnectLowIfIndex=atmVpCrossConnectLowIfIndex, atmTrafficDescrParamIndex=atmTrafficDescrParamIndex, atmVcCrossConnectEntry=atmVcCrossConnectEntry, atmVcCrossConnectGroup=atmVcCrossConnectGroup, atmInterfaceMaxVpcs=atmInterfaceMaxVpcs, atmTrafficDescrParam2=atmTrafficDescrParam2, frPVCEndptRowStatus=frPVCEndptRowStatus, atmVpCrossConnectH2LLastChange=atmVpCrossConnectH2LLastChange, frMgtVCSigNetLinkRelErrors=frMgtVCSigNetLinkRelErrors, atmVccAal5CpcsTransmitSduSize=atmVccAal5CpcsTransmitSduSize, frAccountLportOutSegments=frAccountLportOutSegments, atmInterfaceTCEntry=atmInterfaceTCEntry, aal5VccEntry=aal5VccEntry, atmInterfaceMaxVccs=atmInterfaceMaxVccs, atmVclRowStatus=atmVclRowStatus, frnetservMIB=frnetservMIB, atmVcCrossConnectH2LOperStatus=atmVcCrossConnectH2LOperStatus, atmVplTransmitTrafficDescrIndex=atmVplTransmitTrafficDescrIndex, atmInterfaceConfEntry=atmInterfaceConfEntry, atmTrafficDescrType=atmTrafficDescrType, atmTrafficQoSClass=atmTrafficQoSClass, frMgtVCSigNetnN4=frMgtVCSigNetnN4, atmTrafficDescrParam5=atmTrafficDescrParam5, frLportAddrDLCILen=frLportAddrDLCILen, frLportVCSigPointer=frLportVCSigPointer, frPVCConnectAdminStatus=frPVCConnectAdminStatus, frPVCConnectIndexValue=frPVCConnectIndexValue, atmNoClpNoScr=atmNoClpNoScr, atmMIBCompliances=atmMIBCompliances, frLportType=frLportType, frAccountLportEntry=frAccountLportEntry, frAccountLportInSegments=frAccountLportInSegments, atmVclVci=atmVclVci, atmVcCrossConnectLowVpi=atmVcCrossConnectLowVpi, atmNoClpScr=atmNoClpScr, frMgtVCSigNetT392=frMgtVCSigNetT392, frMgtVCSigUserProtErrors=frMgtVCSigUserProtErrors, frAccountLportTable=frAccountLportTable, atmVclOperStatus=atmVclOperStatus, atmInterfaceDs3PlcpGroup=atmInterfaceDs3PlcpGroup, frPVCEndptOutExcessFrames=frPVCEndptOutExcessFrames, frMgtVCSigUserT391=frMgtVCSigUserT391, frAccountPVCInSegments=frAccountPVCInSegments, frnetservAccountLportGroup=frnetservAccountLportGroup, atmInterfaceDs3PlcpTable=atmInterfaceDs3PlcpTable, atmInterfaceOCDEvents=atmInterfaceOCDEvents, frPVCEndptInBc=frPVCEndptInBc, frnetservConformance=frnetservConformance, frPVCConnectEntry=frPVCConnectEntry, frPVCEndptOutMaxFrameSize=frPVCEndptOutMaxFrameSize, atmInterfaceTCGroup=atmInterfaceTCGroup, atmVplAdminStatus=atmVplAdminStatus, frMgtVCSigUserN392=frMgtVCSigUserN392, AtmTrafficDescrParamIndex=AtmTrafficDescrParamIndex, frnetservLportGroup=frnetservLportGroup, atmVclEntry=atmVclEntry, atmInterfaceMaxActiveVpiBits=atmInterfaceMaxActiveVpiBits, frPVCEndptOutFrames=frPVCEndptOutFrames, atmVpCrossConnectH2LOperStatus=atmVpCrossConnectH2LOperStatus, aal5VccGroup=aal5VccGroup, frPVCConnectL2hOperStatus=frPVCConnectL2hOperStatus, atmTrafficDescrParam3=atmTrafficDescrParam3, frMgtVCSigProced=frMgtVCSigProced, atmInterfaceAdminAddress=atmInterfaceAdminAddress, frMgtVCSigUserLinkRelErrors=frMgtVCSigUserLinkRelErrors, frPVCConnectHighIfIndex=frPVCConnectHighIfIndex, atmVplCrossConnectIdentifier=atmVplCrossConnectIdentifier, atmInterfaceDs3PlcpUASs=atmInterfaceDs3PlcpUASs, atmTrafficDescriptorTypes=atmTrafficDescriptorTypes, atmVcCrossConnectH2LLastChange=atmVcCrossConnectH2LLastChange, atmVpCrossConnectTable=atmVpCrossConnectTable, aal5VccOverSizedSDUs=aal5VccOverSizedSDUs, atmVpCrossConnectHighVpi=atmVpCrossConnectHighVpi, atmVcCrossConnectLowVci=atmVcCrossConnectLowVci, atmInterfaceIlmiVci=atmInterfaceIlmiVci, frPVCEndptInExcessFrames=frPVCEndptInExcessFrames, tellabs=tellabs, frMgtVCSigNetChanInactive=frMgtVCSigNetChanInactive, frPVCConnectLowDLCIIndex=frPVCConnectLowDLCIIndex, atmVcCrossConnectHighIfIndex=atmVcCrossConnectHighIfIndex, atmVclCrossConnectIdentifier=atmVclCrossConnectIdentifier, atmInterfaceConfGroup=atmInterfaceConfGroup, frMgtVCSigEntry=frMgtVCSigEntry, frPVCConnectIndex=frPVCConnectIndex, frAccountPVCTable=frAccountPVCTable, atmVcCrossConnectRowStatus=atmVcCrossConnectRowStatus, atmVcCrossConnectIndex=atmVcCrossConnectIndex, atmVcCrossConnectAdminStatus=atmVcCrossConnectAdminStatus, atmInterfaceAddressType=atmInterfaceAddressType, atmVplTable=atmVplTable, atmVpCrossConnectIndexNext=atmVpCrossConnectIndexNext, aal5VccSarTimeOuts=aal5VccSarTimeOuts, atmTrafficDescrRowStatus=atmTrafficDescrRowStatus, atmVpCrossConnectLowVpi=atmVpCrossConnectLowVpi, frnetservPVCConnectGroup=frnetservPVCConnectGroup, atmVcCrossConnectLowIfIndex=atmVcCrossConnectLowIfIndex, frnetservCompliance=frnetservCompliance, frMgtVCSigUserN391=frMgtVCSigUserN391, aal5VccVci=aal5VccVci, atmInterfaceConfTable=atmInterfaceConfTable, frPVCEndptDLCIIndex=frPVCEndptDLCIIndex, frAccountPVCSegmentSize=frAccountPVCSegmentSize, atmInterfaceDs3PlcpAlarmState=atmInterfaceDs3PlcpAlarmState, atmInterfaceTCTable=atmInterfaceTCTable, frMgtVCSigUserN393=frMgtVCSigUserN393, atmVccAal5CpcsReceiveSduSize=atmVccAal5CpcsReceiveSduSize, frAccountPVCOutSegments=frAccountPVCOutSegments, frPVCEndptInDiscards=frPVCEndptInDiscards)

#
# PySNMP MIB module DL-NEW-DSX1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DL-NEW-DSX1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:47:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, enterprises, Bits, Unsigned32, Gauge32, Counter64, MibIdentifier, NotificationType, Integer32, IpAddress, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter32, ObjectIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "enterprises", "Bits", "Unsigned32", "Gauge32", "Counter64", "MibIdentifier", "NotificationType", "Integer32", "IpAddress", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter32", "ObjectIdentity", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

digital_link = MibIdentifier((1, 3, 6, 1, 4, 1, 300)).setLabel("digital-link")
dl_new_t1 = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200)).setLabel("dl-new-t1")
class Boolean(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class PortId(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43))
    namedValues = NamedValues(("mainNet", 1), ("aux", 2), ("otherNet", 3), ("reserved1", 4), ("reserved2", 5), ("reserved3", 6), ("ethPort", 7), ("commPort", 8), ("int-clock", 9), ("ext-clock", 10), ("data1", 11), ("data2", 12), ("data3", 13), ("data4", 14), ("data5", 15), ("data6", 16), ("data7", 17), ("data8", 18), ("data9", 19), ("data10", 20), ("data11", 21), ("data12", 22), ("data13", 23), ("data14", 24), ("data15", 25), ("data16", 26), ("data17", 27), ("data18", 28), ("data19", 29), ("data20", 30), ("data21", 31), ("data22", 32), ("data23", 33), ("data24", 34), ("data25", 35), ("data26", 36), ("data27", 37), ("data28", 38), ("data29", 39), ("data30", 40), ("data31", 41), ("data32", 42), ("noPort", 43))

class AlarmType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
    namedValues = NamedValues(("lostSignal", 1), ("lostSync", 2), ("detectedYellow", 3), ("detectedAIS", 4), ("detectedExternalAlarm", 5), ("exceededBpvThreshold", 6), ("exceededOofThreshold", 7), ("exceededCrcThreshold", 8), ("remoteAlarmBitSet", 9), ("detectedPSfailure", 10), ("detectedCntlCardMissing", 11), ("lostDlcFdlLink", 12), ("exceededIbCrcThreshold", 13), ("lostDlcInbandLink", 14), ("lmiSpoofing", 15))

class TestType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31))
    namedValues = NamedValues(("noTest", 1), ("selfTest", 2), ("netLoopback", 3), ("payloadLoopback", 4), ("dteLoopback", 5), ("loopUpRemote", 6), ("loopDownRemote", 7), ("sendQrwPattern", 8), ("send1in8Pattern", 9), ("send1in1Pattern", 10), ("send1in3Pattern", 11), ("send1in5Pattern", 12), ("send2in3Pattern", 14), ("send4in5Pattern", 15), ("send3in24Pattern", 16), ("sendAllOnePattern", 17), ("sendAllZeroPattern", 18), ("sendUser1Pattern", 19), ("sendUser2Pattern", 20), ("sendSmartJackSet", 21), ("sendSmartJackReset", 22), ("sendAPatternError", 23), ("dteNetLoopback", 24), ("reserved1", 25), ("reserved2", 26), ("reserved3", 27), ("reserved4", 28), ("reserved5", 29), ("reserved6", 30), ("lampTest", 31))

dlcUnitHwConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 1))
dlcUnitModelType = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("vxEncore", 1), ("dl100Encore", 2), ("dl1200", 3), ("dl2400", 4), ("dl600", 5), ("dl600Encore", 6), ("ensembleEncore", 7), ("soloEncore", 8), ("soloE1Encore", 9), ("ensembleE1Encore", 10), ("soloT1CSU", 11), ("ensembleT1CSU", 12), ("soloSelectT1Module", 13), ("soloSelectE1Module", 14), ("soloSelectT1", 15), ("soloSelectE1", 16), ("dl4200T1", 17), ("dl4200E1", 18), ("dl5440T1", 19), ("dl5440E1", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitModelType.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitModelType.setDescription('The unit model type.')
dlcUnitHwRev = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitHwRev.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitHwRev.setDescription('The ASCII code of the hardware revision number.')
dlcUnitHwOptions = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitHwOptions.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitHwOptions.setDescription("A bit map, reported as the sum of all the values that correspond to installed options: realTimeClock ( 1) netPortT1 ( 2) netPortE1 ( 4) auxPortT1 ( 8) auxPortE1 ( 16) otherNetT1 ( 32) otherNetE1 ( 64) reserved1 (128) reserved2 (256) reserved3 (512) `netPortT1' and `netPortE1' are mutually exclusive and one of the two will always be TRUE. `auxPortT1' and `auxPortE1' are mutually exclusive; if both are FALSE, there is no AUX port present. `otherNetT1' and `otherNetE1' are mutually exclusive; if both are FALSE, there is no CSU port present. ")
dlcUnitSwRev = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitSwRev.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitSwRev.setDescription('The ASCII code of the software revision number.')
dlcUnitDataPorts = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitDataPorts.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitDataPorts.setDescription('The number of data ports installed on the unit.')
dlcUnitRam = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitRam.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitRam.setDescription('The amount of usable ram in the unit, in KBytes.')
dlcUnitRom = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitRom.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitRom.setDescription('The amount of usable rom in the unit, in KBytes.')
dlcUnitFlash = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitFlash.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitFlash.setDescription('The amount of FLASH ROM in the unit, in KBytes. If dlcUnitFlash is 0, the Downloadable Code option is not installed.')
dlcUnitSlotNum = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitSlotNum.setDescription("The slot number the unit is in. If it's a stand alone unit, this object will return 0.")
dlcUnitMibRev = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitMibRev.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitMibRev.setDescription('The ASCII code of the MIB revision number.')
dlcUnitFeatures = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048))).clone(namedValues=NamedValues(("inband", 1), ("ipm32", 2), ("ipm96", 4), ("rmon2", 8), ("sla", 16), ("dni", 32), ("dte2", 64), ("reserved4", 128), ("reserved5", 256), ("reserved6", 512), ("reserved7", 1024), ("reserved8", 2048)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitFeatures.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitFeatures.setDescription('Feature configuration for Solo Select. The value returned is a bit mask of which feature key is on/capable when the corresponding bit is 1.')
dlcUnitConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2))
dlcUnitId = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitId.setDescription("A name that uniquely and globally identifies the unit. The Unit ID must consist of (upper-case) letters 'A'..'Z' and digits '0'..'9'. The first character of the Unit ID may not be a digit.")
dlcUnitProtectMode = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 2), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitProtectMode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitProtectMode.setDescription('When true, the unit configuration can not be changed from the front panel nor can tests be initiated or terminated from the front panel.')
dlcUnitYellowEnable = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 3), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitYellowEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitYellowEnable.setDescription('When false, yellow alarm conditions are ignored when received from a Dsx1 port, and the unit will never transmit a Yellow Alarm signal on a Dsx1 port. This applies to all ports: mainNet, aux, otherNet.')
dlcUnitNetPassFdl = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 4), PortId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitNetPassFdl.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitNetPassFdl.setDescription("Indicates which Dsx1 DTE port's FDL is connected to the `mainNet' FDL when this unit has no traffic of its own. Meaninigful values are `aux', `otherNet', and `noPort'.")
dlcUnitMainClockSource = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 5), PortId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitMainClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitMainClockSource.setDescription('This is the primary transmit timing source.')
dlcUnitAltClockSource = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 6), PortId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitAltClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitAltClockSource.setDescription('This is the alternate transmit timing source. It is used when the primary source is not available.')
dlcUnitExtClockRate = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(56, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitExtClockRate.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitExtClockRate.setDescription('The signal arriving at the BNC connector on the back of the unit, in units of KHz. Must be a multiple of 56 or 64 KHz (n*56 or n*64) or 1544. For T1 units, the largest acceptable value is 1544. For E1 units, the value can go up to 2048. For Solo CSU products, the value is fixed at 1544 and cannot be changed.')
class LoopCodeType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("standard", 1), ("alternate", 2), ("v54", 3), ("reserved1", 4), ("reserved2", 5), ("reserved3", 6), ("disable", 7))

dlcUnitFullBandwidthLoopCode = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 8), LoopCodeType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitFullBandwidthLoopCode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitFullBandwidthLoopCode.setDescription("Determines the loop codes we transmit for the Full Bandwidth Loop Up Remote and Loop Down Remote tests and the code we respond to when it's received on the NET port. For the fullBandwidthLoopCode, `v54' is an invalid value.")
dlcUnitFractionalLoopCode = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 9), LoopCodeType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitFractionalLoopCode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitFractionalLoopCode.setDescription("Determines the loop codes we transmit for the Fractional Loop Up Remote and Loop Down Remote tests and the code we respond to when it's received on fractional bandwidth.")
dlcUnitTestLength = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTestLength.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTestLength.setDescription('Determines the time interval after which tests are automatically terminated. Valid values are 0, 1, 15 and 60. 0 stands for unlimited, 1 for 1 minute, 15 for 15 minutes and 60 for 60 minutes.')
dlcUnitUserPattern1 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitUserPattern1.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitUserPattern1.setDescription("This is a sequence of the characters '0' and '1' that represents the first of two user patterns. The first character represents the first bit in the sequence.")
dlcUnitUserPattern2 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitUserPattern2.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitUserPattern2.setDescription("This is a sequence of the characters '0' and '1' that represents the second of two user patterns. The first character represents the first bit in the sequence.")
dlcUnitBlockAllAlarms = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 13), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitBlockAllAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitBlockAllAlarms.setDescription('When dlcUnitBlockAllAlarms is TRUE, the unit will never send any traps.')
dlcUnitDsx1TrapEnableTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 2, 14), )
if mibBuilder.loadTexts: dlcUnitDsx1TrapEnableTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitDsx1TrapEnableTable.setDescription('A list of traps that are related to a Dsx1 port.')
dlcDsx1TrapEnableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcDsx1TrapPortId"))
if mibBuilder.loadTexts: dlcDsx1TrapEnableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1TrapEnableEntry.setDescription('An entry in the Dsx1 Trap Enable table.')
dlcDsx1TrapPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDsx1TrapPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1TrapPortId.setDescription("Uniquely identifies this port. Valid values are `mainNet', `aux', `otherNet'.")
dlcDsx1BpvThresholdTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1BpvThresholdTrap.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1BpvThresholdTrap.setDescription('Defines Bipolar Violation Error Rate threshold in units of BPV errors per minute. When this threshold is exceeded, the unit will send a trap to the SNMP manager. The threshold is of the form M x 10 ^ -E where M is a mantissa and E the exponent. Both are single digit values. M and E are represented in this value as one number: (M) x 10 + (E). For example, the threshold 7x10^-3 BPVs/min is encoded as the integer 73. A value of 0 disables the trap altogether. Valid values for dlcDsx1BpvThresholdTrap are: 13 23 33 43 53 63 14 24 34 44 54 64 74 84 94 15 25 35 45 55 65 75 85 95 16 26 36 46 56 66 76 86 96 17 27 37 47 57 67 77 87 97 28 38 48 58 68 78 88 98 or, from 6E-3 to 2E-8. N.B. The BPV Threshold Alarm exists only for the mainNet and otherNet Port IDs, so setting the Threshold for the aux PortId will always fail. The BPV Threshold is always reported as 0 for the aux PortId.')
dlcDsx1OofThresholdTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1OofThresholdTrap.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1OofThresholdTrap.setDescription('Defines the Out Of Frame Error Rate threshold in units of OOF errors per minute. The threshold is encoded the same as dlcDsx1BpvThresholdTrap. A value of 0 disables the trap altogether. Valid values for dlcDsx1OofThresholdTap are: 12 22 22 42 52 62 72 13 23 33 43 53 63 73 83 93 14 24 34 44 54 64 74 84 94 15 25 35 45 55 65 75 85 95 36 46 56 66 76 86 96 or, from 7E-2 to 3E-6. N.B. The OOF Threshold Alarm exists only for the mainNet and otherNet Port IDs, so setting the Threshold for the aux PortId will always fail. The OOF Threshold is always reported as 0 for the aux PortId.')
dlcDsx1CrcThresholdTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1CrcThresholdTrap.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1CrcThresholdTrap.setDescription('Defines the CRC-6 Error Rate threshold in units of CRC errors per minute. The threshold is encoded the same as dlcDsx1BpvThresholdTrap. A value of 0 disables the trap altogether. Valid values for dlcDsx1CrcThresholdTrap are: 10 11 21 31 41 51 61 71 81 91 12 22 32 42 52 62 72 82 92 13 23 33 43 53 63 73 83 93 14 24 34 44 54 64 74 84 94 55 65 75 85 95 or, from 1E0 to 5E-5. N.B. The CRC Threshold Alarm exists only for the mainNet and otherNet Port IDs, so setting the Threshold for the aux PortId will always fail. The CRC Threshold is always reported as 0 for the aux PortId.')
dlcDsx1LossOfSignalTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 5), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1LossOfSignalTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1LossOfSignalTrapEnable.setDescription('Enables or disables a trap upon loss of network signal (LOS) on a Dsx1 port.')
dlcDsx1LossOfSyncTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 6), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1LossOfSyncTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1LossOfSyncTrapEnable.setDescription('Enables or disables a trap upon loss of network framing (LOF) on a Dsx1 port.')
dlcDsx1ReceiveAIStrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 7), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1ReceiveAIStrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1ReceiveAIStrapEnable.setDescription('Enables or disables a trap upon detection of AIS (Blue Alarm Signal) on a Dsx1 port.')
dlcDsx1ReceiveYellowAlarmTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 8), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1ReceiveYellowAlarmTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1ReceiveYellowAlarmTrapEnable.setDescription('Enables or disables a trap upon detection of Yellow Alarm Signal on a Dsx1 port.')
dlcDsx1ReceiveRemoteAlarmTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 9), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1ReceiveRemoteAlarmTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1ReceiveRemoteAlarmTrapEnable.setDescription("Enables or disables a trap upon detection of Remote Alarm Indicator on an E1 Dsx1 port. For T1 units, this object's value will always be read as 0 and set operations will succeed, but the value will not be changed.")
dlcDsx1PSfailureTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 10), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1PSfailureTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1PSfailureTrapEnable.setDescription("Enables or disables a trap upon a power supply failure. This object doesn't really belong in the dlcDsx1TrapEnableTable. It is specific to units that are installed in a shelf. When accessing this object, the index (portId) is ignored.")
dlcDsx1CntlCrdMissingTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 11), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1CntlCrdMissingTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1CntlCrdMissingTrapEnable.setDescription("Enables or disables a trap upon detection of a missing controller card. This object doesn't really belong in the dlcDsx1TrapEnableTable. It is specific to units that are installed in a shelf. When accessing this object, the index (portId) is ignored.")
dlcDsx1FdlLinkTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 12), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1FdlLinkTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1FdlLinkTrapEnable.setDescription('Enables or disables a trap upon detection of the remote unit is not responding to DLC FDL messages.')
dlcDsx1IbCrcThresholdTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1IbCrcThresholdTrap.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1IbCrcThresholdTrap.setDescription('Defines the In-Band CRC Error Rate threshold in units of CRC errors per minute. The threshold is encoded the same as dlcDsx1BpvThresholdTrap. A value of 0 disables the trap altogether. For the Eclipse, valid values of dlcDsx1IbCrcThresholdTrap range from 47 to 91. N.B. The CRC Threshold Alarm exists only for the mainNet port.')
dlcDsx1InbandLinkTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 14, 1, 14), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1InbandLinkTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1InbandLinkTrapEnable.setDescription('Enables or disables a trap upon detection of the inband link.')
dlcUnitDataDteLossTrapEnableTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 2, 15), )
if mibBuilder.loadTexts: dlcUnitDataDteLossTrapEnableTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitDataDteLossTrapEnableTable.setDescription('Enables or disables a trap upon the loss of signal on a Data DTE port.')
dlcDataDteLossTrapEnableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 2, 15, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcDataLossPortId"))
if mibBuilder.loadTexts: dlcDataDteLossTrapEnableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataDteLossTrapEnableEntry.setDescription('An entry in the Data DTE Loss Trap Enable table.')
dlcDataLossPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 15, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDataLossPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataLossPortId.setDescription("Uniquely identifies this port. Valid values are `data1' through `data32'.")
dlcDataLossEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 15, 1, 2), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDataLossEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataLossEnable.setDescription('Says whether to enable this trap.')
dlcUnitExternalAlarmInputTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 16), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitExternalAlarmInputTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitExternalAlarmInputTrapEnable.setDescription('Enables or disables a trap upon detection of an alarm condition on the External Alarm Input.')
dlcUnitExternalAlarmInputContacts = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normallyOpen", 1), ("normallyClosed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitExternalAlarmInputContacts.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitExternalAlarmInputContacts.setDescription('When set to normallyOpen, an alarm is declared when the contacts close ... and vice-versa.')
dlcUnitExternalAlarmInputMessage = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitExternalAlarmInputMessage.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitExternalAlarmInputMessage.setDescription("A character string that describes what's going on when an alarm on the External Alarm Input is detected.")
dlcUnitExternalAlarmOutputContacts = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normallyOpen", 1), ("normallyClosed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitExternalAlarmOutputContacts.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitExternalAlarmOutputContacts.setDescription('When set to normallyOpen, the contacts close when any enabled alarm occurs and vice-versa. Pushing any button on the units Front Panel will cause the alarm contacts to open again until another alarm is recognized.')
dlcUnitExternalAlarmOutputTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 20), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitExternalAlarmOutputTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitExternalAlarmOutputTrapEnable.setDescription('Enables or disables the external alarm output contacts.')
dlcUnitDsx1ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 2, 21), )
if mibBuilder.loadTexts: dlcUnitDsx1ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitDsx1ConfigTable.setDescription('A table of configuration items for a Dsx1 port.')
dlcDsx1ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcDsx1ConfigPortId"))
if mibBuilder.loadTexts: dlcDsx1ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1ConfigEntry.setDescription('An entry in the Dsx1 configuration table.')
dlcDsx1ConfigPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDsx1ConfigPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1ConfigPortId.setDescription("Uniquely identifies this port. Valid values are `mainNet', `aux', `otherNet'.")
dlcDsx1Framing = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("esfFraming", 1), ("d4Framing", 2), ("crc4Enabled", 3), ("crc4Disabled", 4), ("unstructured", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1Framing.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1Framing.setDescription('Dsx1 framing type: T1 --> D4 or ESF; E1 --> CRC4 or not. Unstructured is E1 only, when in this mode, the E1 line acts like a 2048 Bps pipe with no framing information.')
dlcDsx1LineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("b8zsCode", 1), ("amiCode", 2), ("hdb3Code", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1LineCode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1LineCode.setDescription('Dsx1 line code type, AMI or B8ZS. E1 lines are always HDB3.')
dlcDsx1LineMatching = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("buildOut0", 1), ("buildOut7p5", 2), ("buildOut15", 3), ("length0", 4), ("length133", 5), ("length266", 6), ("length399", 7), ("length533", 8), ("ohms75", 9), ("ohms120", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1LineMatching.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1LineMatching.setDescription('Dsx1 line build out or equalization: For a T1 NET port, LBO is 0, -7.5 or -15dB. For a T1 AUX port, EQ is 0..533 feet. For any E1 port, impedance is 75 or 120 Ohms.')
dlcDsx1DacsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 5), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1DacsMode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1DacsMode.setDescription('True if DACS mode is in effect for this port.')
dlcDsx1UseDlcFdlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 6), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1UseDlcFdlProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1UseDlcFdlProtocol.setDescription("True when DLC FDL protocol is enabled over this port's FDL.")
dlcDsx1UseAnsiProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 7), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1UseAnsiProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1UseAnsiProtocol.setDescription('True if ANSI Dsx1.403 is enabled over the FDL.')
dlcDsx1Bit7Stuffing = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 8), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1Bit7Stuffing.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1Bit7Stuffing.setDescription('When true, bit 7 stuffing is turned on for a T1 Aux port to provide pulse density protection. Valid only on a T1 AUX port.')
dlcDsx1InBandBit = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 21, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDsx1InBandBit.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDsx1InBandBit.setDescription('Specifies which bit in Timeslot 1 of an E1 link is used to pass message traffic. Not implemented for T1 ports.')
dlcUnitDataDteConfigTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 2, 22), )
if mibBuilder.loadTexts: dlcUnitDataDteConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitDataDteConfigTable.setDescription('The data DTE configuration table.')
dlcDataDteConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 2, 22, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcDataConfigPortId"))
if mibBuilder.loadTexts: dlcDataDteConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataDteConfigEntry.setDescription('An entry in the data DTE configuration table.')
dlcDataConfigPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 22, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDataConfigPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataConfigPortId.setDescription("Uniquely identifies this port. Valid values are `data1' through `data32'.")
dlcDataConfigEncoding = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("hdlc", 2), ("deferred", 3), ("forced", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDataConfigEncoding.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataConfigEncoding.setDescription('Data DTE encoding type.')
dlcDataConfigLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 22, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("never", 1), ("rtsLoss", 2), ("dtrLoss", 3), ("dataDependentLoss", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDataConfigLoss.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataConfigLoss.setDescription('The criterion to declare a Loss of Data DTE.')
dlcDataConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 22, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dteMode", 1), ("dceMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDataConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataConfigMode.setDescription('In dteMode the unit is the DTE and the external equipment the DCE.')
dlcDataConfigFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 22, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v35", 1), ("rs449", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDataConfigFormat.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataConfigFormat.setDescription('Selects V.35 or RS449 format.')
dlcDataConfigTransmitTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 22, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("scte", 1), ("sct", 2), ("sctInverted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDataConfigTransmitTiming.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDataConfigTransmitTiming.setDescription('Selects the Data DTE tramsmit timing source. Can be SCTE, SCT or inverted SCT.')
dlcUnitMuxConfigTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 2, 23), )
if mibBuilder.loadTexts: dlcUnitMuxConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitMuxConfigTable.setDescription('This is the timeslot map configuration.')
dlcMuxConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 2, 23, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcMuxConfigBusId"), (0, "DL-NEW-DSX1-MIB", "dlcMuxConfigSlotNumber"))
if mibBuilder.loadTexts: dlcMuxConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcMuxConfigEntry.setDescription('An entry in the timeslot map.')
dlcMuxConfigBusId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 23, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcMuxConfigBusId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcMuxConfigBusId.setDescription('Identifies which muxBus this timeslot is on.')
dlcMuxConfigSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 23, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcMuxConfigSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dlcMuxConfigSlotNumber.setDescription('Uniquely identifies this timeslot.')
dlcMuxConfigPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 23, 1, 3), PortId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcMuxConfigPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcMuxConfigPortId.setDescription('Says which DTE port receives data from the indicated muxBus during this timeslot.')
dlcUnitSnmpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 24))
dlcSnmpUnitIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpUnitIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpUnitIpAddr.setDescription('Specifies the IP address that is assigned to this unit.')
dlcSnmpUnitNetMask = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpUnitNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpUnitNetMask.setDescription('Specifies the net mask that this unit uses.')
dlcSnmpTrapAddr1 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapAddr1.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapAddr1.setDescription('Specifies the IP address of the management station to which this unit sends traps.')
dlcSnmpTrapAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapAddr2.setDescription('Specifies the IP address of the management station to which this unit sends traps.')
dlcSnmpTrapAddr3 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapAddr3.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapAddr3.setDescription('Specifies the IP address of the management station to which this unit sends traps.')
dlcSnmpTrapDlci1 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 6), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapDlci1.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapDlci1.setDescription('Specifies the first of three DLCI value to which this unit sends TRAP PDUs.')
dlcSnmpTrapDlci2 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 7), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapDlci2.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapDlci2.setDescription('Specifies the second of three DLCI value to which this unit sends TRAP PDUs.')
dlcSnmpTrapDlci3 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 8), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapDlci3.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapDlci3.setDescription('Specifies the third of three DLCI value to which this unit sends TRAP PDUs.')
dlcSnmpTrapDirection1 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("commDirection", 1), ("netDirection", 2), ("dteDirection", 3), ("fdlDirection", 4), ("ethDirection", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapDirection1.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapDirection1.setDescription('Specifies the first of three Port to which this unit sends TRAP PDUs.')
dlcSnmpTrapDirection2 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("commDirection", 1), ("netDirection", 2), ("dteDirection", 3), ("fdlDirection", 4), ("ethDirection", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapDirection2.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapDirection2.setDescription('Specifies the second of three Port to which this unit sends TRAP PDUs.')
dlcSnmpTrapDirection3 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("commDirection", 1), ("netDirection", 2), ("dteDirection", 3), ("fdlDirection", 4), ("ethDirection", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapDirection3.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapDirection3.setDescription('Specifies the third of three Port to which this unit sends TRAP PDUs.')
dlcSnmpTrapDirection = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("commDirection", 1), ("ibcDirection", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSnmpTrapDirection.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSnmpTrapDirection.setDescription('Specifies where this unit sends TRAP PDUs.')
dlcSnmpEthernetConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 13))
dlcEthernetIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 13, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcEthernetIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dlcEthernetIpAddr.setDescription('Specifies the IP address of Ethernet port.')
dlcEthernetIpMask = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 13, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcEthernetIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: dlcEthernetIpMask.setDescription('Specifies the subnet mask of Ethernet port.')
dlcEthernetGatewayAddr = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 13, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcEthernetGatewayAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dlcEthernetGatewayAddr.setDescription('Specifies the gateway address of Ethernet port.')
dlcEthernetMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 24, 13, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcEthernetMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dlcEthernetMacAddr.setDescription('The MAC address of the Ethernet port.')
dlcUnitConfigTime = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 25))
dlcUnitTimeYear = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 25, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1992, 2037))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTimeYear.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTimeYear.setDescription("The unit's notion of the current year.")
dlcUnitTimeMonth = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 25, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTimeMonth.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTimeMonth.setDescription("The unit's notion of the current month.")
dlcUnitTimeDay = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 25, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTimeDay.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTimeDay.setDescription("The unit's notion of the current day.")
dlcUnitTimeHour = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 25, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTimeHour.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTimeHour.setDescription("The the unit's notion of the current hour.")
dlcUnitTimeMinute = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 25, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTimeMinute.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTimeMinute.setDescription("The the unit's notion of the current minute.")
dlcUnitTimeSecond = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 25, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTimeSecond.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTimeSecond.setDescription("The the unit's notion of the current second.")
dlcUnitSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitSerialNum.setDescription('An ID that uniquely and globally identifies the unit. A Serial Number must consist of printable ASCII characters 0x20 ..0x7E.')
dlcUnitModemConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 27))
dlcModemPhoneNum1 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 27, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcModemPhoneNum1.setStatus('mandatory')
if mibBuilder.loadTexts: dlcModemPhoneNum1.setDescription('The first phone number to dial when the unit needs to set up a modem connection.')
dlcModemPhoneNum2 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 27, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcModemPhoneNum2.setStatus('mandatory')
if mibBuilder.loadTexts: dlcModemPhoneNum2.setDescription('The second phone number to try if the phone number failed in setting up a modem connection.')
dlcModemInitString1 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 27, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcModemInitString1.setStatus('mandatory')
if mibBuilder.loadTexts: dlcModemInitString1.setDescription('In setting up a modem connection, the first group of commands used to initialize the modem.')
dlcModemInitString2 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 27, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcModemInitString2.setStatus('mandatory')
if mibBuilder.loadTexts: dlcModemInitString2.setDescription('In setting up a modem connection, the second group of commands used to initialize the modem. There is a delay between sending the first and second groups of initialzation commands.')
dlcUnitInbandMode = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noInband", 1), ("frameRelay", 2), ("ciscoHdlc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitInbandMode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitInbandMode.setDescription('The type of traffic expected on the link for inband management and IPM.')
class UnitStatusItem(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128, 256, 512))
    namedValues = NamedValues(("normal", 1), ("noClock", 2), ("testInProgress", 4), ("sendKeepAlive", 8), ("sendYellowAlarm", 16), ("reserved1", 32), ("reserved2", 64), ("reserved3", 128), ("reserved4", 256), ("reserved5", 512))

class PortStatusItem(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))
    namedValues = NamedValues(("normal", 1), ("lossOfSignal", 2), ("lossOfSync", 3), ("yellowAlarmDetected", 4), ("blueAlarmDetected", 5), ("setCodeReceived", 6), ("resetCodeReceived", 7), ("excessiveErrorRate", 8), ("localTest", 9), ("eBitReceived", 10), ("reserved1", 11), ("reserved2", 12), ("reserved3", 13), ("reserved4", 14))

dlcUnitStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 3))
dlcUnitCurrentStatus = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 3, 1), UnitStatusItem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitCurrentStatus.setDescription("What's going on in this unit?")
dlcUnitErrorFreeSeconds = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 3, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitErrorFreeSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitErrorFreeSeconds.setDescription('Represents the percent of error free seconds over the last 24 hours. The number is multiplied by 10 and rounded to the nearest integer. For example, 94.2% is encoded as 942.')
dlcUnitLastSelfTestResult = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitLastSelfTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitLastSelfTestResult.setDescription('The result of the last self test. unitLastSelfTest is a bitmap ... the sum of: 0 Selftest passed 1 ROM checksum failure 2 RAM test failure 4 EEPROM CRC failure 8 DTE test failure 16 Pattern loss during test 32 FLASH checksum failure 64 reserved 128 reserved 256 reserved 512 reserved A result of 0 means no errors occurred. ')
dlcUnitPortStatusTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 3, 4), )
if mibBuilder.loadTexts: dlcUnitPortStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitPortStatusTable.setDescription('A table of all port-related status')
dlcPortStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 3, 4, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcPortStatusId"), (0, "DL-NEW-DSX1-MIB", "dlcPortStatus"))
if mibBuilder.loadTexts: dlcPortStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcPortStatusEntry.setDescription('An entry in the port status table.')
dlcPortStatusId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 3, 4, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcPortStatusId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcPortStatusId.setDescription('Identifies which port (NET, AUX, Data DTE, or whatever) this status entry is describing.')
dlcPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 3, 4, 1, 2), PortStatusItem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlcPortStatus.setDescription('Gives the actual status value for to this port.')
dlcPortStatusNetRxBwUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 3, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcPortStatusNetRxBwUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: dlcPortStatusNetRxBwUtilization.setDescription('Represents the percent of net receive bandwidth utilization over the last 60 seconds. The number is multiplied by 10 and rounded to the nearest integer. For example, 94.2% is encoded as 942.')
dlcPortStatusNetTxBwUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 3, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcPortStatusNetTxBwUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: dlcPortStatusNetTxBwUtilization.setDescription('Represents the percent of net receive bandwidth utilization over the last 60 seconds. The number is multiplied by 10 and rounded to the nearest integer. For example, 94.2% is encoded as 942.')
dlcUnitAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 3, 5), )
if mibBuilder.loadTexts: dlcUnitAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitAlarmTable.setDescription('A table of all currently-raised alarms')
dlcAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 3, 5, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcAlarmPort"), (0, "DL-NEW-DSX1-MIB", "dlcAlarmType"))
if mibBuilder.loadTexts: dlcAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcAlarmEntry.setDescription('An entry in the alarm table.')
dlcAlarmPort = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 3, 5, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcAlarmPort.setStatus('mandatory')
if mibBuilder.loadTexts: dlcAlarmPort.setDescription('Identifies which port (NET, AUX, Data DTE, or whatever) this alarm relates to.')
dlcAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 3, 5, 1, 2), AlarmType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: dlcAlarmType.setDescription("Identifies an alarm that's currently outstanding against this port.")
dlcUnitErrorSecondsRatio = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 3, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitErrorSecondsRatio.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitErrorSecondsRatio.setDescription('Represents the percent of error seconds over the last 24 hours. The number is multiplied by 10 and rounded to the nearest integer. For example, 94.2% is encoded as 942.')
dlcUnitSeverelyErroredSecondsRatio = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 3, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitSeverelyErroredSecondsRatio.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitSeverelyErroredSecondsRatio.setDescription('Represents the percent of severely errored seconds over the last 24 hours. The number is multiplied by 10 and rounded to the nearest integer. For example, 94.2% is encoded as 942.')
dlcUnitBackgroundBlockErrorRatio = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 3, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitBackgroundBlockErrorRatio.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitBackgroundBlockErrorRatio.setDescription('Represents the percent of background block errors over the last 24 hours. The number is multiplied by 10 and rounded to the nearest integer. For example, 94.2% is encoded as 942.')
dlcUnitUserArchive = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 4))
dlcUnitUserArchiveValidTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 4, 1), )
if mibBuilder.loadTexts: dlcUnitUserArchiveValidTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitUserArchiveValidTable.setDescription('A table of all port-related status')
dlcUserArchiveValidEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 4, 1, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcValidPortId"))
if mibBuilder.loadTexts: dlcUserArchiveValidEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUserArchiveValidEntry.setDescription('An entry in the user archive valid-intervals table.')
dlcValidPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 1, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcValidPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcValidPortId.setDescription("Identifies which port (`net' or `otherNet') this entry is describing.")
dlcValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: dlcValidIntervals.setDescription("The number of valid intervals in the user's error register database for this port. Writing a 0 to this variable will clear the entire archive for this port. Writing any other value is a no-op.")
dlcUnitUserLifetimeTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 4, 2), )
if mibBuilder.loadTexts: dlcUnitUserLifetimeTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitUserLifetimeTable.setDescription('A table of the lifetime error counts, per-port.')
dlcUserLifetimeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 4, 2, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcLifetimePortId"))
if mibBuilder.loadTexts: dlcUserLifetimeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUserLifetimeEntry.setDescription('An entry in the user archive lifetime-totals table.')
dlcLifetimePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 2, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcLifetimePortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLifetimePortId.setDescription("Identifies which port (`net' or `otherNet') this entry relates to.")
dlcLifetimeES = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 2, 1, 2), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLifetimeES.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLifetimeES.setDescription('An ongoing count of Errored Seconds detected on this network port. Can be read and written (to zero).')
dlcLifetimeUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 2, 1, 3), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLifetimeUAS.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLifetimeUAS.setDescription('An ongoing count of Unavailable Seconds detected on this network port. Can be read and written (to zero).')
dlcLifetimeCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 2, 1, 4), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLifetimeCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLifetimeCrcErrors.setDescription('An ongoing count of the CRC errors detected on this network port. Can be read and written (to zero).')
dlcLifetimeBpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 2, 1, 5), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLifetimeBpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLifetimeBpvErrors.setDescription('An ongoing count of the Code Violation errors detected on this network port. Can be read and written (to zero).')
dlcLifetimeOofErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 2, 1, 6), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLifetimeOofErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLifetimeOofErrors.setDescription('For an ESF T1 port, an ongoing count of Out-Of-Frame errors. For a D4 T1 port, an ongoing count of Framing Errors. Available only for the network port. Can be read and written (to zero).')
dlcLifetimeIbCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 2, 1, 7), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLifetimeIbCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLifetimeIbCrcErrors.setDescription('An ongoing count of the FCS errors detected on this network port.')
dlcUnitUserCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 4, 3), )
if mibBuilder.loadTexts: dlcUnitUserCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitUserCurrentTable.setDescription('A table of all the current interval error counts, per-port.')
dlcUserCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcCurrentPortId"))
if mibBuilder.loadTexts: dlcUserCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUserCurrentEntry.setDescription('An entry in the user archive current interval table.')
dlcCurrentPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcCurrentPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcCurrentPortId.setDescription("Identifies which port (`net' or `otherNet') this entry relates to.")
dlcCurrentES = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcCurrentES.setStatus('mandatory')
if mibBuilder.loadTexts: dlcCurrentES.setDescription('Errored seconds in the interval.')
dlcCurrentUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcCurrentUAS.setStatus('mandatory')
if mibBuilder.loadTexts: dlcCurrentUAS.setDescription('Unavailable seconds in the interval.')
dlcCurrentCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcCurrentCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcCurrentCrcErrors.setDescription('CRC Errors in the interval.')
dlcCurrentBpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcCurrentBpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcCurrentBpvErrors.setDescription('Code Violation Errors in the interval.')
dlcCurrentOofErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcCurrentOofErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcCurrentOofErrors.setDescription('OOF or Framing Errors in the interval.')
dlcCurrentTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcCurrentTimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: dlcCurrentTimeElapsed.setDescription('The number of seconds that have elapsed since the beginning of the current error-measurement period. Available only for the network port.')
dlcCurrentIbCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcCurrentIbCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcCurrentIbCrcErrors.setDescription('FCS Errors in the interval.')
dlcUnitUserArchiveTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 4, 4), )
if mibBuilder.loadTexts: dlcUnitUserArchiveTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitUserArchiveTable.setDescription("A table of all the archive intervals' error counts, per-port.")
dlcUserArchiveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcArchivePortId"), (0, "DL-NEW-DSX1-MIB", "dlcArchiveInterval"))
if mibBuilder.loadTexts: dlcUserArchiveEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUserArchiveEntry.setDescription('An entry in the user archive table.')
dlcArchivePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchivePortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchivePortId.setDescription("Identifies which port (`net' or `otherNet') this entry relates to.")
dlcArchiveInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveInterval.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveInterval.setDescription('Identifies which interval this secondaryArchiveEntry describes. 1 indicates the most-recent interval.')
dlcArchiveES = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveES.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveES.setDescription('Errored seconds in the interval.')
dlcArchiveUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveUAS.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveUAS.setDescription('Unavailable seconds in the interval.')
dlcArchiveCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveCrcErrors.setDescription('CRC Errors in the interval.')
dlcArchiveBpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveBpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveBpvErrors.setDescription('Code Violation Errors in the interval.')
dlcArchiveOofErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveOofErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveOofErrors.setDescription('OOF or Framing Errors in the interval.')
dlcArchiveIbCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveIbCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveIbCrcErrors.setDescription('FCS Errors in the interval.')
dlcArchiveNetRxBwUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveNetRxBwUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveNetRxBwUtilization.setDescription('Net Rx Bandwidth Utilization in the interval.')
dlcArchiveNetRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveNetRxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveNetRxPackets.setDescription('Net Rx Packets in the interval.')
dlcArchiveNetTxBwUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveNetTxBwUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveNetTxBwUtilization.setDescription('Net Tx Bandwidth Utilization in the interval.')
dlcArchiveNetTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcArchiveNetTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcArchiveNetTxPackets.setDescription('Net Tx Packets in the interval.')
dlcUnitTest = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 5))
dlcUnitTestTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 5, 1), )
if mibBuilder.loadTexts: dlcUnitTestTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTestTable.setDescription("A table containing all currently active tests. The initial release of the product's firmware does not include multiple tests. However, a later version will allow a number of tests to be active at a time. This MIB object structure allows any number of tests to be running at any time. Upon receiving a SET request, the unit compares this table with the list of currently active tests and terminates or initiates any tests as required. However, this does not apply to Link Based Test. dlcUnitConfigLinkTest group contains objects to configure and start Link Based Test. This table only contains the statistics for Link Based Test.")
dlcUnitTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcUnitTestPortId"))
if mibBuilder.loadTexts: dlcUnitTestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTestEntry.setDescription('An entry in the network configuration table.')
dlcUnitTestPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 1), PortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitTestPortId.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTestPortId.setDescription('Identifies a port that a test might be running on. By convention, Self Test and all full-bandwidth tests (loopbacks, patterns, etc.) are assigned to the netPort. For E1 unit, if it is in unstructured mode, only full-bandwidth tests can be performed.')
dlcUnitTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 2), TestType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTestType.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTestType.setDescription("Says what test is running on this port. Note that the following test nomenclature is equivalent: SNMP Terminal UI Front Panel 1in8 1:7 1:7 3in24 3:24 3.24 1in1 1:1 1:1 AllOne All 1 1's AllZero All 0 0's 1in3 1:2 1:2 1in5 1:4 1:4 The SNMP test identifiers use the names on the left. The terminal User Interface uses the names in the middle column, and the unit's front panel uses the names in the right column.")
dlcUnitTestPatternStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("search", 1), ("locked", 2), ("overflow", 3), ("off", 4), ("lockedAfterLoss", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitTestPatternStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTestPatternStatus.setDescription('The current state of the Pattern Test module.')
dlcUnitTestPatternErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 4), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitTestPatternErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitTestPatternErrors.setDescription('An ongoing count of errors detected by the Pattern Generator/Detector. Can be read and written (to zero).')
dlcLinkTestSentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcLinkTestSentPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestSentPackets.setDescription('Number of sent packets for the currently running link based test.')
dlcLinkTestReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcLinkTestReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestReceivedPackets.setDescription('Number of good received packets for the currently running link based test.')
dlcLinkTestErroredPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcLinkTestErroredPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestErroredPackets.setDescription('Number of errored received packets for the currently running link based test.')
dlcLinkTestMissingPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcLinkTestMissingPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestMissingPackets.setDescription('Number of missing packets for the currently running link based test.')
dlcLinkTestAverageRoundTrip = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcLinkTestAverageRoundTrip.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestAverageRoundTrip.setDescription('Average round trip time in milli seconds for the currently running link based test.')
dlcLinkTestMaximumRoundTrip = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 5, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcLinkTestMaximumRoundTrip.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestMaximumRoundTrip.setDescription('Maximum round trip time in milli seconds for the currently running link based test.')
dlcUnitDialOutTimeInterval = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitDialOutTimeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitDialOutTimeInterval.setDescription('A time interval for the dialout. The value should be between 0 and 255.')
class FramedUnframed(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("framed", 1), ("unframed", 2))

dlcAlarmSignal = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 30), FramedUnframed()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcAlarmSignal.setStatus('mandatory')
if mibBuilder.loadTexts: dlcAlarmSignal.setDescription('Framed/unframed aux alarm signal option')
dlcUnitIdleCode = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitIdleCode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitIdleCode.setDescription('Idle Code that is send on unassigned time slots')
class RemoteCommunicationsMode(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("digital-link", 2), ("att-TR54016", 3), ("ansi-T1-403", 4))

dlcRemoteCommunicationsMode = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 32), RemoteCommunicationsMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcRemoteCommunicationsMode.setStatus('mandatory')
if mibBuilder.loadTexts: dlcRemoteCommunicationsMode.setDescription('Framed/unframed aux alarm signal option')
dlcUnitConfigLinkTest = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 33))
dlcLinkTestState = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 33, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("running", 3), ("idle", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkTestState.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestState.setDescription('Specifies the status configuration of link based test. Only setable to values disabled(1) and enabled(2) to end and start the test respectively. Values running(3) and idle(4) are returned for status of the test.')
dlcLinkTestAddress = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 33, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkTestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestAddress.setDescription('Specifies the address for the next link based test to run.')
dlcLinkTestDlci = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 33, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkTestDlci.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestDlci.setDescription('Specifies the frame relay DLCI for the next link based test to run. This value is used when the unit is in frameRelay InbandMode only and if the next link based test is not done on the commPort.')
dlcLinkTestPort = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 33, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("comm", 1), ("net", 2), ("dte", 3), ("eth", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkTestPort.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestPort.setDescription('Specifies which port to run the next link based test.')
dlcLinkTestLength = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 33, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkTestLength.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestLength.setDescription('Specifies the time length of the next test to run in minutes.')
dlcLinkTestInterval = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 33, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkTestInterval.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestInterval.setDescription('Specifies the repetition interval in seconds between packets for the next link based test.')
dlcLinkTestPacketSize = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 33, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkTestPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestPacketSize.setDescription('Specifies the packet size for the next link based test.')
dlcLinkTestPattern = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 33, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ping511", 1), ("ping2047", 2), ("ping1-0", 3), ("ping-all-1", 4), ("ping-all-0", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkTestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkTestPattern.setDescription('Specifies the test pattern for the next link based test.')
dlcUnitInbandConfig = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 34), Boolean()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitInbandConfig.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitInbandConfig.setDescription('When true (== 2), inband management is enabled.')
dlcUnitInbandTrafficType = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frameRelay", 1), ("ciscoHdlc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUnitInbandTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitInbandTrafficType.setDescription('The type of traffic expected on the link for inband management and IPM.')
dlcUnitPerformanceMonitoring = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 36), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitPerformanceMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitPerformanceMonitoring.setDescription('When true (== 2), the integrated performance monitoring (IPM) is enabled')
dlcUnitPvcAutoDiscovery = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 37), Boolean()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcUnitPvcAutoDiscovery.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUnitPvcAutoDiscovery.setDescription('When true (== 2), automatic discovery of DLCIs is enabled')
dlcUnitDelayMonitorConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 38))
dlcDelayMonitorConfigTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1), )
if mibBuilder.loadTexts: dlcDelayMonitorConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorConfigTable.setDescription('Table of Delay Monitor test configuration.')
dlcDelayMonitorConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcDelayMonitorConfigIndex"))
if mibBuilder.loadTexts: dlcDelayMonitorConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorConfigEntry.setDescription('An entry in the network configuration table.')
dlcDelayMonitorConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDelayMonitorConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorConfigIndex.setDescription('Uniquely identifies which delay monitor test in the configuration table.')
dlcDelayMonitorState = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("running", 3), ("idle", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDelayMonitorState.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorState.setDescription('Specifies the status configuration of this delay monitor. Only setable to values disabled(1) and enabled(2) to end and start the test respectively. Values running(3) and idle(4) are returned for status of the test.')
dlcDelayMonitorTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDelayMonitorTargetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorTargetAddress.setDescription('Specifies the address for the next delay monitor to run.')
dlcDelayMonitorDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDelayMonitorDlci.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorDlci.setDescription('Specifies the frame relay DLCI for the next delay monitor to run. This value is used when the unit is in frameRelay InbandMode only and if the next delay monitor is not done on the commPort.')
dlcDelayMonitorPort = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("comm", 1), ("net", 2), ("dte", 3), ("eth", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDelayMonitorPort.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorPort.setDescription('Specifies which port to run the next delay monitor.')
dlcDelayMonitorInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDelayMonitorInterval.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorInterval.setDescription('Specifies the repetition interval in seconds between packets for the next delay monitor to run.')
dlcDelayMonitorPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDelayMonitorPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorPacketSize.setDescription('Specifies the packet size for the next delay monitor.')
dlcDelayMonitorPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 38, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ping511", 1), ("ping2047", 2), ("ping1-0", 3), ("ping-all-1", 4), ("ping-all-0", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDelayMonitorPattern.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorPattern.setDescription('Specifies the test pattern for the next delay monitor.')
dlcUnitDelayMonitorStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 6))
dlcDelayMonitorStatusTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 6, 1), )
if mibBuilder.loadTexts: dlcDelayMonitorStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorStatusTable.setDescription('Table of Delay Monitor status.')
dlcDelayMonitorStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 6, 1, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcDelayMonitorStatusIndex"))
if mibBuilder.loadTexts: dlcDelayMonitorStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorStatusEntry.setDescription('An entry in the network configuration table.')
dlcDelayMonitorStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDelayMonitorStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorStatusIndex.setDescription('Uniquely identifies which Delay Monitor test in the configuration table.')
dlcDelayMonitorSentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 6, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDelayMonitorSentPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorSentPackets.setDescription('Number of sent packets for the currently running delay monitor test.')
dlcDelayMonitorReceivedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 6, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDelayMonitorReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorReceivedPackets.setDescription('Number of good received packets for the currently running delay monitor test.')
dlcDelayMonitorErroredPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 6, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDelayMonitorErroredPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorErroredPackets.setDescription('Number of errored received packets for the currently running delay monitor test.')
dlcDelayMonitorMissingPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 6, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDelayMonitorMissingPackets.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorMissingPackets.setDescription('Number of missing packets for the currently running delay monitor test.')
dlcDelayMonitorAverageRoundTrip = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 6, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDelayMonitorAverageRoundTrip.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorAverageRoundTrip.setDescription('Average round trip time in milli seconds for the currently running delay monitor test.')
dlcDelayMonitorMaximumRoundTrip = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 6, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDelayMonitorMaximumRoundTrip.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDelayMonitorMaximumRoundTrip.setDescription('Maximum round trip time in milli seconds for the currently running delay monitor test.')
dlcDLCItable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 2, 39), )
if mibBuilder.loadTexts: dlcDLCItable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDLCItable.setDescription('Table for current DLCI')
dlcDLCItableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 2, 39, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcDLCInumber"), (0, "DL-NEW-DSX1-MIB", "dlcDTECIR"), (0, "DL-NEW-DSX1-MIB", "dlcNETCIR"))
if mibBuilder.loadTexts: dlcDLCItableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDLCItableEntry.setDescription('An entry for a DLCI')
dlcDLCInumber = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 39, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDLCInumber.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDLCInumber.setDescription('Identifies DLCI number.')
dlcDTECIR = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 39, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDTECIR.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDTECIR.setDescription("This DLCI's DTE Confirmed Information Rate (CIR)")
dlcNETCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 39, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcNETCIR.setStatus('mandatory')
if mibBuilder.loadTexts: dlcNETCIR.setDescription("This DLCI's NET Confirmed Information Rate (CIR)")
dlcDLCIstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 2, 39, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("active", 3), ("inactive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDLCIstatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDLCIstatus.setDescription("This object represents status of the entry. When read, it will return status 'active' or 'inactive' representing the status of the row. When written, this object is used to add or delete entry. Setting to 'enabled' will add a new entry, setting to 'disabled' will delete the entry.")
dlcUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 300, 200, 7), )
if mibBuilder.loadTexts: dlcUtilizationTable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtilizationTable.setDescription('Table for lifetime Utilization statistics.')
dlcUtilTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 300, 200, 7, 1), ).setIndexNames((0, "DL-NEW-DSX1-MIB", "dlcUtilDLCINumber"))
if mibBuilder.loadTexts: dlcUtilTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtilTableEntry.setDescription('An entry for the utilization table.')
dlcUtilDLCINumber = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtilDLCINumber.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtilDLCINumber.setDescription('Identifies the DLCI number of the utilization statistics of this entry/row.')
dlcUtilEncodedValue = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtilEncodedValue.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtilEncodedValue.setDescription('This object represents the value of the whole row of the table. The intent of object is to increase the efficiency of retrieving the table. For each object value in this table, which are all of Counter type, it will be represented with 4 bytes of data.')
dlcUtilTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtilTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtilTimestamp.setDescription('Identifies timestamp when this entry is last updated.')
dlcUtilLessThan20 = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtilLessThan20.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtilLessThan20.setDescription('The number of times utilization is less than 20% of Committed Information Rate (CIR).')
dlcUtil20_40 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 5), Counter32()).setLabel("dlcUtil20-40").setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtil20_40.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtil20_40.setDescription('The number of times utilization is between 20% and 40% of Committed Information Rate (CIR).')
dlcUtil40_60 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 6), Counter32()).setLabel("dlcUtil40-60").setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtil40_60.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtil40_60.setDescription('The number of times utilization is between 40% and 60% of Committed Information Rate (CIR).')
dlcUtil60_80 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 7), Counter32()).setLabel("dlcUtil60-80").setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtil60_80.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtil60_80.setDescription('The number of times utilization is between 60% and 80% of Committed Information Rate (CIR).')
dlcUtil80_100 = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 8), Counter32()).setLabel("dlcUtil80-100").setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtil80_100.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtil80_100.setDescription('The number of times utilization is between 80% and 100% of Committed Information Rate (CIR).')
dlcUtilMoreThan100 = MibTableColumn((1, 3, 6, 1, 4, 1, 300, 200, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcUtilMoreThan100.setStatus('mandatory')
if mibBuilder.loadTexts: dlcUtilMoreThan100.setDescription('The number of times utilization is more than 100% of Committed Information Rate (CIR).')
dlcLMIConditioningGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 41))
dlcLMIConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1))
dlcLMIEnable = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLMIEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLMIEnable.setDescription('This object specifies whether to enable or disable LMI Conditioning.')
dlcMaintenanceDLCI = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcMaintenanceDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: dlcMaintenanceDLCI.setDescription('This objects specifies the status of the LMI Spoofing.')
dlcManagementDLCI = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 991))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcManagementDLCI.setStatus('mandatory')
if mibBuilder.loadTexts: dlcManagementDLCI.setDescription('This objects specifies the number of management DLCI between 16 and 991 inclusive. Must not be the same as maintenance DLCI. Default is 989.')
dlcManagementDLCIEnable = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcManagementDLCIEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcManagementDLCIEnable.setDescription('This object specifies whether to enable or disable Management DLCI.')
dlcSpoofingProtocolType = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("frf1-0", 1), ("annex-d", 2), ("annex-a", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcSpoofingProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSpoofingProtocolType.setDescription("This objects configures which LMI message type to 'spoof', in the event that spoofing is activated. The possible choices are FRF 1.0 (Frame Relay Forum's early LMI adaptation), Annex A (ITU Q.933, annex A), and Annex D (ANSI T1.617, annex D). Default is Annex D.")
dlcDTESpoofingEnable = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDTESpoofingEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDTESpoofingEnable.setDescription("If the value of this object is 'enabled', LMI spoofing to the DTE port is done automatically.")
dlcNetSpoofingEnable = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcNetSpoofingEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dlcNetSpoofingEnable.setDescription("If the value of this object is 'enabled', LMI spoofing to the Network port is done automatically.")
dlcLinkIntegrityVerificationPollingTimer = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLinkIntegrityVerificationPollingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLinkIntegrityVerificationPollingTimer.setDescription('This object is the interval in seconds between Link Integrity Verification Messages. This is known as T391 in the standards. Possible values are 5 to 30 seconds in increments of 5. Default is 10 seconds.')
dlcFullStatusPollingCounter = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcFullStatusPollingCounter.setStatus('mandatory')
if mibBuilder.loadTexts: dlcFullStatusPollingCounter.setDescription('This value corresponds to N391 in the ITU and ANSI standards. It is the number of polling cycles of the type before the unit generates the full status request. Possible values are 1 to 255. Default is 10.')
dlcLMIErrorEvent = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLMIErrorEvent.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLMIErrorEvent.setDescription('This object configures the parameter which sets the number of errors that can occur on the LMI link in LMI Error Monitored Events before reporting an interface down. Applies to the DTE and Network ports. This is used in the same manner as the N392 parameter (N2) in the standards. Possible values are 1 to 10. Default is 1.')
dlcLMIErrorMonitorEvent = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLMIErrorMonitorEvent.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLMIErrorMonitorEvent.setDescription('This object configures parameter which sets the number of events that are used with the LMI Error Event to define the error ratio that is used to report when the LMI link is down. Applies to the DTE and Network ports. This value is used in the same manner as the N393 parameter (N3) in the standards.')
dlcLMIErrorFreeEvent = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLMIErrorFreeEvent.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLMIErrorFreeEvent.setDescription('This object configures the parameter which sets the number of error-free messages that must be received in LMI Error Free Monitored Events prior to declaring an interface is up. Applies to the DTE and Network ports. For network spoofing, this is the number of error-free events that will cause the DSU to believe the network is back up and runnig, and the DSU will stop spoofing. This is used in the same manner as the N392 parameter (N2) in the standards. Possible values are 1 to 10. Default is 1.')
dlcLMIErrorFreeMonitorEvent = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLMIErrorFreeMonitorEvent.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLMIErrorFreeMonitorEvent.setDescription('This object configures parameter which sets the number of events that are used with the LMI Error Free Event to define the error ratio that is used to report that the LMI link is up. Applies to the DTE and Network ports. This is used in the same manner as the N393 parameter (N3) in the standards.')
dlcDTEResponseTimer = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcDTEResponseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDTEResponseTimer.setDescription('This object configures the parameter which sets the number of seconds between the sending of a status enquiry message and the receipt of a response. Applies to the DTE port. This value is similar in nature to the T392 (T2) parameter in the standards. Possible values are 5 to 30 in increments of 5. Default is 15.')
dlcLMIUnitLocation = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cpe", 1), ("co", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcLMIUnitLocation.setStatus('mandatory')
if mibBuilder.loadTexts: dlcLMIUnitLocation.setDescription("This object configures where the unit is located so that LMI spoofing could be done properly. If 'cpe' is selected, it means the unit is located in Customer Premise. If 'co' is selected, the unit is in Central Office.")
dlcLMIStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 2))
dlcSpoofingStatus = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("dte-spoofing", 2), ("net-spoofing", 3), ("dte-and-net-spoofing", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcSpoofingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlcSpoofingStatus.setDescription("This object configures automatic LMI spoofing to the router. 'True' means LMI spoofing will occur automatically, 'False' means it's disabled.")
dlcDTEInterfaceLMIStatus = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("lmi-up", 2), ("lmi-down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcDTEInterfaceLMIStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlcDTEInterfaceLMIStatus.setDescription('This object indicates the LMI status of DTE interface.')
dlcNetInterfaceLMIStatus = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 41, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("lmi-up", 2), ("lmi-down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlcNetInterfaceLMIStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlcNetInterfaceLMIStatus.setDescription('This object indicates the LMI status of Net interface.')
dlcInbandDtePort = MibScalar((1, 3, 6, 1, 4, 1, 300, 200, 2, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("data1", 1), ("data2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlcInbandDtePort.setStatus('mandatory')
if mibBuilder.loadTexts: dlcInbandDtePort.setDescription('This object configures which DTE port has inband management.')
startTest = NotificationType((1, 3, 6, 1, 4, 1, 300, 200) + (0,1)).setObjects(("DL-NEW-DSX1-MIB", "dlcUnitTestPortId"), ("DL-NEW-DSX1-MIB", "dlcUnitTestType"))
if mibBuilder.loadTexts: startTest.setDescription('Sent upon the initiation of a new test condition.')
endTest = NotificationType((1, 3, 6, 1, 4, 1, 300, 200) + (0,2)).setObjects(("DL-NEW-DSX1-MIB", "dlcUnitTestPortId"), ("DL-NEW-DSX1-MIB", "dlcUnitTestType"))
if mibBuilder.loadTexts: endTest.setDescription('Sent upon the termination of a test condition.')
startAlarm = NotificationType((1, 3, 6, 1, 4, 1, 300, 200) + (0,3)).setObjects(("DL-NEW-DSX1-MIB", "dlcAlarmPort"), ("DL-NEW-DSX1-MIB", "dlcAlarmType"))
if mibBuilder.loadTexts: startAlarm.setDescription('Indicates the beginning of a new alarm condition.')
endAlarm = NotificationType((1, 3, 6, 1, 4, 1, 300, 200) + (0,4)).setObjects(("DL-NEW-DSX1-MIB", "dlcAlarmPort"), ("DL-NEW-DSX1-MIB", "dlcAlarmType"))
if mibBuilder.loadTexts: endAlarm.setDescription('Indicates the end of an alarm condition.')
manualConfigChange = NotificationType((1, 3, 6, 1, 4, 1, 300, 200) + (0,5))
if mibBuilder.loadTexts: manualConfigChange.setDescription('Generated when the configuration was changed manually on the unit.')
mibBuilder.exportSymbols("DL-NEW-DSX1-MIB", dlcDelayMonitorMissingPackets=dlcDelayMonitorMissingPackets, dlcCurrentBpvErrors=dlcCurrentBpvErrors, dlcUnitDataDteConfigTable=dlcUnitDataDteConfigTable, dlcLinkTestSentPackets=dlcLinkTestSentPackets, dlcEthernetGatewayAddr=dlcEthernetGatewayAddr, dlcUnitDataDteLossTrapEnableTable=dlcUnitDataDteLossTrapEnableTable, dlcArchiveBpvErrors=dlcArchiveBpvErrors, dlcUnitConfigTime=dlcUnitConfigTime, dlcDelayMonitorAverageRoundTrip=dlcDelayMonitorAverageRoundTrip, dlcUtil60_80=dlcUtil60_80, dlcDelayMonitorSentPackets=dlcDelayMonitorSentPackets, dlcLinkTestPacketSize=dlcLinkTestPacketSize, dlcUnitTestType=dlcUnitTestType, dlcSnmpTrapAddr1=dlcSnmpTrapAddr1, dlcUnitAltClockSource=dlcUnitAltClockSource, Boolean=Boolean, dlcDsx1UseDlcFdlProtocol=dlcDsx1UseDlcFdlProtocol, PortStatusItem=PortStatusItem, dlcUnitId=dlcUnitId, dlcUnitHwConfig=dlcUnitHwConfig, dlcUnitSeverelyErroredSecondsRatio=dlcUnitSeverelyErroredSecondsRatio, dlcUnitTimeMonth=dlcUnitTimeMonth, dlcCurrentPortId=dlcCurrentPortId, dlcUnitIdleCode=dlcUnitIdleCode, dlcDataConfigMode=dlcDataConfigMode, dlcInbandDtePort=dlcInbandDtePort, dlcModemPhoneNum1=dlcModemPhoneNum1, dlcDsx1CrcThresholdTrap=dlcDsx1CrcThresholdTrap, dlcUserCurrentEntry=dlcUserCurrentEntry, dlcValidPortId=dlcValidPortId, dlcUnitModemConfig=dlcUnitModemConfig, dlcUnitDsx1ConfigTable=dlcUnitDsx1ConfigTable, LoopCodeType=LoopCodeType, dlcEthernetIpAddr=dlcEthernetIpAddr, dlcSpoofingProtocolType=dlcSpoofingProtocolType, digital_link=digital_link, dlcUnitFeatures=dlcUnitFeatures, dlcLinkTestReceivedPackets=dlcLinkTestReceivedPackets, dlcLinkTestLength=dlcLinkTestLength, dlcSnmpTrapDirection1=dlcSnmpTrapDirection1, dlcDTESpoofingEnable=dlcDTESpoofingEnable, dlcDelayMonitorStatusIndex=dlcDelayMonitorStatusIndex, dlcPortStatusNetTxBwUtilization=dlcPortStatusNetTxBwUtilization, dlcDelayMonitorConfigIndex=dlcDelayMonitorConfigIndex, dlcDsx1Bit7Stuffing=dlcDsx1Bit7Stuffing, dlcAlarmSignal=dlcAlarmSignal, dlcDLCItableEntry=dlcDLCItableEntry, dlcUnitInbandMode=dlcUnitInbandMode, dlcNetInterfaceLMIStatus=dlcNetInterfaceLMIStatus, dlcSnmpTrapDlci3=dlcSnmpTrapDlci3, dlcUnitExternalAlarmOutputContacts=dlcUnitExternalAlarmOutputContacts, dlcUnitInbandConfig=dlcUnitInbandConfig, dlcArchiveNetTxPackets=dlcArchiveNetTxPackets, dlcUnitErrorFreeSeconds=dlcUnitErrorFreeSeconds, dlcLinkTestErroredPackets=dlcLinkTestErroredPackets, MacAddress=MacAddress, dlcUnitTestEntry=dlcUnitTestEntry, RemoteCommunicationsMode=RemoteCommunicationsMode, endAlarm=endAlarm, dlcUnitBlockAllAlarms=dlcUnitBlockAllAlarms, dlcDelayMonitorReceivedPackets=dlcDelayMonitorReceivedPackets, dlcManagementDLCI=dlcManagementDLCI, dlcDsx1ReceiveYellowAlarmTrapEnable=dlcDsx1ReceiveYellowAlarmTrapEnable, dlcUnitHwOptions=dlcUnitHwOptions, dlcLifetimeBpvErrors=dlcLifetimeBpvErrors, dlcAlarmPort=dlcAlarmPort, dlcUnitFullBandwidthLoopCode=dlcUnitFullBandwidthLoopCode, dlcDsx1OofThresholdTrap=dlcDsx1OofThresholdTrap, dlcDataConfigPortId=dlcDataConfigPortId, dlcSnmpTrapAddr3=dlcSnmpTrapAddr3, UnitStatusItem=UnitStatusItem, dlcUnitSnmpConfig=dlcUnitSnmpConfig, dlcDsx1InbandLinkTrapEnable=dlcDsx1InbandLinkTrapEnable, dlcUnitExternalAlarmInputMessage=dlcUnitExternalAlarmInputMessage, dlcUnitDsx1TrapEnableTable=dlcUnitDsx1TrapEnableTable, dlcMuxConfigSlotNumber=dlcMuxConfigSlotNumber, dlcMuxConfigPortId=dlcMuxConfigPortId, dlcUtil20_40=dlcUtil20_40, dlcUnitExternalAlarmInputContacts=dlcUnitExternalAlarmInputContacts, dlcUnitTimeMinute=dlcUnitTimeMinute, dlcUnitDelayMonitorStatus=dlcUnitDelayMonitorStatus, dlcLMIConditioningGroup=dlcLMIConditioningGroup, dlcUnitTestPatternStatus=dlcUnitTestPatternStatus, dlcModemInitString2=dlcModemInitString2, dlcUnitStatus=dlcUnitStatus, dlcDataConfigEncoding=dlcDataConfigEncoding, dlcDsx1ReceiveRemoteAlarmTrapEnable=dlcDsx1ReceiveRemoteAlarmTrapEnable, dlcDsx1LossOfSyncTrapEnable=dlcDsx1LossOfSyncTrapEnable, dlcDsx1PSfailureTrapEnable=dlcDsx1PSfailureTrapEnable, dlcSnmpTrapDirection3=dlcSnmpTrapDirection3, dlcDTEInterfaceLMIStatus=dlcDTEInterfaceLMIStatus, dlcSnmpUnitNetMask=dlcSnmpUnitNetMask, dlcDelayMonitorMaximumRoundTrip=dlcDelayMonitorMaximumRoundTrip, dlcSnmpTrapDlci1=dlcSnmpTrapDlci1, startTest=startTest, dlcDataLossPortId=dlcDataLossPortId, dlcDelayMonitorTargetAddress=dlcDelayMonitorTargetAddress, dlcMuxConfigBusId=dlcMuxConfigBusId, dlcUnitTimeDay=dlcUnitTimeDay, dlcDsx1TrapPortId=dlcDsx1TrapPortId, dlcDelayMonitorState=dlcDelayMonitorState, dlcDsx1UseAnsiProtocol=dlcDsx1UseAnsiProtocol, dlcUnitTestPatternErrors=dlcUnitTestPatternErrors, dlcCurrentOofErrors=dlcCurrentOofErrors, dlcUnitPvcAutoDiscovery=dlcUnitPvcAutoDiscovery, dlcLMIErrorMonitorEvent=dlcLMIErrorMonitorEvent, dlcUnitAlarmTable=dlcUnitAlarmTable, dlcUnitErrorSecondsRatio=dlcUnitErrorSecondsRatio, dlcDsx1LineMatching=dlcDsx1LineMatching, dlcFullStatusPollingCounter=dlcFullStatusPollingCounter, dlcSnmpTrapDlci2=dlcSnmpTrapDlci2, dlcArchivePortId=dlcArchivePortId, dlcUnitModelType=dlcUnitModelType, dlcDsx1CntlCrdMissingTrapEnable=dlcDsx1CntlCrdMissingTrapEnable, dlcLinkTestAverageRoundTrip=dlcLinkTestAverageRoundTrip, dlcUtil80_100=dlcUtil80_100, dlcArchiveNetRxPackets=dlcArchiveNetRxPackets, dlcLinkTestPort=dlcLinkTestPort, dlcAlarmType=dlcAlarmType, dlcDelayMonitorStatusEntry=dlcDelayMonitorStatusEntry, dlcUnitFractionalLoopCode=dlcUnitFractionalLoopCode, dlcUnitExternalAlarmInputTrapEnable=dlcUnitExternalAlarmInputTrapEnable, dlcSpoofingStatus=dlcSpoofingStatus, TestType=TestType, dlcUnitMibRev=dlcUnitMibRev, dlcModemPhoneNum2=dlcModemPhoneNum2, dlcUnitFlash=dlcUnitFlash, dlcDsx1DacsMode=dlcDsx1DacsMode, dlcCurrentES=dlcCurrentES, AlarmType=AlarmType, dlcUserLifetimeEntry=dlcUserLifetimeEntry, dlcDataDteConfigEntry=dlcDataDteConfigEntry, dlcRemoteCommunicationsMode=dlcRemoteCommunicationsMode, dlcUtilMoreThan100=dlcUtilMoreThan100, dlcMaintenanceDLCI=dlcMaintenanceDLCI, dlcDsx1BpvThresholdTrap=dlcDsx1BpvThresholdTrap, dlcDsx1InBandBit=dlcDsx1InBandBit, dlcUnitConfigLinkTest=dlcUnitConfigLinkTest, dlcDsx1IbCrcThresholdTrap=dlcDsx1IbCrcThresholdTrap, dlcSnmpTrapDirection2=dlcSnmpTrapDirection2, dlcUnitHwRev=dlcUnitHwRev, dlcUnitCurrentStatus=dlcUnitCurrentStatus, dlcUnitDelayMonitorConfig=dlcUnitDelayMonitorConfig, dlcModemInitString1=dlcModemInitString1, dlcUserArchiveEntry=dlcUserArchiveEntry, dlcSnmpTrapDirection=dlcSnmpTrapDirection, FramedUnframed=FramedUnframed, dlcDelayMonitorPacketSize=dlcDelayMonitorPacketSize, dlcDsx1FdlLinkTrapEnable=dlcDsx1FdlLinkTrapEnable, dlcUnitTimeHour=dlcUnitTimeHour, dlcDelayMonitorInterval=dlcDelayMonitorInterval, dlcUnitNetPassFdl=dlcUnitNetPassFdl, dlcSnmpTrapAddr2=dlcSnmpTrapAddr2, dlcEthernetMacAddr=dlcEthernetMacAddr, dlcUnitLastSelfTestResult=dlcUnitLastSelfTestResult, dlcDataConfigLoss=dlcDataConfigLoss, dlcLMIUnitLocation=dlcLMIUnitLocation, dlcLifetimeES=dlcLifetimeES, dlcArchiveES=dlcArchiveES, dlcDelayMonitorDlci=dlcDelayMonitorDlci, dlcLMIErrorEvent=dlcLMIErrorEvent, dlcLinkTestState=dlcLinkTestState, dlcLMIErrorFreeMonitorEvent=dlcLMIErrorFreeMonitorEvent, dlcDelayMonitorConfigTable=dlcDelayMonitorConfigTable, dlcLinkTestPattern=dlcLinkTestPattern, dlcUnitTimeYear=dlcUnitTimeYear, dlcDelayMonitorPort=dlcDelayMonitorPort, dlcUnitYellowEnable=dlcUnitYellowEnable, dlcUnitTestTable=dlcUnitTestTable, dlcSnmpUnitIpAddr=dlcSnmpUnitIpAddr, dlcUnitUserArchiveTable=dlcUnitUserArchiveTable, dlcUnitBackgroundBlockErrorRatio=dlcUnitBackgroundBlockErrorRatio, endTest=endTest, dlcCurrentUAS=dlcCurrentUAS, dlcNETCIR=dlcNETCIR, dlcUnitUserPattern1=dlcUnitUserPattern1, dlcUtil40_60=dlcUtil40_60, dlcLinkTestDlci=dlcLinkTestDlci, dlcUnitUserArchive=dlcUnitUserArchive, dlcPortStatus=dlcPortStatus, dlcArchiveIbCrcErrors=dlcArchiveIbCrcErrors, dlcMuxConfigEntry=dlcMuxConfigEntry, dlcUnitUserCurrentTable=dlcUnitUserCurrentTable, dlcCurrentIbCrcErrors=dlcCurrentIbCrcErrors, dlcDLCInumber=dlcDLCInumber, dlcDsx1ReceiveAIStrapEnable=dlcDsx1ReceiveAIStrapEnable, dlcUnitTestLength=dlcUnitTestLength, dlcUnitTest=dlcUnitTest, dlcUnitDataPorts=dlcUnitDataPorts, dlcUnitMuxConfigTable=dlcUnitMuxConfigTable, dlcValidIntervals=dlcValidIntervals, dlcUnitConfig=dlcUnitConfig, dlcLifetimeCrcErrors=dlcLifetimeCrcErrors, dlcDsx1ConfigPortId=dlcDsx1ConfigPortId, dlcUtilTimestamp=dlcUtilTimestamp, dl_new_t1=dl_new_t1, dlcUtilTableEntry=dlcUtilTableEntry, dlcDataLossEnable=dlcDataLossEnable, dlcDLCIstatus=dlcDLCIstatus, PortId=PortId, dlcArchiveOofErrors=dlcArchiveOofErrors, dlcDTEResponseTimer=dlcDTEResponseTimer, dlcUserArchiveValidEntry=dlcUserArchiveValidEntry, dlcDataDteLossTrapEnableEntry=dlcDataDteLossTrapEnableEntry, dlcUnitUserPattern2=dlcUnitUserPattern2, dlcUnitRom=dlcUnitRom, dlcUnitExternalAlarmOutputTrapEnable=dlcUnitExternalAlarmOutputTrapEnable, dlcDLCItable=dlcDLCItable, dlcLinkTestAddress=dlcLinkTestAddress, dlcUnitProtectMode=dlcUnitProtectMode, dlcUnitExtClockRate=dlcUnitExtClockRate, dlcEthernetIpMask=dlcEthernetIpMask, dlcDelayMonitorPattern=dlcDelayMonitorPattern, dlcLifetimeIbCrcErrors=dlcLifetimeIbCrcErrors, dlcDsx1LineCode=dlcDsx1LineCode, dlcUtilDLCINumber=dlcUtilDLCINumber, dlcSnmpEthernetConfiguration=dlcSnmpEthernetConfiguration, dlcArchiveInterval=dlcArchiveInterval, dlcLMIEnable=dlcLMIEnable, dlcUnitInbandTrafficType=dlcUnitInbandTrafficType, dlcUtilizationTable=dlcUtilizationTable, startAlarm=startAlarm, dlcUnitTimeSecond=dlcUnitTimeSecond, dlcDelayMonitorConfigEntry=dlcDelayMonitorConfigEntry, dlcCurrentCrcErrors=dlcCurrentCrcErrors, dlcDsx1LossOfSignalTrapEnable=dlcDsx1LossOfSignalTrapEnable, dlcDsx1ConfigEntry=dlcDsx1ConfigEntry, dlcDelayMonitorStatusTable=dlcDelayMonitorStatusTable, dlcLMIErrorFreeEvent=dlcLMIErrorFreeEvent, dlcUnitSlotNum=dlcUnitSlotNum, dlcUnitPerformanceMonitoring=dlcUnitPerformanceMonitoring, dlcArchiveUAS=dlcArchiveUAS, dlcUnitRam=dlcUnitRam, dlcPortStatusNetRxBwUtilization=dlcPortStatusNetRxBwUtilization, dlcUnitSerialNum=dlcUnitSerialNum, dlcUtilEncodedValue=dlcUtilEncodedValue, dlcDsx1TrapEnableEntry=dlcDsx1TrapEnableEntry, dlcDsx1Framing=dlcDsx1Framing, dlcAlarmEntry=dlcAlarmEntry, dlcCurrentTimeElapsed=dlcCurrentTimeElapsed, dlcUnitUserLifetimeTable=dlcUnitUserLifetimeTable, dlcLifetimePortId=dlcLifetimePortId, dlcLifetimeOofErrors=dlcLifetimeOofErrors, dlcUnitTestPortId=dlcUnitTestPortId, dlcDataConfigTransmitTiming=dlcDataConfigTransmitTiming, dlcLifetimeUAS=dlcLifetimeUAS, dlcUnitSwRev=dlcUnitSwRev, dlcManagementDLCIEnable=dlcManagementDLCIEnable, dlcLinkTestMaximumRoundTrip=dlcLinkTestMaximumRoundTrip, dlcNetSpoofingEnable=dlcNetSpoofingEnable, dlcLinkTestMissingPackets=dlcLinkTestMissingPackets, dlcLMIConfiguration=dlcLMIConfiguration, dlcDelayMonitorErroredPackets=dlcDelayMonitorErroredPackets, dlcPortStatusId=dlcPortStatusId)
mibBuilder.exportSymbols("DL-NEW-DSX1-MIB", dlcLinkIntegrityVerificationPollingTimer=dlcLinkIntegrityVerificationPollingTimer, dlcPortStatusEntry=dlcPortStatusEntry, dlcLinkTestInterval=dlcLinkTestInterval, dlcDataConfigFormat=dlcDataConfigFormat, dlcArchiveNetTxBwUtilization=dlcArchiveNetTxBwUtilization, manualConfigChange=manualConfigChange, dlcLMIStatus=dlcLMIStatus, dlcUtilLessThan20=dlcUtilLessThan20, dlcUnitDialOutTimeInterval=dlcUnitDialOutTimeInterval, dlcUnitPortStatusTable=dlcUnitPortStatusTable, dlcArchiveCrcErrors=dlcArchiveCrcErrors, dlcDTECIR=dlcDTECIR, dlcArchiveNetRxBwUtilization=dlcArchiveNetRxBwUtilization, dlcUnitUserArchiveValidTable=dlcUnitUserArchiveValidTable, dlcUnitMainClockSource=dlcUnitMainClockSource)

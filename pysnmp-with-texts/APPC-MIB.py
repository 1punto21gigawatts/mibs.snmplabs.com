#
# PySNMP MIB module APPC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APPC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:23:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
snanauMIB, = mibBuilder.importSymbols("SNA-NAU-MIB", "snanauMIB")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, mib_2, Counter64, NotificationType, Unsigned32, IpAddress, Bits, TimeTicks, iso, Gauge32, Counter32, Integer32, ObjectIdentity, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "mib-2", "Counter64", "NotificationType", "Unsigned32", "IpAddress", "Bits", "TimeTicks", "iso", "Gauge32", "Counter32", "Integer32", "ObjectIdentity", "MibIdentifier")
InstancePointer, DisplayString, TextualConvention, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "InstancePointer", "DisplayString", "TextualConvention", "DateAndTime")
appcMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 34, 3))
if mibBuilder.loadTexts: appcMIB.setLastUpdated('9512150000Z')
if mibBuilder.loadTexts: appcMIB.setOrganization('IETF SNA NAU MIB Working Group')
if mibBuilder.loadTexts: appcMIB.setContactInfo(' Michael Allen Wall Data Inc. P.O.Box 1120 Duval, WA 98019, USA Tel: 1 206 844 3505 E-mail: mallen@hq.walldata.com Bob Clouston Cisco Systems 7025 Kit Creek Road P.O. Box 14987 Research Triangle Park, NC 27709, USA Tel: 1 919 472 2333 E-mail: clouston@cisco.com Zbigniew Kielczewski Cisco Systems 3100 Smoketree Court Raleigh, NC 27604, USA Tel: 1 919 871 6326 E-mail: zbig@cisco.com William Kwan Jupiter Technology Inc. 200 Prospect Street Waltham, MA 02254, USA Tel: 1 617 894 9300, x423 E-mail: billk@jti.com Bob Moore IBM Corporation 800 Park Offices Drive CNMA/664 P.O. Box 12195 Research Triangle Park, NC 27709, USA Tel: 1 919 254 4436 E-mail: remoore@ralvm6.vnet.ibm.com ')
if mibBuilder.loadTexts: appcMIB.setDescription('This is the MIB module for objects used to manage network devices with APPC capabilities.')
appcObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1))
appcGlobal = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1))
appcLu = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 2))
appcTp = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 3))
appcSession = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 4))
appcConversation = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 5))
appcCPIC = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 6))
class SnaSenseData(DisplayString):
    description = "To facilitate their display by a Management Station, sense data objects in the MIB are represented as DisplayStrings of size 8. Eight '0' characters indicates that no sense data identifying an SNA error condition is available."
    status = 'current'
    subtypeSpec = DisplayString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

appcCntrlAdminGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1))
appcCntrlAdminStat = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCntrlAdminStat.setStatus('current')
if mibBuilder.loadTexts: appcCntrlAdminStat.setDescription('Indicates the desired state of statistics collection: notActive collection of counters is not active. active collection of counters is active. When this object is set to notActive, all of the entries are removed from the appcSessStatsTable.')
appcCntrlAdminRscv = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCntrlAdminRscv.setStatus('current')
if mibBuilder.loadTexts: appcCntrlAdminRscv.setDescription('Indicates the desired state of RSCV information collection: notActive collection of route selection control vectors is not active. active collection of route selection control vectors is active.')
appcCntrlAdminTrace = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCntrlAdminTrace.setStatus('current')
if mibBuilder.loadTexts: appcCntrlAdminTrace.setDescription('Indicates the desired state of tracing: notActive collection of tracing information is not active active collection of tracing information is active')
appcCntrlAdminTraceParm = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCntrlAdminTraceParm.setStatus('current')
if mibBuilder.loadTexts: appcCntrlAdminTraceParm.setDescription('Specifies the parameter to be used in conjunction with activating tracing. The actual content is implementation dependent.')
appcCntrlOperGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2))
appcCntrlOperStat = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperStat.setStatus('current')
if mibBuilder.loadTexts: appcCntrlOperStat.setDescription("Indicates the current collection options in effect: notActive collection of counters is not active. active collection of counters is active. Statistical entries are present in the appcSessStatsTable only when the value of this object is 'active'.")
appcCntrlOperStatTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperStatTime.setStatus('current')
if mibBuilder.loadTexts: appcCntrlOperStatTime.setDescription('Time since the appcCntrlOperStat object last changed. This time is in hundreds of a second.')
appcCntrlOperRscv = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperRscv.setStatus('current')
if mibBuilder.loadTexts: appcCntrlOperRscv.setDescription('Indicates the current collection options in effect: notActive collection of route selection control vectors is not active. active collection of route selection control vectors is active.')
appcCntrlOperRscvTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperRscvTime.setStatus('current')
if mibBuilder.loadTexts: appcCntrlOperRscvTime.setDescription('Time since the appcCntrlOperRscv object last changed. This time is in hundreds of a second.')
appcCntrlOperTrace = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperTrace.setStatus('current')
if mibBuilder.loadTexts: appcCntrlOperTrace.setDescription('Indicates the current state of tracing: notActive collection of tracing information is not active. active collection of tracing information is active.')
appcCntrlOperTraceTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperTraceTime.setStatus('current')
if mibBuilder.loadTexts: appcCntrlOperTraceTime.setDescription('Time since the appcCntrlOperTrace object last changed. This time is in hundreds of a second.')
appcCntrlOperTraceParm = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCntrlOperTraceParm.setStatus('current')
if mibBuilder.loadTexts: appcCntrlOperTraceParm.setDescription('Specifies the parameter used in conjunction with activating tracing. The actual content is implementation dependent.')
appcGlobalObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3))
appcUpTime = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcUpTime.setStatus('current')
if mibBuilder.loadTexts: appcUpTime.setDescription('The time, in hundredths of a second, since the APPC portion of the system was last reinitialized.')
appcDefaultModeName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultModeName.setStatus('current')
if mibBuilder.loadTexts: appcDefaultModeName.setDescription('Specifies the mode name to be used under the following conditions: When an incoming BIND request contains a mode name not defined at the local node. The parameters defined for this mode are used for the inbound implicit mode capability. When an APPC program issues an [MC_]ALLOCATE, [MC_]SEND_CONVERSATION, or CNOS verb, or when a CPI-C program issues an Allocate (CMALLC) call, specifying a mode name not defined at the local node. The parameters defined for this mode are used for the outbound implicit mode capability. This mode name must match a defined entry in the appcModeAdminTable.')
appcDefaultLuName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultLuName.setStatus('current')
if mibBuilder.loadTexts: appcDefaultLuName.setDescription('Specifies the name of the local LU that is to serve as the default LU. This is the default LU to which are routed inbound BIND requests that exclude the secondary LU name. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. This local LU name must match a defined entry in the appcLluAdminTable.')
appcDefaultImplInbndPlu = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultImplInbndPlu.setStatus('current')
if mibBuilder.loadTexts: appcDefaultImplInbndPlu.setDescription('Specifies whether or not inbound implicit partner LU support is enabled. The following values are defined: no - Specifies that inbound implicit partner LU support is disabled, which means that an incoming bind that specifies a partner LU that is not defined at the local node will be rejected. yes - Specifies that inbound implicit partner LU support is enabled, which provides the capability to accept an incoming BIND request that contains a partner LU name that is not defined at the local node.')
appcDefaultMaxMcLlSndSize = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultMaxMcLlSndSize.setStatus('current')
if mibBuilder.loadTexts: appcDefaultMaxMcLlSndSize.setDescription('Specifies the maximum size of a logical record to be used for a mapped conversation when sending data to either the inbound or outbound implicit partner LU. This size is the maximum number of bytes in a single logical record, as indicated in the LL field of the record. The default value is 32767. Note that this object does not limit the maximum size that an application program can supply on the Send Data call for a mapped conversation.')
appcDefaultFileSpec = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultFileSpec.setStatus('current')
if mibBuilder.loadTexts: appcDefaultFileSpec.setDescription("The local file specification that is to be searched by the APPC attach manager when no DEFINE_TP verb has been issued for the TP name received on an incoming attach. In this case, the attach manager will attempt to start a program whose file name is the same as the incoming TP name. If found, the program is loaded. If not found, the attach is rejected. The value '*' indicates that the normal search path for executable programs is to be used for locating an undefined transaction program. A null string indicates that there is no default file specification for undefined transaction programs.")
appcDefaultTpOperation = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("queuedOperatorStarted", 2), ("queuedOperatorPreloaded", 3), ("queuedAmStarted", 4), ("nonqueuedAmStarted", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultTpOperation.setStatus('current')
if mibBuilder.loadTexts: appcDefaultTpOperation.setDescription('Specifies how the program will be started. other - Specifies that the default TP operation is none of the methods specified below. It may be a product-specific method. queuedOperatorStarted - Specifies that one version of the program will be run at a time. If an incoming attach arrives and the program has not been started yet, APPC will issue a message to the operator to start the specified program. Subsequent attaches that arrive while the program is active will be queued. queuedOperatorPreloaded - Specifies that one version of the program will be run at a time. If an incoming attach arrives and the program has not been started yet, the Attach will be rejected. The APPC attach manager determines that a TP has started upon reception of an APPC RECEIVE_ALLOCATE verb, or a CPI-C Accept_Conversation (CMACCP) or Specify_Local_TP_Name (CMSLTP) call. No message is sent to the operator. Subsequent attaches that arrive while the program is active are queued. queuedAmStarted - Specifies that one version of the program will be run at a time and will be started by the APPC attach manager. Subsequent attaches that arrive while the program is active will be queued. nonqueuedAmStarted - Specifies that multiple copies of the program will be run at a time and will be started by the APPC attach manager. ')
appcDefaultTpConvSecRqd = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcDefaultTpConvSecRqd.setStatus('current')
if mibBuilder.loadTexts: appcDefaultTpConvSecRqd.setDescription('Specifies whether or not conversation security will be used for default TPs. no - Specifies that the incoming attach does not have to contain security information. yes - Specifies that the incoming attach must contain valid authentication information (e.g., user ID and password).')
appcLocalCpName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLocalCpName.setStatus('current')
if mibBuilder.loadTexts: appcLocalCpName.setDescription('Specifies the name of the local control point. This field is from 0 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. A null string indicates that the value is unknown.')
appcActiveSessions = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveSessions.setStatus('current')
if mibBuilder.loadTexts: appcActiveSessions.setDescription('Specifies the total number of active APPC sessions supported by this implementation. Sessions for which both LUs are local are counted twice.')
appcActiveHprSessions = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 3, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveHprSessions.setStatus('current')
if mibBuilder.loadTexts: appcActiveHprSessions.setDescription('Specifies the total number of active HPR APPC sessions.')
appcCnosControl = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4))
appcCnosCommand = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("initSesslimit", 1), ("changeSesslimit", 2), ("resetSesslimit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosCommand.setStatus('current')
if mibBuilder.loadTexts: appcCnosCommand.setDescription('Specifies the CNOS command or verb to issue. First set the values of the particular CNOS parameter objects (from the range { appcCnosControl 2 } through { appcCnosControl 8 }) that apply to the CNOS command to be executed, set the three CNOS target objects ({ appcCnosControl 9 } through { appcCnosControl 11 }), then set this object to the command to be executed. Here is the list of parameter objects that must be set for each of the CNOS commands: INIT_SESSION_LIMIT - appcCnosMaxSessLimit appcCnosMinCwinLimit appcCnosMinClosLimit appcCnosTargetLocLuName appcCnosTargetParLuName appcCnosTargetModeName CHANGE_SESSION_LIMIT - appcCnosMaxSessLimit appcCnosMinCwinLimit appcCnosMinClosLimit appcCnosResponsible appcCnosTargetLocLuName appcCnosTargetParLuName appcCnosTargetModeName RESET_SESSION_LIMIT - appcCnosResponsible appcCnosDrainPart appcCnosForce appcCnosTargetLocLuName appcCnosTargetParLuName appcCnosTargetModeName ')
appcCnosMaxSessLimit = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosMaxSessLimit.setStatus('current')
if mibBuilder.loadTexts: appcCnosMaxSessLimit.setDescription('Specifies the maximum value that the local LU is to use, during CNOS processing, for the session limit. The local LU, as a target LU, will negotiate a higher session limit it receives in the CNOS request down to this maximum value. The local LU, as a source LU, will restrict the session limit it sends in a CNOS request to a value less than or equal to this maximum value. If set (i.e., greater than 0), this overrides the maximum session limit defined in the appcModeAdminTable. This parameter should be set to the desired value before setting the command (appcCnosCommand). This parameter applies to the INITIALIZE_SESSION_LIMIT and CHANGE_SESSION_LIMIT verbs.')
appcCnosMinCwinLimit = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosMinCwinLimit.setStatus('current')
if mibBuilder.loadTexts: appcCnosMinCwinLimit.setDescription('Specifies the default minimum contention winner sessions limit. This parameter should be set to the desired value before setting the command (appcCnosCommand). This parameter applies to the INITIALIZE_SESSION_LIMIT and CHANGE_SESSION_LIMIT verbs.')
appcCnosMinClosLimit = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosMinClosLimit.setStatus('current')
if mibBuilder.loadTexts: appcCnosMinClosLimit.setDescription('Specifies the default minimum contention loser sessions limit. This parameter should be set to the desired value before setting the command (appcCnosCommand). This parameter applies to the INITIALIZE_SESSION_LIMIT and CHANGE_SESSION_LIMIT verbs.')
appcCnosDrainSelf = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosDrainSelf.setStatus('current')
if mibBuilder.loadTexts: appcCnosDrainSelf.setDescription('Specifies whether the local LU is draining its conversations for this mode. When a mode session limit is reset (via a CNOS RESET_SESSION_LIMIT request), the local LU could be set to process all queued conversations before deactivating all of the sessions (using the SNA Bracket Initiation Stopped or BIS protocol). This parameter should be set to the desired value before setting the command (appcCnosCommand). This parameter applies only to the RESET_SESSION_LIMIT verb.')
appcCnosDrainPart = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosDrainPart.setStatus('current')
if mibBuilder.loadTexts: appcCnosDrainPart.setDescription('Specifies whether the partner LU is draining its conversations for this mode. When a mode session limit is reset (via a CNOS RESET_SESSION_LIMIT request), the partner LU could be set to process all queued conversations before deactivating all of the sessions (using the SNA Bracket Initiation Stop or BIS protocol). This parameter should be set to the desired value before setting the command (appcCnosCommand). This parameter applies only to the RESET_SESSION_LIMIT verb.')
appcCnosResponsible = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("source", 1), ("target", 2))).clone('source')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosResponsible.setStatus('current')
if mibBuilder.loadTexts: appcCnosResponsible.setDescription('Specifies which LU is responsible for selecting and deactivating sessions as a result of a change that decreases the session limit or the maximum number of contention winner sessions for the source or target LU. If no session need to be deactivated, this parameter is ignored. source - specifies that the source (local) LU is responsible. The target (partner) LU cannot negotiate this value. target - specifies that the target (partner) LU is responsible. The target LU can negotiate this value to source. This parameter should be set to the desired value before setting the command (appcCnosCommand). This parameter applies to the RESET_SESSION_LIMIT and CHANGE_SESSION_LIMIT verbs.')
appcCnosForce = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosForce.setStatus('current')
if mibBuilder.loadTexts: appcCnosForce.setDescription('Specifies whether the local LU should force the resetting of the session limit when certain error conditions occur that prevent the successful exchange of CNOS request and reply. This parameter should be set to the desired value before setting the command (appcCnosCommand). This parameter applies only to the RESET_SESSION_LIMIT verb.')
appcCnosTargetLocLuName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosTargetLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcCnosTargetLocLuName.setDescription('The SNA name of the local LU to which the CNOS command is to be applied. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. This object should be set to the desired value before setting the command (appcCnosCommand). This parameter applies to all CNOS verbs.')
appcCnosTargetParLuName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosTargetParLuName.setStatus('current')
if mibBuilder.loadTexts: appcCnosTargetParLuName.setDescription('The SNA name of the partner LU to which the CNOS command is to be applied. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. This object should be set to the desired value before setting the command (appcCnosCommand). This parameter applies to all CNOS verbs.')
appcCnosTargetModeName = MibScalar((1, 3, 6, 1, 2, 1, 34, 3, 1, 1, 4, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcCnosTargetModeName.setStatus('current')
if mibBuilder.loadTexts: appcCnosTargetModeName.setDescription('Specifies the mode name to which the CNOS command is to be applied. This object should be set to the desired value before setting the command (appcCnosCommand). This parameter applies to all CNOS verbs.')
appcLluAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1), )
if mibBuilder.loadTexts: appcLluAdminTable.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminTable.setDescription('APPC Local LU Admin Table.')
appcLluAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcLluAdminName"))
if mibBuilder.loadTexts: appcLluAdminEntry.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminEntry.setDescription('Information about local APPC LUs. ')
appcLluAdminName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcLluAdminName.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminName.setDescription('Specifies the name of the local LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcLluAdminDepType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dependent", 1), ("independent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminDepType.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminDepType.setDescription('This value identifies whether the LU is dependent or independent.')
appcLluAdminLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminLocalAddress.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminLocalAddress.setDescription('The local address for this LU is a byte with a value ranging from 0 to 254. For dependent LUs, this value ranges from 1 to 254; for independent LUs this value is always 0.')
appcLluAdminSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminSessLimit.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminSessLimit.setDescription('The maximum number of sessions supported by this LU.')
appcLluAdminBindRspMayQ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminBindRspMayQ.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminBindRspMayQ.setDescription('Indicates whether or not the local LU, as the sender of a BIND request, allows a partner partner LU to delay sending the BIND response if the partner LU cannot process the BIND request immediately.')
appcLluAdminCompression = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("prohibited", 1), ("required", 2), ("negotiable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminCompression.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminCompression.setDescription('Specifies whether compression is supported. The local LU uses this value for negotiation during session activation (SNA BIND). prohibited - specifies that no compression is to be used. required - specifies that compression is required. negotiable - specifies that the usage of compression is to be negotiated between the LUs. The level of compression is also negotiated.')
appcLluAdminInBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminInBoundCompLevel.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminInBoundCompLevel.setDescription('Specifies the maximum level of compression supported for inbound data. The local LU uses this value in conjunction with appcLluAdminCompression for negotiation during session activation (SNA BIND). none - specifies that no compression is to be used. rle - specifies run-length encoding compression in which a 1 or 2 byte sequence substitution is used for each repeated run of the same character. lz9 - specifies Lempel-Ziv-like compression in which 9 bit codes are used to substitute repeated substrings in the data stream. These codes are indices that refer to entries in a common dictionary generated adaptively at both sender and receiver as the data flows and compression occurs. The larger number bits used for the code, the more storage space is required for the dictionary, but the larger the compression ratio. lz10 - specifies a 10 bit code Lempel-Ziv-like compression. lz12 - specifies a 12 bit code Lempel-Ziv-like compression.')
appcLluAdminOutBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminOutBoundCompLevel.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminOutBoundCompLevel.setDescription('Specifies the maximum level of compression supported for outbound data. The local LU uses this value in conjunction with appcLluAdminCompression for negotiation during session activation (SNA BIND). none - specifies that no compression is to be used. rle - specifies run-length encoding compression in which a 1 or 2 byte sequence substitution is used for each repeated run of the same character. lz9 - specifies Lempel-Ziv-like compression in which 9 bit codes are used to substitute repeated substrings in the data stream. These codes are indices that refer to entries in a common dictionary generated adaptively at both sender and receiver as the data flows and compression occurs. The larger of number bits used for the code, the more storage space is required for the dictionary, but the larger the compression ratio. lz10 - specifies a 10 bit code Lempel-Ziv-like compression. lz12 - specifies a 12 bit code Lempel-Ziv-like compression.')
appcLluAdminCompRleBeforeLZ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminCompRleBeforeLZ.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminCompRleBeforeLZ.setDescription('Specifies whether run-length encoding is to be applied to the data before applying Lempel-Ziv-like compression. The local LU uses this value for negotiation during session activation (SNA BIND). This parameter is only supported if LZ compression is used.')
appcLluAdminAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluAdminAlias.setStatus('current')
if mibBuilder.loadTexts: appcLluAdminAlias.setDescription('A local alias for the local LU. If not known or not applicable, this object contains a zero-length string.')
appcLluOperTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2), )
if mibBuilder.loadTexts: appcLluOperTable.setStatus('current')
if mibBuilder.loadTexts: appcLluOperTable.setDescription('APPC Local LU Operational Table.')
appcLluOperEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1), ).setIndexNames((0, "APPC-MIB", "appcLluOperName"))
if mibBuilder.loadTexts: appcLluOperEntry.setStatus('current')
if mibBuilder.loadTexts: appcLluOperEntry.setDescription('Information about local APPC LUs.')
appcLluOperName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcLluOperName.setStatus('current')
if mibBuilder.loadTexts: appcLluOperName.setDescription('Specifies the name of the local LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcLluOperDepType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dependent", 1), ("independent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperDepType.setStatus('current')
if mibBuilder.loadTexts: appcLluOperDepType.setDescription('This value identifies whether the LU is dependent or independent.')
appcLluOperLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperLocalAddress.setStatus('current')
if mibBuilder.loadTexts: appcLluOperLocalAddress.setDescription('The local address for this LU is a byte with a value ranging from 0 to 254. For dependent LUs, this value ranges from 1 to 254; for independent LUs this value is always 0.')
appcLluOperSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperSessLimit.setStatus('current')
if mibBuilder.loadTexts: appcLluOperSessLimit.setDescription('The maximum number of sessions supported by this LU.')
appcLluOperBindRspMayQ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperBindRspMayQ.setStatus('current')
if mibBuilder.loadTexts: appcLluOperBindRspMayQ.setDescription('Indicates whether or not the local LU, as the sender of a BIND request, allows a partner LU to delay sending the BIND response if the partner LU cannot process the BIND request immediately.')
appcLluOperCompression = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("prohibited", 1), ("required", 2), ("negotiable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperCompression.setStatus('current')
if mibBuilder.loadTexts: appcLluOperCompression.setDescription('Specifies whether compression is supported. The local LU uses this value for negotiation during session activation (SNA BIND). prohibited - specifies that no compression is to be used. required - specifies that compression is required. negotiable - specifies that the usage of compression is to be negotiated between the LUs. The level of compression is also negotiated.')
appcLluOperInBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperInBoundCompLevel.setStatus('current')
if mibBuilder.loadTexts: appcLluOperInBoundCompLevel.setDescription('Specifies the maximum level of compression supported for inbound data. The local LU uses this value in conjunction with appcLluOperCompression for negotiation during session activation (SNA BIND). none - specifies that no compression is to be used. rle - specifies run-length encoding compression in which a 1 or 2 byte sequence substitution is used for each repeated run of the same character. lz9 - specifies Lempel-Ziv-like compression in which 9 bit codes are used to substitute repeated substrings in the data stream. These codes are indices that refer to entries in a common dictionary generated adaptively at both sender and receiver as the data flows and compression occurs. The larger of number bits used for the code, the more storage space is required for the dictionary, but the larger the compression ratio. lz10 - specifies a 10 bit code Lempel-Ziv-like compression. lz12 - specifies a 12 bit code Lempel-Ziv-like compression.')
appcLluOperOutBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperOutBoundCompLevel.setStatus('current')
if mibBuilder.loadTexts: appcLluOperOutBoundCompLevel.setDescription('Specifies the maximum level of compression supported for outbound data. The local LU uses this value in conjunction with appcLluAdminCompression for negotiation during session activation (SNA BIND). none - specifies that no compression is to be used. rle - specifies run-length encoding compression in which a 1 or 2 byte sequence substitution is used for each repeated run of the same character. lz9 - specifies Lempel-Ziv-like compression in which 9 bit codes are used to substitute repeated substrings in the data stream. These codes are indices that refer to entries in a common dictionary generated adaptively at both sender and receiver as the data flows and compression occurs. The larger of number bits used for the code, the more storage space is required for the dictionary, but the larger the compression ratio. lz10 - specifies a 10 bit code Lempel-Ziv-like compression. lz12 - specifies a 12 bit code Lempel-Ziv-like compression.')
appcLluOperCompRleBeforeLZ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperCompRleBeforeLZ.setStatus('current')
if mibBuilder.loadTexts: appcLluOperCompRleBeforeLZ.setDescription('Specifies whether run-length encoding is to be applied to the data before applying Lempel-Ziv-like compression. The local LU uses this value for negotiation during session activation (SNA BIND). This parameter is only supported if LZ compression is used.')
appcLluOperAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperAlias.setStatus('current')
if mibBuilder.loadTexts: appcLluOperAlias.setDescription('A local alias for the local LU. If not known or not applicable, this object contains a zero-length string.')
appcLluOperActiveSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLluOperActiveSessions.setStatus('current')
if mibBuilder.loadTexts: appcLluOperActiveSessions.setDescription('Specifies the total number of active APPC sessions for this LU.')
appcLuPairAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3), )
if mibBuilder.loadTexts: appcLuPairAdminTable.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminTable.setDescription('APPC Partner LU administrative Table')
appcLuPairAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1), ).setIndexNames((0, "APPC-MIB", "appcLuPairAdminLocLuName"), (0, "APPC-MIB", "appcLuPairAdminParLuName"))
if mibBuilder.loadTexts: appcLuPairAdminEntry.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminEntry.setDescription('Entry of APPC Partner LU Information Table. It is indexed by the local and partner LU Names.')
appcLuPairAdminLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcLuPairAdminLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminLocLuName.setDescription("The SNA name of the local LU to which this partner LU definition applies. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. The reserved value '*ALL' indicates that the partner LU definition applies to all local LUs, and not just to a single local LU.")
appcLuPairAdminParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcLuPairAdminParLuName.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminParLuName.setDescription('The SNA name of the partner LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcLuPairAdminParLuAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminParLuAlias.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminParLuAlias.setDescription('A local alias for the partner LU. If not known or not applicable, this object contains a zero-length string.')
appcLuPairAdminSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminSessLimit.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminSessLimit.setDescription('The maximum number of sessions supported by this partner LU.')
appcLuPairAdminSessSec = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("required", 1), ("accepted", 2), ("notAllowed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminSessSec.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminSessSec.setDescription('Specifies the type of session-level security information that a local LU will accept on BIND requests it receives from the partner LU. required - Specifies that the BIND request must carry session level verification information that will be verified upon receipt. accepted - Specifies that the BIND request may carry session level verification information that will be verified upon receipt. notAllowed - Specifies that the BIND request must not carry session level verification information.')
appcLuPairAdminSecAccept = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("conversation", 2), ("alreadyVerified", 3), ("persistentVerification", 4), ("aVandpV", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminSecAccept.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminSecAccept.setDescription('Specifies support for different levels of access security information in ATTACH requests received from this partner LU. Possible values are: none - No access security information will be accepted on allocation requests (ATTACH) from this LU. conversation - Allocation requests will not be accepted that include already verified or persistent verification indicators. Accept conversation-level access security information, which must include both a user Id and password, and may also include a profile. alreadyVerified - Allocation requests will be accepted that include already verified indicators. Persistent verification indicators will not be accepted. persistentVerification - Allocation requests will be accepted that include persistent verification indicators. Already verified indicators will not be accepted. aVandpV - Allocation requests will be accepted that include already verified or persistent verification indicators.')
appcLuPairAdminLinkObjId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 7), InstancePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminLinkObjId.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminLinkObjId.setDescription('Specifies the link associated with this partner LU. This value points to the row in the table containing information on the link instance. (e.g., the sdlcLSAdminTable of the SNA DLC MIB module). This object may be NULL if the link is not specified or if a link is not applicable (as for APPN-level nodes).')
appcLuPairAdminParaSessSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairAdminParaSessSup.setStatus('current')
if mibBuilder.loadTexts: appcLuPairAdminParaSessSup.setDescription('Defined Parallel Sessions Supported. Indicates whether or not multiple sessions between the partner LU and its associated local LU are permitted. Parallel session support also indicates that Change Number of Sessions (CNOS) will be used to negotiate session limits between the LUs.')
appcLuPairOperTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4), )
if mibBuilder.loadTexts: appcLuPairOperTable.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperTable.setDescription('Table of active partner/local LU pairs. Two entries are present in the table when both LUs in a pair are local.')
appcLuPairOperEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1), ).setIndexNames((0, "APPC-MIB", "appcLuPairOperLocLuName"), (0, "APPC-MIB", "appcLuPairOperParLuName"))
if mibBuilder.loadTexts: appcLuPairOperEntry.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperEntry.setDescription('Entry representing one partner/local LU pair.')
appcLuPairOperLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcLuPairOperLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperLocLuName.setDescription('The SNA name of the local LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLluOperName, then the two entries being indexed apply to the same resource (specifically, to the same local LU).')
appcLuPairOperParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcLuPairOperParLuName.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperParLuName.setDescription('The SNA name of the partner LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcLuPairOperParLuAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperParLuAlias.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperParLuAlias.setDescription('A local alias for the partner LU. If not known or not applicable, this object contains a zero-length string.')
appcLuPairOperSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperSessLimit.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperSessLimit.setDescription('The maximum number of sessions supported by this partner LU.')
appcLuPairOperSessSec = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("required", 1), ("accepted", 2), ("notAllowed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperSessSec.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperSessSec.setDescription('Specifies the type of security information that a local LU will accept on BIND requests it receives from the partner LU. required - Specifies that the BIND request must carry session level verification information that will be verified upon receipt. accepted - Specifies that the BIND request may carry session level verification information that will be verified upon receipt. notAllowed - Specifies that the BIND request must not carry session level verification information.')
appcLuPairOperSecAccept = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("conversation", 2), ("alreadyVerified", 3), ("persistentVerification", 4), ("aVandpV", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperSecAccept.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperSecAccept.setDescription('Specifies support for different levels of security acceptance information in ATTACH requests received from this partner LU. Possible values are: none - No access security information will be accepted on allocation requests (ATTACH) from this LU. conversation - Allocation requests will not be accepted that include already verified or persistent verification indicators. Accept conversation-level access security information, which must include both a user Id and password, and may also include a profile. alreadyVerified - Allocation requests will be accepted that include already verified indicators. Persistent verification indicators will not be accepted. persistentVerification - Allocation requests will be accepted that include persistent verification indicators. Already verified indicators will not be accepted. aVandpV - Allocation requests will be accepted that include already verified or persistent verification indicators.')
appcLuPairOperLinkObjId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 7), InstancePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperLinkObjId.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperLinkObjId.setDescription('Specifies the link associated with this partner LU. This value points to the row in the table containing information on the link instance. (e.g., the sdlcLSAdminTable of the SNA DLC MIB module). This object may be NULL if the link is not specified or if a link is not applicable (as for APPN-level nodes).')
appcLuPairOperParaSessSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperParaSessSup.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperParaSessSup.setDescription('Active Parallel Sessions Supported. Indicates whether or not multiple session between the partner LU and its associated local LU are permitted. Parallel session support also indicates that Change Number of Sessions (CNOS) will be used to negotiate session limits between the LUs.')
appcLuPairOperParaSessSupLS = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperParaSessSupLS.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperParaSessSupLS.setDescription('Active Parallel Sessions Supported - last starting value. This object represents the initial value proposed by the local LU the last time this capability was negotiated, i.e., when the first session was bound between the local LU and its partner.')
appcLuPairOperState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcLuPairOperState.setStatus('current')
if mibBuilder.loadTexts: appcLuPairOperState.setDescription('The value identifies the current operational state of this LU pair: inactive (1) - no active or pending session exists between the LUs. active (2) - an active or pending session exists between the LUs.')
appcModeAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5), )
if mibBuilder.loadTexts: appcModeAdminTable.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminTable.setDescription('APPC Mode Table')
appcModeAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1), ).setIndexNames((0, "APPC-MIB", "appcModeAdminLocLuName"), (0, "APPC-MIB", "appcModeAdminParLuName"), (0, "APPC-MIB", "appcModeAdminModeName"))
if mibBuilder.loadTexts: appcModeAdminEntry.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminEntry.setDescription('Entry of APPC Mode Information Table.')
appcModeAdminLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcModeAdminLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminLocLuName.setDescription("The SNA name of the local LU to which this mode definition applies. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. The reserved value '*ALL' indicates that the mode definition applies to all local LUs for the SNA node identified by appcLocalCpName, and not just to a single local LU.")
appcModeAdminParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcModeAdminParLuName.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminParLuName.setDescription("The SNA name of the partner LU to which this mode definition applies. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. The reserved value '*ALL' indicates that the mode definition applies to all partner LUs for the SNA node identified by appcModeAdminLocLuName, and not just to a single partner LU.")
appcModeAdminModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appcModeAdminModeName.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminModeName.setDescription('Specifies the mode name. A mode defines the characteristics for a group of sessions. The mode name can be blank (8 space characters). ')
appcModeAdminCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminCosName.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminCosName.setDescription('Specifies the class of service (COS) name associated with this mode. If the implementation does not support COS names, a null string is returned.')
appcModeAdminSessEndTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSessEndTpName.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminSessEndTpName.setDescription("Specifies the name of the transaction program (TP) to be invoked when a session using this mode is deactivated or ended. If no such TP is defined, this object is a null string. When the TP name consists entirely of displayable EBCDIC code points, it is mapped directly to the equivalent ASCII display string. However, registered TP names always have a non- displayable EBCDIC code point (value less than or equal to x'3F') as the first character, so they cannot be directly mapped to an ASCII display string. These TP names are converted to a display string that is equivalent to a hexadecimal display of the EBCDIC code points. For example, the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte ASCII display string '06F1' (including the two single quotes). ")
appcModeAdminMaxSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminMaxSessLimit.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminMaxSessLimit.setDescription('Specifies the maximum value that the local LU is to use, during CNOS processing, for the session limit. The local LU, as a target LU, will negotiate a higher session limit it receives in the CNOS request down to this maximum value. The local LU, as a source LU, will restrict the session limit it sends in a CNOS request to a value less than or equal to this maximum value.')
appcModeAdminMinCwinLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminMinCwinLimit.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminMinCwinLimit.setDescription('Specifies the default minimum contention winner sessions limit. Some implementations internally issue a INITIALIZE_SESSION_LIMIT verb when a Mode is created. This value is the parameter used for the CNOS processing of that verb. This parameter is not used when issuing an explicit INITIALIZE_SESSION_LIMIT verb. The equivalent object in appcCnosCommandTable is used.')
appcModeAdminMinClosLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminMinClosLimit.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminMinClosLimit.setDescription('Specifies the default minimum contention loser sessions limit. Some implementations internally issue a INITIALIZE_SESSION_LIMIT verb when a Mode is created. This value is the parameter used for the CNOS processing of that verb. This is the same as target minimum contention winner sessions. This parameter is not used when issuing an explicit INITIALIZE_SESSION_LIMIT verb. The equivalent object in appcCnosCommandTable is used.')
appcModeAdminConWinAutoActLmt = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminConWinAutoActLmt.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminConWinAutoActLmt.setDescription('Specifies the limit on the number of contention winner sessions to be automatically activated when the minimum number of contention winner sessions increases (as a result of CNOS processing). The actual number of sessions activated is the lesser of this value and the new minimum number of contention winner sessions. ')
appcModeAdminRecvPacWinSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminRecvPacWinSz.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminRecvPacWinSz.setDescription('Specifies the size of the receive pacing window. This value is used for negotiation during session activations (SNA BIND). The meaning of this value when set to 0 depends on whether adaptive pacing is supported: adaptive pacing No limit on window size fixed pacing No pacing is supported')
appcModeAdminSendPacWinSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSendPacWinSz.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminSendPacWinSz.setDescription('Specifies the size of the send pacing window. This value is used for negotiation during session activations (SNA BIND). The meaning of this value when set to 0 depends on whether adaptive pacing is supported: adaptive pacing No limit on window size fixed pacing No pacing is supported')
appcModeAdminPrefRecvRuSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminPrefRecvRuSz.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminPrefRecvRuSz.setDescription('Specifies the preferred receive RU (Request Unit) size of normal-flow requests on the sessions. This value must be less than or equal to the value specified in appcModeAdminRecvRuSzUpBnd and greater than or equal to the value specified in appcModeAdminRecvRuSzLoBnd. The local LU specifies this value for the receive maximum RU size in session activation (SNA BIND) requests and responses. It will allow negotiation up to the appcModeAdminRecvRuSzUpBnd value or down to the appcModeAdminRecvRuSzLoBnd value.')
appcModeAdminPrefSendRuSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminPrefSendRuSz.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminPrefSendRuSz.setDescription('Specifies the preferred send RU (Request Unit) size of normal- flow requests on the sessions. This value must be less than or equal to the value specified in appcModeAdminSendRuSzUpBnd and greater than or equal to the value specified in appcModeAdminSendRuSzLoBnd. The local LU specifies this value for the send maximum RU size in session activation (SNA BIND) requests and responses. It will allow negotiation up to the appcModeAdminSendRuSzUpBnd value or down to the appcModeAdminSendRuSzLoBnd value.')
appcModeAdminRecvRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminRecvRuSzUpBnd.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminRecvRuSzUpBnd.setDescription('Specifies the upper bound for the maximum receive RU (Request Unit) size of normal-flow requests. This is used for negotiation during session activations (SNA BIND). ')
appcModeAdminSendRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSendRuSzUpBnd.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminSendRuSzUpBnd.setDescription('Specifies the upper bound for the maximum send RU (Request Unit) size of normal-flow requests. This is used for negotiation during session activations (SNA BIND). ')
appcModeAdminRecvRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminRecvRuSzLoBnd.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminRecvRuSzLoBnd.setDescription('Specifies the lower bound for the maximum receive RU (Request Unit) size of normal-flow requests. This is used for negotiation during session activations (SNA BIND). ')
appcModeAdminSendRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSendRuSzLoBnd.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminSendRuSzLoBnd.setDescription('Specifies the lower bound for the maximum send RU (Request Unit) size of normal-flow requests. This is used for negotiation during session activations (SNA BIND). ')
appcModeAdminSingSessReinit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("operatorControlled", 2), ("primaryOnly", 3), ("secondaryOnly", 4), ("primaryOrSecondary", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSingSessReinit.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminSingSessReinit.setDescription('Specifies the responsibility for session reinitiation of a single session with the partner LU (when the session goes down). The local LU uses this parameter to specify the session reinitiation responsibility in session activation (SNA BIND) requests and responses. notApplicable - specifies that this parameter has no meaning since the value of appcLuPairAdminParaSessSup is yes. The field in the SNA BIND is reserved (set to zero). operatorControlled - specifies that neither LU will automatically attempt to reinitiate the session. The operator on either side will manually reactivate the session. A contention race (both side reinitiating at the same time) is won by the LU with the lexicographically greater fully- qualified LU name. primaryOnly - specifies that the primary LU will automatically attempt to reinitiate the session. secondaryOnly - specifies that the secondary LU will automatically attempt to reinitiate the session. primaryOrSecondary - specifies that either the primary or the secondary may automatically attempt to reinitiate the session. A contention race is handled the same way as with operatorControlled. ')
appcModeAdminCompression = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("prohibited", 1), ("required", 2), ("negotiable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminCompression.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminCompression.setDescription('Specifies whether compression is supported. The local LU uses this value for negotiation during session activation (SNA BIND). prohibited - specifies that no compression is to be used. required - specifies that compression is required. negotiable - specifies that the usage of compression is to be negotiated between the LUs. The level of compression is also negotiated.')
appcModeAdminInBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminInBoundCompLevel.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminInBoundCompLevel.setDescription('Specifies the maximum level of compression supported for inbound data. The local LU uses this value in conjunction with appcModeAdminCompression for negotiation during session activation (SNA BIND). none - specifies that no compression is to be used. rle - specifies run-length encoding compression in which a 1 or 2 byte sequence substitution is used for each repeated run of the same character. lz9 - specifies Lempel-Ziv-like compression in which 9 bit codes are used to substitute repeated substrings in the data stream. These codes are indices that refer to entries in a common dictionary generated adaptively at both sender and receiver as the data flows and compression occurs. The larger of number bits used for the code, the more storage space is required for the dictionary, but the larger the compression ratio. lz10 - specifies a 10 bit code Lempel-Ziv-like compression. lz12 - specifies a 12 bit code Lempel-Ziv-like compression.')
appcModeAdminOutBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminOutBoundCompLevel.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminOutBoundCompLevel.setDescription('Specifies the maximum level of compression supported for outbound data. The local LU uses this value in conjunction with appcModeAdminCompression for negotiation during session activation (SNA BIND). none - specifies that no compression is to be used. rle - specifies run-length encoding compression in which a 1 or 2 byte sequence substitution is used for each repeated run of the same character. lz9 - specifies Lempel-Ziv-like compression in which 9 bit codes are used to substitute repeated substrings in the data stream. These codes are indices that refer to entries in a common dictionary generated adaptively at both sender and receiver as the data flows and compression occurs. The larger of number bits used for the code, the more storage space is required for the dictionary, but the larger the compression ratio. lz10 - specifies a 10 bit code Lempel-Ziv-like compression. lz12 - specifies a 12 bit code Lempel-Ziv-like compression.')
appcModeAdminCompRleBeforeLZ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminCompRleBeforeLZ.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminCompRleBeforeLZ.setDescription('Specifies whether run-length encoding is to be applied to the data before applying Lempel-Ziv-like compression. The local LU uses this value for negotiation during session activation (SNA BIND). This parameter is only supported if LZ compression is used.')
appcModeAdminSyncLvl = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("noneConfirm", 2), ("noneConfirmSyncPoint", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminSyncLvl.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminSyncLvl.setDescription('Specifies the sync level support. This value is used for negotiation during session activations (SNA BIND). none - No sync level is supported. noneConfirm - None and Confirm levels supported. noneConfirmSyncPoint - None, Confirm, and Sync Point is supported. ')
appcModeAdminCrypto = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("mandatory", 2), ("selective", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeAdminCrypto.setStatus('current')
if mibBuilder.loadTexts: appcModeAdminCrypto.setDescription('Specifies whether session-level cryptography is supported. This value is used for negotiation during session activations (SNA BIND). notSupported - Specifies session-level cryptography is not to be used. mandatory - Specifies session-level cryptography must be used. selective - Specifies session-level cryptography is required just on selected requests flowing on the sessions.')
appcModeOperTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6), )
if mibBuilder.loadTexts: appcModeOperTable.setStatus('current')
if mibBuilder.loadTexts: appcModeOperTable.setDescription('Operational APPC Mode Information. Two entries are present in the table when both LUs in a pair are local.')
appcModeOperEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1), ).setIndexNames((0, "APPC-MIB", "appcModeOperLocLuName"), (0, "APPC-MIB", "appcModeOperParLuName"), (0, "APPC-MIB", "appcModeOperModeName"))
if mibBuilder.loadTexts: appcModeOperEntry.setStatus('current')
if mibBuilder.loadTexts: appcModeOperEntry.setDescription('Entry of APPC mode operational information table. This entry does not augment the appcModeAdminEntry, but reflects an actual operational mode for a given local LU - partner LU pair.')
appcModeOperLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcModeOperLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcModeOperLocLuName.setDescription('The SNA name of the local LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLluOperName, then the two entries being indexed apply to the same resource (specifically, to the same local LU).')
appcModeOperParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcModeOperParLuName.setStatus('current')
if mibBuilder.loadTexts: appcModeOperParLuName.setDescription('The SNA name of the partner LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLuPairOperParLuName, then the two entries being indexed apply to the same resource (specifically, to the same partner LU).')
appcModeOperModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appcModeOperModeName.setStatus('current')
if mibBuilder.loadTexts: appcModeOperModeName.setDescription('Specifies the mode name. A mode defines the characteristics for a group of sessions. The mode name can be blank (8 space characters). ')
appcModeOperCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCosName.setStatus('current')
if mibBuilder.loadTexts: appcModeOperCosName.setDescription('Specifies the class of service (COS) name associated with this mode. If the implementation does not support COS names, a zero-length string is returned.')
appcModeOperSessEndTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSessEndTpName.setStatus('current')
if mibBuilder.loadTexts: appcModeOperSessEndTpName.setDescription("Specifies the name of the transaction program (TP) to be invoked when a session using this mode is deactivated or ended. If the name is NULL, no transaction program is invoked. When the TP name consists entirely of displayable EBCDIC code points, it is mapped directly to the equivalent ASCII display string. However, registered TP names always have a non- displayable EBCDIC code point (value less than or equal to x'3F') as the first character, so they cannot be directly mapped to an ASCII display string. These TP names are converted to a display string that is equivalent to a hexadecimal display of the EBCDIC code points. For example, the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte ASCII display string '06F1' (including the two single quotes).")
appcModeOperSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSessLimit.setStatus('current')
if mibBuilder.loadTexts: appcModeOperSessLimit.setDescription('Specifies the current session limit of this mode as negotiated through APPC CNOS (Change Number of Sessions) processing. Identifies the total number of sessions that can be established between the local and partner LU using this mode.')
appcModeOperMaxSessLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperMaxSessLimit.setStatus('current')
if mibBuilder.loadTexts: appcModeOperMaxSessLimit.setDescription('Specifies the maximum value that the local LU is to use, during CNOS processing, for the session limit. The local LU, as a target LU, will negotiate a higher session limit it receives in the CNOS request down to this maximum value. The local LU, as a source LU, will restrict the session limit it sends in a CNOS request to a value less than or equal to this maximum value.')
appcModeOperMinCwinLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperMinCwinLimit.setStatus('current')
if mibBuilder.loadTexts: appcModeOperMinCwinLimit.setDescription('Specifies the minimum contention winner sessions limit that was negotiated via CNOS processing.')
appcModeOperMinClosLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperMinClosLimit.setStatus('current')
if mibBuilder.loadTexts: appcModeOperMinClosLimit.setDescription('Specifies the minimum contention loser sessions limit that was negotiated via CNOS processing. This is the same as target minimum contention winner sessions.')
appcModeOperConWinAutoActLmt = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperConWinAutoActLmt.setStatus('current')
if mibBuilder.loadTexts: appcModeOperConWinAutoActLmt.setDescription('Specifies the limit on the number of contention winner sessions to be automatically activated when the minimum number of contention winner sessions increases (as a result of CNOS processing). The actual number of sessions activated is the lesser of this value and the new minimum number of contention winner sessions. ')
appcModeOperRecvPacWinSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperRecvPacWinSz.setStatus('current')
if mibBuilder.loadTexts: appcModeOperRecvPacWinSz.setDescription('Specifies the size of the receive pacing window. This value is used for negotiation during session activations (SNA BIND). The meaning of this value when set to 0 depends on whether adaptive pacing is supported: adaptive pacing - No limit on window size fixed pacing - No pacing is supported')
appcModeOperSendPacWinSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSendPacWinSz.setStatus('current')
if mibBuilder.loadTexts: appcModeOperSendPacWinSz.setDescription('Specifies the size of the send pacing window. This value is used for negotiation during session activations (SNA BIND). The meaning of this value when set to 0 depends on whether adaptive pacing is supported: adaptive pacing No limit on window size fixed pacing No pacing is supported')
appcModeOperPrefRecvRuSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPrefRecvRuSz.setStatus('current')
if mibBuilder.loadTexts: appcModeOperPrefRecvRuSz.setDescription('Specifies the preferred receive RU (Request Unit) size of normal-flow requests on the sessions. This value must be less than or equal to the value specified in appcModeOperRecvRuSzUpBnd and greater than or equal to the value specified in appcModeOperRecvRuSzLoBnd. The local LU specifies this value for the receive maximum RU size in session activation (SNA BIND) requests and responses. It will allow negotiation up to the appcModeOperRecvRuSzUpBnd value or down to the appcModeOperRecvRuSzLoBnd value.')
appcModeOperPrefSendRuSz = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPrefSendRuSz.setStatus('current')
if mibBuilder.loadTexts: appcModeOperPrefSendRuSz.setDescription('Specifies the preferred send RU (Request Unit) size of normal- flow requests on the sessions. This value must be less than or equal to the value specified in appcModeOperSendRuSzUpBnd and greater than or equal to the value specified in appcModeOperSendRuSzLoBnd. The local LU specifies this value for the send maximum RU size in session activation (SNA BIND) requests and responses. It will allow negotiation up to the appcModeOperSendRuSzUpBnd value or down to the appcModeOperSendRuSzLoBnd value.')
appcModeOperRecvRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperRecvRuSzUpBnd.setStatus('current')
if mibBuilder.loadTexts: appcModeOperRecvRuSzUpBnd.setDescription('Specifies the upper bound for the maximum receive RU (Request Unit) size of normal-flow requests. This is used for negotiation during session activations (SNA BIND). ')
appcModeOperSendRuSzUpBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSendRuSzUpBnd.setStatus('current')
if mibBuilder.loadTexts: appcModeOperSendRuSzUpBnd.setDescription('Specifies the upper bound for the maximum send RU (Request Unit) size of normal-flow requests. This is used for negotiation during session activations (SNA BIND). ')
appcModeOperRecvRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperRecvRuSzLoBnd.setStatus('current')
if mibBuilder.loadTexts: appcModeOperRecvRuSzLoBnd.setDescription('Specifies the lower bound for the maximum receive RU (Request Unit) size of normal-flow requests. This is used for negotiation during session activations (SNA BIND). ')
appcModeOperSendRuSzLoBnd = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSendRuSzLoBnd.setStatus('current')
if mibBuilder.loadTexts: appcModeOperSendRuSzLoBnd.setDescription('Specifies the lower bound for the maximum send RU (Request Unit) size of normal-flow requests. This is used for negotiation during session activations (SNA BIND). ')
appcModeOperSingSessReinit = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 1), ("operatorControlled", 2), ("primaryOnly", 3), ("secondaryOnly", 4), ("primaryOrSecondary", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSingSessReinit.setStatus('current')
if mibBuilder.loadTexts: appcModeOperSingSessReinit.setDescription('Specifies the responsibility for session reinitiation of a single session with the partner LU (when the session goes down). The local LU uses this parameter to specify the session reinitiation responsibility in session activation (SNA BIND) requests and responses. notApplicable - specifies that this parameter has no meaning since the value of appcLuPairOperParaSessSup is yes. The field in the SNA BIND is reserved (set to zero). operatorControlled - specifies that neither LU will automatically attempt to reinitiate the session. The operator on either side will manually reactivate the session. A contention race (both side reinitiating at the same time) is won by the LU with the lexicographically greater fully- qualified LU name. primaryOnly - specifies that the primary LU will automatically attempt to reinitiate the session. secondaryOnly - specifies that the secondary LU will automatically attempt to reinitiate the session. primaryOrSecondary - specifies that either the primary or the secondary may automatically attempt to reinitiate the session. A contention race is handled the same way as with operatorControlled. ')
appcModeOperCompression = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("prohibited", 1), ("required", 2), ("negotiable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCompression.setStatus('current')
if mibBuilder.loadTexts: appcModeOperCompression.setDescription('Specifies whether compression is supported. The local LU uses this value for negotiation during session activation (SNA BIND). prohibited - specifies that no compression is to be used. required - specifies that compression is required. negotiable - specifies that the usage of compression is to be negotiated between the LUs. The level of compression is also negotiated.')
appcModeOperInBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperInBoundCompLevel.setStatus('current')
if mibBuilder.loadTexts: appcModeOperInBoundCompLevel.setDescription('Specifies the maximum level of compression supported for inbound data. The local LU uses this value in conjunction with appcModeOperCompression for negotiation during session activation (SNA BIND). none - specifies that no compression is to be used. rle - specifies run-length encoding compression in which a 1 or 2 byte sequence substitution is used for each repeated run of the same character. lz9 - specifies Lempel-Ziv-like compression in which 9 bit codes are used to substitute repeated substrings in the data stream. These codes are indices that refer to entries in a common dictionary generated adaptively at both sender and receiver as the data flows and compression occurs. The larger of number bits used for the code, the more storage space is required for the dictionary, but the larger the compression ratio. lz10 - specifies a 10 bit code Lempel-Ziv-like compression. lz12 - specifies a 12 bit code Lempel-Ziv-like compression.')
appcModeOperOutBoundCompLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("rle", 2), ("lz9", 3), ("lz10", 4), ("lz12", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperOutBoundCompLevel.setStatus('current')
if mibBuilder.loadTexts: appcModeOperOutBoundCompLevel.setDescription('Specifies the maximum level of compression supported for outbound data. The local LU uses this value in conjunction with appcModeOperCompression for negotiation during session activation (SNA BIND). none - specifies that no compression is to be used. rle - specifies run-length encoding compression in which a 1 or 2 byte sequence substitution is used for each repeated run of the same character. lz9 - specifies Lempel-Ziv-like compression in which 9 bit codes are used to substitute repeated substrings in the data stream. These codes are indices that refer to entries in a common dictionary generated adaptively at both sender and receiver as the data flows and compression occurs. The larger of number bits used for the code, the more storage space is required for the dictionary, but the larger the compression ratio. lz10 - specifies a 10 bit code Lempel-Ziv-like compression. lz12 - specifies a 12 bit code Lempel-Ziv-like compression.')
appcModeOperCompRleBeforeLZ = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCompRleBeforeLZ.setStatus('current')
if mibBuilder.loadTexts: appcModeOperCompRleBeforeLZ.setDescription('Specifies whether run-length encoding is to be applied to the data before applying Lempel-Ziv-like compression. The local LU uses this value for negotiation during session activation (SNA BIND). This parameter is only supported if LZ compression is used.')
appcModeOperSyncLvl = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("noneConfirm", 2), ("noneConfirmSyncPoint", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSyncLvl.setStatus('current')
if mibBuilder.loadTexts: appcModeOperSyncLvl.setDescription('Specifies the sync level support for sessions involving this LU pair and mode name. none - No sync level is supported. noneConfirm - None and Confirm level supported. noneConfirmSyncPoint - None, Confirm and Sync Point is supported. ')
appcModeOperCrypto = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("mandatory", 2), ("selective", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCrypto.setStatus('current')
if mibBuilder.loadTexts: appcModeOperCrypto.setDescription('Specifies whether session-level cryptography is supported for sessions involving this LU pair and mode name. notSupported - Specifies session-level cryptography is not being used. mandatory - Specifies session-level cryptography in being used on all requests flowing on the sessions. selective - Specifies session-level cryptography is required just on selected requests flowing on the sessions.')
appcModeOperSyncLvlLastStart = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("noneConfirm", 2), ("noneConfirmSyncPoint", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperSyncLvlLastStart.setStatus('current')
if mibBuilder.loadTexts: appcModeOperSyncLvlLastStart.setDescription('Specifies the sync level support. This value represents the initial value proposed by the local LU the last time this capability was negotiated, i.e., when the first session was bound between the local LU and its partner. none - No sync level is supported. noneConfirm - None and Confirm level supported. noneConfirmSyncPoint - None, Confirm and Sync Point is supported. ')
appcModeOperCryptoLastStart = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("mandatory", 2), ("selective", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCryptoLastStart.setStatus('current')
if mibBuilder.loadTexts: appcModeOperCryptoLastStart.setDescription('Specifies whether session-level cryptography is supported. This value represents the initial value proposed by the local LU the last time this capability was negotiated, i.e., when the first session was bound between the local LU and its partner. notSupported - Specifies session-level cryptography is not to be used. mandatory - Specifies session-level cryptography must be used. selective - Specifies session-level cryptography is required just on selected requests flowing on the sessions.')
appcModeOperCNOSNeg = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperCNOSNeg.setStatus('current')
if mibBuilder.loadTexts: appcModeOperCNOSNeg.setDescription('Specifies whether CNOS negotiation is in process. CNOS negotiation is used to set or change the various session limits for a mode.')
appcModeOperActCwin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperActCwin.setStatus('current')
if mibBuilder.loadTexts: appcModeOperActCwin.setDescription('Specifies the number of active contention winner sessions.')
appcModeOperActClos = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperActClos.setStatus('current')
if mibBuilder.loadTexts: appcModeOperActClos.setDescription('Specifies the number of active contention loser sessions.')
appcModeOperPndCwin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 31), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPndCwin.setStatus('current')
if mibBuilder.loadTexts: appcModeOperPndCwin.setDescription('Specifies the number of contention winner sessions that are pending activation.')
appcModeOperPndClos = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPndClos.setStatus('current')
if mibBuilder.loadTexts: appcModeOperPndClos.setDescription('Specifies the number of contention loser sessions that are pending activation.')
appcModeOperPtmCwin = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPtmCwin.setStatus('current')
if mibBuilder.loadTexts: appcModeOperPtmCwin.setDescription('Specifies the number of contention winner sessions that are pending termination.')
appcModeOperPtmClos = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperPtmClos.setStatus('current')
if mibBuilder.loadTexts: appcModeOperPtmClos.setDescription('Specifies the number of contention loser sessions that are pending termination.')
appcModeOperDrainSelf = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperDrainSelf.setStatus('current')
if mibBuilder.loadTexts: appcModeOperDrainSelf.setDescription('Specifies whether the local LU is draining its conversations for this mode. When a mode session limit is reset (via a CNOS RESET_SESSION_LIMIT request), the local LU could be set to process all queued conversations before deactivating all of the sessions (using the SNA Bracket Initiation Stopped or BIS protocol). ')
appcModeOperDrainPart = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 2, 6, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcModeOperDrainPart.setStatus('current')
if mibBuilder.loadTexts: appcModeOperDrainPart.setDescription('Specifies whether the partner LU is draining its conversations for this mode. When a mode session limit is reset (via a CNOS RESET_SESSION_LIMIT request), the partner LU could be set to process all queued conversations before deactivating all of the sessions (using the SNA Bracket Initiation Stop or BIS protocol). ')
appcTpAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1), )
if mibBuilder.loadTexts: appcTpAdminTable.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminTable.setDescription('APPC Local TP Table')
appcTpAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcTpAdminLocLuName"), (0, "APPC-MIB", "appcTpAdminTpName"))
if mibBuilder.loadTexts: appcTpAdminEntry.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminEntry.setDescription('Entry of APPC Local TP Information Table.')
appcTpAdminLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcTpAdminLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminLocLuName.setDescription("The SNA name of the local LU to which this TP definition applies. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. The reserved value '*ALL' indicates that the TP definition applies to all local LUs, and not just to a single local LU.")
appcTpAdminTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: appcTpAdminTpName.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminTpName.setDescription("The local transaction program name. This name is sent on an ATTACH remote allocation request. When the TP name consists entirely of displayable EBCDIC code points, it is mapped directly to the equivalent ASCII display string. However, registered TP names always have a non-displayable EBCDIC code point (value less than or equal to x'3F') as the first character, so they cannot be directly mapped to an ASCII display string. These TP names are converted to a display string that is equivalent to a hexadecimal display of the EBCDIC code points. For example, the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte ASCII display string '06F1' (including the two single quotes).")
appcTpAdminFileSpec = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminFileSpec.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminFileSpec.setDescription('The local file specification of the transaction program. May be a zero-length string if not applicable.')
appcTpAdminStartParm = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminStartParm.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminStartParm.setDescription('A parameter string passed to the transaction program when it is started. May be a zero-length string if not supported. ')
appcTpAdminTpOperation = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("queuedOperatorStarted", 2), ("queuedOperatorPreloaded", 3), ("queuedAmStarted", 4), ("nonqueuedAmStarted", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminTpOperation.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminTpOperation.setDescription('Specifies how the program will be started. other - Specifies that the program operation is none of the methods specified. It may be a product-specific method. queuedOperatorStarted - Specifies that one version of the program will be run at a time. If an incoming attach arrives and the program has not been started yet, APPC will issue a message to the operator to start the specified program. Subsequent attaches that arrive while the program is active will be queued. queuedOperatorPreloaded - Specifies that one version of the program will be run at a time. If an incoming attach arrives and the program has not been started yet, the Attach will be rejected. The APPC attach manager determines that a TP has started upon reception of an APPC RECEIVE_ALLOCATE verb, or a CPI-C Accept_Conversation (CMACCP) or Specify_Local_TP_Name (CMSLTP) call. No message is sent to the operator. Subsequent attaches that arrive while the program is active are queued. queuedAmStarted - Specifies that one version of the program will be run at a time and will be started by the APPC attach manager. Subsequent attaches that arrive while the program is active will be queued. nonqueuedAmStarted - Specifies that multiple copies of the program will be run at a time and will be started by the APPC attach manager.')
appcTpAdminInAttachTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminInAttachTimeout.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminInAttachTimeout.setDescription('This object specifies the number of seconds incoming attaches will be queued waiting for an APPC program to issue a RECEIVE_ALLOCATE verb or for a CPI-C program to issue an Accept_Conversation (CMACCP) call. This parameter is meaningful only when appcTpAdminTpOperation has one of the following values: queuedOperatorStarted queuedOperatorPreloaded queuedAmStarted A value of zero indicates that there is no timeout.')
appcTpAdminRcvAllocTimeout = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminRcvAllocTimeout.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminRcvAllocTimeout.setDescription("This object specifies the number of seconds an APPC program's RECEIVE_ALLOCATE verb or a CPI-C program's Accept_Conversation (CMACCP) call will wait for an incoming attach to arrive. A value of zero indicates that there is no timeout.")
appcTpAdminSyncLvl = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("confirm", 2), ("noneAndConfirm", 3), ("syncpoint", 4), ("noneAndSyncpoint", 5), ("confirmAndSyncpoint", 6), ("all", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminSyncLvl.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminSyncLvl.setDescription('Indicates the synchronization level or levels that the transaction program supports. The levels are defined as follows: none - allocation requests indicating a synchronization level of none are allowed to start the program. confirm - allocation requests indicating a synchronization level of confirm are allowed to start the program. syncpoint - allocation requests indicating a synchronization level of sync point are allowed to start the program.')
appcTpAdminInstLmt = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminInstLmt.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminInstLmt.setDescription('The maximum number of concurrent instances of this transaction program that will be supported for a local LU. A value of zero indicates that there is no limit.')
appcTpAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("tempDisabled", 2), ("permDisabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminStatus.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminStatus.setDescription('Indicates the status of the TP relative to starting execution when the local LU receives an allocation (ATTACH) request naming this program. enabled - the local LU can start the program. tempDisabled - the local LU cannot start the program. The local LU rejects the request with an indication that the TP is not available but retry is possible. permDisabled - the local LU cannot start the program. The local LU rejects the request with an indication that the TP is not available and retry is not possible.')
appcTpAdminLongRun = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminLongRun.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminLongRun.setDescription('Indicates whether this is a long-running transaction program (i.e., one that stays around even after the conversation goes away).')
appcTpAdminConvType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("basic", 1), ("mapped", 2), ("basicOrMapped", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminConvType.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminConvType.setDescription('Specifies the conversation type (basic or mapped) that will be used by the TP. This value is verified upon receipt of an incoming attach. The acceptable values are: basic - Indicates that this transaction program supports basic conversations. mapped - Indicates that this transaction program supports mapped conversations. basicOrMapped - Indicates that this transaction program supports both basic and mapped conversations.')
appcTpAdminConvDuplex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("half", 1), ("full", 2), ("halfOrFull", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminConvDuplex.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminConvDuplex.setDescription('Specifies the conversation duplex type (half or full) that will be used by the TP. This value is verified upon receipt of an incoming attach. The acceptable values are: half - Indicates that this transaction program supports half duplex conversations. full - Indicates that this transaction program supports full duplex conversations. halfOrFull - Indicates that this transaction program supports either half or full duplex conversations.')
appcTpAdminConvSecReq = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminConvSecReq.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminConvSecReq.setDescription('Indicates whether conversation-level security information is required on incoming attaches designating this TP name. Conversation-level security verification is always performed on those requests that include security information. yes - Indicates that conversation-level security information is required. ATTACHs designating the transaction program must carry a user_id and either a password or an already verified indicator. no - Indicates that no security information is required. ATTACHs designating the transaction program can omit or include security information.')
appcTpAdminVerPip = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminVerPip.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminVerPip.setDescription('Specifies whether the number of PIP (Program Initialization Parameters) subfields should be verified against the number expected (appcTpAdminPipSubNum).')
appcTpAdminPipSubNum = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 3, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcTpAdminPipSubNum.setStatus('current')
if mibBuilder.loadTexts: appcTpAdminPipSubNum.setDescription('Specifies the number of PIP subfields expected by the TP.')
appcActSessTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1), )
if mibBuilder.loadTexts: appcActSessTable.setStatus('current')
if mibBuilder.loadTexts: appcActSessTable.setDescription('Table of active APPC sessions. Two entries are present in the table when both session partners are local.')
appcActSessEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcActSessLocLuName"), (0, "APPC-MIB", "appcActSessParLuName"), (0, "APPC-MIB", "appcActSessIndex"))
if mibBuilder.loadTexts: appcActSessEntry.setStatus('current')
if mibBuilder.loadTexts: appcActSessEntry.setDescription('Entry of APPC Session Information Table. Indexed by LU pair and integer-valued session index.')
appcActSessLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcActSessLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcActSessLocLuName.setDescription('Specifies the name of the local LU for the session. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLluOperName, then the two entries being indexed apply to the same resource (specifically, to the same local LU).')
appcActSessParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcActSessParLuName.setStatus('current')
if mibBuilder.loadTexts: appcActSessParLuName.setDescription('Specifies the name of the partner LU for the session. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLuPairOperParLuName, then the two entries being indexed apply to the same resource (specifically, to the same partner LU).')
appcActSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: appcActSessIndex.setStatus('current')
if mibBuilder.loadTexts: appcActSessIndex.setDescription('This value identifies the index of the session, which is unique for this LU pair. It is recommended that an Agent not reuse the index of a deactivated session for a significant period of time (e.g., one week).')
appcActSessPcidCpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 17), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessPcidCpName.setStatus('current')
if mibBuilder.loadTexts: appcActSessPcidCpName.setDescription('The network-qualified CP name of the node at which the session and PCID originated. For APPN and LEN nodes, this is either CP name of the APPN node at which the origin LU is located or the CP name of the NN serving the LEN node at which the origin LU is located. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name. A null string indicates that the value is unknown.')
appcActSessPcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 5), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessPcid.setStatus('current')
if mibBuilder.loadTexts: appcActSessPcid.setDescription('The procedure correlation identifier (PCID) of a session. It is an 8-octet value assigned by the control point providing session services for the primary LU. A null string indicates that the value is unknown.')
appcActSessPluIndicator = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("localLuIsPlu", 1), ("partnerLuIsPlu", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessPluIndicator.setStatus('current')
if mibBuilder.loadTexts: appcActSessPluIndicator.setDescription("Indicates which LU is the PLU for this session. For independent LUs, the PLU (primary LU) is the one that initiated the session (sent BIND), while the SLU (secondary LU) is the one that accepted the session initiation (received BIND). The 'local' LU is the one identified by appcLluOperName. The 'partner' LU is the one identified by appcLuPairOperParLuName.")
appcActSessModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessModeName.setStatus('current')
if mibBuilder.loadTexts: appcActSessModeName.setDescription('The mode name used for this session.')
appcActSessCosName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessCosName.setStatus('current')
if mibBuilder.loadTexts: appcActSessCosName.setDescription('The Class of Service (COS) name used for this session. A null string indicates that the value is unknown.')
appcActSessTransPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("low", 2), ("medium", 3), ("high", 4), ("network", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessTransPriority.setStatus('current')
if mibBuilder.loadTexts: appcActSessTransPriority.setDescription('The transmission priority of this session. 1 = unknown priority 2 = low priority 3 = medium priority 4 = high priority 5 = network priority ')
appcActSessEnhanceSecSup = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("level1", 2), ("level2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessEnhanceSecSup.setStatus('current')
if mibBuilder.loadTexts: appcActSessEnhanceSecSup.setDescription('Enhanced security supported. Indicates the level of enhanced security support: 1 = none 2 = level 1 3 = level 2 ')
appcActSessSendPacingType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("fixed", 2), ("adaptive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessSendPacingType.setStatus('current')
if mibBuilder.loadTexts: appcActSessSendPacingType.setDescription('The type of pacing being used for sending data.')
appcActSessSendRpc = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessSendRpc.setStatus('current')
if mibBuilder.loadTexts: appcActSessSendRpc.setDescription('The send residual pace count. This represents the number of MUs that can still be sent in the current session window.')
appcActSessSendNxWndwSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessSendNxWndwSize.setStatus('current')
if mibBuilder.loadTexts: appcActSessSendNxWndwSize.setDescription('The size of the next window which will be used to send data.')
appcActSessRecvPacingType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("fixed", 2), ("adaptive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRecvPacingType.setStatus('current')
if mibBuilder.loadTexts: appcActSessRecvPacingType.setDescription('The type of pacing being used for receiving data.')
appcActSessRecvRpc = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRecvRpc.setStatus('current')
if mibBuilder.loadTexts: appcActSessRecvRpc.setDescription('The receive residual pace count. This represents the number of MUs that can still be received in the current session window.')
appcActSessRecvNxWndwSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRecvNxWndwSize.setStatus('current')
if mibBuilder.loadTexts: appcActSessRecvNxWndwSize.setDescription('The size of the next window which will be used to receive data.')
appcActSessRscv = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRscv.setStatus('current')
if mibBuilder.loadTexts: appcActSessRscv.setDescription('The route selection control vector (RSCV CV2B) used for this session. It is present for APPN-level implementations. LEN-level implementations will return a null string. The internal format of this vector is described in SNA Formats. This object contains an uninterpreted copy of the control vector (including the length and key fields).')
appcActSessInUse = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessInUse.setStatus('current')
if mibBuilder.loadTexts: appcActSessInUse.setDescription('Specifies whether the session is currently in use (i.e., in bracket with a conversation).')
appcActSessMaxSndRuSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessMaxSndRuSize.setStatus('current')
if mibBuilder.loadTexts: appcActSessMaxSndRuSize.setDescription('The maximum RU size used on this session for sending RUs.')
appcActSessMaxRcvRuSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessMaxRcvRuSize.setStatus('current')
if mibBuilder.loadTexts: appcActSessMaxRcvRuSize.setDescription('The maximum RU size used on this session for receiving RUs.')
appcActSessSndPacingSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessSndPacingSize.setStatus('current')
if mibBuilder.loadTexts: appcActSessSndPacingSize.setDescription('The size of the send pacing window on this session.')
appcActSessRcvPacingSize = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRcvPacingSize.setStatus('current')
if mibBuilder.loadTexts: appcActSessRcvPacingSize.setDescription('The size of the receive pacing window on this session.')
appcActSessOperState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unbound", 1), ("pendingBind", 2), ("bound", 3), ("pendingUnbind", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appcActSessOperState.setStatus('current')
if mibBuilder.loadTexts: appcActSessOperState.setDescription("The value indicates the current operational state of the session. 'unbound (1)' - session has been unbound; in this state it will be removed from the session table by the Agent. 'pendingBind (2)' - this state has different meanings for dependent and independent LUs; for dependent LU - waiting for BIND from the host, for independent LU - waiting for BIND response. When a session enters this state, the corresponding entry in the session table is created by the Agent. 'bound (3)' - session has been successfully bound. 'pendingUnbind (4)' - session enters this state when an UNBIND is sent and before the rsp(UNBIND) is received. Session deactivation: If a session is in the operational state 'bound (3)' then setting the value of this object to 'unbound (1)' will initiate the session shutdown. If a session is in the operational state 'pendingBind (2)' then setting the value of this object to 'unbound (1)' will initiate the session shutdown. If a session is in the operational state 'pendingUnbind (4)' for an abnormally long period of time (e.g., three minutes) then setting the value of this object to 'unbound (1)' will change the session operational state to 'unbound (1)'. ")
appcActSessUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessUpTime.setStatus('current')
if mibBuilder.loadTexts: appcActSessUpTime.setDescription('The length of time the session has been active, measured in hundredths of a second.')
appcActSessRtpNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRtpNceId.setStatus('current')
if mibBuilder.loadTexts: appcActSessRtpNceId.setDescription('The local HPR Network Connection Endpoint of the session.')
appcActSessRtpTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 26), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessRtpTcid.setStatus('current')
if mibBuilder.loadTexts: appcActSessRtpTcid.setDescription('The local RTP connection TCID of the session.')
appcActSessLinkIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 1, 1, 27), InstancePointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActSessLinkIndex.setStatus('current')
if mibBuilder.loadTexts: appcActSessLinkIndex.setDescription('This value identifies the link over which the session passes. This value points to the row in the table containing information on the link instance. (e.g., the sdlcLSAdminTable of the SNA DLC MIB module). This object may be NULL if the link is not specified or if a link is not applicable (as for APPN-level nodes).')
appcSessStatsTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2), )
if mibBuilder.loadTexts: appcSessStatsTable.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsTable.setDescription("This table contains dynamic statistical information relating to active APPC sessions. The entries in this table cannot be created by a Management Station. Two entries are present in the table when both session partners are local. This table is populated only when the value of appcCntrlOperStat is 'active'.")
appcSessStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1), ).setIndexNames((0, "APPC-MIB", "appcSessStatsLocLuName"), (0, "APPC-MIB", "appcSessStatsParLuName"), (0, "APPC-MIB", "appcSessStatsSessIndex"))
if mibBuilder.loadTexts: appcSessStatsEntry.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsEntry.setDescription('Contains statistics information for an APPC session. Each entry is created by the Agent. Objects in this table have read-only access. Each session from appcActSessTable has one entry in this table.')
appcSessStatsLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcSessStatsLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsLocLuName.setDescription('Specifies the name of the local LU for the session. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLluOperName, then the two entries being indexed apply to the same resource (specifically, to the same local LU).')
appcSessStatsParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcSessStatsParLuName.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsParLuName.setDescription('Specifies the name of the partner LU for the session. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLuPairOperParLuName, then the two entries being indexed apply to the same resource (specifically, to the same partner LU).')
appcSessStatsSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 3), Integer32())
if mibBuilder.loadTexts: appcSessStatsSessIndex.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsSessIndex.setDescription('This value identifies the index of the session, which is unique for this LU pair. It is recommended that an Agent not reuse the index of a deactivated session for a significant period of time (e.g., one week). If this object has the same value as appcActSessIndex for the same LU pair, then the two entries being indexed apply to the same resource (specifically, to the same session).')
appcSessStatsSentFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsSentFmdBytes.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsSentFmdBytes.setDescription('The number of function management data (FMD) bytes sent by the local LU.')
appcSessStatsSentNonFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsSentNonFmdBytes.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsSentNonFmdBytes.setDescription('The number of non-function management data (non-FMD) bytes sent by the local LU.')
appcSessStatsRcvdFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsRcvdFmdBytes.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsRcvdFmdBytes.setDescription('The number of function management data (FMD) bytes received by the local LU.')
appcSessStatsRcvdNonFmdBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsRcvdNonFmdBytes.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsRcvdNonFmdBytes.setDescription('The number of non-function management data (non-FMD) bytes received by the local LU.')
appcSessStatsSentFmdRus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsSentFmdRus.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsSentFmdRus.setDescription('The number of function management data (FMD) RUs sent by the local LU.')
appcSessStatsSentNonFmdRus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsSentNonFmdRus.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsSentNonFmdRus.setDescription('The number of non-function management data (non-FMD) RUs sent by the local LU.')
appcSessStatsRcvdFmdRus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsRcvdFmdRus.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsRcvdFmdRus.setDescription('The number of function management data (FMD) RUs received by the local LU.')
appcSessStatsRcvdNonFmdRus = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsRcvdNonFmdRus.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsRcvdNonFmdRus.setDescription('The number of non-function management data (non-FMD) RUs received by the local LU.')
appcSessStatsCtrUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 2, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessStatsCtrUpTime.setStatus('current')
if mibBuilder.loadTexts: appcSessStatsCtrUpTime.setDescription('The length of time the counters for this session have been active, measured in hundredths of a second.')
appcHistSessTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3), )
if mibBuilder.loadTexts: appcHistSessTable.setStatus('current')
if mibBuilder.loadTexts: appcHistSessTable.setDescription('Table of historical information about APPC sessions that terminated abnormally. Two entries may be present in the table when both session partners are local. It is an implementation choice how long to retain information about a given session.')
appcHistSessEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1), ).setIndexNames((0, "APPC-MIB", "appcHistSessIndex"))
if mibBuilder.loadTexts: appcHistSessEntry.setStatus('current')
if mibBuilder.loadTexts: appcHistSessEntry.setDescription('Entry of APPC Session History Table. This table is indexed by an integer which is continuously incremented until it eventually wraps.')
appcHistSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: appcHistSessIndex.setStatus('current')
if mibBuilder.loadTexts: appcHistSessIndex.setDescription('Table index. The value of the index begins at zero and is incremented up to a maximum value of 2**31-1 (2,147,483,647) before wrapping.')
appcHistSessTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessTime.setStatus('current')
if mibBuilder.loadTexts: appcHistSessTime.setDescription('The time at which the session was either terminated or failed to be established.')
appcHistSessType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("recvNegBindRsp", 1), ("sendNegBindRsp", 2), ("sessActRejected", 3), ("unbindSent", 4), ("unbindReceived", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessType.setStatus('current')
if mibBuilder.loadTexts: appcHistSessType.setDescription('Indicates the type of event that caused the entry to be made: recvNegBindRsp - Received a negative bind response from the partner LU. sendNegBindRsp - Sent a negative bind response to the partner LU. sessActRejected - Session activation rejected by the partner LU. unbindSent - Unbind sent to the partner LU. unbindReceived - Unbind received from the partner LU. These event types correspond to the five SNA/MS Alerts LU62001 through LU62005, documented in the SNA Management Services Reference.')
appcHistSessLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcHistSessLocLuName.setDescription('The network-qualified local LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcHistSessParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessParLuName.setStatus('current')
if mibBuilder.loadTexts: appcHistSessParLuName.setDescription('The network-qualified partner LU name. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcHistSessModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessModeName.setStatus('current')
if mibBuilder.loadTexts: appcHistSessModeName.setDescription('The mode name of the session.')
appcHistSessUnbindType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessUnbindType.setStatus('current')
if mibBuilder.loadTexts: appcHistSessUnbindType.setDescription('The type of unbind which terminated the session. This value is consists of one (1) octet; and its meaning is defined in SNA Formats.')
appcHistSessSenseData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 8), SnaSenseData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessSenseData.setStatus('current')
if mibBuilder.loadTexts: appcHistSessSenseData.setDescription('The sense data associated with the termination of the session, taken from the negative BIND response or UNBIND request.')
appcHistSessComponentId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessComponentId.setStatus('current')
if mibBuilder.loadTexts: appcHistSessComponentId.setDescription('The implementation-specific name of the component which detected the problem.')
appcHistSessDetectModule = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 3, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistSessDetectModule.setStatus('current')
if mibBuilder.loadTexts: appcHistSessDetectModule.setDescription('The implementation-specific name of the module which detected the problem.')
appcSessRtpTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4), )
if mibBuilder.loadTexts: appcSessRtpTable.setStatus('current')
if mibBuilder.loadTexts: appcSessRtpTable.setDescription('A table indicating how many APPC sessions terminating in this node are transported by each RTP connection.')
appcSessRtpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4, 1), ).setIndexNames((0, "APPC-MIB", "appcSessRtpNceId"), (0, "APPC-MIB", "appcSessRtpTcid"))
if mibBuilder.loadTexts: appcSessRtpEntry.setStatus('current')
if mibBuilder.loadTexts: appcSessRtpEntry.setDescription('Entry of APPC session RTP table.')
appcSessRtpNceId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appcSessRtpNceId.setStatus('current')
if mibBuilder.loadTexts: appcSessRtpNceId.setDescription('The local Network Connection Endpoint of the RTP connection.')
appcSessRtpTcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8))
if mibBuilder.loadTexts: appcSessRtpTcid.setStatus('current')
if mibBuilder.loadTexts: appcSessRtpTcid.setDescription('The local TCID of the RTP connection.')
appcSessRtpSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 4, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcSessRtpSessions.setStatus('current')
if mibBuilder.loadTexts: appcSessRtpSessions.setDescription('The number of APPC sessions terminating in this node that are using this RTP connection.')
appcActiveConvTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1), )
if mibBuilder.loadTexts: appcActiveConvTable.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvTable.setDescription("Table of information about active APPC Conversations. In this context 'active' means that a conversation is currently associated with a particular session. Two entries are present in the table when both LUs for the session are local.")
appcActiveConvEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcActiveConvLocLuName"), (0, "APPC-MIB", "appcActiveConvParLuName"), (0, "APPC-MIB", "appcActiveConvSessIndex"))
if mibBuilder.loadTexts: appcActiveConvEntry.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvEntry.setDescription('Entry representing one active APPC Conversation.')
appcActiveConvLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcActiveConvLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvLocLuName.setDescription('The SNA name of the local LU for the conversation. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLluOperName, then the two entries being indexed apply to the same resource (specifically, to the same local LU).')
appcActiveConvParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcActiveConvParLuName.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvParLuName.setDescription('The SNA name of the partner LU for the conversation. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. If this object has the same value as appcLuPairOperParLuName, then the two entries being indexed apply to the same resource (specifically, to the same partner LU).')
appcActiveConvSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: appcActiveConvSessIndex.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvSessIndex.setDescription('Index of entry in appcActSessTable that is associated with this conversation. If this object has the same value as appcActSessIndex for the same LU pair, then the two entries being indexed apply to the same resource (specifically, to the same session).')
appcActiveConvId = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvId.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvId.setDescription('The 4-byte ID of the conversation.')
appcActiveConvState = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("reset", 1), ("send", 2), ("receive", 3), ("confirm", 4), ("confirmSend", 5), ("confirmDealloc", 6), ("pendingDeallocate", 7), ("pendingPost", 8), ("sendReceive", 9), ("sendOnly", 10), ("receiveOnly", 11), ("deferReceive", 12), ("deferDeallocate", 13), ("syncpoint", 14), ("syncpointSend", 15), ("syncpointDeallocate", 16), ("backoutRequired", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvState.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvState.setDescription('Indicates the state of the conversation at the instant when the information was retrieved. The values are: reset The conversation is reset (i.e., deallocated). send The conversation can send data. This value also is returned if the conversation is in Send-Pending state. receive The conversation can receive data. confirm The conversation has received a confirm indicator. It can issue an [MC_]CONFIRMED or [MC_]SEND_ERROR verb to change state. It will continue in Receive state if an [MC_]CONFIRMED verb is issued. confirmSend The conversation is in Confirm state and changes to Send state when an [MC_]CONFIRMED verb is issued. confirmDealloc The conversation is in Confirm state and becomes inactive when an [MC_]CONFIRMED verb is issued. pendingDeallocate The conversation is in Pending-Deallocate state while it waits for (MC_)DEALLOCATE TYPE (sync_level) to complete. pendingPost The conversation is in Pending-Post state while it waits for the [MC_]RECEIVE_AND_POST verb to complete its receive function. sendReceive The full-duplex conversation can send or receive data. sendOnly The full-duplex conversation can send data, but it does not have permission to receive data, because the partner TP has already deallocated its side of the conversation. receiveOnly The full-duplex conversation can receive data, but it does not have permission to send data, because it has already deallocated its side of the conversation. deferReceive Waiting for a successful SYNCPT verb operation to go into the receive state. deferDeallocate Waiting for a successful SYNCPT verb operation to go into the reset state. syncpoint Need to response to a SYNCPT verb issued. After successful operation, the next state will be receive. syncpointSend Need to response to a SYNCPT verb issued. After successful operation, the next state will be send. syncpointDeallocate Need to response to a SYNCPT verb issued. After successful operation, the next state will be reset. backoutRequired TP must execute a BACKOUT verb to backout the transaction.')
appcActiveConvType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("basic", 1), ("mapped", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvType.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvType.setDescription('Indicates the type of conversation. The values are: basic Indicates that this conversation supports basic verbs. mapped Indicates that this conversation supports mapped verbs.')
appcActiveConvCorrelator = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvCorrelator.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvCorrelator.setDescription('This is an 8-byte identifier that the source LU assigns to the conversation; the source LU is the one that sent the allocation request. The conversation correlator is included on the allocation request. The conversation correlator uniquely identifies a conversation, from among all conversations, between the local and partner LUs. It may be used, for example, during problem determination associated with a conversation. A length of 0 indicates that no conversation correlator is defined.')
appcActiveConvSyncLvl = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("confirm", 2), ("syncpt", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvSyncLvl.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvSyncLvl.setDescription('Indicates the highest sync level support for the conversation. The values are: none Indicates that no sync-level processing can be performed on this conversation. The transaction program does not issue verbs or recognize any returned parameters relating to any sync-level function. confirm Indicates that confirmation processing can be performed on this conversation. The transaction program can issue verbs and recognize returned parameters relating to confirmation. syncpt Indicates that syncpt and confirmation processing can be performed on this conversation. The transaction program can issue verbs and recognize returned parameters relating to syncpt and confirmation.')
appcActiveConvSource = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("localLu", 1), ("partnerLu", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvSource.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvSource.setDescription('Indicates whether the local or partner LU is the source of the conversation, that is, which LU started the conversation by sending the allocation request. localLu The local LU is the source of the conversation, and the partner LU is the target of the conversation. partnerLu The partner LU is the source of the conversation, and the local LU is the target of the conversation.')
appcActiveConvDuplex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half", 1), ("full", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvDuplex.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvDuplex.setDescription('Indicates the conversation duplex style in effect for the conversation. half Indicates that information can be transferred in both directions, but only in one direction at a time. full Indicates that information can be transferred in both directions at the same time.')
appcActiveConvUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvUpTime.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvUpTime.setDescription('The length of time since the conversation started, measured in hundredths of a second.')
appcActiveConvSendBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvSendBytes.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvSendBytes.setDescription('Indicates the number of bytes that was sent on the conversation. The count includes all SNA RU bytes sent, including those in the FMH-5 (Attach), FMH-7 (Error Description), SIGNAL, LUSTAT, and SNA responses; it does not include SNA TH and RH bytes.')
appcActiveConvRcvBytes = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvRcvBytes.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvRcvBytes.setDescription('Indicates the number of bytes that was received on the conversation. The count includes all SNA RU bytes sent, including those in the FMH-5 (Attach), FMH-7 (Error Description), SIGNAL, LUSTAT, and SNA responses; it does not include SNA TH and RH bytes.')
appcActiveConvUserid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvUserid.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvUserid.setDescription('The user ID that the initiating program provided in the incoming attach.')
appcActiveConvPcidNauName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 15), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 17), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvPcidNauName.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvPcidNauName.setDescription('The network-qualified NAU name of the node at which the session and PCID originated. For APPN and LEN nodes, this is either CP name of the APPN node at which the origin LU is located or the CP name of the NN serving the LEN node at which the origin LU is located. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name. A null string indicates that the value is unknown.')
appcActiveConvPcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 16), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvPcid.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvPcid.setDescription('The procedure correlation identifier (PCID) of the session. It is an 8-octet value assigned by the control point providing session services for the primary LU. A null string indicates that the value is unknown.')
appcActiveConvModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvModeName.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvModeName.setDescription('The Mode Name used for this conversation. This is a 1-8 character name.')
appcActiveConvLuwIdName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvLuwIdName.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvLuwIdName.setDescription('The SNA name of the LU that initiated the logical unit of work that is associated with this active TP. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the LU name if the NetId is present.')
appcActiveConvLuwIdInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvLuwIdInstance.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvLuwIdInstance.setDescription('The instance identifier for the logical unit of work.')
appcActiveConvLuwIdSequence = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvLuwIdSequence.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvLuwIdSequence.setDescription('The sequence identifier for the logical unit of work.')
appcActiveConvTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcActiveConvTpName.setStatus('current')
if mibBuilder.loadTexts: appcActiveConvTpName.setDescription("The transaction program name which started this conversation. This name could either be from a FMH5 ATTACH for a remotely started conversation, otherwise it could the name of the local TP if available. When the TP name consists entirely of displayable EBCDIC code points, it is mapped directly to the equivalent ASCII display string. However, registered TP names always have a non- displayable EBCDIC code point (value less than or equal to x'3F') as the first character, so they cannot be directly mapped to an ASCII display string. These TP names are converted to a display string that is equivalent to a hexadecimal display of the EBCDIC code points. For example, the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte ASCII display string '06F1' (including the two single quotes). This name is NULL if the conversation is started locally (i.e., not with a FMH5 ATTACH).")
appcHistConvTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2), )
if mibBuilder.loadTexts: appcHistConvTable.setStatus('current')
if mibBuilder.loadTexts: appcHistConvTable.setDescription('Table of historical information about APPC Conversations that ended in error. Possible categories of error conditions that could be saved in this table are: - allocation errors, - deallocate abend, - program errors, and - service errors.')
appcHistConvEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1), ).setIndexNames((0, "APPC-MIB", "appcHistConvIndex"))
if mibBuilder.loadTexts: appcHistConvEntry.setStatus('current')
if mibBuilder.loadTexts: appcHistConvEntry.setDescription('Entry representing one APPC Conversation.')
appcHistConvIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: appcHistConvIndex.setStatus('current')
if mibBuilder.loadTexts: appcHistConvIndex.setDescription('Index for entry in Conversation table. This value identifies the unique index of the conversation. It is recommended that an Agent not reuse the index of a deactivated conversation for a significant period of time (e.g. one week).')
appcHistConvEndTime = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvEndTime.setStatus('current')
if mibBuilder.loadTexts: appcHistConvEndTime.setDescription('The time at which the conversation ended.')
appcHistConvLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcHistConvLocLuName.setDescription('The name of the local LU for this conversation. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcHistConvParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvParLuName.setStatus('current')
if mibBuilder.loadTexts: appcHistConvParLuName.setDescription('The SNA name of the partner LU for the conversation. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcHistConvTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvTpName.setStatus('current')
if mibBuilder.loadTexts: appcHistConvTpName.setDescription("The transaction program name which started this conversation. This name could either be from a FMH5 ATTACH for a remotely started conversation, otherwise it could the name of the local TP if available. When the TP name consists entirely of displayable EBCDIC code points, it is mapped directly to the equivalent ASCII display string. However, registered TP names always have a non- displayable EBCDIC code point (value less than or equal to x'3F') as the first character, so they cannot be directly mapped to an ASCII display string. These TP names are converted to a display string that is equivalent to a hexadecimal display of the EBCDIC code points. For example, the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte ASCII display string '06F1' (including the two single quotes). This name is NULL if the conversation is started locally (i.e., not with a FMH5 ATTACH).")
appcHistConvPcidNauName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 6), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 17), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvPcidNauName.setStatus('current')
if mibBuilder.loadTexts: appcHistConvPcidNauName.setDescription('The network-qualified NAU name of the node at which the session and PCID originated. For APPN and LEN nodes, this is either CP name of the APPN node at which the origin LU is located or the CP name of the NN serving the LEN node at which the origin LU is located. This field is from 3 to 17 characters in length, including a period (.) which separates the NetId from the NAU name. A null string indicates that the value is unknown.')
appcHistConvPcid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 7), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvPcid.setStatus('current')
if mibBuilder.loadTexts: appcHistConvPcid.setDescription('The procedure correlation identifier (PCID) of the session. It is an 8-octet value assigned by the control point providing session services for the primary LU. A null string indicates that the value is unknown.')
appcHistConvSenseData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 8), SnaSenseData()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvSenseData.setStatus('current')
if mibBuilder.loadTexts: appcHistConvSenseData.setDescription('The sense data associated with the action that ended this conversation, e.g., FMH-7 or UNBIND.')
appcHistConvLogData = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvLogData.setStatus('current')
if mibBuilder.loadTexts: appcHistConvLogData.setDescription('The first 32 bytes of the data portion of the Log Data GDS Variable that is associated with the last FMH-7 that occurred on this conversation. If there was no Log Data GDS Variable associated with the FMH-7, this object is null. This object reflects only the data portion of the Log Data GDS Variable (i.e. not the LL or GDS Id).')
appcHistConvEndedBy = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("localLu", 1), ("partnerLu", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcHistConvEndedBy.setStatus('current')
if mibBuilder.loadTexts: appcHistConvEndedBy.setDescription('Indicates which LU ended the conversation.')
appcCpicAdminTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1), )
if mibBuilder.loadTexts: appcCpicAdminTable.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminTable.setDescription('APPC CPI-C side information table.')
appcCpicAdminEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1), ).setIndexNames((0, "APPC-MIB", "appcCpicAdminLocLuName"), (0, "APPC-MIB", "appcCpicAdminSymbDestName"))
if mibBuilder.loadTexts: appcCpicAdminEntry.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminEntry.setDescription('Entry of APPC CPI-C side information Table.')
appcCpicAdminLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcCpicAdminLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminLocLuName.setDescription("The SNA name of the local LU to which this CPI-C side information definition applies. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. The reserved value '*ALL' indicates that the definition applies to all local LUs, and not just to a single local LU.")
appcCpicAdminSymbDestName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appcCpicAdminSymbDestName.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminSymbDestName.setDescription('Specifies the symbolic destination name used by CPI-C applications to identify this definition.')
appcCpicAdminParLuAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminParLuAlias.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminParLuAlias.setDescription('A local alias for the partner LU. If not known or not applicable, this object contains a zero-length string.')
appcCpicAdminParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminParLuName.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminParLuName.setDescription('The SNA name of the partner LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcCpicAdminModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminModeName.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminModeName.setDescription('Specifies the mode name. A mode defines the characteristics for a group of sessions. The mode name can be blank (8 space characters).')
appcCpicAdminTpNameType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("snaServiceTp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminTpNameType.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminTpNameType.setDescription('Specifies whether the TP name in appcCpicAdminTpName identifies a normal TP or an SNA service TP. In this context, a normal TP is one with a name consisting only of displayable characters, while an SNA service TP has a name containing octets that do not map to displayable characters.')
appcCpicAdminTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminTpName.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminTpName.setDescription("Specifies the name of the partner TP to be used when a CPI-C application initiates a conversation specifying this side information entry. Display convention When the TP name consists entirely of displayable EBCDIC code points, it is mapped directly to the equivalent ASCII display string. However, registered TP names always have a non-displayable EBCDIC code point (value less than or equal to x'3F') as the first character, so they cannot be directly mapped to an ASCII display string. These TP names are converted to a display string that is equivalent to a hexadecimal display of the EBCDIC code points. For example, the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte ASCII display string '06F1' (including the two single quotes).")
appcCpicAdminUserid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminUserid.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminUserid.setDescription('The security userid, if any, associated with the side information definition.')
appcCpicAdminSecurity = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("same", 2), ("pgm", 3), ("pgmStrong", 4), ("distributed", 5), ("mutual", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicAdminSecurity.setStatus('current')
if mibBuilder.loadTexts: appcCpicAdminSecurity.setDescription('Specifies the security information to be used for allocating the conversation. none - No security information. same - Use the security environment currently associated with this TP. pgm - Use the program-supplied user_id and password. pgmStrong - Use the program-supplied user_id and password. The local LU will insure that the password is not exposed in clear-text form on the physical network. distributed - Use the security environment and a distributed security system to generate the authentication information for this request. If distributed security tokens cannot be generated, then fail the conversation. mutual - Authenticate both the user to the destination system and the destination system to the user.')
appcCpicOperTable = MibTable((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2), )
if mibBuilder.loadTexts: appcCpicOperTable.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperTable.setDescription('APPC CPI-C side information operational table.')
appcCpicOperEntry = MibTableRow((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1), ).setIndexNames((0, "APPC-MIB", "appcCpicOperLocLuName"), (0, "APPC-MIB", "appcCpicOperSymbDestName"))
if mibBuilder.loadTexts: appcCpicOperEntry.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperEntry.setDescription('Entry of APPC CPI-C side information Table.')
appcCpicOperLocLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17)))
if mibBuilder.loadTexts: appcCpicOperLocLuName.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperLocLuName.setDescription("The SNA name of the local LU to which this CPI-C side information definition applies. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present. The reserved value '*ALL' indicates that the definition applies to all local LUs, and not just to a single local LU.")
appcCpicOperSymbDestName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)))
if mibBuilder.loadTexts: appcCpicOperSymbDestName.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperSymbDestName.setDescription('Specifies the symbolic destination name used by CPI-C applications to identify this definition.')
appcCpicOperParLuAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperParLuAlias.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperParLuAlias.setDescription('A local alias for the partner LU. If not known or not applicable, this object contains a zero-length string.')
appcCpicOperParLuName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperParLuName.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperParLuName.setDescription('The SNA name of the partner LU. This field is from 1 to 17 characters in length, including a period (.) which separates the NetId from the NAU name if the NetId is present.')
appcCpicOperModeName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperModeName.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperModeName.setDescription('Specifies the mode name. A mode defines the characteristics for a group of sessions. The mode name can be blank (8 space characters).')
appcCpicOperTpNameType = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("snaServiceTp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperTpNameType.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperTpNameType.setDescription('Specifies whether the TP name in appcCpicOperTpName identifies a normal TP or an SNA service TP. In this context, a normal TP is one with a name consisting only of displayable characters, while an SNA service TP has a name containing octets that do not map to displayable characters.')
appcCpicOperTpName = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperTpName.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperTpName.setDescription("Specifies the name of the partner TP to be used when a CPI-C application initiates a conversation specifying this side information entry. Display convention When the TP name consists entirely of displayable EBCDIC code points, it is mapped directly to the equivalent ASCII display string. However, registered TP names always have a non-displayable EBCDIC code point (value less than or equal to x'3F') as the first character, so they cannot be directly mapped to an ASCII display string. These TP names are converted to a display string that is equivalent to a hexadecimal display of the EBCDIC code points. For example, the 2-byte TP name x'06F1' (CNOS) is converted to the 6-byte ASCII display string '06F1' (including the two single quotes).")
appcCpicOperUserid = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperUserid.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperUserid.setDescription('The security userid, if any, associated with the active side information definition.')
appcCpicOperSecurity = MibTableColumn((1, 3, 6, 1, 2, 1, 34, 3, 1, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("same", 2), ("pgm", 3), ("pgmStrong", 4), ("distributed", 5), ("mutual", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: appcCpicOperSecurity.setStatus('current')
if mibBuilder.loadTexts: appcCpicOperSecurity.setDescription('Specifies the security information to be used for allocating the conversation. none - No security information. same - Use the security environment currently associated with this TP. pgm - Use the program-supplied user_id and password. pgmStrong - Use the program-supplied user_id and password. The local LU will insure that the password is not exposed in clear-text form on the physical network. distributed - Use the security environment and a distributed security system to generate the authentication information for this request. If distributed security tokens cannot be generated, then fail the conversation. mutual - Authenticate both the user to the destination system and the destination system to the user.')
appcConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 2))
appcCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 2, 1))
appcGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 3, 2, 2))
appcCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 34, 3, 2, 1, 1)).setObjects(("APPC-MIB", "appcGlobalConfGroup"), ("APPC-MIB", "appcLluConfGroup"), ("APPC-MIB", "appcParLuConfGroup"), ("APPC-MIB", "appcModeConfGroup"), ("APPC-MIB", "appcTpConfGroup"), ("APPC-MIB", "appcSessionConfGroup"), ("APPC-MIB", "appcControlConfGroup"), ("APPC-MIB", "appcCnosConfGroup"), ("APPC-MIB", "appcCpicConfGroup"), ("APPC-MIB", "appcConversationConfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcCompliance = appcCompliance.setStatus('current')
if mibBuilder.loadTexts: appcCompliance.setDescription('The compliance statement for the SNMPv2 entities which implement the APPC MIB.')
appcGlobalConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 1)).setObjects(("APPC-MIB", "appcUpTime"), ("APPC-MIB", "appcDefaultModeName"), ("APPC-MIB", "appcDefaultLuName"), ("APPC-MIB", "appcDefaultImplInbndPlu"), ("APPC-MIB", "appcDefaultMaxMcLlSndSize"), ("APPC-MIB", "appcDefaultFileSpec"), ("APPC-MIB", "appcDefaultTpOperation"), ("APPC-MIB", "appcDefaultTpConvSecRqd"), ("APPC-MIB", "appcLocalCpName"), ("APPC-MIB", "appcActiveSessions"), ("APPC-MIB", "appcActiveHprSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcGlobalConfGroup = appcGlobalConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcGlobalConfGroup.setDescription('A collection of objects providing the instrumentation of APPC global information and defaults.')
appcLluConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 2)).setObjects(("APPC-MIB", "appcLluAdminDepType"), ("APPC-MIB", "appcLluAdminLocalAddress"), ("APPC-MIB", "appcLluAdminSessLimit"), ("APPC-MIB", "appcLluAdminBindRspMayQ"), ("APPC-MIB", "appcLluAdminCompression"), ("APPC-MIB", "appcLluAdminInBoundCompLevel"), ("APPC-MIB", "appcLluAdminOutBoundCompLevel"), ("APPC-MIB", "appcLluAdminCompRleBeforeLZ"), ("APPC-MIB", "appcLluAdminAlias"), ("APPC-MIB", "appcLluOperDepType"), ("APPC-MIB", "appcLluOperLocalAddress"), ("APPC-MIB", "appcLluOperSessLimit"), ("APPC-MIB", "appcLluOperBindRspMayQ"), ("APPC-MIB", "appcLluOperCompression"), ("APPC-MIB", "appcLluOperInBoundCompLevel"), ("APPC-MIB", "appcLluOperOutBoundCompLevel"), ("APPC-MIB", "appcLluOperCompRleBeforeLZ"), ("APPC-MIB", "appcLluOperAlias"), ("APPC-MIB", "appcLluOperActiveSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcLluConfGroup = appcLluConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcLluConfGroup.setDescription('A collection of objects providing the instrumentation of APPC local LU6.2s.')
appcParLuConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 3)).setObjects(("APPC-MIB", "appcLuPairAdminParLuAlias"), ("APPC-MIB", "appcLuPairAdminSessLimit"), ("APPC-MIB", "appcLuPairAdminSessSec"), ("APPC-MIB", "appcLuPairAdminSecAccept"), ("APPC-MIB", "appcLuPairAdminLinkObjId"), ("APPC-MIB", "appcLuPairAdminParaSessSup"), ("APPC-MIB", "appcLuPairOperParLuAlias"), ("APPC-MIB", "appcLuPairOperSessLimit"), ("APPC-MIB", "appcLuPairOperSessSec"), ("APPC-MIB", "appcLuPairOperSecAccept"), ("APPC-MIB", "appcLuPairOperLinkObjId"), ("APPC-MIB", "appcLuPairOperParaSessSup"), ("APPC-MIB", "appcLuPairOperParaSessSupLS"), ("APPC-MIB", "appcLuPairOperState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcParLuConfGroup = appcParLuConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcParLuConfGroup.setDescription('A collection of objects providing the instrumentation of APPC partner LUs.')
appcModeConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 4)).setObjects(("APPC-MIB", "appcModeAdminCosName"), ("APPC-MIB", "appcModeAdminSessEndTpName"), ("APPC-MIB", "appcModeAdminMaxSessLimit"), ("APPC-MIB", "appcModeAdminMinCwinLimit"), ("APPC-MIB", "appcModeAdminMinClosLimit"), ("APPC-MIB", "appcModeAdminConWinAutoActLmt"), ("APPC-MIB", "appcModeAdminRecvPacWinSz"), ("APPC-MIB", "appcModeAdminSendPacWinSz"), ("APPC-MIB", "appcModeAdminPrefRecvRuSz"), ("APPC-MIB", "appcModeAdminPrefSendRuSz"), ("APPC-MIB", "appcModeAdminRecvRuSzUpBnd"), ("APPC-MIB", "appcModeAdminSendRuSzUpBnd"), ("APPC-MIB", "appcModeAdminRecvRuSzLoBnd"), ("APPC-MIB", "appcModeAdminSendRuSzLoBnd"), ("APPC-MIB", "appcModeAdminSingSessReinit"), ("APPC-MIB", "appcModeAdminCompression"), ("APPC-MIB", "appcModeAdminInBoundCompLevel"), ("APPC-MIB", "appcModeAdminOutBoundCompLevel"), ("APPC-MIB", "appcModeAdminCompRleBeforeLZ"), ("APPC-MIB", "appcModeAdminSyncLvl"), ("APPC-MIB", "appcModeAdminCrypto"), ("APPC-MIB", "appcModeOperCosName"), ("APPC-MIB", "appcModeOperSessEndTpName"), ("APPC-MIB", "appcModeOperSessLimit"), ("APPC-MIB", "appcModeOperMaxSessLimit"), ("APPC-MIB", "appcModeOperMinCwinLimit"), ("APPC-MIB", "appcModeOperMinClosLimit"), ("APPC-MIB", "appcModeOperConWinAutoActLmt"), ("APPC-MIB", "appcModeOperRecvPacWinSz"), ("APPC-MIB", "appcModeOperSendPacWinSz"), ("APPC-MIB", "appcModeOperPrefRecvRuSz"), ("APPC-MIB", "appcModeOperPrefSendRuSz"), ("APPC-MIB", "appcModeOperRecvRuSzUpBnd"), ("APPC-MIB", "appcModeOperSendRuSzUpBnd"), ("APPC-MIB", "appcModeOperRecvRuSzLoBnd"), ("APPC-MIB", "appcModeOperSendRuSzLoBnd"), ("APPC-MIB", "appcModeOperSingSessReinit"), ("APPC-MIB", "appcModeOperCompression"), ("APPC-MIB", "appcModeOperInBoundCompLevel"), ("APPC-MIB", "appcModeOperOutBoundCompLevel"), ("APPC-MIB", "appcModeOperCompRleBeforeLZ"), ("APPC-MIB", "appcModeOperSyncLvl"), ("APPC-MIB", "appcModeOperCrypto"), ("APPC-MIB", "appcModeOperSyncLvlLastStart"), ("APPC-MIB", "appcModeOperCryptoLastStart"), ("APPC-MIB", "appcModeOperCNOSNeg"), ("APPC-MIB", "appcModeOperActCwin"), ("APPC-MIB", "appcModeOperActClos"), ("APPC-MIB", "appcModeOperPndCwin"), ("APPC-MIB", "appcModeOperPndClos"), ("APPC-MIB", "appcModeOperPtmCwin"), ("APPC-MIB", "appcModeOperPtmClos"), ("APPC-MIB", "appcModeOperDrainSelf"), ("APPC-MIB", "appcModeOperDrainPart"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcModeConfGroup = appcModeConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcModeConfGroup.setDescription('A collection of objects providing the instrumentation of APPC modes.')
appcTpConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 5)).setObjects(("APPC-MIB", "appcTpAdminFileSpec"), ("APPC-MIB", "appcTpAdminStartParm"), ("APPC-MIB", "appcTpAdminTpOperation"), ("APPC-MIB", "appcTpAdminInAttachTimeout"), ("APPC-MIB", "appcTpAdminRcvAllocTimeout"), ("APPC-MIB", "appcTpAdminSyncLvl"), ("APPC-MIB", "appcTpAdminInstLmt"), ("APPC-MIB", "appcTpAdminStatus"), ("APPC-MIB", "appcTpAdminLongRun"), ("APPC-MIB", "appcTpAdminConvType"), ("APPC-MIB", "appcTpAdminConvDuplex"), ("APPC-MIB", "appcTpAdminConvSecReq"), ("APPC-MIB", "appcTpAdminVerPip"), ("APPC-MIB", "appcTpAdminPipSubNum"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcTpConfGroup = appcTpConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcTpConfGroup.setDescription('A collection of objects providing the instrumentation of APPC Transaction Programs.')
appcSessionConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 6)).setObjects(("APPC-MIB", "appcActSessPcidCpName"), ("APPC-MIB", "appcActSessPcid"), ("APPC-MIB", "appcActSessPluIndicator"), ("APPC-MIB", "appcActSessModeName"), ("APPC-MIB", "appcActSessCosName"), ("APPC-MIB", "appcActSessTransPriority"), ("APPC-MIB", "appcActSessEnhanceSecSup"), ("APPC-MIB", "appcActSessSendPacingType"), ("APPC-MIB", "appcActSessSendRpc"), ("APPC-MIB", "appcActSessSendNxWndwSize"), ("APPC-MIB", "appcActSessRecvPacingType"), ("APPC-MIB", "appcActSessRecvRpc"), ("APPC-MIB", "appcActSessRecvNxWndwSize"), ("APPC-MIB", "appcActSessRscv"), ("APPC-MIB", "appcActSessInUse"), ("APPC-MIB", "appcActSessMaxSndRuSize"), ("APPC-MIB", "appcActSessMaxRcvRuSize"), ("APPC-MIB", "appcActSessSndPacingSize"), ("APPC-MIB", "appcActSessRcvPacingSize"), ("APPC-MIB", "appcActSessOperState"), ("APPC-MIB", "appcActSessUpTime"), ("APPC-MIB", "appcActSessRtpNceId"), ("APPC-MIB", "appcActSessRtpTcid"), ("APPC-MIB", "appcActSessLinkIndex"), ("APPC-MIB", "appcSessStatsSentFmdBytes"), ("APPC-MIB", "appcSessStatsSentNonFmdBytes"), ("APPC-MIB", "appcSessStatsRcvdFmdBytes"), ("APPC-MIB", "appcSessStatsRcvdNonFmdBytes"), ("APPC-MIB", "appcSessStatsSentFmdRus"), ("APPC-MIB", "appcSessStatsSentNonFmdRus"), ("APPC-MIB", "appcSessStatsRcvdFmdRus"), ("APPC-MIB", "appcSessStatsRcvdNonFmdRus"), ("APPC-MIB", "appcSessStatsCtrUpTime"), ("APPC-MIB", "appcHistSessTime"), ("APPC-MIB", "appcHistSessType"), ("APPC-MIB", "appcHistSessLocLuName"), ("APPC-MIB", "appcHistSessParLuName"), ("APPC-MIB", "appcHistSessModeName"), ("APPC-MIB", "appcHistSessUnbindType"), ("APPC-MIB", "appcHistSessSenseData"), ("APPC-MIB", "appcHistSessComponentId"), ("APPC-MIB", "appcHistSessDetectModule"), ("APPC-MIB", "appcSessRtpSessions"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcSessionConfGroup = appcSessionConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcSessionConfGroup.setDescription('A collection of objects providing the instrumentation of APPC LU6.2 sessions.')
appcControlConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 7)).setObjects(("APPC-MIB", "appcCntrlAdminStat"), ("APPC-MIB", "appcCntrlAdminRscv"), ("APPC-MIB", "appcCntrlAdminTrace"), ("APPC-MIB", "appcCntrlAdminTraceParm"), ("APPC-MIB", "appcCntrlOperStat"), ("APPC-MIB", "appcCntrlOperStatTime"), ("APPC-MIB", "appcCntrlOperRscv"), ("APPC-MIB", "appcCntrlOperRscvTime"), ("APPC-MIB", "appcCntrlOperTrace"), ("APPC-MIB", "appcCntrlOperTraceTime"), ("APPC-MIB", "appcCntrlOperTraceParm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcControlConfGroup = appcControlConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcControlConfGroup.setDescription('A collection of objects providing the instrumentation of APPC control.')
appcCnosConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 8)).setObjects(("APPC-MIB", "appcCnosCommand"), ("APPC-MIB", "appcCnosMaxSessLimit"), ("APPC-MIB", "appcCnosMinCwinLimit"), ("APPC-MIB", "appcCnosMinClosLimit"), ("APPC-MIB", "appcCnosDrainSelf"), ("APPC-MIB", "appcCnosDrainPart"), ("APPC-MIB", "appcCnosResponsible"), ("APPC-MIB", "appcCnosForce"), ("APPC-MIB", "appcCnosTargetLocLuName"), ("APPC-MIB", "appcCnosTargetParLuName"), ("APPC-MIB", "appcCnosTargetModeName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcCnosConfGroup = appcCnosConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcCnosConfGroup.setDescription('A collection of objects providing the instrumentation of APPC CNOS processing.')
appcCpicConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 9)).setObjects(("APPC-MIB", "appcCpicAdminParLuAlias"), ("APPC-MIB", "appcCpicAdminParLuName"), ("APPC-MIB", "appcCpicAdminModeName"), ("APPC-MIB", "appcCpicAdminTpNameType"), ("APPC-MIB", "appcCpicAdminTpName"), ("APPC-MIB", "appcCpicAdminUserid"), ("APPC-MIB", "appcCpicAdminSecurity"), ("APPC-MIB", "appcCpicOperParLuAlias"), ("APPC-MIB", "appcCpicOperParLuName"), ("APPC-MIB", "appcCpicOperModeName"), ("APPC-MIB", "appcCpicOperTpNameType"), ("APPC-MIB", "appcCpicOperTpName"), ("APPC-MIB", "appcCpicOperUserid"), ("APPC-MIB", "appcCpicOperSecurity"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcCpicConfGroup = appcCpicConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcCpicConfGroup.setDescription('A collection of objects providing the instrumentation of APPC CPI-C side information.')
appcConversationConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 3, 2, 2, 10)).setObjects(("APPC-MIB", "appcActiveConvId"), ("APPC-MIB", "appcActiveConvState"), ("APPC-MIB", "appcActiveConvType"), ("APPC-MIB", "appcActiveConvCorrelator"), ("APPC-MIB", "appcActiveConvSyncLvl"), ("APPC-MIB", "appcActiveConvSource"), ("APPC-MIB", "appcActiveConvDuplex"), ("APPC-MIB", "appcActiveConvUpTime"), ("APPC-MIB", "appcActiveConvSendBytes"), ("APPC-MIB", "appcActiveConvRcvBytes"), ("APPC-MIB", "appcActiveConvUserid"), ("APPC-MIB", "appcActiveConvPcidNauName"), ("APPC-MIB", "appcActiveConvPcid"), ("APPC-MIB", "appcActiveConvModeName"), ("APPC-MIB", "appcActiveConvLuwIdName"), ("APPC-MIB", "appcActiveConvLuwIdInstance"), ("APPC-MIB", "appcActiveConvLuwIdSequence"), ("APPC-MIB", "appcActiveConvTpName"), ("APPC-MIB", "appcHistConvEndTime"), ("APPC-MIB", "appcHistConvLocLuName"), ("APPC-MIB", "appcHistConvParLuName"), ("APPC-MIB", "appcHistConvTpName"), ("APPC-MIB", "appcHistConvPcidNauName"), ("APPC-MIB", "appcHistConvPcid"), ("APPC-MIB", "appcHistConvSenseData"), ("APPC-MIB", "appcHistConvLogData"), ("APPC-MIB", "appcHistConvEndedBy"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    appcConversationConfGroup = appcConversationConfGroup.setStatus('current')
if mibBuilder.loadTexts: appcConversationConfGroup.setDescription('A collection of objects providing the instrumentation of APPC conversations.')
mibBuilder.exportSymbols("APPC-MIB", appcCntrlOperRscvTime=appcCntrlOperRscvTime, appcLluAdminInBoundCompLevel=appcLluAdminInBoundCompLevel, appcLluAdminCompRleBeforeLZ=appcLluAdminCompRleBeforeLZ, appcSessRtpTcid=appcSessRtpTcid, appcModeAdminInBoundCompLevel=appcModeAdminInBoundCompLevel, appcModeOperCryptoLastStart=appcModeOperCryptoLastStart, appcCnosTargetLocLuName=appcCnosTargetLocLuName, appcModeOperRecvRuSzUpBnd=appcModeOperRecvRuSzUpBnd, appcModeOperPtmCwin=appcModeOperPtmCwin, appcActSessRecvNxWndwSize=appcActSessRecvNxWndwSize, appcLuPairOperParLuAlias=appcLuPairOperParLuAlias, appcModeAdminParLuName=appcModeAdminParLuName, appcActSessParLuName=appcActSessParLuName, appcLluAdminBindRspMayQ=appcLluAdminBindRspMayQ, appcModeOperActClos=appcModeOperActClos, appcHistConvEndedBy=appcHistConvEndedBy, appcActiveConvParLuName=appcActiveConvParLuName, appcTpAdminInAttachTimeout=appcTpAdminInAttachTimeout, appcGlobal=appcGlobal, appcHistConvTpName=appcHistConvTpName, appcActSessTransPriority=appcActSessTransPriority, appcCnosDrainSelf=appcCnosDrainSelf, appcActiveConvUpTime=appcActiveConvUpTime, appcCpicAdminSymbDestName=appcCpicAdminSymbDestName, appcGlobalConfGroup=appcGlobalConfGroup, appcHistConvParLuName=appcHistConvParLuName, appcCntrlOperTraceTime=appcCntrlOperTraceTime, appcLluAdminTable=appcLluAdminTable, appcModeOperSessLimit=appcModeOperSessLimit, appcSessStatsLocLuName=appcSessStatsLocLuName, appcLuPairAdminEntry=appcLuPairAdminEntry, appcModeAdminSessEndTpName=appcModeAdminSessEndTpName, appcLluAdminOutBoundCompLevel=appcLluAdminOutBoundCompLevel, appcLuPairOperTable=appcLuPairOperTable, appcModeAdminEntry=appcModeAdminEntry, appcActSessIndex=appcActSessIndex, appcLuPairAdminSecAccept=appcLuPairAdminSecAccept, appcModeOperCosName=appcModeOperCosName, appcCntrlOperGroup=appcCntrlOperGroup, appcConversation=appcConversation, appcModeOperTable=appcModeOperTable, appcHistSessLocLuName=appcHistSessLocLuName, appcCnosDrainPart=appcCnosDrainPart, appcActiveConvLuwIdName=appcActiveConvLuwIdName, SnaSenseData=SnaSenseData, appcModeOperSyncLvlLastStart=appcModeOperSyncLvlLastStart, appcLluOperLocalAddress=appcLluOperLocalAddress, appcActSessRecvPacingType=appcActSessRecvPacingType, appcModeOperMinClosLimit=appcModeOperMinClosLimit, appcSessStatsSentFmdRus=appcSessStatsSentFmdRus, appcHistConvEndTime=appcHistConvEndTime, appcActSessRecvRpc=appcActSessRecvRpc, appcModeAdminRecvRuSzUpBnd=appcModeAdminRecvRuSzUpBnd, appcModeOperPtmClos=appcModeOperPtmClos, appcActiveConvLuwIdInstance=appcActiveConvLuwIdInstance, appcModeOperPndCwin=appcModeOperPndCwin, appcModeOperCrypto=appcModeOperCrypto, appcCpicOperLocLuName=appcCpicOperLocLuName, appcCpicAdminTable=appcCpicAdminTable, appcObjects=appcObjects, appcModeAdminSendPacWinSz=appcModeAdminSendPacWinSz, appcActiveConvSessIndex=appcActiveConvSessIndex, appcHistSessParLuName=appcHistSessParLuName, appcCntrlOperStat=appcCntrlOperStat, appcActSessPcidCpName=appcActSessPcidCpName, appcTpAdminConvDuplex=appcTpAdminConvDuplex, appcCntrlOperTrace=appcCntrlOperTrace, appcCnosMinClosLimit=appcCnosMinClosLimit, appcLluOperBindRspMayQ=appcLluOperBindRspMayQ, appcCntrlOperTraceParm=appcCntrlOperTraceParm, appcSessStatsSessIndex=appcSessStatsSessIndex, appcConversationConfGroup=appcConversationConfGroup, appcModeOperSessEndTpName=appcModeOperSessEndTpName, appcModeOperSendRuSzLoBnd=appcModeOperSendRuSzLoBnd, appcCntrlAdminTraceParm=appcCntrlAdminTraceParm, appcModeOperCNOSNeg=appcModeOperCNOSNeg, appcActiveConvTpName=appcActiveConvTpName, appcCpicAdminParLuName=appcCpicAdminParLuName, appcActSessEntry=appcActSessEntry, appcLuPairAdminParLuAlias=appcLuPairAdminParLuAlias, appcActiveConvModeName=appcActiveConvModeName, appcLuPairAdminSessSec=appcLuPairAdminSessSec, appcHistSessDetectModule=appcHistSessDetectModule, appcModeAdminSendRuSzLoBnd=appcModeAdminSendRuSzLoBnd, appcCpicAdminLocLuName=appcCpicAdminLocLuName, appcSessStatsRcvdFmdRus=appcSessStatsRcvdFmdRus, appcModeOperSendPacWinSz=appcModeOperSendPacWinSz, appcLuPairOperSecAccept=appcLuPairOperSecAccept, appcActiveConvPcid=appcActiveConvPcid, appcModeOperMinCwinLimit=appcModeOperMinCwinLimit, appcCpicAdminUserid=appcCpicAdminUserid, appcActiveConvUserid=appcActiveConvUserid, appcLuPairOperParaSessSup=appcLuPairOperParaSessSup, appcCpicOperModeName=appcCpicOperModeName, appcDefaultTpConvSecRqd=appcDefaultTpConvSecRqd, appcActiveConvId=appcActiveConvId, appcModeAdminMinCwinLimit=appcModeAdminMinCwinLimit, appcTpAdminTable=appcTpAdminTable, appcLuPairOperLinkObjId=appcLuPairOperLinkObjId, appcTpAdminSyncLvl=appcTpAdminSyncLvl, appcTpAdminTpName=appcTpAdminTpName, appcParLuConfGroup=appcParLuConfGroup, appcGroups=appcGroups, appcSessionConfGroup=appcSessionConfGroup, appcModeAdminModeName=appcModeAdminModeName, appcModeOperCompRleBeforeLZ=appcModeOperCompRleBeforeLZ, appcTpConfGroup=appcTpConfGroup, appcHistSessType=appcHistSessType, appcModeOperLocLuName=appcModeOperLocLuName, appcCompliance=appcCompliance, appcHistConvLocLuName=appcHistConvLocLuName, appcSessStatsTable=appcSessStatsTable, appcCpicAdminTpNameType=appcCpicAdminTpNameType, appcModeOperConWinAutoActLmt=appcModeOperConWinAutoActLmt, appcSessStatsSentNonFmdBytes=appcSessStatsSentNonFmdBytes, appcCpicOperTpName=appcCpicOperTpName, appcActSessInUse=appcActSessInUse, appcActiveSessions=appcActiveSessions, appcLluOperActiveSessions=appcLluOperActiveSessions, appcActSessModeName=appcActSessModeName, appcModeOperCompression=appcModeOperCompression, appcLluAdminAlias=appcLluAdminAlias, appcModeAdminCosName=appcModeAdminCosName, appcLluAdminName=appcLluAdminName, appcActiveConvDuplex=appcActiveConvDuplex, appcTpAdminTpOperation=appcTpAdminTpOperation, appcModeOperRecvPacWinSz=appcModeOperRecvPacWinSz, appcActiveConvTable=appcActiveConvTable, appcLluOperOutBoundCompLevel=appcLluOperOutBoundCompLevel, appcCpicOperTpNameType=appcCpicOperTpNameType, appcUpTime=appcUpTime, appcModeAdminOutBoundCompLevel=appcModeAdminOutBoundCompLevel, appcMIB=appcMIB, appcLuPairAdminTable=appcLuPairAdminTable, appcConformance=appcConformance, appcModeAdminSingSessReinit=appcModeAdminSingSessReinit, appcCpicOperUserid=appcCpicOperUserid, appcActiveConvCorrelator=appcActiveConvCorrelator, appcTpAdminVerPip=appcTpAdminVerPip, appcLluAdminDepType=appcLluAdminDepType, appcCpicAdminSecurity=appcCpicAdminSecurity, appcModeOperModeName=appcModeOperModeName, appcActSessOperState=appcActSessOperState, appcActSessRscv=appcActSessRscv, appcSessRtpEntry=appcSessRtpEntry, appcHistSessModeName=appcHistSessModeName, appcModeAdminCrypto=appcModeAdminCrypto, appcDefaultLuName=appcDefaultLuName, appcLuPairAdminParaSessSup=appcLuPairAdminParaSessSup, appcActSessCosName=appcActSessCosName, appcModeOperMaxSessLimit=appcModeOperMaxSessLimit, appcHistConvSenseData=appcHistConvSenseData, appcSessStatsSentNonFmdRus=appcSessStatsSentNonFmdRus, appcCntrlAdminGroup=appcCntrlAdminGroup, appcActiveConvSendBytes=appcActiveConvSendBytes, appcModeOperDrainSelf=appcModeOperDrainSelf, appcSessStatsEntry=appcSessStatsEntry, appcLuPairOperSessLimit=appcLuPairOperSessLimit, appcSessStatsRcvdNonFmdBytes=appcSessStatsRcvdNonFmdBytes, appcLluOperDepType=appcLluOperDepType, appcModeOperEntry=appcModeOperEntry, appcCnosResponsible=appcCnosResponsible, appcCnosMinCwinLimit=appcCnosMinCwinLimit, appcTpAdminEntry=appcTpAdminEntry, appcModeOperParLuName=appcModeOperParLuName, appcLuPairAdminSessLimit=appcLuPairAdminSessLimit, appcModeAdminRecvPacWinSz=appcModeAdminRecvPacWinSz, appcSessStatsCtrUpTime=appcSessStatsCtrUpTime, appcLuPairOperParLuName=appcLuPairOperParLuName, appcHistConvEntry=appcHistConvEntry, appcHistConvLogData=appcHistConvLogData, appcHistConvIndex=appcHistConvIndex, appcActSessMaxSndRuSize=appcActSessMaxSndRuSize, appcLluConfGroup=appcLluConfGroup, appcTpAdminPipSubNum=appcTpAdminPipSubNum, appcSessStatsRcvdNonFmdRus=appcSessStatsRcvdNonFmdRus, appcCPIC=appcCPIC, appcLluOperCompRleBeforeLZ=appcLluOperCompRleBeforeLZ, appcActSessLinkIndex=appcActSessLinkIndex, appcModeOperPrefRecvRuSz=appcModeOperPrefRecvRuSz, appcModeOperSyncLvl=appcModeOperSyncLvl, appcTpAdminFileSpec=appcTpAdminFileSpec, appcLuPairOperSessSec=appcLuPairOperSessSec, appcCnosMaxSessLimit=appcCnosMaxSessLimit, appcActSessUpTime=appcActSessUpTime, appcModeOperSendRuSzUpBnd=appcModeOperSendRuSzUpBnd, appcActSessTable=appcActSessTable, appcLluOperInBoundCompLevel=appcLluOperInBoundCompLevel, appcModeAdminConWinAutoActLmt=appcModeAdminConWinAutoActLmt, appcGlobalObjects=appcGlobalObjects, appcLluAdminEntry=appcLluAdminEntry, appcCnosTargetModeName=appcCnosTargetModeName, appcCntrlAdminTrace=appcCntrlAdminTrace, appcControlConfGroup=appcControlConfGroup, appcActiveConvState=appcActiveConvState, appcDefaultMaxMcLlSndSize=appcDefaultMaxMcLlSndSize, appcLuPairOperState=appcLuPairOperState, appcLluOperCompression=appcLluOperCompression, appcModeAdminCompRleBeforeLZ=appcModeAdminCompRleBeforeLZ, PYSNMP_MODULE_ID=appcMIB, appcTpAdminLocLuName=appcTpAdminLocLuName, appcModeAdminPrefRecvRuSz=appcModeAdminPrefRecvRuSz, appcActSessSendPacingType=appcActSessSendPacingType, appcModeOperInBoundCompLevel=appcModeOperInBoundCompLevel, appcLocalCpName=appcLocalCpName, appcTp=appcTp, appcModeOperSingSessReinit=appcModeOperSingSessReinit, appcSessStatsSentFmdBytes=appcSessStatsSentFmdBytes, appcModeOperOutBoundCompLevel=appcModeOperOutBoundCompLevel, appcActiveHprSessions=appcActiveHprSessions, appcCnosControl=appcCnosControl, appcActSessSendRpc=appcActSessSendRpc, appcHistSessSenseData=appcHistSessSenseData, appcActiveConvRcvBytes=appcActiveConvRcvBytes, appcSessRtpSessions=appcSessRtpSessions, appcActSessSendNxWndwSize=appcActSessSendNxWndwSize, appcLluAdminSessLimit=appcLluAdminSessLimit, appcCpicAdminModeName=appcCpicAdminModeName, appcHistSessIndex=appcHistSessIndex, appcCpicAdminEntry=appcCpicAdminEntry, appcCpicOperParLuAlias=appcCpicOperParLuAlias, appcModeConfGroup=appcModeConfGroup, appcModeAdminLocLuName=appcModeAdminLocLuName, appcTpAdminConvSecReq=appcTpAdminConvSecReq, appcLuPairOperParaSessSupLS=appcLuPairOperParaSessSupLS, appcCpicAdminParLuAlias=appcCpicAdminParLuAlias, appcHistSessTime=appcHistSessTime, appcCpicOperSymbDestName=appcCpicOperSymbDestName, appcActiveConvLuwIdSequence=appcActiveConvLuwIdSequence, appcLuPairAdminLinkObjId=appcLuPairAdminLinkObjId, appcActSessEnhanceSecSup=appcActSessEnhanceSecSup, appcModeAdminTable=appcModeAdminTable, appcCnosForce=appcCnosForce, appcModeAdminPrefSendRuSz=appcModeAdminPrefSendRuSz, appcActSessSndPacingSize=appcActSessSndPacingSize, appcSessStatsParLuName=appcSessStatsParLuName, appcCpicOperSecurity=appcCpicOperSecurity, appcActiveConvEntry=appcActiveConvEntry, appcModeOperRecvRuSzLoBnd=appcModeOperRecvRuSzLoBnd, appcActSessPcid=appcActSessPcid, appcActiveConvSource=appcActiveConvSource, appcActSessRtpTcid=appcActSessRtpTcid, appcCntrlAdminRscv=appcCntrlAdminRscv, appcModeAdminSendRuSzUpBnd=appcModeAdminSendRuSzUpBnd, appcSessStatsRcvdFmdBytes=appcSessStatsRcvdFmdBytes, appcSession=appcSession, appcCpicAdminTpName=appcCpicAdminTpName, appcActiveConvType=appcActiveConvType, appcLuPairOperEntry=appcLuPairOperEntry, appcActSessLocLuName=appcActSessLocLuName, appcModeOperDrainPart=appcModeOperDrainPart, appcActSessRcvPacingSize=appcActSessRcvPacingSize, appcCnosCommand=appcCnosCommand, appcActiveConvSyncLvl=appcActiveConvSyncLvl)
mibBuilder.exportSymbols("APPC-MIB", appcLuPairAdminLocLuName=appcLuPairAdminLocLuName, appcModeAdminMaxSessLimit=appcModeAdminMaxSessLimit, appcTpAdminStartParm=appcTpAdminStartParm, appcTpAdminInstLmt=appcTpAdminInstLmt, appcLluOperTable=appcLluOperTable, appcSessRtpNceId=appcSessRtpNceId, appcDefaultTpOperation=appcDefaultTpOperation, appcCpicConfGroup=appcCpicConfGroup, appcDefaultImplInbndPlu=appcDefaultImplInbndPlu, appcLluOperEntry=appcLluOperEntry, appcTpAdminRcvAllocTimeout=appcTpAdminRcvAllocTimeout, appcLuPairAdminParLuName=appcLuPairAdminParLuName, appcActSessMaxRcvRuSize=appcActSessMaxRcvRuSize, appcModeAdminMinClosLimit=appcModeAdminMinClosLimit, appcActSessRtpNceId=appcActSessRtpNceId, appcCntrlOperStatTime=appcCntrlOperStatTime, appcModeAdminRecvRuSzLoBnd=appcModeAdminRecvRuSzLoBnd, appcTpAdminConvType=appcTpAdminConvType, appcDefaultModeName=appcDefaultModeName, appcLluOperSessLimit=appcLluOperSessLimit, appcHistConvPcidNauName=appcHistConvPcidNauName, appcHistSessTable=appcHistSessTable, appcHistConvPcid=appcHistConvPcid, appcCnosTargetParLuName=appcCnosTargetParLuName, appcModeOperPndClos=appcModeOperPndClos, appcHistSessEntry=appcHistSessEntry, appcHistConvTable=appcHistConvTable, appcLluOperName=appcLluOperName, appcCnosConfGroup=appcCnosConfGroup, appcTpAdminLongRun=appcTpAdminLongRun, appcLluAdminCompression=appcLluAdminCompression, appcLluAdminLocalAddress=appcLluAdminLocalAddress, appcCpicOperParLuName=appcCpicOperParLuName, appcModeAdminSyncLvl=appcModeAdminSyncLvl, appcActiveConvLocLuName=appcActiveConvLocLuName, appcLuPairOperLocLuName=appcLuPairOperLocLuName, appcLluOperAlias=appcLluOperAlias, appcModeOperActCwin=appcModeOperActCwin, appcActiveConvPcidNauName=appcActiveConvPcidNauName, appcTpAdminStatus=appcTpAdminStatus, appcCntrlAdminStat=appcCntrlAdminStat, appcHistSessComponentId=appcHistSessComponentId, appcHistSessUnbindType=appcHistSessUnbindType, appcModeOperPrefSendRuSz=appcModeOperPrefSendRuSz, appcCpicOperEntry=appcCpicOperEntry, appcModeAdminCompression=appcModeAdminCompression, appcLu=appcLu, appcDefaultFileSpec=appcDefaultFileSpec, appcCpicOperTable=appcCpicOperTable, appcSessRtpTable=appcSessRtpTable, appcCntrlOperRscv=appcCntrlOperRscv, appcActSessPluIndicator=appcActSessPluIndicator, appcCompliances=appcCompliances)

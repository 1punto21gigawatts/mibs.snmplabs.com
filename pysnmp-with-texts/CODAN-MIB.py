#
# PySNMP MIB module CODAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CODAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:25:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
codanMibs, = mibBuilder.importSymbols("CODAN-SMI", "codanMibs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, ObjectIdentity, ModuleIdentity, Counter32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Unsigned32, NotificationType, Gauge32, IpAddress, Counter64, Integer32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "ObjectIdentity", "ModuleIdentity", "Counter32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Unsigned32", "NotificationType", "Gauge32", "IpAddress", "Counter64", "Integer32", "TimeTicks")
TextualConvention, DateAndTime, TestAndIncr, TimeInterval, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DateAndTime", "TestAndIncr", "TimeInterval", "DisplayString")
minetMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 23304, 1, 1))
minetMIB.setRevisions(('1997-08-26 18:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: minetMIB.setRevisionsDescriptions(('Release Version of this MIB.',))
if mibBuilder.loadTexts: minetMIB.setLastUpdated('0906260645Z')
if mibBuilder.loadTexts: minetMIB.setOrganization('Codan Limited')
if mibBuilder.loadTexts: minetMIB.setContactInfo(' Andrew Burton Postal: Codan 81 Graves St. Newton 5074 Australia Tel: +61-8-83050311 Fax: +61-8-83050411 http//codan.com.au')
if mibBuilder.loadTexts: minetMIB.setDescription(" This is the MIB module for objects necessary to manage the Codan 8800 DMR device. Also NOTIFICATION-TYPEs (traps) are defined at the end of this document. Its position in the internet tree and its general structure are as follows: iso(1).org(3).dod(6).internet(1) : private(4) : enterprises(1) : codan(23304) : codanMibs(1) : minetMIB(1) : .......................................................... : : : : : : : : : : : wvStatusAndGauges(2) : wvTests(4) : wvConfiguration(1) wvPerformance(3) wvTraps(10) : :........................................................ : : : : : : : : : : wvLinkSettings(1) wvInterfaces(2) : wvManagement(3) wvRelayTable(4) : ....................................................... : : : : : : wvExternalInputTable(5) wvAlarmControl(6) wvComponentsRevisions(7) Note that in addition to the objects defined in this module, the Codan 8800 DMR supports the following objects from standard MIBs: MIB NAME GROUP OBJECT ======== ===== ====== MIB-II (RFC 1213) system sysName sysLocation sysContact sysObjectId sysDescr sysUpTime ipAddrTable ipAdEntAddr ipAdEntIfIndex ipAdEntNetMask Interfaces MIB (RFC 1573) interfaces ifNumber ifIndex ifDescr ifType ifMtu ifSpeed ifPhysAddress ifAdminStatus ifOperStatus ifLastChange ifInOctets ifInUcastPkts ifInNUcastPkts ifInDiscards ifInErrors ifInUnknownProtos ifOutOctets ifOutUcastPkts ifOutNUcastPkts ifOutDiscards ifOutErrors ifOutQLen ifSpecific snmpTraps linkUp linkDown DS1/E1 MIB (RFC 1406) dsx1ConfigTable dsx1LineIndex dsx1IfIndex dsx1LineType dsx1LineCoding dsx1LoopbackConfig dsx1TransmitClockSource dsx1LineStatus dsx1TimeElapsed dsx1CurrentESs dsx1CurrentSESs dsx1CurrentUASs dsx1CurrentDMs dsx1TotalESs dsx1TotalSESs dsx1TotalUASs dsx1TotalDMs DS3/E3 MIB (RFC 1407) dsx3ConfigTable dsx3LineIndex dsx3IfIndex dsx3LineCoding dsx3TransmitClockSource dsx3LineStatus dsx3CurrentUASs dsx3TotalUASs RS-232-like MIB (RFC 1659) rs232PortTable rs232PortIndex rs232PortInSpeed rs232PortOutSpeed rs232PortInFlowType rs232PortOutFlowType rs232PortType rs232AsyncPortTable rs232AsyncPortIndex rs232AsyncPortBits rs232AsyncPortStopBits rs232AsyncPortParity RFC 1907 snmpTraps authenticationFailure ETH-Like MIB (RFC 1643) dot3StatsTable dot3StatsIndex dot3StatsAlignmentErrors dot3StatsFCSErrors dot3StatsSingleCollisionFrames dot3StatsMultipleCollisionFrames dot3StatsSQETestErrors dot3StatsDeferredTransmissions dot3StatsLateCollisions dot3StatsExcessiveCollisions dot3StatsInternalMacTransmitErrors dot3StatsCarrierSenseErrors dot3StatsFrameTooLongs dot3StatsInternalMacReceiveErrors dot3StatsEtherChipSet NOTE: Codan 8800 DMR supports an STS-1 interface. For the purposes of this MIB, it behaves like E3/T3. Since it doesn't have a specific ifType, it's type will be 'other'. ")
class WvAlarmsList(TextualConvention, Bits):
    description = 'Describes all the possible alarms in the system as a bit pattern, taken directly from the various statuses (see wvStatusAndGauges group). The alarms are sorted in a descending severity order (fatal/error/warning), thus automatically defining their severity level.'
    status = 'current'
    namedValues = NamedValues(("filler0", 0), ("wvTelemetrynotOperational", 1), ("wvIduOduCableFault", 2), ("wvOperatingSystemFailure", 3), ("iduPowerSupplyLowValue", 4), ("iduTxSynthesizerOutOfLock", 5), ("iduRxSynthesizerOutOfLock", 6), ("iduNotOperational", 7), ("oduPowerSupplyOutOfRange", 8), ("txFailure", 9), ("oduTxSynthesizerOutOfLock", 10), ("oduRxSynthesizerOutOfLock", 11), ("oduRfSynthesizerOutOfLock", 12), ("remoteTerminalNotResponding", 13), ("linkDown", 14), ("filler15", 15), ("filler16", 16), ("filler17", 17), ("filler18", 18), ("filler19", 19), ("selfTestFault", 20), ("rxFailure", 21), ("wvTelemetryFailure", 22), ("oduTemperatureViolation", 23), ("anyOtherOduFault", 24), ("oduNotResponding", 25), ("wvSlipModemFailure", 26), ("linkIdViolation", 27), ("wvTftpDwnlFailure", 28), ("wvLinkESAlarm", 29), ("wvLinkSESAlarm", 30), ("wvLinkUASAlarm", 31), ("wvLinkDMAlarm", 32), ("wvLinkBERFailureAlarm", 33), ("wvLinkBLERAlarm", 34), ("wvLinkBBERAlarm", 35), ("wvLinkNCBLERAlarm", 36), ("dwnlGeneralError", 37), ("dwnlNoResponseFromServer", 38), ("dwnlChecksumError", 39), ("dwnlSwIncompatibleImage", 40), ("dwnlConfigIncompatibleImage", 41), ("dwnlTftpFileNotFound", 42), ("dwnlTftpAccessViolation", 43), ("remoteTerminalFailure", 44), ("filler45", 45), ("filler46", 46), ("filler47", 47), ("filler48", 48), ("filler49", 49), ("txOnMuteState", 50), ("rxOnMuteState", 51), ("remoteTerminalWarning", 52), ("passwordBypass", 53), ("wvLinkBERWarningAlarm", 54), ("rslLow", 55), ("averageRSLLow", 56), ("ds1Line-1-AIS", 57), ("ds1Line-2-AIS", 58), ("ds1Line-3-AIS", 59), ("ds1Line-4-AIS", 60), ("ds1Line-5-AIS", 61), ("ds1Line-6-AIS", 62), ("ds1Line-7-AIS", 63), ("ds1Line-8-AIS", 64), ("ds1Line-9-AIS", 65), ("ds1Line-10-AIS", 66), ("ds1Line-11-AIS", 67), ("ds1Line-12-AIS", 68), ("ds1Line-13-AIS", 69), ("ds1Line-14-AIS", 70), ("ds1Line-15-AIS", 71), ("ds1Line-16-AIS", 72), ("ds3Sts1Line-AIS", 73), ("ds1Line-1-LOS", 74), ("ds1Line-2-LOS", 75), ("ds1Line-3-LOS", 76), ("ds1Line-4-LOS", 77), ("ds1Line-5-LOS", 78), ("ds1Line-6-LOS", 79), ("ds1Line-7-LOS", 80), ("ds1Line-8-LOS", 81), ("ds1Line-9-LOS", 82), ("ds1Line-10-LOS", 83), ("ds1Line-11-LOS", 84), ("ds1Line-12-LOS", 85), ("ds1Line-13-LOS", 86), ("ds1Line-14-LOS", 87), ("ds1Line-15-LOS", 88), ("ds1Line-16-LOS", 89), ("ds3Sts1Line-LOS", 90), ("ds1Line-1-USD", 91), ("ds1Line-2-USD", 92), ("ds1Line-3-USD", 93), ("ds1Line-4-USD", 94), ("ds1Line-5-USD", 95), ("ds1Line-6-USD", 96), ("ds1Line-7-USD", 97), ("ds1Line-8-USD", 98), ("ds1Line-9-USD", 99), ("ds1Line-10-USD", 100), ("ds1Line-11-USD", 101), ("ds1Line-12-USD", 102), ("ds1Line-13-USD", 103), ("ds1Line-14-USD", 104), ("ds1Line-15-USD", 105), ("ds1Line-16-USD", 106), ("ds3Sts1Line-USD", 107), ("ds1Line-1-LOOP", 108), ("ds1Line-2-LOOP", 109), ("ds1Line-3-LOOP", 110), ("ds1Line-4-LOOP", 111), ("ds1Line-5-LOOP", 112), ("ds1Line-6-LOOP", 113), ("ds1Line-7-LOOP", 114), ("ds1Line-8-LOOP", 115), ("ds1Line-9-LOOP", 116), ("ds1Line-10-LOOP", 117), ("ds1Line-11-LOOP", 118), ("ds1Line-12-LOOP", 119), ("ds1Line-13-LOOP", 120), ("ds1Line-14-LOOP", 121), ("ds1Line-15-LOOP", 122), ("ds1Line-16-LOOP", 123), ("ds3Sts1Line-LOOP", 124), ("dwnlStatusUnknown", 125), ("dwnlInProcess", 126), ("dwnlSuccess", 127), ("ifLinkDown", 128), ("wvTelemetryWarning", 129), ("filler130", 130), ("eth10-100Port-1-CSL", 131), ("eth10-100Port-2-CSL", 132), ("eth10-100Port-3-CSL", 133), ("eth10-100Port-4-CSL", 134), ("eth10-100Port-1-EC", 135), ("eth10-100Port-2-EC", 136), ("eth10-100Port-3-EC", 137), ("eth10-100Port-4-EC", 138), ("eth10-100Port-1-IMTE", 139), ("eth10-100Port-2-IMTE", 140), ("eth10-100Port-3-IMTE", 141), ("eth10-100Port-4-IMTE", 142), ("eth10-100Port-1-IMRE", 143), ("eth10-100Port-2-IMRE", 144), ("eth10-100Port-3-IMRE", 145), ("eth10-100Port-4-IMRE", 146), ("filler147", 147), ("externalInput1Active", 148), ("externalInput2Active", 149), ("externalInput3Active", 150), ("externalInput4Active", 151), ("externalInput5Active", 152), ("externalInput6Active", 153), ("externalInput7Active", 154), ("externalInput8Active", 155), ("eth10-100RxLinkUsageLow", 156), ("eth10-100RxLinkUsageHigh", 157), ("eth10-100TxLinkUsageLow", 158), ("eth10-100TxLinkUsageHigh", 159))

class ComponentRevision(TextualConvention, OctetString):
    description = 'The hex value in the first octet - xx - represent the major revision no. and the hex value in the second octet - yy - the minor revision no.'
    status = 'current'
    displayHint = 'Vxx.yy'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 2)
    fixedLength = 2

class FrontPanelPassword(TextualConvention, OctetString):
    description = 'Describes a Front Panel Password key sequence, in the following convention: 0 - end of password string 1 - ESC key 2 - SEL/SAVE key 3 - Arrow Right key 4 - Arrow Left key 5 - LOCAL/REMOTE key'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 5)

class FloatingPoint(TextualConvention, OctetString):
    description = "The hex value in the first 2 octets specify the mantissa*1000 (1000 =< value <= 9999) and the hex value in the 3rd octet specify the 10th power (1 =< n <= 15). Example: For user input of 1.025E-7 the hex value should be '040107'h."
    status = 'current'
    displayHint = 'a.bcdE-n'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 3)
    fixedLength = 3

class WvLoopbacksList(TextualConvention, Bits):
    description = 'Describes the type of loopbacks that can be performed on the terminal. Local restrictions may dictate how many and which loopbacks can be performed simultaneously.'
    status = 'current'
    namedValues = NamedValues(("filler0", 0), ("localIduInputdsx1-1", 1), ("localIduInputdsx1-2", 2), ("localIduInputdsx1-3", 3), ("localIduInputdsx1-4", 4), ("localIduInputdsx1-5", 5), ("localIduInputdsx1-6", 6), ("localIduInputdsx1-7", 7), ("localIduInputdsx1-8", 8), ("localIduInputdsx1-9", 9), ("localIduInputdsx1-10", 10), ("localIduInputdsx1-11", 11), ("localIduInputdsx1-12", 12), ("localIduInputdsx1-13", 13), ("localIduInputdsx1-14", 14), ("localIduInputdsx1-15", 15), ("localIduInputdsx1-16", 16), ("localIduInputdsx3sts1", 17), ("localIduOutput", 18), ("localOdu", 19), ("localIduInput", 20), ("remoteIdudsx1-1", 21), ("remoteIdudsx1-2", 22), ("remoteIdudsx1-3", 23), ("remoteIdudsx1-4", 24), ("remoteIdudsx1-5", 25), ("remoteIdudsx1-6", 26), ("remoteIdudsx1-7", 27), ("remoteIdudsx1-8", 28), ("remoteIdudsx1-9", 29), ("remoteIdudsx1-10", 30), ("remoteIdudsx1-11", 31), ("remoteIdudsx1-12", 32), ("remoteIdudsx1-13", 33), ("remoteIdudsx1-14", 34), ("remoteIdudsx1-15", 35), ("remoteIdudsx1-16", 36), ("remoteIdudsx3sts1", 37), ("filler38", 38), ("filler39", 39), ("filler40", 40), ("localIduInputEth10-100-1", 41), ("localIduInputEth10-100-2", 42), ("remoteIduEth10-100-1", 43), ("remoteIduEth10-100-2", 44))

wvConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1))
wvStatusAndGauges = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2))
wvPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3))
wvTests = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4))
wvTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10))
wvLinkSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1))
wvInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2))
wvManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3))
wvRelays = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4))
wvExternalInputs = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 5))
wvAlarmControl = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6))
wvComponentsRevisions = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7))
wvLinkId = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkId.setStatus('current')
if mibBuilder.loadTexts: wvLinkId.setDescription('Radio Link ID. The 2 terminals of the link must have the same linkId in order to communicate. This value should be encrypted when carried accross the network.')
wvLinkName = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone('Codan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkName.setStatus('current')
if mibBuilder.loadTexts: wvLinkName.setDescription('Radio Link Name. Limited to above size and [a-z, 0-9,-,*] because of the LCD.')
wvLinkRouteDescription = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone('siteA-siteB')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkRouteDescription.setStatus('current')
if mibBuilder.loadTexts: wvLinkRouteDescription.setDescription('Radio Link Route. Limited to above size and [a-z, 0-9,-,*] because of the LCD.')
wvTxPowerSetting = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 29)).clone(10)).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTxPowerSetting.setStatus('current')
if mibBuilder.loadTexts: wvTxPowerSetting.setDescription('The transmit power value set for this terminal, in 1dBm steps.')
wvChannelNo = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvChannelNo.setStatus('current')
if mibBuilder.loadTexts: wvChannelNo.setDescription("The frequency channel to work on. Each channel corresponds to a given pair of transmit and receive frequencies, depending on the ODU's Standard (US/European), Spectrum Range Allocation (38 Ghz, 23 Ghz, 18 Ghz, etc...), Duplex Spacing (700 Mhz, 1200 Mhz, 1010 Mhz, etc...) and Frequency Band (1, 2, 3 or 4) (see wvOduPartNo below). The channel nos. spacing follow the h/w resolution, that is 0.25 Mhz. According to the FCC standard, each chosen frequency has a minimum spacing of 2.5 Mhz, therefore on FCC allocations the first and last allowed frequency centers are 1.25 Mhz from the start/end of the below specified bands, leaving 5 channels on start side and 4 on the end side not selectable (maybe more, depending on additional restrictions specific to each Duplex Spacing). According to the ETSI standard, each chosen frequency has a minimum spacing of 3.5 Mhz, therefore on ETSI allocations the first and last allowed frequency centers are 1.75 Mhz from the start/end of the below specified bands, leaving 7 channels on start side and 6 on the end side not selectable (maybe more, depending on additional restrictions specific to each Duplex Spacing). ******************************************************* *** For 38 Ghz, according to ITU-R F.749.1 standard *** ******************************************************* ### In the American (FCC) model ### === Duplex Spacing: 700 Mhz === The 38600-40000 Mhz frequency space is divided into 4 350 Mhz bands: 1. 38600-38950 2. 38950-39300 3. 39300-39650 4. 39650-40000 Since the h/w resolution is 0.25 Mhz, we have the 350 Mhz on each band sub-divided into 0 - 1399 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 38600.00 + (Band - 1) * 350 + wvChannelNo * 0.25 for Band = 1,2,3,4 Since the spacing between Tx and Rx is 700 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 700 Rx2 = Tx2 + 700 Rx3 = Tx3 - 700 Rx4 = Tx4 - 700 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 1400-first ### In the European (ETSI) model ### === Duplex Spacing: 1260 Mhz === The 37000-39500 Mhz frequency space is divided into 4 560 Mhz bands (after subtracting 260 MHz guard bands): 1. 37058-37618 2. 37618-38178 3. 38318-38878 4. 38878-39438 Since the h/w resolution is 0.25 Mhz, we have the 560 Mhz on each band sub-divided into 0 - 2239 channels (with 0 sitting on the START of each band). The corresponding Operating frequencies (center point) are calculated by: TxBand = 37058.00 + (Band - 1) * 630 + wvChannelNo * 0.25 for Band = 1,3 and TxBand = 37618.00 + (Band - 2) * 630 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 1260 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1260 Rx2 = Tx2 + 1260 Rx3 = Tx3 - 1260 Rx4 = Tx4 - 1260 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 2240-first. ******************************************************** *** For 23 Ghz, according to ITU-R 637.2 standard *** ******************************************************** ### In the American (FCC) model ### === Duplex Spacing: 1200 Mhz === The 21200-23600 Mhz frequency space is divided into 4 600 Mhz bands: 1. 21200-21800 2. 21800-22400 3. 22400-23000 4. 23000-23600 Since the h/w resolution is 0.25 Mhz, we have the 600 Mhz on each band sub-divided into 0 - 2399 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 21200.00 + (Band - 1) * 600 + wvChannelNo * 0.25 for Band = 1,2,3,4 Since the spacing between Tx and Rx is 1200 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1200 Rx2 = Tx2 + 1200 Rx3 = Tx3 - 1200 Rx4 = Tx4 - 1200 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 2400-first ### In the European (ETSI) model ### === Duplex Spacing: 1008 Mhz === On the 22000-23600 Mhz frequency space there are 2 592 Mhz bands (named bands 1 and 3 for compatibility), with a not used 'hole' of 400 Mhz in the middle, and additional guards on start and end of each band, depending on the channel spacing used (note that not all the 592 Mhz space is used): 1. 22000-22592 3. 23008-23600 Since the h/w resolution is 0.25 Mhz, we have the 592 Mhz on each band sub-divided into 0 - 2367 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 22000.00 + (Band - 1) * 504 + wvChannelNo * 0.25 for Band = 1,3 Since the spacing between Tx and Rx is 1008 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1008 Rx3 = Tx3 - 1008 The first/last allowed wvChannelNo depends on the used channel spacing and is given in the following table: wvChannelSpacing First Last ================ ===== ==== 3.5 Mhz 18 2356 7.0 Mhz 46 2342 14.0 Mhz 60 2300 28.0 Mhz 88 2216 56.0 Mhz 312 2104 === Duplex Spacing: 1200 Mhz === The 21200-23600 Mhz frequency space is divided into 4 600 Mhz bands: 1. 21200-21800 2. 21800-22400 3. 22400-23000 4. 23000-23600 Since the h/w resolution is 0.25 Mhz, we have the 600 Mhz on each band sub-divided into 0 - 2399 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 21200.00 + (Band - 1) * 600 + wvChannelNo * 0.25 for Band = 1,2,3,4 Since the spacing between Tx and Rx is 1200 Mhz, the the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1200 Rx2 = Tx2 + 1200 Rx3 = Tx3 - 1200 Rx4 = Tx4 - 1200 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 2400-first === Duplex Spacing: 1232 Mhz === The 21200-23600 Mhz frequency space is divided into 4 560 Mhz bands, with not used 'holes' of 24 Mhz in the beginning and end of the range and 112 Mhz in the middle: 1. 21224-21784 2. 21784-22344 3. 22456-23016 4. 23016-23576 Since the h/w resolution is 0.25 Mhz, we have the 560 Mhz on each band sub-divided into 0 - 2239 channels (with 0 sitting on the START of each band). The corresponding Operating frequencies (center point) are calculated by: TxBand = 21224.00 + (Band - 1) * 616 + wvChannelNo * 0.25 for Band = 1,3 and TxBand = 21784.00 + (Band - 2) * 616 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 1232 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1232 Rx2 = Tx2 + 1232 Rx3 = Tx3 - 1232 Rx4 = Tx4 - 1232 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 2240-first. ******************************************************** *** For 18 Ghz, according to ITU-R F.595-5 standard *** ******************************************************** ### In the American (FCC) model ### === Duplex Spacing: 1560 Mhz === On the 17700-19700 Mhz frequency space there are 2 440 Mhz bands (named bands 1 and 3 for compatibility), with a not used 'hole' of 1120 Mhz in the middle: 1. 17700-18140 3. 19260-19700 Since the h/w resolution is 0.25 Mhz, we have the 440 Mhz on each band sub-divided into 0 - 1759 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 17700.00 + (Band - 1) * 780 + wvChannelNo * 0.25 for Band = 1,3 Since the spacing between Tx and Rx is 1560 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1560 Rx3 = Tx3 - 1560 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 1760-first ### In the European (ETSI) model ### === Duplex Spacing: 1010 Mhz === The 17700-19700 Mhz frequency space is divided into 2 522.5 Mhz bands (Bands 1 and 3) and 2 467.5 Mhz bands (Bands 2 and 4) with a not used 'hole' of 20 Mhz in the middle, and additional guards (proportionally to the channel spacing used) on start of bands 1/3 and on end of bands 2/4: 1. 17700.0-18222.5 2. 18208.75-18690.0 3. 18710.0-19232.5 4. 19218.75-19700.0 Since the h/w resolution is 0.25 Mhz, we have the 522.5 Mhz on bands 1,3 sub-divided into 0 - 2090 channels and the 481.25 Mhz on bands 2,4 sub-divided into 0 - 1925 channels (with 0 sitting on the START of each band). The corresponding Operating frequencies (center point) are calculated by: TxBand = 17700.00 + (Band - 1) * 505 + wvChannelNo * 0.25 for Band = 1,3 and TxBand = 18208.75 + (Band - 2) * 505 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 1010 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1010 Rx2 = Tx2 + 1010 Rx3 = Tx3 - 1010 Rx4 = Tx4 - 1010 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*4 - wvChannelSpacing/14 for Bands 1,3 first = wvChannelSpacing*2 - wvChannelSpacing/28 for Bands 2,4 last = 2090 - first(2,4) for Bands 1,3 last = 1925 - first(1,3) for Bands 2,4 *********************************************************** *** For 26 Ghz, according to EN 300 431 v1.3.1 standard *** *********************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 1008 Mhz === The 24500-26500 Mhz frequency space is divided into 4 448 Mhz bands: 1. 24549-24997 2. 24997-25445 3. 25557-26005 4. 26005-26453 Since the h/w resolution is 0.25 Mhz, we have the 448 Mhz on each band sub-divided into 0 - 1791 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 24549.00 + (Band - 1) * 504 + wvChannelNo * 0.25 for Band = 1,3 TxBand = 24597.00 + (Band - 2) * 504 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 1008 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1008 Rx2 = Tx2 + 1008 Rx3 = Tx3 - 1008 Rx4 = Tx4 - 1008 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 1792-first ************************************************************** *** For 15 Ghz, according to CEPT/ERC/REC 12-07 E standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 728 Mhz === The 14500-15350 Mhz frequency space is divided into 2 112+7 Mhz bands: 1. 14508-14620 3. 15229-15348 Since the h/w resolution is 0.25 Mhz, we have the 119 Mhz on each band sub-divided into 0 - 475 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 14501.00 + (Band - 1) * 364 + wvChannelNo * 0.25 for Band = 1,3 Since the spacing between Tx and Rx is 728 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 728 Rx3 = Tx3 - 728 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: wvChannelSpacing First Last ================ ===== ==== 3.5 Mhz 7 441 7.0 Mhz 14 434 14.0 Mhz 56 448 28.0 Mhz 56 392 56.0 Mhz 112 336 ************************************************************** *** For 15 Ghz, according to ITU-R F.636-3 standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 420 Mhz === The 14500-15350 Mhz frequency space is divided into 2 224 Mhz bands (Bands 1 and 3) and 2 210 Mhz bands (Bands 2 and 4) : 1. 14501-14725 2. 14718-14928 3. 14921-15145 4. 15138-15348 Since the h/w resolution is 0.25 Mhz, we have the 224 Mhz on bands 1,3 sub-divided into 0 - 895 channels and the 210 Mhz on bands 2,4 sub-divided into 0 - 839 channels (with 0 sitting on the START of each band). The corresponding Operating frequencies (center point) are calculated by: TxBand = 14501 + (Band - 1) * 210 + wvChannelNo * 0.25 for Band = 1,3 and TxBand = 14718 + (Band - 2) * 210 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 420 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 420 Rx2 = Tx2 + 420 Rx3 = Tx3 - 420 Rx4 = Tx4 - 420 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: Band 1,3 Band 2,4 wvChannelSpacing First Last First Last ================ ===== ==== ===== ==== 3.5 Mhz 7 861 7 805 7.0 Mhz 14 854 14 798 14.0 Mhz 56 840 28 812 28.0 Mhz 56 840 84 756 56.0 Mhz 112 784 140 700 ************************************************************** *** For 15 Ghz, ??? *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 315 Mhz === The 14628-15228 Mhz frequency space is divided into 2 139 Mhz bands (Bands 1 and 3) and 2 151 Mhz bands (Bands 2 and 4) : 1. 14628-14767 2. 14760-14911 3. 14943-15082 4. 15075-15226 Since the h/w resolution is 0.25 Mhz, we have the 139 Mhz on bands 1,3 sub-divided into 0 - 555 channels and the 151 Mhz on bands 2,4 sub-divided into 0 - 603 channels (with 0 sitting on the START of each band). The corresponding Operating frequencies (center point) are calculated by: TxBand = 14628 + (Band - 1) * 157.5 + wvChannelNo * 0.25 for Band = 1,3 and TxBand = 14760 + (Band - 2) * 157.5 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 315 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 315 Rx2 = Tx2 + 315 Rx3 = Tx3 - 315 Rx4 = Tx4 - 315 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: Band 1,3 Band 2,4 wvChannelSpacing First Last First Last ================ ===== ==== ===== ==== 3.5 Mhz 10 528 14 588 7.0 Mhz 24 528 28 588 14.0 Mhz 80 472 56 560 28.0 Mhz 136 472 56 504 56.0 Mhz 192 416 112 448 ************************************************************** *** For 13 Ghz, according to CEPT/ERC/REC 12-02 E standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 266 Mhz === The 12750-13250 Mhz frequency space is divided into 4 112 Mhz bands: 1. 12751-12863 2. 12863-12975 3. 13017-13129 4. 13129-13241 Since the h/w resolution is 0.25 Mhz, we have the 112 Mhz on each band sub-divided into 0 - 447 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 12751.00 + (Band - 1) * 133 + wvChannelNo * 0.25 for Band = 1,3 TxBand = 12863.00 + (Band - 2) * 133 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 266 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 266 Rx2 = Tx2 + 266 Rx3 = Tx3 - 266 Rx4 = Tx4 - 266 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 448-first ************************************************************** *** For 8 Ghz, according to ITU-R F.386-6 standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 126 Mhz === The 8275-8500 Mhz frequency space is divided into 4 49 Mhz bands: 1. 8279-8328 2. 8321-8370 3. 8405-8454 4. 8447-8496 Since the h/w resolution is 0.25 Mhz, we have the 49 Mhz on each band sub-divided into 0 - 195 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 8279.00 + (Band - 1) * 63 + wvChannelNo * 0.25 for Band = 1,3 TxBand = 8321.00 + (Band - 2) * 63 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 126 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 126 Rx2 = Tx2 + 126 Rx3 = Tx3 - 126 Rx4 = Tx4 - 126 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 196-first Valid wvChannelSpacing are 3.5MHz,7MHz & 14MHz. ************************************************************** *** For 8 Ghz, according to ITU-R F.386-6 standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 119 Mhz === The 8275-8500 Mhz frequency space is divided into 4 56 Mhz bands: 1. 8279-8335 2. 8321-8377 3. 8398-8454 4. 8440-8496 Since the h/w resolution is 0.25 Mhz, we have the 56 Mhz on each band sub-divided into 0 - 223 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 8279.00 + (Band - 1) * 59.5 + wvChannelNo * 0.25 for Band = 1,3 TxBand = 8321.00 + (Band - 2) * 59.5 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 119 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 119 Rx2 = Tx2 + 119 Rx3 = Tx3 - 119 Rx4 = Tx4 - 119 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 224-first Valid wvChannelSpacing are 14MHz & 28MHz. ************************************************************** *** For 8 Ghz, according to ITU-R F.386-6 standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 311.32 Mhz === The 7725-8275 Mhz frequency space is divided into 4 127 Mhz bands: 1. 7725.00-7852.00 2. 7844.00-8971.00 3. 8036.25-8163.25 4. 8155.25-8282.25 The channel number set from the following table: ( The numbers are transmit center frequency in MHz ) Ch # Band 1 Band 2 Band 3 Band 4 0 7725.4625 7844.0625 8036.7825 8155.3825 15 7729.1687 7847.7687 8040.4887 8159.0887 30 7732.8750 7851.4750 8044.1950 8162.7950 45 7736.5812 7855.1812 8047.9012 8166.5012 60 7740.2875 7858.8875 8051.6075 8170.2075 75 7743.9937 7862.5937 8055.3137 8173.9137 90 7747.7000 7866.3000 8059.0200 8177.6200 105 7751.4062 7870.0062 8062.7262 8181.3262 120 7755.1125 7873.7125 8066.4325 8185.0325 135 7758.8187 7877.4187 8070.1387 8188.7387 150 7762.5250 7881.1250 8073.8450 8192.4450 165 7766.2312 7884.8312 8077.5512 8196.1512 180 7769.9375 7888.5375 8081.2575 8199.8575 195 7773.6437 7892.2437 8084.9637 8203.5637 210 7777.3500 7895.9500 8088.6700 8207.2700 225 7781.0562 7899.6562 8092.3762 8210.9762 240 7784.7625 7903.3625 8096.0825 8214.6825 255 7788.4687 7907.0687 8099.7887 8218.3887 270 7792.1750 7910.7750 8103.4950 8222.0950 285 7795.8812 7914.4812 8107.2012 8225.8012 300 7799.5875 7918.1875 8110.9075 8229.5075 315 7803.2937 7921.8937 8114.6137 8233.2137 330 7807.0000 7925.6000 8118.3200 8236.9200 345 7810.7062 7929.3062 8122.0262 8240.6262 360 7814.4125 7933.0125 8125.7325 8244.3325 375 7818.1187 7936.7187 8129.4387 8248.0387 390 7821.8250 7940.4250 8133.1450 8251.7450 405 7825.5312 7944.1312 8136.8512 8255.4512 420 7829.2375 7947.8375 8140.5575 8259.1575 435 7832.9437 7951.5437 8144.2637 8262.8637 450 7836.6500 7955.2500 8147.9700 8266.5700 465 7840.3562 7958.9562 8151.6762 8270.2762 480 7844.0625 7962.6625 8155.3825 8273.9825 495 7847.7687 7966.3687 8159.0887 8277.6887 Since the spacing between Tx and Rx is 311.32 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 311.32 Rx2 = Tx2 + 311.32 Rx3 = Tx3 - 311.32 Rx4 = Tx4 - 311.32 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = 15 for 7MHz, 30 for 14MHz , 60 for 28MHa last = 510 - first Valid wvChannelSpacing are 14MHz & 28MHz NOTES: 1. Valid channel numbers are n*15 n= 1,2,3...,32 2. When we display the transmit frequency the format is MMMM.KK and we trunk the least significant numbers. ************************************************************** *** For 7 Ghz, according to ITU-R F.385-6 standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 245 Mhz === The 7425-7900 Mhz frequency space is divided into 4 112 Mhz bands: 1. 7428-7540 2. 7540-7652 3. 7673-7785 4. 7785-7897 Since the h/w resolution is 0.25 Mhz, we have the 56 Mhz on each band sub-divided into 0 - 447 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 7428.00 + (Band - 1) * 122.5 + wvChannelNo * 0.25 for Band = 1,3 TxBand = 7540.00 + (Band - 2) * 122.5 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 245 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 245 Rx2 = Tx2 + 245 Rx3 = Tx3 - 245 Rx4 = Tx4 - 245 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 448-first ************************************************************** *** For 7 Ghz, according to ITU-R F.385-6 standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 154 Mhz === The 7125-7425 or 7425-7725 or 7250-7558 or 7550-7850 Mhz frequency space is divided into 2 84 Mhz bands (Bands 1 and 3) and 2 56 Mhz bands (Bands 2 and 4) : 1. 7128-7212 or 7428-7512 or 7253-7337 or 7553-7637 2. 7212-7268 or 7512-7568 or 7337-7393 or 7637-7693 3. 7282-7366 or 7582-7666 or 7407-7491 or 7707-7791 4. 7366-7422 or 7666-7722 or 7491-7547 or 7791-7847 Since the h/w resolution is 0.25 Mhz, we have the 84 Mhz on bands 1,3 sub-divided into 0 - 335 channels and the 56 Mhz on bands 2,4 sub-divided into 0 - 223 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = (7128.00 or 7428.00 or 7253 or 7553) + (Band - 1) * 77.0 + wvChannelNo * 0.25 for Band = 1,3 TxBand = (7212.00 or 7512.00 or 7337 or 7637) + (Band - 2) * 77.0 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 154 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 154 Rx2 = Tx2 + 154 Rx3 = Tx3 - 154 Rx4 = Tx4 - 154 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 336-first for bands 1,3 last = 224-first for bands 2,4 ************************************************************** *** For 7 Ghz, according to ITU-R F.385-6 standard *** ************************************************************** ### In the European (ETSI) model ### === Duplex Spacing: 161 Mhz === The 7124.5-7425.5 or 7424.5-7725.5 Mhz or 7249.5-7550.5 frequency space is divided into 2 84 Mhz bands (Bands 1 and 3) and 2 56 Mhz bands (Bands 2 and 4) : 1. 7124.5-7208.5 or 7424.5-7508.5 or 7249.5-7333.5 2. 7208.5-7264.5 or 7508.5-7564.5 or 7333.5-7389.5 3. 7285.5-7369.5 or 7585.5-7669.5 or 7410.5-7494.5 4. 7369.5-7425.5 or 7669.5-7725.5 or 7494.5-7550.5 Since the h/w resolution is 0.25 Mhz, we have the 84 Mhz on bands 1,3 sub-divided into 0 - 335 channels and the 56 Mhz on bands 2,4 sub-divided into 0 - 223 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = (7124.50 or 7424.50 or 7249.50) + (Band - 1) * 80.5 + wvChannelNo * 0.25 for Band = 1,3 TxBand = (7208.50 or 7508.50 or 7333.50) + (Band - 2) * 80.5 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 161 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 161 Rx2 = Tx2 + 161 Rx3 = Tx3 - 161 Rx4 = Tx4 - 161 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 336-first for bands 1,3 last = 224-first for bands 2,4 ### In the European (ETSI) model 15GHz Australia ITU-R F.636-3### === Duplex Spacing: 644 Mhz === On the 14500-15350 Mhz frequency space there are 2 196 Mhz bands (named bands 1 and 3 for compatibility), with a not used 'hole' of 448 Mhz in the middle, and additional guards on start and end of each band, depending on the channel spacing used : 1. 14501-14697 3. 15145-15341 Since the h/w resolution is 0.25 Mhz, we have the 196 Mhz on each band sub-divided into 0 - 783 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 14501.00 + (Band - 1) * 98 + wvChannelNo * 0.25 for Band = 1,3 Since the spacing between Tx and Rx is 644 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 644 Rx3 = Tx3 - 644 The first/last allowed wvChannelNo depends on the used channel spacing and is given in the following table: first = wvChannelSpacing*10/5 last = 784-first ### In the European (ETSI) model 15GHz Australia ### === Duplex Spacing: 490 Mhz === On the 14403-15348 Mhz frequency space there are 4 224 Mhz bands (named bands 1 to 4 for compatibility): 1. 14403-14627 2. 14627-14821 3. 14893-15117 4. 15117-15341 Since the h/w resolution is 0.25 Mhz, we have the 224 Mhz on each band sub-divided into 0 - 895 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 14403.00 + (Band - 1) * 112 + wvChannelNo * 0.25 for Band = 1,3 and TxBand = 14627.00 + (Band - 2) * 112 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 490 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 490 Rx2 = Tx2 + 490 Rx3 = Tx3 - 490 Rx4 = Tx4 - 490 The first/last allowed wvChannelNo depends on the used channel spacing and is given in the following table: first = wvChannelSpacing*10/5 last = 896-first ### In the European (ETSI) model 15GHz Australia ### === Duplex Spacing: 322 Mhz === The 14634-15229 Mhz frequency space is divided into 2 126 Mhz bands (Bands 1 and 3) and 2 140 Mhz bands (Bands 2 and 4) : 1. 14634-14760 2. 14767-14907 3. 14956-15082 4. 15089-15229 Since the h/w resolution is 0.25 Mhz, we have the 126 Mhz on bands 1,3 sub-divided into 0 - 504 channels and the 140 Mhz on bands 2,4 sub-divided into 0 - 560 channels (with 0 sitting on the START of each band). The corresponding Operating frequencies (center point) are calculated by: TxBand = 14634 + (Band - 1) * 63 + wvChannelNo * 0.25 for Band = 1,3 and TxBand = 14760 + (Band - 2) * 70 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 322 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 322 Rx2 = Tx2 + 322 Rx3 = Tx3 - 322 Rx4 = Tx4 - 322 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 504-first (for band 1,3) last = 560-first (for band 2,4) ### In the European (ETSI) model 10GHz Australia ITU-R F.747### === Duplex Spacing: 65 Mhz === On the 10550-10680 Mhz frequency space is divided into 2 35 Mhz bands (Bands 1 and 3) and 2 30 Mhz bands (Bands 2 and 4) :: 1. 10550-10585 2. 10582.5-10615 3. 10615-10650 4. 10647.5-10680 Since the h/w resolution is 0.25 Mhz, we have the 35 Mhz on bands 1,3 sub-divided into 0 - 139 channels and the 32.5 Mhz on bands 2,4 sub-divided into 0 - 129 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 10550 + (Band - 1) * 32.5 + wvChannelNo * 0.25 for Band = 1,3 TxBand = 10582.5 + (Band - 2) * 32.5 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 65 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 65 Rx2 = Tx2 + 65 Rx3 = Tx3 - 65 Rx4 = Tx4 - 65 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 140-first for bands 1,3 last = 130-first for bands 2,4 ### In the European (ETSI) model 10GHz Australia ITU-R F.747### === Duplex Spacing: 91 Mhz === On the 10500-10680 Mhz frequency space is divided into 4 42 Mhz bands: 1. 10500.5-10542.5 2. 10542.5-10584.5 3. 10591.5-10633.5 4. 10633.5-10675.5 Since the h/w resolution is 0.25 Mhz, we have the 42 Mhz on each band sub-divided into 0 - 167 channels (with 0 sitting on the START of each band). The corresponding Operating Frequencies (center point) are calculated by: TxBand = 10500.5 + (Band - 1) * 45.5 + wvChannelNo * 0.25 for Band = 1,3 TxBand = 10542.5 + (Band - 2) * 45.5 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 119 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 91 Rx2 = Tx2 + 91 Rx3 = Tx3 - 91 Rx4 = Tx4 - 91 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*10/5 last = 168-first ### In the European (ETSI) model 18GHz ### === Duplex Spacing: 1008 Mhz === The 17720.5-19680.5 Mhz frequency space is divided into 2 500.5 Mhz bands (Bands 1 and 3) and 2 451.5 Mhz bands (Bands 2 and 4) with a not used 'hole' of 56 Mhz in the middle. 1. 17702.5-18221.0 2. 18221.0-18672.5 3. 18728.5-19229.0 4. 19229.0-19700.5 Since the h/w resolution is 0.25 Mhz, we have the 500.5 Mhz on bands 1,3 sub-divided into 0 - 2002 channels and the 451.5 Mhz on bands 2,4 sub-divided into 0 - 1806 channels (with 0 sitting on the START of each band). The corresponding Operating frequencies (center point) are calculated by: TxBand = 17702.5 + (Band - 1) * 500.5 + wvChannelNo * 0.25 for Band = 1,3 and TxBand = 18221.0 + (Band - 2) * 451.5 + wvChannelNo * 0.25 for Band = 2,4 Since the spacing between Tx and Rx is 1010 Mhz, the Rx frequency is deduced from the Tx frequency as follows: Rx1 = Tx1 + 1008 Rx2 = Tx2 + 1008 Rx3 = Tx3 - 1008 Rx4 = Tx4 - 1008 The first/last allowed wvChannelNo depends on the used channel spacing and is calculated as follows: first = wvChannelSpacing*4 - wvChannelSpacing/14 for Bands 1,3 first = wvChannelSpacing*2 - wvChannelSpacing/28 for Bands 2,4 last = 2002 - first(2,4) for Bands 1,3 last = 1806 - first(1,3) for Bands 2,4 wvChannelNo's default is the first allowed Channel No, according to the chosen channel spacing.")
wvLinkCapacity = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("oneE1", 1), ("twoE1", 2), ("fourE1", 3), ("eightE1", 4), ("sixteenE1", 5), ("e3", 6), ("e3PlusOneE1", 7), ("e3PlusTwoE1", 8), ("oneT1", 9), ("twoT1", 10), ("fourT1", 11), ("eightT1", 12), ("sixteenT1", 13), ("t3", 14), ("t3PlusTwoT1", 15), ("t3PlusFourT1", 16), ("sts1", 17), ("eth10-100Only", 18), ("eth10-100PlusOneE1", 19), ("eth10-100PlusTwoE1", 20), ("eth10-100PlusFourE1", 21), ("eth10-100PlusOneT1", 22), ("eth10-100PlusTwoT1", 23), ("eth10-100PlusFourT1", 24)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkCapacity.setStatus('current')
if mibBuilder.loadTexts: wvLinkCapacity.setDescription('Terminal Link chosen bit rate. Enables reduced capacity work for a given installed plug-in (according to wvInstalledPlugInPartNo). All subsets of a given plug-in are allowed. Its default is the installed plug-in full capacity.')
wvTransmitterMute = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTransmitterMute.setStatus('current')
if mibBuilder.loadTexts: wvTransmitterMute.setDescription("When 'on', disables this terminal's transmission to the link. Note that disabling transmission sets off an alarm.")
wvReceiverMute = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvReceiverMute.setStatus('current')
if mibBuilder.loadTexts: wvReceiverMute.setDescription("When 'on', disables this terminal's reception from the link. Since disabling reception is regarded as a kind of alarm, setting of this variable causes a trap.")
wvModulation = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("cp4fsk", 2), ("qam4", 3), ("qam8", 4), ("qam16", 5), ("qam32", 6), ("qam64", 7), ("qam128", 8))).clone('cp4fsk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvModulation.setStatus('current')
if mibBuilder.loadTexts: wvModulation.setDescription('Sets the terminal radio modulation. Not all values apply to all models.')
wvForceAis = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("never", 1), ("onBerWarning", 2), ("onBerError", 3), ("always", 4))).clone('never')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvForceAis.setStatus('current')
if mibBuilder.loadTexts: wvForceAis.setDescription("Defines whether to force Alarm Indication Signal (all 1's) on the link upon either occurence of a link BER Warning or BER Error alarm or unconditionally.")
wvFecEnabled = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvFecEnabled.setStatus('deprecated')
if mibBuilder.loadTexts: wvFecEnabled.setDescription('Enables/disables the Forward Error Correction option.')
wvFecReceiveCorrection = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvFecReceiveCorrection.setStatus('current')
if mibBuilder.loadTexts: wvFecReceiveCorrection.setDescription('Enables/disables Automatic Error Correction on receive.')
wvFecNoOfCorrectableBytes = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvFecNoOfCorrectableBytes.setStatus('current')
if mibBuilder.loadTexts: wvFecNoOfCorrectableBytes.setDescription('Specifies the Forward Error Correction level on transmit. - for LAN plug-in the values are 10 or 20. - for PDH plug-in the values are read only. ')
wvEth10_100ChannelSpacing = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("twoAndAHalf", 1), ("five", 2), ("sevenAndAHalf", 3), ("twelveAndAHalf", 4), ("twentyFive", 5), ("fifty", 6), ("threeAndAHalf", 7), ("seven", 8), ("fourteen", 9), ("twentyEight", 10), ("fiftySix", 11)))).setLabel("wvEth10-100ChannelSpacing").setUnits('MHz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100ChannelSpacing.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100ChannelSpacing.setDescription("Specifies the allowed frequency spacing between adjacent channels for the ETH 10/100 plug-in, as a function of the ODU standard (American vs. European) and chosen wvLinkCapacity. The user may specify a given spacing only if the chosen wvLinkCapacity is one of the specified on its right. Note that on the 18 Ghz Spectrum Range the actual values may be different than on the other ranges, and those are specifically mentioned where applicable. When working with ETH 10/100 plug-in, wvChannelSpacing reflects this object's value.")
wvAtpcControl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAtpcControl.setStatus('current')
if mibBuilder.loadTexts: wvAtpcControl.setDescription('Enables/disables the ATPC feature.')
wvAtpcRslOptimalValue = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-90, -15))).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAtpcRslOptimalValue.setStatus('current')
if mibBuilder.loadTexts: wvAtpcRslOptimalValue.setDescription('Defines the targeted working RSL value, for ATPC.')
wvAtpcRslUpperThreshold = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-90, -15))).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAtpcRslUpperThreshold.setStatus('current')
if mibBuilder.loadTexts: wvAtpcRslUpperThreshold.setDescription('Defines the upper threshold for which, if the RSL value is greater than it for more than 10 seconds, the ATPC mechanism (if enabled) will decrease the remote TX power to get the RSL to wvAtpcRslOptimalValue.')
wvAtpcRslLowerThreshold = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-90, -15))).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAtpcRslLowerThreshold.setStatus('current')
if mibBuilder.loadTexts: wvAtpcRslLowerThreshold.setDescription('Defines the lower threshold for which, if the RSL value is less than it for more than 10 seconds, the ATPC mechanism (if enabled) will increase the remote TX power to get the RSL to wvAtpcRslOptimalValue.')
wvPauseTransmitterControl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvPauseTransmitterControl.setStatus('current')
if mibBuilder.loadTexts: wvPauseTransmitterControl.setDescription('Enables/disables the Pause Transmitter feature.')
wvPauseTransmitterTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 36000))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvPauseTransmitterTime.setStatus('current')
if mibBuilder.loadTexts: wvPauseTransmitterTime.setDescription('Defines the time in seconds to hold the pause for the transmitter in mute state.')
wvE1BNC75ohm = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvE1BNC75ohm.setStatus('current')
if mibBuilder.loadTexts: wvE1BNC75ohm.setDescription('set E1 port to 75ohm.')
wvAtpcTimeOutControl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAtpcTimeOutControl.setStatus('current')
if mibBuilder.loadTexts: wvAtpcTimeOutControl.setDescription('Enables/disables the ATPC TimeOut feature.')
wvAtpcTimeOutTimer = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(5)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAtpcTimeOutTimer.setStatus('current')
if mibBuilder.loadTexts: wvAtpcTimeOutTimer.setDescription('Atpc TimeOut timer feature.')
wvAtpcTimeOutAlarm = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAtpcTimeOutAlarm.setStatus('current')
if mibBuilder.loadTexts: wvAtpcTimeOutAlarm.setDescription('Enables/disables the ATPC TimeOut alarm.')
wvAtpcTimeOutAlarmLevel = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("message", 1), ("error", 2), ("fatal", 3))).clone('fatal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAtpcTimeOutAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: wvAtpcTimeOutAlarmLevel.setDescription('declare the ATPC TimeOut alarm level.')
wvDisableAtpcInTimeOutAlarm = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvDisableAtpcInTimeOutAlarm.setStatus('current')
if mibBuilder.loadTexts: wvDisableAtpcInTimeOutAlarm.setDescription('Disable the ATPC if TimeOut alarm in active.')
wvEnableSpaceDiversity = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEnableSpaceDiversity.setStatus('current')
if mibBuilder.loadTexts: wvEnableSpaceDiversity.setDescription('Enable the Space Diversity feature in 1+1 mode.')
wvTributaryPortConnectionsMode = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("autoSensing", 2))).clone('manual')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTributaryPortConnectionsMode.setStatus('current')
if mibBuilder.loadTexts: wvTributaryPortConnectionsMode.setDescription('Defines the data ports connections mode. In Auto Sensing mode the system automatically detects which ports are connected. In Manual mode user choices are reflected through the interfaces wvTributaryPortConnection settings (see below).')
wvTributaryPortTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 2), )
if mibBuilder.loadTexts: wvTributaryPortTable.setStatus('current')
if mibBuilder.loadTexts: wvTributaryPortTable.setDescription('A table for private extensions to standard interface MIBs (like dsx1/dsx3).')
wvTributaryPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 2, 1), ).setIndexNames((0, "CODAN-MIB", "wvTributaryPortIfIndex"))
if mibBuilder.loadTexts: wvTributaryPortEntry.setStatus('current')
if mibBuilder.loadTexts: wvTributaryPortEntry.setDescription('Entry in the wvTributaryPortTable.')
wvTributaryPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvTributaryPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: wvTributaryPortIfIndex.setDescription('The value of this object is equal to the value of ifIndex for the corresponding interface on the Interfaces table of MIB-II. Note that the possible wvTributaryPortIfIndex values depend on the available interfaces, according to wvInstalledPlugInPartNo.')
wvTributaryPortConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTributaryPortConnection.setStatus('current')
if mibBuilder.loadTexts: wvTributaryPortConnection.setDescription('Determines if this port is connected or not. Note that the maximum number of connected ports is a subset of the available data ports (according to wvInstalledPlugInPartNo), and can not exceed the chosen wvLinkCapacity. The default connections are the first ones available. Applicable only when wvTributaryPortConnectionsMode is set to manual.')
wvTributaryPortInvertedAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTributaryPortInvertedAlarm.setStatus('current')
if mibBuilder.loadTexts: wvTributaryPortInvertedAlarm.setDescription("Determines if this line has inverted alarm enabled. A line with inverted alarm enabled will report an alarm if either 'no LOS' or 'AIS' is detected (meaning that the line is alive). This condition is indicated as Unexpected Signal Detection alarm. The default is disabled (not inverted).")
wvTributaryPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTributaryPortName.setStatus('current')
if mibBuilder.loadTexts: wvTributaryPortName.setDescription('Specifies the prefix string for Tributary Port.')
wvDsx3CableLengthRange = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("upTo225Feet", 1), ("moreThan225Feet", 2))).clone('upTo225Feet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvDsx3CableLengthRange.setStatus('current')
if mibBuilder.loadTexts: wvDsx3CableLengthRange.setDescription('Defines the cable length range of the DS3/E3 line, for proper interface support.')
wvSlipConnection = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("modem", 2))).clone('direct')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipConnection.setStatus('current')
if mibBuilder.loadTexts: wvSlipConnection.setDescription("Defines the type of SLIP connection to the IDU. ??? Couldn't this be self detectable ???")
wvTelephoneNumber = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTelephoneNumber.setStatus('current')
if mibBuilder.loadTexts: wvTelephoneNumber.setDescription('Specifies the telephone number for dial-back purposes (e.g., for TFTP connection).')
wvDialPrefixString = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone('ATDT')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvDialPrefixString.setStatus('current')
if mibBuilder.loadTexts: wvDialPrefixString.setDescription('Specifies the prefix string for modem dial up .')
wvInitString = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('ATZ')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvInitString.setStatus('current')
if mibBuilder.loadTexts: wvInitString.setDescription('Specifies the string to be sent to the modem for initialization .')
wvEth10_100SysCtrl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 20), Bits().clone(namedValues=NamedValues(("aging", 0), ("crcCheck", 1), ("flowCtrl", 2)))).setLabel("wvEth10-100SysCtrl").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100SysCtrl.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100SysCtrl.setDescription('Specifies General ETH 10/100 Board controls.')
wvEth10_100SysAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 524280)).clone(80)).setLabel("wvEth10-100SysAgingTime").setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100SysAgingTime.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100SysAgingTime.setDescription('Specifies ETH 10/100 Board Aging Time. Given value will be rounded down to highest multiple of 8.')
wvEth10_100PortTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 22), ).setLabel("wvEth10-100PortTable")
if mibBuilder.loadTexts: wvEth10_100PortTable.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100PortTable.setDescription('A table for ETH 10/100 ports.')
wvEth10_100PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 22, 1), ).setLabel("wvEth10-100PortEntry").setIndexNames((0, "CODAN-MIB", "wvEth10-100PortIfIndex"))
if mibBuilder.loadTexts: wvEth10_100PortEntry.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100PortEntry.setDescription('Entry in the wvEth10-100PortTable.')
wvEth10_100PortIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 22, 1, 1), Integer32()).setLabel("wvEth10-100PortIfIndex").setMaxAccess("readonly")
if mibBuilder.loadTexts: wvEth10_100PortIfIndex.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100PortIfIndex.setDescription('The value of this object is equal to the value of ifIndex for the corresponding interface on the Interfaces table of MIB-II. Note that the possible wvEth10-100PortIfIndex values depend on the available interfaces, according to wvInstalledPlugInPartNo.')
wvEth10_100PortCtrl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 22, 1, 2), Bits().clone(namedValues=NamedValues(("fastSpeed", 0), ("fullDuplex", 1), ("autoNegotiation", 2), ("forceDisconnectOnLinkDown", 3)))).setLabel("wvEth10-100PortCtrl").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100PortCtrl.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100PortCtrl.setDescription('Specifies specific ETH 10/100 Port controls.')
wvEth10_100PortStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 22, 1, 3), Bits().clone(namedValues=NamedValues(("fastSpeedOn", 0), ("fullDuplexOn", 1), ("cslAlarm", 2), ("ecAlarm", 3), ("imteAlarm", 4), ("imreAlarm", 5)))).setLabel("wvEth10-100PortStatus").setMaxAccess("readonly")
if mibBuilder.loadTexts: wvEth10_100PortStatus.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100PortStatus.setDescription('Keeps the specific ETH 10/100 Port status.')
wvEth10_100PortClearStats = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 22, 1, 4), Integer32()).setLabel("wvEth10-100PortClearStats").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100PortClearStats.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100PortClearStats.setDescription("Setting of this object clears the specific ETH 10/100 port statistics. The value given with the object is not relevant and it's not checked.")
wvEth10_100PortThroughputCtrl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 22, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unlimited", 1), ("limit128K", 2), ("limit256K", 3), ("limit512K", 4), ("limit1M", 5), ("limit2M", 6), ("limit4M", 7), ("limit8M", 8))).clone('unlimited')).setLabel("wvEth10-100PortThroughputCtrl").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100PortThroughputCtrl.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100PortThroughputCtrl.setDescription('Specifies specific ETH 10/100 Port Throughput controls.')
wvEth10_100AvailCapacity = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 23), Integer32()).setLabel("wvEth10-100AvailCapacity").setUnits('Bits/sec').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvEth10_100AvailCapacity.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100AvailCapacity.setDescription('Shows the link capacity available for the ETH 10/100, after deducting the capacity used by the DS1s from the total available spectrum.')
wvRs232PortTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30), )
if mibBuilder.loadTexts: wvRs232PortTable.setStatus('current')
if mibBuilder.loadTexts: wvRs232PortTable.setDescription('A list of port entries. The number of entries is given by the value of rs232Number.')
wvRs232PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30, 1), ).setIndexNames((0, "CODAN-MIB", "wvRs232PortIndex"))
if mibBuilder.loadTexts: wvRs232PortEntry.setStatus('current')
if mibBuilder.loadTexts: wvRs232PortEntry.setDescription('Status and parameter values for a port.')
wvRs232PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvRs232PortIndex.setStatus('current')
if mibBuilder.loadTexts: wvRs232PortIndex.setDescription('Same as original rs232PortIndex: The value of ifIndex for the port. By convention and if possible, hardware port numbers map directly to external connectors. The value for each port must remain constant at least from one re-initialization of the network management agent to the next.')
wvRs232PortType = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("rs232", 2), ("rs422", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRs232PortType.setStatus('current')
if mibBuilder.loadTexts: wvRs232PortType.setDescription("The port's hardware type. Same as original rs232PortType, but read-write and with restricted values.")
wvRs232PortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRs232PortSpeed.setStatus('current')
if mibBuilder.loadTexts: wvRs232PortSpeed.setDescription("The port's input/output speed in bits per second. Note that non-standard values, such as 9612, are probably not allowed on most implementations. Same as original rs232PortInSpeed and rs232PortOutSpeed.")
wvRs232PortFlowType = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("xonXoff", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRs232PortFlowType.setStatus('current')
if mibBuilder.loadTexts: wvRs232PortFlowType.setDescription("The port's type of input flow control. 'none' indicates no flow control at this level. Same as original rs232PortInFlowType and rs232PortOutFlowType, but with different values.")
wvRs232AsyncPortBits = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRs232AsyncPortBits.setStatus('current')
if mibBuilder.loadTexts: wvRs232AsyncPortBits.setDescription("The port's number of bits in a character. Same as original rs232AsyncPortBits, but with restricted values.")
wvRs232AsyncPortStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRs232AsyncPortStopBits.setStatus('current')
if mibBuilder.loadTexts: wvRs232AsyncPortStopBits.setDescription("The port's number of stop bits. Same as original rs232AsyncPortStopBits, but with restricted values.")
wvRs232AsyncPortParity = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 2, 30, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRs232AsyncPortParity.setStatus('current')
if mibBuilder.loadTexts: wvRs232AsyncPortParity.setDescription("The port's sense of a character parity bit. Same as original rs232AsyncPortParity, but with restricted values.")
wvUpdateTerminalConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvUpdateTerminalConfiguration.setStatus('current')
if mibBuilder.loadTexts: wvUpdateTerminalConfiguration.setDescription("Initializes a configuration update process from the manager to either the Active or one of the Saved Configurations on the terminal. The actual updated configuration is specified through the community in the request, as explained below on the wvCommunityTable Description. If the Update is to one of the Saved Configurations then it is saved on non-volatile memory. If the Update is to the Active Configuration then the changed parameters are activated. The value given with the object is not relevant and it's not checked.")
wvActivateTerminalConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvActivateTerminalConfiguration.setStatus('current')
if mibBuilder.loadTexts: wvActivateTerminalConfiguration.setDescription("Initializes a configuration transfer process on the terminal from one of the Saved Configurations to the Active Configuration, according to wvActivateTerminalConfigurationTime (see below). The actual activated configuration is specified through the community in the request, as explained below on the wvCommunityTable Description. The value given with the object is not relevant and it's not checked.")
wvResetTerminal = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("cold", 1), ("warm", 2), ("coldSwitchOver", 3), ("terminalSwitchOver", 4), ("running", 5), ("oduSwitchOver", 6))).clone('warm')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvResetTerminal.setStatus('current')
if mibBuilder.loadTexts: wvResetTerminal.setDescription("Activates a cold/warm reset at the terminal. A cold reset is performed at both the IDU and the ODU and stops all communications with the device. A warm reset affects only IDU NMS operation and doesn't interrupt data communications. A cold switch-over reset, in addition to performing a cold reset, causes the IDU to restart with the stand-by software (see wvSwModuleTable) becoming the active one, and the active software becoming the stand-by one.")
wvActivateTerminalConfigurationTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 5), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvActivateTerminalConfigurationTime.setStatus('current')
if mibBuilder.loadTexts: wvActivateTerminalConfigurationTime.setDescription('Defines the time, relative to sysUpTime, when the wvActivateTerminalConfiguration request should be performed. If when set this value is 0 then the the activation is performed immediately.')
wvSavedActiveConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("savedConfiguration1", 1), ("savedConfiguration2", 2), ("savedConfiguration3", 3), ("factoryDefault", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSavedActiveConfiguration.setStatus('deprecated')
if mibBuilder.loadTexts: wvSavedActiveConfiguration.setDescription("Specifies which of the Saved Configurations currently reflects the Active Configuration. It is set to 'none' following a successful wvUpdateTerminalConfiguration to the Active Configuration. It is set to any of the other values following a successful wvActivateTerminalConfiguration request, according to the specified configuration.")
wvOnePlusOneRequestSwitchOut = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvOnePlusOneRequestSwitchOut.setStatus('current')
if mibBuilder.loadTexts: wvOnePlusOneRequestSwitchOut.setDescription("For 1+1 systems only: Simulates a 'Switch-Out' request on the current unit. If not a 1+1 system, the request is rejected. The value given with the object is not relevant and it's not checked.")
wvFrontPanelUserPassword = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 10), FrontPanelPassword().clone(hexValue="0101010101")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvFrontPanelUserPassword.setStatus('current')
if mibBuilder.loadTexts: wvFrontPanelUserPassword.setDescription('Specifies the Password for User privilege Front Panel access.')
wvFrontPanelAdminPassword = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 11), FrontPanelPassword().clone(hexValue="0101020202")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvFrontPanelAdminPassword.setStatus('current')
if mibBuilder.loadTexts: wvFrontPanelAdminPassword.setDescription('Specifies the Password for Admin privilege Front Panel access.')
wvFrontPanelSupervisorPassword = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 12), FrontPanelPassword().clone(hexValue="0101030304")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvFrontPanelSupervisorPassword.setStatus('current')
if mibBuilder.loadTexts: wvFrontPanelSupervisorPassword.setDescription('Specifies the Password for Supervisor privilege Front Panel access.')
wvResetOdu = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cold", 1), ("coldSwitchOver", 2), ("running", 3))).clone('cold')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvResetOdu.setStatus('current')
if mibBuilder.loadTexts: wvResetOdu.setDescription('Activates an ODU only cold reset. This will cause the link to be restarted. A cold switch-over reset, in addition to performing a cold reset, causes the ODU to restart with the stand-by software (see wvSwModuleTable) becoming the active one, and the active software becoming the stand-by one.')
wvSlipInIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipInIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvSlipInIPAddress.setDescription("The terminals' Slip-In IP address.")
wvSlipInIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipInIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvSlipInIPSubnetMask.setDescription('The subnet mask associated with wvSlipInIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvSlipOutIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 22), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipOutIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvSlipOutIPAddress.setDescription("The terminals' Slip-Out IP address.")
wvSlipOutIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipOutIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvSlipOutIPSubnetMask.setDescription('The subnet mask associated with wvSlipOutIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvLanIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 24), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLanIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvLanIPAddress.setDescription("The terminals' LAN IP address.")
wvLanIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 25), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLanIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvLanIPSubnetMask.setDescription('The subnet mask associated with wvLanIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvLinkIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 26), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvLinkIPAddress.setDescription("The terminals' link IP address.")
wvLinkIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 27), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvLinkIPSubnetMask.setDescription('The subnet mask associated with wvLinkIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvEth10_100ManIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 28), IpAddress()).setLabel("wvEth10-100ManIPAddress").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100ManIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100ManIPAddress.setDescription("The terminals' ETH 10/100 IP address.")
wvEth10_100ManIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 29), IpAddress()).setLabel("wvEth10-100ManIPSubnetMask").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100ManIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100ManIPSubnetMask.setDescription('The subnet mask associated with wvEth10-100ManIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvPeerSlipInIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 30), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerSlipInIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvPeerSlipInIPAddress.setDescription("The peer terminals' Slip-In IP address.")
wvPeerSlipInIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 31), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerSlipInIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvPeerSlipInIPSubnetMask.setDescription('The subnet mask associated with wvPeerSlipInIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvPeerSlipOutIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 32), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerSlipOutIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvPeerSlipOutIPAddress.setDescription("The peer terminals' Slip-Out IP address.")
wvPeerSlipOutIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 33), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerSlipOutIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvPeerSlipOutIPSubnetMask.setDescription('The subnet mask associated with wvPeerSlipOutIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvPeerLanIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 34), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerLanIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvPeerLanIPAddress.setDescription("The peer terminals' LAN IP address.")
wvPeerLanIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 35), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerLanIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvPeerLanIPSubnetMask.setDescription('The subnet mask associated with wvPeerLanIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvPeerLinkIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 36), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerLinkIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvPeerLinkIPAddress.setDescription("The peer terminals' link IP address.")
wvPeerLinkIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 37), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerLinkIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvPeerLinkIPSubnetMask.setDescription('The subnet mask associated with wvPeerLinkIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvPeerEth10_100ManIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 38), IpAddress()).setLabel("wvPeerEth10-100ManIPAddress").setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerEth10_100ManIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvPeerEth10_100ManIPAddress.setDescription("The peer terminals' ETH 10/100 IP address.")
wvPeerEth10_100ManIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 39), IpAddress()).setLabel("wvPeerEth10-100ManIPSubnetMask").setMaxAccess("readonly")
if mibBuilder.loadTexts: wvPeerEth10_100ManIPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: wvPeerEth10_100ManIPSubnetMask.setDescription('The subnet mask associated with wvPeerEth10-100ManIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvSlipInDestIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 40), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipInDestIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvSlipInDestIPAddress.setDescription('The IP address of the destination connected to the Slip-In port.')
wvSlipInDestIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 41), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipInDestIPSubnetMask.setStatus('deprecated')
if mibBuilder.loadTexts: wvSlipInDestIPSubnetMask.setDescription('The subnet mask associated with wvSlipInDestIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvSlipOutDestIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 42), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipOutDestIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvSlipOutDestIPAddress.setDescription('The IP address of the destination connected to the Slip-Out port.')
wvSlipOutDestIPSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 43), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSlipOutDestIPSubnetMask.setStatus('deprecated')
if mibBuilder.loadTexts: wvSlipOutDestIPSubnetMask.setDescription('The subnet mask associated with wvSlipOutDestIPAddress. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wvOnePlusOneCompanionLinkIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 44), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOnePlusOneCompanionLinkIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvOnePlusOneCompanionLinkIPAddress.setDescription("The companion terminals' link IP address. VAlid only if system is a '1+1', according to wvOnePlusOneStatus.")
wvOnePlusOneCompanionEthIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 45), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvOnePlusOneCompanionEthIPAddress.setStatus('current')
if mibBuilder.loadTexts: wvOnePlusOneCompanionEthIPAddress.setDescription("The Companion Eth(LAN)IP address in '1+1' system.")
wvUserRoutesManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50))
wvUserRoutesTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 1), )
if mibBuilder.loadTexts: wvUserRoutesTable.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesTable.setDescription('A table of the user defined static routes.')
wvUserRoutesCount = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvUserRoutesCount.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesCount.setDescription('The number of entries in User Routes Table.')
wvUserRoutesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 1, 1), ).setIndexNames((0, "CODAN-MIB", "wvUserRoutesIndex"))
if mibBuilder.loadTexts: wvUserRoutesEntry.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesEntry.setDescription('Entry in the wvUserRoutesTable. The table has a variable size, limited to the range specified by wvUserRoutesIndex below. Deletion of a row is achieved by setting wvUserRoutesType to value. Creation of a new route is achieved by setting any of the read-write fields with a index = Current-Last-Index + 1. ')
wvUserRoutesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvUserRoutesIndex.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesIndex.setDescription('The entry index.')
wvUserRoutesDest = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvUserRoutesDest.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesDest.setDescription('The route destination.')
wvUserRoutesHop = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvUserRoutesHop.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesHop.setDescription('The route hop.')
wvUserRoutesMask = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvUserRoutesMask.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesMask.setDescription('The route mask.')
wvUserRoutesIf = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("eth", 1), ("eth10-100", 2), ("link", 3), ("nms-in", 4), ("nms-out", 5), ("sys-choice", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvUserRoutesIf.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesIf.setDescription(' Set requested interface for the route .')
wvUserRoutesType = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 50, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvUserRoutesType.setStatus('current')
if mibBuilder.loadTexts: wvUserRoutesType.setDescription(' Set for route deleting .')
wvSetOperationId = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 100), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSetOperationId.setStatus('current')
if mibBuilder.loadTexts: wvSetOperationId.setDescription('This object identifies the current successful invocation of the set operation.')
wvSetOperationCtrl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 101), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("setEnabled", 1), ("setDisabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSetOperationCtrl.setStatus('current')
if mibBuilder.loadTexts: wvSetOperationCtrl.setDescription("This object synchronizes between several cooperating manager stations, to coordinate their use of the set operation. If it is set to 'setDisabled' no SNMP set operations are performed by the agent.")
wvSetOperationOwner = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 102), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSetOperationOwner.setStatus('current')
if mibBuilder.loadTexts: wvSetOperationOwner.setDescription("The entity which currently has the 'ownership' required to perform set operations.")
wvConfigurationChangedStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 103), Bits().clone(namedValues=NamedValues(("filler", 0), ("wvLinkSettings", 1), ("wvInterfaces", 2), ("interfaces", 3), ("ifTestTable", 4), ("ipAddrTable", 5), ("dsx1ConfigTable", 6), ("dsx3ConfigTable", 7), ("rs232", 8), ("wvManagement", 9), ("system", 10), ("wvRelayTable", 11), ("wvExternalInputTable", 12), ("wvAlarmControl", 13), ("wvTests", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvConfigurationChangedStatus.setStatus('deprecated')
if mibBuilder.loadTexts: wvConfigurationChangedStatus.setDescription("A bit is set for a family by the agent to indicate that a configuration parameter in the corresponding family has been changed. It is the manager's responsibility to reset set bits.")
wvCommunityTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 110), )
if mibBuilder.loadTexts: wvCommunityTable.setStatus('current')
if mibBuilder.loadTexts: wvCommunityTable.setDescription('A table of SNMP community settings.')
wvCommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 110, 1), ).setIndexNames((0, "CODAN-MIB", "wvCommunityId"))
if mibBuilder.loadTexts: wvCommunityEntry.setStatus('current')
if mibBuilder.loadTexts: wvCommunityEntry.setDescription('Entry in the wvCommunityTable. The table has a variable size, limited to the range specified by wvCommunityId below. Deletion of a row is achieved by setting wvCommunityName to the NULL string. Creation of a new row is achieved by setting wvCommunityName with a non-existing index to a non-NULL string. Setting of wvCommunityPrivilege with a non-existing index is rejected.')
wvCommunityId = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 110, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvCommunityId.setStatus('current')
if mibBuilder.loadTexts: wvCommunityId.setDescription('The entry index.')
wvCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 110, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvCommunityName.setStatus('current')
if mibBuilder.loadTexts: wvCommunityName.setDescription('The name of the community.')
wvCommunityPrivilege = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 110, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvCommunityPrivilege.setStatus('current')
if mibBuilder.loadTexts: wvCommunityPrivilege.setDescription('Sets the privilege of the community which name is given by wvCommunityName .')
wvTrapRecipientsTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 111), )
if mibBuilder.loadTexts: wvTrapRecipientsTable.setStatus('current')
if mibBuilder.loadTexts: wvTrapRecipientsTable.setDescription('A table of SNMP trap managers IP addresses.')
wvTrapRecipientsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 111, 1), ).setIndexNames((0, "CODAN-MIB", "wvTrapRecipientsId"))
if mibBuilder.loadTexts: wvTrapRecipientsEntry.setStatus('current')
if mibBuilder.loadTexts: wvTrapRecipientsEntry.setDescription('Entry in the wvTrapRecipientsTable. The table has a variable size, limited to the range specified by wvTrapRecipientsId below. Deletion of a row is achieved by setting wvTrapRecipientsId to 0.0.0.0. Creation of a new row is achieved by setting wvTrapRecipientsId with a non-existing index to any value different than 0.0.0.0.')
wvTrapRecipientsId = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 111, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvTrapRecipientsId.setStatus('current')
if mibBuilder.loadTexts: wvTrapRecipientsId.setDescription('The entry index.')
wvTrapRecipientsIp = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 111, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTrapRecipientsIp.setStatus('current')
if mibBuilder.loadTexts: wvTrapRecipientsIp.setDescription('The IP Address of the manager to receive the trap.')
wvTftpServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 200), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTftpServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: wvTftpServerIpAddress.setDescription('Defines the IP Address of the TFTP server.')
wvTftpOperationCtrl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 201), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTftpOperationCtrl.setStatus('current')
if mibBuilder.loadTexts: wvTftpOperationCtrl.setDescription("When disabled no TFTP can be performed. This allows a high privilege authority to disallow lower privilege managers to initialize TFTP from this terminal. Note that since the agent has no notion of privilege levels (user/admin/supervisor) it has no means to check authentication of the entity setting this object, and the privilege distinctions are made at the managers' level.")
wvTftpNoOfRetries = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 202), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTftpNoOfRetries.setStatus('current')
if mibBuilder.loadTexts: wvTftpNoOfRetries.setDescription('Determines the no. of retries to be performed by the terminal upon TFTP failures. A value of 0 means to try forever until successful or deliberately stopped.')
wvTftpFileName = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 203), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128)).clone('\\codan.lst')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTftpFileName.setStatus('current')
if mibBuilder.loadTexts: wvTftpFileName.setDescription("Defines the full name of the file to be TFTP'ed.")
wvTftpStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 204), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTftpStartTime.setStatus('current')
if mibBuilder.loadTexts: wvTftpStartTime.setDescription('Defines the desired delay time, in time-ticks, before the TFTP is started. When TFTP is on, either on delay or started, setting wvTftpStartTime to 0 forces a premature stop.')
wvTftpRemainingStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 205), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvTftpRemainingStartTime.setStatus('current')
if mibBuilder.loadTexts: wvTftpRemainingStartTime.setDescription('Defines the ongoing remaining time before the TFTP starts.')
wvSwModuleTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 210), )
if mibBuilder.loadTexts: wvSwModuleTable.setStatus('current')
if mibBuilder.loadTexts: wvSwModuleTable.setDescription('The Terminal Software Modules table.')
wvResetPerformance = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 215), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvResetPerformance.setStatus('current')
if mibBuilder.loadTexts: wvResetPerformance.setDescription("When setting to 'on' it will Reset the Performance parameters. Reading this object will return allways 'off'.")
wvSwModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 210, 1), ).setIndexNames((0, "CODAN-MIB", "wvSwModuleIndex"))
if mibBuilder.loadTexts: wvSwModuleEntry.setStatus('current')
if mibBuilder.loadTexts: wvSwModuleEntry.setDescription('Entry in the wvSwModuleTable.')
wvSwModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 210, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSwModuleIndex.setStatus('current')
if mibBuilder.loadTexts: wvSwModuleIndex.setDescription('An index to the Software Modules Table.')
wvSwModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 210, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSwModuleName.setStatus('current')
if mibBuilder.loadTexts: wvSwModuleName.setDescription('The software module name. For example: Kernel, Agent.')
wvSwModuleActiveRev = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 210, 1, 3), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSwModuleActiveRev.setStatus('current')
if mibBuilder.loadTexts: wvSwModuleActiveRev.setDescription('The module active software revision. This string will have a zero length if the revision is unknown.')
wvSwModuleActiveCS = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 210, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSwModuleActiveCS.setStatus('current')
if mibBuilder.loadTexts: wvSwModuleActiveCS.setDescription('The module active software check-sum.')
wvSwModuleStandByRev = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 210, 1, 5), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSwModuleStandByRev.setStatus('current')
if mibBuilder.loadTexts: wvSwModuleStandByRev.setDescription('The module stand-by software revision. This string will have a zero length if the revision is unknown.')
wvSwModuleStandByCS = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 3, 210, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSwModuleStandByCS.setStatus('current')
if mibBuilder.loadTexts: wvSwModuleStandByCS.setDescription('The module stand-by software check-sum.')
wvRelayTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1), )
if mibBuilder.loadTexts: wvRelayTable.setStatus('current')
if mibBuilder.loadTexts: wvRelayTable.setDescription('A table of relays settings. There are 7 entries in the table: 5 actual relays, a buzzer as 6th entry and a general purpose external TTL output as 7th entry.')
wvRelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1, 1), ).setIndexNames((0, "CODAN-MIB", "wvRelayId"))
if mibBuilder.loadTexts: wvRelayEntry.setStatus('current')
if mibBuilder.loadTexts: wvRelayEntry.setDescription('Entry in the wvRelayTable.')
wvRelayId = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvRelayId.setStatus('current')
if mibBuilder.loadTexts: wvRelayId.setDescription('The entry index.')
wvRelayOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRelayOperation.setStatus('current')
if mibBuilder.loadTexts: wvRelayOperation.setDescription('Enables/disables given relay.')
wvRelayNormalState = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("closed", 2))).clone('open')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRelayNormalState.setStatus('current')
if mibBuilder.loadTexts: wvRelayNormalState.setDescription('Defines the normal state of the relay or TTL out. Buzzer normal state is always off, and can not be chosen.')
wvRelayActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRelayActivate.setStatus('current')
if mibBuilder.loadTexts: wvRelayActivate.setDescription('Manually activates the relay.')
wvRelayToLocalAlarmMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1, 1, 5), WvAlarmsList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRelayToLocalAlarmMapping.setStatus('current')
if mibBuilder.loadTexts: wvRelayToLocalAlarmMapping.setDescription('Bits in the list set to on will cause the given relay to be activated when any of the corresponding local alarms occur.')
wvRelayToRemoteAlarmMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1, 1, 6), WvAlarmsList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvRelayToRemoteAlarmMapping.setStatus('current')
if mibBuilder.loadTexts: wvRelayToRemoteAlarmMapping.setDescription('Bits in the list set to on will cause the given relay to be activated when any of the corresponding remote alarms occur.')
wvRelayStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("closed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvRelayStatus.setStatus('current')
if mibBuilder.loadTexts: wvRelayStatus.setDescription('Describes the current state of the given relay.')
wvExternalInputTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 5, 1), )
if mibBuilder.loadTexts: wvExternalInputTable.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputTable.setDescription('A table of external inputs settings.')
wvExternalInputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 5, 1, 1), ).setIndexNames((0, "CODAN-MIB", "wvExternalInputId"))
if mibBuilder.loadTexts: wvExternalInputEntry.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputEntry.setDescription('Entry in the wvExternalInputTable.')
wvExternalInputId = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvExternalInputId.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputId.setDescription('The entry index.')
wvExternalInputSetting = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvExternalInputSetting.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputSetting.setDescription('Enables/disables given external input.')
wvExternalInputSense = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low", 1), ("high", 2), ("anyChange", 3))).clone('high')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvExternalInputSense.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputSense.setDescription('Sets the sense on which the input alarm is defined as active.')
wvExternalInputAlarmSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("warning", 1), ("error", 2), ("fatal", 3))).clone('error')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvExternalInputAlarmSeverity.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputAlarmSeverity.setDescription('Defines the alarm severity of given input.')
wvExternalInputStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("notActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvExternalInputStatus.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputStatus.setDescription('Describes the current state of the given input.')
wvAlarmsReportToNMSCtrl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("errorAndFatal", 2), ("fatalOnly", 3), ("none", 4))).clone('errorAndFatal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAlarmsReportToNMSCtrl.setStatus('current')
if mibBuilder.loadTexts: wvAlarmsReportToNMSCtrl.setDescription('Defines the severity level of the alarms to be asynchronoulsy reported by the agent to the managers specified in the wvTrapRecepientsIpTable.')
wvAlarmsReportToLCDCtrl = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("errorAndFatal", 2), ("fatalOnly", 3), ("none", 4))).clone('fatalOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvAlarmsReportToLCDCtrl.setStatus('current')
if mibBuilder.loadTexts: wvAlarmsReportToLCDCtrl.setDescription('Defines the severity level of the alarms to be displayed at the front panel LCD.')
wvNoOfAlertsOnLCD = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvNoOfAlertsOnLCD.setStatus('current')
if mibBuilder.loadTexts: wvNoOfAlertsOnLCD.setDescription('Limits the number of alarms to be displayed at the front panel LCD.')
wvLinkBERWarningThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 4), FloatingPoint().clone(hexValue="03e805")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkBERWarningThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkBERWarningThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link BER warning alarm state. If wvLinkxxxBER in a given wvLinkThresholdMeasurementInterval gets above this value a wvlinkBERWarningAlarm is set, to be canceled if the value gets below wvLinkBERWarningThresholdLow (see below).')
wvLinkBERWarningThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 5), FloatingPoint().clone(hexValue="03e806")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkBERWarningThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkBERWarningThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link BER warning alarm state.')
wvLinkBERErrorThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 6), FloatingPoint().clone(hexValue="03e802")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkBERErrorThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkBERErrorThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link BER error alarm state. If wvxxxlinkBER in a given wvLinkThresholdMeasurementInterval gets above this value a wvlinkBERFailureAlarm is set, to be canceled if the value gets below wvLinkBERErrorThresholdLow (see below).')
wvLinkBERErrorThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 7), FloatingPoint().clone(hexValue="03e803")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkBERErrorThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkBERErrorThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link BER error alarm state.')
wvLinkBLERAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 8), FloatingPoint().clone(hexValue="03e802")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkBLERAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkBLERAlarmThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link Blocks Error Rate alarm state. If wvLinkxxxBLER in a given wvLinkThresholdMeasurementInterval gets above this value a wvlinkBLERAlarm is set, to be canceled if the value gets below wvLinkBLERAlarmThresholdLow (see below).')
wvLinkBLERAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 9), FloatingPoint().clone(hexValue="03e803")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkBLERAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkBLERAlarmThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link Blocks Error Rate alarm state.')
wvLinkBBERAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 10), FloatingPoint().clone(hexValue="03e802")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkBBERAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkBBERAlarmThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link Blocks Background Error Rate alarm state. If wvLinkxxxBBER in a given wvLinkThresholdMeasurementInterval gets above this value a wvlinkBBERAlarm is set, to be canceled if the value gets below wvLinkBBERAlarmThresholdLow (see below).')
wvLinkBBERAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 11), FloatingPoint().clone(hexValue="03e803")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkBBERAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkBBERAlarmThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link Blocks Error Rate alarm state.')
wvLinkNCBLERAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 12), FloatingPoint().clone(hexValue="03e802")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkNCBLERAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkNCBLERAlarmThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link Not Corrected Blocks Error Rate alarm state. If wvLinkxxxNCBLER in a given wvLinkThresholdMeasurementInterval gets above this value a wvLinkNCBLERAlarm is set, to be canceled if the value gets below wvLinkNCBLERAlarmThresholdLow (see below).')
wvLinkNCBLERAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 13), FloatingPoint().clone(hexValue="03e803")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkNCBLERAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkNCBLERAlarmThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link Not Corrected Blocks Error Rate alarm state.')
wvLinkESAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkESAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkESAlarmThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link Errored Seconds alarm state. If wvLinkxxxESs in a given wvLinkThresholdMeasurementInterval gets above this value a wvLinkESAlarm is set, to be canceled if the value gets below wvLinkESAlarmThresholdLow (see below). The value is expressed as a percentage x 100 of the elapsed time specified by wvLinkThresholdMeasurementInterval.')
wvLinkESAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkESAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkESAlarmThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link Errored Seconds alarm state. The value is expressed as a percentage x 100 of the elapsed time specified by wvLinkThresholdMeasurementInterval.')
wvLinkSESAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkSESAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkSESAlarmThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link Severely Errored Seconds alarm state. If wvLinkxxxSESs in a given wvLinkThresholdMeasurementInterval gets above this value a wvLinkSESAlarm is set, to be canceled if the value gets below wvLinkSESAlarmThresholdLow (see below). The value is expressed as a percentage x 100 of the elapsed time specified by wvLinkThresholdMeasurementInterval.')
wvLinkSESAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkSESAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkSESAlarmThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link Severely Errored Seconds alarm state. The value is expressed as a percentage x 100 of the elapsed time specified by wvLinkThresholdMeasurementInterval.')
wvLinkDMAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkDMAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkDMAlarmThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link Degraded Minutes alarm state. If wvLinkxxxDMs in a given wvLinkThresholdMeasurementInterval gets above this value a wvLinkDMAlarm is set, to be canceled if the value gets below wvLinkDMAlarmThresholdLow (see below). The value is expressed as a percentage x 100 of the elapsed time specified by wvLinkThresholdMeasurementInterval.')
wvLinkDMAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkDMAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkDMAlarmThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link Degraded Minutes alarm state. The value is expressed as a percentage x 100 of the elapsed time specified by wvLinkThresholdMeasurementInterval.')
wvLinkUASAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkUASAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvLinkUASAlarmThresholdHigh.setDescription('Defines the high water mark above which the terminal enters the link Unavailable Seconds alarm state. If wvLinkxxxUASs in a given wvLinkThresholdMeasurementInterval gets above this value a wvLinkUASAlarm is set, to be canceled if the value gets below wvLinkUASAlarmThresholdLow (see below). The value is expressed as a percentage x 100 of the elapsed time specified by wvLinkThresholdMeasurementInterval.')
wvLinkUASAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(900)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkUASAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvLinkUASAlarmThresholdLow.setDescription('Defines the low water mark below which the terminal exits the link Unavailable Seconds alarm state. The value is expressed as a percentage x 100 of the elapsed time specified by wvLinkThresholdMeasurementInterval.')
wvlinkRSLLowAlarmThresholdhHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, -10))).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvlinkRSLLowAlarmThresholdhHigh.setStatus('current')
if mibBuilder.loadTexts: wvlinkRSLLowAlarmThresholdhHigh.setDescription('Defines the high water mark above which the terminal enters the link rslLow alarm state. If wvLinkxxxRSL in a given wvLinkThresholdMeasurementInterval gets above this value a rslLow is set, to be canceled if the value gets below wvlinkRSLLowAlarmThresholdLow (see below).')
wvlinkRSLLowAlarmThresholdhLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, -10))).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvlinkRSLLowAlarmThresholdhLow.setStatus('current')
if mibBuilder.loadTexts: wvlinkRSLLowAlarmThresholdhLow.setDescription('Defines the low water mark below which the terminal exits the link rslLow alarm state.')
wvlinkAverageRSLLowAlarmThresholdhHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, -10))).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvlinkAverageRSLLowAlarmThresholdhHigh.setStatus('current')
if mibBuilder.loadTexts: wvlinkAverageRSLLowAlarmThresholdhHigh.setDescription('Defines the high water mark above which the terminal enters the link averageRSLLow alarm state. If wvLinkxxxAverageRSL in a given wvLinkThresholdMeasurementInterval gets above this value a averageRSLLow is set, to be canceled if the value gets below wvlinkAverageRSLLowAlarmThresholdLow (see below).')
wvlinkAverageRSLLowAlarmThresholdhLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, -10))).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvlinkAverageRSLLowAlarmThresholdhLow.setStatus('current')
if mibBuilder.loadTexts: wvlinkAverageRSLLowAlarmThresholdhLow.setDescription('Defines the low water mark below which the terminal exits the link averageRSLLow alarm state.')
wvLinkThresholdMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 900)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLinkThresholdMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: wvLinkThresholdMeasurementInterval.setDescription('Defines the periodical interval against which the link performance alarm thresholds are to be checked. A value of zero means no link performance alarms should be issued.')
wvEth10_100CSLAlarmThresholdhHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)).clone(5)).setLabel("wvEth10-100CSLAlarmThresholdhHigh").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100CSLAlarmThresholdhHigh.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100CSLAlarmThresholdhHigh.setDescription('Defines the high water mark above which the terminal enters the ETH 10/100 Carrier Sense Lost alarm state. If dot3StatsCarrierSenseErrors for any ETH 10-100 port gets above this value in a given wvEth10-100ThresholdMeasurementInterval, a eth10-100PortCSLAlarm is set, to be canceled if the value gets below wvEth10-100CSLAlarmThresholdhLow (see below).')
wvEth10_100CSLAlarmThresholdhLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setLabel("wvEth10-100CSLAlarmThresholdhLow").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100CSLAlarmThresholdhLow.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100CSLAlarmThresholdhLow.setDescription('Defines the low water mark below which the terminal exits the ETH 10/100 Carrier Sense Lost alarm state.')
wvEth10_100ECAlarmThresholdhHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)).clone(5)).setLabel("wvEth10-100ECAlarmThresholdhHigh").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100ECAlarmThresholdhHigh.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100ECAlarmThresholdhHigh.setDescription('Defines the high water mark above which the terminal enters the ETH 10/100 Excessive Collisions alarm state. If dot3StatsExcessiveCollisions for any ETH 10-100 port gets above this value in a given wvEth10-100ThresholdMeasurementInterval, a eth10-100PortECAlarm is set, to be canceled if the value gets below wvEth10-100ECAlarmThresholdhLow (see below).')
wvEth10_100ECAlarmThresholdhLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setLabel("wvEth10-100ECAlarmThresholdhLow").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100ECAlarmThresholdhLow.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100ECAlarmThresholdhLow.setDescription('Defines the low water mark below which the terminal exits the ETH 10/100 Excessive Collisions alarm state.')
wvEth10_100IMTEAlarmThresholdhHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)).clone(20)).setLabel("wvEth10-100IMTEAlarmThresholdhHigh").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100IMTEAlarmThresholdhHigh.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100IMTEAlarmThresholdhHigh.setDescription('Defines the high water mark above which the terminal enters the ETH 10/100 Internal MAC Transmit Errors alarm state. If dot3StatsInternalMacTransmitErrors for any ETH 10-100 port gets above this value in a given wvEth10-100ThresholdMeasurementInterval, a eth10-100PortIMTEAlarm is set, to be canceled if the value gets below wvEth10-100IMTEAlarmThresholdhLow (see below).')
wvEth10_100IMTEAlarmThresholdhLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)).clone(5)).setLabel("wvEth10-100IMTEAlarmThresholdhLow").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100IMTEAlarmThresholdhLow.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100IMTEAlarmThresholdhLow.setDescription('Defines the low water mark below which the terminal exits the ETH 10/100 Internal MAC Transmit Errors alarm state.')
wvEth10_100IMREAlarmThresholdhHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)).clone(20)).setLabel("wvEth10-100IMREAlarmThresholdhHigh").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100IMREAlarmThresholdhHigh.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100IMREAlarmThresholdhHigh.setDescription('Defines the high water mark above which the terminal enters the ETH 10/100 Internal MAC Receive Errors alarm state. If dot3StatsInternalMacReceiveErrors for any ETH 10-100 port gets above this value in a given wvEth10-100ThresholdMeasurementInterval, a eth10-100PortIMREAlarm is set, to be canceled if the value gets below wvEth10-100IMREAlarmThresholdhLow (see below).')
wvEth10_100IMREAlarmThresholdhLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)).clone(5)).setLabel("wvEth10-100IMREAlarmThresholdhLow").setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100IMREAlarmThresholdhLow.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100IMREAlarmThresholdhLow.setDescription('Defines the low water mark below which the terminal exits the ETH 10/100 Internal MAC Receive Errors alarm state.')
wvEth10_100TxLinkUsageAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setLabel("wvEth10-100TxLinkUsageAlarmThresholdLow").setUnits('MBits/sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100TxLinkUsageAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100TxLinkUsageAlarmThresholdLow.setDescription('Low threshold of the actual no. of bits being transmitted by the ETH 10/100 ports to the Link interface.')
wvEth10_100TxLinkUsageAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 59), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setLabel("wvEth10-100TxLinkUsageAlarmThresholdHigh").setUnits('MBits/sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100TxLinkUsageAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100TxLinkUsageAlarmThresholdHigh.setDescription('High threshold of the actual no. of bits being transmitted by the ETH 10/100 ports to the Link interface.')
wvEth10_100RxLinkUsageAlarmThresholdLow = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setLabel("wvEth10-100RxLinkUsageAlarmThresholdLow").setUnits('MBits/sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100RxLinkUsageAlarmThresholdLow.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100RxLinkUsageAlarmThresholdLow.setDescription('Low threshold of the actual no. of bits being received by the ETH 10/100 ports from the Link interface.')
wvEth10_100RxLinkUsageAlarmThresholdHigh = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setLabel("wvEth10-100RxLinkUsageAlarmThresholdHigh").setUnits('MBits/sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100RxLinkUsageAlarmThresholdHigh.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100RxLinkUsageAlarmThresholdHigh.setDescription('High threshold of the actual no. of bits being received by the ETH 10/100 ports from the Link interface.')
wvEth10_100ThresholdMeasurementInterval = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 900)).clone(30)).setLabel("wvEth10-100ThresholdMeasurementInterval").setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvEth10_100ThresholdMeasurementInterval.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100ThresholdMeasurementInterval.setDescription('Defines the periodical interval against which the ETH 10/100 alarm thresholds are to be checked. A value of zero means no link performance alarms should be issued.')
wvClearAlarmLog = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 6, 71), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvClearAlarmLog.setStatus('current')
if mibBuilder.loadTexts: wvClearAlarmLog.setDescription("use SET wvClearAlarmLog to Clear the alarm log and insert alarm that 'Alarm log was cleared by user' and GET wvClearAlarmLog to get the number of entries in the alarm log.")
wvInstalledPlugInPartNo = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvInstalledPlugInPartNo.setStatus('current')
if mibBuilder.loadTexts: wvInstalledPlugInPartNo.setDescription("The 8800 DMR Plug-In Part No. is defined as PIN-'xyztu', as follows: x - interface type: x=1 - T1/T3, x=2 - E1/E3, x=3 - STS1, x=4 - 10/100Base-T + T1s, x=5 - 10/100Base-T + E1s, x=6, 7, ...- reserved. y - connector type: for x=1/2, T1/E1 connector type - y=1 - BNC, y=2 - RJ48, y=7 - SCSI, y=8 - SCSI + T3/E3 - BNC for x=4/5, 10/100Base-T + T1/E1 connectors types y=1 - 10/100Base-T - RJ45 + T1/E1 - BNC, y=2 - 10/100Base-T - RJ45 + T1/E1 - RJ48, if no T1/E1s available then y=1 y=3 - 10/100Base-FX - (FIBER) + T1/E1 - BNC, y=4 - 10/100Base-FX - (FIBER) + T1/E1 - RJ48, if no T1/E1s available then y=3 zt- # of T1/E1 interfaces: for x=1/2/3 zt = 00, 01, 02, 04, 08 or 16 for x=4/5 zt = 00, 01, 02, or 04 u - # of high band interfaces: for x=1/2/3, # of T3/E3 interfaces - u = 0 or 1. for x=4/5, # of 10/100Base-T ports - u = 1, 2 or 4.")
wvInstalledPlugInHwRevision = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 2), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvInstalledPlugInHwRevision.setStatus('current')
if mibBuilder.loadTexts: wvInstalledPlugInHwRevision.setDescription('Plug-In Hardware Revision.')
wvIduPartNo = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIduPartNo.setStatus('current')
if mibBuilder.loadTexts: wvIduPartNo.setDescription("The 8800 DMR DIU Part No. is defined as IDU-'xyzt' (exact definition of xyzt TBD).")
wvIduHwRevision = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 4), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIduHwRevision.setStatus('current')
if mibBuilder.loadTexts: wvIduHwRevision.setDescription('IDU Hardware Revision (in fact reflects the ICB - IDU Control Board - revision).')
wvIduSwRevision = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 5), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIduSwRevision.setStatus('current')
if mibBuilder.loadTexts: wvIduSwRevision.setDescription('IDU Software Revision.')
wvIduLastSwUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIduLastSwUpdateTime.setStatus('current')
if mibBuilder.loadTexts: wvIduLastSwUpdateTime.setDescription('Sent together with the software being updated.')
wvOduPartNo = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOduPartNo.setStatus('current')
if mibBuilder.loadTexts: wvOduPartNo.setDescription("The Codan 8800 DMR ODU Part No. is defined as ODU-'xwyzt', as follows: x - Standard: x=1 - FCC(US), x=2 - ETSI(European) w - Duplex Spacing: standard frequency left digit value duplex FCC 38 1 700 FCC 23 1 1200 FCC 18 1 1560 ETSI 38 1 1260 ETSI 26 1 1008 ETSI 23 1 1200 ETSI 23 2 1008 ETSI 23 3 1232 ETSI 18 1 1010 ETSI 18 2 1008 ETSI 15 1 315 ETSI 15 2 420 ETSI 15 3 728 ETSI 15 4 644 ETSI 15 5 490 ETSI 15 6 322 ETSI 13 1 266 ETSI 10 1 65 ETSI 10 2 91 ETSI 10 3 65 ETSI 10 4 65 ETSI 10 5 91 ETSI 10 6 91 ETSI 10 7 91 ETSI 8 1 311.32 ETSI 8 2 126 ETSI 8 3 119 ETSI 7 1 154 (7125-7425) ETSI 7 2 154 (7425-7725) ETSI 7 3 161 (7125-7425) ETSI 7 4 161 (7425-7725) ETSI 7 5 245 ETSI 7 6 161 (7250-7550) y - Frequency Band: y=1-4 - Band 1-4 zt- Spectrum Range Allocation (in Ghz): 38, 23, 18, etc... Example: ODU-2-1-4-23 = ETSI, duplex spacing 1200MHz / band 4, 23GHz. The rules governing the Frequency Band correlation of the 2 terminals usage of a given link depend on the Spectrum Range of the link.")
wvOduHwRevision = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 8), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOduHwRevision.setStatus('current')
if mibBuilder.loadTexts: wvOduHwRevision.setDescription('ODU Hardware Revision.')
wvOduSwRevision = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 9), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOduSwRevision.setStatus('current')
if mibBuilder.loadTexts: wvOduSwRevision.setDescription('ODU Software Revision.')
wvOduLastSwUpdateTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOduLastSwUpdateTime.setStatus('current')
if mibBuilder.loadTexts: wvOduLastSwUpdateTime.setDescription('Sent together with the software being updated.')
wvIpbHwRevision = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 11), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIpbHwRevision.setStatus('current')
if mibBuilder.loadTexts: wvIpbHwRevision.setDescription('The IPB (IDU Panel Board) Hardware Revision.')
wvBootSwRevision = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 12), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvBootSwRevision.setStatus('current')
if mibBuilder.loadTexts: wvBootSwRevision.setDescription('BOOT Software Revision.')
wvIduAlternetSwRevision = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 13), ComponentRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIduAlternetSwRevision.setStatus('current')
if mibBuilder.loadTexts: wvIduAlternetSwRevision.setDescription('IDU Alternate Software Revision.')
wvOemId = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOemId.setStatus('current')
if mibBuilder.loadTexts: wvOemId.setDescription("Describe the manufacture of this system. '1' - Codan. ... future OEM.")
wvOemIduPartNo = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOemIduPartNo.setStatus('current')
if mibBuilder.loadTexts: wvOemIduPartNo.setDescription("The OEM IDU Part No. is defined as IDU-'xx-xxxxx-xxx'.")
wvOemOduPartNo = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOemOduPartNo.setStatus('current')
if mibBuilder.loadTexts: wvOemOduPartNo.setDescription("The OEM ODU Part No. is defined as ODU-'xx-xxxxx-xxx'.")
wvInstalledOemPlugInPartNo = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 1, 7, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvInstalledOemPlugInPartNo.setStatus('current')
if mibBuilder.loadTexts: wvInstalledOemPlugInPartNo.setDescription("The OEM Plug-in Part No. is defined as Plug-in-'xx-xxxxx-xxx'.")
wvTelemetryStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("fault", 3), ("notOperational", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvTelemetryStatus.setStatus('current')
if mibBuilder.loadTexts: wvTelemetryStatus.setDescription('Keeps the status of the Idu-Odu communication.')
wvOperatingSystemStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("systemFailure", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOperatingSystemStatus.setStatus('current')
if mibBuilder.loadTexts: wvOperatingSystemStatus.setDescription('Keeps the state of the system from the firmware point-of-view.')
wvIduOduCableStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("short", 3), ("open", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIduOduCableStatus.setStatus('current')
if mibBuilder.loadTexts: wvIduOduCableStatus.setDescription('Keeps the current status of the Idu-Odu cable.')
wvIduStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 4), Bits().clone(namedValues=NamedValues(("filler0", 0), ("iduPowerSupplyLowValue", 1), ("iduTxSynthesizerOutOfLock", 2), ("iduRxSynthesizerOutOfLock", 3), ("externalInputsActive", 4), ("selfTestFault", 5), ("iduNotOperational", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIduStatus.setStatus('current')
if mibBuilder.loadTexts: wvIduStatus.setDescription('Reports the current status of the IDU.')
wvOduStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 5), Bits().clone(namedValues=NamedValues(("filler0", 0), ("oduPowerSupplyOutOfRange", 1), ("txOnMuteState", 2), ("rxOnMuteState", 3), ("txFailure", 4), ("rxFailure", 5), ("rslLow", 6), ("averageRSLLow", 7), ("oduTxSynthesizerOutOfLock", 8), ("oduRxSynthesizerOutOfLock", 9), ("oduRfSynthesizerOutOfLock", 10), ("oduTemperatureViolation", 11), ("anyOtherOduFault", 12), ("oduNotResponding", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOduStatus.setStatus('current')
if mibBuilder.loadTexts: wvOduStatus.setDescription('Reports the current status of the ODU.')
wvRemoteTerminalStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 6), Bits().clone(namedValues=NamedValues(("remoteTerminalWarning", 0), ("remoteTerminalFailure", 1), ("remoteTerminalNotResponding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvRemoteTerminalStatus.setStatus('current')
if mibBuilder.loadTexts: wvRemoteTerminalStatus.setDescription('Reports the general current status of the remote terminal.')
wvSlipModemStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ok", 1), ("notResponding", 2), ("noDialTone", 3), ("lineBusy", 4), ("connected", 5), ("anyOtherFault", 6), ("noAnswer", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSlipModemStatus.setStatus('current')
if mibBuilder.loadTexts: wvSlipModemStatus.setDescription('Keeps the modem current status.')
wvSecurityStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 8), Bits().clone(namedValues=NamedValues(("filler0", 0), ("linkIdViolation", 1), ("passwordBypass", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSecurityStatus.setStatus('current')
if mibBuilder.loadTexts: wvSecurityStatus.setDescription('Reports the current security status.')
wvTftpDwnlStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("dwnlStatusUnknown", 1), ("dwnlInProcess", 2), ("dwnlSuccess", 3), ("dwnlGeneralError", 4), ("dwnlNoResponseFromServer", 5), ("dwnlChecksumError", 6), ("dwnlSwIncompatibleImage", 7), ("dwnlConfigIncompatibleImage", 8), ("dwnlTftpProtocolError", 9), ("dwnlTftpFilePasswordError", 10), ("dwnlCancelByUser", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvTftpDwnlStatus.setStatus('current')
if mibBuilder.loadTexts: wvTftpDwnlStatus.setDescription('Describes the status of last TFTP operation. If no TFTP has been performed its status is dwnlStatusUnknown.')
wvLinkPerformanceAlarmsStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 10), Bits().clone(namedValues=NamedValues(("filler0", 0), ("wvLinkESAlarm", 1), ("wvLinkSESAlarm", 2), ("wvLinkUASAlarm", 3), ("wvLinkDMAlarm", 4), ("wvLinkBERWarningAlarm", 5), ("wvLinkBERFailureAlarm", 6), ("wvLinkBLERAlarm", 7), ("wvLinkBBERAlarm", 8), ("wvLinkNCBLERAlarm", 9), ("eth10-100RxLinkUsageLow", 10), ("eth10-100RxLinkUsageHigh", 11), ("eth10-100TxLinkUsageLow", 12), ("eth10-100TxLinkUsageHigh", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkPerformanceAlarmsStatus.setStatus('current')
if mibBuilder.loadTexts: wvLinkPerformanceAlarmsStatus.setDescription('Reports the status of link performance related alarms.')
wvOperatingFrequency = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 11), Integer32()).setUnits('MHz*100').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOperatingFrequency.setStatus('current')
if mibBuilder.loadTexts: wvOperatingFrequency.setDescription("Specifies the current Spectrum Range Allocation x 100, in Mhz (3800000, 2300000, 1800000, etc...) The value is extracted from the terminal's wvOduPartNo.")
wvFrequencyBand = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("bandOne", 1), ("bandTwo", 2), ("bandThree", 3), ("bandFour", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvFrequencyBand.setStatus('current')
if mibBuilder.loadTexts: wvFrequencyBand.setDescription("Specifies the current frequency band, as read from preset jumpers at the ODU. The value read should be compatible with the peer's Link Terminal, so that if one side has 1 or 3 the other side must have 2 or 4, accordingly.")
wvChannelSpacing = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("twoAndAHalf", 1), ("five", 2), ("sevenAndAHalf", 3), ("twelveAndAHalf", 4), ("twentyFive", 5), ("fifty", 6), ("threeAndAHalf", 7), ("seven", 8), ("fourteen", 9), ("twentyEight", 10), ("fiftySix", 11)))).setUnits('MHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvChannelSpacing.setStatus('current')
if mibBuilder.loadTexts: wvChannelSpacing.setDescription('Specifies the frequency spacing between adjacent channels, as a function of the ODU standard (American vs. European) and chosen wvLinkCapacity. Note that on the 18 Ghz Spectrum Range the actual values may be different than on the other ranges, and those are specifically mentioned where applicable.')
wvTxPowerLevel = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-70, 30))).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: wvTxPowerLevel.setDescription("The transmit power value read at this terminal's ODU output.")
wvRxSignalLevel = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, -10))).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvRxSignalLevel.setStatus('current')
if mibBuilder.loadTexts: wvRxSignalLevel.setDescription('The receive signal value read on this terminal.')
wvFadeMargin = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 90))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvFadeMargin.setStatus('current')
if mibBuilder.loadTexts: wvFadeMargin.setDescription('The margin on the receive signal level, as a function of the Automatic Gain Control read( min(wvRxSignalLevel) - wvRxSignalLevel ).')
wvOduTemperature = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-58, 212))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOduTemperature.setStatus('current')
if mibBuilder.loadTexts: wvOduTemperature.setDescription('The measured ODU temperature. The units and possible values depend on the ODU model. The shown range is American Fahreneit. The European range is -50..100 Centigrades.')
wvLedState = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 18), Bits().clone(namedValues=NamedValues(("filler0", 0), ("powerOn", 1), ("linkOperational", 2), ("relay1On", 3), ("relay2On", 4), ("relay3On", 5), ("relay4On", 6), ("relay5On", 7), ("localCableFault", 8), ("remoteCableFault", 9), ("localIduFault", 10), ("remoteIduFault", 11), ("localOduFault", 12), ("remoteOduFault", 13), ("localFrontPanelDisplay", 14), ("remoteFrontPanelDisplay", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLedState.setStatus('current')
if mibBuilder.loadTexts: wvLedState.setDescription('The current state of the IDU LEDs.')
wvModemAfc = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvModemAfc.setStatus('current')
if mibBuilder.loadTexts: wvModemAfc.setDescription('The measured Modem Automatic Frequency Control. This is an implementation specific value, mainly for diagnostic purposes.')
wvRxPllFrequency = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvRxPllFrequency.setStatus('current')
if mibBuilder.loadTexts: wvRxPllFrequency.setDescription('The measured Receive Pll Frequency. This is an implementation specific value, mainly for diagnostic purposes.')
wvWorkingFrequency = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 21), Integer32()).setUnits('MHz*100').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvWorkingFrequency.setStatus('current')
if mibBuilder.loadTexts: wvWorkingFrequency.setDescription("Specifies the actual working frequency x 100, in Mhz (3897875, 2122550, 1873875, etc...) The value depends on the chosen wvChannelNo, the terminal's wvOduPartNo and wvFrequencyBand.")
wvMaxTxPowerSetting = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 29)).clone(29)).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvMaxTxPowerSetting.setStatus('current')
if mibBuilder.loadTexts: wvMaxTxPowerSetting.setDescription("This value present the maximum Tx power that can be achieved by the system (this parameter is the maximum value that the user can set for the 'wvTxPowerSetting'). ")
wvMinTxPowerSetting = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 29)).clone(-10)).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvMinTxPowerSetting.setStatus('current')
if mibBuilder.loadTexts: wvMinTxPowerSetting.setDescription("This value present the minimum Tx power that can be achieved by the system (this parameter is the minimum value that the user can set for the 'wvTxPowerSetting'). ")
wvOduSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOduSerialNumber.setStatus('current')
if mibBuilder.loadTexts: wvOduSerialNumber.setDescription('The serial number of ODU.')
wvIduSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvIduSerialNumber.setStatus('current')
if mibBuilder.loadTexts: wvIduSerialNumber.setDescription('The serial number of IDU.')
wvOnePlusOneStatus = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 30), Bits().clone(namedValues=NamedValues(("filler0", 0), ("onePlusOneOn", 1), ("primaryUnit", 2), ("manualModeOn", 3), ("alternateIduOk", 4), ("unitActive", 5), ("frequencyDiversityOn", 6), ("swIduFail", 7), ("upperUnit", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOnePlusOneStatus.setStatus('current')
if mibBuilder.loadTexts: wvOnePlusOneStatus.setDescription('Reports the current status of various 1+1 related signals and s/w detected conditions.')
wvSupport2T1and2E1Status = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("support2T1and2E1Enable", 0), ("support2T1and2E1Disable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSupport2T1and2E1Status.setStatus('current')
if mibBuilder.loadTexts: wvSupport2T1and2E1Status.setDescription('Reports the current status of support 2T1 and 2E1 capacity.')
wvLastUpdateConfigurationTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLastUpdateConfigurationTimestamp.setStatus('current')
if mibBuilder.loadTexts: wvLastUpdateConfigurationTimestamp.setDescription('The Last Update Configuration Timestamp in system ticks')
wvOemIduSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOemIduSerialNumber.setStatus('current')
if mibBuilder.loadTexts: wvOemIduSerialNumber.setDescription('The IDU serial number for OEM manufacture.')
wvOemOduSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOemOduSerialNumber.setStatus('current')
if mibBuilder.loadTexts: wvOemOduSerialNumber.setDescription('The ODU serial number for OEM manufacture.')
wvOnePlusOneConnectorType = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("yCable", 0), ("iauDb25", 1), ("iau75", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvOnePlusOneConnectorType.setStatus('current')
if mibBuilder.loadTexts: wvOnePlusOneConnectorType.setDescription("Reports the current connector type that connected to the plug-in's in the new 1+1 system.")
wvLog = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 40))
wvLogEventsElapsed = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 40, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLogEventsElapsed.setStatus('current')
if mibBuilder.loadTexts: wvLogEventsElapsed.setDescription('The number of events from last reset')
wvLogEventTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 40, 2), )
if mibBuilder.loadTexts: wvLogEventTable.setStatus('current')
if mibBuilder.loadTexts: wvLogEventTable.setDescription('The Log Event table.')
wvLogEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 40, 2, 1), ).setIndexNames((0, "CODAN-MIB", "wvLogEventLock"))
if mibBuilder.loadTexts: wvLogEventEntry.setStatus('current')
if mibBuilder.loadTexts: wvLogEventEntry.setDescription('An entry in the Log Event table.')
wvLogEventLock = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 40, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLogEventLock.setStatus('current')
if mibBuilder.loadTexts: wvLogEventLock.setDescription('A number between 1 and 64, where 1 is the last (new) event in queue and 64 is the first (old) event in queue. (assuming that all 64 events are valid).')
wvLogEventTime = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 40, 2, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLogEventTime.setStatus('current')
if mibBuilder.loadTexts: wvLogEventTime.setDescription('Defines the event time, relative to sysUpTime')
wvLogEventStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 40, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("messageStart", 1), ("warningStart", 2), ("fatalStart", 3), ("messageEnd", 4), ("warningEnd", 5), ("fatalEnd", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLogEventStatus.setStatus('current')
if mibBuilder.loadTexts: wvLogEventStatus.setDescription('Defines the alarm severity.')
wvLogEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 2, 40, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLogEventDescription.setStatus('current')
if mibBuilder.loadTexts: wvLogEventDescription.setDescription('The event description. For example: IDU Tx synt. Fail.')
wvlinkBER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 1), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkBER.setStatus('current')
if mibBuilder.loadTexts: wvlinkBER.setDescription("Specifies the terminal's cummulative Bit Error Rate since link last start-up.")
wvlinkBLER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 2), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkBLER.setStatus('current')
if mibBuilder.loadTexts: wvlinkBLER.setDescription("Specifies the terminal's cummulative Corrected Blocks Rate since link last start-up.")
wvlinkBBER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 3), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkBBER.setStatus('current')
if mibBuilder.loadTexts: wvlinkBBER.setDescription("Specifies the terminal's cummulative Background Blocks Error Rate since link last start-up.")
wvlinkNCBLER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 4), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkNCBLER.setStatus('current')
if mibBuilder.loadTexts: wvlinkNCBLER.setDescription("Specifies the terminal's cummulative Not Corrected Blocks Error Rate since link last start-up.")
wvLinkESs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 5), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkESs.setStatus('current')
if mibBuilder.loadTexts: wvLinkESs.setDescription('Specifies the number of Errored Seconds, encountered by the interface Link since link last start-up.')
wvLinkSESs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 6), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkSESs.setStatus('current')
if mibBuilder.loadTexts: wvLinkSESs.setDescription('Specifies the number of Severely Errored Seconds, encountered by the interface Link since link last start-up.')
wvLinkUAs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 7), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkUAs.setStatus('current')
if mibBuilder.loadTexts: wvLinkUAs.setDescription('Specifies the number of Unavailable Seconds, encountered by the interface Link since link last start-up.')
wvLinkDMs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 8), Gauge32()).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkDMs.setStatus('current')
if mibBuilder.loadTexts: wvLinkDMs.setDescription('Specifies the number of Degraded Minutes, encountered by the interface Link since link last start-up.')
wvlinkAverageRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 9), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkAverageRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkAverageRSL.setDescription('Specifies the average Receive Signal Level, encountered by the interface Link since link last start-up.')
wvlinkMaximumRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 10), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkMaximumRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkMaximumRSL.setDescription('Specifies the maximum Receive Signal Level, encountered by the interface Link since link last start-up.')
wvlinkMinimumRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkMinimumRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkMinimumRSL.setDescription('Specifies the minimum Receive Signal Level, encountered by the interface Link since link last start-up.')
wvLinkValidIntervals = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkValidIntervals.setStatus('current')
if mibBuilder.loadTexts: wvLinkValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 96 unless the interface was brought on-line within the last 24 hours, in which case the value will be the number of complete 15 minute intervals since the interface has been online.')
wvLinkCurrentESs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 13), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkCurrentESs.setStatus('current')
if mibBuilder.loadTexts: wvLinkCurrentESs.setDescription('The number of Errored Seconds, encountered by the interface Link in the current 15 minute interval.')
wvLinkCurrentSESs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 14), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkCurrentSESs.setStatus('current')
if mibBuilder.loadTexts: wvLinkCurrentSESs.setDescription('The number of Severely Errored Seconds, encountered by the interface Link in the current 15 minute interval.')
wvLinkCurrentUASs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 15), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkCurrentUASs.setStatus('current')
if mibBuilder.loadTexts: wvLinkCurrentUASs.setDescription('The number of Unavailable Seconds, encountered by the interface Link in the current 15 minute interval.')
wvLinkCurrentDMs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 16), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkCurrentDMs.setStatus('current')
if mibBuilder.loadTexts: wvLinkCurrentDMs.setDescription('The number of Degraded Minutes, encountered by the interface Link in the current 15 minute interval.')
wvLinkCurrentBER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 17), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkCurrentBER.setStatus('current')
if mibBuilder.loadTexts: wvLinkCurrentBER.setDescription('The Bit Error Rate encountered by the interface Link in the current 15 minute interval.')
wvLinkCurrentBLER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 18), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkCurrentBLER.setStatus('current')
if mibBuilder.loadTexts: wvLinkCurrentBLER.setDescription('The Corrected Blocks Rate encountered by the interface Link in the current 15 minute interval.')
wvLinkCurrentBBER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 19), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkCurrentBBER.setStatus('current')
if mibBuilder.loadTexts: wvLinkCurrentBBER.setDescription('The Background Blocks Error Rate encountered by the interface Link in the current 15 minute interval.')
wvLinkCurrentNCBLER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 20), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkCurrentNCBLER.setStatus('current')
if mibBuilder.loadTexts: wvLinkCurrentNCBLER.setDescription('The Not Corrected Blocks Error Rate encountered by the interface Link in the current 15 minute interval.')
wvlinkCurrentAverageRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 21), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkCurrentAverageRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkCurrentAverageRSL.setDescription('Specifies the average Receive Signal Level, encountered by the Link interface in the current 15 minute interval.')
wvlinkCurrentMaximumRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 22), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkCurrentMaximumRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkCurrentMaximumRSL.setDescription('Specifies the maximum Receive Signal Level, encountered by the Link interface in the current 15 minute interval.')
wvlinkCurrentMinimumRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 23), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkCurrentMinimumRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkCurrentMinimumRSL.setDescription('Specifies the minimum Receive Signal Level, encountered by the Link interface in the current 15 minute interval.')
wvlinkCurrentTimeElapsed = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkCurrentTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: wvlinkCurrentTimeElapsed.setDescription('Specifies the no. of seconds elapsed since the beginning of the current 15 minute interval.')
wvLinkIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25), )
if mibBuilder.loadTexts: wvLinkIntervalTable.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalTable.setDescription('The Link Interval table.')
wvLinkIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1), ).setIndexNames((0, "CODAN-MIB", "wvLinkIntervalNumber"))
if mibBuilder.loadTexts: wvLinkIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalEntry.setDescription('An entry in the Link Interval table.')
wvLinkIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
wvLinkIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalESs.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalESs.setDescription('The number of Errored Seconds encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvLinkIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalSESs.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalSESs.setDescription('The number of Severely Errored Seconds encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvLinkIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalUASs.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalUASs.setDescription('The number of Unavailable Seconds encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvLinkIntervalDMs = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalDMs.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalDMs.setDescription('The number of Degraded Minutes (DMs) encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvLinkIntervalBER = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 6), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalBER.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalBER.setDescription('The Bit Error Rate encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvLinkIntervalBLER = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 7), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalBLER.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalBLER.setDescription('The Corrected Blocks Rate encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvLinkIntervalBBER = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 8), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalBBER.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalBBER.setDescription('The Background Blocks Error Rate encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvLinkIntervalNCBLER = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 9), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkIntervalNCBLER.setStatus('current')
if mibBuilder.loadTexts: wvLinkIntervalNCBLER.setDescription('The Not Corrected Blocks Error Rate encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvlinkIntervalAverageRSL = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 10), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkIntervalAverageRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkIntervalAverageRSL.setDescription('Specifies the average Receive Signal Level, encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvlinkIntervalMaximumRSL = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 11), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkIntervalMaximumRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkIntervalMaximumRSL.setDescription('Specifies the maximum Receive Signal Level, encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvlinkIntervalMinimumRSL = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 25, 1, 12), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkIntervalMinimumRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkIntervalMinimumRSL.setDescription('Specifies the minimum Receive Signal Level, encountered by the Link interface in one of the previous 96, individual 15 minute, intervals.')
wvLinkTotalESs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkTotalESs.setStatus('current')
if mibBuilder.loadTexts: wvLinkTotalESs.setDescription('The number of Errored Seconds encountered by the Link interface in the previous 24 hour interval.')
wvLinkTotalSESs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkTotalSESs.setStatus('current')
if mibBuilder.loadTexts: wvLinkTotalSESs.setDescription('The number of Severely Errored Seconds encountered by the Link interface in the previous 24 hour interval.')
wvLinkTotalUASs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkTotalUASs.setStatus('current')
if mibBuilder.loadTexts: wvLinkTotalUASs.setDescription('The number of Unavailable Seconds encountered by the Link interface the previous 24 hour interval.')
wvLinkTotalDMs = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkTotalDMs.setStatus('current')
if mibBuilder.loadTexts: wvLinkTotalDMs.setDescription('The number of Degraded Minutes (DMs) encountered by the Link interface in the previous 24 hour interval.')
wvLinkTotalBER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 30), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkTotalBER.setStatus('current')
if mibBuilder.loadTexts: wvLinkTotalBER.setDescription('The Bit Error Rate encountered by the Link interface in the previous 24 hour interval.')
wvLinkTotalBLER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 31), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkTotalBLER.setStatus('current')
if mibBuilder.loadTexts: wvLinkTotalBLER.setDescription('The Corrected Blocks Rate encountered by the Link interface in the previous 24 hour interval.')
wvLinkTotalBBER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 32), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkTotalBBER.setStatus('current')
if mibBuilder.loadTexts: wvLinkTotalBBER.setDescription('The Background Blocks Error Rate encountered by the Link interface in the previous 24 hour interval.')
wvLinkTotalNCBLER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 33), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkTotalNCBLER.setStatus('current')
if mibBuilder.loadTexts: wvLinkTotalNCBLER.setDescription('The Not Corrected Blocks Rate encountered by the Link interface in the previous 24 hour interval.')
wvlinkTotalAverageRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 34), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkTotalAverageRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkTotalAverageRSL.setDescription('Specifies the average Receive Signal Level, encountered by the Link interface in the previous 24 hour interval.')
wvlinkTotalMaximumRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 35), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkTotalMaximumRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkTotalMaximumRSL.setDescription('Specifies the maximum Receive Signal Level, encountered by the Link interface in the previous 24 hour interval.')
wvlinkTotalMinimumRSL = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 36), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkTotalMinimumRSL.setStatus('current')
if mibBuilder.loadTexts: wvlinkTotalMinimumRSL.setDescription('Specifies the minimum Receive Signal Level, encountered by the Link interface in the previous 24 hour interval.')
wvlinkNoOfReceivedKBits = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 40), Counter32()).setUnits('Kilobits').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkNoOfReceivedKBits.setStatus('current')
if mibBuilder.loadTexts: wvlinkNoOfReceivedKBits.setDescription('Specifies the total number of kilobits received by the Link interface.')
wvlinkNoOfErrors = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkNoOfErrors.setStatus('current')
if mibBuilder.loadTexts: wvlinkNoOfErrors.setDescription('Specifies the total number of errors received by the Link interface, before FEC Correction.')
wvlinkErroredBlocks = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkErroredBlocks.setStatus('current')
if mibBuilder.loadTexts: wvlinkErroredBlocks.setDescription('Specifies the total number of errored blocks received by the Link interface, before FEC Correction.')
wvlinkNotCorrectedErroredBlocks = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkNotCorrectedErroredBlocks.setStatus('current')
if mibBuilder.loadTexts: wvlinkNotCorrectedErroredBlocks.setDescription('Specifies the total number of blocks that could not be corrected by the FEC, received by the Link interface.')
wvLinkPerformanceCountTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 50), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLinkPerformanceCountTime.setStatus('current')
if mibBuilder.loadTexts: wvLinkPerformanceCountTime.setDescription('The time (in hundredths of a second) since when Link related performance is calculated. It behaves like sysUpTime and is reset to 0 whenever Link characteristics (Capacity, Modulation, etc...) is changed.')
wvlinkInstantaneousBER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 60), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvlinkInstantaneousBER.setStatus('current')
if mibBuilder.loadTexts: wvlinkInstantaneousBER.setDescription('The Instantaneous Bit Error Rate encountered by the Link interface. This is the value adaptively calculated to reach a 1% measurement precision.')
wvEth10_100TxLinkUsage = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 100), Integer32()).setLabel("wvEth10-100TxLinkUsage").setUnits('Bits/sec').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvEth10_100TxLinkUsage.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100TxLinkUsage.setDescription('Shows the actual no. of bits being transmitted by the ETH 10/100 ports to the Link interface.')
wvEth10_100RxLinkUsage = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 101), Integer32()).setLabel("wvEth10-100RxLinkUsage").setUnits('Bits/sec').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvEth10_100RxLinkUsage.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100RxLinkUsage.setDescription('Shows the actual no. of bits being received by the ETH 10/100 ports from the Link interface.')
wvEth10_100TxLinkUtilization = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 102), Integer32()).setLabel("wvEth10-100TxLinkUtilization").setUnits('%').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvEth10_100TxLinkUtilization.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100TxLinkUtilization.setDescription('Shows the calculated ETH 10/100 Link percentage Tx usage (100 X wvEth10-100TxLinkUsage / total channel capacity).')
wvEth10_100RxLinkUtilization = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 3, 103), Integer32()).setLabel("wvEth10-100RxLinkUtilization").setUnits('%').setMaxAccess("readonly")
if mibBuilder.loadTexts: wvEth10_100RxLinkUtilization.setStatus('current')
if mibBuilder.loadTexts: wvEth10_100RxLinkUtilization.setDescription('Shows the calculated ETH 10/100 Link percentage Rx usage (100 X wvEth10-100RxLinkUsage / total channel capacity).')
wvLoopbackType = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 1), WvLoopbacksList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLoopbackType.setStatus('current')
if mibBuilder.loadTexts: wvLoopbackType.setDescription('Defines the type of loopback to be performed on the terminal.')
wvLoopbackStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 2), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLoopbackStartTime.setStatus('current')
if mibBuilder.loadTexts: wvLoopbackStartTime.setDescription('Defines the desired delay time, in time-ticks, before the loopbacks specified by wvLoopbackType are activated. When any loopback is on, either on delay or started, 0 forces a premature stop.')
wvLoopbackTimePeriod = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 3), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvLoopbackTimePeriod.setStatus('current')
if mibBuilder.loadTexts: wvLoopbackTimePeriod.setDescription('Defines the desired duration of the loopback. Setting a value of 0 means it should run until deliberately stopped.')
wvLoopbackRemainingStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLoopbackRemainingStartTime.setStatus('current')
if mibBuilder.loadTexts: wvLoopbackRemainingStartTime.setDescription('Defines the ongoing remaining time before the loopbacks specified by wvLoopbackType are activated.')
wvLoopbackRemainingTimePeriod = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 5), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLoopbackRemainingTimePeriod.setStatus('current')
if mibBuilder.loadTexts: wvLoopbackRemainingTimePeriod.setDescription('Defines the ongoing remaining duration of the loopback activation.')
wvSelfTestType = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 100), Bits().clone(namedValues=NamedValues(("noTest", 0), ("ramTest", 1), ("flashTest", 2), ("epromTest", 3), ("fpTest", 4), ("modemTest", 5), ("fecTest", 6), ("muxTest", 7), ("ibTest", 8), ("bertTest", 9), ("sccTest", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSelfTestType.setStatus('deprecated')
if mibBuilder.loadTexts: wvSelfTestType.setDescription('Defines the type of next self-tests to be performed on the terminal. Local restrictions may limit the tests that can be performed simultaneously.')
wvSelfTestStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 101), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSelfTestStartTime.setStatus('deprecated')
if mibBuilder.loadTexts: wvSelfTestStartTime.setDescription('Defines the desired delay time, in time-ticks, before the tests specified by wvSelfTestType are started. When any test is running, 0 forces a premature stop.')
wvLastSelfTestStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 102), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLastSelfTestStartTime.setStatus('current')
if mibBuilder.loadTexts: wvLastSelfTestStartTime.setDescription('Keeps the time, relative to sysUpTime, when the tests in the wvLastSelfTestTable were last performed.')
wvLastSelfTestTable = MibTable((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 103), )
if mibBuilder.loadTexts: wvLastSelfTestTable.setStatus('current')
if mibBuilder.loadTexts: wvLastSelfTestTable.setDescription('A table of last self tests.')
wvLastSelfTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 103, 1), ).setIndexNames((0, "CODAN-MIB", "wvLastSelfTestType"))
if mibBuilder.loadTexts: wvLastSelfTestEntry.setStatus('current')
if mibBuilder.loadTexts: wvLastSelfTestEntry.setDescription('Entry in the wvLastSelfTestTable. There is one for each of the last run self-tests.')
wvLastSelfTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 103, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("noTest", 0), ("ramTest", 1), ("flashTest", 2), ("epromTest", 3), ("fpTest", 4), ("modemTest", 5), ("fecTest", 6), ("muxTest", 7), ("ibTest", 8), ("bertTest", 9), ("sccTest", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLastSelfTestType.setStatus('current')
if mibBuilder.loadTexts: wvLastSelfTestType.setDescription('The self-test type for this entry.')
wvLastSelfTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 103, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("failed", 1), ("passed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLastSelfTestStatus.setStatus('current')
if mibBuilder.loadTexts: wvLastSelfTestStatus.setDescription('The status of the test specified in wvLastSelfTestType.')
wvSelfTestRemainingStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 104), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvSelfTestRemainingStartTime.setStatus('deprecated')
if mibBuilder.loadTexts: wvSelfTestRemainingStartTime.setDescription('Defines the ongoing remaining time before the tests specified by wvSelfTestType start.')
wvInsertTestSignalLine = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 200), Bits().clone(namedValues=NamedValues(("filler0", 0), ("dsx1-1", 1), ("dsx1-2", 2), ("dsx1-3", 3), ("dsx1-4", 4), ("dsx1-5", 5), ("dsx1-6", 6), ("dsx1-7", 7), ("dsx1-8", 8), ("dsx1-9", 9), ("dsx1-10", 10), ("dsx1-11", 11), ("dsx1-12", 12), ("dsx1-13", 13), ("dsx1-14", 14), ("dsx1-15", 15), ("dsx1-16", 16), ("dsx3", 17), ("eth10-100", 18)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvInsertTestSignalLine.setStatus('current')
if mibBuilder.loadTexts: wvInsertTestSignalLine.setDescription('Defines the line(s) on which a special BER test signal is inserted. Proper loopbacks are assumed to be previously set for the test to succeed. If no loopback is selected, the test results are checked at the peer terminal. The actual lines applicable depend on wvLinkCapacity. In addition, only the following combinations can be simultaneously tested: - 1 T1/E1 line - T3/E3 line - the eth10-100 board (both ports) - all existing lines/ports (full capacity).')
wvInsertTestSignalStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 201), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvInsertTestSignalStartTime.setStatus('current')
if mibBuilder.loadTexts: wvInsertTestSignalStartTime.setDescription('Defines the desired delay time, in time-ticks, before the tests on the lines specified by wvInsertTestSignalLine are started. When any test is on, 0 forces a premature stop.')
wvInsertTestSignalTimePeriod = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 202), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvInsertTestSignalTimePeriod.setStatus('current')
if mibBuilder.loadTexts: wvInsertTestSignalTimePeriod.setDescription('Defines the desired duration of the tests. Setting a value of 0 means it should run until deliberately stopped.')
wvLastTestSignalTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 203), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLastTestSignalTime.setStatus('current')
if mibBuilder.loadTexts: wvLastTestSignalTime.setDescription('Defines the time, relative to sysUpTime, when the insert test signal was last performed.')
wvLastTestSignalBER = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 204), FloatingPoint()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLastTestSignalBER.setStatus('current')
if mibBuilder.loadTexts: wvLastTestSignalBER.setDescription('Specifies the Bit Error Rate from last test signal activation.')
wvInsertTestSignalRemainingStartTime = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 205), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvInsertTestSignalRemainingStartTime.setStatus('current')
if mibBuilder.loadTexts: wvInsertTestSignalRemainingStartTime.setDescription('Defines the ongoing remaining time before the tests on the lines specified by wvInsertTestSignalLine start.')
wvInsertTestSignalRemainingTimePeriod = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 206), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvInsertTestSignalRemainingTimePeriod.setStatus('current')
if mibBuilder.loadTexts: wvInsertTestSignalRemainingTimePeriod.setDescription('Defines the ongoing remaining duration of the tests.')
wvGenericDiagnosticsParameterAddress = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 300), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvGenericDiagnosticsParameterAddress.setStatus('current')
if mibBuilder.loadTexts: wvGenericDiagnosticsParameterAddress.setDescription('This object defines the address on the IDU physical memory from which wvGenericDiagnosticsParameterValue below is read. The given address will be aligned to long, if needed. Attempt to set it to a non-valid address will be rejected.')
wvGenericDiagnosticsParameterValue = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 4, 301), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvGenericDiagnosticsParameterValue.setStatus('current')
if mibBuilder.loadTexts: wvGenericDiagnosticsParameterValue.setDescription('Reading of this object returns the 4 bytes (long) value on the address specified by wvGenericDiagnosticsParameterAddress above.')
wvTraps0 = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0))
wvTrapVars = MibIdentifier((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1))
wvTrapKeepAlivePeriod = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTrapKeepAlivePeriod.setStatus('current')
if mibBuilder.loadTexts: wvTrapKeepAlivePeriod.setDescription('This object defines the keep alive traps period in minutes.')
wvAisPortTrap = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvAisPortTrap.setStatus('current')
if mibBuilder.loadTexts: wvAisPortTrap.setDescription('This object defines the port munber that refers to wvLineAisStart/wvLineAisStop /wvAisReceiveStart/wvAisReceiveStop, this number should be used as wvTributaryPortIfIndex in the wvTributaryPortTable.')
wvLosPortTrap = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvLosPortTrap.setStatus('current')
if mibBuilder.loadTexts: wvLosPortTrap.setDescription('This object defines the port munber that refers to wvLineLosStart/wvLineLosStop, this number should be used as wvTributaryPortIfIndex in the wvTributaryPortTable.')
wvExternalInputTrap = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvExternalInputTrap.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputTrap.setDescription('This object defines the external input munber that refers to wvExternalInputsStart/wvExternalInputsStop.')
wvRelayIdTrap = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvRelayIdTrap.setStatus('current')
if mibBuilder.loadTexts: wvRelayIdTrap.setDescription('This object defines the relay id munber that refers to wvRelayStart\\wvRelayStop, this number should be used as wvRelayId in the wvRelayTable.')
wvSelectTrapVector = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1, 6), Bits().clone(namedValues=NamedValues(("wlOduCableFaultStart", 0), ("wlOduCableFaultStop", 1), ("wlIduIntnlFaultStart", 2), ("wlIduIntnlFaultStop", 3), ("wlOduIntnlFaultStart", 4), ("wlOduIntnlFaultStop", 5), ("wlLinkDownStart", 6), ("wlLinkDownStop", 7), ("wlIdViolationtStart", 8), ("wlIdViolationStop", 9), ("wlRmtTermAccsStart", 10), ("wlRmtTermAccsStop", 11), ("wlLoclOduAccsStart", 12), ("wlLoclOduAccsStop", 13), ("wlRcvSignLowLevlStart", 14), ("wlRcvSignLowLevlStop", 15), ("wlRelayStart", 16), ("wlRelayStop", 17), ("wlAisStart", 18), ("wlAisStop", 19), ("wlLosStart", 20), ("wlLosStop", 21), ("wlBerWarnStart", 22), ("wlBerWarnStop", 23), ("wlBerErrStart", 24), ("wlBerErrStop", 25), ("wlExtInputsStart", 26), ("wlExtInputsStop", 27), ("wlUasStart", 28), ("wlUasStop", 29), ("wlTftpFail", 30), ("wlTftpSuss", 31), ("wlOduTempStart", 32), ("wlOduTempStop", 33), ("wlTxMuteStart", 34), ("wlTxMuteStop", 35), ("wlPwrSupplyStart", 36), ("wlPwrSupplyStop", 37), ("wlCfgMismatch", 38), ("wlBankSw", 39), ("wlPortLoopBckStart", 40), ("wlPortLoopBckStop", 41), ("wlPortBertStart", 42), ("wlPortBertStop", 43), ("wlHeartBit", 44), ("wlAisReceiveStart", 45), ("wlAisReceiveStop", 46), ("wlEth10x100RxLinkUsageLowStart", 47), ("wlEth10x100RxLinkUsageLowStop", 48), ("wlEth10x100RxLinkUsageHighStart", 49), ("wlEth10x100RxLinkUsageHighStop", 50), ("wlEth10x100TxLinkUsageLowStart", 51), ("wlEth10x100TxLinkUsageLowStop", 52), ("wlEth10x100TxLinkUsageHighStart", 53), ("wlEth10x100TxLinkUsageHighStop", 54), ("wlEnd", 55)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvSelectTrapVector.setStatus('current')
if mibBuilder.loadTexts: wvSelectTrapVector.setDescription('Private traps mapping.')
wvTrapKeepAliveVarsSelect = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1, 7), Bits().clone(namedValues=NamedValues(("vRSL", 0), ("vBER", 1), ("vUAS", 2), ("vEnd", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wvTrapKeepAliveVarsSelect.setStatus('current')
if mibBuilder.loadTexts: wvTrapKeepAliveVarsSelect.setDescription('Keep Alive trap variables mapping.')
wvTrapKeepAliveString = MibScalar((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wvTrapKeepAliveString.setStatus('current')
if mibBuilder.loadTexts: wvTrapKeepAliveString.setDescription('A verbal string send with the wvIduHeartBit trap Has the following format: Serial Numbers: \\ [RSL = ] [BER = ] [UAS = ]')
wvIduOduCableFaultStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 1)).setObjects(("CODAN-MIB", "wvIduOduCableStatus"))
if mibBuilder.loadTexts: wvIduOduCableFaultStart.setStatus('current')
if mibBuilder.loadTexts: wvIduOduCableFaultStart.setDescription('A trap indicating Idu or Odu cable fail')
wvIduOduCableFaultStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 2)).setObjects(("CODAN-MIB", "wvIduOduCableStatus"))
if mibBuilder.loadTexts: wvIduOduCableFaultStop.setStatus('current')
if mibBuilder.loadTexts: wvIduOduCableFaultStop.setDescription('A trap indicating restoring from wvIduOduCableFaultStart')
wvIduInternalFaultStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 3)).setObjects(("CODAN-MIB", "wvIduStatus"))
if mibBuilder.loadTexts: wvIduInternalFaultStart.setStatus('current')
if mibBuilder.loadTexts: wvIduInternalFaultStart.setDescription('A trap indicating Idu internal fail: RX or TX synthesizer out of lock or power supply fail')
wvIduInternalFaultStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 4)).setObjects(("CODAN-MIB", "wvIduStatus"))
if mibBuilder.loadTexts: wvIduInternalFaultStop.setStatus('current')
if mibBuilder.loadTexts: wvIduInternalFaultStop.setDescription('A trap indicating restoring from wvIduInternalFaultStart')
wvOduInternalFaultStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 5)).setObjects(("CODAN-MIB", "wvOduStatus"))
if mibBuilder.loadTexts: wvOduInternalFaultStart.setStatus('current')
if mibBuilder.loadTexts: wvOduInternalFaultStart.setDescription('A trap indicating Odu internal fail: RX or TX synthesizer out of lock or power supply fail')
wvOduInternalFaultStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 6)).setObjects(("CODAN-MIB", "wvOduStatus"))
if mibBuilder.loadTexts: wvOduInternalFaultStop.setStatus('current')
if mibBuilder.loadTexts: wvOduInternalFaultStop.setDescription('A trap indicating restoring from wvOduInternalFaultStart')
wvLinkDownStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 7)).setObjects(("CODAN-MIB", "wvLinkPerformanceAlarmsStatus"))
if mibBuilder.loadTexts: wvLinkDownStart.setStatus('current')
if mibBuilder.loadTexts: wvLinkDownStart.setDescription('A trap indicating that MUX or MODEM is not synchronized ')
wvLinkDownStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 8)).setObjects(("CODAN-MIB", "wvLinkPerformanceAlarmsStatus"))
if mibBuilder.loadTexts: wvLinkDownStop.setStatus('current')
if mibBuilder.loadTexts: wvLinkDownStop.setDescription('A trap indicating restoring from wvLinkDownStart')
wvIdViolationStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 9)).setObjects(("CODAN-MIB", "wvSecurityStatus"))
if mibBuilder.loadTexts: wvIdViolationStart.setStatus('current')
if mibBuilder.loadTexts: wvIdViolationStart.setDescription('A trap indicating that the last received peer Link ID does not match the local Link ID')
wvIdViolationStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 10)).setObjects(("CODAN-MIB", "wvSecurityStatus"))
if mibBuilder.loadTexts: wvIdViolationStop.setStatus('current')
if mibBuilder.loadTexts: wvIdViolationStop.setDescription('A trap indicating restoring from wvIdViolationStart')
wvRemoteAccessStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 11)).setObjects(("CODAN-MIB", "wvRemoteTerminalStatus"))
if mibBuilder.loadTexts: wvRemoteAccessStart.setStatus('current')
if mibBuilder.loadTexts: wvRemoteAccessStart.setDescription('A trap indicating that the remote terminal is not accessable')
wvRemoteAccessStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 12)).setObjects(("CODAN-MIB", "wvRemoteTerminalStatus"))
if mibBuilder.loadTexts: wvRemoteAccessStop.setStatus('current')
if mibBuilder.loadTexts: wvRemoteAccessStop.setDescription('A trap indicating restoring from wvRemoteAccessStart')
wvLocalOduAccessStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 13)).setObjects(("CODAN-MIB", "wvOduStatus"))
if mibBuilder.loadTexts: wvLocalOduAccessStart.setStatus('current')
if mibBuilder.loadTexts: wvLocalOduAccessStart.setDescription('A trap indicating that the local Odu is not responding')
wvLocalOduAccessStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 14)).setObjects(("CODAN-MIB", "wvOduStatus"))
if mibBuilder.loadTexts: wvLocalOduAccessStop.setStatus('current')
if mibBuilder.loadTexts: wvLocalOduAccessStop.setDescription('A trap indicating restoring from wvLocalOduAccessStart')
wvReceiveSignalLowerLevelStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 15)).setObjects(("CODAN-MIB", "wvRxSignalLevel"), ("CODAN-MIB", "wvAtpcRslLowerThreshold"))
if mibBuilder.loadTexts: wvReceiveSignalLowerLevelStart.setStatus('current')
if mibBuilder.loadTexts: wvReceiveSignalLowerLevelStart.setDescription('A trap indicating that the local RSL is out of the lower range')
wvReceiveSignalLowerLevelStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 16)).setObjects(("CODAN-MIB", "wvRxSignalLevel"), ("CODAN-MIB", "wvAtpcRslLowerThreshold"))
if mibBuilder.loadTexts: wvReceiveSignalLowerLevelStop.setStatus('current')
if mibBuilder.loadTexts: wvReceiveSignalLowerLevelStop.setDescription('A trap indicating restoring from wvReceiveSignalLowerLevelStart')
wvRelayStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 17)).setObjects(("CODAN-MIB", "wvRelayIdTrap"))
if mibBuilder.loadTexts: wvRelayStart.setStatus('current')
if mibBuilder.loadTexts: wvRelayStart.setDescription('A trap indicating that the relay was switched to on')
wvRelayStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 18)).setObjects(("CODAN-MIB", "wvRelayIdTrap"))
if mibBuilder.loadTexts: wvRelayStop.setStatus('current')
if mibBuilder.loadTexts: wvRelayStop.setDescription('A trap indicating that the relay was switched to off ')
wvLineAisStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 19)).setObjects(("CODAN-MIB", "wvAisPortTrap"))
if mibBuilder.loadTexts: wvLineAisStart.setStatus('current')
if mibBuilder.loadTexts: wvLineAisStart.setDescription('A trap indicating that the port transmit AIS')
wvLineAisStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 20)).setObjects(("CODAN-MIB", "wvAisPortTrap"))
if mibBuilder.loadTexts: wvLineAisStop.setStatus('current')
if mibBuilder.loadTexts: wvLineAisStop.setDescription('A trap indicating restoring from wvLineAisStart')
wvLineLosStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 21)).setObjects(("CODAN-MIB", "wvLosPortTrap"))
if mibBuilder.loadTexts: wvLineLosStart.setStatus('current')
if mibBuilder.loadTexts: wvLineLosStart.setDescription('A trap indicating that there is an LOS on the specified line')
wvLineLosStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 22)).setObjects(("CODAN-MIB", "wvLosPortTrap"))
if mibBuilder.loadTexts: wvLineLosStop.setStatus('current')
if mibBuilder.loadTexts: wvLineLosStop.setDescription('A trap indicating restoring from wvLineLosStart')
wvBerWarningStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 23)).setObjects(("CODAN-MIB", "wvlinkBER"), ("CODAN-MIB", "wvLinkBERWarningThresholdLow"), ("CODAN-MIB", "wvLinkBERWarningThresholdHigh"))
if mibBuilder.loadTexts: wvBerWarningStart.setStatus('current')
if mibBuilder.loadTexts: wvBerWarningStart.setDescription('A trap indicating that the local BER is out of range')
wvBerWarningStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 24)).setObjects(("CODAN-MIB", "wvlinkBER"), ("CODAN-MIB", "wvLinkBERWarningThresholdLow"), ("CODAN-MIB", "wvLinkBERWarningThresholdHigh"))
if mibBuilder.loadTexts: wvBerWarningStop.setStatus('current')
if mibBuilder.loadTexts: wvBerWarningStop.setDescription('A trap indicating restoring from wvBerStart')
wvBerFatalStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 25)).setObjects(("CODAN-MIB", "wvlinkBER"), ("CODAN-MIB", "wvLinkBERErrorThresholdLow"), ("CODAN-MIB", "wvLinkBERErrorThresholdHigh"))
if mibBuilder.loadTexts: wvBerFatalStart.setStatus('current')
if mibBuilder.loadTexts: wvBerFatalStart.setDescription('A trap indicating that the local BER is out of range')
wvBerFatalStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 26)).setObjects(("CODAN-MIB", "wvlinkBER"), ("CODAN-MIB", "wvLinkBERErrorThresholdLow"), ("CODAN-MIB", "wvLinkBERErrorThresholdHigh"))
if mibBuilder.loadTexts: wvBerFatalStop.setStatus('current')
if mibBuilder.loadTexts: wvBerFatalStop.setDescription('A trap indicating restoring from wvBerStart')
wvExternalInputsStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 27)).setObjects(("CODAN-MIB", "wvExternalInputTrap"))
if mibBuilder.loadTexts: wvExternalInputsStart.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputsStart.setDescription('A trap indicating that the external input is active')
wvExternalInputsStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 28)).setObjects(("CODAN-MIB", "wvExternalInputTrap"))
if mibBuilder.loadTexts: wvExternalInputsStop.setStatus('current')
if mibBuilder.loadTexts: wvExternalInputsStop.setDescription('A trap indicating restoring from wvExternalInputsStart')
wvLinkUasStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 29)).setObjects(("CODAN-MIB", "wvLinkUAs"), ("CODAN-MIB", "wvLinkUASAlarmThresholdLow"), ("CODAN-MIB", "wvLinkUASAlarmThresholdHigh"))
if mibBuilder.loadTexts: wvLinkUasStart.setStatus('current')
if mibBuilder.loadTexts: wvLinkUasStart.setDescription('A trap indicating that the link UAS is out of range')
wvLinkUasStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 30)).setObjects(("CODAN-MIB", "wvLinkUAs"), ("CODAN-MIB", "wvLinkUASAlarmThresholdLow"), ("CODAN-MIB", "wvLinkUASAlarmThresholdHigh"))
if mibBuilder.loadTexts: wvLinkUasStop.setStatus('current')
if mibBuilder.loadTexts: wvLinkUasStop.setDescription('A trap indicating restoring from wvLinkUasStart')
wvTftpFail = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 31)).setObjects(("CODAN-MIB", "wvTftpServerIpAddress"), ("CODAN-MIB", "wvTftpOperationCtrl"), ("CODAN-MIB", "wvTftpFileName"), ("CODAN-MIB", "wvTftpDwnlStatus"))
if mibBuilder.loadTexts: wvTftpFail.setStatus('current')
if mibBuilder.loadTexts: wvTftpFail.setDescription('A trap indicating that there was TFTP operation fault')
wvTftpSuccess = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 32)).setObjects(("CODAN-MIB", "wvTftpServerIpAddress"), ("CODAN-MIB", "wvTftpOperationCtrl"), ("CODAN-MIB", "wvTftpFileName"), ("CODAN-MIB", "wvTftpDwnlStatus"))
if mibBuilder.loadTexts: wvTftpSuccess.setStatus('current')
if mibBuilder.loadTexts: wvTftpSuccess.setDescription('A trap indicating that the last TFTP operation was successful')
wvOduTempViolationStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 33)).setObjects(("CODAN-MIB", "wvOduTemperature"))
if mibBuilder.loadTexts: wvOduTempViolationStart.setStatus('current')
if mibBuilder.loadTexts: wvOduTempViolationStart.setDescription('A trap indicating that the ODU temperature is out of range')
wvOduTempViolationStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 34)).setObjects(("CODAN-MIB", "wvOduTemperature"))
if mibBuilder.loadTexts: wvOduTempViolationStop.setStatus('current')
if mibBuilder.loadTexts: wvOduTempViolationStop.setDescription('A trap indicating restoring from wvOduTempViolationStart')
wvOduTxMuteStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 35)).setObjects(("CODAN-MIB", "wvOduStatus"))
if mibBuilder.loadTexts: wvOduTxMuteStart.setStatus('current')
if mibBuilder.loadTexts: wvOduTxMuteStart.setDescription('A trap indicating that the ODU transmitter is in mute state')
wvOduTxMuteStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 36)).setObjects(("CODAN-MIB", "wvOduStatus"))
if mibBuilder.loadTexts: wvOduTxMuteStop.setStatus('current')
if mibBuilder.loadTexts: wvOduTxMuteStop.setDescription('A trap indicating restoring from wvOduTxMuteStart')
wvIduPowerSupplyStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 37)).setObjects(("CODAN-MIB", "wvIduStatus"))
if mibBuilder.loadTexts: wvIduPowerSupplyStart.setStatus('current')
if mibBuilder.loadTexts: wvIduPowerSupplyStart.setDescription('A trap indicating that theIDU ha power supply problems')
wvIduPowerSupplyStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 38)).setObjects(("CODAN-MIB", "wvIduStatus"))
if mibBuilder.loadTexts: wvIduPowerSupplyStop.setStatus('current')
if mibBuilder.loadTexts: wvIduPowerSupplyStop.setDescription('A trap indicating restoring from wvIduPowerSupplyStart')
wvIduConfigurationMismatch = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 39))
if mibBuilder.loadTexts: wvIduConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: wvIduConfigurationMismatch.setDescription("A trap indicating that the IDU's configuration does not match the current hardware")
wvIduBankSwitchover = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 40))
if mibBuilder.loadTexts: wvIduBankSwitchover.setStatus('current')
if mibBuilder.loadTexts: wvIduBankSwitchover.setDescription('A trap indicating that the bank switchover had occured')
wvIduPortLoopbackStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 41)).setObjects(("CODAN-MIB", "wvIduStatus"))
if mibBuilder.loadTexts: wvIduPortLoopbackStart.setStatus('current')
if mibBuilder.loadTexts: wvIduPortLoopbackStart.setDescription('A trap indicating that the corresponding poer is in loopback state')
wvIduPortLoopbackStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 42)).setObjects(("CODAN-MIB", "wvIduStatus"))
if mibBuilder.loadTexts: wvIduPortLoopbackStop.setStatus('current')
if mibBuilder.loadTexts: wvIduPortLoopbackStop.setDescription('A trap indicating restoring from wvIduPortLoopbackStart')
wvIduPortBertStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 43)).setObjects(("CODAN-MIB", "wvIduStatus"))
if mibBuilder.loadTexts: wvIduPortBertStart.setStatus('current')
if mibBuilder.loadTexts: wvIduPortBertStart.setDescription('A trap indicating that the corresponding poer is in loopback state')
wvIduPortBertStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 44)).setObjects(("CODAN-MIB", "wvIduStatus"))
if mibBuilder.loadTexts: wvIduPortBertStop.setStatus('current')
if mibBuilder.loadTexts: wvIduPortBertStop.setDescription('A trap indicating restoring from wvIduPortBertStart')
wvIduHeartBit = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 45)).setObjects(("CODAN-MIB", "wvTrapKeepAliveString"))
if mibBuilder.loadTexts: wvIduHeartBit.setStatus('current')
if mibBuilder.loadTexts: wvIduHeartBit.setDescription(' Serial Numbers: Odu, Idu; HeartBit Values ( string): A HeartBit trap ')
wvAisReceiveStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 46)).setObjects(("CODAN-MIB", "wvAisPortTrap"))
if mibBuilder.loadTexts: wvAisReceiveStart.setStatus('current')
if mibBuilder.loadTexts: wvAisReceiveStart.setDescription('A trap indicating that the port receives AIS')
wvAisReceiveStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 47)).setObjects(("CODAN-MIB", "wvAisPortTrap"))
if mibBuilder.loadTexts: wvAisReceiveStop.setStatus('current')
if mibBuilder.loadTexts: wvAisReceiveStop.setDescription('A trap indicating restoring from wvAisReceiveStart')
wlEth10x100RxLinkUsageLowStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 48)).setObjects(("CODAN-MIB", "wvEth10_100RxLinkUsage"), ("CODAN-MIB", "wvEth10_100RxLinkUsageAlarmThresholdLow"))
if mibBuilder.loadTexts: wlEth10x100RxLinkUsageLowStart.setStatus('current')
if mibBuilder.loadTexts: wlEth10x100RxLinkUsageLowStart.setDescription('A trap indicating that the Rx Link Usage is out of low range')
wlEth10x100RxLinkUsageLowStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 49)).setObjects(("CODAN-MIB", "wvEth10_100RxLinkUsage"), ("CODAN-MIB", "wvEth10_100RxLinkUsageAlarmThresholdLow"))
if mibBuilder.loadTexts: wlEth10x100RxLinkUsageLowStop.setStatus('current')
if mibBuilder.loadTexts: wlEth10x100RxLinkUsageLowStop.setDescription('A trap indicating that the Rx Link Usage is in low range')
wlEth10x100RxLinkUsageHighStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 50)).setObjects(("CODAN-MIB", "wvEth10_100RxLinkUsage"), ("CODAN-MIB", "wvEth10_100RxLinkUsageAlarmThresholdHigh"))
if mibBuilder.loadTexts: wlEth10x100RxLinkUsageHighStart.setStatus('current')
if mibBuilder.loadTexts: wlEth10x100RxLinkUsageHighStart.setDescription('A trap indicating that the Rx Link Usage is out of High range')
wlEth10x100RxLinkUsageHighStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 51)).setObjects(("CODAN-MIB", "wvEth10_100RxLinkUsage"), ("CODAN-MIB", "wvEth10_100RxLinkUsageAlarmThresholdHigh"))
if mibBuilder.loadTexts: wlEth10x100RxLinkUsageHighStop.setStatus('current')
if mibBuilder.loadTexts: wlEth10x100RxLinkUsageHighStop.setDescription('A trap indicating that the Rx Link Usage is in High range')
wlEth10x100TxLinkUsageLowStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 52)).setObjects(("CODAN-MIB", "wvEth10_100TxLinkUsage"), ("CODAN-MIB", "wvEth10_100TxLinkUsageAlarmThresholdLow"))
if mibBuilder.loadTexts: wlEth10x100TxLinkUsageLowStart.setStatus('current')
if mibBuilder.loadTexts: wlEth10x100TxLinkUsageLowStart.setDescription('A trap indicating that the Tx Link Usage is out of Low range')
wlEth10x100TxLinkUsageLowStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 53)).setObjects(("CODAN-MIB", "wvEth10_100TxLinkUsage"), ("CODAN-MIB", "wvEth10_100TxLinkUsageAlarmThresholdLow"))
if mibBuilder.loadTexts: wlEth10x100TxLinkUsageLowStop.setStatus('current')
if mibBuilder.loadTexts: wlEth10x100TxLinkUsageLowStop.setDescription('A trap indicating that the Tx Link Usage is in Low range')
wlEth10x100TxLinkUsageHighStart = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 54)).setObjects(("CODAN-MIB", "wvEth10_100TxLinkUsage"), ("CODAN-MIB", "wvEth10_100TxLinkUsageAlarmThresholdHigh"))
if mibBuilder.loadTexts: wlEth10x100TxLinkUsageHighStart.setStatus('current')
if mibBuilder.loadTexts: wlEth10x100TxLinkUsageHighStart.setDescription('A trap indicating that the Tx Link Usage is out of High range')
wlEth10x100TxLinkUsageHighStop = NotificationType((1, 3, 6, 1, 4, 1, 23304, 1, 1, 10, 0, 55)).setObjects(("CODAN-MIB", "wvEth10_100TxLinkUsage"), ("CODAN-MIB", "wvEth10_100TxLinkUsageAlarmThresholdHigh"))
if mibBuilder.loadTexts: wlEth10x100TxLinkUsageHighStop.setStatus('current')
if mibBuilder.loadTexts: wlEth10x100TxLinkUsageHighStop.setDescription('A trap indicating that the Tx Link Usage is in High range')
mibBuilder.exportSymbols("CODAN-MIB", wvLosPortTrap=wvLosPortTrap, wvPeerSlipInIPSubnetMask=wvPeerSlipInIPSubnetMask, wvEth10_100IMREAlarmThresholdhHigh=wvEth10_100IMREAlarmThresholdhHigh, wvTelemetryStatus=wvTelemetryStatus, wvSelfTestRemainingStartTime=wvSelfTestRemainingStartTime, wvComponentsRevisions=wvComponentsRevisions, wvOduLastSwUpdateTime=wvOduLastSwUpdateTime, wvExternalInputEntry=wvExternalInputEntry, wvDialPrefixString=wvDialPrefixString, wvLinkUasStop=wvLinkUasStop, wlEth10x100RxLinkUsageHighStop=wlEth10x100RxLinkUsageHighStop, wvEth10_100PortCtrl=wvEth10_100PortCtrl, wvIduPortBertStart=wvIduPortBertStart, wvEth10_100TxLinkUsageAlarmThresholdLow=wvEth10_100TxLinkUsageAlarmThresholdLow, wvUserRoutesTable=wvUserRoutesTable, wvAtpcTimeOutAlarm=wvAtpcTimeOutAlarm, wvLoopbackStartTime=wvLoopbackStartTime, wvLastTestSignalBER=wvLastTestSignalBER, wvLinkSettings=wvLinkSettings, wvRs232PortType=wvRs232PortType, wvTransmitterMute=wvTransmitterMute, wvlinkMaximumRSL=wvlinkMaximumRSL, wvlinkBER=wvlinkBER, wvSwModuleEntry=wvSwModuleEntry, wvTributaryPortConnectionsMode=wvTributaryPortConnectionsMode, wvLinkESAlarmThresholdLow=wvLinkESAlarmThresholdLow, wvLinkCapacity=wvLinkCapacity, wvLinkBBERAlarmThresholdHigh=wvLinkBBERAlarmThresholdHigh, wvInterfaces=wvInterfaces, wvSlipInDestIPSubnetMask=wvSlipInDestIPSubnetMask, wvIduConfigurationMismatch=wvIduConfigurationMismatch, wvlinkNoOfErrors=wvlinkNoOfErrors, wlEth10x100TxLinkUsageHighStop=wlEth10x100TxLinkUsageHighStop, wvAtpcTimeOutAlarmLevel=wvAtpcTimeOutAlarmLevel, wvRemoteAccessStop=wvRemoteAccessStop, wvForceAis=wvForceAis, wvResetPerformance=wvResetPerformance, wvTxPowerSetting=wvTxPowerSetting, wvRemoteAccessStart=wvRemoteAccessStart, wvLineAisStart=wvLineAisStart, wvFadeMargin=wvFadeMargin, wvLinkUAs=wvLinkUAs, wvOnePlusOneStatus=wvOnePlusOneStatus, wvAtpcTimeOutControl=wvAtpcTimeOutControl, wvSetOperationCtrl=wvSetOperationCtrl, wvLinkPerformanceCountTime=wvLinkPerformanceCountTime, wvEth10_100TxLinkUtilization=wvEth10_100TxLinkUtilization, wvIduPartNo=wvIduPartNo, wvLinkCurrentESs=wvLinkCurrentESs, wvEth10_100CSLAlarmThresholdhLow=wvEth10_100CSLAlarmThresholdhLow, wvTributaryPortInvertedAlarm=wvTributaryPortInvertedAlarm, wvLineAisStop=wvLineAisStop, wvSwModuleIndex=wvSwModuleIndex, wvLineLosStop=wvLineLosStop, wvIpbHwRevision=wvIpbHwRevision, wvRs232PortFlowType=wvRs232PortFlowType, wvTelephoneNumber=wvTelephoneNumber, wvExternalInputsStop=wvExternalInputsStop, wvActivateTerminalConfiguration=wvActivateTerminalConfiguration, wvTrapRecipientsIp=wvTrapRecipientsIp, wvLinkCurrentBLER=wvLinkCurrentBLER, wvAtpcTimeOutTimer=wvAtpcTimeOutTimer, wvPeerSlipInIPAddress=wvPeerSlipInIPAddress, wvResetTerminal=wvResetTerminal, wvSlipOutDestIPAddress=wvSlipOutDestIPAddress, wvLinkSESAlarmThresholdLow=wvLinkSESAlarmThresholdLow, wvEth10_100ChannelSpacing=wvEth10_100ChannelSpacing, wvTraps0=wvTraps0, wvEth10_100IMTEAlarmThresholdhHigh=wvEth10_100IMTEAlarmThresholdhHigh, wvEth10_100CSLAlarmThresholdhHigh=wvEth10_100CSLAlarmThresholdhHigh, wvlinkCurrentMaximumRSL=wvlinkCurrentMaximumRSL, wvMinTxPowerSetting=wvMinTxPowerSetting, wvRs232PortTable=wvRs232PortTable, wvPeerLinkIPSubnetMask=wvPeerLinkIPSubnetMask, wvFrontPanelUserPassword=wvFrontPanelUserPassword, wvInsertTestSignalStartTime=wvInsertTestSignalStartTime, wvEth10_100PortThroughputCtrl=wvEth10_100PortThroughputCtrl, wvDsx3CableLengthRange=wvDsx3CableLengthRange, wvConfigurationChangedStatus=wvConfigurationChangedStatus, wvExternalInputAlarmSeverity=wvExternalInputAlarmSeverity, wvLinkCurrentNCBLER=wvLinkCurrentNCBLER, wvTrapRecipientsTable=wvTrapRecipientsTable, wlEth10x100RxLinkUsageLowStart=wlEth10x100RxLinkUsageLowStart, wvPerformance=wvPerformance, wvOperatingSystemStatus=wvOperatingSystemStatus, wvLogEventDescription=wvLogEventDescription, wvEth10_100ManIPAddress=wvEth10_100ManIPAddress, wvRelayOperation=wvRelayOperation, wvRelayEntry=wvRelayEntry, wvLinkESAlarmThresholdHigh=wvLinkESAlarmThresholdHigh, wvLinkBLERAlarmThresholdHigh=wvLinkBLERAlarmThresholdHigh, wvLinkTotalBER=wvLinkTotalBER, wvModulation=wvModulation, wvRs232AsyncPortBits=wvRs232AsyncPortBits, wvLinkBLERAlarmThresholdLow=wvLinkBLERAlarmThresholdLow, wvlinkNoOfReceivedKBits=wvlinkNoOfReceivedKBits, wvLanIPSubnetMask=wvLanIPSubnetMask, wvLinkDownStart=wvLinkDownStart, wvTests=wvTests, wvInsertTestSignalLine=wvInsertTestSignalLine, wvLinkTotalBLER=wvLinkTotalBLER, wvEth10_100ECAlarmThresholdhHigh=wvEth10_100ECAlarmThresholdhHigh, wvSlipModemStatus=wvSlipModemStatus, wvOemOduSerialNumber=wvOemOduSerialNumber, wvTrapKeepAlivePeriod=wvTrapKeepAlivePeriod, wvOduTempViolationStart=wvOduTempViolationStart, wvRelayNormalState=wvRelayNormalState, wvOnePlusOneCompanionEthIPAddress=wvOnePlusOneCompanionEthIPAddress, wvlinkInstantaneousBER=wvlinkInstantaneousBER, wvlinkTotalMaximumRSL=wvlinkTotalMaximumRSL, wvLinkBERErrorThresholdLow=wvLinkBERErrorThresholdLow, wvTrapKeepAliveVarsSelect=wvTrapKeepAliveVarsSelect, wvOduSerialNumber=wvOduSerialNumber, wvLinkIntervalTable=wvLinkIntervalTable, wvIduStatus=wvIduStatus, wlEth10x100TxLinkUsageHighStart=wlEth10x100TxLinkUsageHighStart, wvAtpcControl=wvAtpcControl, wvRs232PortIndex=wvRs232PortIndex, wvIduHwRevision=wvIduHwRevision, wvSupport2T1and2E1Status=wvSupport2T1and2E1Status, wvLogEventLock=wvLogEventLock, wvCommunityPrivilege=wvCommunityPrivilege, wvRs232PortEntry=wvRs232PortEntry, wvRelays=wvRelays, wvOnePlusOneRequestSwitchOut=wvOnePlusOneRequestSwitchOut, wvFecEnabled=wvFecEnabled, wvTraps=wvTraps, wvTributaryPortIfIndex=wvTributaryPortIfIndex, wvOnePlusOneCompanionLinkIPAddress=wvOnePlusOneCompanionLinkIPAddress, wvSwModuleStandByRev=wvSwModuleStandByRev, wvLinkTotalNCBLER=wvLinkTotalNCBLER, wvLinkIntervalDMs=wvLinkIntervalDMs, wvPeerSlipOutIPSubnetMask=wvPeerSlipOutIPSubnetMask, wvTributaryPortEntry=wvTributaryPortEntry, wvModemAfc=wvModemAfc, wvLocalOduAccessStart=wvLocalOduAccessStart, wvLinkCurrentSESs=wvLinkCurrentSESs, wvEth10_100RxLinkUsageAlarmThresholdHigh=wvEth10_100RxLinkUsageAlarmThresholdHigh, wvExternalInputs=wvExternalInputs, wvWorkingFrequency=wvWorkingFrequency, wvRs232PortSpeed=wvRs232PortSpeed, wvAtpcRslLowerThreshold=wvAtpcRslLowerThreshold, wvLinkPerformanceAlarmsStatus=wvLinkPerformanceAlarmsStatus, wvLinkDMAlarmThresholdHigh=wvLinkDMAlarmThresholdHigh, wvLastSelfTestEntry=wvLastSelfTestEntry, wvLinkBBERAlarmThresholdLow=wvLinkBBERAlarmThresholdLow, wvIduPowerSupplyStop=wvIduPowerSupplyStop, wvlinkIntervalMaximumRSL=wvlinkIntervalMaximumRSL, wvSwModuleName=wvSwModuleName, wvLinkDMAlarmThresholdLow=wvLinkDMAlarmThresholdLow, wvTrapRecipientsId=wvTrapRecipientsId, wvLinkThresholdMeasurementInterval=wvLinkThresholdMeasurementInterval, wvUserRoutesEntry=wvUserRoutesEntry, wvUserRoutesIndex=wvUserRoutesIndex, wvSelfTestStartTime=wvSelfTestStartTime, wvLinkIntervalBER=wvLinkIntervalBER, wvRelayStart=wvRelayStart, wvRelayStop=wvRelayStop, wvlinkCurrentMinimumRSL=wvlinkCurrentMinimumRSL, wvOduSwRevision=wvOduSwRevision, wvLinkRouteDescription=wvLinkRouteDescription, wvlinkAverageRSLLowAlarmThresholdhHigh=wvlinkAverageRSLLowAlarmThresholdhHigh, wvOemIduSerialNumber=wvOemIduSerialNumber, wvTrapRecipientsEntry=wvTrapRecipientsEntry, wvInitString=wvInitString, wvLocalOduAccessStop=wvLocalOduAccessStop, wvInsertTestSignalTimePeriod=wvInsertTestSignalTimePeriod, wvFecNoOfCorrectableBytes=wvFecNoOfCorrectableBytes, wvAlarmControl=wvAlarmControl, wvFrontPanelAdminPassword=wvFrontPanelAdminPassword, wvBerFatalStop=wvBerFatalStop, wvDisableAtpcInTimeOutAlarm=wvDisableAtpcInTimeOutAlarm, wvLinkIntervalBBER=wvLinkIntervalBBER, wvLinkDMs=wvLinkDMs, wvSecurityStatus=wvSecurityStatus, wvIduHeartBit=wvIduHeartBit, wvSavedActiveConfiguration=wvSavedActiveConfiguration, wvLoopbackType=wvLoopbackType, wvlinkMinimumRSL=wvlinkMinimumRSL, wvLogEventEntry=wvLogEventEntry, wvLinkIntervalNumber=wvLinkIntervalNumber, wvSetOperationId=wvSetOperationId, wvCommunityId=wvCommunityId, wvSlipOutIPAddress=wvSlipOutIPAddress, wvLogEventsElapsed=wvLogEventsElapsed, wvRelayId=wvRelayId, wvClearAlarmLog=wvClearAlarmLog, wvSlipInDestIPAddress=wvSlipInDestIPAddress, wvGenericDiagnosticsParameterAddress=wvGenericDiagnosticsParameterAddress, wvChannelNo=wvChannelNo, wvGenericDiagnosticsParameterValue=wvGenericDiagnosticsParameterValue, wvEth10_100ThresholdMeasurementInterval=wvEth10_100ThresholdMeasurementInterval, wvManagement=wvManagement, wvLastSelfTestTable=wvLastSelfTestTable, wvOduPartNo=wvOduPartNo, wvAtpcRslOptimalValue=wvAtpcRslOptimalValue, wvRelayToRemoteAlarmMapping=wvRelayToRemoteAlarmMapping, wvOduHwRevision=wvOduHwRevision, wvTributaryPortName=wvTributaryPortName, wvFrontPanelSupervisorPassword=wvFrontPanelSupervisorPassword, wvMaxTxPowerSetting=wvMaxTxPowerSetting, wvLinkTotalDMs=wvLinkTotalDMs, wvReceiveSignalLowerLevelStart=wvReceiveSignalLowerLevelStart, wvAisPortTrap=wvAisPortTrap, wvUserRoutesType=wvUserRoutesType, wvPauseTransmitterControl=wvPauseTransmitterControl, wvEth10_100SysCtrl=wvEth10_100SysCtrl, wvLogEventTable=wvLogEventTable, wvExternalInputsStart=wvExternalInputsStart, wvIduAlternetSwRevision=wvIduAlternetSwRevision, wvUserRoutesManagement=wvUserRoutesManagement, wlEth10x100RxLinkUsageLowStop=wlEth10x100RxLinkUsageLowStop, WvAlarmsList=WvAlarmsList, FloatingPoint=FloatingPoint, wvSelectTrapVector=wvSelectTrapVector, wvIduSwRevision=wvIduSwRevision, wvReceiverMute=wvReceiverMute, wvLinkTotalESs=wvLinkTotalESs, wvEth10_100AvailCapacity=wvEth10_100AvailCapacity, wvTftpServerIpAddress=wvTftpServerIpAddress, wvlinkIntervalAverageRSL=wvlinkIntervalAverageRSL, wvAtpcRslUpperThreshold=wvAtpcRslUpperThreshold, wvEth10_100PortIfIndex=wvEth10_100PortIfIndex, wvLinkCurrentBER=wvLinkCurrentBER, wvPeerEth10_100ManIPSubnetMask=wvPeerEth10_100ManIPSubnetMask, wvActivateTerminalConfigurationTime=wvActivateTerminalConfigurationTime, wvAisReceiveStop=wvAisReceiveStop, wvTftpStartTime=wvTftpStartTime, wvSlipOutDestIPSubnetMask=wvSlipOutDestIPSubnetMask, wvUpdateTerminalConfiguration=wvUpdateTerminalConfiguration, wvLinkIntervalUASs=wvLinkIntervalUASs, wvIduPortBertStop=wvIduPortBertStop, wvInsertTestSignalRemainingStartTime=wvInsertTestSignalRemainingStartTime, wvLinkIPSubnetMask=wvLinkIPSubnetMask, wvlinkRSLLowAlarmThresholdhHigh=wvlinkRSLLowAlarmThresholdhHigh, wvLinkIntervalEntry=wvLinkIntervalEntry, wvlinkTotalAverageRSL=wvlinkTotalAverageRSL, wvTftpFileName=wvTftpFileName, wvlinkRSLLowAlarmThresholdhLow=wvlinkRSLLowAlarmThresholdhLow, wvLog=wvLog, wvBerWarningStop=wvBerWarningStop, wvLoopbackRemainingTimePeriod=wvLoopbackRemainingTimePeriod, wvlinkTotalMinimumRSL=wvlinkTotalMinimumRSL, wvTftpNoOfRetries=wvTftpNoOfRetries, wvAisReceiveStart=wvAisReceiveStart, wvEth10_100ECAlarmThresholdhLow=wvEth10_100ECAlarmThresholdhLow, wvOduTxMuteStart=wvOduTxMuteStart, wvPeerSlipOutIPAddress=wvPeerSlipOutIPAddress, wvLedState=wvLedState, wvOduTemperature=wvOduTemperature, wvLastSelfTestType=wvLastSelfTestType, wvLoopbackTimePeriod=wvLoopbackTimePeriod, wvIduBankSwitchover=wvIduBankSwitchover, wvOduTxMuteStop=wvOduTxMuteStop)
mibBuilder.exportSymbols("CODAN-MIB", wvLinkSESs=wvLinkSESs, wvIduPortLoopbackStart=wvIduPortLoopbackStart, wvOduStatus=wvOduStatus, wvTftpDwnlStatus=wvTftpDwnlStatus, wvLinkValidIntervals=wvLinkValidIntervals, wvlinkNotCorrectedErroredBlocks=wvlinkNotCorrectedErroredBlocks, wvLinkDownStop=wvLinkDownStop, wvLinkBERWarningThresholdLow=wvLinkBERWarningThresholdLow, wlEth10x100RxLinkUsageHighStart=wlEth10x100RxLinkUsageHighStart, wvEth10_100ManIPSubnetMask=wvEth10_100ManIPSubnetMask, wvFecReceiveCorrection=wvFecReceiveCorrection, wvLinkCurrentBBER=wvLinkCurrentBBER, wvUserRoutesHop=wvUserRoutesHop, wvE1BNC75ohm=wvE1BNC75ohm, wvSlipInIPSubnetMask=wvSlipInIPSubnetMask, wvFrequencyBand=wvFrequencyBand, wvInstalledOemPlugInPartNo=wvInstalledOemPlugInPartNo, wvEth10_100TxLinkUsage=wvEth10_100TxLinkUsage, wvConfiguration=wvConfiguration, wvOduTempViolationStop=wvOduTempViolationStop, wlEth10x100TxLinkUsageLowStart=wlEth10x100TxLinkUsageLowStart, wvLastUpdateConfigurationTimestamp=wvLastUpdateConfigurationTimestamp, wvLastSelfTestStartTime=wvLastSelfTestStartTime, wvOnePlusOneConnectorType=wvOnePlusOneConnectorType, wvPauseTransmitterTime=wvPauseTransmitterTime, wvTftpFail=wvTftpFail, wvSelfTestType=wvSelfTestType, wvIduOduCableFaultStop=wvIduOduCableFaultStop, wvLinkUasStart=wvLinkUasStart, wvResetOdu=wvResetOdu, wvLinkIPAddress=wvLinkIPAddress, wvRemoteTerminalStatus=wvRemoteTerminalStatus, wvUserRoutesDest=wvUserRoutesDest, wvTributaryPortConnection=wvTributaryPortConnection, wvOduInternalFaultStop=wvOduInternalFaultStop, wvSlipOutIPSubnetMask=wvSlipOutIPSubnetMask, wvRs232AsyncPortStopBits=wvRs232AsyncPortStopBits, wvIduOduCableStatus=wvIduOduCableStatus, wvlinkBBER=wvlinkBBER, wvBerWarningStart=wvBerWarningStart, wvEth10_100RxLinkUtilization=wvEth10_100RxLinkUtilization, wlEth10x100TxLinkUsageLowStop=wlEth10x100TxLinkUsageLowStop, wvRs232AsyncPortParity=wvRs232AsyncPortParity, wvIduPortLoopbackStop=wvIduPortLoopbackStop, wvlinkNCBLER=wvlinkNCBLER, wvInsertTestSignalRemainingTimePeriod=wvInsertTestSignalRemainingTimePeriod, wvlinkCurrentTimeElapsed=wvlinkCurrentTimeElapsed, wvUserRoutesMask=wvUserRoutesMask, wvSetOperationOwner=wvSetOperationOwner, wvIduSerialNumber=wvIduSerialNumber, FrontPanelPassword=FrontPanelPassword, wvOemIduPartNo=wvOemIduPartNo, wvTftpOperationCtrl=wvTftpOperationCtrl, wvExternalInputSetting=wvExternalInputSetting, wvLinkESs=wvLinkESs, wvUserRoutesCount=wvUserRoutesCount, wvChannelSpacing=wvChannelSpacing, wvlinkAverageRSLLowAlarmThresholdhLow=wvlinkAverageRSLLowAlarmThresholdhLow, wvLinkId=wvLinkId, wvIduLastSwUpdateTime=wvIduLastSwUpdateTime, wvlinkBLER=wvlinkBLER, wvExternalInputStatus=wvExternalInputStatus, wvExternalInputSense=wvExternalInputSense, wvLinkNCBLERAlarmThresholdHigh=wvLinkNCBLERAlarmThresholdHigh, wvExternalInputTable=wvExternalInputTable, wvCommunityName=wvCommunityName, wvLinkUASAlarmThresholdLow=wvLinkUASAlarmThresholdLow, minetMIB=minetMIB, wvIduInternalFaultStop=wvIduInternalFaultStop, wvAlarmsReportToLCDCtrl=wvAlarmsReportToLCDCtrl, wvPeerEth10_100ManIPAddress=wvPeerEth10_100ManIPAddress, wvRelayTable=wvRelayTable, wvlinkErroredBlocks=wvlinkErroredBlocks, wvOemOduPartNo=wvOemOduPartNo, wvIduOduCableFaultStart=wvIduOduCableFaultStart, wvEth10_100IMREAlarmThresholdhLow=wvEth10_100IMREAlarmThresholdhLow, wvExternalInputTrap=wvExternalInputTrap, wvEth10_100TxLinkUsageAlarmThresholdHigh=wvEth10_100TxLinkUsageAlarmThresholdHigh, wvRelayStatus=wvRelayStatus, wvLinkIntervalNCBLER=wvLinkIntervalNCBLER, wvEth10_100RxLinkUsage=wvEth10_100RxLinkUsage, wvOemId=wvOemId, wvPeerLinkIPAddress=wvPeerLinkIPAddress, wvInstalledPlugInHwRevision=wvInstalledPlugInHwRevision, wvSlipConnection=wvSlipConnection, wvRelayActivate=wvRelayActivate, wvLinkCurrentUASs=wvLinkCurrentUASs, wvLinkTotalUASs=wvLinkTotalUASs, wvSwModuleStandByCS=wvSwModuleStandByCS, wvLinkNCBLERAlarmThresholdLow=wvLinkNCBLERAlarmThresholdLow, wvEth10_100PortClearStats=wvEth10_100PortClearStats, wvRelayIdTrap=wvRelayIdTrap, wvSwModuleActiveCS=wvSwModuleActiveCS, wvTrapVars=wvTrapVars, wvLineLosStart=wvLineLosStart, wvSwModuleActiveRev=wvSwModuleActiveRev, wvEth10_100PortTable=wvEth10_100PortTable, wvlinkIntervalMinimumRSL=wvlinkIntervalMinimumRSL, wvNoOfAlertsOnLCD=wvNoOfAlertsOnLCD, wvLastTestSignalTime=wvLastTestSignalTime, wvLinkIntervalESs=wvLinkIntervalESs, wvTributaryPortTable=wvTributaryPortTable, wvInstalledPlugInPartNo=wvInstalledPlugInPartNo, wvTxPowerLevel=wvTxPowerLevel, wvBootSwRevision=wvBootSwRevision, wvUserRoutesIf=wvUserRoutesIf, wvEth10_100IMTEAlarmThresholdhLow=wvEth10_100IMTEAlarmThresholdhLow, wvLinkTotalSESs=wvLinkTotalSESs, wvTftpSuccess=wvTftpSuccess, wvEth10_100PortEntry=wvEth10_100PortEntry, wvPeerLanIPSubnetMask=wvPeerLanIPSubnetMask, wvLinkUASAlarmThresholdHigh=wvLinkUASAlarmThresholdHigh, wvSwModuleTable=wvSwModuleTable, wvLastSelfTestStatus=wvLastSelfTestStatus, wvLinkSESAlarmThresholdHigh=wvLinkSESAlarmThresholdHigh, wvIdViolationStart=wvIdViolationStart, wvLogEventTime=wvLogEventTime, wvRxSignalLevel=wvRxSignalLevel, wvStatusAndGauges=wvStatusAndGauges, wvCommunityEntry=wvCommunityEntry, wvIdViolationStop=wvIdViolationStop, wvExternalInputId=wvExternalInputId, wvLogEventStatus=wvLogEventStatus, wvTftpRemainingStartTime=wvTftpRemainingStartTime, wvLinkCurrentDMs=wvLinkCurrentDMs, wvEth10_100SysAgingTime=wvEth10_100SysAgingTime, wvPeerLanIPAddress=wvPeerLanIPAddress, wvLinkTotalBBER=wvLinkTotalBBER, wvLinkBERWarningThresholdHigh=wvLinkBERWarningThresholdHigh, wvLinkIntervalSESs=wvLinkIntervalSESs, wvLoopbackRemainingStartTime=wvLoopbackRemainingStartTime, wvSlipInIPAddress=wvSlipInIPAddress, wvlinkCurrentAverageRSL=wvlinkCurrentAverageRSL, wvLinkIntervalBLER=wvLinkIntervalBLER, wvIduInternalFaultStart=wvIduInternalFaultStart, WvLoopbacksList=WvLoopbacksList, wvCommunityTable=wvCommunityTable, ComponentRevision=ComponentRevision, wvlinkAverageRSL=wvlinkAverageRSL, wvIduPowerSupplyStart=wvIduPowerSupplyStart, wvRelayToLocalAlarmMapping=wvRelayToLocalAlarmMapping, wvBerFatalStart=wvBerFatalStart, wvAlarmsReportToNMSCtrl=wvAlarmsReportToNMSCtrl, wvLinkName=wvLinkName, PYSNMP_MODULE_ID=minetMIB, wvEth10_100PortStatus=wvEth10_100PortStatus, wvRxPllFrequency=wvRxPllFrequency, wvOduInternalFaultStart=wvOduInternalFaultStart, wvEth10_100RxLinkUsageAlarmThresholdLow=wvEth10_100RxLinkUsageAlarmThresholdLow, wvTrapKeepAliveString=wvTrapKeepAliveString, wvEnableSpaceDiversity=wvEnableSpaceDiversity, wvLanIPAddress=wvLanIPAddress, wvOperatingFrequency=wvOperatingFrequency, wvReceiveSignalLowerLevelStop=wvReceiveSignalLowerLevelStop, wvLinkBERErrorThresholdHigh=wvLinkBERErrorThresholdHigh)

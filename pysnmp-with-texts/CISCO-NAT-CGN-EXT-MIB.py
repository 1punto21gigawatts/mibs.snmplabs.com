#
# PySNMP MIB module CISCO-NAT-CGN-EXT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-NAT-CGN-EXT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:08:13 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
natInstanceIndex, NatPoolingType, natCountersEntry, NatBehaviorType, natInstanceEntry = mibBuilder.importSymbols("NAT-MIB", "natInstanceIndex", "NatPoolingType", "natCountersEntry", "NatBehaviorType", "natInstanceEntry")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Counter64, Bits, ObjectIdentity, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, IpAddress, NotificationType, Gauge32, MibIdentifier, Unsigned32, Counter32, Integer32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Bits", "ObjectIdentity", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "IpAddress", "NotificationType", "Gauge32", "MibIdentifier", "Unsigned32", "Counter32", "Integer32", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ciscoNatCgnExtMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 818))
ciscoNatCgnExtMIB.setRevisions(('2014-04-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoNatCgnExtMIB.setRevisionsDescriptions(('Latest version of this MIB module.',))
if mibBuilder.loadTexts: ciscoNatCgnExtMIB.setLastUpdated('201404030000Z')
if mibBuilder.loadTexts: ciscoNatCgnExtMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoNatCgnExtMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoNatCgnExtMIB.setDescription('This MIB module extends the IETF draft NAT MIB available at http://tools.ietf.org/html/draft-ietf-behave-nat-mib-11 The extensions are intended to address the needs of the Carrier Grade NAT (CGN), also known as Large Scale NAT (LSN). GLOSSARY ========== Address mapping - is used to refer to association between a private IP to public IP (in case of NAT44 and DS Lite) or source IPv6 address to IPv4 address in case of NAT64 stateful application. Mapping - A mapping used to refer to a NAT translation record. It is a record held in memory that maps a private IP address and port to a public IP address and port. Subscriber - A subscriber is a record held in memory that provides IP address and other details of an end user device which has one or more mappings. Session - A session is a record maintained in memory that identifies a flow. The flow is uniquely identified by the source IPv4/IPv6 address, source port, translated IP address, translated source port, destination IPv4/IPv6 address and destination port. In to Out packet - A packet originating from a subscriber, with a private source address (or with an IPv6 address in case of NAT64), destined to a host with a public IP address. This packet needs NAT (or NAPT) service. Out to In packet - A packet originating from a host on the public Internet (or any host with a routable/public) source address, whose destination address is a mapped (translated) IP address. This packet needs reverse-NAT. Bulk port allocation - A NAT instance can be configured pre-allocate a range of contiguous ports instead of a single port. A mapping log record is created indicating the range of ports allocated to this subscriber. This is done in anticipation that the subscriber is likely to send packets that require more mappings to be created. For the subsequent mapping requests, one of the pre-allocated port is used and no additional log entries need to be created. This is a technique used to reduce the volume of translation record data.')
ciscoNatCgnExtMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 818, 0))
ciscoNatCgnExtMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 818, 1))
ciscoNatCgnExtMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 818, 2))
class NatCgnInstanceType(TextualConvention, Integer32):
    description = 'A value that represents a type of NAT instance. nat44(1): This is the traditional Network Address Translation from IPv4 to IPv4, explained in RFC 4787. nat64Stateful(2): This is the IPv6 to IPv4 translation (that is, Address Family translation), explained in RFC 6146. dsLite(3): This is the Dual Stack Lite, explained in RFC 6333.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("nat44", 1), ("nat64Stateful", 2), ("dsLite", 3))

class NatCgnALGType(TextualConvention, Integer32):
    description = 'A value that represents ALG (Application Level Gateway) protocol type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))
    namedValues = NamedValues(("algActiveFTP", 1), ("algDNS", 2), ("algH323", 3), ("algHTTP", 4), ("algLDAP", 5), ("algMSRPC", 6), ("algNetBIOS", 7), ("algPCP", 8), ("algPPTP", 9), ("algRCMD", 10), ("algRTSP", 11), ("algSCCP", 12), ("algSIP", 13), ("algSunRPC", 14))

cNatCgnInstanceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1), )
if mibBuilder.loadTexts: cNatCgnInstanceTable.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceTable.setDescription('This table lists the NAT instances configured on the device.')
cNatCgnInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1), )
natInstanceEntry.registerAugmentions(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstanceEntry"))
cNatCgnInstanceEntry.setIndexNames(*natInstanceEntry.getIndexNames())
if mibBuilder.loadTexts: cNatCgnInstanceEntry.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceEntry.setDescription('An entry describes a NAT instance configured on the device. The parameters include the type of the NAT instance and the important configuration elements.')
cNatCgnInstanceType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1, 1), NatCgnInstanceType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnInstanceType.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceType.setDescription('This object specifies the type of the NAT instance. If the instance type is changed, the service-type attribute of the corresponding interfaces will also need to be changed.')
cNatCgnInstanceServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnInstanceServiceName.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceServiceName.setDescription('This object specifies the CGN service name of this instance.')
cNatCgnInstanceVrf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnInstanceVrf.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceVrf.setDescription("This object specifies the name the VRF that is bringing in subscriber's traffic that needs to undergo NAT.")
cNatCgnInstanceInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnInstanceInterface.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceInterface.setDescription("This object specifies the name the interface that is bringing in subscriber's traffic that needs to undergo NAT. Typically either the cNatCgnInstanceVrf or cNatCgnInstanceInterface is needed to be configured, but not both.")
cNatCgnInstanceBehaviorType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1, 5), NatBehaviorType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnInstanceBehaviorType.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceBehaviorType.setDescription('This object specifies the configured NAT mapping behavior for this instance.')
cNatCgnInstancePoolingType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1, 6), NatPoolingType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnInstancePoolingType.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstancePoolingType.setDescription('This object specifies the configured NAT address pooling type for this instance.')
cNatCgnInstanceProtocolPortLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnInstanceProtocolPortLimit.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceProtocolPortLimit.setDescription('This object specifies the configured protocol port limit. This is the maximum number of active mappings each subscriber can have at any given time. Value of zero means, it is unlimited.')
cNatCgnInstanceProtocolPortBulkAllocControl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnInstanceProtocolPortBulkAllocControl.setStatus('current')
if mibBuilder.loadTexts: cNatCgnInstanceProtocolPortBulkAllocControl.setDescription('This object specifies the configured bulk port allocation size. Value of 0 means, bulk allocation is not applicable (or not supported). Value of 1 means, it is not enabled, that is, ports are allocated individually and not in bulk.')
cNatCgnCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2))
cNatCgnCounterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1), )
if mibBuilder.loadTexts: cNatCgnCounterTable.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterTable.setDescription('This table lists the counters of NAT instances in the device.')
cNatCgnCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1), )
natCountersEntry.registerAugmentions(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterEntry"))
cNatCgnCounterEntry.setIndexNames(*natCountersEntry.getIndexNames())
if mibBuilder.loadTexts: cNatCgnCounterEntry.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterEntry.setDescription('An entry contains the additional statistics of a NAT instance.')
cNatCgnCounterSessionCreations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterSessionCreations.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterSessionCreations.setDescription('This object indicates the number of sessions created since the instance is up.')
cNatCgnCounterSessionRemovals = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterSessionRemovals.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterSessionRemovals.setDescription('This object indicates the number of sessions removed since the instance is up. The number of active sessions is equal to cNatCgnCounterSessionCreations - cNatCgnCounterSessionRemovals.')
cNatCgnCounterOutOfSessionDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 3), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterOutOfSessionDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterOutOfSessionDrops.setDescription('This object indicates the number of packets dropped because they required a new session entry to be created, however, there is no space to create new sessions.')
cNatCgnCounterSessionLimitDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 4), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterSessionLimitDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterSessionLimitDrops.setDescription('This object indicates the number of packets in either in to out or out to in direction dropped because of exceeding limit on session entries.')
cNatCgnCounterNoMappingEntryDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 5), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterNoMappingEntryDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterNoMappingEntryDrops.setDescription('This object indicates the number of packets in the out to in direction not translated because there was no mapping found.')
cNatCgnCounterSourceIPOutOfRangeDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 6), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterSourceIPOutOfRangeDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterSourceIPOutOfRangeDrops.setDescription('This object indicates the number of packets in the in to out direction not translated because source address was out of configured prefix or range. For NAT44 configured in predefined mode, NAT64 stateful or DS Lite, it could be drops due to source IP address not matching the configured prefix bits.')
cNatCgnCounterEndPointFilteringDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 7), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterEndPointFilteringDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterEndPointFilteringDrops.setDescription('This object indicates the number of packets in the out to in direction dropped because of end point dependent filtering policy. Note, the value of this object should be interpreted in conjunction with the value of cNatCgnInstanceBehaviorType. If the NAT instance is configured with endpointIndependent behavior, the instance is not supposed to filter or drop any packets based on the destination. In such case this counter could either be zero or could be the number of packets passed which would have otherwise be filtered and dropped if cNatCgnInstanceBehaviorType is set to addressDependent or addressAndPortDependent.')
cNatCgnCounterTCPSequenceDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 8), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterTCPSequenceDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterTCPSequenceDrops.setDescription('This object indicates the number of packets in the out to in direction dropped because TCP sequence check failed.')
cNatCgnCounterTCPMappingDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 9), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterTCPMappingDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterTCPMappingDrops.setDescription('This object indicates the number of TCP packets in the in to out direction dropped because a new mapping was required to be created, however TCP SYN flag was not set.')
cNatCgnCounterFragmentPktsInToOutDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 10), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterFragmentPktsInToOutDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterFragmentPktsInToOutDrops.setDescription('This object indicates the number of fragmented packets in the in to out direction dropped due to errors such as timed out waiting for first fragment or no space to hold the fragment.')
cNatCgnCounterFragmentPktsOutToInDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 11), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterFragmentPktsOutToInDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterFragmentPktsOutToInDrops.setDescription('This object indicates the number of fragmented packets in the out to in direction dropped due to errors such as timed out waiting for first fragment or no space to hold the fragment.')
cNatCgnCounterCurrentPortAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterCurrentPortAllocation.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterCurrentPortAllocation.setDescription('This object indicates the current average port allocation across all available public IP addresses applied to this NAT instance. When bulk allocation is enabled (that is, the value of cNatCgnInstanceProtocolPortBulkAllocControl is more than 1), this value will include all the ports pre-allocated in bulk (whether they are in use or not).')
cNatCgnCounterPortUsageLowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnCounterPortUsageLowThreshold.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterPortUsageLowThreshold.setDescription('This object specifies the low threshold in percentage of available public ports that are used up. The notification cNatCgnNotifPortUsageWatermarkLow is sent once the value of cNatCgnCounterAveragePortAllocation becomes less than or equal to this value. If this object is set to zero, the notification is not generated.')
cNatCgnCounterPortUsageClearLowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnCounterPortUsageClearLowThreshold.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterPortUsageClearLowThreshold.setDescription('This object specifies the clear low threshold in percentage of available public ports that are used up. The notification cNatCgnNotifPortUsageWatermarkLowClear is sent once the value of cNatCgnCounterAveragePortAllocation becomes more than or equal to this value. If this object is set to zero, the notification is not generated. Implementations must ensure that values of objects cNatCgnCounterPortUsageClearLowThreshold and cNatCgnCounterPortUsageLowThreshold remain consistent. For example, an implementation must respond with an inconsistentValue error if an attempt is made to set the the value of cNatCgnCounterPortUsageClearLowThreshold to be less than or equal to that of cNatCgnCounterPortUsageLowThreshold and vice versa.')
cNatCgnCounterPortUsageHighThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnCounterPortUsageHighThreshold.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterPortUsageHighThreshold.setDescription('This object specifies the high threshold in percentage of available public ports that are used up. The notification cNatCgnNotifPortUsageWatermarkHigh is sent once the value of cNatCgnCounterAveragePortAllocation becomes higher than or equal to this value. If this field is set to zero, the notification is not generated.')
cNatCgnCounterPortUsageClearHighThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cNatCgnCounterPortUsageClearHighThreshold.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterPortUsageClearHighThreshold.setDescription('This object specifies the clear high threshold in percentage of available public ports that are used up. The notification cNatCgnNotifPortUsageWatermarkHighClear is sent once the value of cNatCgnCounterAveragePortAllocation becomes less than or equal to this value. If this object is set to zero, the notification is not generated. Implementations must ensure that values of objects cNatCgnCounterPortUsageClearHighThreshold and cNatCgnCounterPortUsageHighThreshold remain consistent. For example, an implementation must respond with an inconsistentValue error if an attempt is made to set the the value of cNatCgnCounterPortUsageClearHighThreshold to be more than or equal to that of cNatCgnCounterPortUsageHighThreshold and vice versa.')
cNatCgnCounterAverageBulkPortUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 1, 1, 17), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnCounterAverageBulkPortUsage.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCounterAverageBulkPortUsage.setDescription('This object indicates the average percentage usage of ports pre-allocated in bulk. This value is valid only if the bulk allocation is configured. That is the value specified by the cNatCgnInstanceProtocolPortBulkAllocControl is more than 1. This value gives hints about effectiveness of bulk port allocation technique. A very low percentage of bulk port usage may suggest that, bulk allocation size be reduced. On the other hand, a value close to 100 may hint at increasing the bulk size to further reduce log data volume.')
cNatCgnLogStatTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2), )
if mibBuilder.loadTexts: cNatCgnLogStatTable.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatTable.setDescription('This table lists the logging statistics of each NAT instance in the device.')
cNatCgnLogStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"))
if mibBuilder.loadTexts: cNatCgnLogStatEntry.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatEntry.setDescription('An entry describes the logging related statistics of a NAT instance.')
cNatCgnLogStatMappingCreateRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnLogStatMappingCreateRecords.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatMappingCreateRecords.setDescription('This object indicates the number of translation create records generated. It could be Netflow or Syslog records. It may not always necessarily be equal to number of mappings created (natMappingCreations of the NAT-MIB). If bulk allocation is enabled, this number could be much smaller than natMappingCreations. If the NAT mode is configured to be pre-defined or if logging is not configured, this could be zero.')
cNatCgnLogStatMappingDeleteRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnLogStatMappingDeleteRecords.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatMappingDeleteRecords.setDescription('This object indicates the number of translation delete records generated. It could be Netflow or Syslog records. It may not always necessarily be equal to number of mappings deleted (natMappingRemovals of the NAT-MIB). If bulk allocation is enabled, this number could be much smaller than natMappingRemovals. If the NAT mode is configured to be pre-defined or if logging is not configured, this could be zero.')
cNatCgnLogStatSessionCreateRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnLogStatSessionCreateRecords.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatSessionCreateRecords.setDescription('This object indicates the number of session create records generated. It could be Netflow or Syslog records. It may not always necessarily be equal to number of sessions created (cNatCgnCounterSessionCreations). If logging is not configured or if session logging is not configured, this could be zero.')
cNatCgnLogStatSessionDeleteRecords = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnLogStatSessionDeleteRecords.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatSessionDeleteRecords.setDescription('This object indicates the number of session delete records generated. It could be Netflow or Syslog records. It may not always necessarily be equal to number of sessions deleted (cNatCgnCounterSessionRemovals). If the logging is not configured or if session logging is not configured, this could be zero.')
cNatCgnLogStatNetflowPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnLogStatNetflowPackets.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatNetflowPackets.setDescription('This object indicates the number of Netflow packets generated. This includes the packet which could not be sent out due to congestion or other reasons.')
cNatCgnLogStatNetflowPacketDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnLogStatNetflowPacketDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatNetflowPacketDrops.setDescription('This object indicates the number of Netflow packets which could not be sent out due to congestion or other errors within the CGN device. This does not include any drops along the way to the collector.')
cNatCgnLogStatSyslogPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnLogStatSyslogPackets.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatSyslogPackets.setDescription('This object indicates the number of Syslog packets generated. This includes the packet which could not be sent out due to congestion or other reasons.')
cNatCgnLogStatSyslogPacketDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnLogStatSyslogPacketDrops.setStatus('current')
if mibBuilder.loadTexts: cNatCgnLogStatSyslogPacketDrops.setDescription('This object indicates the number of Syslog packets which could not be sent out due to congestion or other errors within the CGN device. This does not include any drops along the way to the collector.')
cNatCgnALGCountersTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 3), )
if mibBuilder.loadTexts: cNatCgnALGCountersTable.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGCountersTable.setDescription('This table lists the application level gateway status and counters for each ALG type and for each NAT instance in the device.')
cNatCgnALGCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 3, 1), ).setIndexNames((0, "NAT-MIB", "natInstanceIndex"), (0, "CISCO-NAT-CGN-EXT-MIB", "cNatCgnALGType"))
if mibBuilder.loadTexts: cNatCgnALGCountersEntry.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGCountersEntry.setDescription('An entry describes status and counters of a specific ALG type for a specific NAT instance.')
cNatCgnALGType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 3, 1, 1), NatCgnALGType())
if mibBuilder.loadTexts: cNatCgnALGType.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGType.setDescription('This object indicates the ALG type which together with natInstanceIndex uniquely identifies the set of counters being reported.')
cNatCgnALGStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 1), ("unSupported", 2), ("notEnabled", 3), ("enabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnALGStatus.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGStatus.setDescription('This object indicates the status of this ALG type for this NAT instance. notApplicable: This ALG type is not relevant to this NAT instance. unSupported: This ALG type is relevant to this NAT instance, however it is not supported. notEnabled: This ALG is supported on this NAT instance, however it is not enabled in the configuration. enabled: This ALG is enabled on this NAT instance. The rest of the objects of this entry are valid only if the cNatCgnALGStatus is set to enabled.')
cNatCgnALGMappingCreations = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnALGMappingCreations.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGMappingCreations.setDescription('This object indicates the number of mappings created for this ALG.')
cNatCgnALGMappingRemovals = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnALGMappingRemovals.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGMappingRemovals.setDescription('This object indicates the number of mappings removed which were created for this ALG. The number of active mappings for this ALG is equal to cNatCgnALGMappingCreations - cNatCgnALGMappingRemovals.')
cNatCgnALGUnsupportedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnALGUnsupportedErrors.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGUnsupportedErrors.setDescription('This object indicates the number of application level messages/packets which could not be processed as they used options which are not yet supported. This does not include messages/packets that did not conform to the protocol.')
cNatCgnALGProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 818, 1, 2, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cNatCgnALGProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGProtocolErrors.setDescription('This object indicates the number of application level messages/packets which could not be processed as they did not conform to the protocol.')
cNatCgnNotifPortUsageWatermarkLow = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 818, 0, 1)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterCurrentPortAllocation"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterPortUsageLowThreshold"))
if mibBuilder.loadTexts: cNatCgnNotifPortUsageWatermarkLow.setStatus('current')
if mibBuilder.loadTexts: cNatCgnNotifPortUsageWatermarkLow.setDescription('The device generates this notification when the value of cNatCgnCounterCurrentPortAllocation becomes lower than or equal to the value of cNatCgnCounterPortUsageLowThreshold. The device will not generate notification if cNatCgnCounterPortUsageLowThreshold is set to zero.')
cNatCgnNotifPortUsageWatermarkLowClear = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 818, 0, 2)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterCurrentPortAllocation"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterPortUsageClearLowThreshold"))
if mibBuilder.loadTexts: cNatCgnNotifPortUsageWatermarkLowClear.setStatus('current')
if mibBuilder.loadTexts: cNatCgnNotifPortUsageWatermarkLowClear.setDescription('The device generates this notification when the value of cNatCgnCounterCurrentPortAllocation becomes higher than or equal to the value of cNatCgnCounterPortUsageClearLowThreshold and if cNatCgnNotifPortUsageWatermarkLow is already generated. The device will not generate notification if cNatCgnCounterPortUsageClearLowThreshold is set to zero.')
cNatCgnNotifPortUsageWatermarkHigh = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 818, 0, 3)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterCurrentPortAllocation"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterPortUsageHighThreshold"))
if mibBuilder.loadTexts: cNatCgnNotifPortUsageWatermarkHigh.setStatus('current')
if mibBuilder.loadTexts: cNatCgnNotifPortUsageWatermarkHigh.setDescription('The device generates this notification when the value of cNatCgnCounterCurrentPortAllocation becomes higher than or equal to the cNatCgnCounterPortUsageHighThreshold. The device will not generate notification if cNatCgnCounterPortUsageHighThreshold is set to zero.')
cNatCgnNotifPortUsageWatermarkHighClear = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 818, 0, 4)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterCurrentPortAllocation"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterPortUsageClearHighThreshold"))
if mibBuilder.loadTexts: cNatCgnNotifPortUsageWatermarkHighClear.setStatus('current')
if mibBuilder.loadTexts: cNatCgnNotifPortUsageWatermarkHighClear.setDescription('The device generates this notification when the value of cNatCgnCounterCurrentPortAllocation becomes lower than or equal to the value of cNatCgnCounterPortUsageClearLowThreshold and if cNatCgnNotifPortUsageWatermarkHigh is already generated. The device will not generate notification if cNatCgnCounterPortUsageClearHighThreshold is set to zero.')
cNatCgnMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 1))
cNatCgnMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2))
cNatCgnModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 1, 1)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnConfigGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCountersGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnNotificationsGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnOptionConfigGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnBulkAllocGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnSessionGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnNetflowLoggingGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnSyslogLoggingGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnFragmentsGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnALGCountersGroup"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnServiceNameGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnModuleCompliance = cNatCgnModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: cNatCgnModuleCompliance.setDescription('This compliance statement specifies the minimal requirements an implementation must meet in order to claim full compliance with the definition of the CISCO-NAT-CGN-EXT-MIB.')
cNatCgnConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 1)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstanceType"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstanceInterface"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstanceVrf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnConfigGroup = cNatCgnConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnConfigGroup.setDescription('This group contains objects describing basic configuration elements of NAT instances.')
cNatCgnOptionConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 2)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstanceBehaviorType"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstancePoolingType"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstanceProtocolPortLimit"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnOptionConfigGroup = cNatCgnOptionConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnOptionConfigGroup.setDescription('This group contains objects describing optional configuration elements of NAT instances.')
cNatCgnCountersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 3)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterNoMappingEntryDrops"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterSourceIPOutOfRangeDrops"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterEndPointFilteringDrops"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterTCPSequenceDrops"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterTCPMappingDrops"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterCurrentPortAllocation"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterPortUsageLowThreshold"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterPortUsageClearLowThreshold"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterPortUsageHighThreshold"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterPortUsageClearHighThreshold"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnCountersGroup = cNatCgnCountersGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnCountersGroup.setDescription('This group contains objects describing counters and thresholds.')
cNatCgnSessionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 4)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterSessionCreations"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterSessionRemovals"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterOutOfSessionDrops"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterEndPointFilteringDrops"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterSessionLimitDrops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnSessionGroup = cNatCgnSessionGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnSessionGroup.setDescription('This group contains objects describing counters specific to session level tracking.')
cNatCgnBulkAllocGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 5)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstanceProtocolPortBulkAllocControl"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterAverageBulkPortUsage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnBulkAllocGroup = cNatCgnBulkAllocGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnBulkAllocGroup.setDescription('This group contains objects describing configuration and statistics specific to bulk port allocation.')
cNatCgnNetflowLoggingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 6)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatMappingCreateRecords"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatMappingDeleteRecords"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatSessionCreateRecords"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatSessionDeleteRecords"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatNetflowPackets"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatNetflowPacketDrops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnNetflowLoggingGroup = cNatCgnNetflowLoggingGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnNetflowLoggingGroup.setDescription('This group contains objects describing counters of Netflow based logging.')
cNatCgnSyslogLoggingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 7)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatMappingCreateRecords"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatMappingDeleteRecords"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatSessionCreateRecords"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatSessionDeleteRecords"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatSyslogPackets"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnLogStatSyslogPacketDrops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnSyslogLoggingGroup = cNatCgnSyslogLoggingGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnSyslogLoggingGroup.setDescription('This group contains objects describing counters of syslog based logging.')
cNatCgnFragmentsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 8)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterFragmentPktsInToOutDrops"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnCounterFragmentPktsOutToInDrops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnFragmentsGroup = cNatCgnFragmentsGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnFragmentsGroup.setDescription('This group contains objects describing fragment related counters.')
cNatCgnALGCountersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 9)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnALGStatus"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnALGMappingCreations"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnALGMappingRemovals"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnALGUnsupportedErrors"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnALGProtocolErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnALGCountersGroup = cNatCgnALGCountersGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnALGCountersGroup.setDescription('This group contains objects describing counters related to ALG processing.')
cNatCgnNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 15)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnNotifPortUsageWatermarkLow"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnNotifPortUsageWatermarkLowClear"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnNotifPortUsageWatermarkHigh"), ("CISCO-NAT-CGN-EXT-MIB", "cNatCgnNotifPortUsageWatermarkHighClear"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnNotificationsGroup = cNatCgnNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnNotificationsGroup.setDescription('This group contains notifications supporting NAT instances.')
cNatCgnServiceNameGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 818, 2, 2, 11)).setObjects(("CISCO-NAT-CGN-EXT-MIB", "cNatCgnInstanceServiceName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cNatCgnServiceNameGroup = cNatCgnServiceNameGroup.setStatus('current')
if mibBuilder.loadTexts: cNatCgnServiceNameGroup.setDescription('This group contains objects describing service related configuration elements')
mibBuilder.exportSymbols("CISCO-NAT-CGN-EXT-MIB", cNatCgnInstanceType=cNatCgnInstanceType, cNatCgnModuleCompliance=cNatCgnModuleCompliance, cNatCgnBulkAllocGroup=cNatCgnBulkAllocGroup, cNatCgnLogStatSessionCreateRecords=cNatCgnLogStatSessionCreateRecords, cNatCgnFragmentsGroup=cNatCgnFragmentsGroup, cNatCgnCounterFragmentPktsInToOutDrops=cNatCgnCounterFragmentPktsInToOutDrops, cNatCgnInstanceTable=cNatCgnInstanceTable, cNatCgnLogStatSyslogPackets=cNatCgnLogStatSyslogPackets, cNatCgnALGCountersGroup=cNatCgnALGCountersGroup, cNatCgnNotifPortUsageWatermarkLow=cNatCgnNotifPortUsageWatermarkLow, cNatCgnLogStatSessionDeleteRecords=cNatCgnLogStatSessionDeleteRecords, cNatCgnCountersGroup=cNatCgnCountersGroup, cNatCgnCounters=cNatCgnCounters, cNatCgnCounterSourceIPOutOfRangeDrops=cNatCgnCounterSourceIPOutOfRangeDrops, cNatCgnALGCountersEntry=cNatCgnALGCountersEntry, cNatCgnCounterEntry=cNatCgnCounterEntry, cNatCgnMIBGroups=cNatCgnMIBGroups, cNatCgnOptionConfigGroup=cNatCgnOptionConfigGroup, cNatCgnCounterPortUsageLowThreshold=cNatCgnCounterPortUsageLowThreshold, cNatCgnLogStatMappingDeleteRecords=cNatCgnLogStatMappingDeleteRecords, cNatCgnServiceNameGroup=cNatCgnServiceNameGroup, cNatCgnMIBCompliances=cNatCgnMIBCompliances, cNatCgnLogStatNetflowPacketDrops=cNatCgnLogStatNetflowPacketDrops, cNatCgnCounterTable=cNatCgnCounterTable, cNatCgnNotifPortUsageWatermarkHighClear=cNatCgnNotifPortUsageWatermarkHighClear, cNatCgnCounterEndPointFilteringDrops=cNatCgnCounterEndPointFilteringDrops, cNatCgnLogStatSyslogPacketDrops=cNatCgnLogStatSyslogPacketDrops, cNatCgnALGType=cNatCgnALGType, cNatCgnInstanceInterface=cNatCgnInstanceInterface, NatCgnInstanceType=NatCgnInstanceType, cNatCgnLogStatMappingCreateRecords=cNatCgnLogStatMappingCreateRecords, cNatCgnCounterAverageBulkPortUsage=cNatCgnCounterAverageBulkPortUsage, cNatCgnALGMappingRemovals=cNatCgnALGMappingRemovals, cNatCgnCounterPortUsageClearHighThreshold=cNatCgnCounterPortUsageClearHighThreshold, cNatCgnCounterSessionCreations=cNatCgnCounterSessionCreations, cNatCgnInstanceBehaviorType=cNatCgnInstanceBehaviorType, cNatCgnCounterFragmentPktsOutToInDrops=cNatCgnCounterFragmentPktsOutToInDrops, cNatCgnLogStatNetflowPackets=cNatCgnLogStatNetflowPackets, cNatCgnALGCountersTable=cNatCgnALGCountersTable, cNatCgnCounterPortUsageHighThreshold=cNatCgnCounterPortUsageHighThreshold, cNatCgnSyslogLoggingGroup=cNatCgnSyslogLoggingGroup, ciscoNatCgnExtMIBObjects=ciscoNatCgnExtMIBObjects, cNatCgnCounterSessionLimitDrops=cNatCgnCounterSessionLimitDrops, cNatCgnCounterTCPMappingDrops=cNatCgnCounterTCPMappingDrops, cNatCgnLogStatTable=cNatCgnLogStatTable, cNatCgnNotifPortUsageWatermarkLowClear=cNatCgnNotifPortUsageWatermarkLowClear, ciscoNatCgnExtMIBNotifs=ciscoNatCgnExtMIBNotifs, cNatCgnInstanceProtocolPortBulkAllocControl=cNatCgnInstanceProtocolPortBulkAllocControl, cNatCgnInstanceServiceName=cNatCgnInstanceServiceName, cNatCgnCounterNoMappingEntryDrops=cNatCgnCounterNoMappingEntryDrops, cNatCgnInstancePoolingType=cNatCgnInstancePoolingType, PYSNMP_MODULE_ID=ciscoNatCgnExtMIB, ciscoNatCgnExtMIB=ciscoNatCgnExtMIB, cNatCgnCounterSessionRemovals=cNatCgnCounterSessionRemovals, cNatCgnInstanceEntry=cNatCgnInstanceEntry, cNatCgnCounterOutOfSessionDrops=cNatCgnCounterOutOfSessionDrops, cNatCgnCounterTCPSequenceDrops=cNatCgnCounterTCPSequenceDrops, cNatCgnLogStatEntry=cNatCgnLogStatEntry, cNatCgnConfigGroup=cNatCgnConfigGroup, cNatCgnInstanceProtocolPortLimit=cNatCgnInstanceProtocolPortLimit, cNatCgnInstanceVrf=cNatCgnInstanceVrf, cNatCgnCounterCurrentPortAllocation=cNatCgnCounterCurrentPortAllocation, cNatCgnCounterPortUsageClearLowThreshold=cNatCgnCounterPortUsageClearLowThreshold, cNatCgnALGMappingCreations=cNatCgnALGMappingCreations, cNatCgnSessionGroup=cNatCgnSessionGroup, cNatCgnALGProtocolErrors=cNatCgnALGProtocolErrors, cNatCgnALGUnsupportedErrors=cNatCgnALGUnsupportedErrors, cNatCgnNotificationsGroup=cNatCgnNotificationsGroup, cNatCgnALGStatus=cNatCgnALGStatus, cNatCgnNetflowLoggingGroup=cNatCgnNetflowLoggingGroup, NatCgnALGType=NatCgnALGType, ciscoNatCgnExtMIBConform=ciscoNatCgnExtMIBConform, cNatCgnNotifPortUsageWatermarkHigh=cNatCgnNotifPortUsageWatermarkHigh)

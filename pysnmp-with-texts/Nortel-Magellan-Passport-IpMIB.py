#
# PySNMP MIB module Nortel-Magellan-Passport-IpMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-IpMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion")
AreaID, Integer32, RowStatus, InterfaceIndex, PhysAddress, Gauge32, StorageType, Unsigned32, RouterID, DisplayString, RowPointer, Counter32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "AreaID", "Integer32", "RowStatus", "InterfaceIndex", "PhysAddress", "Gauge32", "StorageType", "Unsigned32", "RouterID", "DisplayString", "RowPointer", "Counter32")
Link, AsciiString, NonReplicated, HexString, EnterpriseDateAndTime, DashedHexString, AsciiStringIndex = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "Link", "AsciiString", "NonReplicated", "HexString", "EnterpriseDateAndTime", "DashedHexString", "AsciiStringIndex")
passportMIBs, = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs")
vrPpIndex, vrIndex, vrPp, vr = mibBuilder.importSymbols("Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex", "vrIndex", "vrPp", "vr")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, MibIdentifier, Integer32, iso, NotificationType, Counter64, Gauge32, TimeTicks, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, IpAddress, ModuleIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibIdentifier", "Integer32", "iso", "NotificationType", "Counter64", "Gauge32", "TimeTicks", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "IpAddress", "ModuleIdentity", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ipMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27))
vrPpIpPort = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5))
vrPpIpPortRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 1), )
if mibBuilder.loadTexts: vrPpIpPortRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPort components.')
vrPpIpPortRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"))
if mibBuilder.loadTexts: vrPpIpPortRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPort component.')
vrPpIpPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPort components. These components can be added and deleted.')
vrPpIpPortComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortStorageType.setDescription('This variable represents the storage type value for the vrPpIpPort tables.')
vrPpIpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpIpPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortIndex.setDescription('This variable represents the index for the vrPpIpPort tables.')
vrPpIpPortProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10), )
if mibBuilder.loadTexts: vrPpIpPortProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortProvTable.setDescription('This group contains provisionable attributes for IP ports.')
vrPpIpPortProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"))
if mibBuilder.loadTexts: vrPpIpPortProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortProvEntry.setDescription('An entry in the vrPpIpPortProvTable.')
vrPpIpPortMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortMaxTxUnit.setDescription('This attribute specifies the IP MTU (Maximum Transmission Unit) supported by this IpPort. The specified MTU must be within the valid range for the IpPort media type.')
vrPpIpPortArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortArpStatus.setDescription('This attribute specifies whether ARP is enabled or disabled on this IpPort. If auto is specified, an appropriate value will be selected based on the IpPort media type.')
vrPpIpPortProxyArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortProxyArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortProxyArpStatus.setDescription('This attribute specifies whether Proxy ARP is enabled or disabled for this IpPort.')
vrPpIpPortArpNoLearn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortArpNoLearn.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortArpNoLearn.setDescription('This attribute specifies whether or not dynamic host entries will be installed in the ARP table when ARP packets are received on this IpPort.')
vrPpIpPortSendRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortSendRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortSendRedirect.setDescription('This attribute specifies whether or not ICMP host redirects will be sent out this IpPort.')
vrPpIpPortMulticastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortMulticastStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortMulticastStatus.setDescription('This attribute specifies whether or not IP multicast packets can be sent out this IpPort. If auto is specified, an appropriate value will be selected based on the IpPort media type.')
vrPpIpPortRelayAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 8), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortRelayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRelayAddress.setDescription("This attribute specifies a relay broadcast address for this IpPort. Each packet, received on this IpPort, meeting the relay broadcast criteria will be forwarded to the specified relay broadcast address. An relay address of all zero's indicates no relay broadcast address.")
vrPpIpPortRelayBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortRelayBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRelayBroadcast.setDescription('This attribute specifies how packets, received on other IpPorts, meeting the relay broadcast criteria, will be forwarded out this IpPort. The three options are described as follows: enabled: packets will be forwarded out this IpPort. disabled: packets will not be forwarded out this IpPort. auto: packets will be forwarded out this IpPort only when the bridge state is forwarding.')
vrPpIpPortLinkModel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5))).clone(namedValues=NamedValues(("localAreaNetwork", 1), ("pointToPoint", 2), ("loopback", 5))).clone('localAreaNetwork')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLinkModel.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLinkModel.setDescription('This attribute specifies the link model to use when the media type for this IpPort is PPP (Point to Point Protocol). A value of localAreaNetwork causes IP to treat this IpPort like a LAN. A value of pointToPoint causes IP to treat this IpPort like two directly connected IP hosts. A value of loopback causes IP to treat this IpPort similar to a point-to-point, but the destination and source points are the same providing an always up interface.')
vrPpIpPortLanModel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("localAreaNetwork", 1), ("nonBroadcastMultipleAccess", 2))).clone('localAreaNetwork')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLanModel.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLanModel.setDescription('This attribute specifies the lan model to use for this IpPort.')
vrPpIpPortEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortEncap.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortEncap.setDescription('This attribute specifies the encapsulation type to be used when sending packets out this IpPort. If auto is specified, an appropriate value is selected based on the IpPort media type. The values ieee8023 and ethernet can only be specified if the media type is ethernet. Otherwise, auto must be specified. For ethernet media type, the default encapsulation is ethernet.')
vrPpIpPortIcmpMaskReply = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortIcmpMaskReply.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortIcmpMaskReply.setDescription('This attribute specifies whether or not replies will be generated in response to ICMP Address Mask Requests received on this IpPort.')
vrPpIpPortDirectedBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortDirectedBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortDirectedBroadcast.setDescription('This attribute specifies whether or not directed broadcast to physical broadcast translation is enabled for incoming traffic on this IpPort. The IP router requirement (RFC1812) says this translation should be enabled; however, in some network environments, setting this attribute to disabled may prevent operational problem such as broadcast storms. Note that in some configuration, setting this attribute to disabled may cause Bootp to fail.')
vrPpIpPortAssignedQos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortAssignedQos.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortAssignedQos.setDescription('This attribute specifies the initial Class of Service (CoS) given to each packet received on the IpPort. The CoS value n is used to select Vr/ <string> QosP/n. which determines the QualityofService-Profile to be used when the packet is forwarded. The intial CoS given to a packet by the assignedQoS attribute may be overriden under certain circumstances (see the description of the Vr Qosp component, the cosPolicyAssignment attribute on the IpPort and Ip components, and the ipCos attribute on any of the frameRelayDte staticDlci, frameRelayDte dynamicDlciDefaults, and atmMpe atmConnection components).')
vrPpIpPortAllowMcastMacDest = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortAllowMcastMacDest.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortAllowMcastMacDest.setDescription('This attribute specifies whether a multicast destination MAC address is valid on this IpPort or not. Enabling it is non-standard. It can be used for applications such as transparent server backup. Multicast destination MAC address is only supported on LAN media.')
vrPpIpPortCosPolicyAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 17), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortCosPolicyAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortCosPolicyAssignment.setDescription('This attribute specifies the CosPolicyGroup component this IpPort component is using. Assigning a particular policy group to the IpPort may override the effect of the assignedQos; this depends on the actual policies provisioned under the policy group.')
vrPpIpPortMcastDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortMcastDomain.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortMcastDomain.setDescription('This attribute specifies the multicast domain index which all traffic coming in from this IpPort use. The numerical value of this attribute selects Vr/<string> Ip Mcast Domain/n.')
vrPpIpPortMcastPolicyAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 10, 1, 19), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortMcastPolicyAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortMcastPolicyAssignment.setDescription('This attribute specifies the policyGroup component that this IpPort component is using.')
vrPpIpPortSresProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 11), )
if mibBuilder.loadTexts: vrPpIpPortSresProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortSresProvTable.setDescription('This group contains the provisioned attributes for SourceRouteEndStation support.')
vrPpIpPortSresProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"))
if mibBuilder.loadTexts: vrPpIpPortSresProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortSresProvEntry.setDescription('An entry in the vrPpIpPortSresProvTable.')
vrPpIpPortSourceRouteEndStationSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortSourceRouteEndStationSupport.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortSourceRouteEndStationSupport.setDescription('This attribute is used to enable or disable support for SourceRouteEndStation (Sres). If set to enable, Sres will be supported on this protocol on this ProtocolPort (Pp). If set to disable, it will not be supported. An Sres component must be provisioned under the VirtualRouter if this attribute is set to enable. If this attribute is set to enable and this Pp has its linkToMedia attribute set, it must be linked to a LanApplication (La) that has its Framer interfaceName linked to a Fddi or TokenRing component.')
vrPpIpPortAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 12), )
if mibBuilder.loadTexts: vrPpIpPortAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrPpIpPortAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"))
if mibBuilder.loadTexts: vrPpIpPortAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortAdminControlEntry.setDescription('An entry in the vrPpIpPortAdminControlTable.')
vrPpIpPortSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrPpIpPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 13), )
if mibBuilder.loadTexts: vrPpIpPortOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperTable.setDescription('This group contains operational attributes for an IpPort.')
vrPpIpPortOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"))
if mibBuilder.loadTexts: vrPpIpPortOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperEntry.setDescription('An entry in the vrPpIpPortOperTable.')
vrPpIpPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("ethernet", 1), ("fddi", 2), ("tokenRing", 3), ("ppp", 4), ("vcpEther", 5), ("vcpToken", 6), ("vns", 7), ("x25", 8), ("frameRelay", 9), ("clusterBridge", 10), ("smds", 11), ("invalid", 12), ("atmMpeVcEncap", 13), ("atmMpeLlcEncap", 14), ("lecEther", 15), ("lecToken", 16), ("tunnel", 17), ("virtual", 18))).clone('invalid')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortMediaType.setDescription('This attribute indicates the media type of this IpPort.')
vrPpIpPortOperMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortOperMtu.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperMtu.setDescription('This attribute indicates the current operational IP MTU for this IpPort. Note that this value may be different than the provisioned maxTxUnit.')
vrPpIpPortOperArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortOperArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperArpStatus.setDescription('This attribute indicates the current operational ARP status. If the provisioned arpStatus is set to auto, then the IP application automatically determines the operArpStatus based on the IpPort media type.')
vrPpIpPortOperMulticastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortOperMulticastStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperMulticastStatus.setDescription('This attribute indicates the current operational Multicast status. If the provisioned multicastStatus is set to auto, then the IP application automatically determines the operMulticastStatus based on the IpPort media type.')
vrPpIpPortOperEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("notApplicable", 3))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortOperEncap.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperEncap.setDescription('This attribute indicates the current operational encapsulation type. If the provisioned encap is set to auto, then the IP application automatically determines the operEncap based on the IpPort media type.')
vrPpIpPortOperCosPolicyAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 13, 1, 433), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortOperCosPolicyAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperCosPolicyAssignment.setDescription('This attribute specifies the CosPolicyGroup component this IpPort component is using.')
vrPpIpPortRelayBcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 14), )
if mibBuilder.loadTexts: vrPpIpPortRelayBcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRelayBcOperTable.setDescription("This group contains operational attributes for an IpPort's RelayBc counters.")
vrPpIpPortRelayBcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"))
if mibBuilder.loadTexts: vrPpIpPortRelayBcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRelayBcOperEntry.setDescription('An entry in the vrPpIpPortRelayBcOperTable.')
vrPpIpPortRelayAddressCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortRelayAddressCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRelayAddressCount.setDescription("This attribute indicates the number of frames received on this IpPort which were forwarded to the provisioned relayAddress for this port. This counter wraps to zero when it reaches it's maximum.")
vrPpIpPortRelayBcCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortRelayBcCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortRelayBcCount.setDescription("This attribute indicates the number of frames received on this port which were forwarded to the broadcastAddress on other IpPorts. This counter is incremented once for every frame received on this port regardless of how many other ports it was sent on. This counter wraps to zero when it reaches it's maximum.")
vrPpIpPortStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 15), )
if mibBuilder.loadTexts: vrPpIpPortStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpIpPortStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"))
if mibBuilder.loadTexts: vrPpIpPortStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortStateEntry.setDescription('An entry in the vrPpIpPortStateTable.')
vrPpIpPortAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpIpPortOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpIpPortUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpIpPortOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 16), )
if mibBuilder.loadTexts: vrPpIpPortOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpIpPortOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"))
if mibBuilder.loadTexts: vrPpIpPortOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortOperStatusEntry.setDescription('An entry in the vrPpIpPortOperStatusTable.')
vrPpIpPortSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpIpPortLogicalIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2))
vrPpIpPortLogicalIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 1), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortLogicalIf components.')
vrPpIpPortLogicalIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortLogicalIf component.')
vrPpIpPortLogicalIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortLogicalIf components. These components can be added and deleted.')
vrPpIpPortLogicalIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortLogicalIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortLogicalIf tables.')
vrPpIpPortLogicalIfAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrPpIpPortLogicalIfAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfAddressIndex.setDescription('This variable represents the index for the vrPpIpPortLogicalIf tables.')
vrPpIpPortLogicalIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 10), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfProvTable.setDescription('This group contains attributes required to define an IpLogicalIf.')
vrPpIpPortLogicalIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfProvEntry.setDescription('An entry in the vrPpIpPortLogicalIfProvTable.')
vrPpIpPortLogicalIfNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 10, 1, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfNetMask.setDescription('This attribute specifies the subnet mask for this IpLogicalIf. This attribute must be specified because the IP application will not automatically provide a default value.')
vrPpIpPortLogicalIfBroadcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 10, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfBroadcastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfBroadcastAddress.setDescription('This attribute specifies the broadcast address for this IpLogicalIf. This attribute is ignored if the IpPort mediaType is ppp (Point to Point Protocol). If the value is 0.0.0.0, the actual broadcast address will be derived from the IP address of this LogicalIf and the netmask attribute.')
vrPpIpPortLogicalIfLinkDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 10, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkDestinationAddress.setDescription('This attribute specifies the address for the link destination for this IpLogicalIf. This attribute is only required if the IpPort media type is PPP (Point to Point Protocol).')
vrPpIpPortLogicalIfLinkToPimSmCandidateRp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 10, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToPimSmCandidateRp.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToPimSmCandidateRp.setDescription("This attribute specifies a link to the CandidateRendezvousPoint component which uses this logicalIf as it's RendezvousPoint (Rp).")
vrPpIpPortLogicalIfLinkToPimSmCandidateBsr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 10, 1, 5), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToPimSmCandidateBsr.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToPimSmCandidateBsr.setDescription("This attribute specifies a link to the CandidateBootstrapRouter component which uses this logicalIf as it's BootstrapRouter Interface.")
vrPpIpPortLogicalIfLinkToMulStaticGpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 706), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToMulStaticGpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToMulStaticGpTable.setDescription("This attribute specifies a link to the component InwStaticRouteEntry which uses this logicalIf as it's OutInterface.")
vrPpIpPortLogicalIfLinkToMulStaticGpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 706, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfLinkToMulStaticGpValue"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToMulStaticGpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToMulStaticGpEntry.setDescription('An entry in the vrPpIpPortLogicalIfLinkToMulStaticGpTable.')
vrPpIpPortLogicalIfLinkToMulStaticGpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 706, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToMulStaticGpValue.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToMulStaticGpValue.setDescription('This variable represents both the value and the index for the vrPpIpPortLogicalIfLinkToMulStaticGpTable.')
vrPpIpPortLogicalIfLinkToMulStaticGpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 706, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToMulStaticGpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfLinkToMulStaticGpRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the vrPpIpPortLogicalIfLinkToMulStaticGpTable.')
vrPpIpPortLogicalIfOspfIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2))
vrPpIpPortLogicalIfOspfIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 1), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortLogicalIfOspfIf components.')
vrPpIpPortLogicalIfOspfIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortLogicalIfOspfIf component.')
vrPpIpPortLogicalIfOspfIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortLogicalIfOspfIf components. These components can be added and deleted.')
vrPpIpPortLogicalIfOspfIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortLogicalIfOspfIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortLogicalIfOspfIf tables.')
vrPpIpPortLogicalIfOspfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfIndex.setDescription('This variable represents the index for the vrPpIpPortLogicalIfOspfIf tables.')
vrPpIpPortLogicalIfOspfIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfProvTable.setDescription('This group of attributes identifies a provisionable set of attributes.')
vrPpIpPortLogicalIfOspfIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfProvEntry.setDescription('An entry in the vrPpIpPortLogicalIfOspfIfProvTable.')
vrPpIpPortLogicalIfOspfIfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 1), AreaID().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfAreaId.setDescription('The area Id this Ospf interface belongs to.')
vrPpIpPortLogicalIfOspfIfIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("broadcast", 1), ("nbma", 2), ("pointToPoint", 3), ("loopback", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfIfType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfIfType.setDescription('This attribute indicates the type of this Ospf interface. This interface type does not necessarily correlate with the type of the interface set on the logicalIf entry under IpPort.')
vrPpIpPortLogicalIfOspfIfSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfSnmpAdminStatus.setDescription('The administrative status of this Ospf interface.')
vrPpIpPortLogicalIfOspfIfRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRtrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRtrPriority.setDescription('The priority of this interface. Used in multi-access networks, this field is used in the designated router election algorithm. The value 0 signifies that the router is not eligible to become the designated router on this particular protocol port. In the event of a tie in this value, routers will use their routerId as a tie breaker.')
vrPpIpPortLogicalIfOspfIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a link-state update packet over this interface.')
vrPpIpPortLogicalIfOspfIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRetransInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRetransInterval.setDescription('The number of seconds between link-state advertisements retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets.')
vrPpIpPortLogicalIfOspfIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfHelloInterval.setDescription('The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for all routers attached to a common network.')
vrPpIpPortLogicalIfOspfIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRtrDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfRtrDeadInterval.setDescription("The number of seconds that a router's hello packets have not been seen before it's neighbors declare the router down. This should be some multiple of the helloIntereval. This value must be the same for all routers attached to a common network.")
vrPpIpPortLogicalIfOspfIfPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfPollInterval.setDescription('The largest time interval, in seconds, between the hello packets sent to an inactive non-broadcast multi-access neighbor.')
vrPpIpPortLogicalIfOspfIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)).clone(hexValue="0000000000000000")).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfAuthKey.setDescription('The Authentication Key. If the value of the attribute authType of an AreaEntry is simplePassword, and the authKey length is shorter than 8 octets, then the value of authKey will be left adjusted zero-filled to 8 octets.')
vrPpIpPortLogicalIfOspfIfMulticastForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("blocked", 1))).clone('blocked')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfMulticastForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfMulticastForwarding.setDescription('The way multicasts should be forwarded on this interface; non forwarded, forwarded as data-link multicasts, or forwarded as data-link unicasts. Data-link multicasting is not meaningful on point-to-point and NBMA(No Broadcast Multi Access) interfaces, and setting this attribute to blocked effectively disables all multicast forwarding.')
vrPpIpPortLogicalIfOspfIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 11), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfOperTable.setDescription('This group of attributes identifies operational state that this interface is performing.')
vrPpIpPortLogicalIfOspfIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfOperEntry.setDescription('An entry in the vrPpIpPortLogicalIfOspfIfOperTable.')
vrPpIpPortLogicalIfOspfIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("down", 1), ("loopback", 2), ("waiting", 3), ("pointToPoint", 4), ("designatedRouter", 5), ("backupDesignatedRouter", 6), ("otherDesignatedRouter", 7))).clone('designatedRouter')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfState.setDescription('The state of the OSPF interface.')
vrPpIpPortLogicalIfOspfIfDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 11, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfDesignatedRouter.setDescription('The Ip address of the designated router.')
vrPpIpPortLogicalIfOspfIfBackupDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfBackupDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfBackupDesignatedRouter.setDescription('The Ip address of the backup designated router')
vrPpIpPortLogicalIfOspfIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfEvents.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfEvents.setDescription('The number of times this OSPF interface has changed its state or an error has occurred.')
vrPpIpPortLogicalIfOspfIfMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 12), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfMetricTable.setDescription('This group contains the operational metric attribute of this interface.')
vrPpIpPortLogicalIfOspfIfMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfMetricEntry.setDescription('An entry in the vrPpIpPortLogicalIfOspfIfMetricTable.')
vrPpIpPortLogicalIfOspfIfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfMetric.setDescription('This attribute indicates the metric being used by this OspfIf. The metric is derived in one of two ways: 1. If there is a TypeOfService component provisioned under this OspfIf component, then the value of the metric attribute is copied from the provisionable attribute tosMetric. 2. Otherwise, the metric is computed based on the interface speed. If the interface speed is greater than 100 Mbit/s, then the metric is 1. If the interface speed is less than 100 Mbit/s, then the metric is 100 Mbit/s divided by the interface speed. If the interface speed is unknown, then it is treated as 1.54 Mbit/s during the calculation. The value of interface speed is available by displaying the ifSpeed attribute of the corresponding IfTableEntry component.')
vrPpIpPortLogicalIfOspfIfTOS = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2))
vrPpIpPortLogicalIfOspfIfTOSRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 1), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortLogicalIfOspfIfTOS components.')
vrPpIpPortLogicalIfOspfIfTOSRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfTOSMetricTosIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortLogicalIfOspfIfTOS component.')
vrPpIpPortLogicalIfOspfIfTOSRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortLogicalIfOspfIfTOS components. These components can be added and deleted.')
vrPpIpPortLogicalIfOspfIfTOSComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortLogicalIfOspfIfTOSStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortLogicalIfOspfIfTOS tables.')
vrPpIpPortLogicalIfOspfIfTOSMetricTosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSMetricTosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSMetricTosIndex.setDescription('This variable represents the index for the vrPpIpPortLogicalIfOspfIfTOS tables.')
vrPpIpPortLogicalIfOspfIfTOSProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 10), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSProvTable.setDescription('Identifies a provisionable set of attributes.')
vrPpIpPortLogicalIfOspfIfTOSProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfTOSMetricTosIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSProvEntry.setDescription('An entry in the vrPpIpPortLogicalIfOspfIfTOSProvTable.')
vrPpIpPortLogicalIfOspfIfTOSTosMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSTosMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfTOSTosMetric.setDescription('The metric using this typeOfService on this interface.')
vrPpIpPortLogicalIfOspfIfNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3))
vrPpIpPortLogicalIfOspfIfNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 1), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortLogicalIfOspfIfNbr components.')
vrPpIpPortLogicalIfOspfIfNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfNbrAddressIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortLogicalIfOspfIfNbr component.')
vrPpIpPortLogicalIfOspfIfNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortLogicalIfOspfIfNbr components. These components can be added and deleted.')
vrPpIpPortLogicalIfOspfIfNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortLogicalIfOspfIfNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortLogicalIfOspfIfNbr tables.')
vrPpIpPortLogicalIfOspfIfNbrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrAddressIndex.setDescription('This variable represents the index for the vrPpIpPortLogicalIfOspfIfNbr tables.')
vrPpIpPortLogicalIfOspfIfNbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 10), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrProvTable.setDescription('Identifies a group of Provisionable attributes.')
vrPpIpPortLogicalIfOspfIfNbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfNbrAddressIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrProvEntry.setDescription('An entry in the vrPpIpPortLogicalIfOspfIfNbrProvTable.')
vrPpIpPortLogicalIfOspfIfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrPriority.setDescription('The priority of this neighbor in the designated router election algorithm. The value 0 signifies that the neighbor is not eligible to become the designated router on this particular network. The higher the number, the better are the chances of being a designated router.')
vrPpIpPortLogicalIfOspfIfNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrOperTable.setDescription('Contains the Operational set of attributes for the Neighbor.')
vrPpIpPortLogicalIfOspfIfNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfOspfIfNbrAddressIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrOperEntry.setDescription('An entry in the vrPpIpPortLogicalIfOspfIfNbrOperTable.')
vrPpIpPortLogicalIfOspfIfNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11, 1, 1), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrRtrId.setDescription('An Ip Address uniquely identifying the neighboring router in the Autonomous System.')
vrPpIpPortLogicalIfOspfIfNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrOptions.setDescription("A bit mask corresponding to the neighbor's options field. Bit 0, if set, indicates that the area accepts and operates on external information, if zero, it is a stub area. Bit 1, if set, indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric. Bit 2, if set, indicates that the system is Network Multicast capable; i.e., that it implements OSPF Multicast Routing.")
vrPpIpPortLogicalIfOspfIfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrState.setDescription('The state of the relationship with this neighbor.')
vrPpIpPortLogicalIfOspfIfNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrEvents.setDescription('The number of times this neighbor relationship has changed state, or an error has occurred.')
vrPpIpPortLogicalIfOspfIfNbrLsRetransQlen = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrLsRetransQlen.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrLsRetransQlen.setDescription('The current length of the Retransmission queue.')
vrPpIpPortLogicalIfOspfIfNbrExchangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrExchangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrExchangeStatus.setDescription('Indicates the exchange status for a neighbor Entry.')
vrPpIpPortLogicalIfOspfIfNbrPermanance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 2, 3, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanent", 1), ("dynamic", 2))).clone('permanent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrPermanance.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfOspfIfNbrPermanance.setDescription('This attribute displays how the neighbor became an entry.')
vrPpIpPortLogicalIfRipIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3))
vrPpIpPortLogicalIfRipIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 1), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortLogicalIfRipIf components.')
vrPpIpPortLogicalIfRipIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfRipIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortLogicalIfRipIf component.')
vrPpIpPortLogicalIfRipIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortLogicalIfRipIf components. These components can be added and deleted.')
vrPpIpPortLogicalIfRipIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortLogicalIfRipIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortLogicalIfRipIf tables.')
vrPpIpPortLogicalIfRipIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIndex.setDescription('This variable represents the index for the vrPpIpPortLogicalIfRipIf tables.')
vrPpIpPortLogicalIfRipIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfProvTable.setDescription('This group contains the provisionable attributes of the RipIf component.')
vrPpIpPortLogicalIfRipIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfRipIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfProvEntry.setDescription('An entry in the vrPpIpPortLogicalIfRipIfProvTable.')
vrPpIpPortLogicalIfRipIfSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfSnmpAdminStatus.setDescription('Identifies the administrative status of this RipInterface. Setting this value to disabled will have the effect of rendering it inactive.')
vrPpIpPortLogicalIfRipIfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfMetric.setDescription('This attribute is the RIP metric for this logical interface.')
vrPpIpPortLogicalIfRipIfSilentFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfSilentFlag.setStatus('obsolete')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfSilentFlag.setDescription('If the value of this attribute is set to true, the protocol will only listen to RIP updates, If set to false, then Rip will listen and send RIP updates.This attribute has been migrated to ifConfSend.')
vrPpIpPortLogicalIfRipIfPoisonReverseFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfPoisonReverseFlag.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfPoisonReverseFlag.setDescription('If the value of this attribute is set to true, then poison reverse algorithm is used when sending out the updates otherwise use split horizon only.')
vrPpIpPortLogicalIfRipIfFlashUpdateFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfFlashUpdateFlag.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfFlashUpdateFlag.setDescription('This attribute when set to true will send updates when updates are received; otherwise RIP will wait till the next update period.')
vrPpIpPortLogicalIfRipIfNetworkRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("naturalNetWithOutDefaultRoute", 1), ("naturalNetWithDefaultRoute", 2), ("defaultRouteOnly", 3), ("subnetsOnly", 4))).clone('naturalNetWithOutDefaultRoute')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNetworkRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNetworkRouteStatus.setDescription('This attribute determines what type of network routes will be sent and whether a default route will be generated for this RipInterface. Generated default routes will not go into the routing table, but are sent in the updates going out on the interface. The possible values for this attribute are: naturalNetWithOutDefaultRoute - This value will cause normal RIP network routes to be put in the update. This means that the address of logicalIf pertaining to this RipInterface knowledge is taken into account in determining if the subnetted network or the natural network is sent for any route going into this update. naturalNetWithDefaultRoute - Selecting this value will cause a default route to be generated with the value of the metric selected for the attribute defaultRouteMetric. defaultRouteOnly - Selection of this value causes the default route to be generated with the value of the metric selected for the attribute defaultRouteMetric. NOTE: No other routes will go in the update. subnetsOnly - selection of this value will cause only subnet information to be put in the update. No default routes will be generated or passed on. Only subnetted routes that are part of the same subnetted network that this logicalInterface is on will be put in the update. NOTE: this also effects receiving of updates on this interface. Only subnetted routes that are part of the same subnetted network that this logicalInterface is on will be accepted on a received RIP update on this RipInterface.')
vrPpIpPortLogicalIfRipIfDefaultRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfDefaultRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfDefaultRouteMetric.setDescription('This attribute identifies the metric value for the default route. This value is only used if the attribute networkRouteStatus is configured with a value of either naturalNetWithDefaultRoute or defaultRouteOnly')
vrPpIpPortLogicalIfRipIfAcceptDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfAcceptDefault.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfAcceptDefault.setDescription('If this attribute is set to true, then accept the default route from this interface.')
vrPpIpPortLogicalIfRipIfIfConfSend = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doNotSend", 1), ("ripVersion1", 2), ("rip1Compatible", 3), ("ripVersion2", 4))).clone('rip1Compatible')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfConfSend.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfConfSend.setDescription('This attribute identifies what the router sends on this RipIf. ripVersion1 implies sending RIP updates compliant with RFC 1058. rip1Compatible implies broadcasting RIP-2 updates according to RFC 1058. ripVersion2 implies multicasting RIP-2 updates.')
vrPpIpPortLogicalIfRipIfIfConfReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rip1", 1), ("rip2", 2), ("rip1OrRip2", 3), ("doNotReceive", 4))).clone('rip1OrRip2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfConfReceive.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfConfReceive.setDescription('This attribute identifies which version of RIP updates are to be accepted on this RipIf. Note that rip2 and rip1OrRip2 implies reception of multicast packets.')
vrPpIpPortLogicalIfRipIfStatTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 11), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfStatTable.setDescription('This group contains operational attributes of the RipIf component. These attributes are statistical data corresponding to the RIP-2 standard MIB (rfc 1724) rip2Status table.')
vrPpIpPortLogicalIfRipIfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfRipIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfStatEntry.setDescription('An entry in the vrPpIpPortLogicalIfRipIfStatTable.')
vrPpIpPortLogicalIfRipIfIfBadPacketRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfBadPacketRcv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfBadPacketRcv.setDescription('This attribute counts the number of RIP response packets recieved by the RIP process which were subsequently discarded for any reason.')
vrPpIpPortLogicalIfRipIfIfBadRouteRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfBadRouteRcv.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfBadRouteRcv.setDescription('This attribute counts how many routes, in valid RIP packets, were ignored for any reason.')
vrPpIpPortLogicalIfRipIfIfTriggeredUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfTriggeredUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfIfTriggeredUpdates.setDescription('This attribute counts the number of triggered updates actually sent on this interface. This explicitly does NOT include full updates sent containing new information.')
vrPpIpPortLogicalIfRipIfNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 2))
vrPpIpPortLogicalIfRipIfNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 2, 1), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortLogicalIfRipIfNbr components.')
vrPpIpPortLogicalIfRipIfNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfRipIfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfRipIfNbrIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortLogicalIfRipIfNbr component.')
vrPpIpPortLogicalIfRipIfNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortLogicalIfRipIfNbr components. These components can be added and deleted.')
vrPpIpPortLogicalIfRipIfNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortLogicalIfRipIfNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortLogicalIfRipIfNbr tables.')
vrPpIpPortLogicalIfRipIfNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 3, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfRipIfNbrIndex.setDescription('This variable represents the index for the vrPpIpPortLogicalIfRipIfNbr tables.')
vrPpIpPortLogicalIfIgmpIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5))
vrPpIpPortLogicalIfIgmpIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 1), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortLogicalIfIgmpIf components.')
vrPpIpPortLogicalIfIgmpIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfIgmpIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortLogicalIfIgmpIf component.')
vrPpIpPortLogicalIfIgmpIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortLogicalIfIgmpIf components. These components can be added and deleted.')
vrPpIpPortLogicalIfIgmpIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortLogicalIfIgmpIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortLogicalIfIgmpIf tables.')
vrPpIpPortLogicalIfIgmpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfIndex.setDescription('This variable represents the index for the vrPpIpPortLogicalIfIgmpIf tables.')
vrPpIpPortLogicalIfIgmpIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 10), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfProvTable.setDescription('This group contains the provisionable attributes for the InwIpIgmpIf component.')
vrPpIpPortLogicalIfIgmpIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfIgmpIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfProvEntry.setDescription('An entry in the vrPpIpPortLogicalIfIgmpIfProvTable.')
vrPpIpPortLogicalIfIgmpIfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("v2", 2))).clone('v2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfVersion.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfVersion.setDescription('This attribute specifies the IGMP protocol version running on this interface. v2 is the only supported version at this time.')
vrPpIpPortLogicalIfIgmpIfQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfQueryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfQueryInterval.setDescription('This attribute specifies the frequency at which IGMP Host-Query packets are transmitted on this interface.')
vrPpIpPortLogicalIfIgmpIfQueryMaxRespTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfQueryMaxRespTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfQueryMaxRespTime.setDescription('This attribute specifies the maximum query response time advertised in IGMPv2 queries on this interface. The number of seconds represented by the queryMaxRespTime must be less than the Query Interval.')
vrPpIpPortLogicalIfIgmpIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 11), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfOperTable.setDescription('This group contains the operational attributes of InwIpIgmpIf component.')
vrPpIpPortLogicalIfIgmpIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfIgmpIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfOperEntry.setDescription('An entry in the vrPpIpPortLogicalIfIgmpIfOperTable.')
vrPpIpPortLogicalIfIgmpIfQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 11, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfQuerier.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfQuerier.setDescription('This attribute indicates the address of the IGMP Querier on the IP subnet to which this interface is attached.')
vrPpIpPortLogicalIfIgmpIfWrongVersionQuery = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfWrongVersionQuery.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfWrongVersionQuery.setDescription('This attribute indicates the number of queries received whose IGMP version does not match that configured for this interface. IGMP requires that all routers on a LAN be configured to run the same version of IGMP.')
vrPpIpPortLogicalIfIgmpIfJoins = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfJoins.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfJoins.setDescription('This attribute indicates the number of times a group membership has been added on this interface.')
vrPpIpPortLogicalIfIgmpIfGroups = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 11, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4292967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfGroups.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfGroups.setDescription('This attribute indicates the current number of entries for this interface in the cache table.')
vrPpIpPortLogicalIfIgmpIfQuerierExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 5, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfQuerierExpiryTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfIgmpIfQuerierExpiryTime.setDescription('This attribute indicates the amount of time remaining before the other querier present timer expires. If the local system is the querier, the value of this object is zero.')
vrPpIpPortLogicalIfPimSmIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6))
vrPpIpPortLogicalIfPimSmIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 1), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortLogicalIfPimSmIf components.')
vrPpIpPortLogicalIfPimSmIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfPimSmIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortLogicalIfPimSmIf component.')
vrPpIpPortLogicalIfPimSmIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortLogicalIfPimSmIf components. These components can be added and deleted.')
vrPpIpPortLogicalIfPimSmIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortLogicalIfPimSmIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortLogicalIfPimSmIf tables.')
vrPpIpPortLogicalIfPimSmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfIndex.setDescription('This variable represents the index for the vrPpIpPortLogicalIfPimSmIf tables.')
vrPpIpPortLogicalIfPimSmIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 10), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfProvTable.setDescription('This group contains the provisionable attributes for the InwIpPimSmIf component.')
vrPpIpPortLogicalIfPimSmIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfPimSmIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfProvEntry.setDescription('An entry in the vrPpIpPortLogicalIfPimSmIfProvTable.')
vrPpIpPortLogicalIfPimSmIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfHelloInterval.setDescription('This attribute specifies the frequency at which PIM-SM hello messages are transmitted on this interface.')
vrPpIpPortLogicalIfPimSmIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 11), )
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfOperTable.setDescription('This group contains the operational attributes for the InwIpPimSmIf component.')
vrPpIpPortLogicalIfPimSmIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortLogicalIfPimSmIfIndex"))
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfOperEntry.setDescription('An entry in the vrPpIpPortLogicalIfPimSmIfOperTable.')
vrPpIpPortLogicalIfPimSmIfDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 2, 6, 11, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortLogicalIfPimSmIfDesignatedRouter.setDescription('This attribute indicates the Designated Router on this PIM-SM interface. For point-to-point interfaces(wan media), this attribute has the value 0.0.0.0.')
vrPpIpPortNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3))
vrPpIpPortNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 1), )
if mibBuilder.loadTexts: vrPpIpPortNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortNs components.')
vrPpIpPortNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortNsIndex"))
if mibBuilder.loadTexts: vrPpIpPortNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortNs component.')
vrPpIpPortNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortNs components. These components can be added and deleted.')
vrPpIpPortNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortNs tables.')
vrPpIpPortNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpIpPortNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsIndex.setDescription('This variable represents the index for the vrPpIpPortNs tables.')
vrPpIpPortNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 10), )
if mibBuilder.loadTexts: vrPpIpPortNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsProvTable.setDescription('This group contains the attributes required by NetSentry to be applied to all IP packets going through this IpPort.')
vrPpIpPortNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortNsIndex"))
if mibBuilder.loadTexts: vrPpIpPortNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsProvEntry.setDescription('An entry in the vrPpIpPortNsProvTable.')
vrPpIpPortNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsIncomingFilter.setDescription('An ASCII string which provides the name of the NetSentry filter which will be applied to all IP datagrams arriving from this IpPort.')
vrPpIpPortNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortNsOutgoingFilter.setDescription('An ASCII string which provides the name of NetSentry filter which will be applied to all IP datagrams sent to this IpPort.')
vrPpIpPortBootpP = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4))
vrPpIpPortBootpPRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 1), )
if mibBuilder.loadTexts: vrPpIpPortBootpPRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPRowStatusTable.setDescription('This entry controls the addition and deletion of vrPpIpPortBootpP components.')
vrPpIpPortBootpPRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: vrPpIpPortBootpPRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPRowStatusEntry.setDescription('A single entry in the table represents a single vrPpIpPortBootpP component.')
vrPpIpPortBootpPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortBootpPRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrPpIpPortBootpP components. These components can be added and deleted.')
vrPpIpPortBootpPComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrPpIpPortBootpPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPStorageType.setDescription('This variable represents the storage type value for the vrPpIpPortBootpP tables.')
vrPpIpPortBootpPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrPpIpPortBootpPIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPIndex.setDescription('This variable represents the index for the vrPpIpPortBootpP tables.')
vrPpIpPortBootpPProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 10), )
if mibBuilder.loadTexts: vrPpIpPortBootpPProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPProvTable.setDescription('This group contains provisionable attributes for the BootpPort component.')
vrPpIpPortBootpPProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: vrPpIpPortBootpPProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPProvEntry.setDescription('An entry in the vrPpIpPortBootpPProvTable.')
vrPpIpPortBootpPRelayForwardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortBootpPRelayForwardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPRelayForwardStatus.setDescription('This attribute controls how BOOTP request packets, received on another port, will be flooded out this port. If relayForwardStatus is enabled, BOOTP requests received on another port will be broadcast out this port. When relayForwardStatus is disabled, BOOTP requests will not be broadcast out this port. If auto is used, the bridge spanning tree database is used to determine if BOOTP requests should be broadcast out this port. Note that when using enabled, it is possible to create misconfigurations which will result in broadcast storms. When using this feature with multiple routers, make sure there are no broadcast forwarding loops. Using auto with bridge spanning tree is safer to use if the network is running bridge spanning tree. Note that for auto to have effect, bridge spanning tree must be running on the corresponding VirtualRouter ProtocolPort.')
vrPpIpPortBootpPBootpLogicalInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 10, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortBootpPBootpLogicalInterface.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPBootpLogicalInterface.setDescription('This attribute identifies the logical interface whose address is to be the GIADDR of this BOOTP port. If not set, the address of the first logical port is chosen.')
vrPpIpPortBootpPAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 11), )
if mibBuilder.loadTexts: vrPpIpPortBootpPAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrPpIpPortBootpPAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: vrPpIpPortBootpPAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPAdminControlEntry.setDescription('An entry in the vrPpIpPortBootpPAdminControlTable.')
vrPpIpPortBootpPSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortBootpPSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrPpIpPortBootpPOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 12), )
if mibBuilder.loadTexts: vrPpIpPortBootpPOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrPpIpPortBootpPOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: vrPpIpPortBootpPOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPOperStatusEntry.setDescription('An entry in the vrPpIpPortBootpPOperStatusTable.')
vrPpIpPortBootpPSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrPpIpPortBootpPStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 13), )
if mibBuilder.loadTexts: vrPpIpPortBootpPStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrPpIpPortBootpPStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: vrPpIpPortBootpPStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPStateEntry.setDescription('An entry in the vrPpIpPortBootpPStateTable.')
vrPpIpPortBootpPAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrPpIpPortBootpPOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrPpIpPortBootpPUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrPpIpPortBootpPStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 14), )
if mibBuilder.loadTexts: vrPpIpPortBootpPStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPStatsTable.setDescription('This group contains BootpPortEntry component statistics.')
vrPpIpPortBootpPStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: vrPpIpPortBootpPStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPStatsEntry.setDescription('An entry in the vrPpIpPortBootpPStatsTable.')
vrPpIpPortBootpPInRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPInRequests.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPInRequests.setDescription('This attribute counts the total number of BOOTP Request messages received on this port.')
vrPpIpPortBootpPInReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPInReplies.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPInReplies.setDescription('This attribute counts the total number of BOOTP Reply messages received on this port.')
vrPpIpPortBootpPOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPOutRequests.setDescription('This attribute counts total the number of BOOTP Request messages broadcast out on this port.')
vrPpIpPortBootpPOutReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPOutReplies.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPOutReplies.setDescription('This attribute counts the total number of BOOTP Reply messages sent out on this port.')
vrPpIpPortBootpPInRequestErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPInRequestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPInRequestErrors.setDescription('This attribute counts the number of BOOTP Request messages received on this port but not forwarded due to an error. An error occurs if the BOOTP hop limit has been exceeded.')
vrPpIpPortBootpPInReplyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPInReplyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPInReplyErrors.setDescription('This attribute counts the number of BOOTP Reply messages received on this port but not forwarded due to an error. An error occurs if the giaddr field in the BOOTP reply does not match an IP address assigned to this VirtualRouter, or if the output IpPort for the BOOTP reply is not provisioned for BOOTP.')
vrPpIpPortBootpPAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 290), )
if mibBuilder.loadTexts: vrPpIpPortBootpPAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPAddrTable.setDescription("This attribute identifies a list of relay addresses. When a BOOTP request message is received on this port, the request will be forwarded to the IP addresses provisioned in relayAddress. Note that BOOTP requests are also broadcast out all other BootpPort's according to the relayForwardStatus of the outgoing port.")
vrPpIpPortBootpPAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 290, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrPpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortBootpPIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrPpIpPortBootpPAddrValue"))
if mibBuilder.loadTexts: vrPpIpPortBootpPAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPAddrEntry.setDescription('An entry in the vrPpIpPortBootpPAddrTable.')
vrPpIpPortBootpPAddrValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 290, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPpIpPortBootpPAddrValue.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPAddrValue.setDescription('This variable represents both the value and the index for the vrPpIpPortBootpPAddrTable.')
vrPpIpPortBootpPAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 3, 5, 4, 290, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vrPpIpPortBootpPAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPpIpPortBootpPAddrRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the vrPpIpPortBootpPAddrTable.')
vrIp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6))
vrIpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 1), )
if mibBuilder.loadTexts: vrIpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIp components.')
vrIpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"))
if mibBuilder.loadTexts: vrIpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRowStatusEntry.setDescription('A single entry in the table represents a single vrIp component.')
vrIpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIp components. These components can be added and deleted.')
vrIpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStorageType.setDescription('This variable represents the storage type value for the vrIp tables.')
vrIpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIndex.setDescription('This variable represents the index for the vrIp tables.')
vrIpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 100), )
if mibBuilder.loadTexts: vrIpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpProvTable.setDescription('This group contains global attributes for IP.')
vrIpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"))
if mibBuilder.loadTexts: vrIpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpProvEntry.setDescription('An entry in the vrIpProvTable.')
vrIpForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("gateway", 1))).clone('gateway')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpForwarding.setDescription('This attribute indicates whether or not this VR is acting as an IP gateway in respect to the forwarding of datagrams received by, but not addressed to, this VR')
vrIpDefaultTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 100, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(255, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpDefaultTtl.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpDefaultTtl.setDescription('This attribute is the default value inserted into the Time-To-Live field of the IP header of datagrams originated at this entity, whenever a Time- To-Live value is not supplied by the transport layer protocol. The value of this attribute deviates from the MIB requirement that it will always have a value of 255.')
vrIpCosPolicyAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 100, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpCosPolicyAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCosPolicyAssignment.setDescription('This attribute specifies the default cosPolicyGroup component that is associated with the IpPort of every protocol port on the vrirtual router. An individual IpPort can override this default using its own cosPolicyAssignment attribute. If this attribute is empty, CoS policy groups are assigned to only those IP ports where the cosPolicyAssignment attribute under the IpPort component is non-empty.')
vrIpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101), )
if mibBuilder.loadTexts: vrIpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStatsTable.setDescription('This is the GROUP holding the struct which contains statistical attributes for IP.')
vrIpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"))
if mibBuilder.loadTexts: vrIpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStatsEntry.setDescription('An entry in the vrIpStatsTable.')
vrIpInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpInReceives.setDescription('This is the number of input datagrams received from the interfaces, including those received in error . inReceives wraps to zero if reaches its maximum defined value.')
vrIpInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpInHdrErrors.setDescription('The number of input datagrams discarded due to errors in their IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc. inHdrErrors wraps to zero if reaches its maximum defined value.')
vrIpInAddrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpInAddrErrors.setDescription('The number of input datagrams discarded due to errors such as invalid address, unsupported address class. inAddrErrors wraps to zero if reaches its maximum defined value.')
vrIpForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpForwDatagrams.setDescription("The number of input datagrams for which this router was not their final IP destination, as a result of which an attempt was made to find a route to forward them to that final destination. forwDatagrams wraps to zero if reaches it's maximum defined value.")
vrIpInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpInUnknownProtos.setDescription('The number of locally-addressed datagrams received successfully but discarded because of an unknown or unsupported protocol inUnknownProtos wraps to zero if reaches its maximum defined value.')
vrIpInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpInDiscards.setDescription('The number of input datagrams for which no problems were encountered to prevent their continued processing, but which were discarded due to the lack of buffers. This does not include any datagram discarded while awaiting for re-assembly. inDiscards wraps to zero if reaches its maximum defined value.')
vrIpInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpInDelivers.setDescription('The number of input datagrams successfully delivered to IP user- protocols (including ICMP). inDelivers wraps to zero if reaches its maximum defined value.')
vrIpOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOutRequests.setDescription('The number of datagrams which local IP user-protocols (including ICMP) supplied to IP in requests for transmission. This sum does not include datagrams counted in ForwDatagrams. outRequests wraps to zero if reaches its maximum defined value.')
vrIpOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOutDiscards.setDescription('The number of outbound datagrams that were discarded due to the lack of buffers. This sum also includes datagrams counted in forwDatagrams if any such packets met the discard criterion. outDiscards wraps to zero if reaches its maximum defined value.')
vrIpOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOutNoRoutes.setDescription('The number of outbound datagrams discarded because no route could be found to transmit them to their destination. This counter includes any datagrams counted in forwDatagrams. outNoRoutes wraps to zero if reaches its maximum defined value.')
vrIpReasmTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpReasmTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpReasmTimeOut.setDescription('The maximum number of seconds, which received fragments are held while they are awaiting reassembly at this gateway.')
vrIpReasmReqds = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpReasmReqds.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpReasmReqds.setDescription('The number of the IP fragments received by this gateway which needed to be reassembled. reasmReqds wraps to zero if reaches its maximum defined value.')
vrIpReasmOks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpReasmOks.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpReasmOks.setDescription('The number of IP fragments successfully reassembled by this gateway. reasmOks wraps to zero if reaches its maximum defined value.')
vrIpReasmFails = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpReasmFails.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpReasmFails.setDescription('The number of times this gateway is unabled to assemble IP-fragments for whatever reasons. reasmFails wraps to zero if reaches its maximum defined value.')
vrIpFragOks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFragOks.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFragOks.setDescription('The number of IP datagrams that have been successfully fragmented by this gateway. fragOks wraps to zero if reaches its maximum defined value.')
vrIpFragFails = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFragFails.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFragFails.setDescription("The number of IP-fragments that have been discarded because they needed to be fragmented but could not be. For example, their Don't Fragment flag was set. fragFails wraps to zero if reaches its maximum defined value.")
vrIpFragCreates = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFragCreates.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFragCreates.setDescription('This number of IP fragments that have been generated as a result of fragmentation by this gateway. fragCreates wraps to zero if reaches its maximum defined value.')
vrIpRoutingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 101, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRoutingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRoutingDiscards.setDescription('The number of routing entries which were chosen to be discarded even though they are valid. One possible reason for discarding such an entry could be to free -up buffer space for other routing entries. In this implementation, this number is always zero because IP never deletes a valid routing entry.')
vrIpAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 102), )
if mibBuilder.loadTexts: vrIpAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrIpAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 102, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"))
if mibBuilder.loadTexts: vrIpAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpAdminControlEntry.setDescription('An entry in the vrIpAdminControlTable.')
vrIpSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 102, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrIpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 104), )
if mibBuilder.loadTexts: vrIpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 104, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"))
if mibBuilder.loadTexts: vrIpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStateEntry.setDescription('An entry in the vrIpStateTable.')
vrIpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 104, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 104, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 104, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 107), )
if mibBuilder.loadTexts: vrIpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrIpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 107, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"))
if mibBuilder.loadTexts: vrIpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOperStatusEntry.setDescription('An entry in the vrIpOperStatusTable.')
vrIpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 107, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrIpCtsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 394), )
if mibBuilder.loadTexts: vrIpCtsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCtsTable.setDescription('This attribute specifies the maximum number of entries that can exist in the IP local cache table on each LP. This attribute provides a way to control the resources allocated to the IP cache tables. The default cache table size is 3000 for an FP and 100 for a CP, is used if this attribute is not specified explicitly. The attribute value must be multiple of 100.')
vrIpCtsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 394, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpCtsIndex"))
if mibBuilder.loadTexts: vrIpCtsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCtsEntry.setDescription('An entry in the vrIpCtsTable.')
vrIpCtsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 394, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: vrIpCtsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCtsIndex.setDescription('This variable represents the vrIpCtsTable specific index for the vrIpCtsTable.')
vrIpCtsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 394, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 8000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpCtsValue.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCtsValue.setDescription('This variable represents an individual value for the vrIpCtsTable.')
vrIpFwd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3))
vrIpFwdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1), )
if mibBuilder.loadTexts: vrIpFwdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpFwd components.')
vrIpFwdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpFwdDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpFwdDestMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpFwdTypeOfServiceIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpFwdGatewayIndex"))
if mibBuilder.loadTexts: vrIpFwdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdRowStatusEntry.setDescription('A single entry in the table represents a single vrIpFwd component.')
vrIpFwdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpFwd components. These components cannot be added nor deleted.')
vrIpFwdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpFwdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdStorageType.setDescription('This variable represents the storage type value for the vrIpFwd tables.')
vrIpFwdDestAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpFwdDestAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdDestAddressIndex.setDescription('This variable represents an index for the vrIpFwd tables.')
vrIpFwdDestMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpFwdDestMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdDestMaskIndex.setDescription('This variable represents an index for the vrIpFwd tables.')
vrIpFwdTypeOfServiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31)))
if mibBuilder.loadTexts: vrIpFwdTypeOfServiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdTypeOfServiceIndex.setDescription('This variable represents an index for the vrIpFwd tables.')
vrIpFwdGatewayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: vrIpFwdGatewayIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdGatewayIndex.setDescription('This variable represents an index for the vrIpFwd tables.')
vrIpFwdOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10), )
if mibBuilder.loadTexts: vrIpFwdOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Identifies a group of operational attributes associated with each entry in the Forward Table.')
vrIpFwdOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpFwdDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpFwdDestMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpFwdTypeOfServiceIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpFwdGatewayIndex"))
if mibBuilder.loadTexts: vrIpFwdOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdOperEntry.setDescription('An entry in the vrIpFwdOperTable.')
vrIpFwdIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10, 1, 1), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdIfIndex.setDescription('This attribute specifies the SNMP index associated with the protocol port represented by the attribute protocolPortName, which identifies the local interface through which the next hop of this route should be reached.')
vrIpFwdType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notDefined", 1), ("invalid", 2), ("localInterface", 3), ("remoteDestination", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdType.setDescription('Specifies the type of the route,')
vrIpFwdProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdProtocol.setDescription('This Attribute identifies the routing mechanism by which this route was learned.')
vrIpFwdAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdAge.setDescription('This attribute specifies the number of seconds since this route was last updated or otherwise determined to be correct.')
vrIpFwdProtocolPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdProtocolPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdProtocolPortName.setDescription('Indicates the name of the protocol port by which the next hop of this route should be reached.')
vrIpFwdNextHopAs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 429467295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdNextHopAs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdNextHopAs.setDescription('This attribute specifies the Autonomous System number of the Next Hop. If unknown or not relevant to the protocol indicated by the attribute protocol, the value should be zero.')
vrIpFwdMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpFwdMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpFwdMetric.setDescription('This attribute specifies the primary routing metric for this route. The semantics of this metric are determined by the routing protocol specified by the value of the attribute protocol. If this metric is not used, its value should be set to -1.')
vrIpRdb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4))
vrIpRdbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1), )
if mibBuilder.loadTexts: vrIpRdbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpRdb components.')
vrIpRdbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRdbDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRdbDestMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRdbProtocolIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRdbGatewayIndex"))
if mibBuilder.loadTexts: vrIpRdbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbRowStatusEntry.setDescription('A single entry in the table represents a single vrIpRdb component.')
vrIpRdbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRdbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpRdb components. These components cannot be added nor deleted.')
vrIpRdbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRdbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpRdbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRdbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbStorageType.setDescription('This variable represents the storage type value for the vrIpRdb tables.')
vrIpRdbDestAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpRdbDestAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbDestAddressIndex.setDescription('This variable represents an index for the vrIpRdb tables.')
vrIpRdbDestMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpRdbDestMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbDestMaskIndex.setDescription('This variable represents an index for the vrIpRdb tables.')
vrIpRdbProtocolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("bogus", 1), ("local", 2), ("remote", 3), ("special", 4), ("ospf", 5), ("ospfExternal", 6), ("ospfType3Discard", 7), ("ospfType7Discard", 8), ("rip", 9), ("ripDiscard", 10), ("egp", 11), ("bgpExternal", 12), ("bgpInternal", 13), ("bgpAggrDiscard", 14), ("redistrib", 15))))
if mibBuilder.loadTexts: vrIpRdbProtocolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbProtocolIndex.setDescription('This variable represents an index for the vrIpRdb tables.')
vrIpRdbGatewayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: vrIpRdbGatewayIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbGatewayIndex.setDescription('This variable represents an index for the vrIpRdb tables.')
vrIpRdbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 10), )
if mibBuilder.loadTexts: vrIpRdbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Identifies a group of operational attributes associated with each entry in the routing database.')
vrIpRdbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRdbDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRdbDestMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRdbProtocolIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRdbGatewayIndex"))
if mibBuilder.loadTexts: vrIpRdbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbOperEntry.setDescription('An entry in the vrIpRdbOperTable.')
vrIpRdbMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRdbMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbMetric.setDescription('This attribute specifies the primary routing metric for this route. The semantics of this metric are determined by the routing protocol specified by the value of the index to this entry protocol. If this metric is not used, its value should be set to -1.')
vrIpRdbPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRdbPreference.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbPreference.setDescription('This attribute specifies the the preference value of this particular entry. The value of this attribute affects the way the routeEntries in this database are selected for installing it in the forwardingTable. The lower the preference value of this entry, the higher are the chances that this entry will be selected to install in the ForwardTable.')
vrIpRdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 4, 10, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRdbAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRdbAge.setDescription('This attribute specifies the number of seconds since this route was last updated or otherwise determined to be correct.')
vrIpIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5))
vrIpIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 1), )
if mibBuilder.loadTexts: vrIpIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpIf components.')
vrIpIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIfInterfaceAddressIndex"))
if mibBuilder.loadTexts: vrIpIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfRowStatusEntry.setDescription('A single entry in the table represents a single vrIpIf component.')
vrIpIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpIf components. These components cannot be added nor deleted.')
vrIpIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfStorageType.setDescription('This variable represents the storage type value for the vrIpIf tables.')
vrIpIfInterfaceAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpIfInterfaceAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfInterfaceAddressIndex.setDescription('This variable represents the index for the vrIpIf tables.')
vrIpIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10), )
if mibBuilder.loadTexts: vrIpIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Identifies a group of operational attributes associated with each entry in the Ip interface table.')
vrIpIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIfInterfaceAddressIndex"))
if mibBuilder.loadTexts: vrIpIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfOperEntry.setDescription('An entry in the vrIpIfOperTable.')
vrIpIfInterfaceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfInterfaceMask.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfInterfaceMask.setDescription('This attribute indicates the mask for this interface entry.')
vrIpIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfStatus.setDescription('This attribute specifies the status of the provisioned Ip logicalInterface entry. A value of disabled is used when the parent components Vr, Ip or ipPort is in a disabled state. A value of up is used when the interface is in an operational state. A state of down is used if the media associated with this interface is not ready or disabled.')
vrIpIfPPName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 23))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfPPName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfPPName.setDescription('Indicates the name of the protocol port this logicalIfEntry belongs to.')
vrIpIfMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("none", 1), ("tokenRing", 2), ("ethernet", 3), ("fddi", 4), ("x25", 5), ("frameRelay", 6), ("ppp", 7), ("clusterBridge", 8), ("virtualLink", 9), ("vcpEther", 10), ("vcpToken", 11), ("vns", 12), ("smds", 13), ("atmMpeVcEncap", 14), ("atmMpeLlcEncap", 15), ("lecEther", 16), ("lecToken", 17), ("tunnel", 18), ("virtual", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfMediaType.setDescription('This attribute indicates the media type of interface. When the interface is down, a value of none indicates the media stays down from the beginning. When the interface is down, a value of some valid media type indicates the media is brought down after it was up. Otherwise, when the interface is up or disabled, this attribute should reflect the proper media type of the interface.')
vrIpIfHardwareAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1, 5), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfHardwareAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfHardwareAddress.setDescription('This attribute specifies the hardware address of the media in canonical form if applicable. The non-canonical version of this address is indicated in ncHardwareAddress.')
vrIpIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfMtu.setDescription('This attribute specifies the maximum transmission unit applicable for this logicalInterface. A value of 0 is used for the interfaces where all the necessary information is not available to compute the mtu applicable for this interface.')
vrIpIfBroadcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfBroadcastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfBroadcastAddress.setDescription("This attribute indicates the destination IP address to be used by any application which needs to broadcast on this interface. The value is determined by the corresponding LogicalIf component's broadcastAddress attribute.")
vrIpIfNcHardwareAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 5, 10, 1, 8), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIfNcHardwareAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIfNcHardwareAddress.setDescription('This attribute is the non-canonical version of hardwareAddress. This attribute is not displayed for interfaces on non-LAN media.')
vrIpEgp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6))
vrIpEgpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 1), )
if mibBuilder.loadTexts: vrIpEgpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpEgp components.')
vrIpEgpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"))
if mibBuilder.loadTexts: vrIpEgpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpEgp component.')
vrIpEgpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpEgp components. These components can be added and deleted.')
vrIpEgpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpEgpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpStorageType.setDescription('This variable represents the storage type value for the vrIpEgp tables.')
vrIpEgpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpEgpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpIndex.setDescription('This variable represents the index for the vrIpEgp tables.')
vrIpEgpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 10), )
if mibBuilder.loadTexts: vrIpEgpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpProvTable.setDescription('This group contains the provisionable attributes for the EGP component')
vrIpEgpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"))
if mibBuilder.loadTexts: vrIpEgpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpProvEntry.setDescription('An entry in the vrIpEgpProvTable.')
vrIpEgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpAsId.setDescription('The autonomous system identifier for this EGP entity. The value of this asId can not be equal to the value of EgpNeighborEntry asId.')
vrIpEgpDefaultHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 900)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpDefaultHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpDefaultHelloInterval.setDescription("This attribute is used to configure the default hello interval for each neighbor. This attribute's value is used by the application for each EgpNeighbor whose helloInterval has not been set.")
vrIpEgpDefaultPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(120, 3600)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpDefaultPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpDefaultPollInterval.setDescription("This attribute is used to configure the default polling interval for the EGP Neighbor. This attribute's value is used by the application for each EgpNeighbor whose pollInterval has not been set.")
vrIpEgpMaxNatNets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpMaxNatNets.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpMaxNatNets.setDescription('This attribute is used to configure the maximum number of external natural networks this virtual router will be advertising via EGP.')
vrIpEgpMaxBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 16)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpMaxBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpMaxBufferSize.setDescription('This attribute specifies the maximum buffer size (in 1024 byte memory blocks) to be used for an EGP update to be sent.')
vrIpEgpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 11), )
if mibBuilder.loadTexts: vrIpEgpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpStatsTable.setDescription('These set of attributes identifies the statistics for the EGP component.')
vrIpEgpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"))
if mibBuilder.loadTexts: vrIpEgpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpStatsEntry.setDescription('An entry in the vrIpEgpStatsTable.')
vrIpEgpInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpInMsgs.setDescription('Identifies the number of EGP messages received without error. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpInErrorMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpInErrorMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpInErrorMsgs.setDescription('Identifies the sum of EGP error messages from all the neighbors. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpOutErrorMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpOutErrorMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpOutErrorMsgs.setDescription('Indicates the sum of Egp error messages sent to all the neighbors. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpInErrors.setDescription('Identifies the number of EGP messages that proved to be in error. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpOutMsgs.setDescription('The total number of locally generated EGP messages. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpOutErrors.setDescription('The number of EGP messages that were locally generated but were not sent out due to resource limitations within an EGP entity.This counter will wraparound once the value reaches the maximum value.')
vrIpEgpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 12), )
if mibBuilder.loadTexts: vrIpEgpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpEgpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"))
if mibBuilder.loadTexts: vrIpEgpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpStateEntry.setDescription('An entry in the vrIpEgpStateTable.')
vrIpEgpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpEgpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpEgpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpEgpAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 13), )
if mibBuilder.loadTexts: vrIpEgpAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrIpEgpAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"))
if mibBuilder.loadTexts: vrIpEgpAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpAdminControlEntry.setDescription('An entry in the vrIpEgpAdminControlTable.')
vrIpEgpSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrIpEgpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 16), )
if mibBuilder.loadTexts: vrIpEgpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrIpEgpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"))
if mibBuilder.loadTexts: vrIpEgpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpOperStatusEntry.setDescription('An entry in the vrIpEgpOperStatusTable.')
vrIpEgpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrIpEgpNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2))
vrIpEgpNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 1), )
if mibBuilder.loadTexts: vrIpEgpNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpEgpNbr components.')
vrIpEgpNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpNbrNeighborAddressIndex"))
if mibBuilder.loadTexts: vrIpEgpNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrRowStatusEntry.setDescription('A single entry in the table represents a single vrIpEgpNbr component.')
vrIpEgpNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpEgpNbr components. These components can be added and deleted.')
vrIpEgpNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpEgpNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrStorageType.setDescription('This variable represents the storage type value for the vrIpEgpNbr tables.')
vrIpEgpNbrNeighborAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpEgpNbrNeighborAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrNeighborAddressIndex.setDescription('This variable represents the index for the vrIpEgpNbr tables.')
vrIpEgpNbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10), )
if mibBuilder.loadTexts: vrIpEgpNbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrProvTable.setDescription('This group of attributes identify the provisionable attributes for this EGP neighbor.')
vrIpEgpNbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpNbrNeighborAddressIndex"))
if mibBuilder.loadTexts: vrIpEgpNbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrProvEntry.setDescription('An entry in the vrIpEgpNbrProvTable.')
vrIpEgpNbrAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpNbrAsId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrAsId.setDescription("The autonomous system identifier of this EGP peer. The value of this neighbor's asId should not be equal to the asId value of Egp entity")
vrIpEgpNbrMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpNbrMode.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrMode.setDescription('This attribute will indicate whether this neighbor is being configured as an active or passive neighbor.')
vrIpEgpNbrGenerateDefaultRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpNbrGenerateDefaultRoute.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrGenerateDefaultRoute.setDescription('This attribute distinguishes whether or not the default route should be generated. This route is put in the EGP update along with the normal EGP update routes when updates are sent to this EGP neighbor')
vrIpEgpNbrDefaultRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpNbrDefaultRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrDefaultRouteMetric.setDescription("This attribute identifies the Metric to be used for propagating the 'Default Route'. The value of defaultRouteMetric is used only in the case where the value of the attribute generateDefaultRoute is set to yes.")
vrIpEgpNbrDefaultMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpNbrDefaultMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrDefaultMetric.setDescription('This attribute identifies the default metric value for routes that are exported to this EgpNeighbor. This value is used when exporting routes to this neighbor and no Export policy applies a different metric.')
vrIpEgpNbrHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 120)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpNbrHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrHelloInterval.setDescription('This attribute identifies the interval in seconds, between EGP hello command retransmissions. This is the P1 timer in the RFC904. This value may change in operation due to negotiations.')
vrIpEgpNbrPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(120, 480)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpNbrPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrPollInterval.setDescription('This attribute identifies the interval in seconds, between EGP poll command retransmissions. This is the P2 timer in the RFC904. This value may change in operation due to negotiations.')
vrIpEgpNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11), )
if mibBuilder.loadTexts: vrIpEgpNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrOperTable.setDescription('This group of attributes identifies the operational set of attributes for the NeighborEntry component.')
vrIpEgpNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpNbrNeighborAddressIndex"))
if mibBuilder.loadTexts: vrIpEgpNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrOperEntry.setDescription('An entry in the vrIpEgpNbrOperTable.')
vrIpEgpNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("idle", 1), ("acquisition", 2), ("down", 3), ("up", 4), ("cease", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrState.setDescription("This attribute describes the state of the local system with respect to this entry's EGP Neighbor.")
vrIpEgpNbrInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrInMsgs.setDescription('The number of EGP messages received without error from the EGP peer. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpNbrInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrInErrors.setDescription('The number of messages received from this EGP peer that proved to be in error. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpNbrOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrOutMsgs.setDescription('The number of locally generated EGP messages for this EGP peer. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpNbrOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrOutErrors.setDescription('The number of locally generated EGP messages not sent to this EGP peer due to resource limitations within an EGP entity.This counter will wraparound once the value reaches the maximum value.')
vrIpEgpNbrInErrorMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrInErrorMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrInErrorMsgs.setDescription('The number of EGP-defined error messages received from this EGP peer.This counter will wraparound once the value reaches the maximum value.')
vrIpEgpNbrOutErrorMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrOutErrorMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrOutErrorMsgs.setDescription('The number of EGP-defined error messages sent to this EGP peer.This counter will wraparound once the value reaches the maximum value.')
vrIpEgpNbrStateUps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrStateUps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrStateUps.setDescription('The number of EGP state transitions to the UP state with this EGP peer. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpNbrStateDowns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrStateDowns.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrStateDowns.setDescription('The number of EGP state transitions from the UP state to any other state with this EGP peer. This counter will wraparound once the value reaches the maximum value.')
vrIpEgpNbrEventTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 2, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("stop", 2))).clone('start')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpNbrEventTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpNbrEventTrigger.setDescription('This attribute is used to control the state of the Neighbor. It is not allowed to change. This attribute from SNMP perspective deviates from MIB that it is made READONLY.')
vrIpEgpImport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3))
vrIpEgpImportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 1), )
if mibBuilder.loadTexts: vrIpEgpImportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpEgpImport components.')
vrIpEgpImportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpImportIndex"))
if mibBuilder.loadTexts: vrIpEgpImportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportRowStatusEntry.setDescription('A single entry in the table represents a single vrIpEgpImport component.')
vrIpEgpImportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpImportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpEgpImport components. These components can be added and deleted.')
vrIpEgpImportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpImportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpEgpImportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpImportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportStorageType.setDescription('This variable represents the storage type value for the vrIpEgpImport tables.')
vrIpEgpImportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpEgpImportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportIndex.setDescription('This variable represents the index for the vrIpEgpImport tables.')
vrIpEgpImportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 10), )
if mibBuilder.loadTexts: vrIpEgpImportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportProvTable.setDescription('These set of attributes describe the provisionable attributes for the import component.')
vrIpEgpImportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpImportIndex"))
if mibBuilder.loadTexts: vrIpEgpImportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportProvEntry.setDescription('An entry in the vrIpEgpImportProvTable.')
vrIpEgpImportUsageFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("use", 1), ("ignore", 2))).clone('use')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpImportUsageFlag.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportUsageFlag.setDescription('This flag will determine whether or not EGP will use or ignore information in updates received. If the attribute nbrAsId is not specified or any of the NetworkList components are not added, then this attribute when set to ignore will ignore all incoming information.')
vrIpEgpImportImportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpImportImportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportImportMetric.setDescription("This attribute is used to set the metric value to be included in the routing table for any routes sent because this particular import instance was it's 'best match' policy. However this attribute is not a selection key. It should not use or ignore a particular metric value. If the value for this attribute is not specified, then the metric value received in an Egp update will be used. Note: When setting this value, caution should be taken to set the metric value in all relevant Import components to make sure that all matching policies for a given route have the same metric set. This will insure that there are no situations where a specific metric was desired, but doesn't get used in the update because the 'best match' policy for that situation did not set the metric parameter. If the attribute usageFlag for this import policy is set to ignore, then the importMetric value will be ignored by the application. The importMetric value is not used to select which routes to use or ignore but is used to set the metric value for the routes being imported. A value of zero indicates that the metric received in the update will be used.")
vrIpEgpImportNbrAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpImportNbrAsId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNbrAsId.setDescription("The autonomous system Id this import policy will apply to. Note: The Valid value of an asId is from 1 to 65,535. This attribute's value when set to 0 will be ignored.")
vrIpEgpImportNet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2))
vrIpEgpImportNetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 1), )
if mibBuilder.loadTexts: vrIpEgpImportNetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpEgpImportNet components.')
vrIpEgpImportNetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpImportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpImportNetIndex"))
if mibBuilder.loadTexts: vrIpEgpImportNetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetRowStatusEntry.setDescription('A single entry in the table represents a single vrIpEgpImportNet component.')
vrIpEgpImportNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpImportNetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpEgpImportNet components. These components can be added and deleted.')
vrIpEgpImportNetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpImportNetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpEgpImportNetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpImportNetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetStorageType.setDescription('This variable represents the storage type value for the vrIpEgpImportNet tables.')
vrIpEgpImportNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpEgpImportNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetIndex.setDescription('This variable represents the index for the vrIpEgpImportNet tables.')
vrIpEgpImportNetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 10), )
if mibBuilder.loadTexts: vrIpEgpImportNetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetProvTable.setDescription('This group identifies attributes for the NetworkList component for which the import policy will be applied to')
vrIpEgpImportNetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpImportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpImportNetIndex"))
if mibBuilder.loadTexts: vrIpEgpImportNetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetProvEntry.setDescription('An entry in the vrIpEgpImportNetProvTable.')
vrIpEgpImportNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 3, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpImportNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpImportNetIpAddress.setDescription('This attribute identifies the IP address that needs to be matched against in this network list for the Import policy to be applied to.')
vrIpEgpExport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4))
vrIpEgpExportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 1), )
if mibBuilder.loadTexts: vrIpEgpExportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpEgpExport components.')
vrIpEgpExportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpExportIndex"))
if mibBuilder.loadTexts: vrIpEgpExportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportRowStatusEntry.setDescription('A single entry in the table represents a single vrIpEgpExport component.')
vrIpEgpExportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpEgpExport components. These components can be added and deleted.')
vrIpEgpExportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpExportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpEgpExportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpExportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportStorageType.setDescription('This variable represents the storage type value for the vrIpEgpExport tables.')
vrIpEgpExportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpEgpExportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportIndex.setDescription('This variable represents the index for the vrIpEgpExport tables.')
vrIpEgpExportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10), )
if mibBuilder.loadTexts: vrIpEgpExportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportProvTable.setDescription('This group contains all the provisioned attributes for the Export component.')
vrIpEgpExportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpExportIndex"))
if mibBuilder.loadTexts: vrIpEgpExportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportProvEntry.setDescription('An entry in the vrIpEgpExportProvTable.')
vrIpEgpExportAdvertiseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("block", 2))).clone('send')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportAdvertiseStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportAdvertiseStatus.setDescription('This attribute specifies if the routes that match this export policy are advertised (send) or not advertised (block).')
vrIpEgpExportExportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportExportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportExportMetric.setDescription('This attribute specifies the metric to be used on the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of exportMetric is ignored. The exportMetric value is not used to select which routes to block or send, but rather the metric value advertised for the routes. A value of 0 indicates that the metric associated with the route in the forwarding table is used.')
vrIpEgpExportProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("all", 1), ("egp", 2), ("rip", 3), ("ospfInternal", 4), ("ospfExternal", 5), ("staticLocal", 6), ("staticRemote", 7))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportProtocol.setDescription('This attribute specifies the routes to which this export policy applies based on the routing protocol of how the routes are learned. If it is set to all, this export policy applies to all routes in the forwarding table.')
vrIpEgpExportRipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportRipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportRipInterface.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP interface from which the routes are learned. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP interface on the same virtual router; otherwise the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router.')
vrIpEgpExportRipNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportRipNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportRipNeighbor.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP neighbor of which the routes are learned from. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP neighbor.')
vrIpEgpExportInEgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportInEgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportInEgpAsId.setDescription('This attribute specifies the EGP learned routes to which this export policy applies, based on the EGP autonomous system identifier of which the routes are learned from. This attribute can only be non zero when protocol is set to egp. The value of 0 implies any EGP autonomous system; otherwise the value of this attribute must match the asId of an EGP neighbor on the same virtual router.')
vrIpEgpExportOspfTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(4294967295)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportOspfTag.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportOspfTag.setDescription('This attribute specifies the OSPF learned external routes to which this export policy applies, based on the learned OSPF tag of the routes. This attribute can only be set to a non default value when protocol is set to ospfExternal. The value of 4294967295 implies any tag.')
vrIpEgpExportOutAutonomousSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportOutAutonomousSystem.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportOutAutonomousSystem.setDescription('This attribute specifies the EGP autonomous system to which routes are exported to as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of outAutonomousSystem is ignored. The outAutonomousSystem value is not used to select which routes to block or send but where to export the routes. A value of 0 indicates that the routes are exported to all EGP autonomous systems of which the virtual router is a neighbor. Otherwise, the value of this attribute must match the asId of an EGP neighbor on the same virtual router.')
vrIpEgpExportNet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2))
vrIpEgpExportNetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 1), )
if mibBuilder.loadTexts: vrIpEgpExportNetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpEgpExportNet components.')
vrIpEgpExportNetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpExportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpExportNetIndex"))
if mibBuilder.loadTexts: vrIpEgpExportNetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetRowStatusEntry.setDescription('A single entry in the table represents a single vrIpEgpExportNet component.')
vrIpEgpExportNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportNetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpEgpExportNet components. These components can be added and deleted.')
vrIpEgpExportNetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpExportNetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpEgpExportNetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpEgpExportNetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetStorageType.setDescription('This variable represents the storage type value for the vrIpEgpExportNet tables.')
vrIpEgpExportNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpEgpExportNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetIndex.setDescription('This variable represents the index for the vrIpEgpExportNet tables.')
vrIpEgpExportNetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 10), )
if mibBuilder.loadTexts: vrIpEgpExportNetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetProvTable.setDescription('This group identifies the set of provisionable attributes for the ExportNetworkList component.')
vrIpEgpExportNetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpExportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpEgpExportNetIndex"))
if mibBuilder.loadTexts: vrIpEgpExportNetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetProvEntry.setDescription('An entry in the vrIpEgpExportNetProvTable.')
vrIpEgpExportNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 6, 4, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpEgpExportNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpEgpExportNetIpAddress.setDescription('This attribute identifies the 32 bit IP address to match against.')
vrIpOspf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7))
vrIpOspfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 1), )
if mibBuilder.loadTexts: vrIpOspfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpOspf components.')
vrIpOspfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"))
if mibBuilder.loadTexts: vrIpOspfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspf component.')
vrIpOspfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspf components. These components can be added and deleted.')
vrIpOspfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStorageType.setDescription('This variable represents the storage type value for the vrIpOspf tables.')
vrIpOspfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpOspfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfIndex.setDescription('This variable represents the index for the vrIpOspf tables.')
vrIpOspfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100), )
if mibBuilder.loadTexts: vrIpOspfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfProvTable.setDescription('This group of attributes are used to configure the OSPF component.')
vrIpOspfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"))
if mibBuilder.loadTexts: vrIpOspfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfProvEntry.setDescription('An entry in the vrIpOspfProvTable.')
vrIpOspfRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1, 1), RouterID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfRouterId.setDescription('This attribute is an Ip Address that uniquely identifies the router in the autonomous system.')
vrIpOspfSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfSnmpAdminStatus.setDescription('The administrative status of the OSPF Component in this Virtual Router.')
vrIpOspfAsBdrRtrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfAsBdrRtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAsBdrRtrStatus.setDescription('This attribute is a flag to note whether this router is an autonomous system border router. If this router is configured to export any routes learned from other than OSPF-internal protocol, this attribute should be configured as autonomous system border router.')
vrIpOspfTosSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfTosSupport.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfTosSupport.setDescription("The router's support for type-of-service routing. Only one value will be allowed. This is a deviation from supporting the MIB.")
vrIpOspfExtLsdbLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExtLsdbLimit.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbLimit.setDescription("The maximum number of external link-state entries that can be stored in the link-state database. If the value is -1, then there is no limit, that is the maximum number of external OSPF routes that this autonomous system border router will originate. It will begin to flush LSA(Link State Advertisement)s, if an ASBR might receive bursts of external routes (for example, a regional network), then the parameter should be configured to a reasonable level. If there are less than two thousand routes and large bursts are unlikely, then the default should be adequate. This parameter will not affect the number of external OSPF routes a router will store in it's database.")
vrIpOspfMulticastForward = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfMulticastForward.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfMulticastForward.setDescription('A bit mask indicating the limits on Network Layer Multicast(class D) forwarding. It is represented as a sum of the following: if intra-Area forwarding is permitted, 1; else 0 if inter-Area forwarding is permitted 2; else 0 if inter-AS forwarding is permitted, 4; else 0 Only the value of 0 is being supported and this is a MIB deviation.')
vrIpOspfMigrateRip = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfMigrateRip.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfMigrateRip.setDescription('This Attribute sets the preference level of OSPF-internal routes to be less preferred than RIP. This Parameter should only be used when starting migration of network from RIP to OSPF. When ready to cutover to OSPF, set this attribute disabled and run under normal preferences. All OSPF routers in the Autonomous System should be running with migraterip enabled or with migraterip disabled to prevent routing loops. It is important that the changeover period from RIP to OSPF be performed quickly on all OSPF routers so that no routing loops are formed. These routing loops could be caused by conflicts in the internal RIP and OSPF databases.')
vrIpOspfGenerateDefaultRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 100, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfGenerateDefaultRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfGenerateDefaultRouteMetric.setDescription('If this router is configured as an autonomous system border router, then this attribute causes the default route to be generated with a metric value equal to generateDefaultRouteMetric value. This route is put in the OSPF update along with the normal update routes when updates are sent to the neighbors. No default route will be generated if the value is 0.')
vrIpOspfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 101), )
if mibBuilder.loadTexts: vrIpOspfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfOperTable.setDescription('These group of attributes identifies the operational attributes for this OSPF Component.')
vrIpOspfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 101, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"))
if mibBuilder.loadTexts: vrIpOspfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfOperEntry.setDescription('An entry in the vrIpOspfOperTable.')
vrIpOspfVersionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 101, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 2)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVersionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVersionNumber.setDescription('The Current Version number of the OSPF Protocol. (2).')
vrIpOspfAreaBdrRtrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 101, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAreaBdrRtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaBdrRtrStatus.setDescription('This attribute is used to specify whether this router is configured as an area border router.')
vrIpOspfExternLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 101, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExternLsaCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExternLsaCount.setDescription('The number of external (LS type 5) link-state advertisements in the link- state database.')
vrIpOspfExternLsaChecksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 101, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExternLsaChecksumSum.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExternLsaChecksumSum.setDescription("The 32-bit unsigned sum of the LS checksums of the external link-state database. This sum can be used to determine if there has been a change in a router's link state database, and to compare the link-state database of two routers.")
vrIpOspfOriginateNewLsas = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 101, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfOriginateNewLsas.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfOriginateNewLsas.setDescription('The number of new link-state advertisements that have been originated. This number is incremented each time the router originates a new LSA.')
vrIpOspfRxNewLsas = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 101, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfRxNewLsas.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfRxNewLsas.setDescription('The number of link-state advertisements received determined to be new instantiations. This number does not include newer instantiations of self- originated link-state advertisements.')
vrIpOspfStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 102), )
if mibBuilder.loadTexts: vrIpOspfStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpOspfStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 102, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"))
if mibBuilder.loadTexts: vrIpOspfStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStateEntry.setDescription('An entry in the vrIpOspfStateTable.')
vrIpOspfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 102, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpOspfOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 102, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpOspfUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 102, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpOspfOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 105), )
if mibBuilder.loadTexts: vrIpOspfOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrIpOspfOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 105, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"))
if mibBuilder.loadTexts: vrIpOspfOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfOperStatusEntry.setDescription('An entry in the vrIpOspfOperStatusTable.')
vrIpOspfSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 105, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrIpOspfArea = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2))
vrIpOspfAreaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 1), )
if mibBuilder.loadTexts: vrIpOspfAreaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpOspfArea components.')
vrIpOspfAreaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAreaAreaIdIndex"))
if mibBuilder.loadTexts: vrIpOspfAreaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfArea component.')
vrIpOspfAreaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfAreaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfArea components. These components can be added and deleted.')
vrIpOspfAreaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAreaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfAreaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAreaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaStorageType.setDescription('This variable represents the storage type value for the vrIpOspfArea tables.')
vrIpOspfAreaAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpOspfAreaAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaAreaIdIndex.setDescription('This variable represents the index for the vrIpOspfArea tables.')
vrIpOspfAreaProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 10), )
if mibBuilder.loadTexts: vrIpOspfAreaProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaProvTable.setDescription('This group describes the set of provisionable attributes for the AreaEntry Component.')
vrIpOspfAreaProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAreaAreaIdIndex"))
if mibBuilder.loadTexts: vrIpOspfAreaProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaProvEntry.setDescription('An entry in the vrIpOspfAreaProvTable.')
vrIpOspfAreaAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("simplePassword", 1))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfAreaAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaAuthType.setDescription('The authentication type specified for this area.')
vrIpOspfAreaImportAsExtern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("importExternal", 1), ("importNoExternal", 2), ("importNssa", 3))).clone('importExternal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfAreaImportAsExtern.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaImportAsExtern.setDescription("The area's support for importing AS external link-state advertisements. For backbone area (that is, areaId 0.0.0.0), this attribute must be set to importExternal.")
vrIpOspfAreaAreaSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAreaSummary", 1), ("sendAreaSummary", 2))).clone('noAreaSummary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfAreaAreaSummary.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaAreaSummary.setDescription('This variable controls the import of summary LSAs into stub areas. If it is noAreaSummary, the router will neither originate nor propagate summary LSAs into the stub areas. It will rely entirely on its default route. If it is sendAreaSummary, the router will both summarize and propagate summary LSAs.')
vrIpOspfAreaOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 11), )
if mibBuilder.loadTexts: vrIpOspfAreaOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaOperTable.setDescription('This group of attributes describes the Operational set of attributes for the AreaEntry component.')
vrIpOspfAreaOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAreaAreaIdIndex"))
if mibBuilder.loadTexts: vrIpOspfAreaOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaOperEntry.setDescription('An entry in the vrIpOspfAreaOperTable.')
vrIpOspfAreaSpfRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAreaSpfRuns.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaSpfRuns.setDescription("The number of times that the intra-area route table has been calculated using this area's link-state database since the protocol became operational.")
vrIpOspfAreaAreaBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 11, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAreaAreaBdrRtrCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaAreaBdrRtrCount.setDescription('The total number of area border routers reachable within this area. This is initially zero, and is calculated in each Shortest Path First Pass.')
vrIpOspfAreaAsBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 11, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAreaAsBdrRtrCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaAsBdrRtrCount.setDescription('The total number of Autonomous System border routers reachable within this area. This is initially zero, and is calculated in each Shortest Path First Pass.')
vrIpOspfAreaLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 11, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAreaLsaCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaLsaCount.setDescription("The total number of link-state advertisements in this area's link-state database, excluding AS External LSA's.")
vrIpOspfAreaAreaLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 2, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAreaAreaLsaCksumSum.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAreaAreaLsaCksumSum.setDescription("The 32-bit unsigned sum of the link-state advertisement's LS checksums contained in this area's link-state database. This sum excludes external (LS type 5) link-state advertisements. The sum can be used to determine if there has been a change in a router's link state database, and to compare the link-state database of two routers.")
vrIpOspfStub = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3))
vrIpOspfStubRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 1), )
if mibBuilder.loadTexts: vrIpOspfStubRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpOspfStub components.')
vrIpOspfStubRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfStubAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfStubTosIndex"))
if mibBuilder.loadTexts: vrIpOspfStubRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfStub component.')
vrIpOspfStubRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfStubRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfStub components. These components can be added and deleted.')
vrIpOspfStubComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfStubComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfStubStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfStubStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubStorageType.setDescription('This variable represents the storage type value for the vrIpOspfStub tables.')
vrIpOspfStubAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpOspfStubAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubAreaIdIndex.setDescription('This variable represents an index for the vrIpOspfStub tables.')
vrIpOspfStubTosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: vrIpOspfStubTosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubTosIndex.setDescription('This variable represents an index for the vrIpOspfStub tables.')
vrIpOspfStubProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 10), )
if mibBuilder.loadTexts: vrIpOspfStubProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubProvTable.setDescription('These set of attributes explain the provisionable group for the StubAreaEntry.')
vrIpOspfStubProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfStubAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfStubTosIndex"))
if mibBuilder.loadTexts: vrIpOspfStubProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubProvEntry.setDescription('An entry in the vrIpOspfStubProvTable.')
vrIpOspfStubMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfStubMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubMetric.setDescription('The metric value applied at the indicated type of service.')
vrIpOspfStubMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ospfMetric", 1), ("comparableCost", 2), ("nonComparable", 3))).clone('ospfMetric')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfStubMetricType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubMetricType.setDescription('This type of the metric advertised as a default route.')
vrIpOspfStubAdvertiseDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfStubAdvertiseDefault.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfStubAdvertiseDefault.setDescription('This attribute determines whether or not the default routing information will be advertised, depending on other criterion. Setting this value to no can prevent advertising default routing information. If the value of the attribute is set to yes, then the value of the attribute importAsExtern for that particular AreaEntry should be set to importNssa.')
vrIpOspfAggregate = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5))
vrIpOspfAggregateRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1), )
if mibBuilder.loadTexts: vrIpOspfAggregateRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpOspfAggregate components.')
vrIpOspfAggregateRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAggregateAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAggregateLsdbTypeIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAggregateAggregateNetIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAggregateAggregateMaskIndex"))
if mibBuilder.loadTexts: vrIpOspfAggregateRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfAggregate component.')
vrIpOspfAggregateRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfAggregateRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfAggregate components. These components can be added and deleted.')
vrIpOspfAggregateComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAggregateComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfAggregateStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfAggregateStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateStorageType.setDescription('This variable represents the storage type value for the vrIpOspfAggregate tables.')
vrIpOspfAggregateAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpOspfAggregateAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateAreaIdIndex.setDescription('This variable represents an index for the vrIpOspfAggregate tables.')
vrIpOspfAggregateLsdbTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 7))).clone(namedValues=NamedValues(("summaryLink", 3), ("nssaExternalLink", 7))))
if mibBuilder.loadTexts: vrIpOspfAggregateLsdbTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateLsdbTypeIndex.setDescription('This variable represents an index for the vrIpOspfAggregate tables.')
vrIpOspfAggregateAggregateNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: vrIpOspfAggregateAggregateNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateAggregateNetIndex.setDescription('This variable represents an index for the vrIpOspfAggregate tables.')
vrIpOspfAggregateAggregateMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: vrIpOspfAggregateAggregateMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateAggregateMaskIndex.setDescription('This variable represents an index for the vrIpOspfAggregate tables.')
vrIpOspfAggregateProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 10), )
if mibBuilder.loadTexts: vrIpOspfAggregateProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateProvTable.setDescription('Identifies a group of provisionable attributes.')
vrIpOspfAggregateProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAggregateAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAggregateLsdbTypeIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAggregateAggregateNetIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfAggregateAggregateMaskIndex"))
if mibBuilder.loadTexts: vrIpOspfAggregateProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateProvEntry.setDescription('An entry in the vrIpOspfAggregateProvTable.')
vrIpOspfAggregateEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("advertiseMatching", 1), ("doNotAdvertiseMatching", 2), ("invalid", 3))).clone('advertiseMatching')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfAggregateEffect.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfAggregateEffect.setDescription('This attribute determines whether or not the routing information will be advertised, depending on other criterion. Setting this value to doNotAdvertiseMatching can prevent advertising routing information for the address and mask values specified as the indices for this entry.')
vrIpOspfHost = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6))
vrIpOspfHostRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 1), )
if mibBuilder.loadTexts: vrIpOspfHostRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpOspfHost components.')
vrIpOspfHostRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfHostAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfHostTosIndex"))
if mibBuilder.loadTexts: vrIpOspfHostRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfHost component.')
vrIpOspfHostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfHostRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfHost components. These components can be added and deleted.')
vrIpOspfHostComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfHostComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfHostStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfHostStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostStorageType.setDescription('This variable represents the storage type value for the vrIpOspfHost tables.')
vrIpOspfHostAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpOspfHostAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostAddressIndex.setDescription('This variable represents an index for the vrIpOspfHost tables.')
vrIpOspfHostTosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: vrIpOspfHostTosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostTosIndex.setDescription('This variable represents an index for the vrIpOspfHost tables.')
vrIpOspfHostProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 10), )
if mibBuilder.loadTexts: vrIpOspfHostProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostProvTable.setDescription('Provisionable set of attributes for the Host entry.')
vrIpOspfHostProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfHostAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfHostTosIndex"))
if mibBuilder.loadTexts: vrIpOspfHostProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostProvEntry.setDescription('An entry in the vrIpOspfHostProvTable.')
vrIpOspfHostAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 10, 1, 1), AreaID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfHostAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostAreaId.setDescription('This is an Ip address for the Host Entry that indicates the area it belongs to.')
vrIpOspfHostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfHostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfHostMetric.setDescription('The metric to be advertised.')
vrIpOspfVirtIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7))
vrIpOspfVirtIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 1), )
if mibBuilder.loadTexts: vrIpOspfVirtIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpOspfVirtIf components.')
vrIpOspfVirtIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtIfAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtIfNbrRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfVirtIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfVirtIf component.')
vrIpOspfVirtIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfVirtIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfVirtIf components. These components can be added and deleted.')
vrIpOspfVirtIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfVirtIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfStorageType.setDescription('This variable represents the storage type value for the vrIpOspfVirtIf tables.')
vrIpOspfVirtIfAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpOspfVirtIfAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfAreaIdIndex.setDescription('This variable represents an index for the vrIpOspfVirtIf tables.')
vrIpOspfVirtIfNbrRouterIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpOspfVirtIfNbrRouterIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfNbrRouterIdIndex.setDescription('This variable represents an index for the vrIpOspfVirtIf tables.')
vrIpOspfVirtIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 10), )
if mibBuilder.loadTexts: vrIpOspfVirtIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfProvTable.setDescription('This group of attributes provide provisioning data for the VirtIfEntry.')
vrIpOspfVirtIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtIfAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtIfNbrRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfVirtIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfProvEntry.setDescription('An entry in the vrIpOspfVirtIfProvTable.')
vrIpOspfVirtIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfVirtIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a link-state update packet over this interface.')
vrIpOspfVirtIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfVirtIfRetransInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfRetransInterval.setDescription('The number of seconds between link-state advertisement retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets. This value would be well over the expected round-trip time.')
vrIpOspfVirtIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfVirtIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfHelloInterval.setDescription('The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for the virtual neighbor.')
vrIpOspfVirtIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfVirtIfRtrDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfRtrDeadInterval.setDescription("The number of seconds that a router's Hello packets have not been seen before its neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for the virtual neighbor.")
vrIpOspfVirtIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 10, 1, 5), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)).clone(hexValue="0000000000000000")).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vrIpOspfVirtIfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfAuthKey.setDescription('If authentication type is simple password, the password for this virtual circuit. If the value of the attribute is not set, then this attribute is ignored by the application. If the value of this attribute is set, then the value of the attribute authType under this particular Area should be set to simplePassword, otherwise the application will ignore this authentication key.')
vrIpOspfVirtIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 11), )
if mibBuilder.loadTexts: vrIpOspfVirtIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfOperTable.setDescription('Represents a group of operational attributes for the VirtIfEntry component.')
vrIpOspfVirtIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtIfAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtIfNbrRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfVirtIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfOperEntry.setDescription('An entry in the vrIpOspfVirtIfOperTable.')
vrIpOspfVirtIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("down", 1), ("pointToPoint", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtIfState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfState.setDescription('The state of the OSPF virtual interface.')
vrIpOspfVirtIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 7, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtIfEvents.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtIfEvents.setDescription('The number of state changes or error events on the virtual link.')
vrIpOspfExport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8))
vrIpOspfExportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 1), )
if mibBuilder.loadTexts: vrIpOspfExportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpOspfExport components.')
vrIpOspfExportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExportIndex"))
if mibBuilder.loadTexts: vrIpOspfExportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfExport component.')
vrIpOspfExportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfExport components. These components can be added and deleted.')
vrIpOspfExportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfExportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportStorageType.setDescription('This variable represents the storage type value for the vrIpOspfExport tables.')
vrIpOspfExportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpOspfExportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportIndex.setDescription('This variable represents the index for the vrIpOspfExport tables.')
vrIpOspfExportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10), )
if mibBuilder.loadTexts: vrIpOspfExportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportProvTable.setDescription('This Group contains all the Provisioned attributes for the Export Component.')
vrIpOspfExportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExportIndex"))
if mibBuilder.loadTexts: vrIpOspfExportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportProvEntry.setDescription('An entry in the vrIpOspfExportProvTable.')
vrIpOspfExportAdvertiseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("block", 2))).clone('send')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportAdvertiseStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportAdvertiseStatus.setDescription('This attribute specifies if the routes that match this export policy are advertised (send) or not advertised (block).')
vrIpOspfExportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 16777215)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportMetric.setDescription('This attribute specifies the metric to be used on the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of metric is ignored. The metric value is not used to select which routes to block or send, but rather the metric value advertised for the routes. A value of -1 indicates that the metric associated with the route in the forwarding table is used.')
vrIpOspfExportProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 6, 7, 9))).clone(namedValues=NamedValues(("all", 1), ("egp", 2), ("rip", 3), ("staticLocal", 6), ("staticRemote", 7), ("bgpExternal", 9))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportProtocol.setDescription('This attribute specifies the routes to which this export policy applies based on the routing protocol of how the routes are learned. If it is set to all, this export policy applies to all routes in the forwarding table.')
vrIpOspfExportRipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportRipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportRipInterface.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP interface from which the routes are learned. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP interface on the same virtual router; otherwise the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router.')
vrIpOspfExportRipNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportRipNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportRipNeighbor.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP neighbor of which the routes are learned from. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP neighbor.')
vrIpOspfExportEgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportEgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportEgpAsId.setDescription('This attribute specifies the EGP learned routes to which this export policy applies, based on the EGP autonomous system identifier of which the routes are learned from. This attribute can only be non zero when protocol is set to egp. The value of 0 implies any EGP autonomous system; otherwise the value of this attribute must match the asId of an EGP neighbor on the same virtual router.')
vrIpOspfExportTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(4294967295)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportTag.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportTag.setDescription('This attribute specifies the OSPF tag to be used on the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of tag is ignored. The tag value is not used to select which routes to block or send, but rather the tag value advertised for the routes. A value of 4294967295 indicates that the tag associated with the route in the forwarding table is used.')
vrIpOspfExportExtLsaMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("useProtocolDefault", 0), ("type1", 1), ("type2", 2))).clone('useProtocolDefault')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportExtLsaMetricType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportExtLsaMetricType.setDescription('This attribute specifies the metric type in the OSPF external link state advertisement of the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of extLsaMetricType is ignored. The extLsaMetricType value is not used to select which routes to block or send, but rather the metric value advertised for the routes. The value useProtocolDefault indicates the metric type is automatically chosen based on the routing protocol which the route was learned from.')
vrIpOspfExportBgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportBgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportBgpAsId.setDescription('This key attribute specifies the bgp AS from which a bgp route is learned from. This key is used only if the protocol is bgpExternal. bgpAsId of value 0 mathces all ASs.')
vrIpOspfExportBgpPeerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 10, 1, 10), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportBgpPeerIp.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportBgpPeerIp.setDescription('This key attribute specifies the bgp peer where the routes were learned from. bgpPeerIp of 0 matches all bgp peers. This attribute is used as a key when protocol is set to bgpInternal or bgpExternal.')
vrIpOspfExportNetList = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2))
vrIpOspfExportNetListRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 1), )
if mibBuilder.loadTexts: vrIpOspfExportNetListRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpOspfExportNetList components.')
vrIpOspfExportNetListRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExportNetListIndex"))
if mibBuilder.loadTexts: vrIpOspfExportNetListRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfExportNetList component.')
vrIpOspfExportNetListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportNetListRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfExportNetList components. These components can be added and deleted.')
vrIpOspfExportNetListComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExportNetListComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfExportNetListStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExportNetListStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListStorageType.setDescription('This variable represents the storage type value for the vrIpOspfExportNetList tables.')
vrIpOspfExportNetListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpOspfExportNetListIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListIndex.setDescription('This variable represents the index for the vrIpOspfExportNetList tables.')
vrIpOspfExportNetListProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 10), )
if mibBuilder.loadTexts: vrIpOspfExportNetListProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListProvTable.setDescription('This group identifies the set of provisionable attributes for the ExportNetworkList component.')
vrIpOspfExportNetListProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExportNetListIndex"))
if mibBuilder.loadTexts: vrIpOspfExportNetListProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListProvEntry.setDescription('An entry in the vrIpOspfExportNetListProvTable.')
vrIpOspfExportNetListIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportNetListIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListIpAddress.setDescription('This attribute identifies the 32 bit IP address to match against.')
vrIpOspfExportNetListIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 8, 2, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpOspfExportNetListIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExportNetListIpMask.setDescription('This attribute is the IP Mask to be used with the IP Address to match against.')
vrIpOspfVirtNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9))
vrIpOspfVirtNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 1), )
if mibBuilder.loadTexts: vrIpOspfVirtNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpOspfVirtNbr components.')
vrIpOspfVirtNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtNbrAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtNbrNbrRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfVirtNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfVirtNbr component.')
vrIpOspfVirtNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfVirtNbr components. These components cannot be added nor deleted.')
vrIpOspfVirtNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfVirtNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrStorageType.setDescription('This variable represents the storage type value for the vrIpOspfVirtNbr tables.')
vrIpOspfVirtNbrAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpOspfVirtNbrAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrAreaIdIndex.setDescription('This variable represents an index for the vrIpOspfVirtNbr tables.')
vrIpOspfVirtNbrNbrRouterIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpOspfVirtNbrNbrRouterIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrNbrRouterIdIndex.setDescription('This variable represents an index for the vrIpOspfVirtNbr tables.')
vrIpOspfVirtNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 10), )
if mibBuilder.loadTexts: vrIpOspfVirtNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group identifies a set of operational attributes.')
vrIpOspfVirtNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtNbrAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfVirtNbrNbrRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfVirtNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrOperEntry.setDescription('An entry in the vrIpOspfVirtNbrOperTable.')
vrIpOspfVirtNbrNbrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrNbrIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrNbrIpAddress.setDescription('Indicates the Ip address this interface this virtual neighbor is using.')
vrIpOspfVirtNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrOptions.setDescription("A bit mask corresponding to the neighbor's options field. Bit 1, if set indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric. Bit 2, if set, indicates that the system is Network Multicast capable; i.e., that it implements OSPF Multicast Routing.")
vrIpOspfVirtNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchange", 5), ("exchangeStatrt", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrState.setDescription('The state of the virtual neighbor relationship.')
vrIpOspfVirtNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrEvents.setDescription('The number of times this virtual link has changed its state, or an error has occurred.')
vrIpOspfVirtNbrLsRetransQlen = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 10, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrLsRetransQlen.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrLsRetransQlen.setDescription('The current length of the Retransmission queue.')
vrIpOspfVirtNbrExchangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 9, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfVirtNbrExchangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfVirtNbrExchangeStatus.setDescription('Indicates the exchange status of the entry in this table.')
vrIpOspfNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10))
vrIpOspfNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 1), )
if mibBuilder.loadTexts: vrIpOspfNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpOspfNbr components.')
vrIpOspfNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfNbrAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfNbrAddressLessIndex"))
if mibBuilder.loadTexts: vrIpOspfNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfNbr component.')
vrIpOspfNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfNbr components. These components cannot be added nor deleted.')
vrIpOspfNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrStorageType.setDescription('This variable represents the storage type value for the vrIpOspfNbr tables.')
vrIpOspfNbrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpOspfNbrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrAddressIndex.setDescription('This variable represents an index for the vrIpOspfNbr tables.')
vrIpOspfNbrAddressLessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: vrIpOspfNbrAddressLessIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrAddressLessIndex.setDescription('This variable represents an index for the vrIpOspfNbr tables.')
vrIpOspfNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10), )
if mibBuilder.loadTexts: vrIpOspfNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group identifies the operational set of attributes for the NeighborEntry.')
vrIpOspfNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfNbrAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfNbrAddressLessIndex"))
if mibBuilder.loadTexts: vrIpOspfNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrOperEntry.setDescription('An entry in the vrIpOspfNbrOperTable.')
vrIpOspfNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrRtrId.setDescription('An Ip Address that uniquely identifies the neighboring router in the autonomous system.')
vrIpOspfNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrOptions.setDescription("A bit mask corresponding to the neighbor's options field. Bit 0, if set, indicates that the area accepts and operates on external information, if zero, it is a stub area. Bit 1, if set, indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric. Bit 2, if set, indicates that the system is Network Multicast capable; i.e., that it implements OSPF Multicast Routing.")
vrIpOspfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrPriority.setDescription('The priority of this neighbor in the designated router election algorithm. The value 0 signifies that the neighbor is not eligible to become the designated router on this particular network.')
vrIpOspfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrState.setDescription('The state of the relationship with this neighbor.')
vrIpOspfNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrEvents.setDescription('The number of times this neighbor relationship has changed state, or an error has occurred.')
vrIpOspfNbrLsRetransQlen = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrLsRetransQlen.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrLsRetransQlen.setDescription('The current length of the Retransmission queue.')
vrIpOspfNbrNbmaNbrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrNbmaNbrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrNbmaNbrStatus.setDescription('This attribute describes the status of the entry.')
vrIpOspfNbrExchangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrExchangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrExchangeStatus.setDescription('Indicates the exchange status for a neighbor entry.')
vrIpOspfNbrPermanence = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 10, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("permanent", 2))).clone('dynamic')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfNbrPermanence.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfNbrPermanence.setDescription('This attribute displays how the neighbor became an entry.')
vrIpOspfLsdb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11))
vrIpOspfLsdbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1), )
if mibBuilder.loadTexts: vrIpOspfLsdbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpOspfLsdb components.')
vrIpOspfLsdbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfLsdbAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfLsdbLsdbTypeIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfLsdbLsIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfLsdbRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfLsdbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfLsdb component.')
vrIpOspfLsdbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfLsdbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfLsdb components. These components cannot be added nor deleted.')
vrIpOspfLsdbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfLsdbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfLsdbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfLsdbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbStorageType.setDescription('This variable represents the storage type value for the vrIpOspfLsdb tables.')
vrIpOspfLsdbAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpOspfLsdbAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbAreaIdIndex.setDescription('This variable represents an index for the vrIpOspfLsdb tables.')
vrIpOspfLsdbLsdbTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)))
if mibBuilder.loadTexts: vrIpOspfLsdbLsdbTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbLsdbTypeIndex.setDescription('This variable represents an index for the vrIpOspfLsdb tables.')
vrIpOspfLsdbLsIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: vrIpOspfLsdbLsIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbLsIdIndex.setDescription('This variable represents an index for the vrIpOspfLsdb tables.')
vrIpOspfLsdbRouterIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: vrIpOspfLsdbRouterIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbRouterIdIndex.setDescription('This variable represents an index for the vrIpOspfLsdb tables.')
vrIpOspfLsdbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 10), )
if mibBuilder.loadTexts: vrIpOspfLsdbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group describes the Operational set of attributes for the LsdbEntry.')
vrIpOspfLsdbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfLsdbAreaIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfLsdbLsdbTypeIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfLsdbLsIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfLsdbRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfLsdbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbOperEntry.setDescription('An entry in the vrIpOspfLsdbOperTable.')
vrIpOspfLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfLsdbSequence.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbSequence.setDescription('A signed 32-bit integer, used to detect old and duplicate LSAs. The space of sequence numbers is linearly ordered. The larger the sequence number, the more recent the advertisement.')
vrIpOspfLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfLsdbAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbAge.setDescription('The age of the Link State Advertisement in seconds.')
vrIpOspfLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfLsdbChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbChecksum.setDescription('The checksum of the complete contents of the advertisement, excepting the age field. The checksum used is the Fletcher checksum.')
vrIpOspfLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 11, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfLsdbAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfLsdbAdvertisement.setDescription('The entire LSA including its header.')
vrIpOspfExtLsdb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12))
vrIpOspfExtLsdbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 1), )
if mibBuilder.loadTexts: vrIpOspfExtLsdbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpOspfExtLsdb components.')
vrIpOspfExtLsdbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExtLsdbLsdbTypeIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExtLsdbLsIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExtLsdbRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfExtLsdbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbRowStatusEntry.setDescription('A single entry in the table represents a single vrIpOspfExtLsdb component.')
vrIpOspfExtLsdbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExtLsdbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpOspfExtLsdb components. These components cannot be added nor deleted.')
vrIpOspfExtLsdbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExtLsdbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpOspfExtLsdbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExtLsdbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbStorageType.setDescription('This variable represents the storage type value for the vrIpOspfExtLsdb tables.')
vrIpOspfExtLsdbLsdbTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)))
if mibBuilder.loadTexts: vrIpOspfExtLsdbLsdbTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbLsdbTypeIndex.setDescription('This variable represents an index for the vrIpOspfExtLsdb tables.')
vrIpOspfExtLsdbLsIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpOspfExtLsdbLsIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbLsIdIndex.setDescription('This variable represents an index for the vrIpOspfExtLsdb tables.')
vrIpOspfExtLsdbRouterIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: vrIpOspfExtLsdbRouterIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbRouterIdIndex.setDescription('This variable represents an index for the vrIpOspfExtLsdb tables.')
vrIpOspfExtLsdbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 10), )
if mibBuilder.loadTexts: vrIpOspfExtLsdbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group describes the operational set of attributes for the ExtLsdbEntry.')
vrIpOspfExtLsdbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExtLsdbLsdbTypeIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExtLsdbLsIdIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpOspfExtLsdbRouterIdIndex"))
if mibBuilder.loadTexts: vrIpOspfExtLsdbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbOperEntry.setDescription('An entry in the vrIpOspfExtLsdbOperTable.')
vrIpOspfExtLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExtLsdbSequence.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbSequence.setDescription('A signed 32-bit integer, used to detect old and duplicate LSAs. The space of sequence numbers is linearly ordered. The larger the sequence number, the more recent the advertisement.')
vrIpOspfExtLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExtLsdbAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbAge.setDescription('The age of the Link State Advertisement in seconds.')
vrIpOspfExtLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExtLsdbChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbChecksum.setDescription('The checksum of the complete contents of the advertisement, excepting the age field. The checksum used is the Fletcher checksum.')
vrIpOspfExtLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 7, 12, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 36))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpOspfExtLsdbAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpOspfExtLsdbAdvertisement.setDescription('The entire LSA including its header.')
vrIpRip = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8))
vrIpRipRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 1), )
if mibBuilder.loadTexts: vrIpRipRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpRip components.')
vrIpRipRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"))
if mibBuilder.loadTexts: vrIpRipRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipRowStatusEntry.setDescription('A single entry in the table represents a single vrIpRip component.')
vrIpRipRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpRip components. These components can be added and deleted.')
vrIpRipComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpRipStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipStorageType.setDescription('This variable represents the storage type value for the vrIpRip tables.')
vrIpRipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpRipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipIndex.setDescription('This variable represents the index for the vrIpRip tables.')
vrIpRipProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 10), )
if mibBuilder.loadTexts: vrIpRipProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipProvTable.setDescription('This group contains the provisionable attributes for the RIP component')
vrIpRipProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"))
if mibBuilder.loadTexts: vrIpRipProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipProvEntry.setDescription('An entry in the vrIpRipProvTable.')
vrIpRipMigrateRip = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipMigrateRip.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipMigrateRip.setDescription('This attribute sets the preference level of OSPF-internal routes to be less preferred than RIP. Note: This parameter should only be used when starting migration of network from RIP to OSPF. When ready to cutover to OSPF, set this attribute value to disabled and run under normal preferences. All OSPF routers in the Autonomous System should be running with migrateRip enabled or with migrateRip disabled to prevent routing loops. It is important that the changeover period from RIP to OSPF be performed quickly on all OSPF routers so that no routing loops are formed. These routing loops could be caused by conflicts in the internal RIP and OSPF databases.')
vrIpRipRfc1058MetricUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipRfc1058MetricUsage.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipRfc1058MetricUsage.setDescription("This attribute determines the metric usage for this RIP instance. This flag is used to determine the way metrics are incremented. RFC1058 way : Sending Update: This is to use the metric for the route from the routing table as the advertised metric to be sent for that route. Nothing is ever added to this value from the sending side. The only special case handling is that if the route being advertised is the network route of a directly connectednetwork, the metric in the routing table will be zero. Then the RipIf interface metric for the interface being advertised is used as the advertise metric. If the interface being advertised is not a Rip interface, then metric value of 1 is used. Receiving Update: Add receiving interface's RIP metric to the metric for the route in the received advertisement and install the result in the receiver's routing table as the metric for that route. Older way: Sending Updates: Add the out going interfaces rip metric to the metric for a route in the routing table to form the metric to be advertised for that route. Receiving Updates: The metric received in the advertisement for a route is put directly in the routing table as the metric for that route. Note: It is recommended that, all the routers in this autonomous system should be following the rfc1058 metric system. Setting this flag to disabled will have the effect of running the RIP with old metric incrementing system.")
vrIpRipGenerateDiscardRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipGenerateDiscardRoute.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipGenerateDiscardRoute.setDescription('This attribute when set to yes will add network disacrd routes to the routing and forwarding table for the subnetted interfaces that are running RIP.')
vrIpRipRipUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 500)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipRipUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipRipUpdate.setDescription('This attribute sets the interval for sending updates bewteen RIP neighbours. Set this attribute with a value less than that of the timeout and garbage collect timers. The ripUpdate timer starts when a route comes up and when updates are received.')
vrIpRipRipTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 500)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipRipTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipRipTimeout.setDescription('This attribute sets the RIP timeout interval. If this timer expires, the route is no longer valid. The ripTimeout timer starts when a route comes up and when updates are received.')
vrIpRipGarbageCollectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 10, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 500)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipGarbageCollectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipGarbageCollectTimer.setDescription("This attribute sets the interval between a route's timeout expiring and the deletion of that route's information from the routing table. The garbage collect timer starts when the ripTimeout period expires.")
vrIpRipStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 11), )
if mibBuilder.loadTexts: vrIpRipStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpRipStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"))
if mibBuilder.loadTexts: vrIpRipStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipStateEntry.setDescription('An entry in the vrIpRipStateTable.')
vrIpRipAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpRipOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpRipUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpRipAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 12), )
if mibBuilder.loadTexts: vrIpRipAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrIpRipAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"))
if mibBuilder.loadTexts: vrIpRipAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipAdminControlEntry.setDescription('An entry in the vrIpRipAdminControlTable.')
vrIpRipSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrIpRipOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 15), )
if mibBuilder.loadTexts: vrIpRipOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrIpRipOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"))
if mibBuilder.loadTexts: vrIpRipOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipOperStatusEntry.setDescription('An entry in the vrIpRipOperStatusTable.')
vrIpRipSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrIpRipOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 16), )
if mibBuilder.loadTexts: vrIpRipOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipOperTable.setDescription('This group defines a set of operational attributes belonging to the RIP component. It corresponds to the rip2Globals table in the RIP-2 standard MIB.')
vrIpRipOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"))
if mibBuilder.loadTexts: vrIpRipOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipOperEntry.setDescription('An entry in the vrIpRipOperTable.')
vrIpRipRouteChangesMade = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipRouteChangesMade.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipRouteChangesMade.setDescription("This attribute counts the route changes made to the IP Route Database by Rip. This does not include the refresh of the route's age.")
vrIpRipQueryResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipQueryResponses.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipQueryResponses.setDescription('This attribute counts the responses sent to RIP queries from other systems.')
vrIpRipImport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2))
vrIpRipImportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 1), )
if mibBuilder.loadTexts: vrIpRipImportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpRipImport components.')
vrIpRipImportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipImportIndex"))
if mibBuilder.loadTexts: vrIpRipImportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportRowStatusEntry.setDescription('A single entry in the table represents a single vrIpRipImport component.')
vrIpRipImportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipImportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpRipImport components. These components can be added and deleted.')
vrIpRipImportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipImportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpRipImportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipImportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportStorageType.setDescription('This variable represents the storage type value for the vrIpRipImport tables.')
vrIpRipImportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpRipImportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportIndex.setDescription('This variable represents the index for the vrIpRipImport tables.')
vrIpRipImportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 10), )
if mibBuilder.loadTexts: vrIpRipImportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportProvTable.setDescription('This is the group of provisionable attributes for the XXXX Import Subcomponent.')
vrIpRipImportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipImportIndex"))
if mibBuilder.loadTexts: vrIpRipImportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportProvEntry.setDescription('An entry in the vrIpRipImportProvTable.')
vrIpRipImportUsageFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("use", 1), ("ignore", 2))).clone('use')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipImportUsageFlag.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportUsageFlag.setDescription('This flag when set to ignore indicates the routes that are not used and if set to use, indicates the routes which are used.')
vrIpRipImportImportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipImportImportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportImportMetric.setDescription('This attribute is used to override the default import metric for the RIP protocol. This value is not used to select which routes to use or ignore, rather it is the metric to be used in the routing table for the routes imported for this import policy. A value of zero indicates that the metric received in the update will be used.')
vrIpRipImportNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 10, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipImportNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNeighbor.setDescription('This attribute indicates the IP Address of the neighbor this policy will apply to.')
vrIpRipImportInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipImportInterface.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportInterface.setDescription('This attribute specifies the RIP interface to which this import policy applies. The value of 0.0.0.0 implies any RIP interface on the virtual router; otherwise the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router.')
vrIpRipImportNet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2))
vrIpRipImportNetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 1), )
if mibBuilder.loadTexts: vrIpRipImportNetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpRipImportNet components.')
vrIpRipImportNetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipImportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipImportNetIndex"))
if mibBuilder.loadTexts: vrIpRipImportNetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetRowStatusEntry.setDescription('A single entry in the table represents a single vrIpRipImportNet component.')
vrIpRipImportNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipImportNetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpRipImportNet components. These components can be added and deleted.')
vrIpRipImportNetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipImportNetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpRipImportNetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipImportNetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetStorageType.setDescription('This variable represents the storage type value for the vrIpRipImportNet tables.')
vrIpRipImportNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpRipImportNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetIndex.setDescription('This variable represents the index for the vrIpRipImportNet tables.')
vrIpRipImportNetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 10), )
if mibBuilder.loadTexts: vrIpRipImportNetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetProvTable.setDescription('This group contains attributes for the XXXX NetworkList component for the Import Policy to be applied to')
vrIpRipImportNetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipImportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipImportNetIndex"))
if mibBuilder.loadTexts: vrIpRipImportNetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetProvEntry.setDescription('An entry in the vrIpRipImportNetProvTable.')
vrIpRipImportNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipImportNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetIpAddress.setDescription('This attribute specifies the IP address that needs to be matched against in this network list for the Import Policy to be applied to.')
vrIpRipImportNetIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 2, 2, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipImportNetIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipImportNetIpMask.setDescription('This attribute specifies the IP mask for the attribute ipAddress.')
vrIpRipExport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3))
vrIpRipExportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 1), )
if mibBuilder.loadTexts: vrIpRipExportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpRipExport components.')
vrIpRipExportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipExportIndex"))
if mibBuilder.loadTexts: vrIpRipExportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportRowStatusEntry.setDescription('A single entry in the table represents a single vrIpRipExport component.')
vrIpRipExportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpRipExport components. These components can be added and deleted.')
vrIpRipExportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipExportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpRipExportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipExportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportStorageType.setDescription('This variable represents the storage type value for the vrIpRipExport tables.')
vrIpRipExportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpRipExportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportIndex.setDescription('This variable represents the index for the vrIpRipExport tables.')
vrIpRipExportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10), )
if mibBuilder.loadTexts: vrIpRipExportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportProvTable.setDescription('This group contains all the provisioned attributes for the Export component.')
vrIpRipExportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipExportIndex"))
if mibBuilder.loadTexts: vrIpRipExportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportProvEntry.setDescription('An entry in the vrIpRipExportProvTable.')
vrIpRipExportAdvertiseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("block", 2))).clone('send')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportAdvertiseStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportAdvertiseStatus.setDescription('This attribute specifies if the routes that match this export policy are advertised (send) or not advertised (block).')
vrIpRipExportExportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportExportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportExportMetric.setDescription('This attribute specifies the metric to be used on the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of exportMetric is ignored. The exportMetric value is not used to select which routes to block or send, but rather the metric value advertised for the routes. A value of 0 indicates that the metric associated with the route in the forwarding table is used.')
vrIpRipExportProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("all", 1), ("egp", 2), ("rip", 3), ("ospfInternal", 4), ("ospfExternal", 5), ("staticLocal", 6), ("staticRemote", 7), ("bgpInternal", 8), ("bgpExternal", 9))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportProtocol.setDescription('This attribute specifies the routes to which this export policy applies based on the routing protocol of how the routes are learned. If it is set to all, this export policy applies to all routes in the forwarding table.')
vrIpRipExportRipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportRipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportRipInterface.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP interface from which the routes are learned. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP interface on the same virtual router; otherwise the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router. DESCRIPTION')
vrIpRipExportEgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportEgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportEgpAsId.setDescription('This attribute specifies the EGP learned routes to which this export policy applies, based on the EGP autonomous system identifier of which the routes are learned from. This attribute can only be non zero when protocol is set to egp. The value of 0 implies any EGP autonomous system; otherwise the value of this attribute must match the asId of an EGP neighbor on the same virtual router.')
vrIpRipExportOspfTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(4294967295)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportOspfTag.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportOspfTag.setDescription('This attribute specifies the OSPF learned external routes to which this export policy applies, based on the learned OSPF tag of the routes. This attribute can only be set to a non default value when protocol is set to ospfExternal. The default value of 4294967295 implies any tag.')
vrIpRipExportOutInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportOutInterface.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportOutInterface.setDescription('This attribute specifies the RIP interface on the virtual router which routes are exported onto as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of outInterface is ignored. The outInterface value is not used to select which routes to block or send, but rather where to export the routes. A value of 0.0.0.0 indicates that the routes are exported to all RIP interfaces on the virtual router. Otherwise, the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router.')
vrIpRipExportBgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportBgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportBgpAsId.setDescription('This key attribute specifies the BGP AS from which the routes are learned. This key will be used only when the protocol is set to bgpExternal. bgpAsId of 0 matches all BGP ASs.')
vrIpRipExportNet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2))
vrIpRipExportNetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 1), )
if mibBuilder.loadTexts: vrIpRipExportNetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpRipExportNet components.')
vrIpRipExportNetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipExportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipExportNetIndex"))
if mibBuilder.loadTexts: vrIpRipExportNetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetRowStatusEntry.setDescription('A single entry in the table represents a single vrIpRipExportNet component.')
vrIpRipExportNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportNetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpRipExportNet components. These components can be added and deleted.')
vrIpRipExportNetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipExportNetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpRipExportNetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRipExportNetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetStorageType.setDescription('This variable represents the storage type value for the vrIpRipExportNet tables.')
vrIpRipExportNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpRipExportNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetIndex.setDescription('This variable represents the index for the vrIpRipExportNet tables.')
vrIpRipExportNetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 10), )
if mibBuilder.loadTexts: vrIpRipExportNetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetProvTable.setDescription('This group identifies the set of Provisionable attributes for the ExportNetworkList component.')
vrIpRipExportNetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipExportIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRipExportNetIndex"))
if mibBuilder.loadTexts: vrIpRipExportNetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetProvEntry.setDescription('An entry in the vrIpRipExportNetProvTable.')
vrIpRipExportNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetIpAddress.setDescription('This attribute identifies the 32 bit IP address to match against.')
vrIpRipExportNetIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 8, 3, 2, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRipExportNetIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRipExportNetIpMask.setDescription('This attribute is the IP Mask to be used with the IP Address to match against.')
vrIpStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9))
vrIpStaticRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 1), )
if mibBuilder.loadTexts: vrIpStaticRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpStatic components.')
vrIpStaticRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticIndex"))
if mibBuilder.loadTexts: vrIpStaticRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRowStatusEntry.setDescription('A single entry in the table represents a single vrIpStatic component.')
vrIpStaticRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpStaticRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpStatic components. These components can be added and deleted.')
vrIpStaticComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpStaticStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticStorageType.setDescription('This variable represents the storage type value for the vrIpStatic tables.')
vrIpStaticIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpStaticIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticIndex.setDescription('This variable represents the index for the vrIpStatic tables.')
vrIpStaticStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 10), )
if mibBuilder.loadTexts: vrIpStaticStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpStaticStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticIndex"))
if mibBuilder.loadTexts: vrIpStaticStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticStateEntry.setDescription('An entry in the vrIpStaticStateTable.')
vrIpStaticAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpStaticOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpStaticUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpStaticRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2))
vrIpStaticRouteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 1), )
if mibBuilder.loadTexts: vrIpStaticRouteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpStaticRoute components.')
vrIpStaticRouteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteDestMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteTypeOfServiceIndex"))
if mibBuilder.loadTexts: vrIpStaticRouteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteRowStatusEntry.setDescription('A single entry in the table represents a single vrIpStaticRoute component.')
vrIpStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpStaticRouteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpStaticRoute components. These components can be added and deleted.')
vrIpStaticRouteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticRouteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpStaticRouteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticRouteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteStorageType.setDescription('This variable represents the storage type value for the vrIpStaticRoute tables.')
vrIpStaticRouteDestAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpStaticRouteDestAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteDestAddressIndex.setDescription('This variable represents an index for the vrIpStaticRoute tables.')
vrIpStaticRouteDestMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpStaticRouteDestMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteDestMaskIndex.setDescription('This variable represents an index for the vrIpStaticRoute tables.')
vrIpStaticRouteTypeOfServiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: vrIpStaticRouteTypeOfServiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteTypeOfServiceIndex.setDescription('This variable represents an index for the vrIpStaticRoute tables.')
vrIpStaticRouteProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 10), )
if mibBuilder.loadTexts: vrIpStaticRouteProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteProvTable.setDescription('This group contains a provisionable set of attributes for the static route entry component.')
vrIpStaticRouteProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteDestMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteTypeOfServiceIndex"))
if mibBuilder.loadTexts: vrIpStaticRouteProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteProvEntry.setDescription('An entry in the vrIpStaticRouteProvTable.')
vrIpStaticRoutePreferredOver = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 72))).clone(namedValues=NamedValues(("intOspf", 5), ("extOspf", 72))).clone('extOspf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpStaticRoutePreferredOver.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRoutePreferredOver.setDescription('This attribute indicates the preference of the static route in comparison with the OSPF route. intOspf means that the static route is chosen over the OSPF internal route, while extOspf means that the OSPF internal route is chosen over the static route. The default static route preference is set to extOspf .')
vrIpStaticRouteNh = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2))
vrIpStaticRouteNhRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 1), )
if mibBuilder.loadTexts: vrIpStaticRouteNhRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpStaticRouteNh components.')
vrIpStaticRouteNhRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteDestMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteTypeOfServiceIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteNhIndex"))
if mibBuilder.loadTexts: vrIpStaticRouteNhRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhRowStatusEntry.setDescription('A single entry in the table represents a single vrIpStaticRouteNh component.')
vrIpStaticRouteNhRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpStaticRouteNhRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpStaticRouteNh components. These components can be added and deleted.')
vrIpStaticRouteNhComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticRouteNhComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpStaticRouteNhStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticRouteNhStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhStorageType.setDescription('This variable represents the storage type value for the vrIpStaticRouteNh tables.')
vrIpStaticRouteNhIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpStaticRouteNhIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhIndex.setDescription('This variable represents the index for the vrIpStaticRouteNh tables.')
vrIpStaticRouteNhProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 10), )
if mibBuilder.loadTexts: vrIpStaticRouteNhProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhProvTable.setDescription('This group contains a provisionable set of attributes for the Static RouteEntry NextHop component.')
vrIpStaticRouteNhProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteDestMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteTypeOfServiceIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticRouteNhIndex"))
if mibBuilder.loadTexts: vrIpStaticRouteNhProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhProvEntry.setDescription('An entry in the vrIpStaticRouteNhProvTable.')
vrIpStaticRouteNhMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpStaticRouteNhMetric.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticRouteNhMetric.setDescription('This attribute specifies the primary routing metric for this NextHop.')
vrIpStaticDiscard = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 3))
vrIpStaticDiscardRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 3, 1), )
if mibBuilder.loadTexts: vrIpStaticDiscardRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticDiscardRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpStaticDiscard components.')
vrIpStaticDiscardRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticDiscardDestAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpStaticDiscardDestMaskIndex"))
if mibBuilder.loadTexts: vrIpStaticDiscardRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticDiscardRowStatusEntry.setDescription('A single entry in the table represents a single vrIpStaticDiscard component.')
vrIpStaticDiscardRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpStaticDiscardRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticDiscardRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpStaticDiscard components. These components can be added and deleted.')
vrIpStaticDiscardComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticDiscardComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticDiscardComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpStaticDiscardStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpStaticDiscardStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticDiscardStorageType.setDescription('This variable represents the storage type value for the vrIpStaticDiscard tables.')
vrIpStaticDiscardDestAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpStaticDiscardDestAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticDiscardDestAddressIndex.setDescription('This variable represents an index for the vrIpStaticDiscard tables.')
vrIpStaticDiscardDestMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 9, 3, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpStaticDiscardDestMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpStaticDiscardDestMaskIndex.setDescription('This variable represents an index for the vrIpStaticDiscard tables.')
vrIpNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10))
vrIpNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 1), )
if mibBuilder.loadTexts: vrIpNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpNs components.')
vrIpNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpNsIndex"))
if mibBuilder.loadTexts: vrIpNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsRowStatusEntry.setDescription('A single entry in the table represents a single vrIpNs component.')
vrIpNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpNs components. These components can be added and deleted.')
vrIpNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsStorageType.setDescription('This variable represents the storage type value for the vrIpNs tables.')
vrIpNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsIndex.setDescription('This variable represents the index for the vrIpNs tables.')
vrIpNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 10), )
if mibBuilder.loadTexts: vrIpNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsProvTable.setDescription('This group contains provisionable attributes for the NetSentry component.')
vrIpNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpNsIndex"))
if mibBuilder.loadTexts: vrIpNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsProvEntry.setDescription('An entry in the vrIpNsProvTable.')
vrIpNsFirstFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsFirstFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsFirstFilter.setDescription('The firstFilter is the first filter point which affects all IP packets before they have been examined in any way for their origin and destination. The most common use of a firstFilter point is to collect statistis for all packets arriving at the route on any interface, before any subsequent filter processing changes their direction or disposition.')
vrIpNsLocalInFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsLocalInFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsLocalInFilter.setDescription("The localInFilter is the second filter point which uses by network administrator to perform a common action on all IP packets that physically arrive over a specific logical interface, regardless of the packet's stated source or destination. Typical uses for a localInFilter include verifying that known Ethernet media source addresses match known IP addresses, or confirming that the IP packet source addresses of received IP packet fall within a narrow range.")
vrIpNsLocalOutFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsLocalOutFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsLocalOutFilter.setDescription('The localOutFilter is the third filter point which applies to any IP packet that will be transmitted from the router to the medium associated with the interface, regardless of its source, destination, or what type of decision was made to cause the datagram to be transmitted on this interface. localOutFilter generally used to ensure that certain paterns of traffic do not enter the network or reach a second IP router on that network. For example, localOutFilter can be used as the exclusion of all IP packets above a certain security classification, or collecting statistics on the amount of IP fragments performed on an outgoing interface.')
vrIpNsLastFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 10, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsLastFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsLastFilter.setDescription('lastFilter is the fourth and last filter point to be excecuted after all other routing and filtering decisions have been made on the IP packet, and transmission of the information is imminent. lastFilter is generally used to collect statistics on traffic after all previous control and routing decisions have been made.')
vrIpNsApply = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2))
vrIpNsApplyRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 1), )
if mibBuilder.loadTexts: vrIpNsApplyRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpNsApply components.')
vrIpNsApplyRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpNsIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpNsApplyIndex"))
if mibBuilder.loadTexts: vrIpNsApplyRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyRowStatusEntry.setDescription('A single entry in the table represents a single vrIpNsApply component.')
vrIpNsApplyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsApplyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpNsApply components. These components can be added and deleted.')
vrIpNsApplyComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpNsApplyComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpNsApplyStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpNsApplyStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyStorageType.setDescription('This variable represents the storage type value for the vrIpNsApply tables.')
vrIpNsApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: vrIpNsApplyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyIndex.setDescription('This variable represents the index for the vrIpNsApply tables.')
vrIpNsApplyProvisionedTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 10), )
if mibBuilder.loadTexts: vrIpNsApplyProvisionedTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyProvisionedTable.setDescription('The instance of provisioned information relating to a filter application to IP packet.')
vrIpNsApplyProvisionedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpNsIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpNsApplyIndex"))
if mibBuilder.loadTexts: vrIpNsApplyProvisionedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyProvisionedEntry.setDescription('An entry in the vrIpNsApplyProvisionedTable.')
vrIpNsApplyFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsApplyFilter.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyFilter.setDescription('The name of the filter to be applied to packet matching the conditions in this entry.')
vrIpNsApplyIpAddress1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsApplyIpAddress1.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyIpAddress1.setDescription('The first IP address used to compare.')
vrIpNsApplyIpMask1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 10, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsApplyIpMask1.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyIpMask1.setDescription('The first netmask associated with ipAddress1 used to compare.')
vrIpNsApplyIpAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsApplyIpAddress2.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyIpAddress2.setDescription('This second IP address used to compare.')
vrIpNsApplyIpMask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 10, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsApplyIpMask2.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyIpMask2.setDescription('This second netmask associated with ipAddress2 used to compare.')
vrIpNsApplyDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 10, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("to", 1), ("from", 2), ("tofrom", 3))).clone('tofrom')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpNsApplyDirection.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpNsApplyDirection.setDescription("Indicates the direction a packet must be moving between the first and second apply list entries in order for the entries to match. First 'to' second, first 'from' second, or first 'tofrom' second (either direction).")
vrIpArp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11))
vrIpArpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 1), )
if mibBuilder.loadTexts: vrIpArpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpArp components.')
vrIpArpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpIndex"))
if mibBuilder.loadTexts: vrIpArpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpArp component.')
vrIpArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpArp components. These components cannot be added nor deleted.')
vrIpArpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpArpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpStorageType.setDescription('This variable represents the storage type value for the vrIpArp tables.')
vrIpArpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpArpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpIndex.setDescription('This variable represents the index for the vrIpArp tables.')
vrIpArpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 10), )
if mibBuilder.loadTexts: vrIpArpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpProvTable.setDescription('The ARP refresh feature allows the router to periodically verify ARP table entries. Whenever the router updates an ARP entry, or creates a new entry, a timeout value is assigned to the entry. When the timeout for an entry expires, the router will send a unicast ARP request to the currently-known physical address. If an ARP response comes back, the entry will be assigned a new timeout. If, however, the host has gone away or been assigned a new physical address, the host will not respond to the unicast ARP, and the entry will be removed from the ARP table. The new physical address will be discovered through the normal ARP mechanism when the next communication is attempted to the host.')
vrIpArpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpIndex"))
if mibBuilder.loadTexts: vrIpArpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpProvEntry.setDescription('An entry in the vrIpArpProvTable.')
vrIpArpAutoRefresh = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpArpAutoRefresh.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpAutoRefresh.setDescription('This attribute is used to enable or disable the ARP refresh feature.')
vrIpArpAutoRefreshTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1440)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpArpAutoRefreshTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpAutoRefreshTimeout.setDescription('This attribute defines the timeout value, in minutes, which is assigned to updated ARP entries, or newly created ARP entries. The range for the timeout is 1 minute to 1440 minutes (24 hours).')
vrIpArpHost = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2))
vrIpArpHostRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 1), )
if mibBuilder.loadTexts: vrIpArpHostRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpArpHost components.')
vrIpArpHostRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpHostHostAddressIndex"))
if mibBuilder.loadTexts: vrIpArpHostRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostRowStatusEntry.setDescription('A single entry in the table represents a single vrIpArpHost component.')
vrIpArpHostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpArpHostRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpArpHost components. These components can be added and deleted.')
vrIpArpHostComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpHostComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpArpHostStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpHostStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostStorageType.setDescription('This variable represents the storage type value for the vrIpArpHost tables.')
vrIpArpHostHostAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpArpHostHostAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostHostAddressIndex.setDescription('This variable represents the index for the vrIpArpHost tables.')
vrIpArpHostProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 10), )
if mibBuilder.loadTexts: vrIpArpHostProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostProvTable.setDescription('This group contains the provisionable attributes of the HostEntry component.')
vrIpArpHostProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpHostHostAddressIndex"))
if mibBuilder.loadTexts: vrIpArpHostProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostProvEntry.setDescription('An entry in the vrIpArpHostProvTable.')
vrIpArpHostPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 10, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 8)).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpArpHostPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostPhysAddress.setDescription('This attribute identifies the physical address of the host being defined. The value for this attribute should only be specified for media types supporting physical addresses (eg. ethernet, fddi, tokenRing etc.)')
vrIpArpHostMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpArpHostMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostMaxTxUnit.setDescription("Specify the maximum transmit unit (MTU) size that can be accepted by the host. If this value is not specified, the value for the media interface is used. The specified MTU must be less than or equal to the interface's MTU size.")
vrIpArpHostPermanentVirtualCircuitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpArpHostPermanentVirtualCircuitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostPermanentVirtualCircuitNumber.setDescription('Specify a permanent virtual circuit number to the remote host on X.25 or frame relay media. The value for this attribute can only be specified for X.25 or frame relay media.')
vrIpArpHostEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpArpHostEncap.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostEncap.setDescription('Specify the encapsulation type for the host. The value for this attribute should only be specified for the hosts on the ethernet media. If a value of auto is specified, the application based on the media will determine the proper applicable encapsulation type.')
vrIpArpHostOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 11), )
if mibBuilder.loadTexts: vrIpArpHostOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostOperTable.setDescription('This group contains the operational attributes of the HostEntry component.')
vrIpArpHostOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpHostHostAddressIndex"))
if mibBuilder.loadTexts: vrIpArpHostOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostOperEntry.setDescription('An entry in the vrIpArpHostOperTable.')
vrIpArpHostOperMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpHostOperMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostOperMaxTxUnit.setDescription('This attribute indicates the operational value of the maximum transmission unit.')
vrIpArpHostOperEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpHostOperEncap.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpHostOperEncap.setDescription('This attribute indicates the operational encapsulation type. if the value of the attribute encap is set to auto, then the application will determine the encapsulation type based on the media being used and assigns the appropriate value.')
vrIpArpDynHost = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3))
vrIpArpDynHostRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 1), )
if mibBuilder.loadTexts: vrIpArpDynHostRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpArpDynHost components.')
vrIpArpDynHostRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpDynHostHostAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpDynHostCosIndex"))
if mibBuilder.loadTexts: vrIpArpDynHostRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostRowStatusEntry.setDescription('A single entry in the table represents a single vrIpArpDynHost component.')
vrIpArpDynHostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpArpDynHost components. These components cannot be added nor deleted.')
vrIpArpDynHostComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpArpDynHostStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostStorageType.setDescription('This variable represents the storage type value for the vrIpArpDynHost tables.')
vrIpArpDynHostHostAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpArpDynHostHostAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostHostAddressIndex.setDescription('This variable represents an index for the vrIpArpDynHost tables.')
vrIpArpDynHostCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("notApplicable", 4))))
if mibBuilder.loadTexts: vrIpArpDynHostCosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostCosIndex.setDescription('This variable represents an index for the vrIpArpDynHost tables.')
vrIpArpDynHostOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10), )
if mibBuilder.loadTexts: vrIpArpDynHostOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of the DynHostEntry component.')
vrIpArpDynHostOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpDynHostHostAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpArpDynHostCosIndex"))
if mibBuilder.loadTexts: vrIpArpDynHostOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostOperEntry.setDescription('An entry in the vrIpArpDynHostOperTable.')
vrIpArpDynHostPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostPhysAddress.setDescription('This attribute indicates the physical address of the host in canonical form.')
vrIpArpDynHostMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostMaxTxUnit.setDescription('This attribute indicates the maximum MTU size that can be accepted by the host.')
vrIpArpDynHostEncapsulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostEncapsulationType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostEncapsulationType.setDescription('This attribute indicates the encapsulation type of the host.')
vrIpArpDynHostPermanentVirtualCircuitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostPermanentVirtualCircuitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostPermanentVirtualCircuitNumber.setDescription('This attribute indicates the permanent virtual circuit number to the remote host.')
vrIpArpDynHostIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10, 1, 6), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostIfIndex.setDescription('This attribute indicates the ifIndex of the protocol port that is associated with this entry.')
vrIpArpDynHostType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pending", 1), ("invalid", 2), ("dynamic", 3), ("static", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostType.setDescription('This attribute indicates how this entry was learned.')
vrIpArpDynHostNcPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 11, 3, 10, 1, 8), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpArpDynHostNcPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpArpDynHostNcPhysAddress.setDescription('This attribute indicates the physical address of the host in non-canonical form. This attribute is not displayed for hosts on non-LAN media.')
vrIpIcmp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12))
vrIpIcmpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 1), )
if mibBuilder.loadTexts: vrIpIcmpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpIcmp components.')
vrIpIcmpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIcmpIndex"))
if mibBuilder.loadTexts: vrIpIcmpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpIcmp component.')
vrIpIcmpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpIcmp components. These components cannot be added nor deleted.')
vrIpIcmpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpIcmpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpStorageType.setDescription('This variable represents the storage type value for the vrIpIcmp tables.')
vrIpIcmpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpIcmpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpIndex.setDescription('This variable represents the index for the vrIpIcmp tables.')
vrIpIcmpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 10), )
if mibBuilder.loadTexts: vrIpIcmpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpProvTable.setDescription('This group holds provisioned attributes for ICMP.')
vrIpIcmpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIcmpIndex"))
if mibBuilder.loadTexts: vrIpIcmpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpProvEntry.setDescription('An entry in the vrIpIcmpProvTable.')
vrIpIcmpSendRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpIcmpSendRedirect.setStatus('obsolete')
if mibBuilder.loadTexts: vrIpIcmpSendRedirect.setDescription('This attribute specifies whether an ICMP redirect will be sent. If enabled, the router may send an ICMP redirect if a an Ip packet is being routed out the same logicalInterface as it was received on. The router will only send host ICMP redirects. If disabled, the router will never send a ICMP redirect.')
vrIpIcmpSendHostUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpIcmpSendHostUnreachable.setStatus('obsolete')
if mibBuilder.loadTexts: vrIpIcmpSendHostUnreachable.setDescription('This attribute specifies whether host unreachable will be sent or not.')
vrIpIcmpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11), )
if mibBuilder.loadTexts: vrIpIcmpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpStatsTable.setDescription('This group holds statistics for ICMP.')
vrIpIcmpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIcmpIndex"))
if mibBuilder.loadTexts: vrIpIcmpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpStatsEntry.setDescription('An entry in the vrIpIcmpStatsTable.')
vrIpIcmpInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInMsgs.setDescription('This attribute indicates the number of ICMP messages received by this gateway. This number includes inErrors. inMsgs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInErrors.setDescription('This attribute indicates the number of ICMP messages received by this gateway but determined as having ICMP specific errors such as bad ICMP checksums or bad length. inErrors wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInDestUnreachs.setDescription('This attribute indicates the number of ICMP destination unreachable messages received by this gateway. inDestUnreachs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInTimeExcds.setDescription('This attribute indicates the number of ICMP time exceeded messages received by this gateway. inTimeExcds wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInParmProbs.setDescription('This attribute indicates the number of ICMP parameter problem messages received by this gateway. inParmProbs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInSrcQuenchs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInSrcQuenchs.setDescription('This attribute indicates the number of ICMP source quench messages received by this gateway. inSrcQuenchs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInRedirects.setDescription('This attribute indicates the number of ICMP redirect messages received by this gateway. inRedirects wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInEchos.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInEchos.setDescription('This attribute indicates the number of ICMP echo request messages received by this gateway. inEchos wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInEchoReps.setDescription('This attribute indicates the number of ICMP echo reply messages received by this gateway. inEchoReps wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInTimestamps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInTimestamps.setDescription('This attribute indicates the number of ICMP timestamp request messages received by this gateway. inTimeStamps wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInTimestampReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInTimestampReps.setDescription('This attribute indicates the number of ICMP timestamp reply messages received by this gateway. inTimeStampReps wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInAddrMasks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInAddrMasks.setDescription('This attribute indicates the number of ICMP address mask request messages received by this gateway. inAddrMasks wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInAddrMaskReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInAddrMaskReps.setDescription('This attribute indicates the number of ICMP address mask reply messages received by this gateway. inAddrMaskReps wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutMsgs.setDescription('This attribute indicates the number of ICMP messages which this gateway attempted to send. This number includes outErrors. outMsgs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutErrors.setDescription('This attribute indicates the number of ICMP messages which this gateway did not send due to problems discovered within ICMP such as a lack of buffers. outErrors does not included errors discovered outside the ICMP layer such as the inability of IP to route the resultant datagram. outErrors wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutDestUnreachs.setDescription('This attribute indicates the number of ICMP destination unreachable messages sent by this gateway. outDestUnreachs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutTimeExcds.setDescription('This attribute indicates the number of ICMP time exceeded messages sent by this gateway. outTimeExcds wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutParmProbs.setDescription('This attribute indicates the number of ICMP parameter problem messages sent by this gateway. outParmProbs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutSrcQuenchs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutSrcQuenchs.setDescription('This attribute indicates the number of ICMP source quench messages sent by this gateway. ourSrcQuench wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutRedirects.setDescription('This attribute indicates the number of ICMP redirect messages sent by this gateway. outRedirects wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutEchos.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutEchos.setDescription('This attribute indicates the number of ICMP echo request messages sent by this gateway. outEchos wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutEchoReps.setDescription('This attribute indicates the number of ICMP echo reply messages sent by this gateway. outEchoReps wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutTimestamps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutTimestamps.setDescription('This attribute indicates the number of ICMP timestamp request messages sent by this gateway. outTimeStamps wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutTimestampReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutTimestampReps.setDescription('This attribute indicates the number of ICMP timestamp reply messages sent by this gateway. outTimeStampReps wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutAddrMasks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutAddrMasks.setDescription('This attribute indicates the number of ICMP address mask request messages sent by this gateway. outAddrMasks wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutAddrMaskReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutAddrMaskReps.setDescription('This attribute indicates the number of ICMP address mask reply message sent by this gateway. outAddrMaskReps wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInRtrAdvs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInRtrAdvs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInRtrAdvs.setDescription('This attribute indicates the number of ICMP router advertisement messages received by this gateway. inRtrAdvs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpInRtrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpInRtrSolicits.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpInRtrSolicits.setDescription('This attribute indicates the number of ICMP router solicitation messages received by this gateway. inRtrSolicits wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutRtrAdvs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutRtrAdvs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutRtrAdvs.setDescription('This attribute indicates the number of ICMP router advertisement messages sent by this gateway. outRtrAdvs wraps to zero if it reaches its maximum defined value.')
vrIpIcmpOutRtrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 12, 11, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpIcmpOutRtrSolicits.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpIcmpOutRtrSolicits.setDescription('This attribute indicates the number of ICMP router solicitation messages sent by this gateway. outRtrSolicits wraps to zero if it reaches its maximum defined value.')
vrIpRelayBC = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13))
vrIpRelayBCRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 1), )
if mibBuilder.loadTexts: vrIpRelayBCRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpRelayBC components.')
vrIpRelayBCRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRelayBCIndex"))
if mibBuilder.loadTexts: vrIpRelayBCRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCRowStatusEntry.setDescription('A single entry in the table represents a single vrIpRelayBC component.')
vrIpRelayBCRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRelayBCRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpRelayBC components. These components cannot be added nor deleted.')
vrIpRelayBCComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRelayBCComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpRelayBCStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRelayBCStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCStorageType.setDescription('This variable represents the storage type value for the vrIpRelayBC tables.')
vrIpRelayBCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpRelayBCIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCIndex.setDescription('This variable represents the index for the vrIpRelayBC tables.')
vrIpRelayBCProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 10), )
if mibBuilder.loadTexts: vrIpRelayBCProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCProvTable.setDescription('This group contains global configuration attributes for the Relay Broadcast component.')
vrIpRelayBCProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRelayBCIndex"))
if mibBuilder.loadTexts: vrIpRelayBCProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCProvEntry.setDescription('An entry in the vrIpRelayBCProvTable.')
vrIpRelayBCRelayStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRelayBCRelayStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCRelayStatus.setDescription('Specifies whether or not IP will forward IP broadcast packets that were received as Link-Layer broadcasts.')
vrIpRelayBCRelayNdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRelayBCRelayNdStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCRelayNdStatus.setDescription('Specifies whether or not IP will forward broadcast packets whose protocol is Sun ND.')
vrIpRelayBCOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 11), )
if mibBuilder.loadTexts: vrIpRelayBCOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCOperTable.setDescription('This group contains RelayBroadcast component statistics.')
vrIpRelayBCOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRelayBCIndex"))
if mibBuilder.loadTexts: vrIpRelayBCOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCOperEntry.setDescription('An entry in the vrIpRelayBCOperTable.')
vrIpRelayBCRelayNdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRelayBCRelayNdCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCRelayNdCount.setDescription('Indicates the number of Sun ND packets received by this router which were forwarded. relayNdCount wraps to zero if reached its maximum.')
vrIpRelayBCPort = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2))
vrIpRelayBCPortRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 1), )
if mibBuilder.loadTexts: vrIpRelayBCPortRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpRelayBCPort components.')
vrIpRelayBCPortRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRelayBCIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRelayBCPortPortNumIndex"))
if mibBuilder.loadTexts: vrIpRelayBCPortRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortRowStatusEntry.setDescription('A single entry in the table represents a single vrIpRelayBCPort component.')
vrIpRelayBCPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpRelayBCPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpRelayBCPort components. These components can be added and deleted.')
vrIpRelayBCPortComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRelayBCPortComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpRelayBCPortStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRelayBCPortStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortStorageType.setDescription('This variable represents the storage type value for the vrIpRelayBCPort tables.')
vrIpRelayBCPortPortNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435455)))
if mibBuilder.loadTexts: vrIpRelayBCPortPortNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortPortNumIndex.setDescription('This variable represents the index for the vrIpRelayBCPort tables.')
vrIpRelayBCPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 10), )
if mibBuilder.loadTexts: vrIpRelayBCPortOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortOperTable.setDescription('This group contains statistics related to InwPortEntry.')
vrIpRelayBCPortOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRelayBCIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpRelayBCPortPortNumIndex"))
if mibBuilder.loadTexts: vrIpRelayBCPortOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortOperEntry.setDescription('An entry in the vrIpRelayBCPortOperTable.')
vrIpRelayBCPortRelayBcUdpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 13, 2, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpRelayBCPortRelayBcUdpCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpRelayBCPortRelayBcUdpCount.setDescription('Indicates the number of forwarded packets with this destination UDP port number. relayBcUdpCount wraps to zero if reached its maximum.')
vrIpUdp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14))
vrIpUdpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 1), )
if mibBuilder.loadTexts: vrIpUdpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpUdp components.')
vrIpUdpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpUdpIndex"))
if mibBuilder.loadTexts: vrIpUdpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpUdp component.')
vrIpUdpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpUdp components. These components cannot be added nor deleted.')
vrIpUdpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpUdpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpStorageType.setDescription('This variable represents the storage type value for the vrIpUdp tables.')
vrIpUdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpUdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpIndex.setDescription('This variable represents the index for the vrIpUdp tables.')
vrIpUdpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 10), )
if mibBuilder.loadTexts: vrIpUdpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpStatsTable.setDescription('This group holds statictics for UDP.')
vrIpUdpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpUdpIndex"))
if mibBuilder.loadTexts: vrIpUdpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpStatsEntry.setDescription('An entry in the vrIpUdpStatsTable.')
vrIpUdpInDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpInDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpInDatagrams.setDescription('The number of UDP datagrams delivered to UDP users. inDatagrams wraps to zero if reaches its maximum defined value.')
vrIpUdpNoPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpNoPorts.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpNoPorts.setDescription('The number of UDP datagrams received for which there was no application at the destination port. noPorts wraps to zero if reaches its maximum defined value.')
vrIpUdpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpInErrors.setDescription('The number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port. inErrors wraps to zero if reaches its maximum defined value.')
vrIpUdpOutDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpOutDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpOutDatagrams.setDescription('The number of UDP datagrams sent from this gateway. outDatagrams wraps to zero if reaches its maximum defined value.')
vrIpUdpListenEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 2))
vrIpUdpListenEntryRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 2, 1), )
if mibBuilder.loadTexts: vrIpUdpListenEntryRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpListenEntryRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpUdpListenEntry components.')
vrIpUdpListenEntryRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpUdpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpUdpListenEntryLocalAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpUdpListenEntryLocalPortIndex"))
if mibBuilder.loadTexts: vrIpUdpListenEntryRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpListenEntryRowStatusEntry.setDescription('A single entry in the table represents a single vrIpUdpListenEntry component.')
vrIpUdpListenEntryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpListenEntryRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpListenEntryRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpUdpListenEntry components. These components cannot be added nor deleted.')
vrIpUdpListenEntryComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpListenEntryComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpListenEntryComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpUdpListenEntryStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpUdpListenEntryStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpListenEntryStorageType.setDescription('This variable represents the storage type value for the vrIpUdpListenEntry tables.')
vrIpUdpListenEntryLocalAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpUdpListenEntryLocalAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpListenEntryLocalAddressIndex.setDescription('This variable represents an index for the vrIpUdpListenEntry tables.')
vrIpUdpListenEntryLocalPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 14, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpUdpListenEntryLocalPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpUdpListenEntryLocalPortIndex.setDescription('This variable represents an index for the vrIpUdpListenEntry tables.')
vrIpTcp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15))
vrIpTcpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 1), )
if mibBuilder.loadTexts: vrIpTcpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpTcp components.')
vrIpTcpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpIndex"))
if mibBuilder.loadTexts: vrIpTcpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpTcp component.')
vrIpTcpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpTcp components. These components cannot be added nor deleted.')
vrIpTcpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpTcpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpStorageType.setDescription('This variable represents the storage type value for the vrIpTcp tables.')
vrIpTcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpTcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpIndex.setDescription('This variable represents the index for the vrIpTcp tables.')
vrIpTcpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10), )
if mibBuilder.loadTexts: vrIpTcpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpStatsTable.setDescription('This group contains statistics for TCP.')
vrIpTcpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpIndex"))
if mibBuilder.loadTexts: vrIpTcpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpStatsEntry.setDescription('An entry in the vrIpTcpStatsTable.')
vrIpTcpRToAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("constant", 2), ("rsre", 3), ("vanJacobson", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpRToAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpRToAlgorithm.setDescription('Indicate which algorithm was used to calculate the timeout value used for retransmitting unackowledged octet.')
vrIpTcpRToMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpRToMin.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpRToMin.setDescription('Indicate the minimum value, measured in milliseconds, allowed for retransmission timeout.')
vrIpTcpRToMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpRToMax.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpRToMax.setDescription('Indicates the maximun value, measured in milliseconds, allowed for retransmission timeout.')
vrIpTcpMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, -1)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpMaxConn.setDescription('Limit on number of connections the TCP can support. The value is always -1 which indicates that the number of connections supported is dynamic (limited by memory in the system).')
vrIpTcpActiveOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpActiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpActiveOpens.setDescription('The number of times TCP connections have made a direct transition to the synSent state from the closed state.')
vrIpTcpPassiveOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpPassiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpPassiveOpens.setDescription('The number of times TCP connections have made a direct transition to the synRcvd state from the listen state.')
vrIpTcpAttemptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpAttemptFails.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpAttemptFails.setDescription('The number of times TCP connections have made a direct transition to the closed state from either the synSent state or the synRcvd state, plus the number of times TCP connections have made a direct transition to the listen state from the synRcvd state.')
vrIpTcpEstabResets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpEstabResets.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpEstabResets.setDescription('The number of times TCP connections have made a direct transition to the closed state from either the established state or the closedWait state.')
vrIpTcpCurrEstab = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpCurrEstab.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpCurrEstab.setDescription('The number of TCP connections for which the current state is either established or closedWait.')
vrIpTcpInSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpInSegs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpInSegs.setDescription('The number of segments received, including those received in error. This count includes segments received on currently established connections.')
vrIpTcpOutSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpOutSegs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpOutSegs.setDescription('The number of segments sent, including those on current connections but excluding those containing only retransmitted octets.')
vrIpTcpRetransSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpRetransSegs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpRetransSegs.setDescription('The number of segments retransmitted that is, the number of TCP segments transmitted containing one or more previously transmitted octets.')
vrIpTcpInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpInErrs.setDescription('Total number of segments received in error, for example bad TCP checksum.')
vrIpTcpOutRsts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 10, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpOutRsts.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpOutRsts.setDescription('Number of TCP segments sent containing the RST flag.')
vrIpTcpTcpEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2))
vrIpTcpTcpEntryRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1), )
if mibBuilder.loadTexts: vrIpTcpTcpEntryRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpTcpTcpEntry components.')
vrIpTcpTcpEntryRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpTcpEntryLocalAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpTcpEntryLocalPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpTcpEntryRemoteAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpTcpEntryRemotePortIndex"))
if mibBuilder.loadTexts: vrIpTcpTcpEntryRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryRowStatusEntry.setDescription('A single entry in the table represents a single vrIpTcpTcpEntry component.')
vrIpTcpTcpEntryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpTcpEntryRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpTcpTcpEntry components. These components cannot be added nor deleted.')
vrIpTcpTcpEntryComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpTcpEntryComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpTcpTcpEntryStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTcpTcpEntryStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryStorageType.setDescription('This variable represents the storage type value for the vrIpTcpTcpEntry tables.')
vrIpTcpTcpEntryLocalAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpTcpTcpEntryLocalAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryLocalAddressIndex.setDescription('This variable represents an index for the vrIpTcpTcpEntry tables.')
vrIpTcpTcpEntryLocalPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpTcpTcpEntryLocalPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryLocalPortIndex.setDescription('This variable represents an index for the vrIpTcpTcpEntry tables.')
vrIpTcpTcpEntryRemoteAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: vrIpTcpTcpEntryRemoteAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryRemoteAddressIndex.setDescription('This variable represents an index for the vrIpTcpTcpEntry tables.')
vrIpTcpTcpEntryRemotePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpTcpTcpEntryRemotePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryRemotePortIndex.setDescription('This variable represents an index for the vrIpTcpTcpEntry tables.')
vrIpTcpTcpEntryOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 10), )
if mibBuilder.loadTexts: vrIpTcpTcpEntryOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains columnar entries for each end-point on the TCP.')
vrIpTcpTcpEntryOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpTcpEntryLocalAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpTcpEntryLocalPortIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpTcpEntryRemoteAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTcpTcpEntryRemotePortIndex"))
if mibBuilder.loadTexts: vrIpTcpTcpEntryOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryOperEntry.setDescription('An entry in the vrIpTcpTcpEntryOperTable.')
vrIpTcpTcpEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 15, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("closed", 1), ("listen", 2), ("synSent", 3), ("synReceived", 4), ("established", 5), ("closeWait", 6), ("finWait1", 7), ("closing", 8), ("lastAck", 9), ("finWait2", 10), ("timeWait", 11), ("delete", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpTcpTcpEntryState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTcpTcpEntryState.setDescription('This attribute reflects the current state of this Tcp connection.')
vrIpBootp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16))
vrIpBootpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 1), )
if mibBuilder.loadTexts: vrIpBootpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpBootp components.')
vrIpBootpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpIndex"))
if mibBuilder.loadTexts: vrIpBootpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpBootp component.')
vrIpBootpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpBootpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpBootp components. These components can be added and deleted.')
vrIpBootpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpBootpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpStorageType.setDescription('This variable represents the storage type value for the vrIpBootp tables.')
vrIpBootpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpBootpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpIndex.setDescription('This variable represents the index for the vrIpBootp tables.')
vrIpBootpAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 10), )
if mibBuilder.loadTexts: vrIpBootpAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrIpBootpAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpIndex"))
if mibBuilder.loadTexts: vrIpBootpAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpAdminControlEntry.setDescription('An entry in the vrIpBootpAdminControlTable.')
vrIpBootpSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpBootpSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrIpBootpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 11), )
if mibBuilder.loadTexts: vrIpBootpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpProvTable.setDescription('This group contains provisionable attributes for the BootpRelayAgent component.')
vrIpBootpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpIndex"))
if mibBuilder.loadTexts: vrIpBootpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpProvEntry.setDescription('An entry in the vrIpBootpProvTable.')
vrIpBootpHopDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 16)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpBootpHopDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpHopDiscardThreshold.setDescription("BOOTP packets contain a 'hops' field which is used to limit the number of relay agents that can process the packet (each relay agent increments the 'hops' field by one). This attribute is used by the relay agent to determine when to discard a BOOTP packet. If the 'hops' field exceeds the hopDiscardThreshold the BOOTP packet will be discarded.")
vrIpBootpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 12), )
if mibBuilder.loadTexts: vrIpBootpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpBootpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpIndex"))
if mibBuilder.loadTexts: vrIpBootpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpStateEntry.setDescription('An entry in the vrIpBootpStateTable.')
vrIpBootpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpBootpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpBootpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpBootpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 13), )
if mibBuilder.loadTexts: vrIpBootpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrIpBootpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpIndex"))
if mibBuilder.loadTexts: vrIpBootpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpOperStatusEntry.setDescription('An entry in the vrIpBootpOperStatusTable.')
vrIpBootpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrIpBootpPpE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2))
vrIpBootpPpERowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 1), )
if mibBuilder.loadTexts: vrIpBootpPpERowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpERowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpBootpPpE components.')
vrIpBootpPpERowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpPpEIndex"))
if mibBuilder.loadTexts: vrIpBootpPpERowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpERowStatusEntry.setDescription('A single entry in the table represents a single vrIpBootpPpE component.')
vrIpBootpPpERowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpERowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpERowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpBootpPpE components. These components cannot be added nor deleted.')
vrIpBootpPpEComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpBootpPpEStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEStorageType.setDescription('This variable represents the storage type value for the vrIpBootpPpE tables.')
vrIpBootpPpEIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: vrIpBootpPpEIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEIndex.setDescription('This variable represents the index for the vrIpBootpPpE tables.')
vrIpBootpPpEOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 10), )
if mibBuilder.loadTexts: vrIpBootpPpEOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains BootpPortEntry component operational data.')
vrIpBootpPpEOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpPpEIndex"))
if mibBuilder.loadTexts: vrIpBootpPpEOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEOperEntry.setDescription('An entry in the vrIpBootpPpEOperTable.')
vrIpBootpPpEStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEStatus.setDescription('This attribute indicates the status of the provisioned BootpPortEntry component. A value of disabled is used when the parent components, Vr, Ip, IpPort, or BootpRelayAgent is in a disabled state. A value of up is used when the BootpPortEntry is in an operational state. A state of down is used if the media associated with the BootpPortEntry is not ready or disabled.')
vrIpBootpPpEStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 11), )
if mibBuilder.loadTexts: vrIpBootpPpEStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains BootpPortEntry component statistics.')
vrIpBootpPpEStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpBootpPpEIndex"))
if mibBuilder.loadTexts: vrIpBootpPpEStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEStatsEntry.setDescription('An entry in the vrIpBootpPpEStatsTable.')
vrIpBootpPpEInRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEInRequests.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEInRequests.setDescription('This attribute counts the total number of BOOTP Request messages received on this port.')
vrIpBootpPpEInReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEInReplies.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEInReplies.setDescription('This attribute counts the total number of BOOTP Reply messages received on this port.')
vrIpBootpPpEOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEOutRequests.setDescription('This attribute counts total the number of BOOTP Request messages broadcast out on this port.')
vrIpBootpPpEOutReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEOutReplies.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEOutReplies.setDescription('This attribute counts the total number of BOOTP Reply messages sent out on this port.')
vrIpBootpPpEInRequestErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEInRequestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEInRequestErrors.setDescription('This attribute counts the number of BOOTP Request messages received on this port but not forwarded due to an error. An error occurs if the BOOTP hop limit has been exceeded.')
vrIpBootpPpEInReplyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 16, 2, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpBootpPpEInReplyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpBootpPpEInReplyErrors.setDescription('This attribute counts the number of BOOTP Reply messages received on this port but not forwarded due to an error. An error occurs if the giaddr field in the BOOTP reply does not match an IP address assigned to this VirtualRouter, or if the output IpPort for the BOOTP reply is not provisioned for BOOTP.')
vrIpCache = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17))
vrIpCacheRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 1), )
if mibBuilder.loadTexts: vrIpCacheRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpCache components.')
vrIpCacheRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpCacheIndex"))
if mibBuilder.loadTexts: vrIpCacheRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheRowStatusEntry.setDescription('A single entry in the table represents a single vrIpCache component.')
vrIpCacheRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpCache components. These components cannot be added nor deleted.')
vrIpCacheComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpCacheStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheStorageType.setDescription('This variable represents the storage type value for the vrIpCache tables.')
vrIpCacheIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: vrIpCacheIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheIndex.setDescription('This variable represents the index for the vrIpCache tables.')
vrIpCacheStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 10), )
if mibBuilder.loadTexts: vrIpCacheStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheStateTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpCacheStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpCacheIndex"))
if mibBuilder.loadTexts: vrIpCacheStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheStateEntry.setDescription('An entry in the vrIpCacheStateTable.')
vrIpCacheAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpCacheOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpCacheUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpCacheOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 11), )
if mibBuilder.loadTexts: vrIpCacheOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the operational attributes of an Ip cache table.')
vrIpCacheOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpCacheIndex"))
if mibBuilder.loadTexts: vrIpCacheOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheOperEntry.setDescription('An entry in the vrIpCacheOperTable.')
vrIpCacheEntriesFree = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheEntriesFree.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheEntriesFree.setDescription('This attribute is indicative of the number of free Ip cache table entries. A consistently high value for this attribute indicates that there is a resource surplus of the memory requirements for cache table. This surplus could be utilized elsewhere if needed by adjusting the cacheTableMaxEntries under the Ip component.')
vrIpCacheTotalLookups = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheTotalLookups.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheTotalLookups.setDescription('This attribute indicates the total number of local cache lookups. It wraps around to 0 when it reaches the maximum value of 4294967295.')
vrIpCacheLookupMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheLookupMisses.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheLookupMisses.setDescription('This attribute indicates the total number of local cache lookup misses. It wraps around to 0 when it reaches the maximum value of 4294967295.')
vrIpCacheCacheTableMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 17, 11, 1, 395), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpCacheCacheTableMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpCacheCacheTableMaxEntries.setDescription('This attribute indicates the current maximum number of entries that can exist in the IP local cache table on each LP.')
vrIpTunnel = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18))
vrIpTunnelRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 1), )
if mibBuilder.loadTexts: vrIpTunnelRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpTunnel components.')
vrIpTunnelRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelIndex"))
if mibBuilder.loadTexts: vrIpTunnelRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelRowStatusEntry.setDescription('A single entry in the table represents a single vrIpTunnel component.')
vrIpTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpTunnelRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpTunnel components. These components can be added and deleted.')
vrIpTunnelComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpTunnelStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelStorageType.setDescription('This variable represents the storage type value for the vrIpTunnel tables.')
vrIpTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpTunnelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelIndex.setDescription('This variable represents the index for the vrIpTunnel tables.')
vrIpTunnelStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 10), )
if mibBuilder.loadTexts: vrIpTunnelStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpTunnelStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelIndex"))
if mibBuilder.loadTexts: vrIpTunnelStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelStateEntry.setDescription('An entry in the vrIpTunnelStateTable.')
vrIpTunnelAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpTunnelOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpTunnelUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpTunnelSep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2))
vrIpTunnelSepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 1), )
if mibBuilder.loadTexts: vrIpTunnelSepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpTunnelSep components.')
vrIpTunnelSepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelSepIndex"))
if mibBuilder.loadTexts: vrIpTunnelSepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepRowStatusEntry.setDescription('A single entry in the table represents a single vrIpTunnelSep component.')
vrIpTunnelSepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpTunnelSepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpTunnelSep components. These components can be added and deleted.')
vrIpTunnelSepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelSepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpTunnelSepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelSepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepStorageType.setDescription('This variable represents the storage type value for the vrIpTunnelSep tables.')
vrIpTunnelSepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: vrIpTunnelSepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepIndex.setDescription('This variable represents the index for the vrIpTunnelSep tables.')
vrIpTunnelSepIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 10), )
if mibBuilder.loadTexts: vrIpTunnelSepIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
vrIpTunnelSepIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelSepIndex"))
if mibBuilder.loadTexts: vrIpTunnelSepIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepIfEntryEntry.setDescription('An entry in the vrIpTunnelSepIfEntryTable.')
vrIpTunnelSepIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpTunnelSepIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
vrIpTunnelSepIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 10, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelSepIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
vrIpTunnelSepMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 11), )
if mibBuilder.loadTexts: vrIpTunnelSepMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepMpTable.setDescription('This group contains the base provisioning data for the media base component.')
vrIpTunnelSepMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelSepIndex"))
if mibBuilder.loadTexts: vrIpTunnelSepMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepMpEntry.setDescription('An entry in the vrIpTunnelSepMpTable.')
vrIpTunnelSepLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 11, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpTunnelSepLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepLinkToProtocolPort.setDescription('This attribute specifies the ProtocolPort to which this interface is linked to. The protocol port is the logical interface to the network. The protocol port component describes the logical characteristics of this interface.')
vrIpTunnelSepProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 12), )
if mibBuilder.loadTexts: vrIpTunnelSepProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepProvTable.setDescription('This group contains the provisionable attributes for the StaticEndPoint component.')
vrIpTunnelSepProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelSepIndex"))
if mibBuilder.loadTexts: vrIpTunnelSepProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepProvEntry.setDescription('An entry in the vrIpTunnelSepProvTable.')
vrIpTunnelSepEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ipInIp", 0), ("greIp", 1))).clone('ipInIp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpTunnelSepEncapType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepEncapType.setDescription('There are two types of encapsulation techniques for IP tunnel, IP in IP (RFC 2003) and GRE over IP (RFC 1701). This attributes specifies the encapsulation type of the IP tunnel. It defaults to ipInIp. ipInIp: As defined in RFC 2003, it can be used to encapsulated IP and IP payload only. If IP is the only type of payload to be encapsulated by the tunnel, this type of encapsulation is recommended as it requires less processing and uses less bandwidth. greIp: As defined in RFC 1701, it can be used to encapsulate IP or IPX payload. To encapsulate IPX payload, this encapsulation type must be used.')
vrIpTunnelSepSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 12, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpTunnelSepSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepSourceAddress.setDescription("This attribute specifies the IP address of the local end of the tunnel. The source address must be an address in the shared domain, and it must equal to an interface address on its own Virtual Router (under Vr/<string> Pp/<string> IpPort LogicalIf/<IpAddress>). However, it must not be the interface address of the linked protocol port's IpPort.")
vrIpTunnelSepDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 12, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpTunnelSepDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepDestinationAddress.setDescription('This attribute specifies the IP address of the far end of the tunnel. It must not match any of the IP interface addresses on this Virtual Router.')
vrIpTunnelSepOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 14), )
if mibBuilder.loadTexts: vrIpTunnelSepOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepOperTable.setDescription('This group contains the operational status attributes of the StaticEndPoint component.')
vrIpTunnelSepOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpTunnelSepIndex"))
if mibBuilder.loadTexts: vrIpTunnelSepOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepOperEntry.setDescription('An entry in the vrIpTunnelSepOperTable.')
vrIpTunnelSepPathMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 18, 2, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpTunnelSepPathMtu.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpTunnelSepPathMtu.setDescription('This attribute indicates the latest learned Path MTU of the tunnel. MTU is the maximum transmission unit of an arbitrary internet path. When a large amount of IP datagrams are to be transmitted, it is usually preferable that the datagrams be of the largest size that does not require fragmentation anywhere along the path from the source to the destination. This datagram size is referred to as the Path MTU (PMTU), and it is equal to the minimum of the MTUs of each hop in the path.')
vrIpMcast = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26))
vrIpMcastRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 1), )
if mibBuilder.loadTexts: vrIpMcastRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcast components.')
vrIpMcastRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"))
if mibBuilder.loadTexts: vrIpMcastRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcast component.')
vrIpMcastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcast components. These components can be added and deleted.')
vrIpMcastComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStorageType.setDescription('This variable represents the storage type value for the vrIpMcast tables.')
vrIpMcastIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpMcastIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIndex.setDescription('This variable represents the index for the vrIpMcast tables.')
vrIpMcastAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 100), )
if mibBuilder.loadTexts: vrIpMcastAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrIpMcastAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"))
if mibBuilder.loadTexts: vrIpMcastAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastAdminControlEntry.setDescription('An entry in the vrIpMcastAdminControlTable.')
vrIpMcastSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrIpMcastStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 103), )
if mibBuilder.loadTexts: vrIpMcastStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpMcastStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 103, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"))
if mibBuilder.loadTexts: vrIpMcastStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStateEntry.setDescription('An entry in the vrIpMcastStateTable.')
vrIpMcastAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 103, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpMcastOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 103, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpMcastUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 103, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpMcastOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 104), )
if mibBuilder.loadTexts: vrIpMcastOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrIpMcastOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 104, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"))
if mibBuilder.loadTexts: vrIpMcastOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastOperStatusEntry.setDescription('An entry in the vrIpMcastOperStatusTable.')
vrIpMcastSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 104, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrIpMcastCtsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 701), )
if mibBuilder.loadTexts: vrIpMcastCtsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCtsTable.setDescription('This attribute specifies the maximum number of entries supported in the IP Multicast cache table on each LP. The default is 100 for a CP and 200 for an FP. The value must be multiple of 100.')
vrIpMcastCtsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 701, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastCtsIndex"))
if mibBuilder.loadTexts: vrIpMcastCtsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCtsEntry.setDescription('An entry in the vrIpMcastCtsTable.')
vrIpMcastCtsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 701, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: vrIpMcastCtsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCtsIndex.setDescription('This variable represents the vrIpMcastCtsTable specific index for the vrIpMcastCtsTable.')
vrIpMcastCtsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 701, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastCtsValue.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCtsValue.setDescription('This variable represents an individual value for the vrIpMcastCtsTable.')
vrIpMcastIgmp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2))
vrIpMcastIgmpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 1), )
if mibBuilder.loadTexts: vrIpMcastIgmpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastIgmp components.')
vrIpMcastIgmpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpIndex"))
if mibBuilder.loadTexts: vrIpMcastIgmpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastIgmp component.')
vrIpMcastIgmpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastIgmpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastIgmp components. These components can be added and deleted.')
vrIpMcastIgmpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastIgmpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpStorageType.setDescription('This variable represents the storage type value for the vrIpMcastIgmp tables.')
vrIpMcastIgmpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpMcastIgmpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpIndex.setDescription('This variable represents the index for the vrIpMcastIgmp tables.')
vrIpMcastIgmpAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 10), )
if mibBuilder.loadTexts: vrIpMcastIgmpAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrIpMcastIgmpAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpIndex"))
if mibBuilder.loadTexts: vrIpMcastIgmpAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpAdminControlEntry.setDescription('An entry in the vrIpMcastIgmpAdminControlTable.')
vrIpMcastIgmpSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastIgmpSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrIpMcastIgmpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 12), )
if mibBuilder.loadTexts: vrIpMcastIgmpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpMcastIgmpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpIndex"))
if mibBuilder.loadTexts: vrIpMcastIgmpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpStateEntry.setDescription('An entry in the vrIpMcastIgmpStateTable.')
vrIpMcastIgmpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpMcastIgmpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpMcastIgmpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpMcastIgmpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 13), )
if mibBuilder.loadTexts: vrIpMcastIgmpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrIpMcastIgmpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpIndex"))
if mibBuilder.loadTexts: vrIpMcastIgmpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpOperStatusEntry.setDescription('An entry in the vrIpMcastIgmpOperStatusTable.')
vrIpMcastIgmpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrIpMcastIgmpGc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2))
vrIpMcastIgmpGcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 1), )
if mibBuilder.loadTexts: vrIpMcastIgmpGcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpMcastIgmpGc components.')
vrIpMcastIgmpGcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpGcGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpGcDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpGcProtocolportStringIndex"))
if mibBuilder.loadTexts: vrIpMcastIgmpGcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastIgmpGc component.')
vrIpMcastIgmpGcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpGcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastIgmpGc components. These components cannot be added nor deleted.')
vrIpMcastIgmpGcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpGcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastIgmpGcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpGcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcStorageType.setDescription('This variable represents the storage type value for the vrIpMcastIgmpGc tables.')
vrIpMcastIgmpGcGAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpMcastIgmpGcGAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcGAddrIndex.setDescription('This variable represents an index for the vrIpMcastIgmpGc tables.')
vrIpMcastIgmpGcDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: vrIpMcastIgmpGcDomainIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcDomainIndex.setDescription('This variable represents an index for the vrIpMcastIgmpGc tables.')
vrIpMcastIgmpGcProtocolportStringIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 1, 1, 12), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: vrIpMcastIgmpGcProtocolportStringIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcProtocolportStringIndex.setDescription('This variable represents an index for the vrIpMcastIgmpGc tables.')
vrIpMcastIgmpGcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 11), )
if mibBuilder.loadTexts: vrIpMcastIgmpGcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of the CacheEntry component.')
vrIpMcastIgmpGcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpGcGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpGcDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIgmpGcProtocolportStringIndex"))
if mibBuilder.loadTexts: vrIpMcastIgmpGcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcOperEntry.setDescription('An entry in the vrIpMcastIgmpGcOperTable.')
vrIpMcastIgmpGcUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 11, 1, 1), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpGcUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcUpTime.setDescription('This attribute indicates the time elapsed since this entry was created.')
vrIpMcastIgmpGcExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 11, 1, 2), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpGcExpiryTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcExpiryTime.setDescription('This attribute indicates the minimum amount of time reamining before this entry will be aged out.')
vrIpMcastIgmpGcLastReporter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 11, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpGcLastReporter.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcLastReporter.setDescription('This attribute indicates the IP address of the source of the last membership report received for this IP Multicast group address on this interface. If no membership report has been received, this attribute has the value 0.0.0.0.')
vrIpMcastIgmpGcVersion1HostTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 2, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastIgmpGcVersion1HostTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastIgmpGcVersion1HostTimer.setDescription('This attribute indicates the time remaining until the local router will assume that there are no longer any IGMPv1 members on the IP subnet attached to this interface. Upon hearing any IGMPv1 Membership Report, this value is reset to the group membership timer.')
vrIpMcastStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3))
vrIpMcastStaticRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 1), )
if mibBuilder.loadTexts: vrIpMcastStaticRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastStatic components.')
vrIpMcastStaticRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticIndex"))
if mibBuilder.loadTexts: vrIpMcastStaticRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastStatic component.')
vrIpMcastStaticRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastStaticRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastStatic components. These components can be added and deleted.')
vrIpMcastStaticComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastStaticComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastStaticStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastStaticStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticStorageType.setDescription('This variable represents the storage type value for the vrIpMcastStatic tables.')
vrIpMcastStaticIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpMcastStaticIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticIndex.setDescription('This variable represents the index for the vrIpMcastStatic tables.')
vrIpMcastStaticStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 10), )
if mibBuilder.loadTexts: vrIpMcastStaticStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpMcastStaticStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticIndex"))
if mibBuilder.loadTexts: vrIpMcastStaticStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticStateEntry.setDescription('An entry in the vrIpMcastStaticStateTable.')
vrIpMcastStaticAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastStaticAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpMcastStaticOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastStaticOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpMcastStaticUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastStaticUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpMcastStaticRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2))
vrIpMcastStaticRouteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 1), )
if mibBuilder.loadTexts: vrIpMcastStaticRouteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastStaticRoute components.')
vrIpMcastStaticRouteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticRouteGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticRouteDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastStaticRouteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastStaticRoute component.')
vrIpMcastStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastStaticRouteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastStaticRoute components. These components can be added and deleted.')
vrIpMcastStaticRouteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastStaticRouteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastStaticRouteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastStaticRouteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteStorageType.setDescription('This variable represents the storage type value for the vrIpMcastStaticRoute tables.')
vrIpMcastStaticRouteGAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpMcastStaticRouteGAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteGAddrIndex.setDescription('This variable represents an index for the vrIpMcastStaticRoute tables.')
vrIpMcastStaticRouteDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: vrIpMcastStaticRouteDomainIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteDomainIndex.setDescription('This variable represents an index for the vrIpMcastStaticRoute tables.')
vrIpMcastStaticRouteOifsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 705), )
if mibBuilder.loadTexts: vrIpMcastStaticRouteOifsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteOifsTable.setDescription('This attribute specifies a list of links to logicalInterfaces representing the outgoing interfaces for this multicast static route entry.')
vrIpMcastStaticRouteOifsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 705, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticRouteGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticRouteDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastStaticRouteOifsValue"))
if mibBuilder.loadTexts: vrIpMcastStaticRouteOifsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteOifsEntry.setDescription('An entry in the vrIpMcastStaticRouteOifsTable.')
vrIpMcastStaticRouteOifsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 705, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastStaticRouteOifsValue.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteOifsValue.setDescription('This variable represents both the value and the index for the vrIpMcastStaticRouteOifsTable.')
vrIpMcastStaticRouteOifsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 3, 2, 705, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vrIpMcastStaticRouteOifsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastStaticRouteOifsRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the vrIpMcastStaticRouteOifsTable.')
vrIpMcastPg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4))
vrIpMcastPgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 1), )
if mibBuilder.loadTexts: vrIpMcastPgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastPg components.')
vrIpMcastPgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPgIndex"))
if mibBuilder.loadTexts: vrIpMcastPgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPg component.')
vrIpMcastPgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPg components. These components can be added and deleted.')
vrIpMcastPgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPg tables.')
vrIpMcastPgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: vrIpMcastPgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgIndex.setDescription('This variable represents the index for the vrIpMcastPg tables.')
vrIpMcastPgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 10), )
if mibBuilder.loadTexts: vrIpMcastPgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgProvTable.setDescription('This group contains the provisionable attributes for the PolicyGroup component.')
vrIpMcastPgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPgIndex"))
if mibBuilder.loadTexts: vrIpMcastPgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgProvEntry.setDescription('An entry in the vrIpMcastPgProvTable.')
vrIpMcastPgAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("allow", 2))).clone('deny')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPgAction.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgAction.setDescription('This attribute specifies the action to be taken if a join request is received for any of the multicast group addresses configured as part of this policy. The default action is to deny the join request.')
vrIpMcastPgLinkToPolicyUserTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 704), )
if mibBuilder.loadTexts: vrIpMcastPgLinkToPolicyUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgLinkToPolicyUserTable.setDescription('This attribute specifies a list of IpPorts on which this policy group is applied.')
vrIpMcastPgLinkToPolicyUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 704, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPgIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPgLinkToPolicyUserValue"))
if mibBuilder.loadTexts: vrIpMcastPgLinkToPolicyUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgLinkToPolicyUserEntry.setDescription('An entry in the vrIpMcastPgLinkToPolicyUserTable.')
vrIpMcastPgLinkToPolicyUserValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 704, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPgLinkToPolicyUserValue.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgLinkToPolicyUserValue.setDescription('This variable represents both the value and the index for the vrIpMcastPgLinkToPolicyUserTable.')
vrIpMcastPgLinkToPolicyUserRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 704, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: vrIpMcastPgLinkToPolicyUserRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgLinkToPolicyUserRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the vrIpMcastPgLinkToPolicyUserTable.')
vrIpMcastPgGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 2))
vrIpMcastPgGrpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 2, 1), )
if mibBuilder.loadTexts: vrIpMcastPgGrpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgGrpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastPgGrp components.')
vrIpMcastPgGrpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPgIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPgGrpGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPgGrpGMaskIndex"))
if mibBuilder.loadTexts: vrIpMcastPgGrpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgGrpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPgGrp component.')
vrIpMcastPgGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPgGrpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgGrpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPgGrp components. These components can be added and deleted.')
vrIpMcastPgGrpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPgGrpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgGrpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPgGrpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPgGrpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgGrpStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPgGrp tables.')
vrIpMcastPgGrpGAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpMcastPgGrpGAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgGrpGAddrIndex.setDescription('This variable represents an index for the vrIpMcastPgGrp tables.')
vrIpMcastPgGrpGMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 4, 2, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpMcastPgGrpGMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPgGrpGMaskIndex.setDescription('This variable represents an index for the vrIpMcastPgGrp tables.')
vrIpMcastDomain = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5))
vrIpMcastDomainRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 1), )
if mibBuilder.loadTexts: vrIpMcastDomainRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastDomain components.')
vrIpMcastDomainRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastDomainRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastDomain component.')
vrIpMcastDomainRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastDomainRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastDomain components. These components can be added and deleted.')
vrIpMcastDomainComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastDomainComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastDomainStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastDomainStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainStorageType.setDescription('This variable represents the storage type value for the vrIpMcastDomain tables.')
vrIpMcastDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: vrIpMcastDomainIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainIndex.setDescription('This variable represents the index for the vrIpMcastDomain tables.')
vrIpMcastDomainOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 11), )
if mibBuilder.loadTexts: vrIpMcastDomainOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainOperTable.setDescription('This group contains the operational attributes for the Domain component.')
vrIpMcastDomainOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastDomainOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainOperEntry.setDescription('An entry in the vrIpMcastDomainOperTable.')
vrIpMcastDomainProtocolActive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("pimSm", 1), ("pimDm", 2), ("local", 3), ("dvmrp", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastDomainProtocolActive.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastDomainProtocolActive.setDescription('This attribute indicates the multicast protocol active in this domain.')
vrIpMcastFwd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6))
vrIpMcastFwdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1), )
if mibBuilder.loadTexts: vrIpMcastFwdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpMcastFwd components.')
vrIpMcastFwdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdSrcAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdSrcMaskIndex"))
if mibBuilder.loadTexts: vrIpMcastFwdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastFwd component.')
vrIpMcastFwdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastFwd components. These components cannot be added nor deleted.')
vrIpMcastFwdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastFwdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdStorageType.setDescription('This variable represents the storage type value for the vrIpMcastFwd tables.')
vrIpMcastFwdGAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpMcastFwdGAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdGAddrIndex.setDescription('This variable represents an index for the vrIpMcastFwd tables.')
vrIpMcastFwdDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: vrIpMcastFwdDomainIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdDomainIndex.setDescription('This variable represents an index for the vrIpMcastFwd tables.')
vrIpMcastFwdSrcAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: vrIpMcastFwdSrcAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdSrcAddrIndex.setDescription('This variable represents an index for the vrIpMcastFwd tables.')
vrIpMcastFwdSrcMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: vrIpMcastFwdSrcMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdSrcMaskIndex.setDescription('This variable represents an index for the vrIpMcastFwd tables.')
vrIpMcastFwdOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 10), )
if mibBuilder.loadTexts: vrIpMcastFwdOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes associated with a multicast forwarding entry.')
vrIpMcastFwdOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdSrcAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdSrcMaskIndex"))
if mibBuilder.loadTexts: vrIpMcastFwdOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOperEntry.setDescription('An entry in the vrIpMcastFwdOperTable.')
vrIpMcastFwdAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdAge.setDescription('This attribute indicates the number of seconds since this route was last updated.')
vrIpMcastFwdInProtocolPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 10, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdInProtocolPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdInProtocolPortName.setDescription('This attribute indicates the name of the (incoming) protocol port from which the route was learned.')
vrIpMcastFwdProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("dvmrp", 4), ("mospf", 5), ("pimSparseDense", 6), ("cbt", 7), ("pimSparse", 8), ("pimDense", 9), ("igmponly", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdProtocol.setDescription('This attribute indicates the multicast routing protocol via which this multicast forwarding entry was learned.')
vrIpMcastFwdReversePathForwardingNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 10, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdReversePathForwardingNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdReversePathForwardingNeighbor.setDescription('This attribute indicates the address of the upstream neighbor (RPF neighbor) from which IP datagrams from these sources to this multicast address are received, or 0.0.0.0 if the upstream is unknown (e.g., in CBT).')
vrIpMcastFwdFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 10, 1, 703), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(3, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdFlags.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdFlags.setDescription('This attribute indicates information concerning the forwarding entry. In particular, the flag information indicates wildcard, SPT, RPT, and Reg entries.')
vrIpMcastFwdOif = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2))
vrIpMcastFwdOifRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 1), )
if mibBuilder.loadTexts: vrIpMcastFwdOifRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpMcastFwdOif components.')
vrIpMcastFwdOifRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdSrcAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdSrcMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdOifOutIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdOifConnectionIndex"))
if mibBuilder.loadTexts: vrIpMcastFwdOifRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastFwdOif component.')
vrIpMcastFwdOifRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdOifRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastFwdOif components. These components cannot be added nor deleted.')
vrIpMcastFwdOifComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdOifComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastFwdOifStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdOifStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifStorageType.setDescription('This variable represents the storage type value for the vrIpMcastFwdOif tables.')
vrIpMcastFwdOifOutIfAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpMcastFwdOifOutIfAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifOutIfAddressIndex.setDescription('This variable represents an index for the vrIpMcastFwdOif tables.')
vrIpMcastFwdOifConnectionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: vrIpMcastFwdOifConnectionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifConnectionIndex.setDescription('This variable represents an index for the vrIpMcastFwdOif tables.')
vrIpMcastFwdOifOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 10), )
if mibBuilder.loadTexts: vrIpMcastFwdOifOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes for the InwIpOutInterface component.')
vrIpMcastFwdOifOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdGAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdSrcAddrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdSrcMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdOifOutIfAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastFwdOifConnectionIndex"))
if mibBuilder.loadTexts: vrIpMcastFwdOifOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifOperEntry.setDescription('An entry in the vrIpMcastFwdOifOperTable.')
vrIpMcastFwdOifIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 10, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdOifIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifIfIndex.setDescription('This attribute indicates the ifIndex value of this outgoing interface entry.')
vrIpMcastFwdOifProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("dvmrp", 4), ("mospf", 5), ("pimSparseDense", 6), ("cbt", 7), ("pimSparse", 8), ("pimDense", 9), ("igmponly", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdOifProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifProtocol.setDescription('This attribute indicates the multicast routing protocol via which this multicast forwarding outinterface entry was learned.')
vrIpMcastFwdOifAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdOifAge.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifAge.setDescription('This attribute indicates the number of seconds since this route was last updated')
vrIpMcastFwdOifOutProtocolPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 6, 2, 10, 1, 702), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastFwdOifOutProtocolPortName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastFwdOifOutProtocolPortName.setDescription('This attribute indicates the name of the protocol port by which the next hop of this route should be reached.')
vrIpMcastCacheStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8))
vrIpMcastCacheStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 1), )
if mibBuilder.loadTexts: vrIpMcastCacheStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpMcastCacheStats components.')
vrIpMcastCacheStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastCacheStatsIndex"))
if mibBuilder.loadTexts: vrIpMcastCacheStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastCacheStats component.')
vrIpMcastCacheStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastCacheStats components. These components cannot be added nor deleted.')
vrIpMcastCacheStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastCacheStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsStorageType.setDescription('This variable represents the storage type value for the vrIpMcastCacheStats tables.')
vrIpMcastCacheStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: vrIpMcastCacheStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsIndex.setDescription('This variable represents the index for the vrIpMcastCacheStats tables.')
vrIpMcastCacheStatsStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 10), )
if mibBuilder.loadTexts: vrIpMcastCacheStatsStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsStateTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpMcastCacheStatsStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastCacheStatsIndex"))
if mibBuilder.loadTexts: vrIpMcastCacheStatsStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsStateEntry.setDescription('An entry in the vrIpMcastCacheStatsStateTable.')
vrIpMcastCacheStatsAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpMcastCacheStatsOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpMcastCacheStatsUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpMcastCacheStatsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 11), )
if mibBuilder.loadTexts: vrIpMcastCacheStatsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the operational attributes of an Ip cache table.')
vrIpMcastCacheStatsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastCacheStatsIndex"))
if mibBuilder.loadTexts: vrIpMcastCacheStatsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsOperEntry.setDescription('An entry in the vrIpMcastCacheStatsOperTable.')
vrIpMcastCacheStatsEntriesFree = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsEntriesFree.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsEntriesFree.setDescription('This attribute is indicative of the number of free Ip cache table entries. A consistently high value for this attribute indicates that there is a resource surplus of the memory requirements for cache table. This surplus could be utilized elsewhere if needed by adjusting the cacheTableMaxEntries under the Ip component.')
vrIpMcastCacheStatsTotalLookups = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsTotalLookups.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsTotalLookups.setDescription('This attribute indicates the total number of local cache lookups. It wraps around to 0 when it reaches the maximum value of 4294967295.')
vrIpMcastCacheStatsLookupMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsLookupMisses.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsLookupMisses.setDescription('This attribute indicates the total number of local cache lookup misses. It wraps around to 0 when it reaches the maximum value of 4294967295.')
vrIpMcastCacheStatsCacheTableMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 8, 11, 1, 395), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastCacheStatsCacheTableMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastCacheStatsCacheTableMaxEntries.setDescription('This attribute indicates the current maximum number of entries that can exist in the IP local cache table on each LP.')
vrIpMcastPimSm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9))
vrIpMcastPimSmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 1), )
if mibBuilder.loadTexts: vrIpMcastPimSmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastPimSm components.')
vrIpMcastPimSmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPimSm component.')
vrIpMcastPimSmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPimSm components. These components can be added and deleted.')
vrIpMcastPimSmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPimSmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPimSm tables.')
vrIpMcastPimSmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpMcastPimSmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmIndex.setDescription('This variable represents the index for the vrIpMcastPimSm tables.')
vrIpMcastPimSmAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 10), )
if mibBuilder.loadTexts: vrIpMcastPimSmAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
vrIpMcastPimSmAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmAdminControlEntry.setDescription('An entry in the vrIpMcastPimSmAdminControlTable.')
vrIpMcastPimSmSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
vrIpMcastPimSmStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 13), )
if mibBuilder.loadTexts: vrIpMcastPimSmStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
vrIpMcastPimSmStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmStateEntry.setDescription('An entry in the vrIpMcastPimSmStateTable.')
vrIpMcastPimSmAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
vrIpMcastPimSmOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
vrIpMcastPimSmUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
vrIpMcastPimSmOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 14), )
if mibBuilder.loadTexts: vrIpMcastPimSmOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
vrIpMcastPimSmOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmOperStatusEntry.setDescription('An entry in the vrIpMcastPimSmOperStatusTable.')
vrIpMcastPimSmSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
vrIpMcastPimSmDomain = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2))
vrIpMcastPimSmDomainRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 1), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastPimSmDomain components.')
vrIpMcastPimSmDomainRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPimSmDomain component.')
vrIpMcastPimSmDomainRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPimSmDomain components. These components can be added and deleted.')
vrIpMcastPimSmDomainComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPimSmDomainStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPimSmDomain tables.')
vrIpMcastPimSmDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainIndex.setDescription('This variable represents the index for the vrIpMcastPimSmDomain tables.')
vrIpMcastPimSmDomainProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 10), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainProvTable.setDescription('This group contains the provisionable attributes of the Domain component under the PimSm component.')
vrIpMcastPimSmDomainProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainProvEntry.setDescription('An entry in the vrIpMcastPimSmDomainProvTable.')
vrIpMcastPimSmDomainJoinPruneInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 4292967295)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainJoinPruneInterval.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainJoinPruneInterval.setDescription('This attribute specifies the frequency at which PIM Join/Prune messages are transmitted on this PIM interface.')
vrIpMcastPimSmDomainSptJoinThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainSptJoinThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainSptJoinThreshold.setDescription('The attribute specifies the threshold at which the last-hop router joins the shortest-path tree. If 0 is selected then the router immediately joins the shortest path tree upon receipt of the first data packet. If infinity is selected then the router never joins the shortest path tree. VALUES ( 1 = infinity )')
vrIpMcastPimSmDomainOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 11), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainOperTable.setDescription('This group contains the operational attributes of the Domain component under the PimSm component.')
vrIpMcastPimSmDomainOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainOperEntry.setDescription('An entry in the vrIpMcastPimSmDomainOperTable.')
vrIpMcastPimSmDomainBsrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 11, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainBsrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainBsrAddress.setDescription('This attribute indicates the IP address of the bootstrap router (BSR) for this PIM domain.')
vrIpMcastPimSmDomainBsrExpiryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 11, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainBsrExpiryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainBsrExpiryTimer.setDescription('This attribute indicates the minimum time remaining before the bootstrap router in this domain will be declared down.')
vrIpMcastPimSmDomainStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainStatsTable.setDescription('This group contains the statistics attributes of the Domain component under the PimSm component.')
vrIpMcastPimSmDomainStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainStatsEntry.setDescription('An entry in the vrIpMcastPimSmDomainStatsTable.')
vrIpMcastPimSmDomainTxBsrMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxBsrMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxBsrMsg.setDescription('This attribute counts the Bootstrap Message transmitted by the bootstrap router (BSR) for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainRxBsrMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxBsrMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxBsrMsg.setDescription('This attribute counts the Bootstrap Message received by this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainTxCRpAdvMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxCRpAdvMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxCRpAdvMsg.setDescription('This attribute counts the Candidate-RP advertisement Message transmitted by the configured CRp for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainRxCRpAdvMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxCRpAdvMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxCRpAdvMsg.setDescription('This attribute counts the Candidate-RP advertisement Message received by the bootstrap router (BSR) for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainTxHelloMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxHelloMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxHelloMsg.setDescription('This attribute counts the Hello Message transmitted from PimIf belonging to this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainRxHelloMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxHelloMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxHelloMsg.setDescription('This attribute counts the Hello Message received from pimif belonging to this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainTxRegisterMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxRegisterMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxRegisterMsg.setDescription('This attribute counts the Register Message transmitted by the Designated Router (DR) for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainRxRegisterMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxRegisterMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxRegisterMsg.setDescription('This attribute counts the Register Message received by the RP for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainTxRegisterStopMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxRegisterStopMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxRegisterStopMsg.setDescription('This attribute counts the RegisterStop Message transmitted by the RP for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainRxRegisterStopMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxRegisterStopMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxRegisterStopMsg.setDescription('This attribute counts the RegisterStop Message received by the Designated router (DR) for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainTxAssertMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxAssertMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxAssertMsg.setDescription('This attribute counts the assert Message transmitted from this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainRxAssertMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxAssertMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxAssertMsg.setDescription('This attribute counts the Assert Message received by this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainTxJPMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxJPMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainTxJPMsg.setDescription('This attribute counts the JP Message transmitted for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainRxJPMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxJPMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRxJPMsg.setDescription('This attribute counts the JP Message received by this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainDiscardBsrMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardBsrMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardBsrMsg.setDescription('This attribute counts the Bootstrap Message discarded by this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainDiscardCRpAdvMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardCRpAdvMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardCRpAdvMsg.setDescription('This attribute counts the Candidate-RP advertisement Message discarded by the bootstrap router (BSR) for this pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainDiscardHelloMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardHelloMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardHelloMsg.setDescription('This attribute counts the Hello Message discarded if it is not destined for us. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainDiscardRegisterMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardRegisterMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardRegisterMsg.setDescription('This attribute counts the Register Message discarded if we are not RP for this Pim domain. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainDiscardRegisterStopMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardRegisterStopMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardRegisterStopMsg.setDescription('This attribute counts the RegisterStop Message discarded. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainDiscardAssertMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardAssertMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardAssertMsg.setDescription('This attribute counts the Assert Message discarded if we are not expecting it. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainDiscardJPMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 12, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardJPMsg.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainDiscardJPMsg.setDescription('This attribute counts the JP Message discarded by this pim domain if it is not destined for us. This counter wraps to zero when the maximum value is exceeded.')
vrIpMcastPimSmDomainCRp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2))
vrIpMcastPimSmDomainCRpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 1), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastPimSmDomainCRp components.')
vrIpMcastPimSmDomainCRpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainCRpIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPimSmDomainCRp component.')
vrIpMcastPimSmDomainCRpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPimSmDomainCRp components. These components can be added and deleted.')
vrIpMcastPimSmDomainCRpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPimSmDomainCRpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPimSmDomainCRp tables.')
vrIpMcastPimSmDomainCRpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpIndex.setDescription('This variable represents the index for the vrIpMcastPimSmDomainCRp tables.')
vrIpMcastPimSmDomainCRpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 10), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpProvTable.setDescription('This group specifies all the attributes for component CandidateRendezvousPoint.')
vrIpMcastPimSmDomainCRpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainCRpIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpProvEntry.setDescription('An entry in the vrIpMcastPimSmDomainCRpProvTable.')
vrIpMcastPimSmDomainCRpCandidateRpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpCandidateRpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpCandidateRpAddress.setDescription('This attribute specifies a link to a logical interface component which specifies an IP address to be used as the local identifier in CRP advertisement messages.')
vrIpMcastPimSmDomainCRpCandidateRpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpCandidateRpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpCandidateRpPreference.setDescription('This attribute specifies the preference value to be used in CRP advertisement messages. Lower values indicate higher preference.')
vrIpMcastPimSmDomainCRpGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 2))
vrIpMcastPimSmDomainCRpGrpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 2, 1), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastPimSmDomainCRpGrp components.')
vrIpMcastPimSmDomainCRpGrpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainCRpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainCRpGrpGrpAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainCRpGrpGrpMaskIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPimSmDomainCRpGrp component.')
vrIpMcastPimSmDomainCRpGrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPimSmDomainCRpGrp components. These components can be added and deleted.')
vrIpMcastPimSmDomainCRpGrpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPimSmDomainCRpGrpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPimSmDomainCRpGrp tables.')
vrIpMcastPimSmDomainCRpGrpGrpAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpGrpAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpGrpAddressIndex.setDescription('This variable represents an index for the vrIpMcastPimSmDomainCRpGrp tables.')
vrIpMcastPimSmDomainCRpGrpGrpMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 2, 2, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpGrpMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCRpGrpGrpMaskIndex.setDescription('This variable represents an index for the vrIpMcastPimSmDomainCRpGrp tables.')
vrIpMcastPimSmDomainRpSet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3))
vrIpMcastPimSmDomainRpSetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 1), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpMcastPimSmDomainRpSet components.')
vrIpMcastPimSmDomainRpSetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainRpSetGrpAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainRpSetGrpMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainRpSetRpAddressIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPimSmDomainRpSet component.')
vrIpMcastPimSmDomainRpSetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPimSmDomainRpSet components. These components cannot be added nor deleted.')
vrIpMcastPimSmDomainRpSetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPimSmDomainRpSetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPimSmDomainRpSet tables.')
vrIpMcastPimSmDomainRpSetGrpAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetGrpAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetGrpAddressIndex.setDescription('This variable represents an index for the vrIpMcastPimSmDomainRpSet tables.')
vrIpMcastPimSmDomainRpSetGrpMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetGrpMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetGrpMaskIndex.setDescription('This variable represents an index for the vrIpMcastPimSmDomainRpSet tables.')
vrIpMcastPimSmDomainRpSetRpAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRpAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRpAddressIndex.setDescription('This variable represents an index for the vrIpMcastPimSmDomainRpSet tables.')
vrIpMcastPimSmDomainRpSetOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 11), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes for a candidate RP.')
vrIpMcastPimSmDomainRpSetOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainRpSetGrpAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainRpSetGrpMaskIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainRpSetRpAddressIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetOperEntry.setDescription('An entry in the vrIpMcastPimSmDomainRpSetOperTable.')
vrIpMcastPimSmDomainRpSetRpSetHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRpSetHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRpSetHoldTime.setDescription('This attribute indicates the holdtime of a Candidate-RP. If the local router is not the BSR, this value is 0.')
vrIpMcastPimSmDomainRpSetRpSetExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 11, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRpSetExpiryTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRpSetExpiryTime.setDescription('This attribute indicates the minimum time remaining before the Candidate-RP will be declared down. If the local router is not the BSR, this value is 0.')
vrIpMcastPimSmDomainRpSetRpSetPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRpSetPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainRpSetRpSetPriority.setDescription('This attribute indicates the priority advertised by BSR for this CRP. If the local router is the BSR, this value specifies the priority advertised by CRP.')
vrIpMcastPimSmDomainCBsr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4))
vrIpMcastPimSmDomainCBsrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 1), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrRowStatusTable.setDescription('This entry controls the addition and deletion of vrIpMcastPimSmDomainCBsr components.')
vrIpMcastPimSmDomainCBsrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainCBsrIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPimSmDomainCBsr component.')
vrIpMcastPimSmDomainCBsrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPimSmDomainCBsr components. These components can be added and deleted.')
vrIpMcastPimSmDomainCBsrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPimSmDomainCBsrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPimSmDomainCBsr tables.')
vrIpMcastPimSmDomainCBsrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrIndex.setDescription('This variable represents the index for the vrIpMcastPimSmDomainCBsr tables.')
vrIpMcastPimSmDomainCBsrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 10), )
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrProvTable.setDescription('This group contains all the provisionable attributes for component CandidateBootstrapRouter.')
vrIpMcastPimSmDomainCBsrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimSmDomainCBsrIndex"))
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrProvEntry.setDescription('An entry in the vrIpMcastPimSmDomainCBsrProvTable.')
vrIpMcastPimSmDomainCBsrCandidateBsrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrCandidateBsrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrCandidateBsrAddress.setDescription('This attribute specifies a link to a logical interface component which specifies an IP address to use as the local system identifier in bootstrap messages.')
vrIpMcastPimSmDomainCBsrCandidateBsrPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 9, 2, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrCandidateBsrPreference.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimSmDomainCBsrCandidateBsrPreference.setDescription('This attribute specifies the preference value used in bootstrap messages. Higher values indicate higher priority.')
vrIpMcastPimNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10))
vrIpMcastPimNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 1), )
if mibBuilder.loadTexts: vrIpMcastPimNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of vrIpMcastPimNbr components.')
vrIpMcastPimNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimNbrNbrAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimNbrDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastPimNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrRowStatusEntry.setDescription('A single entry in the table represents a single vrIpMcastPimNbr component.')
vrIpMcastPimNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of vrIpMcastPimNbr components. These components cannot be added nor deleted.')
vrIpMcastPimNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
vrIpMcastPimNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrStorageType.setDescription('This variable represents the storage type value for the vrIpMcastPimNbr tables.')
vrIpMcastPimNbrNbrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: vrIpMcastPimNbrNbrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrNbrAddressIndex.setDescription('This variable represents an index for the vrIpMcastPimNbr tables.')
vrIpMcastPimNbrDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: vrIpMcastPimNbrDomainIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrDomainIndex.setDescription('This variable represents an index for the vrIpMcastPimNbr tables.')
vrIpMcastPimNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 10), )
if mibBuilder.loadTexts: vrIpMcastPimNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of the PimNeighborEntry componnent.')
vrIpMcastPimNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-VirtualRouterMIB", "vrIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimNbrNbrAddressIndex"), (0, "Nortel-Magellan-Passport-IpMIB", "vrIpMcastPimNbrDomainIndex"))
if mibBuilder.loadTexts: vrIpMcastPimNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrOperEntry.setDescription('An entry in the vrIpMcastPimNbrOperTable.')
vrIpMcastPimNbrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 10, 1, 1), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimNbrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrIfIndex.setDescription('This attribute indicates the value of ifIndex for the interface used to reach this PIM neighbor.')
vrIpMcastPimNbrUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 10, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimNbrUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrUpTime.setDescription('This attribute indicates the time since this PIM neighbor became a neighbor of this local router.')
vrIpMcastPimNbrExpiryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 100, 6, 26, 10, 10, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrIpMcastPimNbrExpiryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: vrIpMcastPimNbrExpiryTimer.setDescription('This attribute indicates the minimum time remaining before this PIM neighbor will be aged out.')
ipGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27, 1))
ipGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27, 1, 5))
ipGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27, 1, 5, 2))
ipGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27, 1, 5, 2, 2))
ipCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27, 3))
ipCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27, 3, 5))
ipCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27, 3, 5, 2))
ipCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 27, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-IpMIB", vrIpEgpNbrStorageType=vrIpEgpNbrStorageType, vrPpIpPortLogicalIfOspfIfProvEntry=vrPpIpPortLogicalIfOspfIfProvEntry, vrIpRipGenerateDiscardRoute=vrIpRipGenerateDiscardRoute, vrPpIpPortBootpPOperStatusEntry=vrPpIpPortBootpPOperStatusEntry, vrIpOspfVirtNbrRowStatusTable=vrIpOspfVirtNbrRowStatusTable, vrPpIpPortLogicalIfIgmpIfGroups=vrPpIpPortLogicalIfIgmpIfGroups, vrPpIpPortBootpPBootpLogicalInterface=vrPpIpPortBootpPBootpLogicalInterface, vrIpTcpTcpEntryOperEntry=vrIpTcpTcpEntryOperEntry, vrIpMcastCacheStatsAdminState=vrIpMcastCacheStatsAdminState, vrIpMcastPgStorageType=vrIpMcastPgStorageType, vrPpIpPortLogicalIfOspfIfNbrProvEntry=vrPpIpPortLogicalIfOspfIfNbrProvEntry, vrPpIpPortLogicalIfOspfIfNbrRowStatusTable=vrPpIpPortLogicalIfOspfIfNbrRowStatusTable, vrIpOspfExportNetListProvTable=vrIpOspfExportNetListProvTable, vrPpIpPortLogicalIfIgmpIfQueryInterval=vrPpIpPortLogicalIfIgmpIfQueryInterval, vrIpMcastPimSmAdminControlEntry=vrIpMcastPimSmAdminControlEntry, vrPpIpPortOperStatusEntry=vrPpIpPortOperStatusEntry, vrIpEgpImportNet=vrIpEgpImportNet, vrPpIpPortLogicalIfIgmpIfOperEntry=vrPpIpPortLogicalIfIgmpIfOperEntry, vrPpIpPortLogicalIfOspfIfNbrEvents=vrPpIpPortLogicalIfOspfIfNbrEvents, vrIpMcastIgmpGcUpTime=vrIpMcastIgmpGcUpTime, vrIpOspfVirtNbrStorageType=vrIpOspfVirtNbrStorageType, vrIpEgpSnmpOperStatus=vrIpEgpSnmpOperStatus, vrIpIcmpInSrcQuenchs=vrIpIcmpInSrcQuenchs, vrIpMcastPimSmDomainCRpGrpRowStatusEntry=vrIpMcastPimSmDomainCRpGrpRowStatusEntry, vrIpUdpIndex=vrIpUdpIndex, vrIpMcastOperStatusEntry=vrIpMcastOperStatusEntry, vrIpRipStateEntry=vrIpRipStateEntry, vrIpEgpExportRowStatusTable=vrIpEgpExportRowStatusTable, vrIpMcastPimSmDomainRpSetComponentName=vrIpMcastPimSmDomainRpSetComponentName, vrIpArpProvEntry=vrIpArpProvEntry, vrIpMcastFwdSrcAddrIndex=vrIpMcastFwdSrcAddrIndex, vrPpIpPortLogicalIfOspfIfRtrPriority=vrPpIpPortLogicalIfOspfIfRtrPriority, vrIpOspfExportComponentName=vrIpOspfExportComponentName, vrIpArpRowStatusEntry=vrIpArpRowStatusEntry, vrIpMcastPimSmDomainCRpGrp=vrIpMcastPimSmDomainCRpGrp, vrIpRipExportRipInterface=vrIpRipExportRipInterface, vrIpEgpNbrStateUps=vrIpEgpNbrStateUps, vrIpArpDynHostEncapsulationType=vrIpArpDynHostEncapsulationType, vrIpOspfLsdbRowStatusTable=vrIpOspfLsdbRowStatusTable, vrIpRelayBCIndex=vrIpRelayBCIndex, vrPpIpPortLogicalIfPimSmIfRowStatusTable=vrPpIpPortLogicalIfPimSmIfRowStatusTable, vrIpRdbRowStatusTable=vrIpRdbRowStatusTable, vrIpRipImportUsageFlag=vrIpRipImportUsageFlag, vrIpForwDatagrams=vrIpForwDatagrams, vrIpOspfVirtIf=vrIpOspfVirtIf, vrIpMcastPimSmDomainRpSetGrpAddressIndex=vrIpMcastPimSmDomainRpSetGrpAddressIndex, vrIpIcmpOutDestUnreachs=vrIpIcmpOutDestUnreachs, vrIpMcastPgRowStatus=vrIpMcastPgRowStatus, vrIpFwdRowStatusEntry=vrIpFwdRowStatusEntry, vrIpBootpPpEOutRequests=vrIpBootpPpEOutRequests, vrIpArpAutoRefreshTimeout=vrIpArpAutoRefreshTimeout, vrIpMcastPimNbrUpTime=vrIpMcastPimNbrUpTime, vrIpMcastPimSmDomainRpSetRpSetExpiryTime=vrIpMcastPimSmDomainRpSetRpSetExpiryTime, vrIpOspfVirtIfHelloInterval=vrIpOspfVirtIfHelloInterval, vrIpCacheLookupMisses=vrIpCacheLookupMisses, vrIpRipImportNetStorageType=vrIpRipImportNetStorageType, vrIpStaticComponentName=vrIpStaticComponentName, vrIpMcastPimSmDomainStorageType=vrIpMcastPimSmDomainStorageType, vrIpNsApplyIpAddress2=vrIpNsApplyIpAddress2, vrIpOspfVirtNbrExchangeStatus=vrIpOspfVirtNbrExchangeStatus, vrPpIpPortDirectedBroadcast=vrPpIpPortDirectedBroadcast, vrIpMcastIgmpAdminControlEntry=vrIpMcastIgmpAdminControlEntry, vrIpOspfVirtNbrEvents=vrIpOspfVirtNbrEvents, vrIpNsApplyIndex=vrIpNsApplyIndex, vrIpUdpListenEntry=vrIpUdpListenEntry, vrIpIcmpInTimestampReps=vrIpIcmpInTimestampReps, vrIpNsProvTable=vrIpNsProvTable, vrIpMcastPimSmDomainDiscardHelloMsg=vrIpMcastPimSmDomainDiscardHelloMsg, vrIpEgpExportNetRowStatusEntry=vrIpEgpExportNetRowStatusEntry, vrIpArpHostRowStatusEntry=vrIpArpHostRowStatusEntry, vrIpMcastSnmpOperStatus=vrIpMcastSnmpOperStatus, vrIpArpAutoRefresh=vrIpArpAutoRefresh, vrPpIpPortAdminControlEntry=vrPpIpPortAdminControlEntry, vrIpIfNcHardwareAddress=vrIpIfNcHardwareAddress, vrIpRipRipUpdate=vrIpRipRipUpdate, vrIpOspfAreaOperEntry=vrIpOspfAreaOperEntry, vrIpArpHostRowStatus=vrIpArpHostRowStatus, vrPpIpPortLogicalIfRipIfDefaultRouteMetric=vrPpIpPortLogicalIfRipIfDefaultRouteMetric, vrIpMcastPgGrpGAddrIndex=vrIpMcastPgGrpGAddrIndex, vrPpIpPortLogicalIfRipIfAcceptDefault=vrPpIpPortLogicalIfRipIfAcceptDefault, ipCapabilitiesBE01=ipCapabilitiesBE01, vrIpRipExport=vrIpRipExport, vrIpMcastStaticRouteRowStatusTable=vrIpMcastStaticRouteRowStatusTable, vrIpRipMigrateRip=vrIpRipMigrateRip, vrPpIpPortLogicalIfIgmpIfComponentName=vrPpIpPortLogicalIfIgmpIfComponentName, vrIpRdbDestMaskIndex=vrIpRdbDestMaskIndex, vrIpMcastStaticUsageState=vrIpMcastStaticUsageState, vrPpIpPortLogicalIfOspfIfNbrRtrId=vrPpIpPortLogicalIfOspfIfNbrRtrId, vrIpMcastPimSmDomainSptJoinThreshold=vrIpMcastPimSmDomainSptJoinThreshold, vrPpIpPortProxyArpStatus=vrPpIpPortProxyArpStatus, vrIpEgpNbrOutMsgs=vrIpEgpNbrOutMsgs, vrIpBootpSnmpOperStatus=vrIpBootpSnmpOperStatus, vrPpIpPortBootpPAddrValue=vrPpIpPortBootpPAddrValue, vrIpMcastIgmpGc=vrIpMcastIgmpGc, vrIpMcastPimSmDomainBsrAddress=vrIpMcastPimSmDomainBsrAddress, vrIpFwdProtocol=vrIpFwdProtocol, vrIpRipExportProvTable=vrIpRipExportProvTable, vrIpStaticDiscardRowStatusTable=vrIpStaticDiscardRowStatusTable, vrIpMcastPimSmDomainRpSetRpAddressIndex=vrIpMcastPimSmDomainRpSetRpAddressIndex, vrIpOspfExportTag=vrIpOspfExportTag, vrIpMcastPimSmRowStatusTable=vrIpMcastPimSmRowStatusTable, vrIpRipImportNetIpMask=vrIpRipImportNetIpMask, vrIpOspfOperTable=vrIpOspfOperTable, vrIpArpHostOperMaxTxUnit=vrIpArpHostOperMaxTxUnit, vrPpIpPortLogicalIfOspfIfNbrPermanance=vrPpIpPortLogicalIfOspfIfNbrPermanance, vrIpCacheOperEntry=vrIpCacheOperEntry, vrIpBootpPpEOutReplies=vrIpBootpPpEOutReplies, vrIpIcmpRowStatusTable=vrIpIcmpRowStatusTable, vrIpMcastPimSmDomainCBsrRowStatus=vrIpMcastPimSmDomainCBsrRowStatus, vrPpIpPortLogicalIfRipIfSilentFlag=vrPpIpPortLogicalIfRipIfSilentFlag, vrIpEgpExportNetIndex=vrIpEgpExportNetIndex, vrIpMcastPimSmUsageState=vrIpMcastPimSmUsageState, vrIpMcastCacheStatsStateTable=vrIpMcastCacheStatsStateTable, vrPpIpPortBootpPIndex=vrPpIpPortBootpPIndex, vrIpMcastPimSmDomainTxHelloMsg=vrIpMcastPimSmDomainTxHelloMsg, vrIpOspfVirtNbrComponentName=vrIpOspfVirtNbrComponentName, vrIpOperStatusEntry=vrIpOperStatusEntry, vrIpMcastPimNbrComponentName=vrIpMcastPimNbrComponentName, vrPpIpPortMcastDomain=vrPpIpPortMcastDomain, vrIpRipRipTimeout=vrIpRipRipTimeout, vrIpArpHostComponentName=vrIpArpHostComponentName, vrIpMcastDomainIndex=vrIpMcastDomainIndex, vrIpIcmpInDestUnreachs=vrIpIcmpInDestUnreachs, vrIpTcpTcpEntryRowStatusEntry=vrIpTcpTcpEntryRowStatusEntry, vrIpMcastPimNbrRowStatusTable=vrIpMcastPimNbrRowStatusTable, vrIpOspfNbrPriority=vrIpOspfNbrPriority, vrPpIpPortLogicalIfComponentName=vrPpIpPortLogicalIfComponentName, vrIpOspfExtLsdbOperEntry=vrIpOspfExtLsdbOperEntry, vrIpMcastIgmpOperStatusEntry=vrIpMcastIgmpOperStatusEntry, vrIpOspfLsdbLsIdIndex=vrIpOspfLsdbLsIdIndex, vrIpMcastPimNbrOperEntry=vrIpMcastPimNbrOperEntry, vrIpRipImportNetComponentName=vrIpRipImportNetComponentName, vrIpBootpPpEStatsEntry=vrIpBootpPpEStatsEntry, vrIpRipRfc1058MetricUsage=vrIpRipRfc1058MetricUsage, vrIpOspfLsdb=vrIpOspfLsdb, vrPpIpPortBootpP=vrPpIpPortBootpP, vrIpFwdAge=vrIpFwdAge, vrPpIpPortLogicalIfIgmpIfStorageType=vrPpIpPortLogicalIfIgmpIfStorageType, vrIpRipAdminControlEntry=vrIpRipAdminControlEntry, vrIpRelayBCProvTable=vrIpRelayBCProvTable, vrIpTunnelSepLinkToProtocolPort=vrIpTunnelSepLinkToProtocolPort, vrPpIpPortAssignedQos=vrPpIpPortAssignedQos, vrPpIpPortBootpPAdminControlEntry=vrPpIpPortBootpPAdminControlEntry, vrPpIpPortLogicalIfOspfIfRetransInterval=vrPpIpPortLogicalIfOspfIfRetransInterval, vrIpCtsIndex=vrIpCtsIndex, vrIpMcastFwdOifIfIndex=vrIpMcastFwdOifIfIndex, vrIpMcastCtsIndex=vrIpMcastCtsIndex, vrIpBootpPpEStatus=vrIpBootpPpEStatus, vrIpIcmp=vrIpIcmp, vrIpEgpNbrDefaultRouteMetric=vrIpEgpNbrDefaultRouteMetric, vrIpArpDynHostOperEntry=vrIpArpDynHostOperEntry, vrIpOspfNbr=vrIpOspfNbr, vrIpArpHostHostAddressIndex=vrIpArpHostHostAddressIndex, vrIpMcastPgAction=vrIpMcastPgAction, vrIpMcastDomainProtocolActive=vrIpMcastDomainProtocolActive, vrPpIpPortLogicalIfLinkToMulStaticGpValue=vrPpIpPortLogicalIfLinkToMulStaticGpValue, vrIpIcmpOutRtrAdvs=vrIpIcmpOutRtrAdvs, vrPpIpPortLogicalIfOspfIfHelloInterval=vrPpIpPortLogicalIfOspfIfHelloInterval, vrIpArpRowStatusTable=vrIpArpRowStatusTable, vrIpOspfUsageState=vrIpOspfUsageState, vrIpOspfExportNetListStorageType=vrIpOspfExportNetListStorageType, vrPpIpPortBootpPSnmpOperStatus=vrPpIpPortBootpPSnmpOperStatus, vrIpArpStorageType=vrIpArpStorageType, vrIpCacheIndex=vrIpCacheIndex, vrIpOspfNbrComponentName=vrIpOspfNbrComponentName, vrPpIpPortLogicalIfOspfIfEvents=vrPpIpPortLogicalIfOspfIfEvents, vrIpMcastCacheStatsTotalLookups=vrIpMcastCacheStatsTotalLookups, vrIpOspfNbrOptions=vrIpOspfNbrOptions, vrIpMcastSnmpAdminStatus=vrIpMcastSnmpAdminStatus, vrIpEgpExportRipInterface=vrIpEgpExportRipInterface, vrIpMcastIgmpGcOperEntry=vrIpMcastIgmpGcOperEntry, vrPpIpPortOperMulticastStatus=vrPpIpPortOperMulticastStatus, vrIpArpDynHostPermanentVirtualCircuitNumber=vrIpArpDynHostPermanentVirtualCircuitNumber, vrPpIpPortLogicalIfOspfIfNbrRowStatusEntry=vrPpIpPortLogicalIfOspfIfNbrRowStatusEntry, vrIpOspfMulticastForward=vrIpOspfMulticastForward, vrIpOspfAggregateAggregateNetIndex=vrIpOspfAggregateAggregateNetIndex, vrIpOspfAggregateRowStatusEntry=vrIpOspfAggregateRowStatusEntry, vrPpIpPortLogicalIfOspfIfTOSRowStatusEntry=vrPpIpPortLogicalIfOspfIfTOSRowStatusEntry, vrIpMcastPimSmIndex=vrIpMcastPimSmIndex, vrIpTunnelSepIndex=vrIpTunnelSepIndex, vrIpOperationalState=vrIpOperationalState, vrIpStaticRouteNhRowStatus=vrIpStaticRouteNhRowStatus, vrIpOspfLsdbOperEntry=vrIpOspfLsdbOperEntry, vrIpMcastStaticRouteGAddrIndex=vrIpMcastStaticRouteGAddrIndex, vrIpEgpExportRowStatusEntry=vrIpEgpExportRowStatusEntry, vrIpEgpExportProtocol=vrIpEgpExportProtocol, vrPpIpPortNsRowStatus=vrPpIpPortNsRowStatus, vrIpDefaultTtl=vrIpDefaultTtl, vrIpIcmpOutEchoReps=vrIpIcmpOutEchoReps, vrIpMcastPimSmDomainStatsEntry=vrIpMcastPimSmDomainStatsEntry, vrIpMcastStorageType=vrIpMcastStorageType, vrPpIpPortBootpPInReplyErrors=vrPpIpPortBootpPInReplyErrors, vrIpOspfExtLsdb=vrIpOspfExtLsdb, vrIpEgpImportUsageFlag=vrIpEgpImportUsageFlag, vrIpMcastPimSmDomainCBsrProvEntry=vrIpMcastPimSmDomainCBsrProvEntry, vrPpIpPortLogicalIfOspfIfMetricEntry=vrPpIpPortLogicalIfOspfIfMetricEntry, vrIpOspfStateEntry=vrIpOspfStateEntry, vrPpIpPortLogicalIfOspfIfTOSRowStatusTable=vrPpIpPortLogicalIfOspfIfTOSRowStatusTable, vrIpMcastPimNbrOperTable=vrIpMcastPimNbrOperTable, vrIpOspfLsdbAge=vrIpOspfLsdbAge, vrIpOspfLsdbStorageType=vrIpOspfLsdbStorageType, vrIpMcastStaticRouteStorageType=vrIpMcastStaticRouteStorageType, vrIpOspfOperationalState=vrIpOspfOperationalState, vrPpIpPortLogicalIfIgmpIfQuerier=vrPpIpPortLogicalIfIgmpIfQuerier, vrIpMcastFwdDomainIndex=vrIpMcastFwdDomainIndex, vrIpStaticRouteDestAddressIndex=vrIpStaticRouteDestAddressIndex, vrIpMcastPimSmDomainRxRegisterStopMsg=vrIpMcastPimSmDomainRxRegisterStopMsg, vrIpMcastPimSmDomainTxBsrMsg=vrIpMcastPimSmDomainTxBsrMsg, vrPpIpPortLogicalIf=vrPpIpPortLogicalIf, vrIpNsApplyComponentName=vrIpNsApplyComponentName, vrIpNsRowStatusEntry=vrIpNsRowStatusEntry, vrPpIpPortLogicalIfOspfIfPollInterval=vrPpIpPortLogicalIfOspfIfPollInterval, vrIpTcp=vrIpTcp, vrIpMcastPimSmDomainCRp=vrIpMcastPimSmDomainCRp, vrIpEgpExportInEgpAsId=vrIpEgpExportInEgpAsId, vrPpIpPortLogicalIfRipIfMetric=vrPpIpPortLogicalIfRipIfMetric, vrIpOspfHostProvTable=vrIpOspfHostProvTable, vrIpRipImport=vrIpRipImport, vrIpUdpStorageType=vrIpUdpStorageType, vrIpEgpOutErrorMsgs=vrIpEgpOutErrorMsgs, vrIpStaticRouteNhStorageType=vrIpStaticRouteNhStorageType, vrIpOspfVirtIfOperTable=vrIpOspfVirtIfOperTable, vrIpStatic=vrIpStatic, vrPpIpPortLogicalIfPimSmIfStorageType=vrPpIpPortLogicalIfPimSmIfStorageType, vrIpOspfVirtIfProvTable=vrIpOspfVirtIfProvTable, vrIpEgpNbrNeighborAddressIndex=vrIpEgpNbrNeighborAddressIndex, vrIpRipImportProvTable=vrIpRipImportProvTable, vrIpTcpInErrs=vrIpTcpInErrs, vrIpEgpExportNetIpAddress=vrIpEgpExportNetIpAddress, vrIpStaticDiscardDestMaskIndex=vrIpStaticDiscardDestMaskIndex, vrIpEgpNbrComponentName=vrIpEgpNbrComponentName, vrIpRipProvEntry=vrIpRipProvEntry, vrIpTcpStatsTable=vrIpTcpStatsTable, vrIpTcpCurrEstab=vrIpTcpCurrEstab, vrIpUdpInDatagrams=vrIpUdpInDatagrams, vrIpRowStatus=vrIpRowStatus, ipCapabilities=ipCapabilities, vrIpMcastPimSmDomainCBsrCandidateBsrPreference=vrIpMcastPimSmDomainCBsrCandidateBsrPreference, vrIpOspfVirtIfRowStatusTable=vrIpOspfVirtIfRowStatusTable, vrIpStaticRouteRowStatusTable=vrIpStaticRouteRowStatusTable, vrIpOspfExportEgpAsId=vrIpOspfExportEgpAsId, vrIpIfOperTable=vrIpIfOperTable, vrIpIcmpOutEchos=vrIpIcmpOutEchos, vrIpOspfExternLsaCount=vrIpOspfExternLsaCount, vrIpArpDynHostOperTable=vrIpArpDynHostOperTable, vrIpMcastDomainRowStatusTable=vrIpMcastDomainRowStatusTable, vrIpRipExportNetStorageType=vrIpRipExportNetStorageType, vrIpOspfExportNetListComponentName=vrIpOspfExportNetListComponentName, vrIpMcastCacheStatsRowStatus=vrIpMcastCacheStatsRowStatus, vrIpUdpListenEntryStorageType=vrIpUdpListenEntryStorageType, vrIpInReceives=vrIpInReceives, vrIpFwdOperTable=vrIpFwdOperTable, vrIpOperStatusTable=vrIpOperStatusTable, vrIpArpDynHostComponentName=vrIpArpDynHostComponentName)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-IpMIB", vrIpRipImportStorageType=vrIpRipImportStorageType, vrIpMcastPimSmDomainRowStatusTable=vrIpMcastPimSmDomainRowStatusTable, vrIpIcmpInErrors=vrIpIcmpInErrors, vrIpIfInterfaceMask=vrIpIfInterfaceMask, vrIpMcastAdminState=vrIpMcastAdminState, vrIpMcastPimSmDomainDiscardBsrMsg=vrIpMcastPimSmDomainDiscardBsrMsg, vrIpMcastPimSmDomainCBsrRowStatusTable=vrIpMcastPimSmDomainCBsrRowStatusTable, vrIpUdpListenEntryRowStatusTable=vrIpUdpListenEntryRowStatusTable, vrIpOspfVirtNbrRowStatusEntry=vrIpOspfVirtNbrRowStatusEntry, vrIpBootpSnmpAdminStatus=vrIpBootpSnmpAdminStatus, vrIpMcastIgmpSnmpOperStatus=vrIpMcastIgmpSnmpOperStatus, vrPpIpPortBootpPInReplies=vrPpIpPortBootpPInReplies, vrIpEgpNbrState=vrIpEgpNbrState, vrIpRipExportNetRowStatusTable=vrIpRipExportNetRowStatusTable, vrPpIpPortRelayBcOperTable=vrPpIpPortRelayBcOperTable, vrIpRipStateTable=vrIpRipStateTable, vrIpOspfAggregateAggregateMaskIndex=vrIpOspfAggregateAggregateMaskIndex, vrIpMcastOperStatusTable=vrIpMcastOperStatusTable, vrIpMcastPimSmDomainCBsr=vrIpMcastPimSmDomainCBsr, vrPpIpPortLogicalIfOspfIfOperEntry=vrPpIpPortLogicalIfOspfIfOperEntry, vrIpOspfVirtNbrOperEntry=vrIpOspfVirtNbrOperEntry, vrIpMcastFwdRowStatusEntry=vrIpMcastFwdRowStatusEntry, vrIpNsLastFilter=vrIpNsLastFilter, vrIpEgpImportNetRowStatusTable=vrIpEgpImportNetRowStatusTable, vrIpTunnelIndex=vrIpTunnelIndex, vrIpRipExportNetIpAddress=vrIpRipExportNetIpAddress, vrIpMcastIgmpGcRowStatusEntry=vrIpMcastIgmpGcRowStatusEntry, vrPpIpPortLanModel=vrPpIpPortLanModel, vrIpUdpRowStatus=vrIpUdpRowStatus, vrIpMcastIgmpOperStatusTable=vrIpMcastIgmpOperStatusTable, vrIpOspfExtLsdbSequence=vrIpOspfExtLsdbSequence, vrPpIpPortMulticastStatus=vrPpIpPortMulticastStatus, vrIpBootpPpERowStatusEntry=vrIpBootpPpERowStatusEntry, vrIpRdbOperTable=vrIpRdbOperTable, vrIpRipRowStatusEntry=vrIpRipRowStatusEntry, vrIpOspfAreaProvTable=vrIpOspfAreaProvTable, vrIpOspfStubAdvertiseDefault=vrIpOspfStubAdvertiseDefault, vrIpUdpRowStatusTable=vrIpUdpRowStatusTable, vrPpIpPortLogicalIfRipIfIfBadPacketRcv=vrPpIpPortLogicalIfRipIfIfBadPacketRcv, vrIpArpProvTable=vrIpArpProvTable, vrIpFwdNextHopAs=vrIpFwdNextHopAs, vrIpNs=vrIpNs, vrPpIpPortLogicalIfOspfIfTOSStorageType=vrPpIpPortLogicalIfOspfIfTOSStorageType, vrIpArpHostProvEntry=vrIpArpHostProvEntry, vrIpEgpDefaultPollInterval=vrIpEgpDefaultPollInterval, vrIpOspfExportRipNeighbor=vrIpOspfExportRipNeighbor, vrIpRelayBCComponentName=vrIpRelayBCComponentName, vrIpMcastDomainRowStatusEntry=vrIpMcastDomainRowStatusEntry, vrIpSnmpAdminStatus=vrIpSnmpAdminStatus, vrPpIpPortLogicalIfLinkToMulStaticGpEntry=vrPpIpPortLogicalIfLinkToMulStaticGpEntry, vrIpNsApplyRowStatusTable=vrIpNsApplyRowStatusTable, vrIpTcpTcpEntryRemoteAddressIndex=vrIpTcpTcpEntryRemoteAddressIndex, vrIpMcastStaticRouteOifsTable=vrIpMcastStaticRouteOifsTable, vrIpEgpNbrOutErrorMsgs=vrIpEgpNbrOutErrorMsgs, vrIpTcpRToMin=vrIpTcpRToMin, vrIpArpHostRowStatusTable=vrIpArpHostRowStatusTable, vrPpIpPortBootpPStorageType=vrPpIpPortBootpPStorageType, vrIpOspfNbrRtrId=vrIpOspfNbrRtrId, vrIpCacheRowStatus=vrIpCacheRowStatus, vrIpOspfExportNetListIndex=vrIpOspfExportNetListIndex, vrPpIpPortLogicalIfProvEntry=vrPpIpPortLogicalIfProvEntry, vrIpMcastPimSm=vrIpMcastPimSm, vrIpEgpExportRipNeighbor=vrIpEgpExportRipNeighbor, vrIpOspfAggregateRowStatusTable=vrIpOspfAggregateRowStatusTable, vrIpFwdMetric=vrIpFwdMetric, vrIpEgpIndex=vrIpEgpIndex, vrIpMcastPimSmDomainDiscardRegisterMsg=vrIpMcastPimSmDomainDiscardRegisterMsg, vrIpEgpRowStatus=vrIpEgpRowStatus, vrIpIcmpComponentName=vrIpIcmpComponentName, vrIpEgpStatsEntry=vrIpEgpStatsEntry, vrIpArpIndex=vrIpArpIndex, vrIpTcpActiveOpens=vrIpTcpActiveOpens, vrIpRipAdminControlTable=vrIpRipAdminControlTable, vrIpTunnelSepMpTable=vrIpTunnelSepMpTable, vrPpIpPortMcastPolicyAssignment=vrPpIpPortMcastPolicyAssignment, vrIpMcastPimSmDomainRpSetRowStatusTable=vrIpMcastPimSmDomainRpSetRowStatusTable, vrIpMcastCacheStatsIndex=vrIpMcastCacheStatsIndex, vrPpIpPortLogicalIfOspfIfRowStatusTable=vrPpIpPortLogicalIfOspfIfRowStatusTable, vrIpMcastStaticStateEntry=vrIpMcastStaticStateEntry, vrPpIpPortLogicalIfOspfIfNbrState=vrPpIpPortLogicalIfOspfIfNbrState, vrIpInDiscards=vrIpInDiscards, vrIpIcmpInAddrMaskReps=vrIpIcmpInAddrMaskReps, vrIpMcastStaticStorageType=vrIpMcastStaticStorageType, vrIpOspfAreaAreaIdIndex=vrIpOspfAreaAreaIdIndex, vrIpNsApplyRowStatus=vrIpNsApplyRowStatus, vrPpIpPortSendRedirect=vrPpIpPortSendRedirect, vrIpOspfHost=vrIpOspfHost, vrIpTcpInSegs=vrIpTcpInSegs, vrIpRipExportRowStatus=vrIpRipExportRowStatus, vrPpIpPortLogicalIfOspfIfNbrRowStatus=vrPpIpPortLogicalIfOspfIfNbrRowStatus, vrIpMcastIgmpGcLastReporter=vrIpMcastIgmpGcLastReporter, vrPpIpPortLogicalIfPimSmIfRowStatusEntry=vrPpIpPortLogicalIfPimSmIfRowStatusEntry, vrIpStaticRouteNhRowStatusEntry=vrIpStaticRouteNhRowStatusEntry, vrIpEgpImportRowStatusTable=vrIpEgpImportRowStatusTable, vrIpTunnelStateTable=vrIpTunnelStateTable, vrIpMcastPimSmDomainCRpRowStatusTable=vrIpMcastPimSmDomainCRpRowStatusTable, vrPpIpPortArpStatus=vrPpIpPortArpStatus, vrIpBootpPpEInRequests=vrIpBootpPpEInRequests, vrIpMcastCtsEntry=vrIpMcastCtsEntry, vrIpArpDynHost=vrIpArpDynHost, vrPpIpPortLogicalIfRipIfIfTriggeredUpdates=vrPpIpPortLogicalIfRipIfIfTriggeredUpdates, vrIpIfHardwareAddress=vrIpIfHardwareAddress, vrIpEgpImportProvEntry=vrIpEgpImportProvEntry, vrIpOutDiscards=vrIpOutDiscards, vrIpTcpTcpEntry=vrIpTcpTcpEntry, vrIpMcastPgIndex=vrIpMcastPgIndex, vrIpUdp=vrIpUdp, vrIpStaticRouteNhIndex=vrIpStaticRouteNhIndex, vrIpBootpComponentName=vrIpBootpComponentName, vrIpRipExportNet=vrIpRipExportNet, vrIpMcastPimSmDomainCRpRowStatusEntry=vrIpMcastPimSmDomainCRpRowStatusEntry, vrIpRdbDestAddressIndex=vrIpRdbDestAddressIndex, vrIpStaticDiscardRowStatus=vrIpStaticDiscardRowStatus, vrPpIpPortLogicalIfOspfIfRowStatusEntry=vrPpIpPortLogicalIfOspfIfRowStatusEntry, vrIpTcpTcpEntryLocalPortIndex=vrIpTcpTcpEntryLocalPortIndex, vrIpRipExportNetIpMask=vrIpRipExportNetIpMask, vrIpOspfLsdbComponentName=vrIpOspfLsdbComponentName, vrPpIpPortLogicalIfIgmpIfProvEntry=vrPpIpPortLogicalIfIgmpIfProvEntry, vrIpOspfExportExtLsaMetricType=vrIpOspfExportExtLsaMetricType, vrIpMcastStaticOperationalState=vrIpMcastStaticOperationalState, vrIpNsApplyIpAddress1=vrIpNsApplyIpAddress1, vrPpIpPortLogicalIfRipIfRowStatusEntry=vrPpIpPortLogicalIfRipIfRowStatusEntry, vrPpIpPortAllowMcastMacDest=vrPpIpPortAllowMcastMacDest, vrPpIpPortLogicalIfOspfIfAuthKey=vrPpIpPortLogicalIfOspfIfAuthKey, vrIpNsApplyStorageType=vrIpNsApplyStorageType, vrIpMcastPimSmDomainRpSet=vrIpMcastPimSmDomainRpSet, vrIpOspfRouterId=vrIpOspfRouterId, vrPpIpPortBootpPStatsEntry=vrPpIpPortBootpPStatsEntry, vrIpOspfExport=vrIpOspfExport, vrIpRelayBCPortRowStatusEntry=vrIpRelayBCPortRowStatusEntry, vrPpIpPortLogicalIfRipIfComponentName=vrPpIpPortLogicalIfRipIfComponentName, vrIpEgpExportExportMetric=vrIpEgpExportExportMetric, vrIpTcpRToAlgorithm=vrIpTcpRToAlgorithm, vrIpEgpNbrRowStatusTable=vrIpEgpNbrRowStatusTable, vrIpOspfExtLsdbAge=vrIpOspfExtLsdbAge, vrIpMcastRowStatusEntry=vrIpMcastRowStatusEntry, vrIpOspfStub=vrIpOspfStub, vrIpEgpNbrProvTable=vrIpEgpNbrProvTable, vrIpOspfExternLsaChecksumSum=vrIpOspfExternLsaChecksumSum, vrIpRipProvTable=vrIpRipProvTable, vrIpRelayBCPortRowStatusTable=vrIpRelayBCPortRowStatusTable, vrIpMcastCacheStatsStorageType=vrIpMcastCacheStatsStorageType, ipGroupBE01A=ipGroupBE01A, vrIpMcastIgmpSnmpAdminStatus=vrIpMcastIgmpSnmpAdminStatus, vrPpIpPortNsRowStatusTable=vrPpIpPortNsRowStatusTable, vrIpArpDynHostIfIndex=vrIpArpDynHostIfIndex, vrIpAdminState=vrIpAdminState, vrIpMcastFwdOifConnectionIndex=vrIpMcastFwdOifConnectionIndex, vrIpCacheComponentName=vrIpCacheComponentName, vrPpIpPortBootpPSnmpAdminStatus=vrPpIpPortBootpPSnmpAdminStatus, vrIpNsFirstFilter=vrIpNsFirstFilter, vrPpIpPortLogicalIfOspfIfNbrOperEntry=vrPpIpPortLogicalIfOspfIfNbrOperEntry, vrIpStaticRouteNhProvTable=vrIpStaticRouteNhProvTable, vrIpIfMtu=vrIpIfMtu, vrIpStaticRouteComponentName=vrIpStaticRouteComponentName, vrPpIpPortLogicalIfLinkToPimSmCandidateBsr=vrPpIpPortLogicalIfLinkToPimSmCandidateBsr, vrIpArpHostOperTable=vrIpArpHostOperTable, vrIpBootpOperStatusTable=vrIpBootpOperStatusTable, vrIpMcastPimSmDomainIndex=vrIpMcastPimSmDomainIndex, vrIpTunnelSepMpEntry=vrIpTunnelSepMpEntry, vrIpMcastAdminControlEntry=vrIpMcastAdminControlEntry, vrIpCosPolicyAssignment=vrIpCosPolicyAssignment, vrIpOspfVirtIfComponentName=vrIpOspfVirtIfComponentName, vrPpIpPortBootpPAdminControlTable=vrPpIpPortBootpPAdminControlTable, vrIpBootpUsageState=vrIpBootpUsageState, vrIpMcastPimSmDomainCRpProvTable=vrIpMcastPimSmDomainCRpProvTable, vrIpRdbProtocolIndex=vrIpRdbProtocolIndex, vrIpMcastPimSmDomainRxHelloMsg=vrIpMcastPimSmDomainRxHelloMsg, vrIpOspfNbrState=vrIpOspfNbrState, vrIpOspfOperEntry=vrIpOspfOperEntry, vrIpRipImportNeighbor=vrIpRipImportNeighbor, vrIpArpHostMaxTxUnit=vrIpArpHostMaxTxUnit, vrPpIpPortLogicalIfRipIfProvEntry=vrPpIpPortLogicalIfRipIfProvEntry, vrPpIpPortLogicalIfPimSmIfProvEntry=vrPpIpPortLogicalIfPimSmIfProvEntry, vrIpNsLocalOutFilter=vrIpNsLocalOutFilter, vrIpMcastIndex=vrIpMcastIndex, vrPpIpPortLogicalIfIgmpIfRowStatusTable=vrPpIpPortLogicalIfIgmpIfRowStatusTable, vrIpTunnelSepPathMtu=vrIpTunnelSepPathMtu, vrIpOspfStubRowStatusEntry=vrIpOspfStubRowStatusEntry, vrPpIpPortNsRowStatusEntry=vrPpIpPortNsRowStatusEntry, vrPpIpPortLogicalIfRipIfSnmpAdminStatus=vrPpIpPortLogicalIfRipIfSnmpAdminStatus, vrIpMcastCacheStatsUsageState=vrIpMcastCacheStatsUsageState, vrIpNsRowStatus=vrIpNsRowStatus, vrIpRipIndex=vrIpRipIndex, vrIpOspfLsdbLsdbTypeIndex=vrIpOspfLsdbLsdbTypeIndex, vrIpMcastPimSmOperStatusEntry=vrIpMcastPimSmOperStatusEntry, vrIpEgpExportOutAutonomousSystem=vrIpEgpExportOutAutonomousSystem, vrIpTcpTcpEntryComponentName=vrIpTcpTcpEntryComponentName, vrIpMcastCacheStatsComponentName=vrIpMcastCacheStatsComponentName, vrIpMcastStateTable=vrIpMcastStateTable, vrIpRipSnmpAdminStatus=vrIpRipSnmpAdminStatus, vrIpArpHostStorageType=vrIpArpHostStorageType, vrPpIpPortProvEntry=vrPpIpPortProvEntry, vrIpOspfLsdbOperTable=vrIpOspfLsdbOperTable, vrIpMcastPimSmDomainTxJPMsg=vrIpMcastPimSmDomainTxJPMsg, vrIpEgpAdminControlEntry=vrIpEgpAdminControlEntry, vrIpMcastPgLinkToPolicyUserValue=vrIpMcastPgLinkToPolicyUserValue, vrIpStaticOperationalState=vrIpStaticOperationalState, vrPpIpPortLogicalIfOspfIfRtrDeadInterval=vrPpIpPortLogicalIfOspfIfRtrDeadInterval, vrPpIpPortLogicalIfOspfIfIndex=vrPpIpPortLogicalIfOspfIfIndex, vrIpStaticRouteNhMetric=vrIpStaticRouteNhMetric, vrIpMcastPgComponentName=vrIpMcastPgComponentName, vrPpIpPortLogicalIfOspfIfComponentName=vrPpIpPortLogicalIfOspfIfComponentName, vrIpMcastStaticRouteOifsValue=vrIpMcastStaticRouteOifsValue, vrIpMcastDomainComponentName=vrIpMcastDomainComponentName, vrIpOspfVirtNbrNbrRouterIdIndex=vrIpOspfVirtNbrNbrRouterIdIndex, vrIpRelayBCRowStatus=vrIpRelayBCRowStatus, vrPpIpPortEncap=vrPpIpPortEncap, vrIpMcastPgGrpRowStatusTable=vrIpMcastPgGrpRowStatusTable, vrIpOspfLsdbSequence=vrIpOspfLsdbSequence, vrIpMcastIgmpStateTable=vrIpMcastIgmpStateTable, vrIpMcastPimSmDomainProvTable=vrIpMcastPimSmDomainProvTable, vrIpOspfMigrateRip=vrIpOspfMigrateRip, vrIpStaticDiscard=vrIpStaticDiscard, vrIpEgpNbrDefaultMetric=vrIpEgpNbrDefaultMetric, vrIpOspfVirtIfAuthKey=vrIpOspfVirtIfAuthKey, vrIpOspfLsdbAdvertisement=vrIpOspfLsdbAdvertisement, vrIpOspfAggregateProvEntry=vrIpOspfAggregateProvEntry, vrIpTcpStorageType=vrIpTcpStorageType, vrIpOspfExportRipInterface=vrIpOspfExportRipInterface, vrIpTunnelSepDestinationAddress=vrIpTunnelSepDestinationAddress, vrIpMcastPimSmDomainTxCRpAdvMsg=vrIpMcastPimSmDomainTxCRpAdvMsg, vrIpArpDynHostType=vrIpArpDynHostType, vrIpMcastFwdOifComponentName=vrIpMcastFwdOifComponentName, vrIpMcastIgmpGcProtocolportStringIndex=vrIpMcastIgmpGcProtocolportStringIndex, vrIpEgpStatsTable=vrIpEgpStatsTable, vrIpBootpAdminState=vrIpBootpAdminState, vrPpIpPortOperCosPolicyAssignment=vrPpIpPortOperCosPolicyAssignment, vrIpMcastFwdFlags=vrIpMcastFwdFlags, vrIpRipImportNetIndex=vrIpRipImportNetIndex, vrIpOspfHostRowStatusEntry=vrIpOspfHostRowStatusEntry, vrIpOspfExtLsdbOperTable=vrIpOspfExtLsdbOperTable, vrIpStaticRouteStorageType=vrIpStaticRouteStorageType, vrIpCacheRowStatusTable=vrIpCacheRowStatusTable, vrIpTunnelSepRowStatus=vrIpTunnelSepRowStatus, vrIpEgpAdminControlTable=vrIpEgpAdminControlTable, vrIpRelayBCOperTable=vrIpRelayBCOperTable, vrIpMcastCtsValue=vrIpMcastCtsValue, vrPpIpPortLogicalIfOspfIfMulticastForwarding=vrPpIpPortLogicalIfOspfIfMulticastForwarding, vrIpOspfExportRowStatusTable=vrIpOspfExportRowStatusTable, vrIpMcastStaticRowStatusEntry=vrIpMcastStaticRowStatusEntry, vrPpIpPortBootpPRowStatus=vrPpIpPortBootpPRowStatus, vrIpMcastPimNbrDomainIndex=vrIpMcastPimNbrDomainIndex, vrIpStaticRowStatusEntry=vrIpStaticRowStatusEntry, vrPpIpPortLogicalIfOspfIfRowStatus=vrPpIpPortLogicalIfOspfIfRowStatus, vrIpRelayBCPortComponentName=vrIpRelayBCPortComponentName, vrIpIcmpStatsTable=vrIpIcmpStatsTable, vrPpIpPortLogicalIfOspfIfTOS=vrPpIpPortLogicalIfOspfIfTOS, vrPpIpPortLogicalIfOspfIfNbrStorageType=vrPpIpPortLogicalIfOspfIfNbrStorageType, vrIpMcastPimSmDomainTxRegisterStopMsg=vrIpMcastPimSmDomainTxRegisterStopMsg, vrIpTunnelSepProvEntry=vrIpTunnelSepProvEntry, vrIpTcpComponentName=vrIpTcpComponentName, vrIpMcastPimSmDomainCRpGrpRowStatus=vrIpMcastPimSmDomainCRpGrpRowStatus, vrIpOspfExtLsdbStorageType=vrIpOspfExtLsdbStorageType)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-IpMIB", vrPpIpPortLogicalIfOspfIfSnmpAdminStatus=vrPpIpPortLogicalIfOspfIfSnmpAdminStatus, vrIpRelayBCRelayNdCount=vrIpRelayBCRelayNdCount, vrIpMcastCacheStats=vrIpMcastCacheStats, vrPpIpPortLogicalIfLinkToMulStaticGpRowStatus=vrPpIpPortLogicalIfLinkToMulStaticGpRowStatus, vrIpEgp=vrIpEgp, vrIpEgpImportComponentName=vrIpEgpImportComponentName, vrIpStaticRowStatus=vrIpStaticRowStatus, vrIpEgpNbrRowStatusEntry=vrIpEgpNbrRowStatusEntry, vrPpIpPortLogicalIfIgmpIfProvTable=vrPpIpPortLogicalIfIgmpIfProvTable, vrIpIcmpOutSrcQuenchs=vrIpIcmpOutSrcQuenchs, vrIpMcastPimSmSnmpAdminStatus=vrIpMcastPimSmSnmpAdminStatus, vrIpOspfExportRowStatusEntry=vrIpOspfExportRowStatusEntry, vrIpOspfExportRowStatus=vrIpOspfExportRowStatus, vrIpBootpStateTable=vrIpBootpStateTable, vrIpMcastFwdOifProtocol=vrIpMcastFwdOifProtocol, vrPpIpPortLogicalIfIgmpIfQueryMaxRespTime=vrPpIpPortLogicalIfIgmpIfQueryMaxRespTime, vrIpUdpOutDatagrams=vrIpUdpOutDatagrams, vrIpStatsTable=vrIpStatsTable, vrIpStaticDiscardDestAddressIndex=vrIpStaticDiscardDestAddressIndex, vrIpOspfExportNetListIpMask=vrIpOspfExportNetListIpMask, vrIpOspfHostAddressIndex=vrIpOspfHostAddressIndex, vrIpMcastDomainStorageType=vrIpMcastDomainStorageType, vrIpTunnelSepOperTable=vrIpTunnelSepOperTable, vrIpRipExportRowStatusEntry=vrIpRipExportRowStatusEntry, vrIpArpHostPhysAddress=vrIpArpHostPhysAddress, vrIpTunnelSepStorageType=vrIpTunnelSepStorageType, vrIpOspfAreaComponentName=vrIpOspfAreaComponentName, vrIpMcastCacheStatsCacheTableMaxEntries=vrIpMcastCacheStatsCacheTableMaxEntries, vrPpIpPortIndex=vrPpIpPortIndex, vrPpIpPortBootpPInRequests=vrPpIpPortBootpPInRequests, vrPpIpPortLogicalIfRipIfNbrComponentName=vrPpIpPortLogicalIfRipIfNbrComponentName, vrPpIpPortBootpPOutRequests=vrPpIpPortBootpPOutRequests, vrIpRelayBCPortStorageType=vrIpRelayBCPortStorageType, vrIpTunnelSepIfIndex=vrIpTunnelSepIfIndex, vrIpIcmpOutTimeExcds=vrIpIcmpOutTimeExcds, vrIpOspfAggregateProvTable=vrIpOspfAggregateProvTable, vrIpMcastDomainRowStatus=vrIpMcastDomainRowStatus, vrPpIpPortLogicalIfRipIfIfConfSend=vrPpIpPortLogicalIfRipIfIfConfSend, vrPpIpPortLogicalIfRipIfNbr=vrPpIpPortLogicalIfRipIfNbr, vrPpIpPortLogicalIfRipIfNbrRowStatusEntry=vrPpIpPortLogicalIfRipIfNbrRowStatusEntry, vrIpOspfHostComponentName=vrIpOspfHostComponentName, vrIpStaticRouteNhRowStatusTable=vrIpStaticRouteNhRowStatusTable, vrIpOspfExtLsdbLsIdIndex=vrIpOspfExtLsdbLsIdIndex, vrPpIpPortLogicalIfOspfIfTransitDelay=vrPpIpPortLogicalIfOspfIfTransitDelay, vrIpMcastCacheStatsOperTable=vrIpMcastCacheStatsOperTable, vrIpIcmpSendHostUnreachable=vrIpIcmpSendHostUnreachable, vrPpIpPortLogicalIfOspfIfIfType=vrPpIpPortLogicalIfOspfIfIfType, vrPpIpPortLogicalIfPimSmIfComponentName=vrPpIpPortLogicalIfPimSmIfComponentName, vrIpOutNoRoutes=vrIpOutNoRoutes, vrIpCtsValue=vrIpCtsValue, vrIpFwdProtocolPortName=vrIpFwdProtocolPortName, vrIpMcastFwdRowStatusTable=vrIpMcastFwdRowStatusTable, vrIpMcastStaticIndex=vrIpMcastStaticIndex, vrIpMcastFwdOifRowStatusEntry=vrIpMcastFwdOifRowStatusEntry, vrIpEgpNbrRowStatus=vrIpEgpNbrRowStatus, vrIpMcastPimSmDomainJoinPruneInterval=vrIpMcastPimSmDomainJoinPruneInterval, vrIpIfRowStatusTable=vrIpIfRowStatusTable, vrIpMcastPimSmDomainRpSetStorageType=vrIpMcastPimSmDomainRpSetStorageType, vrIpTcpTcpEntryRowStatus=vrIpTcpTcpEntryRowStatus, vrIpRipExportComponentName=vrIpRipExportComponentName, vrIpMcastStaticAdminState=vrIpMcastStaticAdminState, vrIpOspfStubStorageType=vrIpOspfStubStorageType, vrIpMcastPgLinkToPolicyUserRowStatus=vrIpMcastPgLinkToPolicyUserRowStatus, vrIpEgpImportNbrAsId=vrIpEgpImportNbrAsId, vrIpOspfExportProvTable=vrIpOspfExportProvTable, vrPpIpPortLogicalIfOspfIfNbrAddressIndex=vrPpIpPortLogicalIfOspfIfNbrAddressIndex, vrIpBootpPpEStatsTable=vrIpBootpPpEStatsTable, vrIpIcmpInAddrMasks=vrIpIcmpInAddrMasks, vrIpFwdTypeOfServiceIndex=vrIpFwdTypeOfServiceIndex, vrIpIcmpOutErrors=vrIpIcmpOutErrors, vrIpMcastUsageState=vrIpMcastUsageState, vrPpIpPortAdminState=vrPpIpPortAdminState, vrIpBootpPpERowStatusTable=vrIpBootpPpERowStatusTable, vrIpOspfTosSupport=vrIpOspfTosSupport, vrIpStatsEntry=vrIpStatsEntry, vrIpBootpAdminControlTable=vrIpBootpAdminControlTable, vrIpMcastCacheStatsLookupMisses=vrIpMcastCacheStatsLookupMisses, vrIpEgpExport=vrIpEgpExport, vrIpMcastPimSmDomainRowStatusEntry=vrIpMcastPimSmDomainRowStatusEntry, vrIpRipImportImportMetric=vrIpRipImportImportMetric, vrIpNsApplyDirection=vrIpNsApplyDirection, vrIpEgpImportNetProvTable=vrIpEgpImportNetProvTable, vrIpEgpInMsgs=vrIpEgpInMsgs, vrIpMcastCacheStatsOperEntry=vrIpMcastCacheStatsOperEntry, vrIpTunnelSepSourceAddress=vrIpTunnelSepSourceAddress, vrPpIpPortLogicalIfPimSmIfRowStatus=vrPpIpPortLogicalIfPimSmIfRowStatus, vrPpIpPortBootpPStateEntry=vrPpIpPortBootpPStateEntry, vrIpOspfAreaBdrRtrStatus=vrIpOspfAreaBdrRtrStatus, vrIpRelayBCProvEntry=vrIpRelayBCProvEntry, ipCapabilitiesBE=ipCapabilitiesBE, vrIpIcmpOutTimestamps=vrIpIcmpOutTimestamps, vrIpOspfHostTosIndex=vrIpOspfHostTosIndex, vrIpMcastStaticRouteComponentName=vrIpMcastStaticRouteComponentName, vrPpIpPort=vrPpIpPort, vrIpOspfVirtIfStorageType=vrIpOspfVirtIfStorageType, vrIpNsApplyIpMask2=vrIpNsApplyIpMask2, vrIpMcastPimSmDomainDiscardJPMsg=vrIpMcastPimSmDomainDiscardJPMsg, vrIpMcastPimSmStorageType=vrIpMcastPimSmStorageType, vrIpEgpNbr=vrIpEgpNbr, vrIpEgpImportNetProvEntry=vrIpEgpImportNetProvEntry, vrIpRipExportBgpAsId=vrIpRipExportBgpAsId, vrPpIpPortLogicalIfRowStatusTable=vrPpIpPortLogicalIfRowStatusTable, vrIpCacheAdminState=vrIpCacheAdminState, vrPpIpPortOperationalState=vrPpIpPortOperationalState, vrIpInHdrErrors=vrIpInHdrErrors, vrIpRelayBCPortPortNumIndex=vrIpRelayBCPortPortNumIndex, vrIpEgpExportNetProvEntry=vrIpEgpExportNetProvEntry, vrIpTunnelSep=vrIpTunnelSep, ipGroup=ipGroup, vrIpMcastDomainOperEntry=vrIpMcastDomainOperEntry, vrIpUdpListenEntryRowStatusEntry=vrIpUdpListenEntryRowStatusEntry, vrIpRipImportRowStatus=vrIpRipImportRowStatus, vrIpStaticAdminState=vrIpStaticAdminState, vrPpIpPortLogicalIfOspfIfNbrOptions=vrPpIpPortLogicalIfOspfIfNbrOptions, vrIpMcastPimSmDomainCRpProvEntry=vrIpMcastPimSmDomainCRpProvEntry, vrIpEgpImportNetRowStatus=vrIpEgpImportNetRowStatus, vrIpTunnelSepOperEntry=vrIpTunnelSepOperEntry, vrIpRipImportNetRowStatus=vrIpRipImportNetRowStatus, vrIpTunnelComponentName=vrIpTunnelComponentName, vrIpOspfAreaImportAsExtern=vrIpOspfAreaImportAsExtern, vrPpIpPortLogicalIfOspfIfProvTable=vrPpIpPortLogicalIfOspfIfProvTable, vrIpOspfVirtNbrOptions=vrIpOspfVirtNbrOptions, vrIpCacheEntriesFree=vrIpCacheEntriesFree, vrIpMcastIgmpOperationalState=vrIpMcastIgmpOperationalState, vrIpRipOperStatusEntry=vrIpRipOperStatusEntry, vrIpArpDynHostPhysAddress=vrIpArpDynHostPhysAddress, vrIpMcastFwdGAddrIndex=vrIpMcastFwdGAddrIndex, vrIpOspfStateTable=vrIpOspfStateTable, vrIpIcmpRowStatusEntry=vrIpIcmpRowStatusEntry, vrIpBootpPpEIndex=vrIpBootpPpEIndex, vrIpOspfRxNewLsas=vrIpOspfRxNewLsas, vrIpRowStatusEntry=vrIpRowStatusEntry, vrPpIpPortLogicalIfAddressIndex=vrPpIpPortLogicalIfAddressIndex, vrIpRipImportNetRowStatusTable=vrIpRipImportNetRowStatusTable, vrIpMcastPimSmDomainRpSetRowStatusEntry=vrIpMcastPimSmDomainRpSetRowStatusEntry, vrIpOspfNbrNbmaNbrStatus=vrIpOspfNbrNbmaNbrStatus, vrIpNsApplyRowStatusEntry=vrIpNsApplyRowStatusEntry, vrIpCache=vrIpCache, vrIpCacheStorageType=vrIpCacheStorageType, vrIpUdpInErrors=vrIpUdpInErrors, vrIpMcastFwdOifRowStatusTable=vrIpMcastFwdOifRowStatusTable, vrIpOspfAreaRowStatusTable=vrIpOspfAreaRowStatusTable, vrIpOspfOriginateNewLsas=vrIpOspfOriginateNewLsas, vrPpIpPortNsProvTable=vrPpIpPortNsProvTable, vrIpIcmpIndex=vrIpIcmpIndex, vrPpIpPortLogicalIfLinkToPimSmCandidateRp=vrPpIpPortLogicalIfLinkToPimSmCandidateRp, vrIpUdpNoPorts=vrIpUdpNoPorts, vrIpTcpRowStatusEntry=vrIpTcpRowStatusEntry, vrIpEgpImportNetIndex=vrIpEgpImportNetIndex, vrIpArpDynHostHostAddressIndex=vrIpArpDynHostHostAddressIndex, vrIpOspfNbrRowStatusEntry=vrIpOspfNbrRowStatusEntry, vrIpStaticRouteNhProvEntry=vrIpStaticRouteNhProvEntry, vrIpFragFails=vrIpFragFails, vrIpMcastStaticComponentName=vrIpMcastStaticComponentName, vrIpRipOperTable=vrIpRipOperTable, vrIpMcastPimSmDomainCRpGrpGrpMaskIndex=vrIpMcastPimSmDomainCRpGrpGrpMaskIndex, vrIpOspfHostMetric=vrIpOspfHostMetric, vrIpOspfExtLsdbChecksum=vrIpOspfExtLsdbChecksum, vrIpTunnelSepIfEntryEntry=vrIpTunnelSepIfEntryEntry, vrIpRipImportNetProvTable=vrIpRipImportNetProvTable, vrIpEgpNbrInMsgs=vrIpEgpNbrInMsgs, vrIpMcastStateEntry=vrIpMcastStateEntry, vrIpCacheRowStatusEntry=vrIpCacheRowStatusEntry, vrPpIpPortLogicalIfRowStatusEntry=vrPpIpPortLogicalIfRowStatusEntry, vrIpMcastRowStatus=vrIpMcastRowStatus, vrIpOspfComponentName=vrIpOspfComponentName, vrPpIpPortLogicalIfPimSmIfIndex=vrPpIpPortLogicalIfPimSmIfIndex, vrIpTunnelSepIfEntryTable=vrIpTunnelSepIfEntryTable, vrPpIpPortLogicalIfOspfIfTOSProvTable=vrPpIpPortLogicalIfOspfIfTOSProvTable, vrIpOspfExportNetListProvEntry=vrIpOspfExportNetListProvEntry, vrIpEgpSnmpAdminStatus=vrIpEgpSnmpAdminStatus, vrIpTunnelStateEntry=vrIpTunnelStateEntry, vrPpIpPortLogicalIfOspfIfMetric=vrPpIpPortLogicalIfOspfIfMetric, vrIpOspfArea=vrIpOspfArea, vrIpMcastFwdRowStatus=vrIpMcastFwdRowStatus, vrIpRipImportInterface=vrIpRipImportInterface, vrIpRip=vrIpRip, vrIpIfComponentName=vrIpIfComponentName, vrIpFwdOperEntry=vrIpFwdOperEntry, vrIpOspfExportNetListIpAddress=vrIpOspfExportNetListIpAddress, vrPpIpPortLogicalIfOspfIfNbrExchangeStatus=vrPpIpPortLogicalIfOspfIfNbrExchangeStatus, vrIpMcastStatic=vrIpMcastStatic, vrIpMcastPgGrpStorageType=vrIpMcastPgGrpStorageType, vrIpStaticRouteNhComponentName=vrIpStaticRouteNhComponentName, vrIpMcastPimSmStateEntry=vrIpMcastPimSmStateEntry, vrIpEgpNbrInErrors=vrIpEgpNbrInErrors, vrIpEgpNbrOperTable=vrIpEgpNbrOperTable, vrIpOspfVirtIfRowStatusEntry=vrIpOspfVirtIfRowStatusEntry, vrIpOspfStubTosIndex=vrIpOspfStubTosIndex, vrIpEgpImportRowStatusEntry=vrIpEgpImportRowStatusEntry, vrIpEgpNbrStateDowns=vrIpEgpNbrStateDowns, vrIpMcastFwdOifRowStatus=vrIpMcastFwdOifRowStatus, vrIpOspfNbrExchangeStatus=vrIpOspfNbrExchangeStatus, vrIpMcastFwdInProtocolPortName=vrIpMcastFwdInProtocolPortName, vrPpIpPortLogicalIfOspfIfNbrPriority=vrPpIpPortLogicalIfOspfIfNbrPriority, vrIpOspfOperStatusEntry=vrIpOspfOperStatusEntry, vrIpRipExportOutInterface=vrIpRipExportOutInterface, vrIpReasmTimeOut=vrIpReasmTimeOut, vrIpOspfVirtIfRowStatus=vrIpOspfVirtIfRowStatus, vrIpMcastIgmpAdminControlTable=vrIpMcastIgmpAdminControlTable, vrIpRelayBCOperEntry=vrIpRelayBCOperEntry, vrIpMcastFwdOperEntry=vrIpMcastFwdOperEntry, vrIpIcmpInRtrSolicits=vrIpIcmpInRtrSolicits, vrIpMcastPimSmAdminState=vrIpMcastPimSmAdminState, vrIpMcastPgProvTable=vrIpMcastPgProvTable, vrIpMcastFwdOifAge=vrIpMcastFwdOifAge, vrIpIcmpInTimeExcds=vrIpIcmpInTimeExcds, vrPpIpPortNsIncomingFilter=vrPpIpPortNsIncomingFilter, vrIpOspfNbrRowStatusTable=vrIpOspfNbrRowStatusTable, vrIpStaticDiscardRowStatusEntry=vrIpStaticDiscardRowStatusEntry, vrIpBootpPpEInReplyErrors=vrIpBootpPpEInReplyErrors, vrPpIpPortLogicalIfRipIfNbrRowStatus=vrPpIpPortLogicalIfRipIfNbrRowStatus, vrIpRelayBC=vrIpRelayBC, vrIpTcpOutSegs=vrIpTcpOutSegs, vrIpBootpRowStatus=vrIpBootpRowStatus, vrIpMcastPgLinkToPolicyUserTable=vrIpMcastPgLinkToPolicyUserTable, vrIpMcastPimNbr=vrIpMcastPimNbr, vrIpOspfExportNetList=vrIpOspfExportNetList, vrIpOspfSnmpAdminStatus=vrIpOspfSnmpAdminStatus, vrIpFwd=vrIpFwd, vrIpOspfHostProvEntry=vrIpOspfHostProvEntry, vrIpEgpOperStatusEntry=vrIpEgpOperStatusEntry, vrIpEgpProvEntry=vrIpEgpProvEntry, vrPpIpPortLogicalIfBroadcastAddress=vrPpIpPortLogicalIfBroadcastAddress, vrIpRipAdminState=vrIpRipAdminState, vrIpRipExportNetProvEntry=vrIpRipExportNetProvEntry, vrPpIpPortBootpPStatsTable=vrPpIpPortBootpPStatsTable, vrPpIpPortRowStatusEntry=vrPpIpPortRowStatusEntry, vrIpMcastPimSmDomainRpSetOperEntry=vrIpMcastPimSmDomainRpSetOperEntry, vrIpOspfAreaAreaBdrRtrCount=vrIpOspfAreaAreaBdrRtrCount, vrPpIpPortLogicalIfIgmpIfRowStatus=vrPpIpPortLogicalIfIgmpIfRowStatus, vrIp=vrIp, vrPpIpPortSresProvTable=vrPpIpPortSresProvTable, vrPpIpPortOperTable=vrPpIpPortOperTable, vrIpMcastStaticRouteDomainIndex=vrIpMcastStaticRouteDomainIndex, ipGroupBE01=ipGroupBE01, vrIpIcmpInMsgs=vrIpIcmpInMsgs, vrPpIpPortLogicalIfOspfIfNbrProvTable=vrPpIpPortLogicalIfOspfIfNbrProvTable, vrPpIpPortLogicalIfOspfIfStorageType=vrPpIpPortLogicalIfOspfIfStorageType, vrIpStaticRouteNh=vrIpStaticRouteNh, vrIpEgpStorageType=vrIpEgpStorageType, vrIpMcastPimSmDomainCBsrStorageType=vrIpMcastPimSmDomainCBsrStorageType, vrIpBootpOperationalState=vrIpBootpOperationalState, vrIpMcastPimSmSnmpOperStatus=vrIpMcastPimSmSnmpOperStatus, vrIpMcastPimSmDomainCRpGrpStorageType=vrIpMcastPimSmDomainCRpGrpStorageType, vrPpIpPortMediaType=vrPpIpPortMediaType, vrIpMcastCacheStatsRowStatusEntry=vrIpMcastCacheStatsRowStatusEntry, vrIpEgpOperationalState=vrIpEgpOperationalState, vrPpIpPortIcmpMaskReply=vrPpIpPortIcmpMaskReply, vrPpIpPortLogicalIfOspfIfNbr=vrPpIpPortLogicalIfOspfIfNbr, vrIpOspfAggregateLsdbTypeIndex=vrIpOspfAggregateLsdbTypeIndex, vrIpMcastPimSmDomainCBsrIndex=vrIpMcastPimSmDomainCBsrIndex, vrIpRipRouteChangesMade=vrIpRipRouteChangesMade, vrIpMcastPimSmDomain=vrIpMcastPimSmDomain)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-IpMIB", vrIpEgpExportIndex=vrIpEgpExportIndex, vrIpOspfNbrRowStatus=vrIpOspfNbrRowStatus, vrIpMcastFwdOperTable=vrIpMcastFwdOperTable, vrPpIpPortOperStatusTable=vrPpIpPortOperStatusTable, vrIpStorageType=vrIpStorageType, vrIpMcastIgmpGcRowStatus=vrIpMcastIgmpGcRowStatus, vrIpCacheOperTable=vrIpCacheOperTable, vrIpMcastPimNbrNbrAddressIndex=vrIpMcastPimNbrNbrAddressIndex, vrIpOspfVirtIfState=vrIpOspfVirtIfState, vrIpArpDynHostMaxTxUnit=vrIpArpDynHostMaxTxUnit, vrIpMcastPgRowStatusTable=vrIpMcastPgRowStatusTable, vrIpMcastPimSmOperStatusTable=vrIpMcastPimSmOperStatusTable, vrIpFwdRowStatus=vrIpFwdRowStatus, vrPpIpPortBootpPStateTable=vrPpIpPortBootpPStateTable, vrIpMcastPimSmDomainCBsrRowStatusEntry=vrIpMcastPimSmDomainCBsrRowStatusEntry, vrIpIcmpInEchoReps=vrIpIcmpInEchoReps, vrPpIpPortRelayBroadcast=vrPpIpPortRelayBroadcast, vrPpIpPortLogicalIfRipIfIfBadRouteRcv=vrPpIpPortLogicalIfRipIfIfBadRouteRcv, vrIpRipImportRowStatusTable=vrIpRipImportRowStatusTable, vrIpFragOks=vrIpFragOks, vrIpTunnelSepRowStatusEntry=vrIpTunnelSepRowStatusEntry, vrIpOspfLsdbRouterIdIndex=vrIpOspfLsdbRouterIdIndex, vrIpRipGarbageCollectTimer=vrIpRipGarbageCollectTimer, vrIpTcpTcpEntryStorageType=vrIpTcpTcpEntryStorageType, vrIpRdbRowStatusEntry=vrIpRdbRowStatusEntry, vrIpInDelivers=vrIpInDelivers, vrPpIpPortSresProvEntry=vrPpIpPortSresProvEntry, vrPpIpPortNsProvEntry=vrPpIpPortNsProvEntry, vrIpTunnelRowStatusEntry=vrIpTunnelRowStatusEntry, vrPpIpPortLogicalIfRipIfStatEntry=vrPpIpPortLogicalIfRipIfStatEntry, vrIpArpDynHostRowStatus=vrIpArpDynHostRowStatus, vrIpFwdDestAddressIndex=vrIpFwdDestAddressIndex, vrIpOspfAggregateStorageType=vrIpOspfAggregateStorageType, vrIpMcastPgGrp=vrIpMcastPgGrp, vrIpEgpImportStorageType=vrIpEgpImportStorageType, vrIpOspfAreaSpfRuns=vrIpOspfAreaSpfRuns, vrIpIcmpOutRtrSolicits=vrIpIcmpOutRtrSolicits, vrIpEgpNbrHelloInterval=vrIpEgpNbrHelloInterval, vrIpMcastPimSmDomainRxRegisterMsg=vrIpMcastPimSmDomainRxRegisterMsg, vrIpRdbAge=vrIpRdbAge, vrIpFwdDestMaskIndex=vrIpFwdDestMaskIndex, vrPpIpPortLogicalIfRipIfIndex=vrPpIpPortLogicalIfRipIfIndex, vrIpEgpImportImportMetric=vrIpEgpImportImportMetric, vrPpIpPortLogicalIfRipIfFlashUpdateFlag=vrPpIpPortLogicalIfRipIfFlashUpdateFlag, vrPpIpPortBootpPRowStatusTable=vrPpIpPortBootpPRowStatusTable, vrIpEgpAdminState=vrIpEgpAdminState, vrIpRipRowStatus=vrIpRipRowStatus, vrIpOspfLsdbRowStatusEntry=vrIpOspfLsdbRowStatusEntry, vrIpEgpNbrInErrorMsgs=vrIpEgpNbrInErrorMsgs, vrPpIpPortLogicalIfOspfIfMetricTable=vrPpIpPortLogicalIfOspfIfMetricTable, vrIpOspfAreaStorageType=vrIpOspfAreaStorageType, vrIpOutRequests=vrIpOutRequests, vrIpMcastPimSmDomainRxJPMsg=vrIpMcastPimSmDomainRxJPMsg, vrIpRelayBCRelayStatus=vrIpRelayBCRelayStatus, vrIpMcastPimSmRowStatusEntry=vrIpMcastPimSmRowStatusEntry, vrIpEgpImportNetComponentName=vrIpEgpImportNetComponentName, vrPpIpPortRelayAddress=vrPpIpPortRelayAddress, vrIpFwdComponentName=vrIpFwdComponentName, vrIpMcastPimSmDomainCBsrCandidateBsrAddress=vrIpMcastPimSmDomainCBsrCandidateBsrAddress, vrIpOspfStubRowStatusTable=vrIpOspfStubRowStatusTable, vrIpEgpImportNetStorageType=vrIpEgpImportNetStorageType, vrIpMcastPimSmDomainCRpIndex=vrIpMcastPimSmDomainCRpIndex, vrPpIpPortBootpPOutReplies=vrPpIpPortBootpPOutReplies, vrPpIpPortLogicalIfOspfIfAreaId=vrPpIpPortLogicalIfOspfIfAreaId, vrIpTunnelStorageType=vrIpTunnelStorageType, vrIpTunnel=vrIpTunnel, vrIpBootpPpEStorageType=vrIpBootpPpEStorageType, vrIpFwdStorageType=vrIpFwdStorageType, vrIpCacheCacheTableMaxEntries=vrIpCacheCacheTableMaxEntries, vrPpIpPortLogicalIfRipIfProvTable=vrPpIpPortLogicalIfRipIfProvTable, vrIpEgpImportNetRowStatusEntry=vrIpEgpImportNetRowStatusEntry, vrIpStaticRouteTypeOfServiceIndex=vrIpStaticRouteTypeOfServiceIndex, vrIpIcmpProvTable=vrIpIcmpProvTable, vrPpIpPortLinkModel=vrPpIpPortLinkModel, vrPpIpPortBootpPAddrTable=vrPpIpPortBootpPAddrTable, vrIpMcastDomain=vrIpMcastDomain, vrIpRelayBCStorageType=vrIpRelayBCStorageType, vrPpIpPortLogicalIfOspfIfDesignatedRouter=vrPpIpPortLogicalIfOspfIfDesignatedRouter, vrIpOspfStubComponentName=vrIpOspfStubComponentName, vrIpIndex=vrIpIndex, vrIpEgpExportNetRowStatusTable=vrIpEgpExportNetRowStatusTable, vrIpMcastComponentName=vrIpMcastComponentName, vrIpArpHostEncap=vrIpArpHostEncap, vrIpNsRowStatusTable=vrIpNsRowStatusTable, vrPpIpPortLogicalIfOspfIf=vrPpIpPortLogicalIfOspfIf, vrIpNsApplyProvisionedTable=vrIpNsApplyProvisionedTable, vrIpOspfNbrStorageType=vrIpOspfNbrStorageType, vrIpOspfRowStatusTable=vrIpOspfRowStatusTable, vrIpIcmpInRedirects=vrIpIcmpInRedirects, vrIpEgpExportNetRowStatus=vrIpEgpExportNetRowStatus, vrIpRipImportIndex=vrIpRipImportIndex, vrIpOspfExtLsdbRowStatusEntry=vrIpOspfExtLsdbRowStatusEntry, vrIpOspfStubAreaIdIndex=vrIpOspfStubAreaIdIndex, vrIpArp=vrIpArp, vrIpRipImportProvEntry=vrIpRipImportProvEntry, vrIpRipExportNetProvTable=vrIpRipExportNetProvTable, vrIpReasmReqds=vrIpReasmReqds, vrIpMcastPimSmAdminControlTable=vrIpMcastPimSmAdminControlTable, vrIpRipImportNetProvEntry=vrIpRipImportNetProvEntry, vrIpStaticRouteDestMaskIndex=vrIpStaticRouteDestMaskIndex, vrIpTcpIndex=vrIpTcpIndex, vrIpRelayBCPortRowStatus=vrIpRelayBCPortRowStatus, vrIpIcmpProvEntry=vrIpIcmpProvEntry, vrIpEgpComponentName=vrIpEgpComponentName, vrIpMcastIgmpAdminState=vrIpMcastIgmpAdminState, vrIpMcastIgmpRowStatusEntry=vrIpMcastIgmpRowStatusEntry, vrIpIcmpInParmProbs=vrIpIcmpInParmProbs, vrIpFragCreates=vrIpFragCreates, vrIpMcastPgGrpGMaskIndex=vrIpMcastPgGrpGMaskIndex, vrIpTcpRToMax=vrIpTcpRToMax, vrPpIpPortLogicalIfPimSmIfDesignatedRouter=vrPpIpPortLogicalIfPimSmIfDesignatedRouter, vrIpEgpProvTable=vrIpEgpProvTable, vrIpIcmpStatsEntry=vrIpIcmpStatsEntry, vrIpMcastPimSmDomainCRpGrpGrpAddressIndex=vrIpMcastPimSmDomainCRpGrpGrpAddressIndex, vrIpOspfNbrEvents=vrIpOspfNbrEvents, vrPpIpPortLogicalIfRowStatus=vrPpIpPortLogicalIfRowStatus, vrIpRipExportStorageType=vrIpRipExportStorageType, vrIpRipComponentName=vrIpRipComponentName, vrIpIcmpInRtrAdvs=vrIpIcmpInRtrAdvs, vrIpTcpTcpEntryRemotePortIndex=vrIpTcpTcpEntryRemotePortIndex, vrIpMcastIgmpGcOperTable=vrIpMcastIgmpGcOperTable, vrIpEgpDefaultHelloInterval=vrIpEgpDefaultHelloInterval, vrIpStaticStorageType=vrIpStaticStorageType, vrIpRipOperEntry=vrIpRipOperEntry, vrIpFwdType=vrIpFwdType, vrIpMcastPimNbrRowStatus=vrIpMcastPimNbrRowStatus, vrIpMcastIgmpUsageState=vrIpMcastIgmpUsageState, vrIpRipExportIndex=vrIpRipExportIndex, vrIpArpHostOperEncap=vrIpArpHostOperEncap, vrIpRdbPreference=vrIpRdbPreference, vrIpEgpNbrOperEntry=vrIpEgpNbrOperEntry, vrIpEgpRowStatusTable=vrIpEgpRowStatusTable, vrIpNsComponentName=vrIpNsComponentName, vrIpEgpRowStatusEntry=vrIpEgpRowStatusEntry, vrIpMcastCacheStatsOperationalState=vrIpMcastCacheStatsOperationalState, vrIpEgpNbrPollInterval=vrIpEgpNbrPollInterval, vrIpRipExportNetRowStatusEntry=vrIpRipExportNetRowStatusEntry, vrPpIpPortProvTable=vrPpIpPortProvTable, vrIpMcastPimSmDomainRpSetGrpMaskIndex=vrIpMcastPimSmDomainRpSetGrpMaskIndex, vrIpRipOperStatusTable=vrIpRipOperStatusTable, vrIpMcastPgGrpComponentName=vrIpMcastPgGrpComponentName, vrIpOspfLsdbAreaIdIndex=vrIpOspfLsdbAreaIdIndex, vrIpOspfExtLsdbRowStatusTable=vrIpOspfExtLsdbRowStatusTable, vrIpOspfAreaRowStatus=vrIpOspfAreaRowStatus, vrIpMcastIgmpComponentName=vrIpMcastIgmpComponentName, vrIpMcastFwdProtocol=vrIpMcastFwdProtocol, vrIpMcastStaticRouteOifsEntry=vrIpMcastStaticRouteOifsEntry, vrIpEgpInErrorMsgs=vrIpEgpInErrorMsgs, vrPpIpPortStateTable=vrPpIpPortStateTable, vrIpMcastCacheStatsRowStatusTable=vrIpMcastCacheStatsRowStatusTable, vrPpIpPortStateEntry=vrPpIpPortStateEntry, vrIpMcastStaticRouteOifsRowStatus=vrIpMcastStaticRouteOifsRowStatus, vrIpOspfExtLsdbRowStatus=vrIpOspfExtLsdbRowStatus, vrIpMcastFwdReversePathForwardingNeighbor=vrIpMcastFwdReversePathForwardingNeighbor, vrIpOspfGenerateDefaultRouteMetric=vrIpOspfGenerateDefaultRouteMetric, vrIpMcastIgmpGcGAddrIndex=vrIpMcastIgmpGcGAddrIndex, vrIpNsApplyProvisionedEntry=vrIpNsApplyProvisionedEntry, vrIpOspfStorageType=vrIpOspfStorageType, vrIpRdbMetric=vrIpRdbMetric, vrPpIpPortLogicalIfOspfIfTOSRowStatus=vrPpIpPortLogicalIfOspfIfTOSRowStatus, vrIpEgpExportNet=vrIpEgpExportNet, vrIpRipExportOspfTag=vrIpRipExportOspfTag, vrIpMcastStaticStateTable=vrIpMcastStaticStateTable, vrIpMcastPimSmDomainRowStatus=vrIpMcastPimSmDomainRowStatus, vrPpIpPortLogicalIfIgmpIfQuerierExpiryTime=vrPpIpPortLogicalIfIgmpIfQuerierExpiryTime, vrPpIpPortOperEntry=vrPpIpPortOperEntry, vrIpOspfExportAdvertiseStatus=vrIpOspfExportAdvertiseStatus, vrIpTunnelOperationalState=vrIpTunnelOperationalState, vrIpMcastPg=vrIpMcastPg, vrIpRipExportRowStatusTable=vrIpRipExportRowStatusTable, vrIpTcpOutRsts=vrIpTcpOutRsts, vrIpOspfVirtIfTransitDelay=vrIpOspfVirtIfTransitDelay, vrIpRelayBCRowStatusTable=vrIpRelayBCRowStatusTable, vrIpIfBroadcastAddress=vrIpIfBroadcastAddress, vrIpMcastPimSmDomainRxCRpAdvMsg=vrIpMcastPimSmDomainRxCRpAdvMsg, vrIpMcastPimSmStateTable=vrIpMcastPimSmStateTable, vrPpIpPortLogicalIfOspfIfTOSTosMetric=vrPpIpPortLogicalIfOspfIfTOSTosMetric, vrIpIfStatus=vrIpIfStatus, vrPpIpPortLogicalIfIgmpIfJoins=vrPpIpPortLogicalIfIgmpIfJoins, vrIpMcastFwdStorageType=vrIpMcastFwdStorageType, vrIpEgpMaxBufferSize=vrIpEgpMaxBufferSize, vrIpMcastFwdComponentName=vrIpMcastFwdComponentName, vrIpRdbGatewayIndex=vrIpRdbGatewayIndex, vrPpIpPortLogicalIfIgmpIf=vrPpIpPortLogicalIfIgmpIf, vrIpIcmpOutRedirects=vrIpIcmpOutRedirects, vrIpBootpPpERowStatus=vrIpBootpPpERowStatus, vrIpStaticRoutePreferredOver=vrIpStaticRoutePreferredOver, vrIpOspfNbrAddressLessIndex=vrIpOspfNbrAddressLessIndex, vrIpEgpMaxNatNets=vrIpEgpMaxNatNets, vrIpTunnelSepIfAdminStatus=vrIpTunnelSepIfAdminStatus, vrIpOspfVirtIfProvEntry=vrIpOspfVirtIfProvEntry, vrIpRdb=vrIpRdb, vrIpAdminControlTable=vrIpAdminControlTable, vrIpArpDynHostRowStatusEntry=vrIpArpDynHostRowStatusEntry, vrIpArpHostPermanentVirtualCircuitNumber=vrIpArpHostPermanentVirtualCircuitNumber, vrIpFwdRowStatusTable=vrIpFwdRowStatusTable, vrIpOspfAsBdrRtrStatus=vrIpOspfAsBdrRtrStatus, vrPpIpPortRelayBcOperEntry=vrPpIpPortRelayBcOperEntry, vrIpOspfStubProvTable=vrIpOspfStubProvTable, vrPpIpPortLogicalIfPimSmIfOperEntry=vrPpIpPortLogicalIfPimSmIfOperEntry, vrIpUdpListenEntryLocalAddressIndex=vrIpUdpListenEntryLocalAddressIndex, vrIpOspfExportBgpPeerIp=vrIpOspfExportBgpPeerIp, vrIpOspfAggregateRowStatus=vrIpOspfAggregateRowStatus, vrIpRipImportComponentName=vrIpRipImportComponentName, vrPpIpPortRelayAddressCount=vrPpIpPortRelayAddressCount, vrIpIcmpStorageType=vrIpIcmpStorageType, vrIpMcastPimSmDomainRpSetRpSetPriority=vrIpMcastPimSmDomainRpSetRpSetPriority, vrIpRipExportNetRowStatus=vrIpRipExportNetRowStatus, vrIpBootpPpEComponentName=vrIpBootpPpEComponentName, vrIpUdpStatsEntry=vrIpUdpStatsEntry, vrIpEgpImportNetIpAddress=vrIpEgpImportNetIpAddress, vrIpMcastFwdOifStorageType=vrIpMcastFwdOifStorageType, vrIpRelayBCPortOperTable=vrIpRelayBCPortOperTable, vrIpStaticIndex=vrIpStaticIndex, vrIpIcmpOutAddrMasks=vrIpIcmpOutAddrMasks, vrPpIpPortLogicalIfLinkDestinationAddress=vrPpIpPortLogicalIfLinkDestinationAddress, vrIpMcastPimSmDomainRxAssertMsg=vrIpMcastPimSmDomainRxAssertMsg, vrPpIpPortLogicalIfRipIfStorageType=vrPpIpPortLogicalIfRipIfStorageType, vrIpBootpPpEOperEntry=vrIpBootpPpEOperEntry, vrIpEgpExportProvTable=vrIpEgpExportProvTable, vrIpOspfHostStorageType=vrIpOspfHostStorageType, vrIpTcpTcpEntryState=vrIpTcpTcpEntryState, vrIpBootpPpEInRequestErrors=vrIpBootpPpEInRequestErrors, vrPpIpPortUsageState=vrPpIpPortUsageState, vrIpMcastPimSmDomainDiscardCRpAdvMsg=vrIpMcastPimSmDomainDiscardCRpAdvMsg, vrIpMcastFwdOifOperEntry=vrIpMcastFwdOifOperEntry, vrIpUsageState=vrIpUsageState, vrIpMcastPimSmComponentName=vrIpMcastPimSmComponentName, vrIpMcastIgmpGcStorageType=vrIpMcastIgmpGcStorageType, vrPpIpPortBootpPRowStatusEntry=vrPpIpPortBootpPRowStatusEntry, vrPpIpPortBootpPOperStatusTable=vrPpIpPortBootpPOperStatusTable, vrIpOspfVirtNbrNbrIpAddress=vrIpOspfVirtNbrNbrIpAddress, vrIpOspfExportStorageType=vrIpOspfExportStorageType, vrIpOspfExportBgpAsId=vrIpOspfExportBgpAsId, vrIpMcastPimSmDomainCRpComponentName=vrIpMcastPimSmDomainCRpComponentName, vrIpArpHostOperEntry=vrIpArpHostOperEntry, vrIpMcastPimSmDomainCRpGrpRowStatusTable=vrIpMcastPimSmDomainCRpGrpRowStatusTable, vrIpOspfExtLsdbLimit=vrIpOspfExtLsdbLimit, vrIpBootpAdminControlEntry=vrIpBootpAdminControlEntry, vrIpMcastStaticRowStatusTable=vrIpMcastStaticRowStatusTable, vrIpMcastPimSmDomainCRpGrpComponentName=vrIpMcastPimSmDomainCRpGrpComponentName, vrIpUdpListenEntryLocalPortIndex=vrIpUdpListenEntryLocalPortIndex, vrPpIpPortOperArpStatus=vrPpIpPortOperArpStatus, vrPpIpPortBootpPComponentName=vrPpIpPortBootpPComponentName, vrIpArpComponentName=vrIpArpComponentName, vrIpOspfAggregateEffect=vrIpOspfAggregateEffect, vrIpTunnelAdminState=vrIpTunnelAdminState, vrIpRdbOperEntry=vrIpRdbOperEntry, vrIpBootpPpE=vrIpBootpPpE, vrIpCacheUsageState=vrIpCacheUsageState, vrIpMcastFwdOifOutIfAddressIndex=vrIpMcastFwdOifOutIfAddressIndex, vrIpMcastCacheStatsEntriesFree=vrIpMcastCacheStatsEntriesFree, vrPpIpPortBootpPUsageState=vrPpIpPortBootpPUsageState, vrIpReasmOks=vrIpReasmOks)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-IpMIB", vrIpOspfVirtNbrAreaIdIndex=vrIpOspfVirtNbrAreaIdIndex, vrIpMcastPgGrpRowStatus=vrIpMcastPgGrpRowStatus, vrIpStaticRouteRowStatusEntry=vrIpStaticRouteRowStatusEntry, vrIpTunnelRowStatusTable=vrIpTunnelRowStatusTable, vrIpEgpUsageState=vrIpEgpUsageState, vrIpOspfAreaAreaSummary=vrIpOspfAreaAreaSummary, vrIpBootpPpEOperTable=vrIpBootpPpEOperTable, vrIpStaticRowStatusTable=vrIpStaticRowStatusTable, vrIpBootpIndex=vrIpBootpIndex, vrIpOspfAreaAsBdrRtrCount=vrIpOspfAreaAsBdrRtrCount, vrIpMcastPimSmDomainCRpCandidateRpAddress=vrIpMcastPimSmDomainCRpCandidateRpAddress, vrIpOspfExportNetListRowStatusTable=vrIpOspfExportNetListRowStatusTable, ipMIB=ipMIB, vrIpOspfExportIndex=vrIpOspfExportIndex, vrIpCacheStateEntry=vrIpCacheStateEntry, vrIpNsProvEntry=vrIpNsProvEntry, vrIpOspfStubMetric=vrIpOspfStubMetric, vrIpIf=vrIpIf, vrIpOspfVirtIfAreaIdIndex=vrIpOspfVirtIfAreaIdIndex, vrPpIpPortNsStorageType=vrPpIpPortNsStorageType, vrPpIpPortLogicalIfIgmpIfWrongVersionQuery=vrPpIpPortLogicalIfIgmpIfWrongVersionQuery, vrPpIpPortLogicalIfRipIfRowStatus=vrPpIpPortLogicalIfRipIfRowStatus, vrIpIcmpOutMsgs=vrIpIcmpOutMsgs, vrIpReasmFails=vrIpReasmFails, vrPpIpPortLogicalIfStorageType=vrPpIpPortLogicalIfStorageType, vrIpRipExportAdvertiseStatus=vrIpRipExportAdvertiseStatus, vrIpMcastPimSmDomainCBsrProvTable=vrIpMcastPimSmDomainCBsrProvTable, vrIpMcastIgmpRowStatusTable=vrIpMcastIgmpRowStatusTable, vrPpIpPortBootpPProvEntry=vrPpIpPortBootpPProvEntry, vrIpEgpInErrors=vrIpEgpInErrors, vrIpMcastPgGrpRowStatusEntry=vrIpMcastPgGrpRowStatusEntry, vrIpMcastPimSmDomainStatsTable=vrIpMcastPimSmDomainStatsTable, vrIpOspfProvEntry=vrIpOspfProvEntry, vrPpIpPortLogicalIfRipIfIfConfReceive=vrPpIpPortLogicalIfRipIfIfConfReceive, vrIpMcastPimSmDomainOperTable=vrIpMcastPimSmDomainOperTable, vrPpIpPortLogicalIfPimSmIf=vrPpIpPortLogicalIfPimSmIf, vrIpEgpNbrAsId=vrIpEgpNbrAsId, vrIpMcastOperationalState=vrIpMcastOperationalState, vrIpOspfVirtIfEvents=vrIpOspfVirtIfEvents, vrPpIpPortOperEncap=vrPpIpPortOperEncap, vrIpIfMediaType=vrIpIfMediaType, vrIpOspfProvTable=vrIpOspfProvTable, vrIpMcastIgmpStorageType=vrIpMcastIgmpStorageType, vrIpMcastPimSmDomainTxAssertMsg=vrIpMcastPimSmDomainTxAssertMsg, vrIpIcmpOutAddrMaskReps=vrIpIcmpOutAddrMaskReps, vrIpEgpOperStatusTable=vrIpEgpOperStatusTable, vrIpMcastIgmpGcDomainIndex=vrIpMcastIgmpGcDomainIndex, vrIpTunnelSepComponentName=vrIpTunnelSepComponentName, vrIpOspfVirtNbrState=vrIpOspfVirtNbrState, vrIpRipExportExportMetric=vrIpRipExportExportMetric, vrIpIcmpRowStatus=vrIpIcmpRowStatus, vrIpOspfAreaLsaCount=vrIpOspfAreaLsaCount, vrIpOspfAreaAreaLsaCksumSum=vrIpOspfAreaAreaLsaCksumSum, vrIpOspfHostRowStatus=vrIpOspfHostRowStatus, vrIpOspfNbrLsRetransQlen=vrIpOspfNbrLsRetransQlen, vrPpIpPortBootpPOperationalState=vrPpIpPortBootpPOperationalState, vrIpRdbStorageType=vrIpRdbStorageType, ipCapabilitiesBE01A=ipCapabilitiesBE01A, vrPpIpPortLogicalIfOspfIfNbrOperTable=vrPpIpPortLogicalIfOspfIfNbrOperTable, vrIpEgpStateEntry=vrIpEgpStateEntry, vrIpOspfIndex=vrIpOspfIndex, vrIpNsApply=vrIpNsApply, vrPpIpPortLogicalIfRipIfStatTable=vrPpIpPortLogicalIfRipIfStatTable, vrIpBootpPpEInReplies=vrIpBootpPpEInReplies, vrIpMcastPimSmDomainRpSetRowStatus=vrIpMcastPimSmDomainRpSetRowStatus, vrIpTcpTcpEntryLocalAddressIndex=vrIpTcpTcpEntryLocalAddressIndex, vrIpTunnelSepRowStatusTable=vrIpTunnelSepRowStatusTable, vrIpEgpExportNetStorageType=vrIpEgpExportNetStorageType, vrIpEgpOutMsgs=vrIpEgpOutMsgs, vrIpMcastStaticRouteRowStatusEntry=vrIpMcastStaticRouteRowStatusEntry, vrIpOspfHostRowStatusTable=vrIpOspfHostRowStatusTable, vrIpEgpExportComponentName=vrIpEgpExportComponentName, vrIpMcastIgmpGcVersion1HostTimer=vrIpMcastIgmpGcVersion1HostTimer, vrIpOspfRowStatusEntry=vrIpOspfRowStatusEntry, vrIpMcastIgmpGcComponentName=vrIpMcastIgmpGcComponentName, vrIpIfPPName=vrIpIfPPName, vrIpUdpListenEntryComponentName=vrIpUdpListenEntryComponentName, vrPpIpPortOperMtu=vrPpIpPortOperMtu, vrIpNsStorageType=vrIpNsStorageType, vrIpStaticRouteProvTable=vrIpStaticRouteProvTable, vrPpIpPortRowStatusTable=vrPpIpPortRowStatusTable, vrIpAdminControlEntry=vrIpAdminControlEntry, vrIpRipExportNetIndex=vrIpRipExportNetIndex, vrIpTcpTcpEntryRowStatusTable=vrIpTcpTcpEntryRowStatusTable, vrIpEgpNbrProvEntry=vrIpEgpNbrProvEntry, vrIpEgpOutErrors=vrIpEgpOutErrors, vrIpFwdGatewayIndex=vrIpFwdGatewayIndex, vrPpIpPortSnmpOperStatus=vrPpIpPortSnmpOperStatus, vrIpMcastPimSmDomainDiscardRegisterStopMsg=vrIpMcastPimSmDomainDiscardRegisterStopMsg, vrIpOspfVirtIfRetransInterval=vrIpOspfVirtIfRetransInterval, vrIpTcpRowStatus=vrIpTcpRowStatus, vrIpMcastStaticRoute=vrIpMcastStaticRoute, vrIpOspfRowStatus=vrIpOspfRowStatus, vrIpMcastFwdOifOutProtocolPortName=vrIpMcastFwdOifOutProtocolPortName, vrIpBootpStateEntry=vrIpBootpStateEntry, vrIpMcastPimSmDomainDiscardAssertMsg=vrIpMcastPimSmDomainDiscardAssertMsg, vrIpMcastPimSmDomainCRpCandidateRpPreference=vrIpMcastPimSmDomainCRpCandidateRpPreference, vrIpEgpImportIndex=vrIpEgpImportIndex, vrIpIcmpInEchos=vrIpIcmpInEchos, vrIpOspfStubRowStatus=vrIpOspfStubRowStatus, vrIpMcastCtsTable=vrIpMcastCtsTable, vrIpOspfExportProvEntry=vrIpOspfExportProvEntry, vrIpOspfVirtNbrRowStatus=vrIpOspfVirtNbrRowStatus, vrIpMcastPimSmDomainCRpRowStatus=vrIpMcastPimSmDomainCRpRowStatus, vrIpOspfVirtIfNbrRouterIdIndex=vrIpOspfVirtIfNbrRouterIdIndex, vrIpOspfAreaAuthType=vrIpOspfAreaAuthType, vrIpMcastPimSmDomainRxBsrMsg=vrIpMcastPimSmDomainRxBsrMsg, vrIpStaticRouteProvEntry=vrIpStaticRouteProvEntry, vrIpRipUsageState=vrIpRipUsageState, vrIpTcpStatsEntry=vrIpTcpStatsEntry, vrIpNsIndex=vrIpNsIndex, vrIpOspfVirtNbrLsRetransQlen=vrIpOspfVirtNbrLsRetransQlen, vrIpMcastIgmp=vrIpMcastIgmp, vrIpRipImportNetIpAddress=vrIpRipImportNetIpAddress, vrPpIpPortLogicalIfRipIfNbrRowStatusTable=vrPpIpPortLogicalIfRipIfNbrRowStatusTable, vrIpOspfVirtNbrOperTable=vrIpOspfVirtNbrOperTable, vrIpMcastPimSmDomainTxRegisterMsg=vrIpMcastPimSmDomainTxRegisterMsg, vrPpIpPortLogicalIfRipIfNbrIndex=vrPpIpPortLogicalIfRipIfNbrIndex, vrPpIpPortLogicalIfOspfIfNbrLsRetransQlen=vrPpIpPortLogicalIfOspfIfNbrLsRetransQlen, vrIpMcastPgProvEntry=vrIpMcastPgProvEntry, vrIpMcastPgRowStatusEntry=vrIpMcastPgRowStatusEntry, vrIpRipStorageType=vrIpRipStorageType, vrIpOspfAggregate=vrIpOspfAggregate, vrIpMcastPimNbrIfIndex=vrIpMcastPimNbrIfIndex, vrIpSnmpOperStatus=vrIpSnmpOperStatus, vrIpEgpExportNetProvTable=vrIpEgpExportNetProvTable, vrIpMcastPimSmDomainProvEntry=vrIpMcastPimSmDomainProvEntry, vrIpIcmpInTimestamps=vrIpIcmpInTimestamps, vrIpEgpNbrEventTrigger=vrIpEgpNbrEventTrigger, vrIpMcastPimSmOperationalState=vrIpMcastPimSmOperationalState, vrIpBootpRowStatusEntry=vrIpBootpRowStatusEntry, vrPpIpPortLogicalIfIgmpIfOperTable=vrPpIpPortLogicalIfIgmpIfOperTable, vrIpRdbComponentName=vrIpRdbComponentName, vrIpArpDynHostRowStatusTable=vrIpArpDynHostRowStatusTable, vrIpRipExportProvEntry=vrIpRipExportProvEntry, vrIpMcastFwdOif=vrIpMcastFwdOif, vrIpMcastAdminControlTable=vrIpMcastAdminControlTable, vrIpForwarding=vrIpForwarding, vrPpIpPortBootpPAdminState=vrPpIpPortBootpPAdminState, vrIpRipImportRowStatusEntry=vrIpRipImportRowStatusEntry, vrIpEgpExportStorageType=vrIpEgpExportStorageType, vrPpIpPortRelayBcCount=vrPpIpPortRelayBcCount, vrIpBootpProvTable=vrIpBootpProvTable, vrIpTunnelUsageState=vrIpTunnelUsageState, vrIpEgpExportRowStatus=vrIpEgpExportRowStatus, vrIpOspfAggregateComponentName=vrIpOspfAggregateComponentName, vrIpMcastPimSmDomainComponentName=vrIpMcastPimSmDomainComponentName, vrPpIpPortLogicalIfRipIfPoisonReverseFlag=vrPpIpPortLogicalIfRipIfPoisonReverseFlag, vrPpIpPortLogicalIfOspfIfTOSComponentName=vrPpIpPortLogicalIfOspfIfTOSComponentName, vrIpStaticUsageState=vrIpStaticUsageState, vrIpStaticRouteRowStatus=vrIpStaticRouteRowStatus, vrIpStaticRoute=vrIpStaticRoute, vrIpIfRowStatus=vrIpIfRowStatus, vrIpMcastIgmpIndex=vrIpMcastIgmpIndex, vrIpOspfAggregateAreaIdIndex=vrIpOspfAggregateAreaIdIndex, vrIpMcastPimSmDomainCRpStorageType=vrIpMcastPimSmDomainCRpStorageType, vrIpBootpProvEntry=vrIpBootpProvEntry, vrIpOspfSnmpOperStatus=vrIpOspfSnmpOperStatus, vrIpRipRowStatusTable=vrIpRipRowStatusTable, vrIpMcastFwdAge=vrIpMcastFwdAge, vrIpMcastPimNbrRowStatusEntry=vrIpMcastPimNbrRowStatusEntry, vrIpTcpTcpEntryOperTable=vrIpTcpTcpEntryOperTable, vrIpProvTable=vrIpProvTable, vrIpMcastPimSmDomainRpSetRpSetHoldTime=vrIpMcastPimSmDomainRpSetRpSetHoldTime, vrPpIpPortBootpPAddrRowStatus=vrPpIpPortBootpPAddrRowStatus, vrIpRipExportProtocol=vrIpRipExportProtocol, vrPpIpPortNsIndex=vrPpIpPortNsIndex, vrIpRipQueryResponses=vrIpRipQueryResponses, vrIpOspfVirtNbr=vrIpOspfVirtNbr, vrIpUdpComponentName=vrIpUdpComponentName, vrIpOspfVirtIfRtrDeadInterval=vrIpOspfVirtIfRtrDeadInterval, vrIpIcmpOutParmProbs=vrIpIcmpOutParmProbs, vrIpOspfAreaRowStatusEntry=vrIpOspfAreaRowStatusEntry, vrIpEgpNbrOutErrors=vrIpEgpNbrOutErrors, vrIpOspfExtLsdbRouterIdIndex=vrIpOspfExtLsdbRouterIdIndex, vrIpFwdIfIndex=vrIpFwdIfIndex, vrIpIfOperEntry=vrIpIfOperEntry, vrPpIpPortRowStatus=vrPpIpPortRowStatus, vrIpOspfExportNetListRowStatus=vrIpOspfExportNetListRowStatus, vrIpEgpExportOspfTag=vrIpEgpExportOspfTag, vrIpOspfNbrPermanence=vrIpOspfNbrPermanence, vrIpIcmpSendRedirect=vrIpIcmpSendRedirect, vrIpComponentName=vrIpComponentName, vrIpStaticDiscardStorageType=vrIpStaticDiscardStorageType, vrIpOspfHostAreaId=vrIpOspfHostAreaId, vrIpMcastFwdSrcMaskIndex=vrIpMcastFwdSrcMaskIndex, ipGroupBE=ipGroupBE, vrIpEgpImportProvTable=vrIpEgpImportProvTable, vrIpTcpEstabResets=vrIpTcpEstabResets, vrPpIpPortLogicalIfProvTable=vrPpIpPortLogicalIfProvTable, vrIpOspfExtLsdbAdvertisement=vrIpOspfExtLsdbAdvertisement, vrIpTcpAttemptFails=vrIpTcpAttemptFails, vrIpRelayBCPortOperEntry=vrIpRelayBCPortOperEntry, vrPpIpPortComponentName=vrPpIpPortComponentName, vrIpStaticStateEntry=vrIpStaticStateEntry, vrIpCtsTable=vrIpCtsTable, vrPpIpPortBootpPAddrEntry=vrPpIpPortBootpPAddrEntry, vrIpArpDynHostStorageType=vrIpArpDynHostStorageType, vrIpStaticStateTable=vrIpStaticStateTable, vrIpUdpStatsTable=vrIpUdpStatsTable, vrPpIpPortLogicalIfNetMask=vrPpIpPortLogicalIfNetMask, vrIpCacheStateTable=vrIpCacheStateTable, vrPpIpPortNsOutgoingFilter=vrPpIpPortNsOutgoingFilter, vrIpInAddrErrors=vrIpInAddrErrors, vrPpIpPortLogicalIfLinkToMulStaticGpTable=vrPpIpPortLogicalIfLinkToMulStaticGpTable, vrPpIpPortNsComponentName=vrPpIpPortNsComponentName, vrIpRipExportEgpAsId=vrIpRipExportEgpAsId, vrIpEgpExportNetComponentName=vrIpEgpExportNetComponentName, vrIpMcastIgmpRowStatus=vrIpMcastIgmpRowStatus, vrIpOspfNbrOperTable=vrIpOspfNbrOperTable, vrIpCtsEntry=vrIpCtsEntry, vrPpIpPortLogicalIfOspfIfOperTable=vrPpIpPortLogicalIfOspfIfOperTable, vrIpMcastIgmpGcExpiryTime=vrIpMcastIgmpGcExpiryTime, vrIpEgpNbrMode=vrIpEgpNbrMode, vrIpTcpMaxConn=vrIpTcpMaxConn, vrPpIpPortBootpPRelayForwardStatus=vrPpIpPortBootpPRelayForwardStatus, vrIpIfStorageType=vrIpIfStorageType, vrPpIpPortLogicalIfOspfIfTOSProvEntry=vrPpIpPortLogicalIfOspfIfTOSProvEntry, vrIpMcastPimSmDomainCBsrComponentName=vrIpMcastPimSmDomainCBsrComponentName, vrPpIpPortLogicalIfRipIf=vrPpIpPortLogicalIfRipIf, vrIpStateTable=vrIpStateTable, vrPpIpPortStorageType=vrPpIpPortStorageType, vrIpRelayBCPort=vrIpRelayBCPort, vrIpTunnelSepProvTable=vrIpTunnelSepProvTable, vrIpTcpPassiveOpens=vrIpTcpPassiveOpens, vrIpMcastPimSmDomainBsrExpiryTimer=vrIpMcastPimSmDomainBsrExpiryTimer, vrIpRoutingDiscards=vrIpRoutingDiscards, vrIpCacheTotalLookups=vrIpCacheTotalLookups, vrIpMcast=vrIpMcast, vrPpIpPortLogicalIfRipIfRowStatusTable=vrPpIpPortLogicalIfRipIfRowStatusTable, vrPpIpPortLogicalIfPimSmIfOperTable=vrPpIpPortLogicalIfPimSmIfOperTable, vrIpTunnelRowStatus=vrIpTunnelRowStatus, vrPpIpPortLogicalIfPimSmIfHelloInterval=vrPpIpPortLogicalIfPimSmIfHelloInterval, vrIpIfInterfaceAddressIndex=vrIpIfInterfaceAddressIndex, vrIpArpHost=vrIpArpHost, vrIpUdpRowStatusEntry=vrIpUdpRowStatusEntry, vrIpMcastPimSmRowStatus=vrIpMcastPimSmRowStatus, vrIpMcastPimSmDomainOperEntry=vrIpMcastPimSmDomainOperEntry, vrIpStateEntry=vrIpStateEntry, vrPpIpPortLogicalIfIgmpIfIndex=vrPpIpPortLogicalIfIgmpIfIndex, vrIpOspfOperStatusTable=vrIpOspfOperStatusTable, vrIpTcpRowStatusTable=vrIpTcpRowStatusTable, vrIpMcastIgmpStateEntry=vrIpMcastIgmpStateEntry, vrIpNsLocalInFilter=vrIpNsLocalInFilter, vrPpIpPortLogicalIfIgmpIfVersion=vrPpIpPortLogicalIfIgmpIfVersion, vrIpOspfAreaOperTable=vrIpOspfAreaOperTable, vrIpCacheOperationalState=vrIpCacheOperationalState, vrIpBootpHopDiscardThreshold=vrIpBootpHopDiscardThreshold, vrIpBootpRowStatusTable=vrIpBootpRowStatusTable, vrIpRipImportNetRowStatusEntry=vrIpRipImportNetRowStatusEntry, vrIpOspfExportMetric=vrIpOspfExportMetric, vrIpMcastPimSmDomainRpSetOperTable=vrIpMcastPimSmDomainRpSetOperTable, vrIpRelayBCRowStatusEntry=vrIpRelayBCRowStatusEntry, vrIpMcastFwdOifOperTable=vrIpMcastFwdOifOperTable)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-IpMIB", vrIpMcastCacheStatsStateEntry=vrIpMcastCacheStatsStateEntry, vrIpRowStatusTable=vrIpRowStatusTable, vrPpIpPortLogicalIfPimSmIfProvTable=vrPpIpPortLogicalIfPimSmIfProvTable, vrIpOspfLsdbRowStatus=vrIpOspfLsdbRowStatus, vrIpArpDynHostCosIndex=vrIpArpDynHostCosIndex, vrIpOspfExtLsdbLsdbTypeIndex=vrIpOspfExtLsdbLsdbTypeIndex, vrIpEgpImportRowStatus=vrIpEgpImportRowStatus, vrIpArpHostProvTable=vrIpArpHostProvTable, vrIpMcastPgLinkToPolicyUserEntry=vrIpMcastPgLinkToPolicyUserEntry, vrIpIcmpOutTimestampReps=vrIpIcmpOutTimestampReps, vrIpBootpStorageType=vrIpBootpStorageType, vrPpIpPortLogicalIfOspfIfBackupDesignatedRouter=vrPpIpPortLogicalIfOspfIfBackupDesignatedRouter, vrIpEgpExportAdvertiseStatus=vrIpEgpExportAdvertiseStatus, vrPpIpPortLogicalIfRipIfNetworkRouteStatus=vrPpIpPortLogicalIfRipIfNetworkRouteStatus, vrPpIpPortBootpPInRequestErrors=vrPpIpPortBootpPInRequestErrors, vrIpOspfNbrAddressIndex=vrIpOspfNbrAddressIndex, vrIpOspfExportNetListRowStatusEntry=vrIpOspfExportNetListRowStatusEntry, vrIpNsApplyFilter=vrIpNsApplyFilter, vrIpArpDynHostNcPhysAddress=vrIpArpDynHostNcPhysAddress, vrIpOspfAdminState=vrIpOspfAdminState, vrIpEgpStateTable=vrIpEgpStateTable, vrIpOspfVersionNumber=vrIpOspfVersionNumber, vrIpMcastDomainOperTable=vrIpMcastDomainOperTable, vrPpIpPortCosPolicyAssignment=vrPpIpPortCosPolicyAssignment, vrIpMcastRowStatusTable=vrIpMcastRowStatusTable, vrIpIfRowStatusEntry=vrIpIfRowStatusEntry, vrPpIpPortLogicalIfRipIfNbrStorageType=vrPpIpPortLogicalIfRipIfNbrStorageType, vrIpMcastPimNbrStorageType=vrIpMcastPimNbrStorageType, vrIpEgpExportProvEntry=vrIpEgpExportProvEntry, vrIpEgpNbrGenerateDefaultRoute=vrIpEgpNbrGenerateDefaultRoute, vrIpNsApplyIpMask1=vrIpNsApplyIpMask1, vrIpOspfNbrOperEntry=vrIpOspfNbrOperEntry, vrIpOspfLsdbChecksum=vrIpOspfLsdbChecksum, vrPpIpPortMaxTxUnit=vrPpIpPortMaxTxUnit, vrPpIpPortLogicalIfOspfIfTOSMetricTosIndex=vrPpIpPortLogicalIfOspfIfTOSMetricTosIndex, vrPpIpPortLogicalIfOspfIfNbrComponentName=vrPpIpPortLogicalIfOspfIfNbrComponentName, vrIpOspfStubProvEntry=vrIpOspfStubProvEntry, vrIpStaticDiscardComponentName=vrIpStaticDiscardComponentName, vrIpArpRowStatus=vrIpArpRowStatus, vrIpOspfAreaProvEntry=vrIpOspfAreaProvEntry, vrPpIpPortSourceRouteEndStationSupport=vrPpIpPortSourceRouteEndStationSupport, vrIpUdpListenEntryRowStatus=vrIpUdpListenEntryRowStatus, vrPpIpPortLogicalIfIgmpIfRowStatusEntry=vrPpIpPortLogicalIfIgmpIfRowStatusEntry, vrIpMcastStaticRowStatus=vrIpMcastStaticRowStatus, vrPpIpPortSnmpAdminStatus=vrPpIpPortSnmpAdminStatus, vrIpBootpOperStatusEntry=vrIpBootpOperStatusEntry, vrIpRipOperationalState=vrIpRipOperationalState, vrIpOspf=vrIpOspf, vrIpMcastFwd=vrIpMcastFwd, vrPpIpPortArpNoLearn=vrPpIpPortArpNoLearn, vrIpRelayBCRelayNdStatus=vrIpRelayBCRelayNdStatus, vrIpRipExportNetComponentName=vrIpRipExportNetComponentName, vrPpIpPortNs=vrPpIpPortNs, vrIpInUnknownProtos=vrIpInUnknownProtos, vrIpOspfVirtIfOperEntry=vrIpOspfVirtIfOperEntry, vrPpIpPortLogicalIfOspfIfState=vrPpIpPortLogicalIfOspfIfState, vrIpOspfStubMetricType=vrIpOspfStubMetricType, vrPpIpPortBootpPProvTable=vrPpIpPortBootpPProvTable, vrIpMcastStaticRouteRowStatus=vrIpMcastStaticRouteRowStatus, vrIpMcastPimNbrExpiryTimer=vrIpMcastPimNbrExpiryTimer, vrIpTunnelSepEncapType=vrIpTunnelSepEncapType, vrIpBootp=vrIpBootp, vrIpRipSnmpOperStatus=vrIpRipSnmpOperStatus, vrIpTcpRetransSegs=vrIpTcpRetransSegs, vrIpOspfExtLsdbComponentName=vrIpOspfExtLsdbComponentName, vrIpProvEntry=vrIpProvEntry, vrIpOspfExportProtocol=vrIpOspfExportProtocol, vrIpEgpImport=vrIpEgpImport, vrIpRipImportNet=vrIpRipImportNet, vrPpIpPortAdminControlTable=vrPpIpPortAdminControlTable, vrIpMcastIgmpGcRowStatusTable=vrIpMcastIgmpGcRowStatusTable, vrIpEgpAsId=vrIpEgpAsId, vrIpRdbRowStatus=vrIpRdbRowStatus, vrIpRelayBCPortRelayBcUdpCount=vrIpRelayBCPortRelayBcUdpCount)

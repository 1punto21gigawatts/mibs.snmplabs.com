#
# PySNMP MIB module Fore-DS1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Fore-DS1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:16:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint")
asx, = mibBuilder.importSymbols("Fore-Common-MIB", "asx")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, IpAddress, Gauge32, Integer32, MibIdentifier, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, NotificationType, Counter32, ObjectIdentity, Unsigned32, Counter64, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "IpAddress", "Gauge32", "Integer32", "MibIdentifier", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "NotificationType", "Counter32", "ObjectIdentity", "Unsigned32", "Counter64", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
foreDs1 = ModuleIdentity((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7))
if mibBuilder.loadTexts: foreDs1.setLastUpdated('9911050000Z')
if mibBuilder.loadTexts: foreDs1.setOrganization('FORE')
if mibBuilder.loadTexts: foreDs1.setContactInfo(' Postal: FORE Systems Inc. 1000 FORE Drive Warrendale, PA 15086-7502 Tel: +1 724 742 6900 Email: nm_mibs@fore.com Web: http://www.fore.com')
if mibBuilder.loadTexts: foreDs1.setDescription('Fore DS1 mib module for supporting the DS1 port module.')
ds1ConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1))
ds1StatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2))
ds1ConfTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1), )
if mibBuilder.loadTexts: ds1ConfTable.setStatus('current')
if mibBuilder.loadTexts: ds1ConfTable.setDescription('A table of DS1 switch port configuration information.')
ds1ConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1), ).setIndexNames((0, "Fore-DS1-MIB", "ds1ConfBoard"), (0, "Fore-DS1-MIB", "ds1ConfModule"), (0, "Fore-DS1-MIB", "ds1ConfPort"))
if mibBuilder.loadTexts: ds1ConfEntry.setStatus('current')
if mibBuilder.loadTexts: ds1ConfEntry.setDescription('A table entry containing DS1 configuration information for each port. Not all RFC1406 configuration table variables are included, and some are modified.')
ds1ConfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1ConfBoard.setStatus('current')
if mibBuilder.loadTexts: ds1ConfBoard.setDescription("The index of this port's switch board.")
ds1ConfModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1ConfModule.setStatus('current')
if mibBuilder.loadTexts: ds1ConfModule.setDescription('The network module of this port.')
ds1ConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1ConfPort.setStatus('current')
if mibBuilder.loadTexts: ds1ConfPort.setDescription('The number of this port.')
ds1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ds1Other", 1), ("ds1ESF", 2), ("ds1D4", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1LineType.setStatus('current')
if mibBuilder.loadTexts: ds1LineType.setDescription('This variable indicates the variety of DS1 Line implementing this circuit. The type of circuit affects the number of bits per second that the circuit can reasonably carry, as well as the interpretation of the usage and error statistics. This variable is defined in the rfc1406 configuration table as dsx1LineType. According to rfc1406, the different values are: ds1ESF Extended SuperFrame DS1 ds1D4 AT&T D4 format DS1.')
ds1LineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ds1Other", 1), ("ds1JBZS", 2), ("ds1B8ZS", 3), ("ds1HDB3", 4), ("ds1ZBTSI", 5), ("ds1AMI", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1LineCoding.setStatus('current')
if mibBuilder.loadTexts: ds1LineCoding.setDescription('This variable describes the variety of Zero Code suppression used on this link, which in turn affects a number of its characteristics. ds1B8ZS (2) refers to the use of specified pattern of normal bits and bipolar violations which are used to replaced sequences of eight zero bits. This variable is defined in the rfc1406 configuration table as dsx1LineCoding.')
ds1SendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ds1SendNoCode", 1), ("ds1SendLineCode", 2), ("ds1SendPayloadCode", 3), ("ds1SendResetCode", 4), ("ds1SendQRS", 5), ("ds1Send511Pattern", 6), ("ds1Send3in24Pattern", 7), ("ds1SendOtherTestPattern", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1SendCode.setStatus('current')
if mibBuilder.loadTexts: ds1SendCode.setDescription('This variable indicates what type of code is being sent across the DS1 interface by the device. The values mean: ds1SendNoCode sending looped or normal data ds1SendLineCode sending request for a line loopback ds1SendPayloadCode sending a request for a payload loopback ds1SendResetCode sending a loopback termination request ds1SendQRS sending a Quasi-Random Signal (QRS) test pattern ds1Send511Pattern sending a 511 bit fixed test pattern ds1Send3in24Pattern sending a fixed test pattern of 3 bits set in 24 ds1SendTestPattern sending a test pattern other than the above.')
ds1ReceiveCode = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ds1ReceiveNoCode", 1), ("ds1ReceiveLineCode", 2), ("ds1ReceivePayloadCode", 3), ("ds1ReceiveResetCode", 4), ("ds1SendQRS", 5), ("ds1Send511Pattern", 6), ("ds1Send3in24Pattern", 7), ("ds1SendOtherTestPattern", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1ReceiveCode.setStatus('current')
if mibBuilder.loadTexts: ds1ReceiveCode.setDescription('This variable indicates the type of code that was received across the DS interface. The values mean: ds1ReceiveNoCode receiving looped or normal data ds1ReceiveLineCode receiving request for a line loopback ds1ReceivePayloadCode receiving a request for a payload loopback ds1ReceiveResetCode receiving a loopback deactivation request ds1ReceiveQRS receiving a Quasi-Random Signal (QRS) test pattern ds1Receive511Pattern receiving a 511 bit fixed test pattern ds1Receive3in24Pattern receiving a fixed test pattern of 3 bits set in 24 ds1ReceiveTestPattern receiving a test pattern other than the above.')
ds1LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ds1NoLoop", 1), ("ds1LineLoop", 2), ("ds1PayloadLoop", 3), ("ds1DiagLoop", 4), ("ds1OtherLoop", 5))).clone('ds1NoLoop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1LoopbackConfig.setStatus('current')
if mibBuilder.loadTexts: ds1LoopbackConfig.setDescription("This variable represents the loopback configuration of the DS1 interface. This variable is defined in the rfc1406 configuration table as dsx1LoopbackConfig, with slightly different values. ds1NoLoop (1) means that the interface is not in a loopback state. ds1LineLoop (2) means that cells that are processed by the receiving component are not written into the receive FIFO, but into the transmit FIFO for retransmission. ds1PayloadLoop (3) means that the receive signal is looped back for retransmission after it has passed through the port's reframing function. ds1DiagLoop (4) means that the transmit data stream is looped back to the receiver. ds1OtherLoop (5) means that the interface is in a loopback that is not defined here.")
ds1TxClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rxTiming", 1), ("localTiming", 2))).clone('localTiming')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1TxClockSource.setStatus('current')
if mibBuilder.loadTexts: ds1TxClockSource.setDescription('The source of the transmit clock. rxTiming(1) indicated that the recovered receive clock is used as the transmit clock. localTiming(2) indicates that a local source clock is used as the transmit clock. To determine which local source clock is used advise the ntGlobalClock in the netmodTimingTable for this netmod (refer to the Fore-Switch-MIB for more information).')
ds1LineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1LineStatus.setStatus('current')
if mibBuilder.loadTexts: ds1LineStatus.setDescription('This variable indicates the Line Status of the interface. A similar object is defined in the rfc1406 configuration table as dsx1LineStatus. The variable contains loopback state information and failure state information. It is a bit map represented as a sum. The ds1NoAlarm should be set if and only if no other flag is set. The various bit positions are: 1 No Alarm. 2 Receiving PLCP Yellow Alarm Indication. 4 Transmitting PLCP Yellow alarm indication. 8 Receiving PLCP LOF. 16 Receiving DS1 Yellow Alarm Indication. 32 Transmiting DS1 Yellow Alarm Indication. 64 Receiving AIS failure indication. 128 Receiving LOF failure indication. 256 Receiving LOS failure indication. 512 Loopback State. 1024 Receiving a test pattern. 2048 Other failures. 4096 Receiving Excessive CRC Errors. 32768 Receiving LCD failure indication.')
ds1IdleUnassignedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unassigned", 1), ("idle", 2))).clone('unassigned')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1IdleUnassignedCells.setStatus('current')
if mibBuilder.loadTexts: ds1IdleUnassignedCells.setDescription("This variable indicates the types of cells that should be sent in case there is no real data to send. According to the ATM Forum, Unassigned cells should be sent (octet 1-3 are 0's, octet 4 is 0000xxx0, where x is 'don't care'). According to the CCITT specifications, Idle cells should be sent (everything is '0' except for the CLP bit which is '1'). By default, unassigned cells are transmitted is case there is no data to send.")
ds1LineTypeFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ds1Hcs", 2), ("ds1Plcp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1LineTypeFraming.setStatus('current')
if mibBuilder.loadTexts: ds1LineTypeFraming.setDescription('This variable indicates the way ATM cells are constructed from the DS1 stream. ds1Hcs(2) indicates that the ATM cells are constructed upon the Header Check Sequence (HCS) inside the ATM cell header. ds1Plcp(3) indicates that the ATM cells are constructed from the DS1 PLCP (Physical Layer Convergence Protocol) bits.')
ds1LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("ds1LineLt110", 1), ("ds1Line110-220", 2), ("ds1Line220-330", 3), ("ds1Line330-440", 4), ("ds1Line440-550", 5), ("ds1Line550-660", 6), ("ds1LineGt655", 7), ("ds1LineLt110Alt", 9), ("ds1Line110-220Alt", 10), ("ds1Line220-330Alt", 11), ("ds1Line330-440Alt", 12), ("ds1Line440-550Alt", 13), ("ds1Line550-660Alt", 14), ("ds1LineGt655Alt", 15))).clone('ds1LineLt110')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1LineLength.setStatus('current')
if mibBuilder.loadTexts: ds1LineLength.setDescription('This variable represents the length of the physical cable connected to the ds1 port. The user has to set this object to match the physical cable in order to get the netmod to receive the signal on the cable. The different values are: ds1LineLt110 (1) means the line is shorter than 110 ft, ds1Line110-220 (2) means the line length is between 110 and 220 ft, ds1Line220-330 (3) means the line length is between 220 and 330 ft, ds1Line330-440 (4) means the line length is between 330 and 440 ft, ds1Line440-550 (5) means the line length is between 440 and 550 ft, ds1Line550-660 (6) means the line length is between 550 and 660 ft, ds1LineGt655 (7) means the line is longer than 655 ft.')
ds1RxScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("descrambling", 1), ("noDescrambling", 2))).clone('noDescrambling')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1RxScrambling.setStatus('current')
if mibBuilder.loadTexts: ds1RxScrambling.setDescription('This variable indicates whether the information is being descrambled on receiving. It should be set the same as the transmitting side.')
ds1TxScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("scrambling", 1), ("noScrambling", 2))).clone('noScrambling')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1TxScrambling.setStatus('current')
if mibBuilder.loadTexts: ds1TxScrambling.setDescription('This variable indicates whether the information (48 octet payload) is being scrambled before transmitting. It should be set the same as the receiving side.')
ds1TxPRBS = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("invert", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1TxPRBS.setStatus('current')
if mibBuilder.loadTexts: ds1TxPRBS.setDescription('This variable controls the Pseudo-Random Bit Sequence Generator (PRSG) which generates an unframed 2^15-1 test sequence as define in Recommendation O.151. The pattern may be inverted.')
ds1CRCErrThrSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 19), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1CRCErrThrSeconds.setStatus('current')
if mibBuilder.loadTexts: ds1CRCErrThrSeconds.setDescription('This variable represents the consecutive number of BAD/GOOD seconds to detect/clear an Excessive CRC Error Defect. The range of values it can take is between 2 and 10 inclusive.')
ds1CRCErrThrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1CRCErrThrErrors.setStatus('current')
if mibBuilder.loadTexts: ds1CRCErrThrErrors.setDescription('This variable is a threshold for the number of CRC Errors per second and is used as a parameter to the Excessive CRC Error Defect. If the number of errors exceeds the threshold, the particular second is declared BAD, otherwise it is declared GOOD.')
ds1CRCErrFailEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1CRCErrFailEnable.setStatus('current')
if mibBuilder.loadTexts: ds1CRCErrFailEnable.setDescription("This variable controls whether declaration of an Excessive CRC Error Defect forces the port's operState to Down.")
ds1SigFailBer = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1SigFailBer.setStatus('current')
if mibBuilder.loadTexts: ds1SigFailBer.setDescription('This is the exponent of 10 for the current signal fail bit error rate (BER) threshold for this port. The value -4, for example, represents a BER of 1E-4. This variable is only applicable when ds1BerErrorModel is set to errorModelRandom.')
ds1SigDegradeBer = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1SigDegradeBer.setStatus('current')
if mibBuilder.loadTexts: ds1SigDegradeBer.setDescription('This is the exponent of 10 for the current signal degrade bit error rate (BER) threshold for this port. The value -8, for example, represents a BER of 1E-8. This variable is only applicable when ds1BerErrorModel is set to errorModelRandom.')
ds1BerErrorModel = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("errorModelNone", 0), ("errorModelRandom", 1), ("errorModelBurst", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1BerErrorModel.setStatus('current')
if mibBuilder.loadTexts: ds1BerErrorModel.setDescription('This is the error distribution model to be used to identify signal degrade and signal fail conditions. errorModelRandom selects a random error distribution and declares signal conditions based on the thresholds set in ds1SigDegradeBer and ds1SigFailBer. errorModelBurst selects a burst error model and declares signal degrade conditions based on the thresholds set in ds1CRCErrThrSeconds and ds1CRCErrThrErrors. errorModelNone disables detection of signal conditions.')
ds1BerState = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("berStateOk", 0), ("berStateSigDegrade", 1), ("berStateSigFail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1BerState.setStatus('current')
if mibBuilder.loadTexts: ds1BerState.setDescription('This value describes the current state of the port as determined through bit error rate analysis.')
ds1FramingTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1), )
if mibBuilder.loadTexts: ds1FramingTable.setStatus('current')
if mibBuilder.loadTexts: ds1FramingTable.setDescription('A table of DS1 framing statistics information.')
ds1FramingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1), ).setIndexNames((0, "Fore-DS1-MIB", "ds1FramingBoard"), (0, "Fore-DS1-MIB", "ds1FramingModule"), (0, "Fore-DS1-MIB", "ds1FramingPort"))
if mibBuilder.loadTexts: ds1FramingEntry.setStatus('current')
if mibBuilder.loadTexts: ds1FramingEntry.setDescription('A table entry containing DS1 framing statistics information.')
ds1FramingBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingBoard.setStatus('current')
if mibBuilder.loadTexts: ds1FramingBoard.setDescription("The index of this port's switch board.")
ds1FramingModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingModule.setStatus('current')
if mibBuilder.loadTexts: ds1FramingModule.setDescription('The network module of this port.')
ds1FramingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingPort.setStatus('current')
if mibBuilder.loadTexts: ds1FramingPort.setDescription('The number of this port.')
ds1FramingLOSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingLOSs.setStatus('current')
if mibBuilder.loadTexts: ds1FramingLOSs.setDescription('The number of seconds in which Loss Of Signal (LOS) errors have been detected.')
ds1FramingLCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingLCVs.setStatus('current')
if mibBuilder.loadTexts: ds1FramingLCVs.setDescription('The number of Line Code Violations (LCV) that have been detected.')
ds1FramingFERRs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingFERRs.setStatus('current')
if mibBuilder.loadTexts: ds1FramingFERRs.setDescription('The number of Framing ERRor (FERR) events that have been detected.')
ds1FramingOOFs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingOOFs.setStatus('current')
if mibBuilder.loadTexts: ds1FramingOOFs.setDescription('The number of Out Of Frame (OOF) error events that have been detected.')
ds1FramingAISs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingAISs.setStatus('current')
if mibBuilder.loadTexts: ds1FramingAISs.setDescription('The number of seconds in which Alarm Indication Signals (AIS) have been detected. AIS indicates that an upstream failure has been detected by the far end.')
ds1FramingB8ZSPatterns = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingB8ZSPatterns.setStatus('deprecated')
if mibBuilder.loadTexts: ds1FramingB8ZSPatterns.setDescription('The number of seconds in which B8ZS Pattern events have been detected.')
ds1Framing8Zeros = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1Framing8Zeros.setStatus('deprecated')
if mibBuilder.loadTexts: ds1Framing8Zeros.setDescription('The number of seconds in which 8 Zeros events have been detected.')
ds1Framing16Zeros = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1Framing16Zeros.setStatus('deprecated')
if mibBuilder.loadTexts: ds1Framing16Zeros.setDescription('The number of seconds in which 16 Zeros events have been detected.')
ds1FramingYellowAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingYellowAlarms.setStatus('current')
if mibBuilder.loadTexts: ds1FramingYellowAlarms.setDescription('The number of seconds in which Yellow Alarm events have been detected.')
ds1FramingRedAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingRedAlarms.setStatus('current')
if mibBuilder.loadTexts: ds1FramingRedAlarms.setDescription('The number of seconds in which Red Alarm events have been detected.')
ds1FramingBEEs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingBEEs.setStatus('current')
if mibBuilder.loadTexts: ds1FramingBEEs.setDescription('The number of Bit Encoding Error (BEE) events that have been detected. A Bit Error Event is defined as a CRC-6 error in ESF.')
ds1FramingPRBSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingPRBSs.setStatus('current')
if mibBuilder.loadTexts: ds1FramingPRBSs.setDescription('The number of seconds in which Pseudo Random Bit Sequence (PRBS) patterns have been detected.')
ds1FramingBERs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1FramingBERs.setStatus('current')
if mibBuilder.loadTexts: ds1FramingBERs.setDescription('The number of PRBS Bit ERror events that have been detected.')
ds1PlcpTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2), )
if mibBuilder.loadTexts: ds1PlcpTable.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpTable.setDescription('A table of DS1 Physical Layer Convergence Protocol (Procedure) statistics information.')
ds1PlcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1), ).setIndexNames((0, "Fore-DS1-MIB", "ds1PlcpBoard"), (0, "Fore-DS1-MIB", "ds1PlcpModule"), (0, "Fore-DS1-MIB", "ds1PlcpPort"))
if mibBuilder.loadTexts: ds1PlcpEntry.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpEntry.setDescription('A table entry containing DS1 PLCP statistics information.')
ds1PlcpBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PlcpBoard.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpBoard.setDescription("The index of this port's switch board.")
ds1PlcpModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PlcpModule.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpModule.setDescription('The network module of this port.')
ds1PlcpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PlcpPort.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpPort.setDescription('The number of this port.')
ds1PlcpBIP8s = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PlcpBIP8s.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpBIP8s.setDescription('Number of BIP-8 (Bit Interleaved Parity - 8) error events. The BIP-8 is calculated over the Path Overhead field and the associated ATM cell of the previous frame. A BIP-N is a method of error monitoring. An N bit code is generated by the transmitting equipment in such a manner that the first bit of the code provides even parity over the first bit of all N-bit sequences in the previous VT SPE, the second bit provides even parity over the second bits of all N-bit sequences within the specified portion, etc.')
ds1PlcpFERRs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PlcpFERRs.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpFERRs.setDescription('Number of Physical Layer Convergence Protocol (PLCP) octet error events.')
ds1PlcpFEBEs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PlcpFEBEs.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpFEBEs.setDescription('Number of ATM Far End Block Error (FEBE) events.')
ds1PlcpLOFs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PlcpLOFs.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpLOFs.setDescription('The number of seconds in which Loss Of Frame (LOF) errors were detected by the PLCP (Physical Layer Convergence Protocol) receiver. LOF is declared when an Out-Of-Frame state persists for more than 1ms. LOF is removed when in-frame state persists for more than 12ms.')
ds1PlcpYellows = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PlcpYellows.setStatus('current')
if mibBuilder.loadTexts: ds1PlcpYellows.setDescription('The number of seconds in which Yellow alarm errors were detected by the PLCP (Physical Layer Convergence Protocol) receiver. Yellow alarm is asserted when 10 consecutive yellow signal bits are set to logical 1. Yellow signals are used to alert upstream terminals of a downstream failure in order to initiate trunk conditioning on the failure circuit.')
ds1AtmTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3), )
if mibBuilder.loadTexts: ds1AtmTable.setStatus('current')
if mibBuilder.loadTexts: ds1AtmTable.setDescription('A table of DS1 ATM statistics information.')
ds1AtmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1), ).setIndexNames((0, "Fore-DS1-MIB", "ds1AtmBoard"), (0, "Fore-DS1-MIB", "ds1AtmModule"), (0, "Fore-DS1-MIB", "ds1AtmPort"))
if mibBuilder.loadTexts: ds1AtmEntry.setStatus('current')
if mibBuilder.loadTexts: ds1AtmEntry.setDescription('A table entry containing DS1 ATM statistics information.')
ds1AtmBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmBoard.setStatus('current')
if mibBuilder.loadTexts: ds1AtmBoard.setDescription("The index of this port's switch board.")
ds1AtmModule = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmModule.setStatus('current')
if mibBuilder.loadTexts: ds1AtmModule.setDescription('The network module of this port.')
ds1AtmPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmPort.setStatus('current')
if mibBuilder.loadTexts: ds1AtmPort.setDescription('The number of this port.')
ds1AtmHCSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmHCSs.setStatus('current')
if mibBuilder.loadTexts: ds1AtmHCSs.setDescription('Number of header check sequence (HCS) error events. The HCS is a CRC-8 calculation over the first 4 octets of the ATM cell header.')
ds1AtmRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmRxCells.setStatus('current')
if mibBuilder.loadTexts: ds1AtmRxCells.setDescription('Number of ATM cells that were received.')
ds1AtmTxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmTxCells.setStatus('current')
if mibBuilder.loadTexts: ds1AtmTxCells.setDescription('Number of non-null ATM cells that were transmitted.')
ds1AtmUHCSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmUHCSs.setStatus('current')
if mibBuilder.loadTexts: ds1AtmUHCSs.setDescription('Number of uncorrectable header check sequence (UHCS) error events. The HCS is a CRC-8 calculation over the first 4 octets of the ATM cell header.')
ds1AtmCHCSs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmCHCSs.setStatus('current')
if mibBuilder.loadTexts: ds1AtmCHCSs.setDescription('Number of correctable header check sequence (UHCS) error events. The HCS is a CRC-8 calculation over the first 4 octets of the ATM cell header.')
ds1AtmLCDs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 1, 1, 7, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1AtmLCDs.setStatus('current')
if mibBuilder.loadTexts: ds1AtmLCDs.setDescription('The number of seconds in which Loss of Cell Delineation (LCD) has occurred. An LCD defect is detected when an out of cell delination state has persisted for 4ms. An LCD defect is cleared when the sync state has been maintained for 4ms.')
mibBuilder.exportSymbols("Fore-DS1-MIB", ds1PlcpYellows=ds1PlcpYellows, ds1ConfModule=ds1ConfModule, ds1Framing8Zeros=ds1Framing8Zeros, ds1AtmModule=ds1AtmModule, ds1PlcpEntry=ds1PlcpEntry, ds1PlcpBoard=ds1PlcpBoard, ds1CRCErrFailEnable=ds1CRCErrFailEnable, ds1SendCode=ds1SendCode, ds1AtmUHCSs=ds1AtmUHCSs, ds1SigDegradeBer=ds1SigDegradeBer, ds1LineLength=ds1LineLength, ds1AtmHCSs=ds1AtmHCSs, ds1PlcpBIP8s=ds1PlcpBIP8s, ds1FramingBoard=ds1FramingBoard, foreDs1=foreDs1, ds1Framing16Zeros=ds1Framing16Zeros, ds1TxScrambling=ds1TxScrambling, ds1ConfBoard=ds1ConfBoard, ds1CRCErrThrSeconds=ds1CRCErrThrSeconds, ds1FramingLCVs=ds1FramingLCVs, ds1FramingB8ZSPatterns=ds1FramingB8ZSPatterns, ds1FramingTable=ds1FramingTable, ds1AtmTxCells=ds1AtmTxCells, ds1AtmCHCSs=ds1AtmCHCSs, ds1AtmRxCells=ds1AtmRxCells, ds1PlcpModule=ds1PlcpModule, ds1PlcpFERRs=ds1PlcpFERRs, ds1FramingFERRs=ds1FramingFERRs, ds1FramingLOSs=ds1FramingLOSs, ds1TxPRBS=ds1TxPRBS, PYSNMP_MODULE_ID=foreDs1, ds1LineType=ds1LineType, ds1IdleUnassignedCells=ds1IdleUnassignedCells, ds1CRCErrThrErrors=ds1CRCErrThrErrors, ds1AtmBoard=ds1AtmBoard, ds1AtmPort=ds1AtmPort, ds1LineTypeFraming=ds1LineTypeFraming, ds1TxClockSource=ds1TxClockSource, ds1StatsGroup=ds1StatsGroup, ds1FramingEntry=ds1FramingEntry, ds1FramingAISs=ds1FramingAISs, ds1ReceiveCode=ds1ReceiveCode, ds1FramingBEEs=ds1FramingBEEs, ds1RxScrambling=ds1RxScrambling, ds1ConfGroup=ds1ConfGroup, ds1FramingPort=ds1FramingPort, ds1PlcpFEBEs=ds1PlcpFEBEs, ds1BerState=ds1BerState, ds1ConfPort=ds1ConfPort, ds1PlcpTable=ds1PlcpTable, ds1FramingYellowAlarms=ds1FramingYellowAlarms, ds1FramingModule=ds1FramingModule, ds1FramingRedAlarms=ds1FramingRedAlarms, ds1AtmTable=ds1AtmTable, ds1AtmLCDs=ds1AtmLCDs, ds1SigFailBer=ds1SigFailBer, ds1ConfTable=ds1ConfTable, ds1FramingBERs=ds1FramingBERs, ds1LineStatus=ds1LineStatus, ds1PlcpLOFs=ds1PlcpLOFs, ds1FramingPRBSs=ds1FramingPRBSs, ds1FramingOOFs=ds1FramingOOFs, ds1BerErrorModel=ds1BerErrorModel, ds1LoopbackConfig=ds1LoopbackConfig, ds1AtmEntry=ds1AtmEntry, ds1PlcpPort=ds1PlcpPort, ds1ConfEntry=ds1ConfEntry, ds1LineCoding=ds1LineCoding)

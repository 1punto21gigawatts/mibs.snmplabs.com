#
# PySNMP MIB module CISCO-VISM-MODULE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-VISM-MODULE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:18:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
voice, cardSpecific = mibBuilder.importSymbols("BASIS-MIB", "voice", "cardSpecific")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
ModuleIdentity, MibIdentifier, Integer32, iso, TimeTicks, Gauge32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, NotificationType, ObjectIdentity, IpAddress, Counter32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "Integer32", "iso", "TimeTicks", "Gauge32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "NotificationType", "ObjectIdentity", "IpAddress", "Counter32", "Unsigned32")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
ciscoVismModuleMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 82))
ciscoVismModuleMIB.setRevisions(('2005-10-17 00:00', '2005-03-01 00:00', '2004-05-24 00:00', '2004-03-09 00:00', '2003-10-31 00:00', '2003-06-18 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoVismModuleMIB.setRevisionsDescriptions(('Added objects - vismOamLoopbackSetCLP - vismFaxDeJitterMode - vismFaxDeJitterInitialDelay - vismPvcAlarmLogEnable - vismPvcAlarmLogAdminTimer - vismPvcAlarmLogOperTimer - vismContinuityCheckCellEnable ', 'Added objects - vismSplModemToneBitMap - vismSSRCEnable ', 'Corrected description for vismConfigChangeTypeBitMap Added new objects - vismBearerIpPingEnable - vismTrapFilteringEnable - vismTrapIntegerValue ', 'Deprecated object: -vismAisSuppression Modified description for vismConfigChangeTypeBitMap ', 'Update descriptions in MIB. Add new object vismAisSuppression to vismSystemGrp. ', 'Initial version of the MIB. The content of this MIB was originally available in SMIv1 version. The MIB has been converted to SMIv2 version and descriptions of some of the objects have been modified.',))
if mibBuilder.loadTexts: ciscoVismModuleMIB.setLastUpdated('200510170000Z')
if mibBuilder.loadTexts: ciscoVismModuleMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoVismModuleMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoVismModuleMIB.setDescription('This MIB module contains VISM Card specific attributes and call statistics information for VISM service module. ')
vismSystemPerfStats = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 25))
vismCallStats = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 13))
vismConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17))
vismIpGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1))
vismVoIpGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2))
vismDspGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3))
vismSystemGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4))
vismTrapObjGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5))
vismAal2Grp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6))
vismInteropGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 7))
class VismFaxDeJitterMode(TextualConvention, Integer32):
    description = "This mode parameter selects the de-jitter mode to be used during fax calls. 'unSpecified': Unspecified mode of operation 'adaptive': In this mode of operation, the delay applied by the de-jitter buffer is adapted based on observations of the incoming packet jitter. 'fixedWithTS': Indicates use of a constant jitter buffer size with a timestamp check on the incoming packets, as defined by the object vismFaxDeJitterInitialDelay. 'fixedWithoutTS': Indicates use of a constant jitter buffer size, which is defined by the object vismFaxDeJitterInitialDelay. 'passThrough': This mode is designed to support de-jittering while in pass-through mode for the transport of modem and fax signals. "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("unSpecified", 1), ("adaptive", 2), ("fixedWithTS", 3), ("fixedWithoutTS", 4), ("passThrough", 5))

class VismFaxDeJitterInitDelay(TextualConvention, Integer32):
    description = 'General category of fax initial delays in milliseconds supported on the module.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100))
    namedValues = NamedValues(("unSpecified", 0), ("five", 5), ("ten", 10), ("fifteen", 15), ("twenty", 20), ("twentyfive", 25), ("thirty", 30), ("thirtyfive", 35), ("forty", 40), ("fortyfive", 45), ("fifty", 50), ("fiftyfive", 55), ("sixty", 60), ("sixtyfive", 65), ("seventy", 70), ("seventyfive", 75), ("eighty", 80), ("eightyfive", 85), ("ninety", 90), ("ninetyfive", 95), ("hundred", 100))

vismCPUUtilization = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 25, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismCPUUtilization.setStatus('current')
if mibBuilder.loadTexts: vismCPUUtilization.setDescription('This is the percentage of time CPU is in non-idle state. ')
vismMemoryUtilization = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 25, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismMemoryUtilization.setStatus('current')
if mibBuilder.loadTexts: vismMemoryUtilization.setDescription('This is the percentage of memory in use by VISM. ')
vismSysPerfClrButton = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 25, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSysPerfClrButton.setStatus('current')
if mibBuilder.loadTexts: vismSysPerfClrButton.setDescription("This variable is used to clear all the CPU and Memory Utilization statistics. 'noaction(1)': The value return on a GET operation. 'clear(2)' : Clear alarm. ")
vismTotalCalls = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 13, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismTotalCalls.setStatus('current')
if mibBuilder.loadTexts: vismTotalCalls.setDescription('Total number of calls made in VISM. ')
vismSuccessfulCalls = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 13, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismSuccessfulCalls.setStatus('current')
if mibBuilder.loadTexts: vismSuccessfulCalls.setDescription('Total number successful calls made in VISM. ')
vismFailedCalls = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismFailedCalls.setStatus('current')
if mibBuilder.loadTexts: vismFailedCalls.setDescription('Total number failed calls made in VISM. ')
vismCallStatsClrButton = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 5, 5, 13, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noaction", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCallStatsClrButton.setStatus('current')
if mibBuilder.loadTexts: vismCallStatsClrButton.setDescription("This variable is used to clear all the VISM call statistics. 'noaction': The value return on a GET operation 'clear': Clear all alarm ")
vismIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismIpAddress.setStatus('current')
if mibBuilder.loadTexts: vismIpAddress.setDescription('This object identifies the IP address of VISM card. Each VISM card has its own IP address. IP address for each VISM card is required to communicate with the call agent. This object is applicable if the object vismMode is in VoIP(Voice Over IP) or Switched mode. ')
vismSubNetMask = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSubNetMask.setStatus('current')
if mibBuilder.loadTexts: vismSubNetMask.setDescription('SUB-NETMASK of the VISM IP interface. This object is applicable if the object vismMode is in VoIP or Switched mode. ')
vismControlTos = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(96)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismControlTos.setStatus('current')
if mibBuilder.loadTexts: vismControlTos.setDescription('This object is used to provision the bitmask used for the TOS (Type Of Service) octet for cells carrying the control xGCP(Gateway Control Protocol) traffic. Default value 96 = 0x60 => Precedence = 3 and TOS nibble = 0 The bitmask can be only a byte value. ')
vismBearerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerIpAddress.setStatus('current')
if mibBuilder.loadTexts: vismBearerIpAddress.setDescription('The bearer IP address of VISM card. This is an optional second IP address of the VISM card. If this bearer IP address is defined, the vismIpAddress automatically becomes the control IP address. ')
vismBearerSubNetMask = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerSubNetMask.setStatus('current')
if mibBuilder.loadTexts: vismBearerSubNetMask.setDescription('Bearer SUB-NETMASK of the VISM IP interface. This optional bearer subnet mask must be provided when vismBearerIpAddress is provided. ')
vismBearerTos = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(160)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerTos.setStatus('current')
if mibBuilder.loadTexts: vismBearerTos.setDescription('This object is used to provision the bitmask used for the TOS octet for cells carrying VoIP bearer RTP(Real-time Transport Protocol) traffic. Default value 160 = 0xA0 => Precedence = 5 and TOS nibble = 0 The bitmask can be only a byte value. ')
vismRtcpRepInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(500, 15000)).clone(5000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRtcpRepInterval.setStatus('current')
if mibBuilder.loadTexts: vismRtcpRepInterval.setDescription('This attribute defines the RTCP(Real-time Transport Control Protocol) report interval (defined in RFC 1889). This indicates the interval at which the RTCP reports should be sent to the participating members. The RTCP reports are not sent at a fixed rate at this interval. Rather, this value is used as a base value to arrive at a random number between 0.5 and 1.5 times this value. This interval timer also serves the purpose of RTP packets receive timer. At every vismRtcpRecvMultiplier times this interval, where vismRtcpRecvMultiplier is specified in the MIB object below, a check is made on a VoIP connection (which is in SENDRECV or RECVONLY xGCP modes) to see if any RTP packets have been received. If not, gateway-initiated DLCX should be sent to the Call Agent. Currently, this interval timer is a card-specific value, which means the value is configurable on a per card basis and not on a per call basis. This value is applicable for VoIP adaptation only. ')
vismRtpReceiveTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRtpReceiveTimer.setStatus('current')
if mibBuilder.loadTexts: vismRtpReceiveTimer.setDescription('This object defines whether the RTP packets receive timer on the VISM needs to be enabled or not. For some VoIP applications if a connection is in send-recv mode or recv-only mode, after the bearer cut-through is done, the RTP stream should be monitored for RTP packets. If there are no packets received within a time interval specified by 5 seconds, then a Gateway initiated DLCX (Delete connection) should be sent on that connection. If this object is set to enable, the RTP stream is monitored. Otherwise, it is not monitored. This value is applicable for VoIP adaptation only. ')
vismPacketizationPeriod = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 20, 30, 40))).clone(namedValues=NamedValues(("tenms", 10), ("twentyms", 20), ("thirtyms", 30), ("fourtyms", 40))).clone('tenms')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPacketizationPeriod.setStatus('deprecated')
if mibBuilder.loadTexts: vismPacketizationPeriod.setDescription(' This object is used to provision the packetization period to be applied and is applicable for VoIP only. For VoAAL2 adaptations, the packetization period is derived from the profile table entry. For VoAAL1 adaptation, it is fixed at 5.875 ms.')
vismVoIpDtmfRelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpDtmfRelay.setStatus('current')
if mibBuilder.loadTexts: vismVoIpDtmfRelay.setDescription('This attribute defines whether the DTMF (Dual Tone Multi-Frequency) digits need to be transported to the other endpoint via NSE(Named Signal Event) packets. ')
vismVoIpCasTransport = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpCasTransport.setStatus('current')
if mibBuilder.loadTexts: vismVoIpCasTransport.setDescription('This attribute defines whether the CAS(Channel Associated Signaling) bits need to be transported to the other endpoint via NSE packets. ')
vismVoIpTripleRedundancy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpTripleRedundancy.setStatus('current')
if mibBuilder.loadTexts: vismVoIpTripleRedundancy.setDescription('This attribute defines whether triple redundancy is enabled or not. With triple redundancy, NSEs are sent three times at 20 ms intervals. For reliable channels, triple redundancy can be disabled in order to save the bandwidth and the processing overheads. ')
vismVoIpVADTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(250, 65535)).clone(250)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpVADTimer.setStatus('current')
if mibBuilder.loadTexts: vismVoIpVADTimer.setDescription('This attribute defines the hangover time for VAD(Voice Activity Detection) in milliseconds. Once the voice inactivity is detected, the gateway will wait for this duration before activating silence suppression. ')
vismVoIpNTECapabilityNegotiate = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 9), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpNTECapabilityNegotiate.setStatus('current')
if mibBuilder.loadTexts: vismVoIpNTECapabilityNegotiate.setDescription("This attribute defines whether the VISM has the capability to negotiate the list of events either NSE or NTE(Named Telephony Events), using rtpmap and fmtpmap in the SDP. If the value is 'true(1)', then VISM will accept rtpmap and fmtpmap in the SDP. Any events NSE/NTE not listed will be interpreted as not supported. If the value is 'false(2)', then VISM will neither include nor accept rtpmap for X-NSE & X-NTE, and fmtpmap. For the backward compatibility sake VISM will transmit DTMF digits using NSEs if the value is 'false(2).' ")
vismVoIpSIDPayloadType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(13)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpSIDPayloadType.setStatus('current')
if mibBuilder.loadTexts: vismVoIpSIDPayloadType.setDescription('This attribute sets the payload type of a RTP packet carrying SID(Silence Insertion Descriptor) which is sent to the other end when silence is detected. The default value is in accordance to RFC-3551. ')
vismVoIpDPvcOamCellGap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 5000)).clone(500)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpDPvcOamCellGap.setStatus('current')
if mibBuilder.loadTexts: vismVoIpDPvcOamCellGap.setDescription('This attribute defines the inter cell gap for dual PVC(Permanent Virtual Circuit) OAM (Operational and management) cells. ')
vismVoIpDPvcRetryCnt = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpDPvcRetryCnt.setStatus('current')
if mibBuilder.loadTexts: vismVoIpDPvcRetryCnt.setDescription('This attribute defines the threshold for failure of a PVC. If the number of consecutive OAM cells sent for which no ack was received equals this number then the connection is considered failed. ')
vismVoIpDPvcRecoverCnt = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpDPvcRecoverCnt.setStatus('current')
if mibBuilder.loadTexts: vismVoIpDPvcRecoverCnt.setDescription('This attribute defines the threshold for recovery of a PVC. If the number of consecutive OAM cells sent for which ack was received equals this number then the connection is considered recovered from failure. ')
vismRtcpRecvMultiplier = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismRtcpRecvMultiplier.setStatus('current')
if mibBuilder.loadTexts: vismRtcpRecvMultiplier.setDescription('The object vismRtcpRepInterval specified above defines an approximate RTCP report interval (defined in RFC 1889) which indicates the interval in milliseconds at which the RTCP reports should be sent to the participating members. The object vismRtcpRecvMultiplier defines how many times the RTCP reports may fail before exception condition activity may be done. The number of times specified in this MIB object times the RTCP Report Interval, a check is made on a VoIP connection (which is in SENDRECV or RECVONLY xGCP modes) to see if any RTP packets have been received. If not, gateway-initiated DLCX should be sent to the call agent. Currently, this interval multiplier is a card-specific value, which means the value is configurable on a per card basis and not on a per call basis. This value is applicable for VoIP adaptation only.')
vismVoIpLapdTrunkPVC = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("control", 1), ("bearer", 2))).clone('control')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpLapdTrunkPVC.setStatus('current')
if mibBuilder.loadTexts: vismVoIpLapdTrunkPVC.setDescription("This object should be used for VoIP Trunking applications and only if the signaling type is configured to be CCS(Common Channel Signaling). By default the PRI(Primary Rate Interface) D-channel information will be sent on the control channel. If the control network is totally separated from the bearer network then the user needs to set this object to 'bearer' to send his LAPD(Link Access Procedure on the D-channel) Trunk messages to the remote VISM. ")
vismVoIpEventNegotiationPolicy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("proprietary", 2), ("all", 3))).clone('proprietary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVoIpEventNegotiationPolicy.setStatus('current')
if mibBuilder.loadTexts: vismVoIpEventNegotiationPolicy.setDescription("This attribute defines whether or not the VISM should advertise the event codecs, NSE, NTE, or Cisco-rtp, in addition to the list of events specified by the call agent. If the value is 'none', then VISM will not include any more event codecs than what has been specified by the call agent. If the value is 'proprietary', then VISM can advertise proprietary event codecs in addition to the event codecs specified by the call agent. If the value is 'all', then VISM can advertise both proprietary as well as standard event codecs in addition to the event codecs specified by the call agent. ")
vismEcanCnfIdlePattern = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pattern1", 1), ("pattern2", 2), ("pattern3", 3), ("pattern4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismEcanCnfIdlePattern.setStatus('deprecated')
if mibBuilder.loadTexts: vismEcanCnfIdlePattern.setDescription("Echo Canceller pattern for Idle code. Mu-Law : 1 - 7f, 2 - ff, 3 - 7f or ff, 4 - f7 A-Law : 1 - None, 2 - 54, 3 - 55, 4 - Programmable Idle code. DEFVAL : 'pattern3' (7f or ff) for Mu-law and 'pattern2' (54) for A-Law. ")
vismEcanCnfIdleDirection = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("either", 2), ("send", 3), ("receive", 4))).clone('both')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismEcanCnfIdleDirection.setStatus('deprecated')
if mibBuilder.loadTexts: vismEcanCnfIdleDirection.setDescription('Echo Canceller Idle Direction. This determines in which direction the Idle code must be present. ')
vismCompCnfPacketSize = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(80, 80), ValueRangeConstraint(160, 160), )).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCompCnfPacketSize.setStatus('current')
if mibBuilder.loadTexts: vismCompCnfPacketSize.setDescription('Compressed output packet size - This value is used in the DSP(Digital Signal Processing) interface API commands to configure the DSPs for the maximum packet size. The valid values are 80 and 160 only. ')
vismERL = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("zerodb", 1), ("threedb", 2), ("sixdb", 3), ("worstdb", 4))).clone('sixdb')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismERL.setStatus('current')
if mibBuilder.loadTexts: vismERL.setDescription('This object is used to provision the return echo lost, i.e the db loss of the echo that the DSPs are supposed to cancel. ')
vismJitterDelayMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("adaptive", 2))).clone('fixed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismJitterDelayMode.setStatus('deprecated')
if mibBuilder.loadTexts: vismJitterDelayMode.setDescription(" This object is used to provision the jitter buffer mode to be apply to a call connection. The possible values are: 'fixed' : means use a constant jitter buffer size, which is defined by the object vismJitterInitialDelay. 'adaptive': means let the DSP pick the optimal value for the call connection. ")
vismJitterInitialDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100))).clone(namedValues=NamedValues(("zero", 1), ("five", 5), ("ten", 10), ("fifteen", 15), ("twenty", 20), ("twentyfive", 25), ("thirty", 30), ("thirtyfive", 35), ("fourty", 40), ("fortyfive", 45), ("fifty", 50), ("fiftyfive", 55), ("sixty", 60), ("sixtyfive", 65), ("seventy", 70), ("seventyfive", 75), ("eighty", 80), ("eightyfive", 85), ("ninty", 90), ("ninetyfive", 95), ("hundred", 100))).clone('fourty')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismJitterInitialDelay.setStatus('deprecated')
if mibBuilder.loadTexts: vismJitterInitialDelay.setDescription('Defines the jitter buffer size. If the vismJitterDelayMode is set to be fixed, the jitter buffer is fixed at this value for the call. If vismJitterDelayMode is adaptive, this is the initial jitter buffer size, and the DSP will adapt to an optimal size. The valid range for template 1 : 1,10,20,30,40,50,60,70, 80,90,100 The valid range for template 2 : 1,5,10,15,20,25,30,35, 40,45,50,55,60,65,70, 75,80,85,90,95,100. When the template of the card changes, either from template 1 to 2 or vice versa the value of this object will be implicitly set to default value. ')
vismAdaptiveGainControl = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAdaptiveGainControl.setStatus('current')
if mibBuilder.loadTexts: vismAdaptiveGainControl.setDescription("If set to 'on', the DSP will adjust the gain of the call connection to an optimal value. ")
vismDspHealth = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDspHealth.setStatus('current')
if mibBuilder.loadTexts: vismDspHealth.setDescription('This attribute indicates the health of the DSPs. It is a percentage of the total number of DSPs that are currently functional. ')
vismUpspeedCodec = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("g-711u", 1), ("g-711a", 2), ("g-726-32", 3), ("clearChannel", 4), ("g-723h", 5), ("g-723l", 6), ("g-726-16", 7), ("g-726-24", 8), ("g-726-40", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismUpspeedCodec.setStatus('current')
if mibBuilder.loadTexts: vismUpspeedCodec.setDescription("This object specifies the codec to be used when fax upspeed happens. The default value for this object is 'g711u' when the line type is T1 and 'g711a' when the line type is E1. This object is applicable only in the case of VoIP applications, for AAL2 the upspeedCodec is obtained from profile table and this object will have no affect. ")
vismPayloadType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPayloadType.setStatus('current')
if mibBuilder.loadTexts: vismPayloadType.setDescription('This object specifies the payload type to be used when fax upspeed happens. IANA values (0..95) are static payload and (96..127) are dynamic payload type. This object is applicable only in the case of VoIP applications, for AAL2 the upspeedCodec is obtained from profile table and this object will have no affect. ')
vismDSPHeartbeat = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDSPHeartbeat.setStatus('current')
if mibBuilder.loadTexts: vismDSPHeartbeat.setDescription('This object will specify the timer interval, DSP send a regular heartbeat messages from the DSP to the HOST Application. If the value is zero the Heartbeat message will be disabled. ')
vismFaxDeJitterMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 12), VismFaxDeJitterMode().clone('unSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFaxDeJitterMode.setStatus('current')
if mibBuilder.loadTexts: vismFaxDeJitterMode.setDescription('This object specifies the de-jitter mode to be used for the fax upspeed. This object is applicable only in the case of VoIP applications. ')
vismFaxDeJitterInitialDelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 3, 13), VismFaxDeJitterInitDelay().clone('unSpecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFaxDeJitterInitialDelay.setStatus('current')
if mibBuilder.loadTexts: vismFaxDeJitterInitialDelay.setDescription("This object defines the de-jitter buffer size for fax upspeed. If the vismFaxDeJitter Mode is set to be 'fixedWithTS' or 'fixedWithoutTS', the jitter buffer size is set to this value for the call. If vismDeJitterMode is 'adaptive', this is the initial jitter buffer size, and the DSP will adapt to an optimal size. If the vismDeJitterMode is 'passThrough', this value is ignored. ")
vismDaughterCardSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDaughterCardSerialNum.setStatus('current')
if mibBuilder.loadTexts: vismDaughterCardSerialNum.setDescription('A unique value for each VISM daughter card, entered in nvram by manufacturing. The serial number is on the non-volatile RAM on the VISM daughter card. ')
vismDaughterCardDescription = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDaughterCardDescription.setStatus('current')
if mibBuilder.loadTexts: vismDaughterCardDescription.setDescription('This object identifies the VISM daughter card. ')
vismDaughterCardHWRev = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismDaughterCardHWRev.setStatus('current')
if mibBuilder.loadTexts: vismDaughterCardHWRev.setDescription('This object identifies the hardware revision number for the daughter card. ')
vismEcanEncoding = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mu-law", 1), ("a-law", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismEcanEncoding.setStatus('current')
if mibBuilder.loadTexts: vismEcanEncoding.setDescription("The object identifies the voice encoding type, mu-law or a-law. 'mu-law' is returned for T1 lines and 'a-law' is returned for E1 lines. ")
vismMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 99, 100))).clone(namedValues=NamedValues(("voipSwitching", 1), ("aal2Trunking", 2), ("aal1Svc", 3), ("switchedVoipCASBh", 4), ("switchedVoipPRIBh", 5), ("switchedAal2CASBh", 6), ("switchedAal2Svc", 7), ("switchedAal2Pvc", 8), ("voipAndAal1Svc", 9), ("voipAndAal2Trunking", 10), ("superMode", 99), ("unknownMode", 100))).clone('voipSwitching')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismMode.setStatus('current')
if mibBuilder.loadTexts: vismMode.setDescription(" This attribute defines the connection model that the VISM card is configured to operate with. This object can be modified by CLI(Command Line Interface) only. The CLI 'cnfvismmode' can be used to set this object. VISM card will be reset after modifying this parameter for the VISM card to come up in the new mode. Each mode enables a set of features on the VISM card. The feature set for each of the above modes is : 'voipSwitching':VoIP mode. In this mode VISM interacts with the call agent using XGCP protocol, bearer path is VoIP. This mode is also used for VoIP applications that dosen't use call agent(VoIP Trunking). 'aal2Trunking': AAL2 Trunking mode. In this mode VISM does not interact with the call agent. Bearer Path is AAL2. 'aal1Svc' : AAL1 SVC(Switched Virtual Circuit) mode. In this mode VISM interacts with call agent using XGCP protocol over AAL5 control PVCs. In this mode, bearer path is VoAAL1 and the bearer connections are SVCs. i.e VISM dynamically sets-up and tears down bearer connections. 'switchedVoipCASBh', 'switchedVoipPRIBh', 'switchedAal2CASBh', 'switchedAal2Svc' and superMode are ignored. 'switchedAal2Pvc': Switched and trunked AAL2 PVC with CAS xGCP backhaul, CCS and CAS forwarding. 'switchedAal2Svc': Switched AAL2 SVC with PRI backhaul. 'voipAndAal1Svc': VoIP and ATM Groomer. 'voipAndAal2Trunking': VoIP Trunking And AAL2 Trunking. 'unknowMode': Unknown mode, when user change vismFeatureBitMap to a combination of Features that are not in the above modes. This object has to be synchronized with vismFeatureBitMap. When vismFeatureBitMap is changed this object will be implicitly set to the mode that has the right combination of features. ")
vismPrevMode = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("voipSwitching", 1), ("aal2Trunking", 2), ("aal1Svc", 3), ("aal2PvcSwitching", 4))).clone('voipSwitching')).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPrevMode.setStatus('deprecated')
if mibBuilder.loadTexts: vismPrevMode.setDescription('This attribute indicates the mode in which VISM was operating before the object vismMode value was changed. i.e It gives the value of vismMode before it got changed to the current value. When the card comes up in the default mode, the value of vismPrevMode will be the same as vismMode. Hence this object is no longer needed. ')
vismCacEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCacEnable.setStatus('current')
if mibBuilder.loadTexts: vismCacEnable.setDescription('This attribute describes whether CAC (Connection Admission Control) functionality needs to be applied on the VISM card, on a per PVC basis. For some applications, the CAC functionality may not be required and in that case, it has to be disabled on a card basis. ')
vismAvailableDs0Count = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 248))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismAvailableDs0Count.setStatus('current')
if mibBuilder.loadTexts: vismAvailableDs0Count.setDescription('This attribute describes the number of DS0s available for new connections on VISM. This is modified by the VISM firmware after each connection is setup. ')
vismAppliedTemplate = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismAppliedTemplate.setStatus('current')
if mibBuilder.loadTexts: vismAppliedTemplate.setDescription(' This attribute describes the Codec template currently configured on the VISM card. The value refers to an index to the vismCodecTemplateCnfGrpTable (defined in CISCO-VISM-CODEC-MIB MIB). This template is applicable for all connections on the card. When a switch is made to a new template, the number of channels (endpoints) in use will be checked to ensure the switch will not occur if there are more endpoints active at the present time than what the new template allow, the number of channels per template are specify in vismCodecTemplateMaxChanCount. Also whenever an attempt is made to add a new endpoint for any template, this template maximum number will limit the number of endpoints that may be added for this template. ')
vismTftpServerDn = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismTftpServerDn.setStatus('current')
if mibBuilder.loadTexts: vismTftpServerDn.setDescription("This object holds the domain name of the tftp server from where the CAS module will download the CAS files. This domain name can be resolved internally or externally. Before configuring this object the domain name should be added in the mgDomainNameTable(defined in CISCO-WAN-MG-MIB MIB) and at least one IP address (internal or external) should be associated with this domain name in mgcResolutionTable (defined in the same MIB). By default, the object is set to TFTPDOMAIN. Before the last entry corresponding to the tftp domain is deleted from the mgDomainNameTable or the last IP address associated with this object is deleted from mgcResolutionTable, it should be set to 'TFTPDOMAIN'. If the user configures 'localhost' to be the tftp server domain then the cas files will be downloaded from PXM(Processor Switch Module). If the user configures the domain name to be TFTPDOMIAN or localhost then that entry need not be present in mgDomainNameTable or mgcResolutionTable. ")
vismXgcpBearerNetworkType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ip", 1), ("atm", 2))).clone('ip')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismXgcpBearerNetworkType.setStatus('current')
if mibBuilder.loadTexts: vismXgcpBearerNetworkType.setDescription('This object specifies the network type to use in order to transport bearer traffic. The user can configure this to IP or ATM based on where the VISM will be located. If the call agent specifies the network type in the MGCP local connection options CRCX(Create Connection) request, then the configuration of this object will have no effect, else the value of this object will be used when sending CRCX response. ')
vismXgcpBearerVCType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pvc", 1), ("svc", 2))).clone('pvc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismXgcpBearerVCType.setStatus('current')
if mibBuilder.loadTexts: vismXgcpBearerVCType.setDescription('This object specifies the VC(Virtual Channel) type to use in order to transport bearer traffic. If the call agent specifies the VC type in the MGCP local connection options (CRCX request), then the configuration of this object will have no effect, else the value of this object will be used when sending CRCX response. ')
vismXgcpBearerConnectionType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("aal1Sdt", 1), ("aal2", 2), ("notApplicable", 3))).clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismXgcpBearerConnectionType.setStatus('current')
if mibBuilder.loadTexts: vismXgcpBearerConnectionType.setDescription("This object specifies the connection type used to transport bearer traffic. If the vismXgcpBearerNetworkType is chosen to be IP then the value of this object has to be/will be set to 'notApplicable'. If the call agent specifies the connection type in the MGCP local connection options (CRCX request), then the configuration of this object will have no effect, else the value of this object will be used when sending CRCX response. ")
vismBearerContinuityTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerContinuityTimer.setStatus('current')
if mibBuilder.loadTexts: vismBearerContinuityTimer.setDescription('This object specifies the co4 (bearer continuity) timer in millisecs. The timer will be started in the terminating/originating gateway for a duration as specified in this MIB object when a co3 message is sent from the terminating/originating gateway to the originating/terminating gateway. If the terminating/originating gateway does not receive co4 as an acknowledgement from the originating/termintaing gateway and the timer expires, gateway initiated DLCX is sent to the call agent from the terminating/originating gateway. This object is applicable when the call agent feature is available. ')
vismCodecNegotiationOption = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lcoRcdLcl", 1), ("lcoLclRcd", 2), ("rcdLcoLcl", 3), ("rcdLclLco", 4), ("lclLcoRcd", 5), ("lclRcdLco", 6))).clone('lcoRcdLcl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCodecNegotiationOption.setStatus('current')
if mibBuilder.loadTexts: vismCodecNegotiationOption.setDescription("This object helps in forming an ordered intersection of lists and one of the lists must be used in determining the resulting order of codecs. Lco - local connection options Rcd - remote connection description Lcl - local codec list If the value of this object is 'lcoRcdLcl' then effectively we are giving first priority to the local connection options sent by the call agent, followed by remote connection description sent by the remote gateway (CA) and the last priority will be to local codec list stored in VISM. If the value of this object is 'lcoLclRcd' then effectively we are giving first priority to local connection options sent by the call agent, followed by local codec list stored in VISM and the last priority will be to remote connection description sent by the remote gateway (or remote CA). If the value of this object is 'rcdLcoLcl' then effectively we are giving first priority to remote connection description sent by the remote gateway /call agent, followed by local connection options sent by the call agent and the last priority will be to the local codec list stored on the local gateway(VISM). If the value of this object is 'rcdLclLco' then effectively we are giving first priority to remote connection description sent by the remote gateway/CA followed by local codec list stored on the local gateway and the last priority will be to the local connection options sent by the call agent. If the value of this object is 'lclLcoRcd' then effectively we are giving first priority to local codec list stored on the local gateway (VISM) followed by local connection options sent by the call agent and the last priority will be to remote connection description sent by the remote gateway (or remote CA). If the value of this object is 'lclRcdLco' then effectively we are giving first priority to local codec list stored on the VISM followed by remote connection description sent by the remote gateway (or remote CA) and the last priority will be to local connection options sent by the call agent. ")
vismProfileNegotiationOption = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lcoRcdLcl", 1), ("lcoLclRcd", 2), ("rcdLcoLcl", 3), ("rcdLclLco", 4), ("lclLcoRcd", 5), ("lclRcdLco", 6))).clone('lcoRcdLcl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismProfileNegotiationOption.setStatus('current')
if mibBuilder.loadTexts: vismProfileNegotiationOption.setDescription("This object helps in forming an ordered intersection of lists and one of the lists must be used in determining the resulting order of profiles. Lco - local connection options Rcd - remote connection description Lcl - local codec list If the value of this object is 'lcoRcdLcl' then effectively we are giving first priority to the local connection options sent by the call agent, followed by remote connection description sent by the remote gateway (CA) and the last priority will be to local codec list stored in VISM. If the value of this object is 'lcoLclRcd' then effectively we are giving first priority to local connection options sent by the call agent, followed by local codec list stored in VISM and the last priority will be to remote connection description sent by the remote gateway (or remote CA). If the value of this object is 'rcdLcoLcl' then effectively we are giving first priority to remote connection description sent by the remote gateway /call agent, followed by local connection options sent by the call agent and the last priority will be to the local codec list stored on the local gateway(VISM). If the value of this object is 'rcdLclLco' then effectively we are giving first priority to remote connection description sent by the remote gateway followed by local codec list stored on the local gateway and the last priority will be to the local connection options sent by the CA. If the value of this object is 'lclLcoRcd' then effectively we are giving first priority to local codec list stored on the local gateway (VISM) followed by local connection options sent by the call agent and the last priority will be to remote connection description sent by the remote gateway (or remote CA). If the value of this object is 'lclRcdLco' then effectively we are giving first priority to local codec list stored on the VISM followed by remote connection description sent by the remote gateway (or remote CA) and the last priority will be to local connection options sent by the call agent. ")
vismCarrierLossPolicy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("previousCodec", 1), ("upspeedCodec", 2))).clone('previousCodec')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCarrierLossPolicy.setStatus('current')
if mibBuilder.loadTexts: vismCarrierLossPolicy.setDescription("This object defines the policy that needs to be applied when a carrier loss is detected. This states whether to switch to the pre-upspeed codec or to remain with the upspeed codec. This object is applicable in case of SVCs. This object will be applicable in case of PVC if the per PVC object - vismChanCarrierLossPolicy (defined in vismChanCacTable) is set to 'unspecified'. Configuring this object will not have any affect when card level CAC is disabled (vismCacEnable). ")
vismCacRejectionPolicy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delete", 1), ("maintain", 2))).clone('maintain')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCacRejectionPolicy.setStatus('current')
if mibBuilder.loadTexts: vismCacRejectionPolicy.setDescription("This attribute defines the policy that needs to be applied once the CAC function rejects the upspeeding of a connection, due to a fax/modem switch-over request. The applicable options are: 'delete' : To delete the connection that got rejected by CAC for upspeed. 'maintain' : To maintain the connection with the prior compression scheme. This object is applicable in case of SVCs. This object will be applicable in case of PVCs if the per PVC object - vismChanCacRejectionPolicy (defined in vismChanCacTable) is set to 'unspecified'. Configuring this object will not have any affect when card level CAC is disabled (vismCacEnable). ")
vismExtDnsServerDn = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 20), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismExtDnsServerDn.setStatus('current')
if mibBuilder.loadTexts: vismExtDnsServerDn.setDescription("This object refers to the domain name of the external DNS server which will be used to resolve other domain name. Currently this domain name can only be resolved internally. Therefore, before configuring this object not only the domain name has to be added in the mgDomainNameTable with resolution type 'internalOnly' but also at least one IP address has been added with this domain name in mgcResolutionTable. Before deleting external DNS server from mgDomainNameTable or deleting the last IP address associated with the external DNS server this object should be set to 'NULL'. After we change the value of this object to NULL, all the externally resolved IP address in mgcResolutionTable will be purged. By default this object will be set to 'NULL'. ")
vismFeatureBitMap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFeatureBitMap.setStatus('current')
if mibBuilder.loadTexts: vismFeatureBitMap.setDescription('This object denotes the bit map for VISM features. It indicates the current features that are enabled. It should be consistent with vismMode. When user change vismMode, this object is implicitly set to the feature combination that indicate to that mode. The change of vismFeatureBitMap will not cause VISM to reset and the configuration will not be cleared. For each bit, value 1 means the feature is enabled, 0 means disabled. Bit 0 - AAL1 adaptation Bit 1 - AAL2 adaptation Bit 2 - AAL5 adaptation (Bearer network type is IP). Bit 3 - Switching (with Call Agent) Bit 4 - Trunking (without Call Agent) Bit 5 - Bearer VC type is PVC. Bit 6 - Bearer VC type is SVC. Bit 7 - CAS signaling Bit 8 - PRI backhaul Bit 9 - CCS signaling Bit 10 - Domain Name For example, 0x5AC corresponds to vismMode 1 (VoipSwitching). Currently this object is not settable, it can only be set thru some debug commands. ')
vismVADTolerance = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVADTolerance.setStatus('current')
if mibBuilder.loadTexts: vismVADTolerance.setDescription('The value in this object refers to the customer accepted drop rate for voice connections when the bandwidth usage exceeds allowed value. The actual range of this object is 0.0001% - 1.00 % The unit is in percentage, since the default is 0.01 %, and since we cannot express such fractions in MIB , it is being multiplied by 10000 . However, when the underlying CAC module is notified of the change in this object, then the value has to be divided by a factor of 10000. Multiplication factor 10000 is picked as someone might be interested in a tolerance as low as 0.0001%. This object will be applicable in case of AAL2 SVCs where the user does not add a PVC and also this object will be applicable if the per PVC level object vismChanVADTolerance(defined in CISCO-VISM-CAC-MIB MIB) is configured to have a value of zero. Configuring this object will not have any affect when card level CAC is disabled (vismCacEnable). ')
vismVADDutyCycle = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(61)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismVADDutyCycle.setStatus('current')
if mibBuilder.loadTexts: vismVADDutyCycle.setDescription(' This object refers to the talk-spurts duty cycle. The unit is in percentage. When the value of this object is to be passed to underlying CAC module in VISM this value has to be divided by 100. This causes the actual range of this object to be 0.01 to 0.99 and not 0.01 to 1.00 as specified in the range of values above. Since a value of 100 will cause a floating point exception, this value is disallowed. The default value is 0.61 and since we cannot have fractions in a MIB variable the value is being multiplied by 100 and is expressed as 61. This object will be applicable in case of AAL2 SVCs where the user does not add a PVC and also this object will be applicable if the per PVC level object vismChanVADDutyCycle(defined in CISCO-VISM-CAC-MIB MIB) is configured to have a value of zero. Configuring this object will not have any affect when card level CAC is disabled (vismCacEnable). ')
vismAggregateTrafficClipping = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAggregateTrafficClipping.setStatus('current')
if mibBuilder.loadTexts: vismAggregateTrafficClipping.setDescription("This attribute defines the aggregate traffic clipping policy which is applicable to all bearer traffic generated at VISM card. The applicable options are: 'disable' : aggregate traffic clipping is disabled, VISM card traffic management does not perform aggregate traffic clipping. 'enable' : aggregate traffic clipping is enabled, VISM card traffic management performs aggregate traffic clipping. This is applicable to only AAL2 SVC voice bearer traffic. When aggregate traffic clipping is enabled, VISM card can discard cells which are exceeding VISM card aggregate SVC bandwidth which is specified as vismAggregateSvcBandwidth value. ")
vismAggregateSvcBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAggregateSvcBandwidth.setStatus('current')
if mibBuilder.loadTexts: vismAggregateSvcBandwidth.setDescription('The aggregate svc bandwidth is used for AAL2 SVC aggregate SVC CAC and also used for aggregate traffic clipping at VISM card when vismAggregateTrafficClipping is enabled. This is expressed in cells per second. This need to be configured for AAL2 SVC aggregate bandwidth call admission control to admit AAL2 SVC connections at VISM card. ')
vismBearerContinuityTest = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 26), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerContinuityTest.setStatus('current')
if mibBuilder.loadTexts: vismBearerContinuityTest.setDescription("This attribute defines whether the bearer continuity test for a connection will be performed at the time of call setup or not. When the vismBearerContinuityTest is enabled, the terminating media Gateway initiates a NSE/Type 3 packet towards the originating gateway and starts a timer defined by vismBearerContinuityTimer. The originating gateway, on receipt of co3, responds by sending a co4 to the terminating end. If the terminating gateway doesn't receive co4 NSE/Type 3 packet with in the time defined by co4 timer, it initiates a GW-initiated DLCX to the call agent which in turn deletes the connection. The value in this object will be utilized when the call agent does not specify this. ")
vismCaleaEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 27), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCaleaEnable.setStatus('current')
if mibBuilder.loadTexts: vismCaleaEnable.setDescription('This attribute describes whether CALEA (Communication Assistance for Law Enforcement Agency) functionality needs to be enabled on the VISM card. This attribute enables/disables this feature at a card level. This command is only applicable for CALEA enable image. ')
vismMaxConfNum = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismMaxConfNum.setStatus('current')
if mibBuilder.loadTexts: vismMaxConfNum.setDescription('Identify how many conference will be supported on a VISM card ')
vismLongDurationTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismLongDurationTimer.setStatus('current')
if mibBuilder.loadTexts: vismLongDurationTimer.setDescription('The long duration is the elapse time in hour to indicate a connection has been established for a given period of time. The default time is one hour. ')
vismContinuityCo1Timer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismContinuityCo1Timer.setStatus('current')
if mibBuilder.loadTexts: vismContinuityCo1Timer.setDescription('A 2010Hz tone is applied, if the co1(Continuity Tone 1) is specify as a signal the range is 2010Hz +/- 8Hz and if it is specify as an event the range is 2010Hz +/- 30Hz. The continuity tone is applied for the specified duration of time in seconds. ')
vismContinuityCo2Timer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismContinuityCo2Timer.setStatus('current')
if mibBuilder.loadTexts: vismContinuityCo2Timer.setDescription(' A 1780Hz tone is applied, if the co2(Continuity Tone 2) is specify as a signal the range is 1780Hz +/- 20Hz and if it is specify as an event the range is 1780Hz +/- 30Hz. The continuity tone is applied for the specified duration of time in seconds. ')
vismReverseCotTone = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 32), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismReverseCotTone.setStatus('current')
if mibBuilder.loadTexts: vismReverseCotTone.setDescription(' This attribute defines the direction of COT Tone that is sent in a 2w to 4w arrangement. The VISM responds to a request from the call agent through the M:conttest mode, it returns a 1780 Hz tone in response to a 2010 Hz go tone and vice versa. ')
vismSendDnEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 33), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSendDnEnable.setStatus('current')
if mibBuilder.loadTexts: vismSendDnEnable.setDescription("This will allow VISM to send domain name as part of Audit Enpoint response to the call agent when it is configured as 'true(1)'. ")
vismSendDataGramSize = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSendDataGramSize.setStatus('current')
if mibBuilder.loadTexts: vismSendDataGramSize.setDescription("Specify the size of datagram that should be sent when the vismSendDnEnable is set to 'true(1)'. Any value greater than the specified size will be rejected. ")
vismOamLoopThreshold = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismOamLoopThreshold.setStatus('current')
if mibBuilder.loadTexts: vismOamLoopThreshold.setDescription('Specify OAM loopback cell loss count before declaring a PVC alarm. ')
vismFreeDs0Threshold = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 248))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismFreeDs0Threshold.setStatus('current')
if mibBuilder.loadTexts: vismFreeDs0Threshold.setDescription('This attribute holds the threshold value of free DS0 counts on the VISM card. A trap is sent out if the number of free ds0s fall below this threshold. ')
vismCPUUtilizationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismCPUUtilizationThreshold.setStatus('current')
if mibBuilder.loadTexts: vismCPUUtilizationThreshold.setDescription('This attribute holds the threshold value of CPU utilization on the VISM card. A trap is sent out if the CPU utilization equals or exceeds this threshold. ')
vismMemoryUtilizationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismMemoryUtilizationThreshold.setStatus('current')
if mibBuilder.loadTexts: vismMemoryUtilizationThreshold.setDescription('This attribute holds the threshold value of memory utilization on the VISM card. A trap is sent out if the memory utilization equals or exceeds this threshold. ')
vismDualToneDetect = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 39), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDualToneDetect.setStatus('current')
if mibBuilder.loadTexts: vismDualToneDetect.setDescription('This object is use to enable/disable dual tone configuration. When the dual tone is enable and detected, the Marconi Application will upspeed to VBD(Voice Band Data) codec. ')
vismAisSuppression = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAisSuppression.setStatus('deprecated')
if mibBuilder.loadTexts: vismAisSuppression.setDescription('This object is used to enable/disable the AIS(Alarm Indication Signal) suppression functionality. When AIS suppression is enabled AIS and RDI(Remote Defect Indication)/FERF(Far End Receive Failure) alarm cells received from the network will not propagate to the line and cause an line alarm. NOTE: CID(Channel Identifier) alarms are not affected by this setting. ')
vismBearerIpPingEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 41), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismBearerIpPingEnable.setStatus('current')
if mibBuilder.loadTexts: vismBearerIpPingEnable.setDescription('This object is used to enable/disable the bearer IP ping response configuration. When set to true, the bearer IP ping feature will be enabled on the module and the bearer IP will respond to ping messages. When set to false, the bearer IP ping feature is disabled on the module. ')
vismTrapFilteringEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 42), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismTrapFilteringEnable.setStatus('current')
if mibBuilder.loadTexts: vismTrapFilteringEnable.setDescription('This object is used to enable/disable the trap filtering feature on the module. When set to true, the trap filtering feature is enabled on the module. When set to false, the trap filtering feature is disabled on the module.')
vismSplModemToneBitMap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 43), Bits().clone(namedValues=NamedValues(("vism1560980Tone", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSplModemToneBitMap.setStatus('current')
if mibBuilder.loadTexts: vismSplModemToneBitMap.setDescription('This bit map is applicable for any special modem tones that need to be enabled or disabled on the module. If a bit is set to 1, the tone detection is enabled. If the bit is set to 0, the tone detection is disabled. The values mean: vism1560980Tone: 1560/ 980Hz tone in used in special modem calls to carry encrypted data.')
vismSSRCEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 44), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismSSRCEnable.setStatus('current')
if mibBuilder.loadTexts: vismSSRCEnable.setDescription('This object is used to enable/disable more than one SSRC (Synchronization Source) per RTP session. When set to true, the module will accept more than one SSRC per RTP session. When set to false, the module will not allow more than one SSRC per RTP session.')
vismOamLoopbackSetCLP = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 45), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismOamLoopbackSetCLP.setStatus('current')
if mibBuilder.loadTexts: vismOamLoopbackSetCLP.setDescription('This object is used to set the cell loss priority of the oam loopback cell for all the PVCs. If set to true, all the CLP bits will be set to 1. If set to false, all the CLP bits will be set to 0. ')
vismPvcAlarmLogEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 46), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPvcAlarmLogEnable.setStatus('current')
if mibBuilder.loadTexts: vismPvcAlarmLogEnable.setDescription("This object specifies whether detailed alarm logging on all the PVC's on the module is enabled or disabled. If this object is true, detailed alarm logging for all the PVC's on the module will be enabled. If this object is false, detailed alarm logging for all the PVC's on the module will be disabled.")
vismPvcAlarmLogAdminTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 47), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(7200)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismPvcAlarmLogAdminTimer.setStatus('current')
if mibBuilder.loadTexts: vismPvcAlarmLogAdminTimer.setDescription('This object specifies the time for which the detailed alarm logging for all the PVCs on the module will remain active. The value in this object can be set and is valid only if vismPvcAlarmLogEnable is set to true. If this object is set to 0, it indicates that the alarm logging will remain active forever. Once set, this object can be overwritten as long as vismPvcAlarmLogEnable is true. If this is done, the vismPvcAlarmLogAdminTimer will be refreshed to take the new value set in this object.')
vismPvcAlarmLogOperTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 48), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: vismPvcAlarmLogOperTimer.setStatus('current')
if mibBuilder.loadTexts: vismPvcAlarmLogOperTimer.setDescription('This object specifies the time remaining in minutes for which the detailed alarm logging will remain enabled on all the PVCs on the module. When this value becomes 0, it indicates that all the PVCs on the module have run through the time specified in vismPvcAlarmLogOperTimer. This will cause the vismPvcAlarmLogEnable to be set to false. If vismPvcAlarmLogAdminTimer is overwritten with a new value, this object will also be set to reflect the new value.')
vismContinuityCheckCellEnable = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 4, 49), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismContinuityCheckCellEnable.setStatus('current')
if mibBuilder.loadTexts: vismContinuityCheckCellEnable.setDescription('This object is used to enable/disable the continuity check cell for all the PVCs on the module. If set to true, the module will transmit continuity check cells. If set to false, the module will disable the cell transmission. ')
vismXgcpSdpOst = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismXgcpSdpOst.setStatus('current')
if mibBuilder.loadTexts: vismXgcpSdpOst.setDescription("This object is used to enable/disable building of s=,t=,o= lines in SDP(Session Description Protocol) message. If this object is set to 'enable' then it indicates that the o=, s=, t= lines be built before sending SDP (Session Description Protocol). If it set to 'disable' then it indicates that the o=,s=,t= parameters need not be built for SDP. where o field indicates the owner/creator and session identifier s field indicates the session name t field indicates the duration while a session is valid. ")
vismDynamicPT = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismDynamicPT.setStatus('current')
if mibBuilder.loadTexts: vismDynamicPT.setDescription('This object is used to enable/disable dynamic payload type configuration on the VISM Card. ')
vismConfigChangeTypeBitMap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismConfigChangeTypeBitMap.setStatus('current')
if mibBuilder.loadTexts: vismConfigChangeTypeBitMap.setDescription('Configuration change Type BitMap used in vismTableChanged trap and vismScalarChanged trap. When used in vismTableChanged trap, the bits indicate the following: bit 0 set = mgcTable changed bit 1 set = mgEndpointTable changed bit 2 set = mgcResolutionTable changed bit 3 set = srcpPeerTable changed bit 4 set = vismDsx1Table changed bit 5 set = vismXgcpPeerTable changed bit 6 set = xgcpPackageTable changed bit 7 set = vismChanCacTable changed bit 8 set = vismCasVariantTable changed bit 9 set = vismCasXgcpVariantTable changed bit 10 set = vismAal2CidCnfTable changed bit 11 set = dsx0VismCnfTable changed bit 12 set = vismHdlcChanCnfTable changed bit 13 set = lineAssignmentTable changed bit 14 set = vismCodecCnfTable changed bit 15 set = vismLapdTable changed bit 16 set = vismRudpSessionCnfTable changed bit 17 set = aal2ProfilesGrpTable changed bit 18 set = mgDomainNameTable changed bit 19 set = vismPortCnfGrpTable changed bit 20 set = mgcRedundancyGrpTable changed bit 21 set = mgcRedundancyGrpParamTable changed bit 22 set = srcpPeerGrpParamTable changed bit 23 set = vismRtpConnGrpTable changed bit 24 set = vismCodecGenParmTable changed bit 25 set = t38FaxRelayGrpTable changed bit 26 set = mgcRedundancyProtocolTable changed bit 27 set = vismSessionSetTable changed bit 28 set = vismSessionGrpTable changed bit 29 set = cvcmABCDBitTemplateConfigTable changed bit 30 set = vismConfigToneDetectTable changed When used in vismScalarChanged trap, the bits indicate the following: bit 0 set = mediaGateway group changed bit 1 set = mediaGatewayEndpoint group changed bit 2 set = mediaGatewayControllerResolution group changed bit 3 set = srcpAdminObjects group changed bit 4 set = vismConfig group changed bit 5 set = vismXgcpCoreObjects group changed bit 6 set = xgcpCoreObjects group changed bit 7 set = xgcpExtensionObjects group changed bit 8 set = xgcpPackageObjects group changed bit 9 set = vismSvcAtmQosGrp Objects group changed bit 10 set = vismSvcTrfScalingGrp Objects group changed bit 11 set = vismSvcAal2CidGrp Objects group changed bit 12 set = srcpAdminRetryObjects Objects group changed bit 13 set = vismConfig IpGrp group objects changed bit 14 set = vismConfig VoipGrp group objects changed bit 15 set = vismConfig DspGrp group objects changed bit 16 set = vismConfig SystemGrp group objects changed bit 17 set = vismConfig Aal2Grp group objects changed bit 18 set = vismConfig InteropGrp group objects changed bit 19 set = announceControlGrp Objects group changed bit 20 set = vismXgcpEnhancementsObjects group changed bit 21 set = vismSequentialToneDetectGrp changed default value is 0, no change This MIB makes sense only in traps. A GET on this may not return a Useful result. ')
vismTrapIntIndex1 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismTrapIntIndex1.setStatus('current')
if mibBuilder.loadTexts: vismTrapIntIndex1.setDescription('This object is used only for the purpose of sending it in the trap varbind. This object is used for two purposes: 1. When the integer index of a SMIv2 table has to be sent, this object will be used instead of the actual index object. The instance value of the object will be the instance value of the actual index. 2. In the config change trap trapVismTableChange, to send the index value of the table entry which got changed. This object will contain the value of the first integer index. The NMS applications should not depend on the implementation of this object. The SNMP Requests(GET,GET-NEXT) may not be valid for this object. ')
vismTrapIntIndex2 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismTrapIntIndex2.setStatus('current')
if mibBuilder.loadTexts: vismTrapIntIndex2.setDescription('This object is used only for the purpose of sending it in the trap varbind. This object is used for two purposes: 1. This object will be used when the SMIv2 table has two index objects and the 2nd object is an integer. This object will be used instead of the actual second index object. The instance value of the object will be the instance value of the actual second index. 2. In the config change trap trapVismTableChange, to send the index value of the table entry which got changed. This object will contain the value of the second integer index. The NMS applications should not depend on the implementation of this object. The SNMP Requests(GET,GET-NEXT) may not be valid for this object. ')
vismTrapStrIndex1 = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 66))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vismTrapStrIndex1.setStatus('current')
if mibBuilder.loadTexts: vismTrapStrIndex1.setDescription('This object is used only for the purpose of sending it in the trap varbind. This object is used for two purposes: 1. When the OctetString index of a SMIv2 table has to be sent, this object will be used instead of the actual index object. The instance value of the object will be the instance value of the actual index. 2. In the config change trap trapVismTableChange, to send the index value of the table entry which got changed. This object will contain the value of the first OctetString index. The NMS applications should not depend on the implementation of this object. The SNMP Requests(GET,GET-NEXT) may not be valid for this object. ')
vismTrapIntegerValue = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vismTrapIntegerValue.setStatus('current')
if mibBuilder.loadTexts: vismTrapIntegerValue.setDescription('This object is used only for the purpose of sending it in the trap varbind. This object can be used when the instance value of an integer object has to be sent instead of the actual integer object. The NMS applications should not depend on the implementation of this object. The SNMP Requests(GET,GET-NEXT) may not be valid for this object. ')
vismAal2SubcellMuxing = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2SubcellMuxing.setStatus('current')
if mibBuilder.loadTexts: vismAal2SubcellMuxing.setDescription('This object is a card level parameter for AAL2 adaptation and it identifies the mutiplexing function of the AAL2 CPS(Common Part Sub-layer). When it is disabled then each CPS-Packet would fill only one or two cells with padding (Partial fill cells) Note that the length field for each CPS-Packet can be up to 64bytes. When this option is enabled then mutiple streams of CPS-Packets are mutiplexed to a single ATM connection without partial fill unless there is time-out. Refer to ITU-T I.363.2 for more information. When the muxing type changes if CIDs are present, then we need to check for CAC voilation for all CIDs, if the CAC fails then the change request will be rejected else the muxing status will be changed and the vismAal2MuxingTrap will be sent and the card will be reset . All the existing connecitons will come up in new muxing type. when the muxing type changes while there are no CIDs then the card will NOT be reset, but the vismAal2MuxingTrap will be sent. ')
vismAal2DtmfRelay = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2DtmfRelay.setStatus('current')
if mibBuilder.loadTexts: vismAal2DtmfRelay.setDescription('This attribute defines whether the DTMF(Dual Tone Multi Frequency) digits need to be transported to the other end-point or not. The value in this object will be utilized when the call agent does not specify this in CRCX. ')
vismAal2CasTransport = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CasTransport.setStatus('current')
if mibBuilder.loadTexts: vismAal2CasTransport.setDescription('This attribute defines whether the CAS bits need to be transported to the other endpoint. In the case of switching application, the CAS bits are backhauled to the Call Agent through xGCP-CAS protocol. The value in this object will be utilized when the call agent does not specify this in CRCX. ')
vismAal2Type3Redundancy = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2Type3Redundancy.setStatus('current')
if mibBuilder.loadTexts: vismAal2Type3Redundancy.setDescription('This attribute defines whether the triple redundancy is supported for Type 3 packets in AAL2 SVC/PVC. When Triple redundancy is enabled, the Type 3 packets (CAS bits, dialled digits and user state control packets) are transmitted in triplicates with an interval defined as per the standards I.366.2. For channels which are quite reliable, triple redundancy can be disabled in order to save the bandwidth and the processing overheads. The value in this object will be utilized when the call agent does not specify this in CRCX. ')
vismAal2VADTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(250, 65535)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2VADTimer.setStatus('current')
if mibBuilder.loadTexts: vismAal2VADTimer.setDescription('This attribute defines the hangover time for VAD in milliseconds. Once the voice inactivity is detected, the gateway will wait for this duration before activating silence suppression on an AAL2 SVC/PVC. The value in this object will be utilized when the call agent does not specify this in CRCX. ')
vismAal2CidFillTimer = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 3, 17, 6, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 100)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vismAal2CidFillTimer.setStatus('current')
if mibBuilder.loadTexts: vismAal2CidFillTimer.setDescription('This attribute defines the time (millisecs) to wait for filling up the cell when the next packet is not ready. After waiting for the time configured in this object, the cell will be sent out. This timer has no effect when vismAal2SubcellMuxing is disabled. This object is applicable only for AAL2 adaptations. ')
ciscoVismModuleMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 82, 2))
ciscoVismModuleMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1))
ciscoVismModuleMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 2))
ciscoVismModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 2, 1)).setObjects(("CISCO-VISM-MODULE-MIB", "ciscoVismPerfStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismCallStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismVoIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismDspGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismInteropGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismTrapObjGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismAal2Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismModuleCompliance = ciscoVismModuleCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismModuleCompliance.setDescription('The compliance statement for objects related to VISM module.')
ciscoVismModuleCompliance1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 2, 2)).setObjects(("CISCO-VISM-MODULE-MIB", "ciscoVismPerfStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismCallStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismVoIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismDspGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemGroup1"), ("CISCO-VISM-MODULE-MIB", "ciscoVismInteropGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismTrapObjGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismAal2Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismModuleCompliance1 = ciscoVismModuleCompliance1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismModuleCompliance1.setDescription('The compliance statement for objects related to VISM module.')
ciscoVismModuleComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 2, 3)).setObjects(("CISCO-VISM-MODULE-MIB", "ciscoVismPerfStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismCallStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismVoIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismDspGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemGroup1"), ("CISCO-VISM-MODULE-MIB", "ciscoVismInteropGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismTrapObjGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismAal2Group"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemFeatureGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismTrapVarbindGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismModuleComplianceRev2 = ciscoVismModuleComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismModuleComplianceRev2.setDescription('The compliance statement for objects related to VISM module.')
ciscoVismModuleComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 2, 4)).setObjects(("CISCO-VISM-MODULE-MIB", "ciscoVismPerfStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismCallStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismVoIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismDspGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemGroup1"), ("CISCO-VISM-MODULE-MIB", "ciscoVismInteropGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismTrapObjGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismAal2Group"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemFeatureGroupRev1"), ("CISCO-VISM-MODULE-MIB", "ciscoVismTrapVarbindGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismModuleComplianceRev3 = ciscoVismModuleComplianceRev3.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismModuleComplianceRev3.setDescription('The compliance statement for objects related to VISM module.')
ciscoVismModuleComplianceRev4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 2, 5)).setObjects(("CISCO-VISM-MODULE-MIB", "ciscoVismPerfStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismCallStatsGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismVoIpGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismDspGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemGroup1"), ("CISCO-VISM-MODULE-MIB", "ciscoVismInteropGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismTrapObjGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismAal2Group"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemFeatureGroupRev1"), ("CISCO-VISM-MODULE-MIB", "ciscoVismTrapVarbindGroup"), ("CISCO-VISM-MODULE-MIB", "ciscoVismDspGroupSup1"), ("CISCO-VISM-MODULE-MIB", "ciscoVismSystemGroupSup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismModuleComplianceRev4 = ciscoVismModuleComplianceRev4.setStatus('current')
if mibBuilder.loadTexts: ciscoVismModuleComplianceRev4.setDescription('The compliance statement for objects related to VISM module.')
ciscoVismPerfStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 1)).setObjects(("CISCO-VISM-MODULE-MIB", "vismCPUUtilization"), ("CISCO-VISM-MODULE-MIB", "vismMemoryUtilization"), ("CISCO-VISM-MODULE-MIB", "vismSysPerfClrButton"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismPerfStatsGroup = ciscoVismPerfStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismPerfStatsGroup.setDescription('The collection of objects which are used to represent VISM performance statistics.')
ciscoVismCallStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 2)).setObjects(("CISCO-VISM-MODULE-MIB", "vismTotalCalls"), ("CISCO-VISM-MODULE-MIB", "vismSuccessfulCalls"), ("CISCO-VISM-MODULE-MIB", "vismFailedCalls"), ("CISCO-VISM-MODULE-MIB", "vismCallStatsClrButton"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismCallStatsGroup = ciscoVismCallStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismCallStatsGroup.setDescription('The collection of objects which are used to represent VISM Call Statistics.')
ciscoVismIpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 3)).setObjects(("CISCO-VISM-MODULE-MIB", "vismIpAddress"), ("CISCO-VISM-MODULE-MIB", "vismSubNetMask"), ("CISCO-VISM-MODULE-MIB", "vismControlTos"), ("CISCO-VISM-MODULE-MIB", "vismBearerIpAddress"), ("CISCO-VISM-MODULE-MIB", "vismBearerSubNetMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismIpGroup = ciscoVismIpGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismIpGroup.setDescription('This group contains objects that are specific to IP.')
ciscoVismVoIpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 4)).setObjects(("CISCO-VISM-MODULE-MIB", "vismBearerTos"), ("CISCO-VISM-MODULE-MIB", "vismRtcpRepInterval"), ("CISCO-VISM-MODULE-MIB", "vismRtpReceiveTimer"), ("CISCO-VISM-MODULE-MIB", "vismVoIpDtmfRelay"), ("CISCO-VISM-MODULE-MIB", "vismVoIpCasTransport"), ("CISCO-VISM-MODULE-MIB", "vismVoIpTripleRedundancy"), ("CISCO-VISM-MODULE-MIB", "vismVoIpVADTimer"), ("CISCO-VISM-MODULE-MIB", "vismVoIpNTECapabilityNegotiate"), ("CISCO-VISM-MODULE-MIB", "vismVoIpSIDPayloadType"), ("CISCO-VISM-MODULE-MIB", "vismVoIpDPvcOamCellGap"), ("CISCO-VISM-MODULE-MIB", "vismVoIpDPvcRetryCnt"), ("CISCO-VISM-MODULE-MIB", "vismVoIpDPvcRecoverCnt"), ("CISCO-VISM-MODULE-MIB", "vismRtcpRecvMultiplier"), ("CISCO-VISM-MODULE-MIB", "vismVoIpLapdTrunkPVC"), ("CISCO-VISM-MODULE-MIB", "vismVoIpEventNegotiationPolicy"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismVoIpGroup = ciscoVismVoIpGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismVoIpGroup.setDescription('This group contains objects that are specific to VoIP.')
ciscoVismDspGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 5)).setObjects(("CISCO-VISM-MODULE-MIB", "vismCompCnfPacketSize"), ("CISCO-VISM-MODULE-MIB", "vismERL"), ("CISCO-VISM-MODULE-MIB", "vismAdaptiveGainControl"), ("CISCO-VISM-MODULE-MIB", "vismDspHealth"), ("CISCO-VISM-MODULE-MIB", "vismUpspeedCodec"), ("CISCO-VISM-MODULE-MIB", "vismPayloadType"), ("CISCO-VISM-MODULE-MIB", "vismDSPHeartbeat"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismDspGroup = ciscoVismDspGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismDspGroup.setDescription('This group contains objects that are used to manage DSPs on the VISM card.')
ciscoVismSystemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 6)).setObjects(("CISCO-VISM-MODULE-MIB", "vismDaughterCardSerialNum"), ("CISCO-VISM-MODULE-MIB", "vismDaughterCardDescription"), ("CISCO-VISM-MODULE-MIB", "vismDaughterCardHWRev"), ("CISCO-VISM-MODULE-MIB", "vismEcanEncoding"), ("CISCO-VISM-MODULE-MIB", "vismMode"), ("CISCO-VISM-MODULE-MIB", "vismCacEnable"), ("CISCO-VISM-MODULE-MIB", "vismAvailableDs0Count"), ("CISCO-VISM-MODULE-MIB", "vismAppliedTemplate"), ("CISCO-VISM-MODULE-MIB", "vismTftpServerDn"), ("CISCO-VISM-MODULE-MIB", "vismXgcpBearerNetworkType"), ("CISCO-VISM-MODULE-MIB", "vismXgcpBearerVCType"), ("CISCO-VISM-MODULE-MIB", "vismXgcpBearerConnectionType"), ("CISCO-VISM-MODULE-MIB", "vismBearerContinuityTimer"), ("CISCO-VISM-MODULE-MIB", "vismCodecNegotiationOption"), ("CISCO-VISM-MODULE-MIB", "vismProfileNegotiationOption"), ("CISCO-VISM-MODULE-MIB", "vismCarrierLossPolicy"), ("CISCO-VISM-MODULE-MIB", "vismCacRejectionPolicy"), ("CISCO-VISM-MODULE-MIB", "vismExtDnsServerDn"), ("CISCO-VISM-MODULE-MIB", "vismFeatureBitMap"), ("CISCO-VISM-MODULE-MIB", "vismVADTolerance"), ("CISCO-VISM-MODULE-MIB", "vismVADDutyCycle"), ("CISCO-VISM-MODULE-MIB", "vismAggregateTrafficClipping"), ("CISCO-VISM-MODULE-MIB", "vismAggregateSvcBandwidth"), ("CISCO-VISM-MODULE-MIB", "vismBearerContinuityTest"), ("CISCO-VISM-MODULE-MIB", "vismCaleaEnable"), ("CISCO-VISM-MODULE-MIB", "vismMaxConfNum"), ("CISCO-VISM-MODULE-MIB", "vismLongDurationTimer"), ("CISCO-VISM-MODULE-MIB", "vismContinuityCo1Timer"), ("CISCO-VISM-MODULE-MIB", "vismContinuityCo2Timer"), ("CISCO-VISM-MODULE-MIB", "vismReverseCotTone"), ("CISCO-VISM-MODULE-MIB", "vismSendDnEnable"), ("CISCO-VISM-MODULE-MIB", "vismSendDataGramSize"), ("CISCO-VISM-MODULE-MIB", "vismOamLoopThreshold"), ("CISCO-VISM-MODULE-MIB", "vismFreeDs0Threshold"), ("CISCO-VISM-MODULE-MIB", "vismCPUUtilizationThreshold"), ("CISCO-VISM-MODULE-MIB", "vismMemoryUtilizationThreshold"), ("CISCO-VISM-MODULE-MIB", "vismDualToneDetect"), ("CISCO-VISM-MODULE-MIB", "vismAisSuppression"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismSystemGroup = ciscoVismSystemGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismSystemGroup.setDescription('This group contains objects that are specific to the card.')
ciscoVismInteropGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 7)).setObjects(("CISCO-VISM-MODULE-MIB", "vismXgcpSdpOst"), ("CISCO-VISM-MODULE-MIB", "vismDynamicPT"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismInteropGroup = ciscoVismInteropGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismInteropGroup.setDescription('This group contains objects which will enhance the interoperability functionalities of VISM.')
ciscoVismTrapObjGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 8)).setObjects(("CISCO-VISM-MODULE-MIB", "vismConfigChangeTypeBitMap"), ("CISCO-VISM-MODULE-MIB", "vismTrapIntIndex1"), ("CISCO-VISM-MODULE-MIB", "vismTrapIntIndex2"), ("CISCO-VISM-MODULE-MIB", "vismTrapStrIndex1"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismTrapObjGroup = ciscoVismTrapObjGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismTrapObjGroup.setDescription('This group contains objects that are defined for the purpose of sending in trap varbinds.')
ciscoVismAal2Group = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 9)).setObjects(("CISCO-VISM-MODULE-MIB", "vismAal2SubcellMuxing"), ("CISCO-VISM-MODULE-MIB", "vismAal2DtmfRelay"), ("CISCO-VISM-MODULE-MIB", "vismAal2CasTransport"), ("CISCO-VISM-MODULE-MIB", "vismAal2Type3Redundancy"), ("CISCO-VISM-MODULE-MIB", "vismAal2VADTimer"), ("CISCO-VISM-MODULE-MIB", "vismAal2CidFillTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismAal2Group = ciscoVismAal2Group.setStatus('current')
if mibBuilder.loadTexts: ciscoVismAal2Group.setDescription('This group contains objects which will enhance the interoperability functionalities of VISM.')
ciscoVismDspDeprecatedGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 10)).setObjects(("CISCO-VISM-MODULE-MIB", "vismEcanCnfIdlePattern"), ("CISCO-VISM-MODULE-MIB", "vismEcanCnfIdleDirection"), ("CISCO-VISM-MODULE-MIB", "vismJitterDelayMode"), ("CISCO-VISM-MODULE-MIB", "vismJitterInitialDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismDspDeprecatedGroup = ciscoVismDspDeprecatedGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismDspDeprecatedGroup.setDescription('The collection of objects that were supported earlier but deprecated now.')
ciscoVismSystemDeprecatedGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 11)).setObjects(("CISCO-VISM-MODULE-MIB", "vismPrevMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismSystemDeprecatedGroup = ciscoVismSystemDeprecatedGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismSystemDeprecatedGroup.setDescription('The collection of objects that were supported earlier but deprecated now.')
ciscoVismVoIpDeprecateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 12)).setObjects(("CISCO-VISM-MODULE-MIB", "vismPacketizationPeriod"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismVoIpDeprecateGroup = ciscoVismVoIpDeprecateGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismVoIpDeprecateGroup.setDescription('The collection of objects that were supported earlier but deprecated now.')
ciscoVismSystemGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 13)).setObjects(("CISCO-VISM-MODULE-MIB", "vismDaughterCardSerialNum"), ("CISCO-VISM-MODULE-MIB", "vismDaughterCardDescription"), ("CISCO-VISM-MODULE-MIB", "vismDaughterCardHWRev"), ("CISCO-VISM-MODULE-MIB", "vismEcanEncoding"), ("CISCO-VISM-MODULE-MIB", "vismMode"), ("CISCO-VISM-MODULE-MIB", "vismCacEnable"), ("CISCO-VISM-MODULE-MIB", "vismAvailableDs0Count"), ("CISCO-VISM-MODULE-MIB", "vismAppliedTemplate"), ("CISCO-VISM-MODULE-MIB", "vismTftpServerDn"), ("CISCO-VISM-MODULE-MIB", "vismXgcpBearerNetworkType"), ("CISCO-VISM-MODULE-MIB", "vismXgcpBearerVCType"), ("CISCO-VISM-MODULE-MIB", "vismXgcpBearerConnectionType"), ("CISCO-VISM-MODULE-MIB", "vismBearerContinuityTimer"), ("CISCO-VISM-MODULE-MIB", "vismCodecNegotiationOption"), ("CISCO-VISM-MODULE-MIB", "vismProfileNegotiationOption"), ("CISCO-VISM-MODULE-MIB", "vismCarrierLossPolicy"), ("CISCO-VISM-MODULE-MIB", "vismCacRejectionPolicy"), ("CISCO-VISM-MODULE-MIB", "vismExtDnsServerDn"), ("CISCO-VISM-MODULE-MIB", "vismFeatureBitMap"), ("CISCO-VISM-MODULE-MIB", "vismVADTolerance"), ("CISCO-VISM-MODULE-MIB", "vismVADDutyCycle"), ("CISCO-VISM-MODULE-MIB", "vismAggregateTrafficClipping"), ("CISCO-VISM-MODULE-MIB", "vismAggregateSvcBandwidth"), ("CISCO-VISM-MODULE-MIB", "vismBearerContinuityTest"), ("CISCO-VISM-MODULE-MIB", "vismCaleaEnable"), ("CISCO-VISM-MODULE-MIB", "vismMaxConfNum"), ("CISCO-VISM-MODULE-MIB", "vismLongDurationTimer"), ("CISCO-VISM-MODULE-MIB", "vismContinuityCo1Timer"), ("CISCO-VISM-MODULE-MIB", "vismContinuityCo2Timer"), ("CISCO-VISM-MODULE-MIB", "vismReverseCotTone"), ("CISCO-VISM-MODULE-MIB", "vismSendDnEnable"), ("CISCO-VISM-MODULE-MIB", "vismSendDataGramSize"), ("CISCO-VISM-MODULE-MIB", "vismOamLoopThreshold"), ("CISCO-VISM-MODULE-MIB", "vismFreeDs0Threshold"), ("CISCO-VISM-MODULE-MIB", "vismCPUUtilizationThreshold"), ("CISCO-VISM-MODULE-MIB", "vismMemoryUtilizationThreshold"), ("CISCO-VISM-MODULE-MIB", "vismDualToneDetect"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismSystemGroup1 = ciscoVismSystemGroup1.setStatus('current')
if mibBuilder.loadTexts: ciscoVismSystemGroup1.setDescription('This group contains objects that are specific to the card.')
ciscoVismSystemFeatureGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 14)).setObjects(("CISCO-VISM-MODULE-MIB", "vismBearerIpPingEnable"), ("CISCO-VISM-MODULE-MIB", "vismTrapFilteringEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismSystemFeatureGroup = ciscoVismSystemFeatureGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoVismSystemFeatureGroup.setDescription('This group contains specific card level objects for feature support on the module.')
ciscoVismTrapVarbindGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 15)).setObjects(("CISCO-VISM-MODULE-MIB", "vismTrapIntegerValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismTrapVarbindGroup = ciscoVismTrapVarbindGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoVismTrapVarbindGroup.setDescription('This group contains objects that are defined for the purpose of sending in trap varbinds.')
ciscoVismSystemFeatureGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 16)).setObjects(("CISCO-VISM-MODULE-MIB", "vismBearerIpPingEnable"), ("CISCO-VISM-MODULE-MIB", "vismTrapFilteringEnable"), ("CISCO-VISM-MODULE-MIB", "vismSplModemToneBitMap"), ("CISCO-VISM-MODULE-MIB", "vismSSRCEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismSystemFeatureGroupRev1 = ciscoVismSystemFeatureGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoVismSystemFeatureGroupRev1.setDescription('This group contains specific card level objects for feature support on the module.')
ciscoVismSystemGroupSup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 17)).setObjects(("CISCO-VISM-MODULE-MIB", "vismOamLoopbackSetCLP"), ("CISCO-VISM-MODULE-MIB", "vismPvcAlarmLogEnable"), ("CISCO-VISM-MODULE-MIB", "vismPvcAlarmLogAdminTimer"), ("CISCO-VISM-MODULE-MIB", "vismPvcAlarmLogOperTimer"), ("CISCO-VISM-MODULE-MIB", "vismContinuityCheckCellEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismSystemGroupSup1 = ciscoVismSystemGroupSup1.setStatus('current')
if mibBuilder.loadTexts: ciscoVismSystemGroupSup1.setDescription('This group contains objects that are specific to the card.')
ciscoVismDspGroupSup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 82, 2, 1, 18)).setObjects(("CISCO-VISM-MODULE-MIB", "vismFaxDeJitterMode"), ("CISCO-VISM-MODULE-MIB", "vismFaxDeJitterInitialDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoVismDspGroupSup1 = ciscoVismDspGroupSup1.setStatus('current')
if mibBuilder.loadTexts: ciscoVismDspGroupSup1.setDescription('This group contains objects that are used to manage DSPs on the VISM card.')
mibBuilder.exportSymbols("CISCO-VISM-MODULE-MIB", vismVoIpNTECapabilityNegotiate=vismVoIpNTECapabilityNegotiate, ciscoVismSystemGroupSup1=ciscoVismSystemGroupSup1, vismVoIpDPvcRecoverCnt=vismVoIpDPvcRecoverCnt, vismOamLoopThreshold=vismOamLoopThreshold, vismCompCnfPacketSize=vismCompCnfPacketSize, vismFailedCalls=vismFailedCalls, vismDspHealth=vismDspHealth, vismSystemGrp=vismSystemGrp, vismXgcpBearerConnectionType=vismXgcpBearerConnectionType, vismAisSuppression=vismAisSuppression, vismSSRCEnable=vismSSRCEnable, vismMemoryUtilizationThreshold=vismMemoryUtilizationThreshold, vismCPUUtilization=vismCPUUtilization, vismAvailableDs0Count=vismAvailableDs0Count, vismAal2DtmfRelay=vismAal2DtmfRelay, vismJitterDelayMode=vismJitterDelayMode, vismBearerTos=vismBearerTos, vismProfileNegotiationOption=vismProfileNegotiationOption, vismXgcpBearerVCType=vismXgcpBearerVCType, vismCacRejectionPolicy=vismCacRejectionPolicy, vismAdaptiveGainControl=vismAdaptiveGainControl, vismTrapFilteringEnable=vismTrapFilteringEnable, PYSNMP_MODULE_ID=ciscoVismModuleMIB, vismExtDnsServerDn=vismExtDnsServerDn, vismContinuityCo1Timer=vismContinuityCo1Timer, vismCallStats=vismCallStats, vismAggregateTrafficClipping=vismAggregateTrafficClipping, vismSuccessfulCalls=vismSuccessfulCalls, vismBearerIpAddress=vismBearerIpAddress, ciscoVismSystemGroup1=ciscoVismSystemGroup1, vismAal2SubcellMuxing=vismAal2SubcellMuxing, vismConfigChangeTypeBitMap=vismConfigChangeTypeBitMap, vismRtcpRecvMultiplier=vismRtcpRecvMultiplier, vismCodecNegotiationOption=vismCodecNegotiationOption, vismConfig=vismConfig, vismSystemPerfStats=vismSystemPerfStats, vismVoIpTripleRedundancy=vismVoIpTripleRedundancy, vismPayloadType=vismPayloadType, vismPacketizationPeriod=vismPacketizationPeriod, ciscoVismAal2Group=ciscoVismAal2Group, ciscoVismModuleMIB=ciscoVismModuleMIB, ciscoVismModuleMIBConformance=ciscoVismModuleMIBConformance, vismFeatureBitMap=vismFeatureBitMap, vismCacEnable=vismCacEnable, vismVoIpCasTransport=vismVoIpCasTransport, ciscoVismDspDeprecatedGroup=ciscoVismDspDeprecatedGroup, vismDspGrp=vismDspGrp, ciscoVismDspGroupSup1=ciscoVismDspGroupSup1, ciscoVismSystemFeatureGroupRev1=ciscoVismSystemFeatureGroupRev1, vismAal2CasTransport=vismAal2CasTransport, vismInteropGrp=vismInteropGrp, vismSendDataGramSize=vismSendDataGramSize, ciscoVismModuleMIBGroups=ciscoVismModuleMIBGroups, vismVADTolerance=vismVADTolerance, ciscoVismIpGroup=ciscoVismIpGroup, VismFaxDeJitterInitDelay=VismFaxDeJitterInitDelay, vismReverseCotTone=vismReverseCotTone, vismDaughterCardSerialNum=vismDaughterCardSerialNum, ciscoVismVoIpDeprecateGroup=ciscoVismVoIpDeprecateGroup, vismTrapObjGrp=vismTrapObjGrp, vismXgcpSdpOst=vismXgcpSdpOst, vismAppliedTemplate=vismAppliedTemplate, vismDynamicPT=vismDynamicPT, vismSubNetMask=vismSubNetMask, vismControlTos=vismControlTos, vismXgcpBearerNetworkType=vismXgcpBearerNetworkType, vismTrapIntIndex2=vismTrapIntIndex2, vismVoIpDtmfRelay=vismVoIpDtmfRelay, vismVoIpLapdTrunkPVC=vismVoIpLapdTrunkPVC, vismBearerContinuityTest=vismBearerContinuityTest, vismIpGrp=vismIpGrp, vismTotalCalls=vismTotalCalls, vismOamLoopbackSetCLP=vismOamLoopbackSetCLP, vismIpAddress=vismIpAddress, vismBearerSubNetMask=vismBearerSubNetMask, vismPvcAlarmLogEnable=vismPvcAlarmLogEnable, vismEcanCnfIdleDirection=vismEcanCnfIdleDirection, ciscoVismModuleComplianceRev4=ciscoVismModuleComplianceRev4, ciscoVismModuleCompliance1=ciscoVismModuleCompliance1, vismUpspeedCodec=vismUpspeedCodec, vismVoIpGrp=vismVoIpGrp, vismPvcAlarmLogAdminTimer=vismPvcAlarmLogAdminTimer, ciscoVismDspGroup=ciscoVismDspGroup, ciscoVismCallStatsGroup=ciscoVismCallStatsGroup, vismMemoryUtilization=vismMemoryUtilization, ciscoVismSystemDeprecatedGroup=ciscoVismSystemDeprecatedGroup, ciscoVismSystemGroup=ciscoVismSystemGroup, vismTrapIntegerValue=vismTrapIntegerValue, vismContinuityCheckCellEnable=vismContinuityCheckCellEnable, vismVADDutyCycle=vismVADDutyCycle, vismCallStatsClrButton=vismCallStatsClrButton, vismVoIpEventNegotiationPolicy=vismVoIpEventNegotiationPolicy, vismFaxDeJitterInitialDelay=vismFaxDeJitterInitialDelay, vismAal2CidFillTimer=vismAal2CidFillTimer, vismDualToneDetect=vismDualToneDetect, vismEcanEncoding=vismEcanEncoding, vismAal2Grp=vismAal2Grp, vismBearerIpPingEnable=vismBearerIpPingEnable, vismFaxDeJitterMode=vismFaxDeJitterMode, vismVoIpDPvcOamCellGap=vismVoIpDPvcOamCellGap, vismBearerContinuityTimer=vismBearerContinuityTimer, ciscoVismTrapObjGroup=ciscoVismTrapObjGroup, vismPvcAlarmLogOperTimer=vismPvcAlarmLogOperTimer, vismVoIpDPvcRetryCnt=vismVoIpDPvcRetryCnt, vismERL=vismERL, vismEcanCnfIdlePattern=vismEcanCnfIdlePattern, vismRtcpRepInterval=vismRtcpRepInterval, ciscoVismInteropGroup=ciscoVismInteropGroup, ciscoVismModuleComplianceRev2=ciscoVismModuleComplianceRev2, vismDSPHeartbeat=vismDSPHeartbeat, ciscoVismModuleComplianceRev3=ciscoVismModuleComplianceRev3, ciscoVismTrapVarbindGroup=ciscoVismTrapVarbindGroup, vismSplModemToneBitMap=vismSplModemToneBitMap, vismMaxConfNum=vismMaxConfNum, vismSysPerfClrButton=vismSysPerfClrButton, vismTftpServerDn=vismTftpServerDn, vismContinuityCo2Timer=vismContinuityCo2Timer, vismAal2Type3Redundancy=vismAal2Type3Redundancy, vismFreeDs0Threshold=vismFreeDs0Threshold, vismCarrierLossPolicy=vismCarrierLossPolicy, vismDaughterCardHWRev=vismDaughterCardHWRev, vismCaleaEnable=vismCaleaEnable, vismLongDurationTimer=vismLongDurationTimer, vismTrapStrIndex1=vismTrapStrIndex1, vismJitterInitialDelay=vismJitterInitialDelay, vismDaughterCardDescription=vismDaughterCardDescription, vismPrevMode=vismPrevMode, ciscoVismPerfStatsGroup=ciscoVismPerfStatsGroup, vismMode=vismMode, vismRtpReceiveTimer=vismRtpReceiveTimer, ciscoVismSystemFeatureGroup=ciscoVismSystemFeatureGroup, vismSendDnEnable=vismSendDnEnable, ciscoVismModuleMIBCompliances=ciscoVismModuleMIBCompliances, ciscoVismVoIpGroup=ciscoVismVoIpGroup, vismAggregateSvcBandwidth=vismAggregateSvcBandwidth, vismVoIpVADTimer=vismVoIpVADTimer, vismTrapIntIndex1=vismTrapIntIndex1, VismFaxDeJitterMode=VismFaxDeJitterMode, vismAal2VADTimer=vismAal2VADTimer, vismVoIpSIDPayloadType=vismVoIpSIDPayloadType, ciscoVismModuleCompliance=ciscoVismModuleCompliance, vismCPUUtilizationThreshold=vismCPUUtilizationThreshold)

#
# PySNMP MIB module RH-ATT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RH-ATT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:57:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, Bits, MibIdentifier, Gauge32, iso, IpAddress, enterprises, Counter64, Unsigned32, Integer32, ModuleIdentity, Counter32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "MibIdentifier", "Gauge32", "iso", "IpAddress", "enterprises", "Counter64", "Unsigned32", "Integer32", "ModuleIdentity", "Counter32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
att_2 = MibIdentifier((1, 3, 6, 1, 4, 1, 74)).setLabel("att-2")
att_products = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 1)).setLabel("att-products")
att_mgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2)).setLabel("att-mgmt")
att_rh1products = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 1, 6)).setLabel("att-rh1products")
att_rh1xe = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 1, 6, 1)).setLabel("att-rh1xe")
att_rh1mgt = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 14)).setLabel("att-rh1mgt")
rh1BasicCtrlCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 14, 1))
rh1SelfTestCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 14, 2))
rh1PerfMonCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 14, 3))
rh1DownloadCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 14, 4))
rh1AddrTrackCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 14, 5))
rh1EnhCtrlCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 14, 6))
rh1SecurityCapability = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 14, 7))
rh1BasicCtrlRackMAC = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1BasicCtrlRackMAC.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlRackMAC.setDescription("The rack's base MAC address. By definintion it may be inferred that the next 3 consecutive MAC addresses are also assigned to this rack. This object is included in all traps to allow the manager to ascertain the hub's MAC address (unique identifier). This is required for UDP/IP communications across an internet since the source MAC address is not preserved end-to-end. This is also the MAC address used to send hub learn packets on the first segment.")
rh1BasicCtrlCardCapacity = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1BasicCtrlCardCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlCardCapacity.setDescription('Indicates the number of groups that can be contained within the rack. Valid range is 1-32. Within each managed rack, the groups are uniquely numbered in the range from 1 to rh1BasicCtrlCardCapacity. Each group corresponds to a physical card in the rack. The the rack hub agent (in the current chassis design) returns 7 for this object.')
rh1BasicCtrlCardTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 3), )
if mibBuilder.loadTexts: rh1BasicCtrlCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlCardTable.setDescription('A list of card control entries.')
rh1BasicCtrlCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 3, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1BasicCtrlCardID"))
if mibBuilder.loadTexts: rh1BasicCtrlCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlCardEntry.setDescription('Entry of the Basic Control Group Card table')
rh1BasicCtrlCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1BasicCtrlCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlCardID.setDescription('Index into the Basic Control Card Table')
rh1BasicCtrlNumberOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1BasicCtrlNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlNumberOfPorts.setDescription('The number of ports is an 8 bit integer whose value points to the port address of the highest numbered port. For the R1 and R2 Rack MPR boards, the value is 12. For an R2 MPR with the optional FOMAU installed, the value is 13.')
rh1BasicCtrlPortTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 4), )
if mibBuilder.loadTexts: rh1BasicCtrlPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlPortTable.setDescription('A list of Basic port control entries.')
rh1BasicCtrlPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 4, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1BasicPortCtrlCardID"), (0, "RH-ATT-MIB", "rh1BasicCtrlPortID"))
if mibBuilder.loadTexts: rh1BasicCtrlPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlPortEntry.setDescription('Entry into the Basic Control Group Port table.')
rh1BasicPortCtrlCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1BasicPortCtrlCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicPortCtrlCardID.setDescription('Index by card into the basic control table')
rh1BasicCtrlPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1BasicCtrlPortID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlPortID.setDescription('Index by port into the basic control table')
rh1BasicCtrlPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("repeater", 2), ("tenBASE-F-Async", 3), ("tenBASE-F-Synch", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1BasicCtrlPortType.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlPortType.setDescription('The type of port. All ports on a repeater are of the same type at this layer. Different port types have different delay characteristics and topological implications. For the Rack Hub the value is 2. Note that this object does not convey media information. That type of information is outside the charter of the IEEE HM group.')
rh1BasicCtrlPortCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1BasicCtrlPortCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlPortCtrl.setDescription('The administrator settable state of this port. Indicates whether a port has been administratively disabled or whether it is in the normal, enabled state. This allows a network operator to disable a problem port or to deny the port access to network resources for administrative reasons. A disabled port neither transmits nor receives. rh1BasicCtrlPortCtrl takes precedence over auto partition. The auto partion/reconnection mechanism may or may not continue to function while a port is disabled.')
rh1BasicCtrlAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("not-auto-partitioned", 2), ("auto-partitioned", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1BasicCtrlAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: rh1BasicCtrlAutoPartitionState.setDescription("Indicates whether the port is currently partitioned by the hub's auto-partition protection. (The Hub automatically partitions a port if it is signaling continuous collision, or greater than 30 consecutive collisions). It is the same as jab indication.")
rh1SelfTestResetRack = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SelfTestResetRack.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestResetRack.setDescription('This action initializes the Rack. This reset is the software equivalent of a power up reset. This action may result in the loss of packets.')
rh1SelfTestExecuteSelfTest1 = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-test", 1), ("test", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SelfTestExecuteSelfTest1.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestExecuteSelfTest1.setDescription('Causes the Rack to initiate the non-disruptive self-test function. The hub performs a non-disruptive self-test that has the following characteristics: - The test changes neither the state of the hub nor management information about the hub. - The test does not inject packets onto any segment. - The test does not prevent the relay of any packets. Test results are conveyed by the hubHealth objects. Note, the IEEE specification does not specify the components to be tested.')
rh1SelfTestExecuteSelfTest2 = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-test", 1), ("test", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SelfTestExecuteSelfTest2.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestExecuteSelfTest2.setDescription('Causes the Rack to initiate the disruptive self-test function. The hub performs a disruptive self-test that has the following characteristics: - The test resets the hub without affecting management information about the hub. - The test does not inject packets onto any segment. - Packets sent during the test may or may not be relayed. Test results are conveyed by the hubHealth objects.')
rh1SelfTestRackHealthState = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SelfTestRackHealthState.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestRackHealthState.setDescription('The health state object indicates the operational state of the rack. This object will also map to the color of the rack status LED, where state ok(2) is green, and state failure(3) is red.')
rh1SelfTestRackHealthData = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SelfTestRackHealthData.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestRackHealthData.setDescription("This object gives data on the health of all major rack components. The object is an octet string with a size of 103 octets broken 6 sections: Reason for trap Chassis failure conditions Debugging data Test result map Card failure map Diagnostic results registers The sections are encoded as follows: Octet Definition Reason for trap 0 Reason for trap 0 no trap 1 non-disruptive test 2 disruptive test 3 temperature condition 4 fan failure 5 power supply failure 6 Deadman timer expired 7 Software panic occured 8 Sanity Reset occured 9 Configuration checksum failure Chassis failure conditions 1 Temperature condition 0 OK 1 High 2 Fan condition 0 OK 1 Fan 1 failed 2 Fan 2 failed 3 Fan 1 and Fan 2 failed 3 Power supply condition 0 OK 1 Supply 1 failed 2 Supply 2 failed Debugging data 4-5 Software panic counters 6-7 ID last module panic 8-9 Line number of last panic 10-13 NAU control dead man timer 14-17 Sanity reset counter 18 NVRAM configuration checksum Test Result Map (any bit set to 1 indicates the test failed on at least one card) The map supports a total of 32 tests of which 17 are reserved for future use 19 Disruptive Rack tests (Self Test 2) bit Test 1 0 SRAM R/W Test 2 1 SRAM Address Test 3 2 MPR Registers Test 4 3 Security R/W Test 5 4 NAU Memory R/W Test 6 5 NAU Memory Address Test 7 6 NAU IRQ Test 8 7 NAU Self Test 20 Test 9 0 NAU Loopback Test 10 1 NAU Registers Test 11 2 Slot 0 EAROM Test 12-16 3-7 Reserved for future use Non-Disruptive Rack tests (Self Test 1) bit 21 Test 17 0 SRAM R/W Test 18 1 SRAM Address Test 19 2 Flash Checksum Test 20 3 Flash Read Test 21 4 NAU I/O Test 22 5 NAU Memory R/W Test 23-24 6-7 Reserved for future use 22 Test 25-32 0-7 Reserved for future use Card Failure Map For each test in the Test Result map, there is are two corresponding octects in the card failure map. The octects are positionally encoded to represent the cards in the rack, if a bit is set (1) it indicates which card failed that test (more than one bit may be set). Bit 0 is the Bus Logic Unit (slot 0), and bits 1 to 15 are cards 1 to 15 respectively (note the SmartHUB XE only supports 7 cards at this time) Octet 23, 24 Test 1 card results 25, 26 Test 2 card results 27, 28 Test 3 card results 29, 30 Test 4 card results 31, 32 Test 5 card results 33, 34 Test 6 card results 35, 36 Test 7 card results 37, 38 Test 8 card results 39, 40 Test 9 card results 41, 42 Test 10 card results 43, 33 Test 11 card results 45, 46 Test 12 card results 47, 48 Test 13 card results 49, 50 Test 14 card results 51, 52 Test 15 card results 53, 54 Test 16 card results 55, 56 Test 17 card results 57, 58 Test 18 card results 59, 60 Test 19 card results 61, 62 Test 20 card results 63, 64 Test 21 card results 65, 66 Test 22 card results 67, 68 Test 23 card results 69, 70 Test 24 card results 71, 72 Test 25 card results 73, 74 Test 26 card results 75, 76 Test 27 card results 77, 78 Test 28 card results 79, 80 Test 29 card results 81, 82 Test 30 card results 83, 84 Test 31 card results 85, 86 Test 32 card results Diagnostic Register Results All boards also support a diagnostic register which contains a code corresponding to the current health of that board. (This is especially useful for non-MPR boards which don't report other diagnostics through this MIB) Definitions for diagnostic register: 0x00 to 0xEF Vendor specific Display as 'error code: xx' 0xF0 Power on reset value After timeout X1 Display as 'reset failure' 0xF1 Diagnostics passed Display as 'passed' 0xF2 General failure Major Display as 'failed' 0xF3 General failure Minor Display as 'failed' 0xF4 Checksum error Display as 'checksum error' (note: this value for a bad flash image) 0xF5 Configuration error Display as 'configuration error' 0xF6 to 0xFD Reserved for future use Display as 'error code: xx' 0xFE Running diagnostics, extended timeout On timeout X2 display as 'diagnostic timeout' 0xFF Running diagnostics, standard timeout On timeout X3 display as 'diagnostic timeout' Octet 87 Slot 0 diagnostic register 88 Slot 1 diagnostic register 89 Slot 2 diagnostic register 90 Slot 3 diagnostic register 91 Slot 4 diagnostic register 92 Slot 5 diagnostic register 93 Slot 6 diagnostic register 94 Slot 7 diagnostic register 95 Slot 8 diagnostic register 96 Slot 9 diagnostic register 97 Slot 10 diagnostic register 98 Slot 11 diagnostic register 99 Slot 12 diagnostic register 100 Slot 13 diagnostic register 101 Slot 14 diagnostic register 102 Slot 15 diagnostic register")
rh1SelfTestCardTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6), )
if mibBuilder.loadTexts: rh1SelfTestCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestCardTable.setDescription('A list of self test entries.')
rh1SelfTestCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1SelfTestCardID"))
if mibBuilder.loadTexts: rh1SelfTestCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestCardEntry.setDescription('Entry into the Self Test Capability Card table.')
rh1SelfTestCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SelfTestCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestCardID.setDescription('Index into the self test card table.')
rh1SelfTestCardResetTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SelfTestCardResetTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestCardResetTimeStamp.setDescription('A snapshot of sysUpTime when the card was last reset.')
rh1SelfTestResetCard = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SelfTestResetCard.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestResetCard.setDescription('Causes a reset of all functions of the selected card. If the selected card is the rack manager, the agent and volatile information is reset. Packets may be lost.')
rh1SelfTestResetMPR = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SelfTestResetMPR.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestResetMPR.setDescription('For an MPR card, causes a selective reset of the MPR portion only. No management information is changed, however packets may be lost.')
rh1SelfTestExecuteCardSelfTest1 = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-test", 1), ("test", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SelfTestExecuteCardSelfTest1.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestExecuteCardSelfTest1.setDescription('Causes the card to initiate the non-disruptive self-test function. The non-disruptive self-test has the following characteristics: - The test changes neither the state of the card nor management information about the card. - The test does not inject packets onto any segment. - The test does not prevent the relay of any packets. Test results are conveyed by the cardHealth objects.')
rh1SelfTestExecuteCardSelfTest2 = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-test", 1), ("test", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SelfTestExecuteCardSelfTest2.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestExecuteCardSelfTest2.setDescription('Causes the card to initiate the disruptive self-test function. The disruptive self-test has the following characteristics: - The test resets the card without affecting management information about the card. - The test does not inject packets onto any segment. - Packets sent during the test may or may not be relayed. Test results are conveyed by the cardHealth objects.')
rh1SelfTestCardHealthState = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SelfTestCardHealthState.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestCardHealthState.setDescription('State of a card.')
rh1SelfTestCardHealthData = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 2, 6, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SelfTestCardHealthData.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SelfTestCardHealthData.setDescription('This object gives data on the health of each 10BaseT card in the rack. The object is an octet string with a size of 3 octet, encoded as follows: Octet Definition 0 Reason for trap 1 Result of last non-disruptive test 2 Result of last disruptive test 1 Disruptive test result (Self Test 2) 0 Sram R/W 1 Sram Address 2 Timer 1 3-7 Reserved for future use 2 Non-disruptive test result (Self Test 1) 0 Sram R/W 1 Sram Address 2 Flash Checksum 3 Flash Read 4-7 Reserve for future use')
rh1PerfMonSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1), )
if mibBuilder.loadTexts: rh1PerfMonSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegmentTable.setDescription('A list of Performance Monitoring entries. Range from 1 to 3. Note, since these objects represent the sum of values from several cards in the rack, each time any card in a given segment is added or removed, the counters for all cards on that segment are reset.')
rh1PerfMonSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1PerfMonSegmentID"))
if mibBuilder.loadTexts: rh1PerfMonSegmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegmentEntry.setDescription('Entry into the Performance Monitor Segment Table')
rh1PerfMonSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegmentID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegmentID.setDescription('Index by segment into the Performance Monitor table. This value available even if there are no cards on the segment.')
rh1PerfMonSegFrameSize1Bound = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1PerfMonSegFrameSize1Bound.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegFrameSize1Bound.setDescription('The upper boundary for the first quantization band (the lower bound is 64 by definition). This boundary applies to both rh1PerfMonSegTotalBand1Frames and rh1PerfMonSegBand1Frames. The value may range from 64 to 1518, but the values of Size1Bound to Size4Bound must define non-overlapping bands (ie they must be an increasing series of values). This value available even if there are no cards on the segment.')
rh1PerfMonSegFrameSize2Bound = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1PerfMonSegFrameSize2Bound.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegFrameSize2Bound.setDescription('The upper boundary for the second quantization band. This boundary applies to both rh1PerfMonSegTotalBand2Frames and rh1PerfMonSegBand2Frames. The value may range from 64 to 1518, but the values of Size1Bound to Size4Bound must define non-overlapping bands (ie they must be an increasing series of values). This value available even if there are no cards on the segment.')
rh1PerfMonSegFrameSize3Bound = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1PerfMonSegFrameSize3Bound.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegFrameSize3Bound.setDescription('The upper boundary for the third quantization band. This boundary applies to both rh1PerfMonSegTotalBand3Frames and rh1PerfMonSegBand3Frames. The value may range from 64 to 1518, but the values of Size1Bound to Size4Bound must define non-overlapping bands (ie they must be an increasing series of values). This value available even if there are no cards on the segment.')
rh1PerfMonSegFrameSize4Bound = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1PerfMonSegFrameSize4Bound.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegFrameSize4Bound.setDescription('The upper boundary for the fourth quantization band (and the lower bound for the fifth quantization band). This boundary applies to both rh1PerfMonSegTotalBand4Frames and rh1PerfMonSegBand4Frames. The value may range from 64 to 1518, but the values of Size1Bound to Size4Bound must define non-overlapping bands (ie they must be an increasing series of values). This value available even if there are no cards on the segment.')
rh1PerfMonSegTotalFramesProcessedOk = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalFramesProcessedOk.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalFramesProcessedOk.setDescription('The number of valid frames processed through the segment. It does not include frames received with frame-too-long, FCS, length, or alignment errors, or frames lost due to internal errors. The approximate minimum time for counter rollover is 73 hours.')
rh1PerfMonSegTotalOctetsProcessedOk = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalOctetsProcessedOk.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalOctetsProcessedOk.setDescription('The total number of octets processed through the segment. Octets counted are the number of data and padding octets in frames that are successfully received. The approximate minimum time for counter rollover is 58 minutes.')
rh1PerfMonSegTotalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalCollisions.setDescription('The total number of times the transmit collision state is entered, no matter how many ports are involved. The counter is not incremented for receive collisions. The approximate minimum time for counter rollover is 16 hours. This object allows a single reading of collisions/segment rather than polling each of the ports.')
rh1PerfMonSegTotalLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalLateCollisions.setDescription('Counts the number of times that a collision has been detected on this port later than 512 bit times into the transmitted packet. A late collision is counted twice, as both a collision and as a late collision.')
rh1PerfMonSegTotalRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalRunts.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalRunts.setDescription('Counts the number of collision fragments longer than 96 bits and shorter than a legal packet, detected on this segment. (Runts do not indicate a problem in the network).')
rh1PerfMonSegTotalShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalShortEvents.setDescription('Counts the number of fragments received on this segment. These fragments, less than 96-n bits long, indicate an external noise hit (a problem on the network).')
rh1PerfMonSegTotalFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalFrameTooLongs.setDescription('Counts the number of frames received through this segment that are greater than 1518 bytes long.')
rh1PerfMonSegTotalAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalAutoPartitions.setDescription('The total number of times ports on this segment (in this chassis) have been autopartitioned.')
rh1PerfMonSegTotalLongFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalLongFragments.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalLongFragments.setDescription('The total number of fragments received by this segment. LongFragments are any frames greater or equal to 96 bits but less than 512 bits (which includes runt frames). The fragment count also includes any other length frames in which the start of frame delimiter is not present.')
rh1PerfMonSegTotalFifoErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalFifoErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalFifoErrors.setDescription('Counts the total number of times that a packet has been received by this segment with the transmission frequency (data rate) detectably out of spec. The exact degree is unspecified and vendor specific.')
rh1PerfMonSegTotalErrorEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalErrorEnergy.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalErrorEnergy.setDescription('The total length in bytes of all error energy. Used to calculate network utilization. Errors included in this counter are: late collisions, long frames, long fragments, fifo errors, and manchester code violations.')
rh1PerfMonSegTotalNondataEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalNondataEnergy.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalNondataEnergy.setDescription('The total length in bytes of all non-data energy. Used to calculate network utilization. Non-data is defined as: collisions, runts, and short events.')
rh1PerfMonSegTotalManchesterViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalManchesterViolations.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalManchesterViolations.setDescription('The number of manchester code violations.')
rh1PerfMonSegTotalBand1Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand1Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand1Frames.setDescription('The number of frames transmitted from this segment summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonSegTotalBand2Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand2Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand2Frames.setDescription('The number of frames transmitted from this segment summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonSegTotalBand3Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand3Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand3Frames.setDescription('The number of frames transmitted from this segment summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonSegTotalBand4Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand4Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand4Frames.setDescription('The number of frames transmitted from this segment summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonSegTotalBand5Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand5Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegTotalBand5Frames.setDescription('The number of frames transmitted from this segment summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonSegCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 1, 1, 24), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonSegCounts.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonSegCounts.setDescription('This object aggregates selected stats into one coded bit string. The definition of each position in the string is: Statistics counts for this segment. The octet string is positionally encoded in four octet increments as follows: Octet position Object 1-4 segFramesProcessedOk 5-8 segOctetsProcessedOk 9-12 segCollisions 13-16 segLateCollisions 17-20 segRunts 21-14 segShortEvents 25-18 segFrameTooLongs 29-32 segAutoPartitions 33-36 segLongFragments 37-40 segFifoErrors 41-44 segErrorEnergy 45-48 segNondataEnergy 49-52 segManchesterCodeViolations Specifications for the values contained in this MIB object can be found in the specifications for the individual objects.')
rh1PerfMonPortTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2), )
if mibBuilder.loadTexts: rh1PerfMonPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonPortTable.setDescription('A list of Performance Monitor port entries.')
rh1PerfMonPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1PerfMonCardID"), (0, "RH-ATT-MIB", "rh1PerfMonPortID"))
if mibBuilder.loadTexts: rh1PerfMonPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonPortEntry.setDescription('Entry into the Performance Monitor Port table')
rh1PerfMonCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonCardID.setDescription('An index into the performance monitoring port table.')
rh1PerfMonPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonPortID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonPortID.setDescription('An index into the performance monitoring port table.')
rh1PerfMonFramesReceivedOk = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonFramesReceivedOk.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonFramesReceivedOk.setDescription('A representation of the total frames of legal length that have not been corrupted in transmission. These frames can be encoded and decoded by commonly available MACs and provides a measure of network bandwidth being used. This count is equal to the sum of framesReceivedOk and outOfRangeLengthFieldFrames. It does not include frames received with frames-too-long, alignment errors, frames lost due to internal MAC sublayer errors, runts, or shortEvents. The approximate minimum time to rollover is 81 hours.')
rh1PerfMonOctetsReceivedOk = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonOctetsReceivedOk.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonOctetsReceivedOk.setDescription('The number of octets received on this port. Octets counted are the number of data and padding octets in frames that are successfully received. The approximate minimum time for counter rollover is 58 minutes.')
rh1PerfMonCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonCollisions.setDescription('Counts the number of times that a collision has been detected on this port later than 512 bit times into the transmitted packet. A late collision is counted twice, as both a collision and as a late collision.')
rh1PerfMonLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonLateCollisions.setDescription('Counts the number of times that a collision has been detected on this port later than 512 bit times into the transmitted packet. A late collision is counted twice, as both a collision and as a late collision.')
rh1PerfMonRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonRunts.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonRunts.setDescription('Counts the number of collision fragments longer than a shortEvent and shorter than a legal packet, detected on this port. (Runts do not indicate a problem in the network).')
rh1PerfMonShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonShortEvents.setDescription('Counts the number of fragments received on this port. These fragments, less than 64 +/- 10 bits long, indicate an external noise hit (a problem on the network).')
rh1PerfMonFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonFrameTooLongs.setDescription('Counts the number of frames received through this port that are greater than 1518 octets long.')
rh1PerfMonAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonAutoPartitions.setDescription('Counts the number of times that the repeater has automatically partitioned this port.')
rh1PerfMonLongFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonLongFragments.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonLongFragments.setDescription('The total number of fragments received by this segment. LongFragments are any frames greater or equal to 96 bits but less than 512 bits (which includes runt frames). The fragment count also includes any other length frames in which the start of frame delimiter is not present.')
rh1PerfMonFifoErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonFifoErrors.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonFifoErrors.setDescription("Counts the number of times that a packet has been received by this port with the transmission frequency (data rate) detectably out of spec. The exact degree is unspecified and vendor specific. This object is also referred to as 'number of FIFO errors'.")
rh1PerfMonFramesTransmittedOk = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonFramesTransmittedOk.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonFramesTransmittedOk.setDescription("Transmitted frames are the number of valid 'authorized' frames transmitted out the port. Authorized frames are those for which: 1) port authorized type equals 'single' and the destination address equals the port authorized mac address (or) 2) port authorized type equals 'multiple' or 'hub'. If the port authorized type equals 'none', no frames are counted as 'authorized', and are therefore not counted as 'transmitted' frames. The approximate minimum time for counter rollover is 73 hours.")
rh1PerfMonOctetsTransmittedOk = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonOctetsTransmittedOk.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonOctetsTransmittedOk.setDescription('The number of octets transmitted from the hub on this port. Octets counted are the number of data and padding octets in frames that are successfully received (note definition above of frames successfully received). The approximate minimum time for counter rollover is 58 minutes.')
rh1PerfMonErrorEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonErrorEnergy.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonErrorEnergy.setDescription('The total length in bytes of all error energy. Used to calculate network utilization. Errors included in this counter are: late collisions, long frames, long fragments, fifo errors, and manchester code violations.')
rh1PerfMonNondataEnergy = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonNondataEnergy.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonNondataEnergy.setDescription('The total length in bytes of all non-data energy. Used to calculate network utilization. Non-data is defined as: collisions, runts and short events.')
rh1PerfMonManchesterViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonManchesterViolations.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonManchesterViolations.setDescription('The number of manchester code violations.')
rh1PerfMonBand1Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonBand1Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonBand1Frames.setDescription('The number of frames transmitted from this port (e.g., to a workstation) summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonBand2Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonBand2Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonBand2Frames.setDescription('The number of frames transmitted from this port (e.g., to a workstation) summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonBand3Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonBand3Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonBand3Frames.setDescription('The number of frames transmitted from this port (e.g., to a workstation) summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonBand4Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonBand4Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonBand4Frames.setDescription('The number of frames transmitted from this port (e.g., to a workstation) summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonBand5Frames = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonBand5Frames.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonBand5Frames.setDescription('The number of frames transmitted from this port (e.g., to a workstation) summarized into packet size bands. The sizes are with respect to LLC data.')
rh1PerfMonPortCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonPortCounts.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonPortCounts.setDescription('This object aggregates selected stats into one coded bit string. The definition of each position in the string is: Octet position Object 1-4 FramesReceivedOk 5-8 OctetsReceivedOk 9-12 Collisions 13-16 LateCollisions 17-20 Runts 21-14 ShortEvents 25-18 FrameTooLongs 29-32 AutoPartitions 33-36 LongFragments 37-40 FifoErrors 41-44 FramesTransmittedOK 45-48 OctetsTransmitedOK 49-52 ErrorEnergy 53-56 NondataEnergy 57-60 ManchesterCodeViolations Specifications for the values contained in this MIB object can be found in the specifications for the individual objects.')
rh1PerfMonFrameSize1Bound = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonFrameSize1Bound.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonFrameSize1Bound.setDescription('A duplicate entry of rh1PerfMonSegFrameSizeXBound allow graphing of port stats with mimimum number of gets.')
rh1PerfMonFrameSize2Bound = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonFrameSize2Bound.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonFrameSize2Bound.setDescription('A duplicate entry of rh1PerfMonSegFrameSizeXBound allow graphing of port stats with mimimum number of gets.')
rh1PerfMonFrameSize3Bound = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonFrameSize3Bound.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonFrameSize3Bound.setDescription('A duplicate entry of rh1PerfMonSegFrameSizeXBound allow graphing of port stats with mimimum number of gets.')
rh1PerfMonFrameSize4Bound = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 3, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1PerfMonFrameSize4Bound.setStatus('mandatory')
if mibBuilder.loadTexts: rh1PerfMonFrameSize4Bound.setDescription('A duplicate entry of rh1PerfMonSegFrameSizeXBound allow graphing of port stats with mimimum number of gets.')
rh1DownloadImageFile = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 4, 1), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1DownloadImageFile.setStatus('mandatory')
if mibBuilder.loadTexts: rh1DownloadImageFile.setDescription("The file that the Rack requests to be downloaded from the server. This object's value is the full or relative path of the file on the TFTP server containing the image to be downloaded. The syntax of the string depends upon the operating system of the TFTP host. (Forward slashes, backslashes, MS-DOS drive indicators, and 'at' signs may be in the string.) This object is reset after re-boot.")
rh1DownloadIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 4, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1DownloadIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1DownloadIpAddr.setDescription('The IP address the Rack sends to request a download. A zero value indicates that it has not been set. This object is re-set after reboot.')
rh1DownloadMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 4, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1DownloadMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1DownloadMacAddr.setDescription('The MAC address of a non-UDP/IP download server. If the either rh1EnhCtrlRackIpAddr or rh1DownloadIpAddr is not set (ie 0.0.0.0), then this address will be used to download using TFTP over Ethernet. This object is reset after re- boot.')
rh1DownloadCardTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 4, 4), )
if mibBuilder.loadTexts: rh1DownloadCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1DownloadCardTable.setDescription('A list of Download capability entries.')
rh1DownloadCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 4, 4, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1DownloadCardID"))
if mibBuilder.loadTexts: rh1DownloadCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1DownloadCardEntry.setDescription('Entry into the download capability card table.')
rh1DownloadCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1DownloadCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1DownloadCardID.setDescription('Index into the download execution table.')
rh1DownloadExecute = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-execute", 1), ("execute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1DownloadExecute.setStatus('mandatory')
if mibBuilder.loadTexts: rh1DownloadExecute.setDescription('Setting the value to 2 causes the rack to initiate a download request to the Download Server for the selected card. After a download, the card is reset.')
rh1AddrTrackSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 1), )
if mibBuilder.loadTexts: rh1AddrTrackSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackSegmentTable.setDescription('A list of Address tracking entries.')
rh1AddrTrackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 1, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1AddrTrackSegmentID"))
if mibBuilder.loadTexts: rh1AddrTrackEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackEntry.setDescription('Entry into the address tracking segment table.')
rh1AddrTrackSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1AddrTrackSegmentID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackSegmentID.setDescription('Index into the address tracking segement table')
rh1AddrTrackSendHubLearn = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("learning", 1), ("send-learn-packet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1AddrTrackSendHubLearn.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackSendHubLearn.setDescription('Writing (2) is used to cause the special map learn frame to be sent.')
rh1AddrTrackSendHubLearnCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("inhibit-learn-packet", 2), ("allow-learn-packet", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1AddrTrackSendHubLearnCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackSendHubLearnCtrl.setDescription('Used enable/inhibit the use of the special map learn frames.')
rh1AddrTrackPortTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2), )
if mibBuilder.loadTexts: rh1AddrTrackPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackPortTable.setDescription('A list of address tracking entries.')
rh1AddrTrackPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1AddrTrackCardID"), (0, "RH-ATT-MIB", "rh1AddrTrackPortID"))
if mibBuilder.loadTexts: rh1AddrTrackPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackPortEntry.setDescription('Entry into the address tracking port table')
rh1AddrTrackCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1AddrTrackCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackCardID.setDescription('An index into the address tracking port table.')
rh1AddrTrackPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1AddrTrackPortID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackPortID.setDescription('An index into the address tracking port table.')
rh1AddrTrackDetectedMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1AddrTrackDetectedMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackDetectedMacAddr.setDescription("This is the MAC address that the Rack has detected on this port. The address isn't recorded if there is a CRC error; but is recorded if the length field is incorrect or the frame too long. For 'singly', 'multiply' and 'none' connection types, this address is the last source address. For 'hub connected' connections, this is the MAC address of the connected hub.")
rh1AddrTrackDetectedAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("singly-connected", 2), ("connected-to-another-hub", 3), ("multiply-connected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1AddrTrackDetectedAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackDetectedAddrType.setDescription('The detected type of connectivity associated with this port.')
rh1AddrTrackAuthMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1AddrTrackAuthMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackAuthMacAddr.setDescription('This is the authorized MAC address the hub was configured with for this port. The value is settable to allow the administration station to establish a source address for security reasons.')
rh1AddrTrackAuthAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("singly-connected", 2), ("connected-to-another-hub", 3), ("multiply-connected", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1AddrTrackAuthAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackAuthAddrType.setDescription('The authorized connectivity associated with this port.')
rh1AddrTrackNewHubAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 5, 2, 1, 7), OctetString())
if mibBuilder.loadTexts: rh1AddrTrackNewHubAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1AddrTrackNewHubAddr.setDescription('Indicates that a new, adjacent hub has been detected. The MAC address of that hub is included. This object included in traps only.')
rh1EnhCtrlResetRackConfig = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlResetRackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlResetRackConfig.setDescription('This action resets all configuration data to be equal to the factory default values stored in firmware. This action also causes a reset. Note, that when new cards are inserted, or cards are moved, the configuration information associated with the slot is used.')
rh1EnhCtrlRackVersion = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlRackVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlRackVersion.setDescription('The hardware release number for the rack which is made up of slot 0, and the backplane. The numbers are in the format x backplane y.m slot zero This numbers x and y will also be reflected in the text string associated with the sysDesc object.')
rh1EnhCtrlPowerTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 3), )
if mibBuilder.loadTexts: rh1EnhCtrlPowerTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPowerTable.setDescription("Information about the two power supply 'slots'")
rh1EnhCtrlPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 3, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1EnhCtrlPowerID"))
if mibBuilder.loadTexts: rh1EnhCtrlPowerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPowerEntry.setDescription('Entry into the Enhanced Control Power supply table')
rh1EnhCtrlPowerID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlPowerID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPowerID.setDescription('Index into the power supply table.')
rh1EnhCtrlPowerType = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("alternate", 3), ("standard", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlPowerType.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPowerType.setDescription("For each of the two 'slots' for a power supply, this object defines what type of power supply is installed. Type none means no supply is present. Type alternate means that a supply other than the standard supply is installed. Type standard is a single slot fault tolerant unit. If two standard supplies are detected, the rack has power supply redundancy installed.")
rh1EnhCtrlCardMap = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlCardMap.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlCardMap.setDescription('A string of bits which reflects the current configuration of units which are viewed by group managed objects. In each bit position, a 1 is present, and a 0 is not present. The low order bit (bit 0) represents slot 0 which cannot be a repeater card, hence it is always 0, because this object applies to 10baseT cards only. Bit 1 is slot one etc.')
rh1EnhCtrlRackMap = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlRackMap.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlRackMap.setDescription('The card type for each card in the rack, contained in one string. For each card (not including slot 0), there are 5 octets which define manufacturer, board type, board variant, if the board has rackmaster capability, and f/w base (applicable to 10Base-T only). Format of the octet string is: octet 1 bit 0-3 F board present 3 board present but non-functional 0 no board present bit 4-7 F rack master capable 0 not master capable 2-3 manufacturer backplane registers 4-5 type/variant backplane registers (bit 3-7 of variant = f/w base) By convention, boards with the same type and f/w base have a common download file image even if the variant is different.')
rh1EnhCtrlRackmaster = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlRackmaster.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlRackmaster.setDescription('An index (rh1EnhCrlCardID) to the current rack master.')
rh1EnhCtrlLastRackmaster = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlLastRackmaster.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlLastRackmaster.setDescription('An index (rh1EnhCrlCardID) to the last rack master. A non zero value here means that since the last reset, a card successfully became rack master, then relinquished control.')
rh1EnhCtrlGatewayIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlGatewayIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlGatewayIpAddr.setDescription('The IP address of a gateway server to which all IP packets will be sent whose destination network is not the local network.')
rh1EnhCtrlNetworkMask = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlNetworkMask.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlNetworkMask.setDescription("The subnet mask that is used in the comparison of the hub IP address to the destination IP address to determine whether or not the destination IP address is on the local subnetwork. If it is not, and if a gateway IP address has been administered, then the gateway will be used to deliver the packet. Although this object is registered in the AT&T proprietary object space, it is the same as the RFC 1066 object: ipAdEntNetMask. The standard object is not implemented since the entire 'ip' group cannot be implemented at this time.")
rh1EnhCtrlRackIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlRackIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlRackIpAddr.setDescription("The rackmaster's IP address. This object's value is the IP address in dot notation.")
rh1EnhCtrlRs232State = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-connected", 1), ("connected", 2), ("connected-logged-in", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlRs232State.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlRs232State.setDescription('Indicates whether the RS-232 port is active (i.e., something connected) and if active, whether the user is currently logged in.')
rh1EnhCtrlRs232DataRate = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("bps-300", 1), ("bps-1200", 2), ("bps-2400", 3), ("bps-4800", 4), ("bps-9600", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlRs232DataRate.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlRs232DataRate.setDescription('Indicates the data rate the RS-232 port is set at.')
rh1EnhCtrlTrapCountPeriodCtrl = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlTrapCountPeriodCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlTrapCountPeriodCtrl.setDescription("The transmission period (seconds) of the Trap(count) packet. The valid range of timer values is 1 through 3,600 (1 hour). A value of all 0's causes the packet to never be sent. Periodic transmission of this trap is used as a keepalive function.")
rh1EnhCtrlFlashRackStatusLED = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("noflash", 2), ("flash", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlFlashRackStatusLED.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlFlashRackStatusLED.setDescription('When set to FLASH, the main functional status indicator, an LED labelled Rack Status will flash at a slow rate (about 30 times per minute). This object allows a management station to mark an arbitrary card and is intended to facilitate servicing operations (although the significance of the flashing LED is at the discretion of the management station operator). Flashing applies to all LED colors (red, amber, and green) and does not stop the LED from changing color. This object is reset to NOFLASH after an agent reset.')
rh1EnhCtrlSendTrapConfig = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sending", 1), ("send-trap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlSendTrapConfig.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlSendTrapConfig.setDescription('Writing (2) causes the trap(config) packet to be sent.')
rh1EnhCtrlMngrTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 16), )
if mibBuilder.loadTexts: rh1EnhCtrlMngrTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlMngrTable.setDescription('A list of addresses for multiple management station which get traps.')
rh1EnhCtrlMngrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 16, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1EnhCtrlMngrID"))
if mibBuilder.loadTexts: rh1EnhCtrlMngrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlMngrEntry.setDescription('Entry into the Enhanced Control Manager table')
rh1EnhCtrlMngrID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlMngrID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlMngrID.setDescription('Index into the manager table.')
rh1EnhCtrlTrapMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 16, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlTrapMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlTrapMacAddr.setDescription('The MAC address(es) to which hubs send Trap packets if the IP address is not set. The single default is a multicast address. That address might be changed from the default in order to create multiple logical subnetworks each handled with a different management station, and to improve security. Up to four values are supported.')
rh1EnhCtrlTrapIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 16, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlTrapIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlTrapIpAddr.setDescription('The IP address(es) to which hubs send Trap packets. 0.0.0.0 defines not set. Up to four values are supported.')
rh1EnhCtrlCardTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17), )
if mibBuilder.loadTexts: rh1EnhCtrlCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlCardTable.setDescription('A list of enhanced control entries.')
rh1EnhCtrlCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1EnhCtrlCardID"))
if mibBuilder.loadTexts: rh1EnhCtrlCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlCardEntry.setDescription('Entry into the Enhanced Control Card table')
rh1EnhCtrlCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlCardID.setDescription('Index into the Enhanced control card table.')
rh1EnhCtrlSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlSegment.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlSegment.setDescription('The backplane segment which the card is attached to. This information is coded into the first three bits (0-2) of the octet. Set (1) means there is a connection, and reset (0) means there is no connection. Bit 0 is segment 1 (primary administration segment) and bits 1 and 2 are segments 2 and 3 respectively.')
rh1EnhCtrlCardVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlCardVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlCardVersion.setDescription('The CPU and MPR hardware, ROM, and software (flash) version of the card. For non MPRs, the ROM and software versions are 0.0 octet 1-2 H/W version (backplane register) 3-4 ROM version (MPRs only) 5-6 S/W version (Flash version MPRs only) The versions are in the format major.minor. The major H/W version and the major S/W version are reflected in the sysDesc string.')
rh1EnhCtrlCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlCardType.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlCardType.setDescription('The same 5 bytes defined in rh1EnhCtrlRackMap for this card. Duplicated here to simplify management station screen development, MIB browsing, and traps.')
rh1EnhCtrlCardIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlCardIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlCardIpAddr.setDescription('The IP Address associated with the primary agent for the card. Depending on the card chosen, a set may change the address used, or may only change the stored address reported by the rackmaster agent. For cards which use the rack master as the primary agent, this address will be the same as rh1EnhCtrlRackIpAddr, a set to either changes both. This method of changing the rack IP address IS NOT RECOMMENDED, since some managers will not associate the state trap of a CardIP change with the resulting rackIP change. This object is intended to allow one management application with a view of the rackmaster to automatically launch other applications for other cards with a different MIB and IP addresss. It should only be used to track the addresses of these types of cards.')
rh1EnhCtrlResetCardConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlResetCardConfig.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlResetCardConfig.setDescription('This action resets the card configuration data to be equal to the factory default values stored the firmware. These values are Port state, Authorized addresses, Authorized types, Link Integrity, and Extended Distance. This action also causes the card to reset.')
rh1EnhCtrlFlashCardStatusLED = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 17, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("noflash", 2), ("flash", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlFlashCardStatusLED.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlFlashCardStatusLED.setDescription('When set to FLASH, the main functional status indicator, an LED labelled Status will flash at a slow rate (about 30 times per minute). This object allows a management station to mark an arbitrary card and is intended to facilitate servicing operations (although the significance of the flashing LED is at the discretion of the management station operator). Flashing applies to all LED colors (red, amber, and green) and does not stop the LED from changing color. This object is reset to NOFLASH after an agent reset.')
rh1EnhCtrlPortTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18), )
if mibBuilder.loadTexts: rh1EnhCtrlPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPortTable.setDescription('A list of Enhanced control entries.')
rh1EnhCtrlPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1EnhPortCtrlCardID"), (0, "RH-ATT-MIB", "rh1EnhCtrlPortID"))
if mibBuilder.loadTexts: rh1EnhCtrlPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPortEntry.setDescription('Entry into the enhanced control port table')
rh1EnhPortCtrlCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhPortCtrlCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhPortCtrlCardID.setDescription('An index into the enhanced control port table.')
rh1EnhCtrlPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlPortID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPortID.setDescription('An index into the enhanced control port table.')
rh1EnhCtrlLinkIntegrityCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlLinkIntegrityCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlLinkIntegrityCtrl.setDescription('Link integrity checking is enabled/disabled on a per port basis.')
rh1EnhCtrlLinkIntegrityAlarmingCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlLinkIntegrityAlarmingCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlLinkIntegrityAlarmingCtrl.setDescription("Enables/disables alarming (i.e., trap(alarm)) on a port basis for the link integrity alarming feature. The reason to add control at the hub for suppressing this alarm condition has to do with the frequency with which these alarms could occur. We want to be able to minimize the number of alarms sent over the internet. LI alarming is one candidate for 'minimizing'.")
rh1EnhCtrlLinkIntegrityState = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-applicable", 1), ("connected", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlLinkIntegrityState.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlLinkIntegrityState.setDescription("Indicates whether the link is good or not. If the port or link integrity is disabled, the value is 'not applicable'. A Trap(alarm) is generated whenever the state transitions from connected ---> broken or from broken -> connected.")
rh1EnhCtrlExtendedDistanceCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlExtendedDistanceCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlExtendedDistanceCtrl.setDescription('Enables/disables the extended distance option.')
rh1EnhCtrlPortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 18, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlPortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPortConfig.setDescription('A collection of configuration information for a specific port. The data value of this object contains the data values associated with the following objects. Since the object identifiers and length indicators for the individual objects are not included, the octet string is positionally encoded. This object has been defined for efficiency reasons. Octet Object Value 1 rh1BasicCtrlPortCtrl 2-7 rh1AddrTrackAuthMacAddr 8 rh1AddrTrackAuthAddrType 9 rh1EnhCtrlLinkIntegrityCtrl 10 rh1EnhCtrlLinkIntegrityAlarmCtrl 11 rh1EnhCtrlExtendedDistanceCtrl')
rh1EnhCtrlPAPortCtrl = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlPAPortCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPAPortCtrl.setDescription('The administrator settable state of the Private Administration port. Indicates whether the port has been administratively disabled or whether it is in the normal, enabled state. A disabled port neither transmits nor receives.')
rh1EnhCtrlPALinkIntegrityState = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("connected", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlPALinkIntegrityState.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlPALinkIntegrityState.setDescription('Indicates whether the link is good or not. This value is valid even if the port is disabled.')
rh1EnhCtrlSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 21), )
if mibBuilder.loadTexts: rh1EnhCtrlSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlSegmentTable.setDescription(' ')
rh1EnhCtrlSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 21, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1EnhCtrlSegmentID"))
if mibBuilder.loadTexts: rh1EnhCtrlSegmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlSegmentEntry.setDescription(' ')
rh1EnhCtrlSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 21, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlSegmentID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlSegmentID.setDescription(' ')
rh1EnhCtrlSegConfigReset = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlSegConfigReset.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlSegConfigReset.setDescription('This action resets the segment configuration data (for Segmentation, FrameSizeBounds, and Security) to be equal to the factory default values stored the firmware. This action also causes a rack reset.')
rh1EnhCtrlConfigResetHub = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1EnhCtrlConfigResetHub.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlConfigResetHub.setDescription('This action resets the Hub level configuration data to be equal to the factory default values stored in the firmware. These values are: Hub IP address, Trap IP addresses, Gateway IP address, Network mask, Trap MAC addresses, Count trap period, RS232 data rate, and Inband sets. This action also causes a rack reset.')
rh1EnhCtrlSegmentMap = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 6, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1EnhCtrlSegmentMap.setStatus('mandatory')
if mibBuilder.loadTexts: rh1EnhCtrlSegmentMap.setDescription("This bit string indicates which segments have MPR card present. Only segments with MPR cards attached have valid statistics available. If a bit is set, the segment has a card: bit 0 is segment 1, bit 1 is segment 2, and bit 2 is segment 3. Bits 4 to 7 are don't care.")
rh1SecPassword = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 1), OctetString()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: rh1SecPassword.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecPassword.setDescription("The community string (password) for which the Rack will allow SETs. This object is defined for setting/changing the password. The password sent in SET packets is sent in the Community Name field which is in the packet's header (i.e., it is not sent as an object). Community string 'public' can do monitoring (i.e., GETs). Only control (i.e., SETs) needs password protection. This scheme allows for multiple monitor stations but only one control station.")
rh1SecBadComPasswords = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecBadComPasswords.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecBadComPasswords.setDescription('Indicates a login attempt on the serial port was attempted with the wrong password. Although this is an important alarm, no acknowledgement strategy is proposed because there will probably be many of these sent - especially if some guess algorithm is being used.')
rh1SecSettingAdminMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecSettingAdminMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecSettingAdminMacAddr.setDescription("The source MAC address of the last SNMP Set packet processed by the hub. Also, if the state of the hub is changed via the RS-232 interface, this object is sent. In that case, the object's value is encoded all 0's.")
rh1SecSettingAdminIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecSettingAdminIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecSettingAdminIpAddr.setDescription('The source IP address of the last SNMP Set packet processed by the hub.')
rh1SecInbandSetsState = MibScalar((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("disable-all", 2), ("disable-public", 3), ("disable-private", 4), ("enabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecInbandSetsState.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecInbandSetsState.setDescription('Indicates whether the hub will permit SNMP SETs received on the network. SETs can only be disabled or enabled via the RS-232 port.')
rh1SecSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 6), )
if mibBuilder.loadTexts: rh1SecSegmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecSegmentTable.setDescription('A list of Security capability entries.')
rh1SecSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 6, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1SecSegmentID"))
if mibBuilder.loadTexts: rh1SecSegmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecSegmentEntry.setDescription('Entry into the Security segment table')
rh1SecSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecSegmentID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecSegmentID.setDescription('Index into the table.')
rh1SecEavesdroppingCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SecEavesdroppingCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecEavesdroppingCtrl.setDescription('Enables/disables jamming of frames to non-destination ports. This is enabled/disabled on a segment basis.')
rh1SecIntrusionCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SecIntrusionCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecIntrusionCtrl.setDescription('Enables/disables filtering on a segment basis.')
rh1SecIntrusionAlarmCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rh1SecIntrusionAlarmCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecIntrusionAlarmCtrl.setDescription('Enables/disables alarming (i.e., trap(intrusion)) on a segment basis for the intrusion protection security feature.')
rh1SecPortTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 7), )
if mibBuilder.loadTexts: rh1SecPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecPortTable.setDescription('A list of Security capability entries.')
rh1SecPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 7, 1), ).setIndexNames((0, "RH-ATT-MIB", "rh1SecCardID"), (0, "RH-ATT-MIB", "rh1SecPortID"))
if mibBuilder.loadTexts: rh1SecPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecPortEntry.setDescription('Entry into the Security port table')
rh1SecCardID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecCardID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecCardID.setDescription('An index into the security port table.')
rh1SecPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecPortID.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecPortID.setDescription('An index into the security port table.')
rh1SecIntrusionAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 7, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecIntrusionAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecIntrusionAddr.setDescription("If an intruder has been detected on this port, the value of this object is the source address of the intruder. If the value is all 0's, no intrusion is detected.")
rh1SecIntrusionTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 7, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecIntrusionTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecIntrusionTimeStamp.setDescription('The timestamp of the last intrusion. It is a snapshot of sysUpTime.')
rh1SecIntrusions = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 14, 7, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rh1SecIntrusions.setStatus('mandatory')
if mibBuilder.loadTexts: rh1SecIntrusions.setDescription("Indicates the number of times intrusion has been detected on this port. If the value is all 0's, no intrusion is detected.")
mibBuilder.exportSymbols("RH-ATT-MIB", rh1BasicCtrlCardCapacity=rh1BasicCtrlCardCapacity, rh1PerfMonSegmentEntry=rh1PerfMonSegmentEntry, rh1PerfMonErrorEnergy=rh1PerfMonErrorEnergy, rh1AddrTrackSegmentID=rh1AddrTrackSegmentID, rh1SecPortID=rh1SecPortID, rh1SelfTestExecuteCardSelfTest1=rh1SelfTestExecuteCardSelfTest1, rh1PerfMonCollisions=rh1PerfMonCollisions, rh1PerfMonSegFrameSize1Bound=rh1PerfMonSegFrameSize1Bound, rh1PerfMonFrameSize4Bound=rh1PerfMonFrameSize4Bound, rh1PerfMonSegTotalFifoErrors=rh1PerfMonSegTotalFifoErrors, rh1AddrTrackAuthMacAddr=rh1AddrTrackAuthMacAddr, rh1SecIntrusionCtrl=rh1SecIntrusionCtrl, rh1EnhCtrlRs232DataRate=rh1EnhCtrlRs232DataRate, rh1AddrTrackSendHubLearn=rh1AddrTrackSendHubLearn, rh1PerfMonFrameSize3Bound=rh1PerfMonFrameSize3Bound, rh1SelfTestRackHealthData=rh1SelfTestRackHealthData, rh1PerfMonFrameTooLongs=rh1PerfMonFrameTooLongs, rh1EnhCtrlMngrID=rh1EnhCtrlMngrID, rh1AddrTrackCapability=rh1AddrTrackCapability, rh1EnhCtrlLinkIntegrityState=rh1EnhCtrlLinkIntegrityState, rh1SelfTestCardEntry=rh1SelfTestCardEntry, rh1PerfMonBand1Frames=rh1PerfMonBand1Frames, att_mgmt=att_mgmt, rh1EnhCtrlResetRackConfig=rh1EnhCtrlResetRackConfig, rh1SecInbandSetsState=rh1SecInbandSetsState, rh1PerfMonPortCounts=rh1PerfMonPortCounts, rh1SecPortTable=rh1SecPortTable, rh1BasicCtrlPortCtrl=rh1BasicCtrlPortCtrl, rh1EnhCtrlMngrTable=rh1EnhCtrlMngrTable, rh1PerfMonFifoErrors=rh1PerfMonFifoErrors, rh1BasicCtrlRackMAC=rh1BasicCtrlRackMAC, rh1PerfMonSegTotalCollisions=rh1PerfMonSegTotalCollisions, rh1PerfMonFrameSize2Bound=rh1PerfMonFrameSize2Bound, rh1EnhCtrlLastRackmaster=rh1EnhCtrlLastRackmaster, rh1EnhCtrlConfigResetHub=rh1EnhCtrlConfigResetHub, rh1PerfMonSegTotalLateCollisions=rh1PerfMonSegTotalLateCollisions, rh1PerfMonPortTable=rh1PerfMonPortTable, rh1SecSegmentEntry=rh1SecSegmentEntry, rh1DownloadCapability=rh1DownloadCapability, rh1BasicCtrlNumberOfPorts=rh1BasicCtrlNumberOfPorts, rh1PerfMonSegTotalOctetsProcessedOk=rh1PerfMonSegTotalOctetsProcessedOk, rh1PerfMonSegFrameSize3Bound=rh1PerfMonSegFrameSize3Bound, rh1AddrTrackPortID=rh1AddrTrackPortID, rh1EnhCtrlTrapMacAddr=rh1EnhCtrlTrapMacAddr, rh1PerfMonFrameSize1Bound=rh1PerfMonFrameSize1Bound, rh1SelfTestResetMPR=rh1SelfTestResetMPR, rh1AddrTrackNewHubAddr=rh1AddrTrackNewHubAddr, rh1SelfTestExecuteCardSelfTest2=rh1SelfTestExecuteCardSelfTest2, rh1PerfMonSegmentID=rh1PerfMonSegmentID, rh1EnhCtrlSegmentID=rh1EnhCtrlSegmentID, rh1SecEavesdroppingCtrl=rh1SecEavesdroppingCtrl, rh1EnhCtrlPAPortCtrl=rh1EnhCtrlPAPortCtrl, rh1DownloadCardID=rh1DownloadCardID, rh1EnhCtrlCapability=rh1EnhCtrlCapability, rh1EnhCtrlSegmentMap=rh1EnhCtrlSegmentMap, rh1BasicCtrlCardEntry=rh1BasicCtrlCardEntry, rh1EnhCtrlRackMap=rh1EnhCtrlRackMap, rh1EnhCtrlTrapCountPeriodCtrl=rh1EnhCtrlTrapCountPeriodCtrl, rh1SelfTestCardResetTimeStamp=rh1SelfTestCardResetTimeStamp, rh1EnhCtrlSendTrapConfig=rh1EnhCtrlSendTrapConfig, rh1SelfTestCardID=rh1SelfTestCardID, rh1PerfMonOctetsTransmittedOk=rh1PerfMonOctetsTransmittedOk, rh1SecSegmentTable=rh1SecSegmentTable, rh1EnhCtrlTrapIpAddr=rh1EnhCtrlTrapIpAddr, rh1AddrTrackCardID=rh1AddrTrackCardID, rh1EnhCtrlRackIpAddr=rh1EnhCtrlRackIpAddr, rh1SecPassword=rh1SecPassword, rh1EnhCtrlPALinkIntegrityState=rh1EnhCtrlPALinkIntegrityState, rh1EnhCtrlLinkIntegrityAlarmingCtrl=rh1EnhCtrlLinkIntegrityAlarmingCtrl, rh1EnhCtrlPortID=rh1EnhCtrlPortID, rh1EnhCtrlSegmentEntry=rh1EnhCtrlSegmentEntry, rh1PerfMonManchesterViolations=rh1PerfMonManchesterViolations, rh1EnhCtrlPowerTable=rh1EnhCtrlPowerTable, rh1EnhCtrlSegConfigReset=rh1EnhCtrlSegConfigReset, rh1BasicCtrlPortID=rh1BasicCtrlPortID, rh1SelfTestCardHealthState=rh1SelfTestCardHealthState, rh1AddrTrackDetectedAddrType=rh1AddrTrackDetectedAddrType, rh1EnhCtrlCardIpAddr=rh1EnhCtrlCardIpAddr, rh1PerfMonSegTotalBand3Frames=rh1PerfMonSegTotalBand3Frames, rh1SecBadComPasswords=rh1SecBadComPasswords, rh1PerfMonSegTotalManchesterViolations=rh1PerfMonSegTotalManchesterViolations, rh1BasicCtrlPortTable=rh1BasicCtrlPortTable, rh1DownloadCardEntry=rh1DownloadCardEntry, rh1PerfMonOctetsReceivedOk=rh1PerfMonOctetsReceivedOk, rh1SecIntrusionTimeStamp=rh1SecIntrusionTimeStamp, rh1PerfMonSegTotalBand5Frames=rh1PerfMonSegTotalBand5Frames, rh1SecIntrusionAlarmCtrl=rh1SecIntrusionAlarmCtrl, rh1PerfMonSegmentTable=rh1PerfMonSegmentTable, rh1PerfMonSegTotalFramesProcessedOk=rh1PerfMonSegTotalFramesProcessedOk, rh1SecPortEntry=rh1SecPortEntry, rh1SecCardID=rh1SecCardID, rh1SelfTestCardTable=rh1SelfTestCardTable, rh1EnhCtrlCardEntry=rh1EnhCtrlCardEntry, rh1AddrTrackSegmentTable=rh1AddrTrackSegmentTable, rh1EnhCtrlGatewayIpAddr=rh1EnhCtrlGatewayIpAddr, rh1EnhCtrlExtendedDistanceCtrl=rh1EnhCtrlExtendedDistanceCtrl, rh1PerfMonAutoPartitions=rh1PerfMonAutoPartitions, rh1EnhCtrlFlashRackStatusLED=rh1EnhCtrlFlashRackStatusLED, rh1EnhCtrlCardVersion=rh1EnhCtrlCardVersion, rh1PerfMonBand4Frames=rh1PerfMonBand4Frames, rh1AddrTrackPortEntry=rh1AddrTrackPortEntry, rh1PerfMonCapability=rh1PerfMonCapability, rh1EnhCtrlPortEntry=rh1EnhCtrlPortEntry, rh1PerfMonCardID=rh1PerfMonCardID, rh1PerfMonBand2Frames=rh1PerfMonBand2Frames, rh1EnhPortCtrlCardID=rh1EnhPortCtrlCardID, rh1PerfMonSegTotalShortEvents=rh1PerfMonSegTotalShortEvents, rh1AddrTrackSendHubLearnCtrl=rh1AddrTrackSendHubLearnCtrl, att_2=att_2, rh1PerfMonFramesTransmittedOk=rh1PerfMonFramesTransmittedOk, rh1DownloadCardTable=rh1DownloadCardTable, rh1PerfMonNondataEnergy=rh1PerfMonNondataEnergy, att_rh1xe=att_rh1xe, rh1SecSettingAdminMacAddr=rh1SecSettingAdminMacAddr, rh1BasicCtrlCapability=rh1BasicCtrlCapability, rh1SelfTestCardHealthData=rh1SelfTestCardHealthData, rh1PerfMonSegTotalBand1Frames=rh1PerfMonSegTotalBand1Frames, rh1EnhCtrlResetCardConfig=rh1EnhCtrlResetCardConfig, rh1SelfTestExecuteSelfTest2=rh1SelfTestExecuteSelfTest2, att_rh1products=att_rh1products, rh1BasicCtrlCardID=rh1BasicCtrlCardID, rh1DownloadMacAddr=rh1DownloadMacAddr, att_products=att_products, rh1PerfMonSegTotalNondataEnergy=rh1PerfMonSegTotalNondataEnergy, rh1BasicPortCtrlCardID=rh1BasicPortCtrlCardID, rh1SecIntrusions=rh1SecIntrusions, rh1EnhCtrlPortTable=rh1EnhCtrlPortTable, rh1SecSettingAdminIpAddr=rh1SecSettingAdminIpAddr, rh1PerfMonSegFrameSize2Bound=rh1PerfMonSegFrameSize2Bound, rh1SecIntrusionAddr=rh1SecIntrusionAddr, rh1EnhCtrlFlashCardStatusLED=rh1EnhCtrlFlashCardStatusLED, rh1PerfMonPortID=rh1PerfMonPortID, rh1BasicCtrlPortType=rh1BasicCtrlPortType, rh1PerfMonLateCollisions=rh1PerfMonLateCollisions, rh1EnhCtrlPowerID=rh1EnhCtrlPowerID, rh1EnhCtrlPowerEntry=rh1EnhCtrlPowerEntry, rh1SelfTestRackHealthState=rh1SelfTestRackHealthState, rh1PerfMonBand3Frames=rh1PerfMonBand3Frames, rh1BasicCtrlCardTable=rh1BasicCtrlCardTable, rh1AddrTrackAuthAddrType=rh1AddrTrackAuthAddrType, rh1AddrTrackEntry=rh1AddrTrackEntry, rh1EnhCtrlRs232State=rh1EnhCtrlRs232State, rh1PerfMonBand5Frames=rh1PerfMonBand5Frames, rh1PerfMonFramesReceivedOk=rh1PerfMonFramesReceivedOk, rh1DownloadImageFile=rh1DownloadImageFile, rh1EnhCtrlPortConfig=rh1EnhCtrlPortConfig, rh1SecSegmentID=rh1SecSegmentID, rh1SecurityCapability=rh1SecurityCapability, rh1SelfTestExecuteSelfTest1=rh1SelfTestExecuteSelfTest1, rh1DownloadExecute=rh1DownloadExecute, att_rh1mgt=att_rh1mgt, rh1BasicCtrlPortEntry=rh1BasicCtrlPortEntry, rh1PerfMonLongFragments=rh1PerfMonLongFragments, rh1DownloadIpAddr=rh1DownloadIpAddr, rh1EnhCtrlRackVersion=rh1EnhCtrlRackVersion, rh1PerfMonSegTotalAutoPartitions=rh1PerfMonSegTotalAutoPartitions, rh1PerfMonSegTotalBand2Frames=rh1PerfMonSegTotalBand2Frames, rh1EnhCtrlLinkIntegrityCtrl=rh1EnhCtrlLinkIntegrityCtrl, rh1EnhCtrlCardID=rh1EnhCtrlCardID, rh1EnhCtrlCardTable=rh1EnhCtrlCardTable, rh1PerfMonShortEvents=rh1PerfMonShortEvents, rh1PerfMonSegCounts=rh1PerfMonSegCounts, rh1EnhCtrlSegmentTable=rh1EnhCtrlSegmentTable, rh1EnhCtrlSegment=rh1EnhCtrlSegment, rh1EnhCtrlNetworkMask=rh1EnhCtrlNetworkMask, rh1SelfTestCapability=rh1SelfTestCapability, rh1PerfMonPortEntry=rh1PerfMonPortEntry, rh1PerfMonRunts=rh1PerfMonRunts, rh1EnhCtrlPowerType=rh1EnhCtrlPowerType, rh1AddrTrackDetectedMacAddr=rh1AddrTrackDetectedMacAddr, rh1PerfMonSegTotalFrameTooLongs=rh1PerfMonSegTotalFrameTooLongs, rh1SelfTestResetRack=rh1SelfTestResetRack, rh1PerfMonSegTotalErrorEnergy=rh1PerfMonSegTotalErrorEnergy, rh1PerfMonSegTotalBand4Frames=rh1PerfMonSegTotalBand4Frames, rh1SelfTestResetCard=rh1SelfTestResetCard, rh1EnhCtrlCardMap=rh1EnhCtrlCardMap, rh1AddrTrackPortTable=rh1AddrTrackPortTable, rh1PerfMonSegTotalLongFragments=rh1PerfMonSegTotalLongFragments, rh1EnhCtrlRackmaster=rh1EnhCtrlRackmaster, rh1PerfMonSegTotalRunts=rh1PerfMonSegTotalRunts, rh1PerfMonSegFrameSize4Bound=rh1PerfMonSegFrameSize4Bound, rh1EnhCtrlCardType=rh1EnhCtrlCardType, rh1EnhCtrlMngrEntry=rh1EnhCtrlMngrEntry, rh1BasicCtrlAutoPartitionState=rh1BasicCtrlAutoPartitionState)

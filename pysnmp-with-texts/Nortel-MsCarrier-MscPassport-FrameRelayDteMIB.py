#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-FrameRelayDteMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-FrameRelayDteMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:30:07 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
Counter32, DisplayString, StorageType, InterfaceIndex, Gauge32, Integer32, RowStatus, Unsigned32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Counter32", "DisplayString", "StorageType", "InterfaceIndex", "Gauge32", "Integer32", "RowStatus", "Unsigned32")
EnterpriseDateAndTime, HexString, PassportCounter64, NonReplicated, Link, DashedHexString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "EnterpriseDateAndTime", "HexString", "PassportCounter64", "NonReplicated", "Link", "DashedHexString")
mscComponents, mscPassportMIBs = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscComponents", "mscPassportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, iso, Gauge32, Integer32, ModuleIdentity, IpAddress, TimeTicks, Counter64, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, ObjectIdentity, Unsigned32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "iso", "Gauge32", "Integer32", "ModuleIdentity", "IpAddress", "TimeTicks", "Counter64", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "ObjectIdentity", "Unsigned32", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
frameRelayDteMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32))
mscFrDte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101))
mscFrDteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 1), )
if mibBuilder.loadTexts: mscFrDteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDte components.')
mscFrDteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDte component.')
mscFrDteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDte components. These components can be added and deleted.')
mscFrDteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStorageType.setDescription('This variable represents the storage type value for the mscFrDte tables.')
mscFrDteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mscFrDteIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteIndex.setDescription('This variable represents the index for the mscFrDte tables.')
mscFrDteCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 20), )
if mibBuilder.loadTexts: mscFrDteCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscFrDteCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 20, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteCidDataEntry.setDescription('An entry in the mscFrDteCidDataTable.')
mscFrDteCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscFrDteIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 21), )
if mibBuilder.loadTexts: mscFrDteIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscFrDteIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 21, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteIfEntryEntry.setDescription('An entry in the mscFrDteIfEntryTable.')
mscFrDteIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 21, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscFrDteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 21, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscFrDteProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 22), )
if mibBuilder.loadTexts: mscFrDteProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteProvTable.setDescription('This group contains the provisioned attributes for the FrDte component.')
mscFrDteProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 22, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteProvEntry.setDescription('An entry in the mscFrDteProvTable.')
mscFrDteAcceptUndefinedDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 22, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteAcceptUndefinedDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteAcceptUndefinedDlci.setDescription('This parameter allows previously undefined Data Link Connection Identifiers (DLCIs) to be dynamically accepted in the default remote group. If set to enabled, undefined DLCIs will be accepted, if disabled, they will not.')
mscFrDteStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 23), )
if mibBuilder.loadTexts: mscFrDteStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrDteStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 23, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStateEntry.setDescription('An entry in the mscFrDteStateTable.')
mscFrDteAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 23, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrDteOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 23, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrDteUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 23, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrDteOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 24), )
if mibBuilder.loadTexts: mscFrDteOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscFrDteOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 24, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteOperStatusEntry.setDescription('An entry in the mscFrDteOperStatusTable.')
mscFrDteSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 24, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscFrDteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 25), )
if mibBuilder.loadTexts: mscFrDteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteOperTable.setDescription('This group contains the operational attributes for the FrDte component.')
mscFrDteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 25, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteOperEntry.setDescription('An entry in the mscFrDteOperTable.')
mscFrDteLinkOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 25, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("down", 2), ("polling", 3))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLinkOperState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLinkOperState.setDescription('This attribute describes the operational state of the Link Control protocol. If the interface to the physical link hardware is inactive, the linkOperState is in the down state. The polling state only occurs when the Local Management Interface (LMI) is enabled and the physical link is active. The polling state indicates LMI is polling for its peer. Once communication is established the linkOperState will transition to the active state. If the procedure attribute of the Lmi component is set to none, linkOperState will transition to the active state once the physical link becomes active.')
mscFrDteErrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 26), )
if mibBuilder.loadTexts: mscFrDteErrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrTable.setDescription('This group contains the SNMP frErrEntry attributes for the FrDte component.')
mscFrDteErrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 26, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteErrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrEntry.setDescription('An entry in the mscFrDteErrTable.')
mscFrDteErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 26, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unknownError", 1), ("receiveShort", 2), ("receiveLong", 3), ("illegalDlci", 4), ("dlcmiProtoErr", 5), ("dlcmiUnknownIe", 6), ("dlcmiSequenceErr", 7), ("dlcmiUnknownRpt", 8), ("noErrorSinceReset", 9))).clone('noErrorSinceReset')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteErrType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrType.setDescription("The type of error that was last seen on this interface. The error types are as follows: receiveShort: This error indicates a received frame was discarded because it was less than four octets long or it was missing the Organizationally Unique Identifier (OUI) for a SNAP header. receiveLong: This error indicates a received frame was discarded because it was longer than expected. This error is currently not used on this interface. illegalDlci: This error indicates that a received frame was discarded because it's Q.922 address was not two octets in length. This error could also indicate that a frame was discarded because it was received on a DLCI reserved for LMI which had not been provisioned active. dlcmiProtoErr: This error indicates an LMI frame was received with contents formatted incorrectly. dlcmiUnknownIe: This error indicates that an LMI frame was received which contained an unsupported Information Element (IE) type dlcmiSequenceErr: This error indicates that an LMI frame was received whose Keep Alive Sequence was incorrect. dlcmiUnknownRpt: This error indicates that an LMI frame was received which contained a Report-type Information Element with an invalid type of report. noErrorSinceReset: This error type indicates that there has not been an error since the interface has been reset. unknownError: This error type contains the cumulation of receive frame errors that did not fit one of the MIB error descriptions above. These errors include those counted by the following attributes: ulpUnknownProtocol - A received frame was discarded because the Upper Level Protocol (ULP) encapsulation used was unsupported. badFc - A received frame was discarded because the frame control character was incorrect. defragSequenceErrors - A fragment was received which was discarded due to an out of sequence error detection.")
mscFrDteErrData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 26, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(64, 64)).setFixedLength(64)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteErrData.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrData.setDescription('An octet string containing the first part of the frame in which an error was last detected.')
mscFrDteErrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 26, 1, 4), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteErrTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrTime.setDescription('The time at which the last error was detected and recorded in errType.')
mscFrDteErrDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 26, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteErrDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrDiscards.setDescription('Number of inbound frames dropped because of format errors or because the virtual circuit was not known. Format errors, in this case, are any errors which would prevent the system from recognizing the DLCI and placing the error in the discard category. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteErrFaults = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 26, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteErrFaults.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrFaults.setDescription('This attribute counts the number of times LMI has taken down the interface. When the procedure attribute of the Lmi component is set to none, this counter will not be incremented. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteErrFaultTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 26, 1, 8), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteErrFaultTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrFaultTime.setDescription('The last time the errFaults counter was incremented.')
mscFrDteErrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27), )
if mibBuilder.loadTexts: mscFrDteErrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrStatsTable.setDescription('This group contains error counters for the FrDte.')
mscFrDteErrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"))
if mibBuilder.loadTexts: mscFrDteErrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteErrStatsEntry.setDescription('An entry in the mscFrDteErrStatsTable.')
mscFrDteXmitDiscardPvcDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteXmitDiscardPvcDown.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteXmitDiscardPvcDown.setDescription("Count of transmitted frames discarded because the Dlci or a component positioned in a hierarchically fashion above it (e.g. it's remote group or the FrDte component) was administratively disabled. This counter will wrap around to 0 when it exceeds its maximum count.")
mscFrDteXmitDiscardLmiInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteXmitDiscardLmiInactive.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteXmitDiscardLmiInactive.setDescription('Count of transmitted frames discarded because the Local Management Interface (LMI) was not yet active (i.e. LMI was still in the polling state). This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteXmitDiscardFramerDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteXmitDiscardFramerDown.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteXmitDiscardFramerDown.setDescription('Count of transmitted frames discarded because the framer component was down. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteXmitDiscardPvcInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteXmitDiscardPvcInactive.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteXmitDiscardPvcInactive.setDescription('Count of transmitted frames discarded because the Local Management Interface (LMI) had inactivated or invalidated the Dlci. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteXmitDiscardCirExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteXmitDiscardCirExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteXmitDiscardCirExceeded.setDescription('Count of transmitted frames discarded because CIR was enabled on a Dlci without a HibernationQueue subcomponent and the traffic exceeded the combined Committed and Excess Burst thresholds. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteRecvDiscardPvcDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRecvDiscardPvcDown.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRecvDiscardPvcDown.setDescription("Count of received frames discarded because the Dlci or a component positioned in a hierarchically fashion above it (e.g. it's remote group or the FrDte component) was administratively disabled. This counter will wrap around to 0 when it exceeds its maximum count.")
mscFrDteRecvDiscardLmiInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRecvDiscardLmiInactive.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRecvDiscardLmiInactive.setDescription('Count of received frames discarded because the Local Management Interface (LMI) was not yet active (i.e. LMI was still in the polling state). This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteRecvDiscardPvcInactive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRecvDiscardPvcInactive.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRecvDiscardPvcInactive.setDescription('Count of received frames discarded because the Local Management Interface (LMI) had inactivated or invalidated the Dlci. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteBadFc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteBadFc.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteBadFc.setDescription('Count of received frames discarded because the frame control character was incorrect. This may indicate that the other side of the link is configured for a different link level protocol. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteUlpUnknownProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteUlpUnknownProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteUlpUnknownProtocol.setDescription('Count of received frames discarded because the Upper Level Protocol (ULP) encapsulation used was unsupported. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDefragSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDefragSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDefragSequenceErrors.setDescription('Count of fragments received which were discarded due to out of sequence error detection. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteReceiveShort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteReceiveShort.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteReceiveShort.setDescription('Count of received frames (including LMI frames) discarded because they were less than four octets long or they were missing the Organizationally Unique Identifier (OUI) for a SNAP header. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteIllegalDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteIllegalDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteIllegalDlci.setDescription('Count of received frames discarded because their Q.922 address was not two octets in length. This count also includes frames discarded because they were received on a Dlci reserved for LMI which had not been provisioned active. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlcmiProtoErr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlcmiProtoErr.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlcmiProtoErr.setDescription('Count of received LMI frames whose contents were formatted incorrectly. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlcmiUnknownIe = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlcmiUnknownIe.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlcmiUnknownIe.setDescription('Count of received LMI frames which contained an unsupported Information Element (IE) type. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlcmiSequenceErr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlcmiSequenceErr.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlcmiSequenceErr.setDescription('Count of received LMI frames whose Keep Alive Sequence was incorrect. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlcmiUnknownRpt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 27, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlcmiUnknownRpt.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlcmiUnknownRpt.setDescription('Count of received LMI frames which contained a Report-type Information Element with an invalid type of report. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2))
mscFrDteFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 1), )
if mibBuilder.loadTexts: mscFrDteFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteFramer components.')
mscFrDteFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteFramerIndex"))
if mibBuilder.loadTexts: mscFrDteFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteFramer component.')
mscFrDteFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteFramer components. These components can be added and deleted.')
mscFrDteFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerStorageType.setDescription('This variable represents the storage type value for the mscFrDteFramer tables.')
mscFrDteFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrDteFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerIndex.setDescription('This variable represents the index for the mscFrDteFramer tables.')
mscFrDteFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 10), )
if mibBuilder.loadTexts: mscFrDteFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisional Framer groups.')
mscFrDteFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteFramerIndex"))
if mibBuilder.loadTexts: mscFrDteFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerProvEntry.setDescription('An entry in the mscFrDteFramerProvTable.')
mscFrDteFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscFrDteFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 12), )
if mibBuilder.loadTexts: mscFrDteFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrDteFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteFramerIndex"))
if mibBuilder.loadTexts: mscFrDteFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerStateEntry.setDescription('An entry in the mscFrDteFramerStateTable.')
mscFrDteFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrDteFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrDteFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrDteFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13), )
if mibBuilder.loadTexts: mscFrDteFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscFrDteFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteFramerIndex"))
if mibBuilder.loadTexts: mscFrDteFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerStatsEntry.setDescription('An entry in the mscFrDteFramerStatsTable.')
mscFrDteFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerFrmToIf.setDescription('This attribute counts the number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscFrDteFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerFrmFromIf.setDescription('This attribute counts the number of frames received from the link interface by Framer.')
mscFrDteFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerAborts.setDescription('This attribute counts the total number of aborts received.')
mscFrDteFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerCrcErrors.setDescription('This attribute counts the total number of frames with CRC errors.')
mscFrDteFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerLrcErrors.setDescription('This attribute counts the total number of frames with LRC errors.')
mscFrDteFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerNonOctetErrors.setDescription('This attribute counts the total number of frames that were non octet aligned.')
mscFrDteFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerOverruns.setDescription('This attribute counts the total number of frames received from the link for which overruns occurred.')
mscFrDteFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerUnderruns.setDescription('This attribute counts the total number of frames transmitted to the link for which underruns occurred.')
mscFrDteFramerLargeFrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerLargeFrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerLargeFrmErrors.setDescription('This attribute counts the total number of frames received which were too large. The frame exceeded the maximumFrameLengthLimit provisioned attribute or it contained more than the 255 block hardware limit.')
mscFrDteFramerUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 14), )
if mibBuilder.loadTexts: mscFrDteFramerUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerUtilTable.setDescription('This group contains the link utilization operational data for a Framer component.')
mscFrDteFramerUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteFramerIndex"))
if mibBuilder.loadTexts: mscFrDteFramerUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerUtilEntry.setDescription('An entry in the mscFrDteFramerUtilTable.')
mscFrDteFramerNormPrioLinkUtilToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 14, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerNormPrioLinkUtilToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerNormPrioLinkUtilToIf.setDescription('This attribute is the utilization of the normal priority data sent to the link as a percentage of the available bandwidth on the link. The utilization is the average for the last minute.')
mscFrDteFramerNormPrioLinkUtilFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 2, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteFramerNormPrioLinkUtilFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteFramerNormPrioLinkUtilFromIf.setDescription('This attribute is the utilization of the normal priority data received from the link as a percentage of the available bandwidth on the link. The utilization is the average for the last minute.')
mscFrDteLmi = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3))
mscFrDteLmiRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 1), )
if mibBuilder.loadTexts: mscFrDteLmiRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteLmi components.')
mscFrDteLmiRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLmiIndex"))
if mibBuilder.loadTexts: mscFrDteLmiRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteLmi component.')
mscFrDteLmiRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLmiRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteLmi components. These components cannot be added nor deleted.')
mscFrDteLmiComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLmiComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteLmiStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLmiStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiStorageType.setDescription('This variable represents the storage type value for the mscFrDteLmi tables.')
mscFrDteLmiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrDteLmiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiIndex.setDescription('This variable represents the index for the mscFrDteLmi tables.')
mscFrDteLmiProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 10), )
if mibBuilder.loadTexts: mscFrDteLmiProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiProvTable.setDescription('This group contains the provisioned attributes for the Lmi component.')
mscFrDteLmiProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLmiIndex"))
if mibBuilder.loadTexts: mscFrDteLmiProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiProvEntry.setDescription('An entry in the mscFrDteLmiProvTable.')
mscFrDteLmiProcedures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("none", 1), ("vendorForum", 2), ("ansi", 3), ("ccitt", 5))).clone('ccitt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLmiProcedures.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiProcedures.setDescription('This attribute selects the Local Management Interface (LMI) protocol to be used on the interface. This attribute is equivalent to the SNMP variable frDlcmiState. The vendorForum LMI protocol automatically implies that the DLCI used by the protocol is 1023. The ansi (T1.617 Annex D) and ccitt (Q.933 Annex A) LMI protocols use DLCI 0. If none is selected, no LMI procedures will run on the interface.')
mscFrDteLmiPollingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 30)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLmiPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiPollingInterval.setDescription('This is the number of seconds between successive status enquiry messages. This field corresponds to the parameter T391 described in the ANSI T1.617-1991 Annex D.')
mscFrDteLmiFullEnquiryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLmiFullEnquiryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiFullEnquiryInterval.setDescription('The count of status polls before a full status enquiry message is issued. Every nth poll will request a full status. This field corresponds to the parameter N391 described in the ANSI T1.617-1991 Annex D.')
mscFrDteLmiErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLmiErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiErrorThreshold.setDescription('The number of errors detected within the monitored events window before declaring the link non-functional. This field corresponds to the parameter N392 described in the ANSI T1.617-1991 Annex D.')
mscFrDteLmiMonitoredEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLmiMonitoredEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiMonitoredEvents.setDescription('The number of status polling intervals over which the errorthreshold is counted This is used to determine if the errorThreshold is exceeded. This field corresponds to the parameter N393 described in the ANSI T1.617-1991 Annex D.')
mscFrDteLmiOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 11), )
if mibBuilder.loadTexts: mscFrDteLmiOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiOperTable.setDescription('This group contains the operational attributes for the Lmi component.')
mscFrDteLmiOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLmiIndex"))
if mibBuilder.loadTexts: mscFrDteLmiOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiOperEntry.setDescription('An entry in the mscFrDteLmiOperTable.')
mscFrDteLmiLmiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("running", 1), ("fault", 2), ("initializing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLmiLmiStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLmiLmiStatus.setDescription('This indicates the status of the Frame Relay interface as determined by the performance of the link management interface (LMI). If no LMI is running, lmiStatus will stay in the running state indefinitely.')
mscFrDteRg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4))
mscFrDteRgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 1), )
if mibBuilder.loadTexts: mscFrDteRgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteRg components.')
mscFrDteRgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"))
if mibBuilder.loadTexts: mscFrDteRgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteRg component.')
mscFrDteRgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteRg components. These components can be added and deleted.')
mscFrDteRgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteRgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgStorageType.setDescription('This variable represents the storage type value for the mscFrDteRg tables.')
mscFrDteRgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)))
if mibBuilder.loadTexts: mscFrDteRgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgIndex.setDescription('This variable represents the index for the mscFrDteRg tables.')
mscFrDteRgIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 10), )
if mibBuilder.loadTexts: mscFrDteRgIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscFrDteRgIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"))
if mibBuilder.loadTexts: mscFrDteRgIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgIfEntryEntry.setDescription('An entry in the mscFrDteRgIfEntryTable.')
mscFrDteRgIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRgIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscFrDteRgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 10, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscFrDteRgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 11), )
if mibBuilder.loadTexts: mscFrDteRgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgProvTable.setDescription('This group contains the provisioned attributes for the Remote Group component.')
mscFrDteRgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"))
if mibBuilder.loadTexts: mscFrDteRgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgProvEntry.setDescription('An entry in the mscFrDteRgProvTable.')
mscFrDteRgMaxTransmissionUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(262, 9190)).clone(1604)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRgMaxTransmissionUnit.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgMaxTransmissionUnit.setDescription('The Maximum Transmission Unit size of the largest datagram (including Frame Relay header) which can be sent on the interface.')
mscFrDteRgMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 12), )
if mibBuilder.loadTexts: mscFrDteRgMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgMpTable.setDescription('This group contains the base provisioning data for the Media Application component.')
mscFrDteRgMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"))
if mibBuilder.loadTexts: mscFrDteRgMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgMpEntry.setDescription('An entry in the mscFrDteRgMpTable.')
mscFrDteRgLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 12, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRgLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgLinkToProtocolPort.setDescription('This attribute contains a protocol port component name. The attribute associates the application with a protocol port.')
mscFrDteRgStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 13), )
if mibBuilder.loadTexts: mscFrDteRgStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrDteRgStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"))
if mibBuilder.loadTexts: mscFrDteRgStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgStateEntry.setDescription('An entry in the mscFrDteRgStateTable.')
mscFrDteRgAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrDteRgOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrDteRgUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrDteRgOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 14), )
if mibBuilder.loadTexts: mscFrDteRgOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscFrDteRgOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"))
if mibBuilder.loadTexts: mscFrDteRgOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgOperStatusEntry.setDescription('An entry in the mscFrDteRgOperStatusTable.')
mscFrDteRgSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscFrDteRgLtDlciTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 219), )
if mibBuilder.loadTexts: mscFrDteRgLtDlciTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgLtDlciTable.setDescription('This attribute associates a Rg component with zero or more StDlci components. The Rg and StDlci components must be under the same FrDte component.')
mscFrDteRgLtDlciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 219, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgLtDlciValue"))
if mibBuilder.loadTexts: mscFrDteRgLtDlciEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgLtDlciEntry.setDescription('An entry in the mscFrDteRgLtDlciTable.')
mscFrDteRgLtDlciValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 219, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRgLtDlciValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgLtDlciValue.setDescription('This variable represents both the value and the index for the mscFrDteRgLtDlciTable.')
mscFrDteRgLtDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 219, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscFrDteRgLtDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgLtDlciRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscFrDteRgLtDlciTable.')
mscFrDteRgBfr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15))
mscFrDteRgBfrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 1), )
if mibBuilder.loadTexts: mscFrDteRgBfrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteRgBfr components.')
mscFrDteRgBfrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgBfrIndex"))
if mibBuilder.loadTexts: mscFrDteRgBfrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteRgBfr component.')
mscFrDteRgBfrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRgBfrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteRgBfr components. These components can be added and deleted.')
mscFrDteRgBfrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgBfrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteRgBfrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgBfrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrStorageType.setDescription('This variable represents the storage type value for the mscFrDteRgBfr tables.')
mscFrDteRgBfrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrDteRgBfrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrIndex.setDescription('This variable represents the index for the mscFrDteRgBfr tables.')
mscFrDteRgBfrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 10), )
if mibBuilder.loadTexts: mscFrDteRgBfrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrProvTable.setDescription('This group contains the provisioning attributes for the Bfr component.')
mscFrDteRgBfrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgBfrIndex"))
if mibBuilder.loadTexts: mscFrDteRgBfrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrProvEntry.setDescription('An entry in the mscFrDteRgBfrProvTable.')
mscFrDteRgBfrMacType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fddi", 0), ("enet", 1), ("tokenRing", 2))).clone('enet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRgBfrMacType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrMacType.setDescription('This attribute specifies the MAC address type of the Bfr component. The value must be chosen based on the media of the traffic source. For traffic originated from FDDI, use fddi; for ethernet, use enet; for token ring, use tokenRing')
mscFrDteRgBfrBfrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 511))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteRgBfrBfrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrBfrIndex.setDescription('This attribute specifies the value which is used to derive a unique MAC address for the Bfr. The bfrIndex must be unique across all Bfrs on the same Lp.')
mscFrDteRgBfrOprTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 11), )
if mibBuilder.loadTexts: mscFrDteRgBfrOprTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrOprTable.setDescription('This group contains the operational attributes for the Bfr component..')
mscFrDteRgBfrOprEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteRgBfrIndex"))
if mibBuilder.loadTexts: mscFrDteRgBfrOprEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrOprEntry.setDescription('An entry in the mscFrDteRgBfrOprTable.')
mscFrDteRgBfrMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 4, 15, 11, 1, 1), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteRgBfrMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteRgBfrMacAddr.setDescription('This attribute indicates the unique MAC address of the Bfr component. This value is derived by the value of the attribute bfrIndex. The value is displayed as cannonical format.')
mscFrDteDynDlciDefs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5))
mscFrDteDynDlciDefsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 1), )
if mibBuilder.loadTexts: mscFrDteDynDlciDefsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteDynDlciDefs components.')
mscFrDteDynDlciDefsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteDynDlciDefsIndex"))
if mibBuilder.loadTexts: mscFrDteDynDlciDefsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteDynDlciDefs component.')
mscFrDteDynDlciDefsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteDynDlciDefs components. These components cannot be added nor deleted.')
mscFrDteDynDlciDefsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteDynDlciDefsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsStorageType.setDescription('This variable represents the storage type value for the mscFrDteDynDlciDefs tables.')
mscFrDteDynDlciDefsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrDteDynDlciDefsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsIndex.setDescription('This variable represents the index for the mscFrDteDynDlciDefs tables.')
mscFrDteDynDlciDefsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10), )
if mibBuilder.loadTexts: mscFrDteDynDlciDefsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsProvTable.setDescription('This group contains the provisioned attributes for a virtual circuit. These attributes represent the default settings for the resulting Dlci components and can be operationally changed using the corresponding attributes under the Dlci component.')
mscFrDteDynDlciDefsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteDynDlciDefsIndex"))
if mibBuilder.loadTexts: mscFrDteDynDlciDefsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsProvEntry.setDescription('An entry in the mscFrDteDynDlciDefsProvTable.')
mscFrDteDynDlciDefsStdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsStdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsStdRowStatus.setDescription('This attribute is used to manage the status of a StDlci component. Set to active to enable the StDlci component. Set to notInService to disable the StDlci component. Set to createAndGo (SNMP only) to create a new StDlci component. Set to destroy (SNMP only) to delete an existing StDlci component.')
mscFrDteDynDlciDefsRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsRateEnforcement.setDescription('This attribute specifies whether the CIR attributes committedInformationRate, committedBurst, and excessBurst are used to define rate enforcement on this user DLCI. If rateEnforcement is enabled, and the combined Committed and Excess burst thresholds are exceeded, the frame in violation will be discarded immediately if a HibernationQueue subcomponent is not provisioned under the StDlci component. If a HibernationQueue is provisioned, the frame will be placed on the HibernationQueue at time of violation and transmission will be attempted later after the point at which the burst thresholds will no longer be exceeded. Setting all the CIR attributes to zero has the same affect as setting this attribute to disabled.')
mscFrDteDynDlciDefsCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 48000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsCommittedInformationRate.setDescription('The average number of bits to be transferred per second over the DLCI to the DCE. When this attribute is set to zero, the link speed will be used instead.')
mscFrDteDynDlciDefsCommittedBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsCommittedBurst.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsCommittedBurst.setDescription('The committed burst size (in bits) to which the DLCI wants to subscribe.')
mscFrDteDynDlciDefsExcessBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsExcessBurst.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsExcessBurst.setDescription('The excess burst size (in bits) to which the DLCI wants to subscribe.')
mscFrDteDynDlciDefsExcessBurstAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("setDeBit", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsExcessBurstAction.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsExcessBurstAction.setDescription('This attribute specifies the action taken when the committedBurst size has been exceeded on the DLCI but the excessBurst size has not. If the attribute is set to setDeBit, the Discard Eligibility bit in the Frame Relay header will be turned on. If the attribute is set to none, no action will be taken.')
mscFrDteDynDlciDefsIpCos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDynDlciDefsIpCos.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDynDlciDefsIpCos.setDescription("This attribute specifies the initial Class of Service (CoS) given to each packet received on the virtual circuit identified by the DLCI. The CoS value n is used to select Vr/<string> QosP/n. which determines the QualityofService-Profile to be used when the packet is forwarded. The initial CoS given to a packet by the assignedQoS attribute may be overridden when the cosPolicyAssignment attribute is defined on the IpPort or Ip components. When a packet is to be transmitted on a frDte protocol port where multiple virtual circuits are available for the packet's next hop, the packet is forwarded using the dlci where the ipCos value matches the CoS of the packet. When the packets's CoS does not match the ipCos value of any of the available virtual circuits, the packet will be forwarded using next lowest CoS; failing this, the packet will be forwarded using the next highest CoS.")
mscFrDteStDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6))
mscFrDteStDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 1), )
if mibBuilder.loadTexts: mscFrDteStDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteStDlci components.')
mscFrDteStDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteStDlci component.')
mscFrDteStDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteStDlci components. These components can be added and deleted.')
mscFrDteStDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteStDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciStorageType.setDescription('This variable represents the storage type value for the mscFrDteStDlci tables.')
mscFrDteStDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1007)))
if mibBuilder.loadTexts: mscFrDteStDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciIndex.setDescription('This variable represents the index for the mscFrDteStDlci tables.')
mscFrDteStDlciProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10), )
if mibBuilder.loadTexts: mscFrDteStDlciProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciProvTable.setDescription('This group contains the provisioned attributes for a virtual circuit. These attributes represent the default settings for the resulting Dlci components and can be operationally changed using the corresponding attributes under the Dlci component.')
mscFrDteStDlciProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciProvEntry.setDescription('An entry in the mscFrDteStDlciProvTable.')
mscFrDteStDlciStdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciStdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciStdRowStatus.setDescription('This attribute is used to manage the status of a StDlci component. Set to active to enable the StDlci component. Set to notInService to disable the StDlci component. Set to createAndGo (SNMP only) to create a new StDlci component. Set to destroy (SNMP only) to delete an existing StDlci component.')
mscFrDteStDlciRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciRateEnforcement.setDescription('This attribute specifies whether the CIR attributes committedInformationRate, committedBurst, and excessBurst are used to define rate enforcement on this user DLCI. If rateEnforcement is enabled, and the combined Committed and Excess burst thresholds are exceeded, the frame in violation will be discarded immediately if a HibernationQueue subcomponent is not provisioned under the StDlci component. If a HibernationQueue is provisioned, the frame will be placed on the HibernationQueue at time of violation and transmission will be attempted later after the point at which the burst thresholds will no longer be exceeded. Setting all the CIR attributes to zero has the same affect as setting this attribute to disabled.')
mscFrDteStDlciCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 48000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciCommittedInformationRate.setDescription('The average number of bits to be transferred per second over the DLCI to the DCE. When this attribute is set to zero, the link speed will be used instead.')
mscFrDteStDlciCommittedBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciCommittedBurst.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciCommittedBurst.setDescription('The committed burst size (in bits) to which the DLCI wants to subscribe.')
mscFrDteStDlciExcessBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciExcessBurst.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciExcessBurst.setDescription('The excess burst size (in bits) to which the DLCI wants to subscribe.')
mscFrDteStDlciExcessBurstAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("setDeBit", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciExcessBurstAction.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciExcessBurstAction.setDescription('This attribute specifies the action taken when the committedBurst size has been exceeded on the DLCI but the excessBurst size has not. If the attribute is set to setDeBit, the Discard Eligibility bit in the Frame Relay header will be turned on. If the attribute is set to none, no action will be taken.')
mscFrDteStDlciIpCos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciIpCos.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciIpCos.setDescription("This attribute specifies the initial Class of Service (CoS) given to each packet received on the virtual circuit identified by the DLCI. The CoS value n is used to select Vr/<string> QosP/n. which determines the QualityofService-Profile to be used when the packet is forwarded. The initial CoS given to a packet by the assignedQoS attribute may be overridden when the cosPolicyAssignment attribute is defined on the IpPort or Ip components. When a packet is to be transmitted on a frDte protocol port where multiple virtual circuits are available for the packet's next hop, the packet is forwarded using the dlci where the ipCos value matches the CoS of the packet. When the packets's CoS does not match the ipCos value of any of the available virtual circuits, the packet will be forwarded using next lowest CoS; failing this, the packet will be forwarded using the next highest CoS.")
mscFrDteStDlciRgLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 11), )
if mibBuilder.loadTexts: mscFrDteStDlciRgLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciRgLinkTable.setDescription('This group provides the link between a Dlci and a remoteGroup.')
mscFrDteStDlciRgLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciRgLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciRgLinkEntry.setDescription('An entry in the mscFrDteStDlciRgLinkTable.')
mscFrDteStDlciLinkToRemoteGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 11, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciLinkToRemoteGroup.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciLinkToRemoteGroup.setDescription('This attribute associates a StDlci component with a Rg component. Provisioned StDlci components must be linked to a Rg component which is under the same FrDte component.')
mscFrDteStDlciHq = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2))
mscFrDteStDlciHqRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 1), )
if mibBuilder.loadTexts: mscFrDteStDlciHqRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteStDlciHq components.')
mscFrDteStDlciHqRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciHqIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciHqRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteStDlciHq component.')
mscFrDteStDlciHqRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciHqRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteStDlciHq components. These components can be added and deleted.')
mscFrDteStDlciHqComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteStDlciHqStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqStorageType.setDescription('This variable represents the storage type value for the mscFrDteStDlciHq tables.')
mscFrDteStDlciHqIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrDteStDlciHqIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqIndex.setDescription('This variable represents the index for the mscFrDteStDlciHq tables.')
mscFrDteStDlciHqProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 10), )
if mibBuilder.loadTexts: mscFrDteStDlciHqProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqProvTable.setDescription('This group contains the Link Emission Queue provisioned attributes.')
mscFrDteStDlciHqProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciHqIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciHqProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqProvEntry.setDescription('An entry in the mscFrDteStDlciHqProvTable.')
mscFrDteStDlciHqMaxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciHqMaxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqMaxPackets.setDescription('This attribute specifies the maximum number of packets allowed in the Leq before being discarded. If this attribute is set to zero then the maximum number of packets is calculated from the transmit data rate. This calculated value is placed in queuePktThreshold.')
mscFrDteStDlciHqMaxMsecData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 60000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciHqMaxMsecData.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqMaxMsecData.setDescription("This attribute specifies the maximum number of 'Milliseconds worth of data' allowed in the Leq before packets are discarded. The queueByteThreshold will be calculated from this attribute, based on the transmit data rate.")
mscFrDteStDlciHqMaxPercentMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciHqMaxPercentMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqMaxPercentMulticast.setDescription('This attribute specifies the maximum percentage of multicast packets allowed in the Leq, based on queuePktThreshold, before being discarded. The calculated value will be placed in queueMulticastThreshold.')
mscFrDteStDlciHqTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 60000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteStDlciHqTimeToLive.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTimeToLive.setDescription("This attribute specifies the 'Milliseconds Time To Live' of packets in the Leq. If the timeToLive of a packet expires, it will be discarded.")
mscFrDteStDlciHqStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 11), )
if mibBuilder.loadTexts: mscFrDteStDlciHqStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqStatsTable.setDescription('This group contains HibernationQueue general statistics.')
mscFrDteStDlciHqStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciHqIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciHqStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqStatsEntry.setDescription('An entry in the mscFrDteStDlciHqStatsTable.')
mscFrDteStDlciHqTimedOutPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqTimedOutPkt.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTimedOutPkt.setDescription('This attribute counts the number of packets that have been discarded due to exceeding the timeToLive. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqQueuePurgeDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqQueuePurgeDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqQueuePurgeDiscards.setDescription('This attribute counts the total number of packets discarded by a queue purge which occurs when the Dlci goes down. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqTStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 12), )
if mibBuilder.loadTexts: mscFrDteStDlciHqTStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTStatsTable.setDescription('This group contains Link Emission Queue total statistics.')
mscFrDteStDlciHqTStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciHqIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciHqTStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTStatsEntry.setDescription('An entry in the mscFrDteStDlciHqTStatsTable.')
mscFrDteStDlciHqTotalPktHandled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalPktHandled.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalPktHandled.setDescription('This attribute counts the total number of packets handled by the Leq. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqTotalPktForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalPktForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalPktForwarded.setDescription('This attribute counts the total number of packets forwarded by the Leq. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqTotalPktQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalPktQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalPktQueued.setDescription('This attribute counts the total number of packets that required queuing by the Leq due to transmit congestion. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqTotalMulticastPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalMulticastPkt.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalMulticastPkt.setDescription('This attribute counts the total number of multicast packets handled by this instance of FrDte. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqTotalPktDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalPktDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqTotalPktDiscards.setDescription('This attribute counts the total number of packets that were discarded for this instance of FrDte. This is the sum of timedOutPkt, forcedPktDiscards, queuePurgeDiscards, pktThresholdExceeded, byteThresholdExceeded, mulThresholdExceeded and memThresholdExceeded. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqCStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 13), )
if mibBuilder.loadTexts: mscFrDteStDlciHqCStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqCStatsTable.setDescription('This group contains Link Emission Queue current statistics.')
mscFrDteStDlciHqCStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciHqIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciHqCStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqCStatsEntry.setDescription('An entry in the mscFrDteStDlciHqCStatsTable.')
mscFrDteStDlciHqCurrentPktQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 13, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqCurrentPktQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqCurrentPktQueued.setDescription('This attribute contains the current number of packets queued.')
mscFrDteStDlciHqCurrentBytesQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 13, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqCurrentBytesQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqCurrentBytesQueued.setDescription('This attribute contains the current number of bytes queued.')
mscFrDteStDlciHqCurrentMulticastQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 13, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqCurrentMulticastQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqCurrentMulticastQueued.setDescription('This attribute counts the current number of multicast packets in the queue.')
mscFrDteStDlciHqThrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14), )
if mibBuilder.loadTexts: mscFrDteStDlciHqThrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqThrStatsTable.setDescription('This group contains Link Emission Queue threshold statistics.')
mscFrDteStDlciHqThrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteStDlciHqIndex"))
if mibBuilder.loadTexts: mscFrDteStDlciHqThrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqThrStatsEntry.setDescription('An entry in the mscFrDteStDlciHqThrStatsTable.')
mscFrDteStDlciHqQueuePktThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqQueuePktThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqQueuePktThreshold.setDescription('This attribute is the maximum number of packets that can be contained in the queue before being discarded. If maxPackets was set to 0 then this attribute will contain the value that has been calculated based on the transmit data rate. If maxPackets was set to one or more than this attribute will contain that number.')
mscFrDteStDlciHqPktThresholdExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqPktThresholdExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqPktThresholdExceeded.setDescription('This attribute counts the number of packets discarded due to the queuePktThreshold being exceeded. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqQueueByteThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqQueueByteThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqQueueByteThreshold.setDescription('This attribute is the maximum number of bytes allowed in the queue based on maxMsecData and the transmit data rate.')
mscFrDteStDlciHqByteThresholdExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqByteThresholdExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqByteThresholdExceeded.setDescription('This attribute counts the number of packets discarded due to the queueByteThreshold being exceeded. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqQueueMulticastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqQueueMulticastThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqQueueMulticastThreshold.setDescription('This attribute is the number of multicast packets allowed in the queue based on maxPercentMulticast and maxPackets.')
mscFrDteStDlciHqMulThresholdExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqMulThresholdExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqMulThresholdExceeded.setDescription('This attribute counts the number of packets discarded due to the queueMulticastThreshold being exceeded. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteStDlciHqMemThresholdExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 6, 2, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteStDlciHqMemThresholdExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteStDlciHqMemThresholdExceeded.setDescription('This attribute counts the number of packets discarded due to exceeding the memory usage threshold for Leq. The memory usage threshold is determined by the Leq software, guaranteeing that the Leq does not consume all of the memory. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeq = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7))
mscFrDteLeqRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 1), )
if mibBuilder.loadTexts: mscFrDteLeqRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteLeq components.')
mscFrDteLeqRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLeqIndex"))
if mibBuilder.loadTexts: mscFrDteLeqRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteLeq component.')
mscFrDteLeqRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLeqRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteLeq components. These components can be added and deleted.')
mscFrDteLeqComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteLeqStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqStorageType.setDescription('This variable represents the storage type value for the mscFrDteLeq tables.')
mscFrDteLeqIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrDteLeqIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqIndex.setDescription('This variable represents the index for the mscFrDteLeq tables.')
mscFrDteLeqProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 10), )
if mibBuilder.loadTexts: mscFrDteLeqProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqProvTable.setDescription('This group contains the Link Emission Queue provisioned attributes.')
mscFrDteLeqProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLeqIndex"))
if mibBuilder.loadTexts: mscFrDteLeqProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqProvEntry.setDescription('An entry in the mscFrDteLeqProvTable.')
mscFrDteLeqMaxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLeqMaxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqMaxPackets.setDescription('This attribute specifies the maximum number of packets allowed in the Leq before being discarded. If this attribute is set to zero then the maximum number of packets is calculated from the transmit data rate. This calculated value is placed in queuePktThreshold.')
mscFrDteLeqMaxMsecData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 60000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLeqMaxMsecData.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqMaxMsecData.setDescription("This attribute specifies the maximum number of 'Milliseconds worth of data' allowed in the Leq before packets are discarded. The queueByteThreshold will be calculated from this attribute, based on the transmit data rate.")
mscFrDteLeqMaxPercentMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLeqMaxPercentMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqMaxPercentMulticast.setDescription('This attribute specifies the maximum percentage of multicast packets allowed in the Leq, based on queuePktThreshold, before being discarded. The calculated value will be placed in queueMulticastThreshold.')
mscFrDteLeqTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 60000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteLeqTimeToLive.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTimeToLive.setDescription("This attribute specifies the 'Milliseconds Time To Live' of packets in the Leq. If the timeToLive of a packet expires, it will be discarded.")
mscFrDteLeqStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 11), )
if mibBuilder.loadTexts: mscFrDteLeqStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqStatsTable.setDescription('This group contains Link Emission Queue general statistics.')
mscFrDteLeqStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLeqIndex"))
if mibBuilder.loadTexts: mscFrDteLeqStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqStatsEntry.setDescription('An entry in the mscFrDteLeqStatsTable.')
mscFrDteLeqTimedOutPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqTimedOutPkt.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTimedOutPkt.setDescription('This attribute counts the number of packets that have been discarded due to exceeding the timeToLive. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqHardwareForcedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqHardwareForcedPkt.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqHardwareForcedPkt.setDescription('This attribute counts the number of hardware forced packets on this instance of FrDte. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqForcedPktDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqForcedPktDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqForcedPktDiscards.setDescription('This attribute counts the total number of hardware forced packets that had to be discarded due to link failure. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqQueuePurgeDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqQueuePurgeDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqQueuePurgeDiscards.setDescription('This attribute counts the total number of packets discarded by a queue purge (i.e. a discarding of all packets on the queue). This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqTStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 12), )
if mibBuilder.loadTexts: mscFrDteLeqTStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTStatsTable.setDescription('This group contains Link Emission Queue total statistics.')
mscFrDteLeqTStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLeqIndex"))
if mibBuilder.loadTexts: mscFrDteLeqTStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTStatsEntry.setDescription('An entry in the mscFrDteLeqTStatsTable.')
mscFrDteLeqTotalPktHandled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqTotalPktHandled.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTotalPktHandled.setDescription('This attribute counts the total number of packets handled by the Leq. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqTotalPktForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqTotalPktForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTotalPktForwarded.setDescription('This attribute counts the total number of packets forwarded by the Leq. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqTotalPktQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqTotalPktQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTotalPktQueued.setDescription('This attribute counts the total number of packets that required queuing by the Leq due to transmit congestion. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqTotalMulticastPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqTotalMulticastPkt.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTotalMulticastPkt.setDescription('This attribute counts the total number of multicast packets handled by this instance of FrDte. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqTotalPktDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqTotalPktDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqTotalPktDiscards.setDescription('This attribute counts the total number of packets that were discarded for this instance of FrDte. This is the sum of timedOutPkt, forcedPktDiscards, queuePurgeDiscards, pktThresholdExceeded, byteThresholdExceeded, mulThresholdExceeded and memThresholdExceeded. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqCStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 13), )
if mibBuilder.loadTexts: mscFrDteLeqCStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqCStatsTable.setDescription('This group contains Link Emission Queue current statistics.')
mscFrDteLeqCStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLeqIndex"))
if mibBuilder.loadTexts: mscFrDteLeqCStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqCStatsEntry.setDescription('An entry in the mscFrDteLeqCStatsTable.')
mscFrDteLeqCurrentPktQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 13, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqCurrentPktQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqCurrentPktQueued.setDescription('This attribute contains the current number of packets queued.')
mscFrDteLeqCurrentBytesQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 13, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqCurrentBytesQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqCurrentBytesQueued.setDescription('This attribute contains the current number of bytes queued.')
mscFrDteLeqCurrentMulticastQueued = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 13, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqCurrentMulticastQueued.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqCurrentMulticastQueued.setDescription('This attribute counts the current number of multicast packets in the queue.')
mscFrDteLeqThrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14), )
if mibBuilder.loadTexts: mscFrDteLeqThrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqThrStatsTable.setDescription('This group contains Link Emission Queue threshold statistics.')
mscFrDteLeqThrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteLeqIndex"))
if mibBuilder.loadTexts: mscFrDteLeqThrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqThrStatsEntry.setDescription('An entry in the mscFrDteLeqThrStatsTable.')
mscFrDteLeqQueuePktThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqQueuePktThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqQueuePktThreshold.setDescription('This attribute is the maximum number of packets that can be contained in the queue before being discarded. If maxPackets was set to 0 then this attribute will contain the value that has been calculated based on the transmit data rate. If maxPackets was set to one or more than this attribute will contain that number.')
mscFrDteLeqPktThresholdExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqPktThresholdExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqPktThresholdExceeded.setDescription('This attribute counts the number of packets discarded due to the queuePktThreshold being exceeded. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqQueueByteThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqQueueByteThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqQueueByteThreshold.setDescription('This attribute is the maximum number of bytes allowed in the queue based on maxMsecData and the transmit data rate.')
mscFrDteLeqByteThresholdExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqByteThresholdExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqByteThresholdExceeded.setDescription('This attribute counts the number of packets discarded due to the queueByteThreshold being exceeded. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqQueueMulticastThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqQueueMulticastThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqQueueMulticastThreshold.setDescription('This attribute is the number of multicast packets allowed in the queue based on maxPercentMulticast and maxPackets.')
mscFrDteLeqMulThresholdExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqMulThresholdExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqMulThresholdExceeded.setDescription('This attribute counts the number of packets discarded due to the queueMulticastThreshold being exceeded. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteLeqMemThresholdExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 7, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteLeqMemThresholdExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteLeqMemThresholdExceeded.setDescription('This attribute counts the number of packets discarded due to exceeding the memory usage threshold for Leq. The memory usage threshold is determined by the Leq software, guaranteeing that the Leq does not consume all of the memory. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8))
mscFrDteDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 1), )
if mibBuilder.loadTexts: mscFrDteDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscFrDteDlci components.')
mscFrDteDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteDlciIndex"))
if mibBuilder.loadTexts: mscFrDteDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteDlci component.')
mscFrDteDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteDlci components. These components cannot be added nor deleted.')
mscFrDteDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciStorageType.setDescription('This variable represents the storage type value for the mscFrDteDlci tables.')
mscFrDteDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)))
if mibBuilder.loadTexts: mscFrDteDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciIndex.setDescription('This variable represents the index for the mscFrDteDlci tables.')
mscFrDteDlciStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 10), )
if mibBuilder.loadTexts: mscFrDteDlciStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciStateTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrDteDlciStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteDlciIndex"))
if mibBuilder.loadTexts: mscFrDteDlciStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciStateEntry.setDescription('An entry in the mscFrDteDlciStateTable.')
mscFrDteDlciAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrDteDlciOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrDteDlciUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrDteDlciOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11), )
if mibBuilder.loadTexts: mscFrDteDlciOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes for the Dlci component.')
mscFrDteDlciOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteDlciIndex"))
if mibBuilder.loadTexts: mscFrDteDlciOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciOperEntry.setDescription('An entry in the mscFrDteDlciOperTable.')
mscFrDteDlciDlciState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("active", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciDlciState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciDlciState.setDescription('This attribute reflects the current operational circuit state of the Dlci. The state active indicates that the circuit is up and inactive that the circuit is down. The state invalid means the circuit has been deleted by the DCE (via Lmi).')
mscFrDteDlciLastTimeChange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciLastTimeChange.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciLastTimeChange.setDescription('The last time dlciState changed state.')
mscFrDteDlciSentFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciSentFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciSentFrames.setDescription('Number of frames transmitted across the interface. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlciSentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciSentOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciSentOctets.setDescription('The number of octets sent from this virtual circuit since it was created. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlciReceivedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciReceivedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciReceivedFrames.setDescription('Number of frames received across the interface. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlciReceivedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciReceivedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciReceivedOctets.setDescription('The number of octets sent from this virtual circuit since it was created. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlciReceivedFECNs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciReceivedFECNs.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciReceivedFECNs.setDescription('Number of frames with the FECN bit set received from the network. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlciReceivedBECNs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciReceivedBECNs.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciReceivedBECNs.setDescription('Number of frames with the BECN bit set received from the network. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlciDiscardedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciDiscardedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciDiscardedFrames.setDescription('The number of inbound frames dropped because of format errors, or because the VC was inactive. This counter will wrap around to 0 when it exceeds its maximum count.')
mscFrDteDlciCreationType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciCreationType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciCreationType.setDescription('This indicates whether the virtual circuit was manually created (static), or dynamically created (dynamic) via the data link control management interface.')
mscFrDteDlciCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 15), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteDlciCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciCreationTime.setDescription('The time when the circuit was created, whether by the Data Link Connection Management Interface or by an SNMP set request.')
mscFrDteDlciRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDlciRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciRateEnforcement.setDescription('This attribute specifies whether the CIR attributes committedInformationRate, committedBurst, and excessBurst are used to define rate enforcement on this user DLCI. If rateEnforcement is enabled, and the combined Committed and Excess burst thresholds are exceeded, the frame in violation will be discarded immediately if a HibernationQueue subcomponent is not provisioned under the StDlci component (static entries only). If a HibernationQueue is provisioned, the frame will be placed on the HibernationQueue at time of violation and transmission will be attempted later after the point at which the burst thresholds will no longer be exceeded. Setting all the CIR attributes to zero has the same affect as setting this attribute to disabled. Setting this attribute will operationally override the corresponding provisional value on static entries.')
mscFrDteDlciCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 18), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 48000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDlciCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciCommittedInformationRate.setDescription('The average number of bits to be transferred per second over the DLCI to the DCE. When this attribute is set to zero, the link speed will be used instead. Setting this attribute will operationally override the corresponding provisional value on static entries.')
mscFrDteDlciCommittedBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDlciCommittedBurst.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciCommittedBurst.setDescription('The committed burst size (in bits) to which the DLCI wants to subscribe. Setting this attribute will operationally override the corresponding provisional value on static entries.')
mscFrDteDlciExcessBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDlciExcessBurst.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciExcessBurst.setDescription('The excess burst size (in bits) to which the DLCI wants to subscribe. Setting this attribute will operationally override the corresponding provisional value on static entries.')
mscFrDteDlciExcessBurstAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 8, 11, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("setDeBit", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteDlciExcessBurstAction.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteDlciExcessBurstAction.setDescription('This attribute specifies the action taken when the committedBurst size has been exceeded on the Dlci but the excessBurst size has not. If the attribute is set to setDeBit, the Discard Eligibility bit in the Frame Relay header will be turned on. If the attribute is set to none, no action will be taken. Setting this attribute will operationally override the corresponding provisional value on static entries.')
mscFrDteVFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9))
mscFrDteVFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 1), )
if mibBuilder.loadTexts: mscFrDteVFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrDteVFramer components.')
mscFrDteVFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteVFramerIndex"))
if mibBuilder.loadTexts: mscFrDteVFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscFrDteVFramer component.')
mscFrDteVFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteVFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrDteVFramer components. These components can be added and deleted.')
mscFrDteVFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteVFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrDteVFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteVFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerStorageType.setDescription('This variable represents the storage type value for the mscFrDteVFramer tables.')
mscFrDteVFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrDteVFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerIndex.setDescription('This variable represents the index for the mscFrDteVFramer tables.')
mscFrDteVFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 10), )
if mibBuilder.loadTexts: mscFrDteVFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerProvTable.setDescription('This group contains provisionable attributes for the VirtualFramer component.')
mscFrDteVFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteVFramerIndex"))
if mibBuilder.loadTexts: mscFrDteVFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerProvEntry.setDescription('An entry in the mscFrDteVFramerProvTable.')
mscFrDteVFramerOtherVirtualFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteVFramerOtherVirtualFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerOtherVirtualFramer.setDescription('This attribute specifies the other VirtualFramer to which the service is linked, for example, FrUni/n VirtualFramer, FrDte/n VirtualFramer.')
mscFrDteVFramerLogicalProcessor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 10, 1, 2), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrDteVFramerLogicalProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerLogicalProcessor.setDescription('This attribute specifies the logical processor on which the service component will reside.')
mscFrDteVFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 11), )
if mibBuilder.loadTexts: mscFrDteVFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrDteVFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteVFramerIndex"))
if mibBuilder.loadTexts: mscFrDteVFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerStateEntry.setDescription('An entry in the mscFrDteVFramerStateTable.')
mscFrDteVFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteVFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrDteVFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteVFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrDteVFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteVFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrDteVFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 12), )
if mibBuilder.loadTexts: mscFrDteVFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerStatsTable.setDescription('This group contains the operational statistics data for a VirtualFramer component.')
mscFrDteVFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", "mscFrDteVFramerIndex"))
if mibBuilder.loadTexts: mscFrDteVFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerStatsEntry.setDescription('An entry in the mscFrDteVFramerStatsTable.')
mscFrDteVFramerFrmToOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 12, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteVFramerFrmToOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerFrmToOtherVFramer.setDescription('This attribute counts the frames transmitted to the otherVirtualFramer.')
mscFrDteVFramerFrmFromOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 12, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteVFramerFrmFromOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerFrmFromOtherVFramer.setDescription('This attribute counts the frames received from the otherVirtualFramer.')
mscFrDteVFramerOctetFromOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 101, 9, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrDteVFramerOctetFromOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrDteVFramerOctetFromOtherVFramer.setDescription('This attribute counts the octets received from the otherVirtualFramer.')
frameRelayDteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32, 1))
frameRelayDteGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32, 1, 1))
frameRelayDteGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32, 1, 1, 3))
frameRelayDteGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32, 1, 1, 3, 2))
frameRelayDteCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32, 3))
frameRelayDteCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32, 3, 1))
frameRelayDteCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32, 3, 1, 3))
frameRelayDteCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 32, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", mscFrDteBadFc=mscFrDteBadFc, mscFrDteLmiProvTable=mscFrDteLmiProvTable, mscFrDteDlciReceivedOctets=mscFrDteDlciReceivedOctets, mscFrDteRgSnmpOperStatus=mscFrDteRgSnmpOperStatus, mscFrDteLmiComponentName=mscFrDteLmiComponentName, mscFrDteFramerInterfaceName=mscFrDteFramerInterfaceName, mscFrDteDlciOperEntry=mscFrDteDlciOperEntry, mscFrDteLeqCurrentBytesQueued=mscFrDteLeqCurrentBytesQueued, mscFrDteDlciStateEntry=mscFrDteDlciStateEntry, mscFrDteLeq=mscFrDteLeq, mscFrDteFramerFrmFromIf=mscFrDteFramerFrmFromIf, mscFrDteDlciRowStatusEntry=mscFrDteDlciRowStatusEntry, mscFrDteStDlciHqByteThresholdExceeded=mscFrDteStDlciHqByteThresholdExceeded, mscFrDteStDlciHqMaxPercentMulticast=mscFrDteStDlciHqMaxPercentMulticast, mscFrDteStDlciHqCStatsEntry=mscFrDteStDlciHqCStatsEntry, mscFrDteVFramerOctetFromOtherVFramer=mscFrDteVFramerOctetFromOtherVFramer, mscFrDteRgBfrBfrIndex=mscFrDteRgBfrBfrIndex, mscFrDteRgRowStatus=mscFrDteRgRowStatus, mscFrDteRgIfIndex=mscFrDteRgIfIndex, mscFrDteFramerUtilTable=mscFrDteFramerUtilTable, mscFrDteStDlciHqProvEntry=mscFrDteStDlciHqProvEntry, mscFrDteIndex=mscFrDteIndex, mscFrDteDlcmiUnknownRpt=mscFrDteDlcmiUnknownRpt, mscFrDteStDlciHqThrStatsEntry=mscFrDteStDlciHqThrStatsEntry, mscFrDteVFramerFrmToOtherVFramer=mscFrDteVFramerFrmToOtherVFramer, mscFrDteLeqRowStatus=mscFrDteLeqRowStatus, mscFrDteStDlciHqMaxMsecData=mscFrDteStDlciHqMaxMsecData, mscFrDteLmiStorageType=mscFrDteLmiStorageType, mscFrDteLeqForcedPktDiscards=mscFrDteLeqForcedPktDiscards, mscFrDteStDlciHqPktThresholdExceeded=mscFrDteStDlciHqPktThresholdExceeded, mscFrDteOperationalState=mscFrDteOperationalState, mscFrDteRgLtDlciTable=mscFrDteRgLtDlciTable, mscFrDteVFramerOtherVirtualFramer=mscFrDteVFramerOtherVirtualFramer, mscFrDteAdminState=mscFrDteAdminState, mscFrDteXmitDiscardFramerDown=mscFrDteXmitDiscardFramerDown, mscFrDteRgBfrMacType=mscFrDteRgBfrMacType, mscFrDteLeqTotalPktHandled=mscFrDteLeqTotalPktHandled, mscFrDteDlciSentFrames=mscFrDteDlciSentFrames, mscFrDteDlciCreationTime=mscFrDteDlciCreationTime, mscFrDteStDlciHqStorageType=mscFrDteStDlciHqStorageType, mscFrDteVFramerUsageState=mscFrDteVFramerUsageState, mscFrDteRg=mscFrDteRg, mscFrDteFramerNonOctetErrors=mscFrDteFramerNonOctetErrors, mscFrDteRgBfrComponentName=mscFrDteRgBfrComponentName, mscFrDteRgRowStatusTable=mscFrDteRgRowStatusTable, mscFrDteRgBfr=mscFrDteRgBfr, mscFrDteCidDataTable=mscFrDteCidDataTable, mscFrDteRgProvTable=mscFrDteRgProvTable, mscFrDteFramerOperationalState=mscFrDteFramerOperationalState, mscFrDteErrStatsTable=mscFrDteErrStatsTable, mscFrDteRgLtDlciEntry=mscFrDteRgLtDlciEntry, mscFrDteLmiLmiStatus=mscFrDteLmiLmiStatus, mscFrDteDlciAdminState=mscFrDteDlciAdminState, mscFrDteLeqTotalMulticastPkt=mscFrDteLeqTotalMulticastPkt, mscFrDteVFramerLogicalProcessor=mscFrDteVFramerLogicalProcessor, mscFrDteErrType=mscFrDteErrType, frameRelayDteGroupCA02A=frameRelayDteGroupCA02A, mscFrDteSnmpOperStatus=mscFrDteSnmpOperStatus, mscFrDteVFramerFrmFromOtherVFramer=mscFrDteVFramerFrmFromOtherVFramer, mscFrDteLeqCurrentMulticastQueued=mscFrDteLeqCurrentMulticastQueued, mscFrDteErrTable=mscFrDteErrTable, mscFrDteLeqStorageType=mscFrDteLeqStorageType, mscFrDteDlciIndex=mscFrDteDlciIndex, frameRelayDteGroup=frameRelayDteGroup, mscFrDteFramerProvTable=mscFrDteFramerProvTable, mscFrDteLeqThrStatsTable=mscFrDteLeqThrStatsTable, mscFrDteFramerUtilEntry=mscFrDteFramerUtilEntry, mscFrDteVFramerStatsEntry=mscFrDteVFramerStatsEntry, mscFrDteOperTable=mscFrDteOperTable, frameRelayDteCapabilities=frameRelayDteCapabilities, mscFrDteErrEntry=mscFrDteErrEntry, mscFrDteDlciComponentName=mscFrDteDlciComponentName, mscFrDteProvTable=mscFrDteProvTable, mscFrDteFramerOverruns=mscFrDteFramerOverruns, mscFrDteVFramerStatsTable=mscFrDteVFramerStatsTable, mscFrDteDlciOperationalState=mscFrDteDlciOperationalState, mscFrDteErrDiscards=mscFrDteErrDiscards, mscFrDteRgLtDlciValue=mscFrDteRgLtDlciValue, mscFrDteRgUsageState=mscFrDteRgUsageState, mscFrDteRgMpTable=mscFrDteRgMpTable, mscFrDteStDlciHqQueueMulticastThreshold=mscFrDteStDlciHqQueueMulticastThreshold, mscFrDteLeqHardwareForcedPkt=mscFrDteLeqHardwareForcedPkt, mscFrDteLeqTStatsTable=mscFrDteLeqTStatsTable, mscFrDteErrStatsEntry=mscFrDteErrStatsEntry, mscFrDteLmiProvEntry=mscFrDteLmiProvEntry, mscFrDteStDlciHqQueuePktThreshold=mscFrDteStDlciHqQueuePktThreshold, mscFrDteLmiOperTable=mscFrDteLmiOperTable, mscFrDteLmiPollingInterval=mscFrDteLmiPollingInterval, mscFrDteStDlciRateEnforcement=mscFrDteStDlciRateEnforcement, mscFrDteVFramerRowStatus=mscFrDteVFramerRowStatus, mscFrDteVFramerRowStatusTable=mscFrDteVFramerRowStatusTable, mscFrDteLeqTotalPktDiscards=mscFrDteLeqTotalPktDiscards, mscFrDteDlcmiSequenceErr=mscFrDteDlcmiSequenceErr, mscFrDteErrFaults=mscFrDteErrFaults, mscFrDteStDlciHqMaxPackets=mscFrDteStDlciHqMaxPackets, mscFrDteFramerComponentName=mscFrDteFramerComponentName, mscFrDteFramerUnderruns=mscFrDteFramerUnderruns, mscFrDteStDlciRgLinkTable=mscFrDteStDlciRgLinkTable, frameRelayDteCapabilitiesCA02A=frameRelayDteCapabilitiesCA02A, mscFrDteFramerProvEntry=mscFrDteFramerProvEntry, mscFrDteLeqRowStatusTable=mscFrDteLeqRowStatusTable, mscFrDteStDlciExcessBurst=mscFrDteStDlciExcessBurst, mscFrDteLeqByteThresholdExceeded=mscFrDteLeqByteThresholdExceeded, mscFrDteStDlciHqThrStatsTable=mscFrDteStDlciHqThrStatsTable, mscFrDteFramerRowStatusTable=mscFrDteFramerRowStatusTable, mscFrDteAcceptUndefinedDlci=mscFrDteAcceptUndefinedDlci, mscFrDteStDlciHqQueuePurgeDiscards=mscFrDteStDlciHqQueuePurgeDiscards, mscFrDteDynDlciDefsIpCos=mscFrDteDynDlciDefsIpCos, mscFrDteLmiRowStatus=mscFrDteLmiRowStatus, mscFrDteRgBfrRowStatus=mscFrDteRgBfrRowStatus, mscFrDteLmiFullEnquiryInterval=mscFrDteLmiFullEnquiryInterval, mscFrDteFramerRowStatusEntry=mscFrDteFramerRowStatusEntry, mscFrDteStDlciHqMulThresholdExceeded=mscFrDteStDlciHqMulThresholdExceeded, mscFrDteLmiProcedures=mscFrDteLmiProcedures, mscFrDteLeqComponentName=mscFrDteLeqComponentName, mscFrDteVFramerIndex=mscFrDteVFramerIndex, mscFrDteLeqStatsTable=mscFrDteLeqStatsTable, mscFrDteRgLtDlciRowStatus=mscFrDteRgLtDlciRowStatus, mscFrDteDynDlciDefsRowStatusEntry=mscFrDteDynDlciDefsRowStatusEntry, mscFrDteStDlciHqTotalPktQueued=mscFrDteStDlciHqTotalPktQueued, mscFrDteCustomerIdentifier=mscFrDteCustomerIdentifier, mscFrDteStDlciHqProvTable=mscFrDteStDlciHqProvTable, mscFrDteRgMaxTransmissionUnit=mscFrDteRgMaxTransmissionUnit, mscFrDteLmiMonitoredEvents=mscFrDteLmiMonitoredEvents, mscFrDteLeqCStatsEntry=mscFrDteLeqCStatsEntry, mscFrDteStDlciHqCurrentBytesQueued=mscFrDteStDlciHqCurrentBytesQueued, mscFrDteLmiRowStatusEntry=mscFrDteLmiRowStatusEntry, mscFrDteStDlciRowStatus=mscFrDteStDlciRowStatus, mscFrDteStDlciIndex=mscFrDteStDlciIndex, mscFrDteXmitDiscardCirExceeded=mscFrDteXmitDiscardCirExceeded, mscFrDteStDlciHqTotalMulticastPkt=mscFrDteStDlciHqTotalMulticastPkt, mscFrDteVFramerComponentName=mscFrDteVFramerComponentName, mscFrDteLeqTotalPktForwarded=mscFrDteLeqTotalPktForwarded, mscFrDteVFramerStorageType=mscFrDteVFramerStorageType, mscFrDteRgRowStatusEntry=mscFrDteRgRowStatusEntry, mscFrDteDlciDiscardedFrames=mscFrDteDlciDiscardedFrames, mscFrDteFramerNormPrioLinkUtilFromIf=mscFrDteFramerNormPrioLinkUtilFromIf, mscFrDteDefragSequenceErrors=mscFrDteDefragSequenceErrors, mscFrDteLeqStatsEntry=mscFrDteLeqStatsEntry, mscFrDteStDlciStorageType=mscFrDteStDlciStorageType, mscFrDteStDlciHqRowStatusTable=mscFrDteStDlciHqRowStatusTable, mscFrDteStDlciHqComponentName=mscFrDteStDlciHqComponentName, mscFrDteLeqTotalPktQueued=mscFrDteLeqTotalPktQueued, mscFrDteRgIfAdminStatus=mscFrDteRgIfAdminStatus, mscFrDteDlciDlciState=mscFrDteDlciDlciState, mscFrDteStDlciHqStatsTable=mscFrDteStDlciHqStatsTable, mscFrDteErrFaultTime=mscFrDteErrFaultTime, mscFrDteOperStatusTable=mscFrDteOperStatusTable, mscFrDteStDlciExcessBurstAction=mscFrDteStDlciExcessBurstAction, mscFrDteVFramerOperationalState=mscFrDteVFramerOperationalState, mscFrDteRgBfrProvTable=mscFrDteRgBfrProvTable, mscFrDteDlciStorageType=mscFrDteDlciStorageType, mscFrDteDlciRateEnforcement=mscFrDteDlciRateEnforcement, mscFrDteLeqIndex=mscFrDteLeqIndex, mscFrDteRgBfrOprEntry=mscFrDteRgBfrOprEntry, mscFrDteDlcmiProtoErr=mscFrDteDlcmiProtoErr, mscFrDteDlciCommittedBurst=mscFrDteDlciCommittedBurst, mscFrDteIfEntryEntry=mscFrDteIfEntryEntry, mscFrDteOperEntry=mscFrDteOperEntry, mscFrDteStDlciHqCurrentMulticastQueued=mscFrDteStDlciHqCurrentMulticastQueued, mscFrDteStDlciHqTotalPktHandled=mscFrDteStDlciHqTotalPktHandled, frameRelayDteCapabilitiesCA=frameRelayDteCapabilitiesCA, mscFrDteRgIfEntryEntry=mscFrDteRgIfEntryEntry, mscFrDteStDlciRowStatusEntry=mscFrDteStDlciRowStatusEntry, mscFrDteRgIfEntryTable=mscFrDteRgIfEntryTable, mscFrDteDynDlciDefsRateEnforcement=mscFrDteDynDlciDefsRateEnforcement, mscFrDteLmiIndex=mscFrDteLmiIndex, mscFrDteLeqThrStatsEntry=mscFrDteLeqThrStatsEntry, mscFrDteRecvDiscardLmiInactive=mscFrDteRecvDiscardLmiInactive, mscFrDteFramerLargeFrmErrors=mscFrDteFramerLargeFrmErrors, mscFrDteRgProvEntry=mscFrDteRgProvEntry, mscFrDteFramerLrcErrors=mscFrDteFramerLrcErrors, mscFrDteStDlciRgLinkEntry=mscFrDteStDlciRgLinkEntry, mscFrDteLeqMaxMsecData=mscFrDteLeqMaxMsecData, mscFrDteRowStatusEntry=mscFrDteRowStatusEntry, mscFrDteRgLinkToProtocolPort=mscFrDteRgLinkToProtocolPort, mscFrDteStDlciHqTotalPktForwarded=mscFrDteStDlciHqTotalPktForwarded, mscFrDteFramerStatsEntry=mscFrDteFramerStatsEntry, mscFrDteLeqProvEntry=mscFrDteLeqProvEntry, mscFrDteDynDlciDefsProvEntry=mscFrDteDynDlciDefsProvEntry, mscFrDteRgBfrIndex=mscFrDteRgBfrIndex, mscFrDteLeqMaxPackets=mscFrDteLeqMaxPackets, mscFrDteCidDataEntry=mscFrDteCidDataEntry, mscFrDteRgStateTable=mscFrDteRgStateTable, mscFrDteFramerStatsTable=mscFrDteFramerStatsTable, mscFrDteFramerIndex=mscFrDteFramerIndex, mscFrDteDynDlciDefsIndex=mscFrDteDynDlciDefsIndex, mscFrDteFramerStateTable=mscFrDteFramerStateTable, mscFrDteDlciReceivedFrames=mscFrDteDlciReceivedFrames, mscFrDteDynDlciDefs=mscFrDteDynDlciDefs, mscFrDteLeqQueueByteThreshold=mscFrDteLeqQueueByteThreshold, mscFrDteStDlciCommittedBurst=mscFrDteStDlciCommittedBurst, frameRelayDteGroupCA=frameRelayDteGroupCA, mscFrDteDlciExcessBurstAction=mscFrDteDlciExcessBurstAction, mscFrDteDlciLastTimeChange=mscFrDteDlciLastTimeChange, mscFrDteDlciReceivedBECNs=mscFrDteDlciReceivedBECNs, mscFrDteStDlciHqTimeToLive=mscFrDteStDlciHqTimeToLive, mscFrDteStDlciHqQueueByteThreshold=mscFrDteStDlciHqQueueByteThreshold, mscFrDteStDlciProvTable=mscFrDteStDlciProvTable, mscFrDteStDlciHqCurrentPktQueued=mscFrDteStDlciHqCurrentPktQueued, mscFrDteXmitDiscardPvcInactive=mscFrDteXmitDiscardPvcInactive, mscFrDteRgComponentName=mscFrDteRgComponentName, mscFrDteIllegalDlci=mscFrDteIllegalDlci, mscFrDteRgBfrProvEntry=mscFrDteRgBfrProvEntry, mscFrDteRgBfrMacAddr=mscFrDteRgBfrMacAddr, mscFrDteLeqMaxPercentMulticast=mscFrDteLeqMaxPercentMulticast, mscFrDteStorageType=mscFrDteStorageType, mscFrDteVFramerStateEntry=mscFrDteVFramerStateEntry, mscFrDteDlciRowStatusTable=mscFrDteDlciRowStatusTable, mscFrDteLmiOperEntry=mscFrDteLmiOperEntry, mscFrDteStDlciComponentName=mscFrDteStDlciComponentName, mscFrDteDynDlciDefsRowStatusTable=mscFrDteDynDlciDefsRowStatusTable, mscFrDteStateTable=mscFrDteStateTable, mscFrDteStDlciHqTStatsTable=mscFrDteStDlciHqTStatsTable, mscFrDteVFramer=mscFrDteVFramer, mscFrDteIfIndex=mscFrDteIfIndex, mscFrDteRgMpEntry=mscFrDteRgMpEntry, mscFrDteDlci=mscFrDteDlci, mscFrDteRgStorageType=mscFrDteRgStorageType, mscFrDteDlciCreationType=mscFrDteDlciCreationType, mscFrDteRgStateEntry=mscFrDteRgStateEntry, mscFrDteStDlciHq=mscFrDteStDlciHq, mscFrDteRgBfrRowStatusEntry=mscFrDteRgBfrRowStatusEntry, mscFrDteLeqMemThresholdExceeded=mscFrDteLeqMemThresholdExceeded, mscFrDteStDlciHqIndex=mscFrDteStDlciHqIndex, mscFrDteRowStatusTable=mscFrDteRowStatusTable, mscFrDteFramerCrcErrors=mscFrDteFramerCrcErrors, mscFrDteDlciRowStatus=mscFrDteDlciRowStatus, mscFrDteDlciExcessBurst=mscFrDteDlciExcessBurst, mscFrDteStDlciStdRowStatus=mscFrDteStDlciStdRowStatus, mscFrDteVFramerRowStatusEntry=mscFrDteVFramerRowStatusEntry, mscFrDteRgOperStatusTable=mscFrDteRgOperStatusTable, mscFrDteDynDlciDefsExcessBurstAction=mscFrDteDynDlciDefsExcessBurstAction, mscFrDteStDlciHqMemThresholdExceeded=mscFrDteStDlciHqMemThresholdExceeded, mscFrDteRgBfrRowStatusTable=mscFrDteRgBfrRowStatusTable, frameRelayDteMIB=frameRelayDteMIB, mscFrDteStDlciHqStatsEntry=mscFrDteStDlciHqStatsEntry, mscFrDteDlciUsageState=mscFrDteDlciUsageState, mscFrDteComponentName=mscFrDteComponentName, mscFrDteFramerStorageType=mscFrDteFramerStorageType, mscFrDteFramerNormPrioLinkUtilToIf=mscFrDteFramerNormPrioLinkUtilToIf, mscFrDteDlciReceivedFECNs=mscFrDteDlciReceivedFECNs, mscFrDte=mscFrDte, mscFrDteLeqQueuePktThreshold=mscFrDteLeqQueuePktThreshold, mscFrDteDynDlciDefsCommittedInformationRate=mscFrDteDynDlciDefsCommittedInformationRate, mscFrDteStDlciRowStatusTable=mscFrDteStDlciRowStatusTable, mscFrDteStDlciHqRowStatus=mscFrDteStDlciHqRowStatus, mscFrDteFramerStateEntry=mscFrDteFramerStateEntry, mscFrDteDynDlciDefsExcessBurst=mscFrDteDynDlciDefsExcessBurst, mscFrDteLeqTStatsEntry=mscFrDteLeqTStatsEntry, mscFrDteVFramerProvEntry=mscFrDteVFramerProvEntry, mscFrDteErrData=mscFrDteErrData, mscFrDteDlciOperTable=mscFrDteDlciOperTable, mscFrDteDlciCommittedInformationRate=mscFrDteDlciCommittedInformationRate)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayDteMIB", mscFrDteUsageState=mscFrDteUsageState, mscFrDteRgIndex=mscFrDteRgIndex, mscFrDteDlciStateTable=mscFrDteDlciStateTable, mscFrDteDlcmiUnknownIe=mscFrDteDlcmiUnknownIe, mscFrDteLeqCStatsTable=mscFrDteLeqCStatsTable, mscFrDteXmitDiscardLmiInactive=mscFrDteXmitDiscardLmiInactive, mscFrDteStDlciHqTStatsEntry=mscFrDteStDlciHqTStatsEntry, mscFrDteLeqProvTable=mscFrDteLeqProvTable, mscFrDteStDlciHqRowStatusEntry=mscFrDteStDlciHqRowStatusEntry, mscFrDteStDlciCommittedInformationRate=mscFrDteStDlciCommittedInformationRate, mscFrDteXmitDiscardPvcDown=mscFrDteXmitDiscardPvcDown, mscFrDteRgBfrStorageType=mscFrDteRgBfrStorageType, mscFrDteLmi=mscFrDteLmi, mscFrDteRgBfrOprTable=mscFrDteRgBfrOprTable, mscFrDteLeqQueueMulticastThreshold=mscFrDteLeqQueueMulticastThreshold, mscFrDteIfAdminStatus=mscFrDteIfAdminStatus, mscFrDteRgOperStatusEntry=mscFrDteRgOperStatusEntry, mscFrDteDynDlciDefsStdRowStatus=mscFrDteDynDlciDefsStdRowStatus, mscFrDteStDlciHqTotalPktDiscards=mscFrDteStDlciHqTotalPktDiscards, mscFrDteOperStatusEntry=mscFrDteOperStatusEntry, mscFrDteUlpUnknownProtocol=mscFrDteUlpUnknownProtocol, mscFrDteLeqCurrentPktQueued=mscFrDteLeqCurrentPktQueued, mscFrDteLmiErrorThreshold=mscFrDteLmiErrorThreshold, mscFrDteVFramerAdminState=mscFrDteVFramerAdminState, mscFrDteRowStatus=mscFrDteRowStatus, mscFrDteLeqMulThresholdExceeded=mscFrDteLeqMulThresholdExceeded, mscFrDteProvEntry=mscFrDteProvEntry, mscFrDteDynDlciDefsStorageType=mscFrDteDynDlciDefsStorageType, mscFrDteReceiveShort=mscFrDteReceiveShort, mscFrDteFramerFrmToIf=mscFrDteFramerFrmToIf, mscFrDteRecvDiscardPvcDown=mscFrDteRecvDiscardPvcDown, mscFrDteDlciSentOctets=mscFrDteDlciSentOctets, mscFrDteStateEntry=mscFrDteStateEntry, frameRelayDteGroupCA02=frameRelayDteGroupCA02, mscFrDteLeqTimeToLive=mscFrDteLeqTimeToLive, mscFrDteFramerUsageState=mscFrDteFramerUsageState, mscFrDteRecvDiscardPvcInactive=mscFrDteRecvDiscardPvcInactive, mscFrDteVFramerProvTable=mscFrDteVFramerProvTable, mscFrDteErrTime=mscFrDteErrTime, mscFrDteStDlciProvEntry=mscFrDteStDlciProvEntry, mscFrDteLeqRowStatusEntry=mscFrDteLeqRowStatusEntry, mscFrDteLinkOperState=mscFrDteLinkOperState, mscFrDteStDlciHqTimedOutPkt=mscFrDteStDlciHqTimedOutPkt, mscFrDteDynDlciDefsComponentName=mscFrDteDynDlciDefsComponentName, mscFrDteFramerAdminState=mscFrDteFramerAdminState, mscFrDteFramer=mscFrDteFramer, mscFrDteLeqPktThresholdExceeded=mscFrDteLeqPktThresholdExceeded, mscFrDteLeqTimedOutPkt=mscFrDteLeqTimedOutPkt, mscFrDteRgAdminState=mscFrDteRgAdminState, mscFrDteStDlciHqCStatsTable=mscFrDteStDlciHqCStatsTable, mscFrDteStDlciIpCos=mscFrDteStDlciIpCos, mscFrDteFramerRowStatus=mscFrDteFramerRowStatus, mscFrDteStDlciLinkToRemoteGroup=mscFrDteStDlciLinkToRemoteGroup, mscFrDteFramerAborts=mscFrDteFramerAborts, mscFrDteIfEntryTable=mscFrDteIfEntryTable, mscFrDteVFramerStateTable=mscFrDteVFramerStateTable, frameRelayDteCapabilitiesCA02=frameRelayDteCapabilitiesCA02, mscFrDteLmiRowStatusTable=mscFrDteLmiRowStatusTable, mscFrDteLeqQueuePurgeDiscards=mscFrDteLeqQueuePurgeDiscards, mscFrDteStDlci=mscFrDteStDlci, mscFrDteDynDlciDefsCommittedBurst=mscFrDteDynDlciDefsCommittedBurst, mscFrDteDynDlciDefsProvTable=mscFrDteDynDlciDefsProvTable, mscFrDteDynDlciDefsRowStatus=mscFrDteDynDlciDefsRowStatus, mscFrDteRgOperationalState=mscFrDteRgOperationalState)

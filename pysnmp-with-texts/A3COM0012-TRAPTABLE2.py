#
# PySNMP MIB module A3COM0012-TRAPTABLE2 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/A3COM0012-TRAPTABLE2
# Produced by pysmi-0.3.4 at Wed May  1 11:08:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
localSnmp, = mibBuilder.importSymbols("A3COM0004-GENERIC", "localSnmp")
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, Integer32, IpAddress, ModuleIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Gauge32, Counter64, Unsigned32, TimeTicks, Bits, iso, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Integer32", "IpAddress", "ModuleIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Gauge32", "Counter64", "Unsigned32", "TimeTicks", "Bits", "iso", "MibIdentifier")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
snmpTrapTable = MibTable((1, 3, 6, 1, 4, 1, 43, 10, 10, 2), )
if mibBuilder.loadTexts: snmpTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapTable.setDescription('This table can store the destination addresses of SNMP managers that wish to receive traps from this device.')
snmpTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1), ).setIndexNames((0, "A3COM0012-TRAPTABLE2", "snmpTrapIndex"))
if mibBuilder.loadTexts: snmpTrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapEntry.setDescription('This table can store the destination addresses of SNMP managers that wish to receive traps from this device.')
snmpTrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapIndex.setDescription('This is the unique identifier for this row in the snmpTrapTable. When creating a new row, a manager can read the value of the snmpTrapNextFreeIndex object and (if non-zero) can use this value as the index of the new row to be created. The actual number of rows that can be created on any particular device depends on the memory and processing resources available at the time.')
snmpTrapDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapDestination.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapDestination.setDescription('This DisplayString is the network address of the device to which SNMP traps will be sent. This is an IP or IPX address. The following formats can be used. IP nnn.nnn.nnn.nnn - dotted format IPX AABBCCDD:AABBCCDDEEFF - network : node Destination addresses must be unique within this table. An error is returned if an attempt is made to add a duplicate address.')
snmpTrapProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("ip", 2), ("ipx", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapProtocol.setDescription('This defines the transport protocol to use when sending an SNMP trap. At present, this value is determined by the format/value of snmpTrapDestionation which is currently un-ambiguous and so this object is read-only.')
snmpTrapCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCommunity.setDescription('SNMP Community String to be used when sending Traps to this destination.')
snmpTrapCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapCategory.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapCategory.setDescription("32 Bit Mask indicating which Trap categories that the snmpTrapDestination is interested in. '00000001'h - High Priority Configuration Traps '00000002'h - Low Priority Configuration Traps '00000004'h - High Priority Security Traps '00000008'h - Low Priority Security Traps '00000010'h - Alarms & Polling Traps '00000020'h - Regular Heartbeat Traps '00000040'h - End Station Table Traps '00000080'h - reserved '00000100'h - Physical Entity Traps '00000200'h - Facility Traps '00000400'h - Service Related Traps A value of 0xFFFFFFFF enables all traps.")
snmpTrapThrottle = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99999)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapThrottle.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapThrottle.setDescription('The maximum rate at which that snmpTrapDestination is willing to receive traps, specified as the minimum interval in milliseconds between traps. For example, a value of 2000 will limit traps sent to this destination to one trap every 2 seconds. A value of zero indicates that no trap throttling is required.')
snmpTrapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 43, 10, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapRowStatus.setDescription('The SNMPv2 RowStatus convention. Notes: Because this is such a simple table:- 1) Writing any data to a destroyed row, changes its state to active. 2) There is no notReady or notInService state. Each row is either active or destroyed.')
snmpTrapNextFreeIndex = MibScalar((1, 3, 6, 1, 4, 1, 43, 10, 10, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapNextFreeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: snmpTrapNextFreeIndex.setDescription('Indicates the the next value of snmpTrapIndex which can be used to create a new trap destination entry. This value is zero if there are no free rows in the table.')
mibBuilder.exportSymbols("A3COM0012-TRAPTABLE2", snmpTrapProtocol=snmpTrapProtocol, snmpTrapDestination=snmpTrapDestination, snmpTrapEntry=snmpTrapEntry, snmpTrapCommunity=snmpTrapCommunity, snmpTrapNextFreeIndex=snmpTrapNextFreeIndex, snmpTrapCategory=snmpTrapCategory, snmpTrapRowStatus=snmpTrapRowStatus, snmpTrapTable=snmpTrapTable, snmpTrapIndex=snmpTrapIndex, snmpTrapThrottle=snmpTrapThrottle)

#
# PySNMP MIB module EICON-MIB-SERVER (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EICON-MIB-SERVER
# Produced by pysmi-0.3.4 at Wed May  1 12:59:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
iso, Integer32, enterprises, Gauge32, Counter32, NotificationType, ModuleIdentity, IpAddress, MibIdentifier, Bits, ObjectIdentity, TimeTicks, Unsigned32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Integer32", "enterprises", "Gauge32", "Counter32", "NotificationType", "ModuleIdentity", "IpAddress", "MibIdentifier", "Bits", "ObjectIdentity", "TimeTicks", "Unsigned32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType")
DisplayString, PhysAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "PhysAddress", "TextualConvention")
eicon = MibIdentifier((1, 3, 6, 1, 4, 1, 434))
management = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2))
mibv2 = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2))
module = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2, 4))
class OperState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("other", 1), ("disabled", 2), ("ready", 3), ("active", 4), ("busy", 5))

class AdminState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("start", 1), ("stop", 2), ("dump", 3), ("test", 4), ("invalid", 5))

class ActionState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("done", 1), ("failed", 2), ("in-progress", 3))

class EiconCardType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37))
    namedValues = NamedValues(("ect-NONE", 1), ("ect-PC-NA", 2), ("ect-PC-DNA", 3), ("ect-PC-SPNA", 4), ("ect-MC-SPCC", 5), ("ect-PC-DPNA", 6), ("ect-PC-EC", 7), ("ect-PC-ECHSI", 8), ("ect-PC-QPNA", 9), ("ect-PC-MPNA", 10), ("ect-MC-EC", 11), ("ect-MC-HSI", 12), ("ect-XX-DIGI", 13), ("ect-MC-IMC", 14), ("ect-PC-IMC", 15), ("ect-MC-MPNA", 16), ("ect-PC-HSI1M", 17), ("ect-MC-HSI1M", 18), ("ect-NB-HSI1M", 19), ("ect-PC-EC1M", 20), ("ect-MC-EC1M", 21), ("ect-NB-EC1M", 22), ("ect-NB-IMC", 23), ("ect-NB-SPCC", 24), ("ect-NB-EC", 25), ("ect-PC-ACC8", 26), ("ect-PC-ISDN", 27), ("ect-PC-DPNA2M", 28), ("ect-PC-MPNA2M", 29), ("ect-MC-MPNA2M", 30), ("ect-MC-SPCC2", 31), ("ect-PP-IMC", 32), ("ect-MC-ISDN", 33), ("ect-PP-EC", 34), ("ect-PC-HSI2", 35), ("ect-PC-S51", 36), ("ect-PC-S52", 37))

class ControlOnOff(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("stop", 1), ("start", 2), ("invalid", 3))

class CardRef(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 6)

class PortRef(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 48)

class PortName(DisplayString):
    subtypeSpec = DisplayString.subtypeSpec + ValueSizeConstraint(1, 15)

class PositiveInteger(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

server = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2, 1))
srvAdminStateCtr = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 1), AdminState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvAdminStateCtr.setStatus('mandatory')
if mibBuilder.loadTexts: srvAdminStateCtr.setDescription('The administrative state of the server. This control parameter is modified (set) by Operator in order to change the state of the server.')
srvOsName = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("dos", 2), ("os2", 3), ("unix", 4), ("mac", 5), ("windows", 6), ("netware", 7), ("nt", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvOsName.setStatus('mandatory')
if mibBuilder.loadTexts: srvOsName.setDescription('The name of the Operating System.')
srvOsVersion = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvOsVersion.setStatus('mandatory')
if mibBuilder.loadTexts: srvOsVersion.setDescription('The version of the Operating System; e.g. SCO UNIX 3.2 ')
srvNosName = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("netWare", 2), ("lanManager", 3), ("vines", 4), ("lanServer", 5), ("genericNetBIOS", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvNosName.setStatus('mandatory')
if mibBuilder.loadTexts: srvNosName.setDescription('The name of the Network Operating System.')
srvNosVersion = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvNosVersion.setStatus('mandatory')
if mibBuilder.loadTexts: srvNosVersion.setDescription('The version of the Network Operating System; e.g. NetWare v3.11 ')
srvLanShellInfo = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanShellInfo.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanShellInfo.setDescription('The name and version of the Network Operating System shell.')
srvBusType = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("isa", 2), ("eisa", 3), ("mca", 4), ("parallelPort", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvBusType.setStatus('mandatory')
if mibBuilder.loadTexts: srvBusType.setDescription('The type of the BUS. ')
srvCpuType = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCpuType.setStatus('mandatory')
if mibBuilder.loadTexts: srvCpuType.setDescription('The version of the CPU, e.g. 386 ')
srvCpuSpeed = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 9), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCpuSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: srvCpuSpeed.setDescription('The CPU speed in MGHz.')
srvStdMemory = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 10), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvStdMemory.setStatus('mandatory')
if mibBuilder.loadTexts: srvStdMemory.setDescription('The standard memory (in Kilo Bytes)')
srvExtendMemory = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 11), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvExtendMemory.setStatus('mandatory')
if mibBuilder.loadTexts: srvExtendMemory.setDescription('The extended memory (in Kilo Bytes)')
srvExpandedMemory = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 12), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvExpandedMemory.setStatus('mandatory')
if mibBuilder.loadTexts: srvExpandedMemory.setDescription('The expanded memory (in Kilo Bytes)')
srvVideoAdaptType = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvVideoAdaptType.setStatus('mandatory')
if mibBuilder.loadTexts: srvVideoAdaptType.setDescription('The type of video adapter ')
srvHardDisk = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvHardDisk.setStatus('mandatory')
if mibBuilder.loadTexts: srvHardDisk.setDescription('The name/type of hard disk')
srvHardDiskSize = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvHardDiskSize.setStatus('mandatory')
if mibBuilder.loadTexts: srvHardDiskSize.setDescription('The size in MB of the hard disk')
srvNotePad = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvNotePad.setStatus('mandatory')
if mibBuilder.loadTexts: srvNotePad.setDescription('The string used by the Administrator for supplementary information about the Server. It will be stored by the Agent and retrived from the Agent.')
srvAgentMajorVersion = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvAgentMajorVersion.setStatus('mandatory')
if mibBuilder.loadTexts: srvAgentMajorVersion.setDescription('The major version of the agent. For exemple, version 3.01, the major version is 3.')
srvAgentMinorVersion = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvAgentMinorVersion.setStatus('mandatory')
if mibBuilder.loadTexts: srvAgentMinorVersion.setDescription('The minor version of the agent. For exemple, version 3.01, the minor version is 1.')
srvAgentMaxOfLostNMPHeartB = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvAgentMaxOfLostNMPHeartB.setStatus('mandatory')
if mibBuilder.loadTexts: srvAgentMaxOfLostNMPHeartB.setDescription('The threshold for the number of lost consecutive NMP heartbeat messages. If the number of lost messsages is greater than srvAgentMaxOfLostNMPHeartB, then Agent will generate a Trap.')
srvAgentHeartBeatPeriod = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvAgentHeartBeatPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: srvAgentHeartBeatPeriod.setDescription('The period (in seconds) of the Trap with the server heartbeat message that the Agent will send to the NMC.')
srvAgentPollFrequency = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvAgentPollFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: srvAgentPollFrequency.setDescription('The period (in seconds) for the poll request, issued by the agent to the server components, to detect state changes and send a trap.')
srvAgentAlarmsFilterValue = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvAgentAlarmsFilterValue.setStatus('mandatory')
if mibBuilder.loadTexts: srvAgentAlarmsFilterValue.setDescription('The threshold for the severity value of the alarms. Agent uses the filter for every Alarm before it is sent to the Manager.')
srvDomainName = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: srvDomainName.setDescription('The name of the administrative/security domain of the Server. Has to be known by ECLAN. ECLAN uses this value in the server advertising messages.')
srvDomainConfigDir = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvDomainConfigDir.setStatus('mandatory')
if mibBuilder.loadTexts: srvDomainConfigDir.setDescription('The path-name in the ESS server of the current default directory for all server configuration files. This variable could be set to a new value through the SNMP NM Console before sending the request to the Agent to start the EiconCard, ECLAN or the SSM. The Agent will use it to find necessary configuration information.')
srvNbOfLanCards = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 25), CardRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvNbOfLanCards.setStatus('mandatory')
if mibBuilder.loadTexts: srvNbOfLanCards.setDescription('The number of installed LAN cards ')
srvLanCardTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26), )
if mibBuilder.loadTexts: srvLanCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardTable.setDescription('The table of local LAN cards.')
srvLanCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1), ).setIndexNames((0, "EICON-MIB-SERVER", "srvLanCardIndex"))
if mibBuilder.loadTexts: srvLanCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardEntry.setDescription('The information about one LAN card.')
srvLanCardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 1), CardRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardIndex.setDescription('LAN card reference number. ')
srvLanCardCFGMajorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardCFGMajorVer.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardCFGMajorVer.setDescription('LAN CFG Major Version. This Field is defined by Novell and contains the major version number of the configuration table. In the version number 1.0, 1 is the major version number.')
srvLanCardCFGMinorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardCFGMinorVer.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardCFGMinorVer.setDescription('LAN CFG Minor Version. This Field is defined by Novell and contains the minor version number of the configuration table. In the version number 1.0, 0 is the minor version number.')
srvLanCardNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardNodeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardNodeAddr.setDescription(' Lan Card Node Address. This Field contains the node address of LAN Board.')
srvLanCardMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardMaxSize.setDescription('This field contains the maximum send or receive packet size (in bytes) that the LAN board can transmit or receive.')
srvLanCardName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardName.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardName.setDescription('Lan Card Name. This field contains a pointer to a byte-length proceded, zero-terminated ASCII description string that is contained in the OSDATA segment and is similar to the description string in the definition table. For example: NE2000 ETHERNET Driver.')
srvLanCardShortName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardShortName.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardShortName.setDescription('This field contains a pointer to a string that describes the LAN board in eight bytes or less such as NE2000.')
srvLanCardFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardFrameType.setDescription(" This field contains a pointer to a string that describes the MLID's frame type. Examples include ETHERNET_802.3 and ETHERNET_II. The Independent Manufactuer Support Program (IMSP) assigns strings for the Frame Type. This String is case sensitive, and is a byte length-preceded, zero-terminated ASCII string. ")
srvLanCardDrvMajorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardDrvMajorVer.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardDrvMajorVer.setDescription(' This field contain the major version number of the MLID.')
srvLanCardDrvMinorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardDrvMinorVer.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardDrvMinorVer.setDescription(' This field contain the minor version number of the MLID.')
srvLanCardMemoryAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardMemoryAddr.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardMemoryAddr.setDescription(' This field contains the absolute primary memory address the LAN board used. If not used, this field is set to 0.')
srvLanCardInterrupt = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardInterrupt.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardInterrupt.setDescription(' This field contains the primary interrupt vector number. FFh = not used.')
srvLanCardDMAUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 26, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvLanCardDMAUsage.setStatus('mandatory')
if mibBuilder.loadTexts: srvLanCardDMAUsage.setDescription(' This field contains the primary DMA channel used by the LAN board. FFh = not used.')
srvNbOfSoftPackage = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 27), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvNbOfSoftPackage.setStatus('mandatory')
if mibBuilder.loadTexts: srvNbOfSoftPackage.setDescription('The number of entries in the srvSoftPackageTable.')
srvSoftPackageTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 28), )
if mibBuilder.loadTexts: srvSoftPackageTable.setStatus('mandatory')
if mibBuilder.loadTexts: srvSoftPackageTable.setDescription('The information about the Eicon software installed in the server.')
srvPackageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 28, 1), ).setIndexNames((0, "EICON-MIB-SERVER", "srvProductIndex"))
if mibBuilder.loadTexts: srvPackageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srvPackageEntry.setDescription("The information about Eicon's products in the server.")
srvProductIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 28, 1, 1), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvProductIndex.setStatus('mandatory')
if mibBuilder.loadTexts: srvProductIndex.setDescription('The product reference number')
srvProductName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 28, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvProductName.setStatus('mandatory')
if mibBuilder.loadTexts: srvProductName.setDescription('The name of the product.')
srvProductVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 28, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvProductVersion.setStatus('mandatory')
if mibBuilder.loadTexts: srvProductVersion.setDescription('The version of the (Eicon) product.')
srvProductDate = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 28, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvProductDate.setStatus('mandatory')
if mibBuilder.loadTexts: srvProductDate.setDescription('The installation date and time of the product.')
srvProductConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 28, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvProductConfigured.setStatus('mandatory')
if mibBuilder.loadTexts: srvProductConfigured.setDescription('If the value is yes, the product is configured. If the value is no, the product is installed, but not configured.')
srvCfgNbOfEiconCards = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 29), CardRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgNbOfEiconCards.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgNbOfEiconCards.setDescription('The number of configured EiconCards (from the current configuration)')
srvCfgEiconCardTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30), )
if mibBuilder.loadTexts: srvCfgEiconCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgEiconCardTable.setDescription('The table of configuration information of EiconCards (from the current configuration.')
srvCfgEiconCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1), ).setIndexNames((0, "EICON-MIB-SERVER", "srvCfgECIndex"))
if mibBuilder.loadTexts: srvCfgEiconCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgEiconCardEntry.setDescription('The configuration information about one EiconCard.')
srvCfgECIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1, 1), CardRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgECIndex.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgECIndex.setDescription('The Id of the EiconCard.')
srvCfgECMemAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgECMemAddr.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgECMemAddr.setDescription('The EiconCard memory segment address.')
srvCfgECIoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgECIoAddr.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgECIoAddr.setDescription('The EiconCard IO address.')
srvCfgECIntrLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgECIntrLevel.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgECIntrLevel.setDescription('The EiconCard interrupt level.')
srvCfgECNbOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1, 5), PortRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgECNbOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgECNbOfPorts.setDescription('The number of ports.')
srvCfgECSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgECSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgECSlotNumber.setDescription('The slot number for MicroChannel.')
srvCfgECOptModule = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mod-DPSM", 1), ("mod-HSIM", 2), ("mod-None", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgECOptModule.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgECOptModule.setDescription('The optional module for the MPNA card.')
srvCfgECAutoActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 30, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgECAutoActivate.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgECAutoActivate.setDescription('The auto activation of the X.25 ports when the card starts.')
srvCfgNbOfPorts = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 31), PortRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgNbOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgNbOfPorts.setDescription('The number of configured ports for all EiconCards (from the current configuration)')
srvCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 32), )
if mibBuilder.loadTexts: srvCfgPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgPortTable.setDescription('The table of configuration information of ports, from the current configuration.')
srvCfgPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 32, 1), ).setIndexNames((0, "EICON-MIB-SERVER", "srvCfgPortIndex"))
if mibBuilder.loadTexts: srvCfgPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgPortEntry.setDescription('The configuration information about one port.')
srvCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 32, 1, 1), PortRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgPortIndex.setDescription('The index of the port generated by the Agent.')
srvCfgPortLanaNo = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 32, 1, 2), PortRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgPortLanaNo.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgPortLanaNo.setDescription('The LANA number of the port from the configuration, range: 1..48.')
srvCfgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 32, 1, 3), PortName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvCfgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: srvCfgPortName.setDescription('The unique port name.')
srvDescr = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDescr.setStatus('mandatory')
if mibBuilder.loadTexts: srvDescr.setDescription("A textual description of the entity. This value should include the full name and version identification of the system's hardware type, software operating-system, and networking software. It is mandatory that this only contain printable ASCII characters.")
srvObjectID = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 34), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: srvObjectID.setDescription("The vendor's authoritative identification of the network management subsystem contained in the entity. This value is allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides an easy and unambiguous means for determining `what kind of box' is being managed. For example, if vendor `Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, it could assign the identifier 1.3.6.1.4.1.4242.1.1 to its `Fred Router'.")
srvUpTime = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 35), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: srvUpTime.setDescription('The time (in hundredths of a second) since the network management portion of the system was last re-initialized.')
srvContact = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 36), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvContact.setStatus('mandatory')
if mibBuilder.loadTexts: srvContact.setDescription('The textual identification of the contact person for this managed node, together with information on how to contact this person.')
srvName = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 37), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvName.setStatus('mandatory')
if mibBuilder.loadTexts: srvName.setDescription("An administratively-assigned name for this managed node. By convention, this is the node's fully-qualified domain name.")
srvLocation = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 38), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvLocation.setStatus('mandatory')
if mibBuilder.loadTexts: srvLocation.setDescription("The physical location of this node (e.g., `telephone closet, 3rd floor').")
srvServices = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvServices.setStatus('mandatory')
if mibBuilder.loadTexts: srvServices.setDescription('A value which indicates the set of services that this entity offers primarily. The value is a sum. This sum initially takes the value zero, Then, for each layer, L, in the range 1 through 7, that this node performs transactions for, 2 raised to (L - 1) is added to the sum. For example, a node which performs primarily routing functions would have a value of 4 (2^(3-1)). In contrast, a node which is a host offering application services would have a value of 72 (2^(4-1) + 2^(7-1)). Note that in the context of the Internet suite of protocols, values should be calculated accordingly: layer functionality 1 physical (e.g., repeaters) 2 datalink/subnetwork (e.g., bridges) 3 internet (e.g., IP gateways) 4 end-to-end (e.g., IP hosts) 7 applications (e.g., mail relays) For systems including OSI protocols, layers 5 and 6 may also be counted.')
srvIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfNumber.setDescription('The number of network interfaces (regardless of their current state) present on this system.')
srvIfTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41), )
if mibBuilder.loadTexts: srvIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfTable.setDescription('A list of interface entries. The number of entries is given by the value of ifNumber.')
srvIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1), ).setIndexNames((0, "EICON-MIB-SERVER", "srvIfIndex"))
if mibBuilder.loadTexts: srvIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfEntry.setDescription('An interface entry containing objects at the subnetwork layer and below for a particular interface.')
srvIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfIndex.setDescription("A unique value for each interface. Its value ranges between 1 and the value of srvIfNumber. The value for each interface must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
srvIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfDescr.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfDescr.setDescription('A textual string containing information about the interface. This string should include the name of the manufacturer, the product name and the version of the hardware interface.')
srvIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet-csmacd", 6), ("iso88023-csmacd", 7), ("iso88024-tokenBus", 8), ("iso88025-tokenRing", 9), ("iso88026-man", 10), ("starLan", 11), ("proteon-10Mbit", 12), ("proteon-80Mbit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("ds1", 18), ("e1", 19), ("basicISDN", 20), ("primaryISDN", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("frame-relay", 32), ("appc", 33), ("snafm", 34), ("snapc", 35), ("xport-iso", 36), ("xport-tgx", 37), ("netview", 38), ("llc", 39), ("snafr", 40)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfType.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfType.setDescription("The type of interface, distinguished according to the physical/link protocol(s) immediately `below' the network layer in the protocol stack.")
srvIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfMtu.setDescription('The size of the largest datagram which can be sent/received on the interface, specified in octets. For interfaces that are used for transmitting network datagrams, this is the size of the largest network datagram that can be sent on the interface.')
srvIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfSpeed.setDescription("An estimate of the interface's current bandwidth in bits per second. For interfaces which do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.")
srvIfPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfPhysAddress.setDescription("The interface's address at the protocol layer immediately `below' the network layer in the protocol stack. For interfaces which do not have such an address (e.g., a serial line), this object should contain an octet string of zero length.")
srvIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfAdminStatus.setDescription('The desired state of the interface. The testing(3) state indicates that no operational packets can be passed.')
srvIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfOperStatus.setDescription('The current operational state of the interface. The testing(3) state indicates that no operational packets can be passed.')
srvIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfLastChange.setDescription('The value of sysUpTime at the time the interface entered its current operational state. If the current state was entered prior to the last re-initialization of the local network management subsystem, then this object contains a zero value.')
srvIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfInOctets.setDescription('The total number of octets received on the interface, including framing characters.')
srvIfInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfInUcastPkts.setDescription('The number of subnetwork-unicast packets delivered to a higher-layer protocol.')
srvIfInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfInNUcastPkts.setDescription('The number of non-unicast (i.e., subnetwork- broadcast or subnetwork-multicast) packets delivered to a higher-layer protocol.')
srvIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfInDiscards.setDescription('The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space.')
srvIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfInErrors.setDescription('The number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
srvIfInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfInUnknownProtos.setDescription('The number of packets received via the interface which were discarded because of an unknown or unsupported protocol.')
srvIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfOutOctets.setDescription('The total number of octets transmitted out of the interface, including framing characters.')
srvIfOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfOutUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a subnetwork-unicast address, including those that were discarded or not sent.')
srvIfOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfOutNUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a non- unicast (i.e., a subnetwork-broadcast or subnetwork-multicast) address, including those that were discarded or not sent.')
srvIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfOutDiscards.setDescription('The number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent them from being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
srvIfOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfOutErrors.setDescription('The number of outbound packets that could not be transmitted because of errors.')
srvIfOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfOutQLen.setDescription('The length of the output packet queue (in packets).')
srvIfSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 41, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvIfSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: srvIfSpecific.setDescription('A reference to MIB definitions specific to the particular media being used to realize the interface. For example, if the interface is realized by an ethernet, then the value of this object refers to a document defining objects specific to ethernet. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }, which is a syntatically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
srvModulesOperStates = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 42), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvModulesOperStates.setStatus('mandatory')
if mibBuilder.loadTexts: srvModulesOperStates.setDescription('This is an array of Operation States for the Eicon modules running on the gateway. Each entry will have the syntax OperState. Array Index 0 Server state (Always active) 1 EcAppc state 2 SSM state 3 Router state 4 EcPad state 5 EcSwitch state 6 SLC state 7 HPRINT state 8 ECLan State A value of 0 in these positions means the specific module is not loaded.')
srvInstallDirName = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 43), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvInstallDirName.setStatus('mandatory')
if mibBuilder.loadTexts: srvInstallDirName.setDescription("This is the directory where Eicon's products are installed.")
srvCurrDirName = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 44), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srvCurrDirName.setStatus('mandatory')
if mibBuilder.loadTexts: srvCurrDirName.setDescription('The entries in srvDirTable are the contents of this directory.')
srvDirTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 45), )
if mibBuilder.loadTexts: srvDirTable.setStatus('mandatory')
if mibBuilder.loadTexts: srvDirTable.setDescription('A list of entries for the directory specified in srvCurrDirname.')
srvDirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 45, 1), ).setIndexNames((0, "EICON-MIB-SERVER", "srvIfIndex"))
if mibBuilder.loadTexts: srvDirEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srvDirEntry.setDescription('An directory entry containing the names of files.')
srvDirIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 45, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDirIndex.setStatus('mandatory')
if mibBuilder.loadTexts: srvDirIndex.setDescription(' The index assigned by the Agent.')
srvDirFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 45, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDirFilename.setStatus('mandatory')
if mibBuilder.loadTexts: srvDirFilename.setDescription('The file name. ')
srvDirFileAttribute = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 45, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDirFileAttribute.setStatus('mandatory')
if mibBuilder.loadTexts: srvDirFileAttribute.setDescription('The attributes of the file. 0x0 - Normal 0x1 - ReadOnly 0x2 - Hidden 0x4 - System 0x10 - Subdirectory 0x20 - Archive 0x80 - Share.')
srvDirFileAccessTime = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 45, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDirFileAccessTime.setStatus('mandatory')
if mibBuilder.loadTexts: srvDirFileAccessTime.setDescription('The time the file is accessed expressed in seconds since Jan 01 1970.')
srvDirFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 1, 45, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srvDirFileSize.setStatus('mandatory')
if mibBuilder.loadTexts: srvDirFileSize.setDescription('The file size in bytes.')
srvTrapHeartbeat = NotificationType((1, 3, 6, 1, 4, 1, 434) + (0,11)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: srvTrapHeartbeat.setDescription('The srvTrapHeartbeat trap indicates that the server is still active.')
srvTrapInternal = NotificationType((1, 3, 6, 1, 4, 1, 434) + (0,12)).setObjects(("SNMPv2-MIB", "sysName"))
if mibBuilder.loadTexts: srvTrapInternal.setDescription('The generic Internal trap indicates that the Agent detected an internal error.')
mibBuilder.exportSymbols("EICON-MIB-SERVER", ActionState=ActionState, srvCfgNbOfEiconCards=srvCfgNbOfEiconCards, srvDomainConfigDir=srvDomainConfigDir, srvOsName=srvOsName, OperState=OperState, srvStdMemory=srvStdMemory, srvDescr=srvDescr, srvIfInNUcastPkts=srvIfInNUcastPkts, srvIfOutDiscards=srvIfOutDiscards, srvNotePad=srvNotePad, PortRef=PortRef, srvDirEntry=srvDirEntry, srvCfgEiconCardTable=srvCfgEiconCardTable, srvIfEntry=srvIfEntry, srvBusType=srvBusType, management=management, srvLanCardDrvMajorVer=srvLanCardDrvMajorVer, srvIfOutQLen=srvIfOutQLen, srvIfSpecific=srvIfSpecific, srvExpandedMemory=srvExpandedMemory, srvCfgNbOfPorts=srvCfgNbOfPorts, PositiveInteger=PositiveInteger, srvAgentMaxOfLostNMPHeartB=srvAgentMaxOfLostNMPHeartB, srvExtendMemory=srvExtendMemory, srvVideoAdaptType=srvVideoAdaptType, srvLanCardMemoryAddr=srvLanCardMemoryAddr, srvCfgECIoAddr=srvCfgECIoAddr, srvLocation=srvLocation, srvCfgPortLanaNo=srvCfgPortLanaNo, srvSoftPackageTable=srvSoftPackageTable, srvLanCardNodeAddr=srvLanCardNodeAddr, srvTrapInternal=srvTrapInternal, srvIfInUnknownProtos=srvIfInUnknownProtos, srvInstallDirName=srvInstallDirName, srvDirFilename=srvDirFilename, srvCfgECIndex=srvCfgECIndex, EiconCardType=EiconCardType, srvCfgECOptModule=srvCfgECOptModule, srvCfgECSlotNumber=srvCfgECSlotNumber, srvLanShellInfo=srvLanShellInfo, srvIfType=srvIfType, srvLanCardShortName=srvLanCardShortName, ControlOnOff=ControlOnOff, srvAdminStateCtr=srvAdminStateCtr, srvNbOfSoftPackage=srvNbOfSoftPackage, CardRef=CardRef, srvLanCardDrvMinorVer=srvLanCardDrvMinorVer, srvDirFileSize=srvDirFileSize, eicon=eicon, srvHardDisk=srvHardDisk, srvAgentMajorVersion=srvAgentMajorVersion, srvProductName=srvProductName, AdminState=AdminState, srvIfAdminStatus=srvIfAdminStatus, mibv2=mibv2, srvProductVersion=srvProductVersion, srvLanCardTable=srvLanCardTable, srvProductIndex=srvProductIndex, srvIfTable=srvIfTable, srvLanCardCFGMinorVer=srvLanCardCFGMinorVer, srvCfgPortName=srvCfgPortName, module=module, srvCpuSpeed=srvCpuSpeed, srvServices=srvServices, srvLanCardName=srvLanCardName, srvIfPhysAddress=srvIfPhysAddress, PortName=PortName, srvCfgPortTable=srvCfgPortTable, srvLanCardDMAUsage=srvLanCardDMAUsage, srvDirTable=srvDirTable, srvIfOutOctets=srvIfOutOctets, srvAgentMinorVersion=srvAgentMinorVersion, srvDomainName=srvDomainName, srvAgentPollFrequency=srvAgentPollFrequency, srvLanCardMaxSize=srvLanCardMaxSize, srvObjectID=srvObjectID, server=server, srvContact=srvContact, srvLanCardFrameType=srvLanCardFrameType, srvTrapHeartbeat=srvTrapHeartbeat, srvCurrDirName=srvCurrDirName, srvCfgEiconCardEntry=srvCfgEiconCardEntry, srvLanCardCFGMajorVer=srvLanCardCFGMajorVer, srvCfgPortIndex=srvCfgPortIndex, srvAgentHeartBeatPeriod=srvAgentHeartBeatPeriod, srvLanCardEntry=srvLanCardEntry, srvCfgECNbOfPorts=srvCfgECNbOfPorts, srvIfDescr=srvIfDescr, srvNosVersion=srvNosVersion, srvCfgECAutoActivate=srvCfgECAutoActivate, srvIfInOctets=srvIfInOctets, srvCfgECMemAddr=srvCfgECMemAddr, srvOsVersion=srvOsVersion, srvIfSpeed=srvIfSpeed, srvPackageEntry=srvPackageEntry, srvName=srvName, srvDirIndex=srvDirIndex, srvHardDiskSize=srvHardDiskSize, srvModulesOperStates=srvModulesOperStates, srvLanCardIndex=srvLanCardIndex, srvIfOperStatus=srvIfOperStatus, srvAgentAlarmsFilterValue=srvAgentAlarmsFilterValue, srvCfgPortEntry=srvCfgPortEntry, srvProductConfigured=srvProductConfigured, srvIfIndex=srvIfIndex, srvNbOfLanCards=srvNbOfLanCards, srvIfInDiscards=srvIfInDiscards, srvIfOutUcastPkts=srvIfOutUcastPkts, srvUpTime=srvUpTime, srvIfInErrors=srvIfInErrors, srvProductDate=srvProductDate, srvIfNumber=srvIfNumber, srvIfInUcastPkts=srvIfInUcastPkts, srvIfLastChange=srvIfLastChange, srvIfMtu=srvIfMtu, srvDirFileAttribute=srvDirFileAttribute, srvLanCardInterrupt=srvLanCardInterrupt, srvDirFileAccessTime=srvDirFileAccessTime, srvIfOutErrors=srvIfOutErrors, srvCpuType=srvCpuType, srvCfgECIntrLevel=srvCfgECIntrLevel, srvNosName=srvNosName, srvIfOutNUcastPkts=srvIfOutNUcastPkts)

#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:30:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
Unsigned32, Gauge32, Integer32, DisplayString, InterfaceIndex, RowStatus, Counter32, StorageType, RowPointer = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Unsigned32", "Gauge32", "Integer32", "DisplayString", "InterfaceIndex", "RowStatus", "Counter32", "StorageType", "RowPointer")
NonReplicated, PassportCounter64, Link = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "NonReplicated", "PassportCounter64", "Link")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, ModuleIdentity, IpAddress, Unsigned32, TimeTicks, Gauge32, Integer32, Counter64, Counter32, ObjectIdentity, MibIdentifier, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "ModuleIdentity", "IpAddress", "Unsigned32", "TimeTicks", "Gauge32", "Integer32", "Counter64", "Counter32", "ObjectIdentity", "MibIdentifier", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
frameRelayMuxMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38))
mscFrMux = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112))
mscFrMuxRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 1), )
if mibBuilder.loadTexts: mscFrMuxRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrMux components.')
mscFrMuxRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"))
if mibBuilder.loadTexts: mscFrMuxRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxRowStatusEntry.setDescription('A single entry in the table represents a single mscFrMux component.')
mscFrMuxRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrMux components. These components can be added and deleted.')
mscFrMuxComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrMuxStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxStorageType.setDescription('This variable represents the storage type value for the mscFrMux tables.')
mscFrMuxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mscFrMuxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxIndex.setDescription('This variable represents the index for the mscFrMux tables.')
mscFrMuxOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 8), )
if mibBuilder.loadTexts: mscFrMuxOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscFrMuxOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 8, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"))
if mibBuilder.loadTexts: mscFrMuxOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxOperStatusEntry.setDescription('An entry in the mscFrMuxOperStatusTable.')
mscFrMuxSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscFrMuxIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 9), )
if mibBuilder.loadTexts: mscFrMuxIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscFrMuxIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 9, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"))
if mibBuilder.loadTexts: mscFrMuxIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxIfEntryEntry.setDescription('An entry in the mscFrMuxIfEntryTable.')
mscFrMuxIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscFrMuxIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 9, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscFrMuxCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 10), )
if mibBuilder.loadTexts: mscFrMuxCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscFrMuxCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"))
if mibBuilder.loadTexts: mscFrMuxCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxCidDataEntry.setDescription('An entry in the mscFrMuxCidDataTable.')
mscFrMuxCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscFrMuxStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11), )
if mibBuilder.loadTexts: mscFrMuxStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscFrMuxStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"))
if mibBuilder.loadTexts: mscFrMuxStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxStateEntry.setDescription('An entry in the mscFrMuxStateTable.')
mscFrMuxAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrMuxOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrMuxUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrMuxAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscFrMuxProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscFrMuxControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscFrMuxAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscFrMuxStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscFrMuxUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscFrMuxStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 12), )
if mibBuilder.loadTexts: mscFrMuxStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxStatsTable.setDescription('This group contains the statistics about the operational behavior of the FrMux at the interface level.')
mscFrMuxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"))
if mibBuilder.loadTexts: mscFrMuxStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxStatsEntry.setDescription('An entry in the mscFrMuxStatsTable.')
mscFrMuxLastUnknownDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLastUnknownDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLastUnknownDlci.setDescription('This attribute identifies the most recent DLCI which user frames were received on, for which a Dlci has not been provisioned on the interface.')
mscFrMuxUnknownDlciFramesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxUnknownDlciFramesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxUnknownDlciFramesFromIf.setDescription('This attribute counts frames received from the interface with an unknown DLCI (Dlci which is not provisioned). When the maximum is reached the count wraps to zero.')
mscFrMuxInvalidHeaderFramesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxInvalidHeaderFramesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxInvalidHeaderFramesFromIf.setDescription('This attribute counts the number of frames received from the interface with an invalid header format. When the maximum is reached the count wraps to zero.')
mscFrMuxTimeFramerCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxTimeFramerCongested.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxTimeFramerCongested.setDescription('This attribute accumulates the time (in msec) during which Framer congestion has been observed in the direction towards the interface. The overload causing this statistic to increase may be caused by oversubscription. When this count reaches maximum, it wraps to zero.')
mscFrMuxFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2))
mscFrMuxFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 1), )
if mibBuilder.loadTexts: mscFrMuxFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrMuxFramer components.')
mscFrMuxFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxFramerIndex"))
if mibBuilder.loadTexts: mscFrMuxFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscFrMuxFramer component.')
mscFrMuxFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrMuxFramer components. These components cannot be added nor deleted.')
mscFrMuxFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrMuxFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerStorageType.setDescription('This variable represents the storage type value for the mscFrMuxFramer tables.')
mscFrMuxFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrMuxFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerIndex.setDescription('This variable represents the index for the mscFrMuxFramer tables.')
mscFrMuxFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 10), )
if mibBuilder.loadTexts: mscFrMuxFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscFrMuxFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxFramerIndex"))
if mibBuilder.loadTexts: mscFrMuxFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerProvEntry.setDescription('An entry in the mscFrMuxFramerProvTable.')
mscFrMuxFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscFrMuxFramerLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 11), )
if mibBuilder.loadTexts: mscFrMuxFramerLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerLinkTable.setDescription('This group contains attributes defining the framing of data on the link interface.')
mscFrMuxFramerLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxFramerIndex"))
if mibBuilder.loadTexts: mscFrMuxFramerLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerLinkEntry.setDescription('An entry in the mscFrMuxFramerLinkTable.')
mscFrMuxFramerDataInversion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 16))).clone(namedValues=NamedValues(("off", 0), ("on", 16))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxFramerDataInversion.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerDataInversion.setDescription("This attribute determines whether data bits are to be inverted (1 to 0 and 0 to 1) before transmission of frames to the interface. If the value of this attribute is On, the incoming data bits will also be inverted when frames are received from the link before being processed. This option is typically used in hdlc framing mode when inversion is used to guarantee 1's density. Note that aborts (in hdlc and interrupting modes) are corrupted when data is inverted. This attribute may only take its default value for non-MSA cards.")
mscFrMuxFramerFrameCrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("crc16", 0), ("crc32", 1), ("noCrc", 2))).clone('crc16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxFramerFrameCrcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerFrameCrcType.setDescription('This attribute defines the type of CRC used. The CRC value calculated is appended to the end of the frames transmitted to the link. The CRC value is removed from the end of frames received from the link and checked for correctness. NoCrc means that CRC is not used. This attribute may take only its default value for non-MSA cards.')
mscFrMuxFramerFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxFramerFlagsBetweenFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerFlagsBetweenFrames.setDescription('This attribute defines the number of flags that are inserted between frames sent to the link interface.')
mscFrMuxFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 12), )
if mibBuilder.loadTexts: mscFrMuxFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrMuxFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxFramerIndex"))
if mibBuilder.loadTexts: mscFrMuxFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerStateEntry.setDescription('An entry in the mscFrMuxFramerStateTable.')
mscFrMuxFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrMuxFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrMuxFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrMuxFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13), )
if mibBuilder.loadTexts: mscFrMuxFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscFrMuxFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxFramerIndex"))
if mibBuilder.loadTexts: mscFrMuxFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerStatsEntry.setDescription('An entry in the mscFrMuxFramerStatsTable.')
mscFrMuxFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerFrmToIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrMuxFramerFrmToIf.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscFrMuxFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerFrmFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrMuxFramerFrmFromIf.setDescription('The number of frames received from the link interface by Framer.')
mscFrMuxFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerOctetFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrMuxFramerOctetFromIf.setDescription('The number of bytes received from the link interface by Framer.')
mscFrMuxFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerAborts.setDescription('This attribute is the total number of aborts received.')
mscFrMuxFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerCrcErrors.setDescription('This attribute is the total number of frames with CRC errors, occurring in the receive direction from the link.')
mscFrMuxFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerLrcErrors.setDescription('This attribute is the total number of frames with LRC errors, occurring in the Tx link prior to transmission onto the link.')
mscFrMuxFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerNonOctetErrors.setDescription('This attribute is the total number of frames that were non octet aligned.')
mscFrMuxFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerOverruns.setDescription('This attribute is the total number of frames received from the link for which overruns occurred.')
mscFrMuxFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerUnderruns.setDescription('This attribute is the total number of frames transmitted to the link for which underruns occurred.')
mscFrMuxFramerLargeFrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerLargeFrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerLargeFrmErrors.setDescription('This attribute is the total number of frames received which were too large. The frame execeeded the maximumFrameLengthLimit provisioned attribute or it contained more than the 255 block hardware limit.')
mscFrMuxFramerFrmModeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerFrmModeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerFrmModeErrors.setDescription('This attribute is the total number of frames detected with framing mode errors. A framingModeError is flagged when frames are inconsistent with the specified framingType, that is when interrupting frames are used while running in hdlc mode.')
mscFrMuxFramerFrmToIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerFrmToIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerFrmToIf64.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscFrMuxFramerFrmFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerFrmFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerFrmFromIf64.setDescription('The number of frames received from the link interface by Framer.')
mscFrMuxFramerOctetFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 13, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerOctetFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerOctetFromIf64.setDescription('The number of bytes received from the link interface by Framer.')
mscFrMuxFramerUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 14), )
if mibBuilder.loadTexts: mscFrMuxFramerUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerUtilTable.setDescription('This group contains the link utilizaiton operational data for a Framer component.')
mscFrMuxFramerUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxFramerIndex"))
if mibBuilder.loadTexts: mscFrMuxFramerUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerUtilEntry.setDescription('An entry in the mscFrMuxFramerUtilTable.')
mscFrMuxFramerNormPrioLinkUtilToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 14, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerNormPrioLinkUtilToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerNormPrioLinkUtilToIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) sent to the link as a percentage of the available bandwidth on the link. Note that this indluces traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscFrMuxFramerNormPrioLinkUtilFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 2, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxFramerNormPrioLinkUtilFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxFramerNormPrioLinkUtilFromIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) received from the link as a percentage of the available bandwidth on the link. Note that this includes traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscFrMuxLmi = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3))
mscFrMuxLmiRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 1), )
if mibBuilder.loadTexts: mscFrMuxLmiRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrMuxLmi components.')
mscFrMuxLmiRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxLmiIndex"))
if mibBuilder.loadTexts: mscFrMuxLmiRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiRowStatusEntry.setDescription('A single entry in the table represents a single mscFrMuxLmi component.')
mscFrMuxLmiRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrMuxLmi components. These components cannot be added nor deleted.')
mscFrMuxLmiComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrMuxLmiStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiStorageType.setDescription('This variable represents the storage type value for the mscFrMuxLmi tables.')
mscFrMuxLmiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrMuxLmiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiIndex.setDescription('This variable represents the index for the mscFrMuxLmi tables.')
mscFrMuxLmiProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 10), )
if mibBuilder.loadTexts: mscFrMuxLmiProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiProvTable.setDescription('This group contains the provisionable attributes of the Local Management Interface component of the FrMux. The Local Management Interface of the FrMux is always User Side Procedure of the User Network Interface (USP-UNI).')
mscFrMuxLmiProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxLmiIndex"))
if mibBuilder.loadTexts: mscFrMuxLmiProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiProvEntry.setDescription('An entry in the mscFrMuxLmiProvTable.')
mscFrMuxLmiProcedures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("vendorForum", 1), ("ansi", 2), ("ccitt", 3))).clone('ccitt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxLmiProcedures.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiProcedures.setDescription('This attribute selects the procedures to be used for the Local Management Interface. The following are the supported procedures: none : No Local Management Interface procedure is active. vendorForum : Local Management Interface procedure according to the Vendor Forum specification is active. DLCI 1023 is used for the LMI protocol. ansi: Local Management Interface procedure according to the ANSI specification is active. DLCI 0 is used for the LMI protocol. ccitt: Local Management Interface procedure according to the CCITT specification is active. DLCI 0 is used for the LMI protocol.')
mscFrMuxLmiLinkVerificationTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(15, 15), ValueRangeConstraint(20, 20), ValueRangeConstraint(25, 25), ValueRangeConstraint(30, 30), )).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxLmiLinkVerificationTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiLinkVerificationTimer.setDescription('This attribute specifies the time interval (in seconds) at which the FrMux sends Status Enquiry messages to the interface. Exchange of Status Enquiry and Status Report messages constitutes a polling cycle, so this attribute may also be interpreted as time interval at which the FrMux initiates polling cycles. It must be less than checkPointTimer (t392) configured at the other end of the Frame Relay interface. This attribute corresponds to t391 of the ANSI and CCITT specifications, and nT1 of the Vendor Forum specification.')
mscFrMuxLmiFullStatusPollingCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxLmiFullStatusPollingCycles.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiFullStatusPollingCycles.setDescription('This attribute specifies every which polling cycle the FrMux sends a full STATUS ENQUIRY to the interface. Every fullStatusPollingCycles polling cycles the FrMux sends a full STATUS ENQUIRY. In all other cycles of a sequence of fullStatusPollingCycles polling cycles the FrMux sends a keep alive STATUS ENQUIRY. This attribute corresponds to n391 of the ANSI and CCITT specifications and nN1 of the Vendor Forum specification.')
mscFrMuxLmiErrorEventThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxLmiErrorEventThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiErrorEventThreshold.setDescription('This attribute specifies the number of error events which, if they occur within eventCount events, will cause a protocol error condition (protocolStatus = errorCondition). The error condition is cleared after eventCount sequential correct events occur (protocolStatus = normalCondition). An event is one of the following: (1) expiry of the linkVerificationTimer (t391), (2) reception of a STATUS message. An error event is one of the following: (1)non-receipt of the STATUS message in t391 seconds, (2)invalid STATUS message, (3) invalid sequence number. This attribute corresponds to n392 of the ANSI and CCITT specifications and nN2 of the Vendor Forum Specification. This attribute must be less than or equal to eventCount.')
mscFrMuxLmiEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxLmiEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiEventCount.setDescription('This attribute specifies the number of contiguous events within which no more than eventErrorThreshold error events are allowed. This attribute corresponds to n392 of the ANSI and CCITT specifications and nN3 of the Vendor Forum Specification. This attribute must be greater than or equal to errorEventThreshold.')
mscFrMuxLmiStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 11), )
if mibBuilder.loadTexts: mscFrMuxLmiStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrMuxLmiStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxLmiIndex"))
if mibBuilder.loadTexts: mscFrMuxLmiStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiStateEntry.setDescription('An entry in the mscFrMuxLmiStateTable.')
mscFrMuxLmiAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrMuxLmiOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrMuxLmiUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrMuxLmiPsiTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 12), )
if mibBuilder.loadTexts: mscFrMuxLmiPsiTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiPsiTable.setDescription('This group provides the protocol status of the Local Management Interface of this FrMux.')
mscFrMuxLmiPsiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxLmiIndex"))
if mibBuilder.loadTexts: mscFrMuxLmiPsiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiPsiEntry.setDescription('An entry in the mscFrMuxLmiPsiTable.')
mscFrMuxLmiProtocolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("errorCondition", 0), ("normalCondition", 1))).clone('normalCondition')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiProtocolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiProtocolStatus.setDescription("This attribute indicates whether the Lmi is in an error condition or whether the protocol is behaving normally. When operating with no LMI protocol (procedures = none), this attribute will always be set to normalCondition. When operating with an LMI protocol (procedures set to one of venforForum, ansi, ccitt), this attribute is set to errorCondition when errorEventThreshold of the last eventCount events are in error. The error condition is cleared when eventCount consecutive good events take place. The consequence of an error condition is that all Dlci's on this interface become disabled and there is no data flow in either direction.")
mscFrMuxLmiStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13), )
if mibBuilder.loadTexts: mscFrMuxLmiStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiStatsTable.setDescription('This group contains the operational statistics for the FrMux Local Management Interface.')
mscFrMuxLmiStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxLmiIndex"))
if mibBuilder.loadTexts: mscFrMuxLmiStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiStatsEntry.setDescription('An entry in the mscFrMuxLmiStatsTable.')
mscFrMuxLmiKeepAliveStatusEnqToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiKeepAliveStatusEnqToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiKeepAliveStatusEnqToIf.setDescription('This attribute counts the number of keep alive STATUS ENQUIRY messages sent to the interface. When the maximum count is reached it wraps to zero.')
mscFrMuxLmiFullStatusEnqToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiFullStatusEnqToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiFullStatusEnqToIf.setDescription('This attribute counts the number of full STATUS ENQUIRY messages sent to the interface. When the maximum count is reached it wraps to zero.')
mscFrMuxLmiProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiProtocolErrors.setDescription('This attribute counts the number of Local Management Interface protocol errors. Protocol errors include (1) protocol message format errors, (2) protocol timer expiry errors, and (3) sequence errors. When the maximum count is reached it wraps to zero.')
mscFrMuxLmiUnexpectedIes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiUnexpectedIes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiUnexpectedIes.setDescription('This attribute counts the number of frames received with an Information Element identifier that is unknown or unexpected. When the maximum count is reached, this counter wraps to zero.')
mscFrMuxLmiSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiSequenceErrors.setDescription('This attribute counts the number of Local Management Interface sequence errors. A sequence error is receipt of an LMI message with a receive sequence number not equal to the last send sequence number. When the maximum count is reached the counter wraps to zero.')
mscFrMuxLmiUnexpectedReports = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiUnexpectedReports.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiUnexpectedReports.setDescription('This attribute counts the number of frames received on the Local Management Interface with an unknown or unexpected report type. When the maximum count is reached the counter wraps to zero.')
mscFrMuxLmiNoStatusReportCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 3, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxLmiNoStatusReportCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxLmiNoStatusReportCount.setDescription('This attribute counts the number of times when no status report or an invalid status report comes from the external network. This attribute is incremented in two cases: i) after a status enquiry is sent out and t391 timer expires without having a status report received. ii) an invalid status report is received. When the maximum count is reached it wraps to zero.')
mscFrMuxDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4))
mscFrMuxDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 1), )
if mibBuilder.loadTexts: mscFrMuxDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrMuxDlci components.')
mscFrMuxDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciIndex"))
if mibBuilder.loadTexts: mscFrMuxDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciRowStatusEntry.setDescription('A single entry in the table represents a single mscFrMuxDlci component.')
mscFrMuxDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrMuxDlci components. These components can be added and deleted.')
mscFrMuxDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrMuxDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciStorageType.setDescription('This variable represents the storage type value for the mscFrMuxDlci tables.')
mscFrMuxDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1007)))
if mibBuilder.loadTexts: mscFrMuxDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciIndex.setDescription('This variable represents the index for the mscFrMuxDlci tables.')
mscFrMuxDlciOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 10), )
if mibBuilder.loadTexts: mscFrMuxDlciOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciOperTable.setDescription('This group contains the name of the application associated with this Dlci.')
mscFrMuxDlciOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciIndex"))
if mibBuilder.loadTexts: mscFrMuxDlciOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciOperEntry.setDescription('An entry in the mscFrMuxDlciOperTable.')
mscFrMuxDlciApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplicationName.setDescription('This attribute contains the name of the application associated with this Dlci.')
mscFrMuxDlciStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 11), )
if mibBuilder.loadTexts: mscFrMuxDlciStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrMuxDlciStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciIndex"))
if mibBuilder.loadTexts: mscFrMuxDlciStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciStateEntry.setDescription('An entry in the mscFrMuxDlciStateTable.')
mscFrMuxDlciAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrMuxDlciOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrMuxDlciUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrMuxDlciAbitTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 12), )
if mibBuilder.loadTexts: mscFrMuxDlciAbitTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciAbitTable.setDescription('This group contains the A-Bit status information for this Dlci.')
mscFrMuxDlciAbitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciIndex"))
if mibBuilder.loadTexts: mscFrMuxDlciAbitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciAbitEntry.setDescription('An entry in the mscFrMuxDlciAbitTable.')
mscFrMuxDlciABitStatusFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciABitStatusFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciABitStatusFromIf.setDescription('This attribute is the most recent A-Bit status received from the interface.')
mscFrMuxDlciStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13), )
if mibBuilder.loadTexts: mscFrMuxDlciStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciStatsTable.setDescription('This group contains the operational statistics for the FrMux Dlci.')
mscFrMuxDlciStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciIndex"))
if mibBuilder.loadTexts: mscFrMuxDlciStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciStatsEntry.setDescription('An entry in the mscFrMuxDlciStatsTable.')
mscFrMuxDlciFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciFrmToIf.setDescription('This attribute counts the frames sent to the interface. When the maximum count is reached the count wraps to zero.')
mscFrMuxDlciBytesToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciBytesToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciBytesToIf.setDescription('This attribute counts the bytes sent to the interface. When the maximum count is reached the count wraps to zero.')
mscFrMuxDlciFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciFrmFromIf.setDescription('This attribute counts the frames received from the interface. Frames that are discarded are not included in this count. When the maximum count is reached the count wraps to zero.')
mscFrMuxDlciDeFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciDeFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciDeFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscFrMuxDlciBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciBytesFromIf.setDescription('This attribute counts the bytes received from the interface. Frames that are discarded are not included in this count. When the maximum count is reached the count wraps to zero.')
mscFrMuxDlciDeBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciDeBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciDeBytesFromIf.setDescription('This attribute counts the bytes received from the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscFrMuxDlciFecnFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciFecnFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciFecnFrmToIf.setDescription('This attribute counts the frames sent to the interface with the Forward Explicit Congestion Notification (FECN) bit set. When the count reaches maximum it wraps to zero.')
mscFrMuxDlciFecnFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciFecnFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciFecnFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Forward Explicit Congestion Notification (FECN) bit set. When the count reaches maximum it wraps to zero.')
mscFrMuxDlciBecnFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciBecnFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciBecnFrmToIf.setDescription('This attribute counts the frames sent to the interface with the Backward Explicit Congestion Notification (BECN) bit set. When the count reaches maximum it wraps to zero.')
mscFrMuxDlciBecnFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciBecnFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciBecnFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Backward Explicit Congestion Notification (BECN) bit set. When the count reaches maximum it wraps to zero.')
mscFrMuxDlciDiscCongestedFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciDiscCongestedFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciDiscCongestedFromIf.setDescription('This attribute counts the number of frames discarded in the receive direction due to local congestion. When this count reaches maximum, it wraps to zero.')
mscFrMuxDlciDiscCongestedFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciDiscCongestedFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciDiscCongestedFromIfBytes.setDescription('This attribute counts the number of bytes discarded in the receive direction due to local congestion. When this count reaches maximum, it wraps to zero.')
mscFrMuxDlciDiscDeCongestedFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciDiscDeCongestedFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciDiscDeCongestedFromIf.setDescription('This attribute counts the number of discard eligible (DE=1) frames discarded in the receive direction due to local congestion. When this count reaches maximum, it wraps to zero.')
mscFrMuxDlciDiscDeCongestedFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciDiscDeCongestedFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciDiscDeCongestedFromIfBytes.setDescription('This attribute counts the number of bytes of discard eligible (DE=1) traffic discarded in the receive direction due to local congestion. When the maximum count is reached the count wraps to zero.')
mscFrMuxDlciErrorShortFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciErrorShortFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciErrorShortFrmFromIf.setDescription('This attribute counts the frames received with 0 octets in the information field. When the count reaches maximum it wraps to zero.')
mscFrMuxDlciErrorLongFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 13, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciErrorLongFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciErrorLongFrmFromIf.setDescription('This attribute counts the frames received with number of octets in the information field greater than the maximum frame size provisioned in the component pointed to by the applicationName. When the count reaches maximum it wraps to zero. Frames whose lengths are greater than the hardware receive buffer are discarded by the Framer and are therefore not included in this count.')
mscFrMuxDlciApplInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2))
mscFrMuxDlciApplInfoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 1), )
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrMuxDlciApplInfo components.')
mscFrMuxDlciApplInfoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciApplInfoIndex"))
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoRowStatusEntry.setDescription('A single entry in the table represents a single mscFrMuxDlciApplInfo component.')
mscFrMuxDlciApplInfoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrMuxDlciApplInfo components. These components cannot be added nor deleted.')
mscFrMuxDlciApplInfoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrMuxDlciApplInfoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoStorageType.setDescription('This variable represents the storage type value for the mscFrMuxDlciApplInfo tables.')
mscFrMuxDlciApplInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoIndex.setDescription('This variable represents the index for the mscFrMuxDlciApplInfo tables.')
mscFrMuxDlciApplInfoProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 11), )
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoProvTable.setDescription('This group contains provisionable attributes of this Dlci.')
mscFrMuxDlciApplInfoProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", "mscFrMuxDlciApplInfoIndex"))
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoProvEntry.setDescription('An entry in the mscFrMuxDlciApplInfoProvTable.')
mscFrMuxDlciApplInfoApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 112, 4, 2, 11, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrMuxDlciApplInfoApplicationName.setDescription('This attribute is the link to the application associated with this Dlci.')
frameRelayMuxGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38, 1))
frameRelayMuxGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38, 1, 1))
frameRelayMuxGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38, 1, 1, 3))
frameRelayMuxGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38, 1, 1, 3, 2))
frameRelayMuxCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38, 3))
frameRelayMuxCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38, 3, 1))
frameRelayMuxCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38, 3, 1, 3))
frameRelayMuxCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 38, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayMuxMIB", mscFrMuxFramerOctetFromIf64=mscFrMuxFramerOctetFromIf64, mscFrMuxOperationalState=mscFrMuxOperationalState, mscFrMuxDlciApplInfoRowStatus=mscFrMuxDlciApplInfoRowStatus, mscFrMuxControlStatus=mscFrMuxControlStatus, mscFrMuxLmiEventCount=mscFrMuxLmiEventCount, mscFrMuxLmiAdminState=mscFrMuxLmiAdminState, mscFrMuxFramerUtilEntry=mscFrMuxFramerUtilEntry, mscFrMuxRowStatus=mscFrMuxRowStatus, mscFrMuxLmiComponentName=mscFrMuxLmiComponentName, mscFrMuxInvalidHeaderFramesFromIf=mscFrMuxInvalidHeaderFramesFromIf, mscFrMuxLmiUnexpectedReports=mscFrMuxLmiUnexpectedReports, mscFrMuxIfEntryEntry=mscFrMuxIfEntryEntry, mscFrMuxDlciStateEntry=mscFrMuxDlciStateEntry, mscFrMuxUsageState=mscFrMuxUsageState, frameRelayMuxCapabilitiesCA=frameRelayMuxCapabilitiesCA, mscFrMuxRowStatusEntry=mscFrMuxRowStatusEntry, mscFrMuxCidDataTable=mscFrMuxCidDataTable, mscFrMuxDlciApplInfoProvEntry=mscFrMuxDlciApplInfoProvEntry, mscFrMuxFramerStateEntry=mscFrMuxFramerStateEntry, frameRelayMuxCapabilitiesCA02=frameRelayMuxCapabilitiesCA02, mscFrMuxLastUnknownDlci=mscFrMuxLastUnknownDlci, mscFrMuxDlciStorageType=mscFrMuxDlciStorageType, mscFrMuxFramerStatsEntry=mscFrMuxFramerStatsEntry, mscFrMuxLmiErrorEventThreshold=mscFrMuxLmiErrorEventThreshold, mscFrMuxDlciDeFrmFromIf=mscFrMuxDlciDeFrmFromIf, mscFrMuxLmiProvTable=mscFrMuxLmiProvTable, mscFrMuxDlciApplInfoStorageType=mscFrMuxDlciApplInfoStorageType, mscFrMuxFramerLrcErrors=mscFrMuxFramerLrcErrors, mscFrMuxLmiOperationalState=mscFrMuxLmiOperationalState, mscFrMuxLmiStateEntry=mscFrMuxLmiStateEntry, mscFrMuxFramerUsageState=mscFrMuxFramerUsageState, mscFrMuxLmiPsiTable=mscFrMuxLmiPsiTable, mscFrMuxFramerRowStatus=mscFrMuxFramerRowStatus, mscFrMuxDlciOperEntry=mscFrMuxDlciOperEntry, mscFrMuxLmiSequenceErrors=mscFrMuxLmiSequenceErrors, mscFrMuxFramerAborts=mscFrMuxFramerAborts, mscFrMuxFramerUnderruns=mscFrMuxFramerUnderruns, mscFrMuxDlciApplInfoProvTable=mscFrMuxDlciApplInfoProvTable, mscFrMuxAvailabilityStatus=mscFrMuxAvailabilityStatus, mscFrMuxLmiRowStatusTable=mscFrMuxLmiRowStatusTable, mscFrMuxDlciFrmToIf=mscFrMuxDlciFrmToIf, mscFrMuxLmiStatsEntry=mscFrMuxLmiStatsEntry, mscFrMuxLmi=mscFrMuxLmi, mscFrMuxDlciApplInfo=mscFrMuxDlciApplInfo, mscFrMuxLmiRowStatusEntry=mscFrMuxLmiRowStatusEntry, mscFrMuxComponentName=mscFrMuxComponentName, mscFrMuxDlciErrorLongFrmFromIf=mscFrMuxDlciErrorLongFrmFromIf, mscFrMuxDlciComponentName=mscFrMuxDlciComponentName, frameRelayMuxGroupCA02=frameRelayMuxGroupCA02, mscFrMuxFramerFrmFromIf=mscFrMuxFramerFrmFromIf, mscFrMuxLmiFullStatusPollingCycles=mscFrMuxLmiFullStatusPollingCycles, mscFrMuxFramer=mscFrMuxFramer, mscFrMuxLmiStatsTable=mscFrMuxLmiStatsTable, mscFrMuxDlciApplInfoIndex=mscFrMuxDlciApplInfoIndex, mscFrMuxOperStatusTable=mscFrMuxOperStatusTable, mscFrMuxStateEntry=mscFrMuxStateEntry, mscFrMuxDlciIndex=mscFrMuxDlciIndex, frameRelayMuxCapabilities=frameRelayMuxCapabilities, mscFrMuxDlciFrmFromIf=mscFrMuxDlciFrmFromIf, mscFrMuxLmiUsageState=mscFrMuxLmiUsageState, mscFrMuxDlciApplInfoApplicationName=mscFrMuxDlciApplInfoApplicationName, mscFrMuxLmiProtocolErrors=mscFrMuxLmiProtocolErrors, mscFrMuxStorageType=mscFrMuxStorageType, mscFrMuxFramerInterfaceName=mscFrMuxFramerInterfaceName, mscFrMuxLmiNoStatusReportCount=mscFrMuxLmiNoStatusReportCount, mscFrMuxDlciRowStatusEntry=mscFrMuxDlciRowStatusEntry, mscFrMuxFramerFrmModeErrors=mscFrMuxFramerFrmModeErrors, mscFrMuxDlciBecnFrmFromIf=mscFrMuxDlciBecnFrmFromIf, mscFrMuxIfAdminStatus=mscFrMuxIfAdminStatus, mscFrMuxFramerDataInversion=mscFrMuxFramerDataInversion, mscFrMuxDlciBecnFrmToIf=mscFrMuxDlciBecnFrmToIf, mscFrMuxSnmpOperStatus=mscFrMuxSnmpOperStatus, mscFrMuxLmiProvEntry=mscFrMuxLmiProvEntry, mscFrMuxDlciAbitEntry=mscFrMuxDlciAbitEntry, mscFrMuxFramerOctetFromIf=mscFrMuxFramerOctetFromIf, mscFrMuxAlarmStatus=mscFrMuxAlarmStatus, frameRelayMuxGroup=frameRelayMuxGroup, mscFrMuxFramerRowStatusTable=mscFrMuxFramerRowStatusTable, mscFrMuxDlciDiscDeCongestedFromIf=mscFrMuxDlciDiscDeCongestedFromIf, mscFrMuxFramerOperationalState=mscFrMuxFramerOperationalState, mscFrMuxDlciDeBytesFromIf=mscFrMuxDlciDeBytesFromIf, mscFrMuxLmiFullStatusEnqToIf=mscFrMuxLmiFullStatusEnqToIf, mscFrMuxFramerIndex=mscFrMuxFramerIndex, mscFrMuxLmiPsiEntry=mscFrMuxLmiPsiEntry, mscFrMuxDlciFecnFrmFromIf=mscFrMuxDlciFecnFrmFromIf, mscFrMuxDlciUsageState=mscFrMuxDlciUsageState, mscFrMuxFramerNormPrioLinkUtilFromIf=mscFrMuxFramerNormPrioLinkUtilFromIf, mscFrMuxLmiStorageType=mscFrMuxLmiStorageType, frameRelayMuxGroupCA=frameRelayMuxGroupCA, mscFrMuxOperStatusEntry=mscFrMuxOperStatusEntry, mscFrMuxDlciStateTable=mscFrMuxDlciStateTable, mscFrMuxDlciDiscDeCongestedFromIfBytes=mscFrMuxDlciDiscDeCongestedFromIfBytes, mscFrMuxDlciStatsTable=mscFrMuxDlciStatsTable, mscFrMuxDlciBytesToIf=mscFrMuxDlciBytesToIf, mscFrMuxDlciApplInfoRowStatusEntry=mscFrMuxDlciApplInfoRowStatusEntry, mscFrMuxDlciAbitTable=mscFrMuxDlciAbitTable, mscFrMuxIfIndex=mscFrMuxIfIndex, mscFrMuxFramerUtilTable=mscFrMuxFramerUtilTable, mscFrMuxFramerFrmFromIf64=mscFrMuxFramerFrmFromIf64, mscFrMuxFramerFrmToIf64=mscFrMuxFramerFrmToIf64, mscFrMuxFramerNormPrioLinkUtilToIf=mscFrMuxFramerNormPrioLinkUtilToIf, mscFrMuxDlciErrorShortFrmFromIf=mscFrMuxDlciErrorShortFrmFromIf, mscFrMuxDlciOperationalState=mscFrMuxDlciOperationalState, mscFrMuxFramerAdminState=mscFrMuxFramerAdminState, mscFrMuxDlciApplInfoComponentName=mscFrMuxDlciApplInfoComponentName, mscFrMuxFramerProvTable=mscFrMuxFramerProvTable, mscFrMuxCustomerIdentifier=mscFrMuxCustomerIdentifier, mscFrMuxFramerRowStatusEntry=mscFrMuxFramerRowStatusEntry, mscFrMuxLmiProcedures=mscFrMuxLmiProcedures, mscFrMuxFramerLinkEntry=mscFrMuxFramerLinkEntry, mscFrMuxStatsEntry=mscFrMuxStatsEntry, mscFrMuxDlciABitStatusFromIf=mscFrMuxDlciABitStatusFromIf, mscFrMuxLmiIndex=mscFrMuxLmiIndex, mscFrMuxDlciBytesFromIf=mscFrMuxDlciBytesFromIf, mscFrMuxCidDataEntry=mscFrMuxCidDataEntry, mscFrMuxFramerLinkTable=mscFrMuxFramerLinkTable, mscFrMuxDlciApplInfoRowStatusTable=mscFrMuxDlciApplInfoRowStatusTable, mscFrMuxDlciFecnFrmToIf=mscFrMuxDlciFecnFrmToIf, mscFrMuxFramerFrmToIf=mscFrMuxFramerFrmToIf, mscFrMuxFramerStateTable=mscFrMuxFramerStateTable, frameRelayMuxGroupCA02A=frameRelayMuxGroupCA02A, mscFrMuxFramerFlagsBetweenFrames=mscFrMuxFramerFlagsBetweenFrames, mscFrMuxDlciApplicationName=mscFrMuxDlciApplicationName, mscFrMuxStatsTable=mscFrMuxStatsTable, mscFrMuxDlciRowStatus=mscFrMuxDlciRowStatus, mscFrMuxFramerProvEntry=mscFrMuxFramerProvEntry, mscFrMuxAdminState=mscFrMuxAdminState, mscFrMuxStateTable=mscFrMuxStateTable, mscFrMuxTimeFramerCongested=mscFrMuxTimeFramerCongested, mscFrMuxFramerCrcErrors=mscFrMuxFramerCrcErrors, mscFrMuxFramerComponentName=mscFrMuxFramerComponentName, mscFrMuxIndex=mscFrMuxIndex, mscFrMuxFramerFrameCrcType=mscFrMuxFramerFrameCrcType, mscFrMuxDlciAdminState=mscFrMuxDlciAdminState, mscFrMuxLmiKeepAliveStatusEnqToIf=mscFrMuxLmiKeepAliveStatusEnqToIf, mscFrMuxLmiStateTable=mscFrMuxLmiStateTable, mscFrMuxDlciDiscCongestedFromIf=mscFrMuxDlciDiscCongestedFromIf, mscFrMuxRowStatusTable=mscFrMuxRowStatusTable, mscFrMuxStandbyStatus=mscFrMuxStandbyStatus, mscFrMuxIfEntryTable=mscFrMuxIfEntryTable, mscFrMuxDlciRowStatusTable=mscFrMuxDlciRowStatusTable, mscFrMuxFramerNonOctetErrors=mscFrMuxFramerNonOctetErrors, mscFrMuxLmiRowStatus=mscFrMuxLmiRowStatus, frameRelayMuxCapabilitiesCA02A=frameRelayMuxCapabilitiesCA02A, mscFrMuxLmiUnexpectedIes=mscFrMuxLmiUnexpectedIes, frameRelayMuxMIB=frameRelayMuxMIB, mscFrMuxDlciOperTable=mscFrMuxDlciOperTable, mscFrMuxDlciStatsEntry=mscFrMuxDlciStatsEntry, mscFrMuxFramerOverruns=mscFrMuxFramerOverruns, mscFrMuxDlci=mscFrMuxDlci, mscFrMuxUnknownStatus=mscFrMuxUnknownStatus, mscFrMuxDlciDiscCongestedFromIfBytes=mscFrMuxDlciDiscCongestedFromIfBytes, mscFrMuxFramerLargeFrmErrors=mscFrMuxFramerLargeFrmErrors, mscFrMuxFramerStatsTable=mscFrMuxFramerStatsTable, mscFrMuxUnknownDlciFramesFromIf=mscFrMuxUnknownDlciFramesFromIf, mscFrMuxLmiLinkVerificationTimer=mscFrMuxLmiLinkVerificationTimer, mscFrMuxProceduralStatus=mscFrMuxProceduralStatus, mscFrMuxLmiProtocolStatus=mscFrMuxLmiProtocolStatus, mscFrMux=mscFrMux, mscFrMuxFramerStorageType=mscFrMuxFramerStorageType)

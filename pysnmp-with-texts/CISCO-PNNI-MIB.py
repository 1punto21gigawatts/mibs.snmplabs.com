#
# PySNMP MIB module CISCO-PNNI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-PNNI-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:09:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
pnniIfEntry, pnniNodeEntry, pnniRouteAddrEntry = mibBuilder.importSymbols("PNNI-MIB", "pnniIfEntry", "pnniNodeEntry", "pnniRouteAddrEntry")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
iso, MibIdentifier, Counter64, NotificationType, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Bits, Counter32, Gauge32, IpAddress, Unsigned32, TimeTicks, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "MibIdentifier", "Counter64", "NotificationType", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Bits", "Counter32", "Gauge32", "IpAddress", "Unsigned32", "TimeTicks", "ObjectIdentity")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
ciscoPnniMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 65))
ciscoPnniMIB.setRevisions(('1996-10-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoPnniMIB.setRevisionsDescriptions(('Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoPnniMIB.setLastUpdated('9610280000Z')
if mibBuilder.loadTexts: ciscoPnniMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoPnniMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-atm@cisco.com')
if mibBuilder.loadTexts: ciscoPnniMIB.setDescription('The MIB module for managing Cisco specific extensions to the ATM Forum PNNI MIB.')
ciscoPnniMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 1))
class E164Address(TextualConvention, OctetString):
    description = 'A native E.164 address, encoded in BCD format. An address of length zero indicates that no address is specified.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), )
ciscoPnniBase = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 1))
ciscoPnniBackgroundRoutes = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniBackgroundRoutes.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniBackgroundRoutes.setDescription("Specifies whether background route computation is enabled on this switching system. In this mode, multiple background trees are precomputed for several service categories and QoS metrics. If no route is found in the background trees that satisfies the QoS requirements of a particular setup request, route selection reverts to on-demand computation. When the value of this object is `false', only on-demand route computation is used (i.e., a separate route computation is performed for each SETUP or ADD PARTY message received over a UNI or IISP interface, or for which this node is a PNNI entry border node). It is recommended that background route computation be enabled in large networks, due to better scalability in terms of processing requirements.")
ciscoPnniBackgroundPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniBackgroundPollInterval.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniBackgroundPollInterval.setDescription('Specifies how often the switching system polls for a significant change that triggers new computation of the background routes. Increasing the value of this object causes the switching system to throttle background route computation.')
ciscoPnniBackgroundInsignificantThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(32)).setUnits('changes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniBackgroundInsignificantThreshold.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniBackgroundInsignificantThreshold.setDescription('Specifies the number of insignificant changes necessary to trigger a new computation of the background routes.')
ciscoPnniResourceMgmtPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(5)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniResourceMgmtPollInterval.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniResourceMgmtPollInterval.setDescription('Specifies how often PNNI polls resource management to update the values of local interface metrics and attributes. The value of this object impacts the number of new instances of PTSEs originated by this switching system. A larger interval reduces the number of new instances of PTSEs caused by interface traffic fluctuation. A smaller interval allows PNNI to track traffic fluctuations more quickly, at the expense of increased processing load. In normal situations, this object should not be changed from its default value. Care should be taken when adjusting this parameter so as not to overload switch processing.')
ciscoPnniAdminWeightMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uniform", 1), ("linespeed", 2))).clone('uniform')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniAdminWeightMode.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniAdminWeightMode.setDescription("Specifies the mode of default administrative weight assignment for PNNI interfaces. When this value is set to `uniform', by default the administrative weight of each PNNI interface is set to 5040, as defined in the ATM Forum PNNI 1.0 Specification. When this value is set to `linespeed', by default the administrative weight is set based on the linespeed or maximum cell rate of the interface. In the absence of other constraints, the `uniform' mode causes PNNI routing to minimize the number of hops. Basing administrative weight on linespeed allows path selection to prefer paths along higher bandwidth interfaces.")
ciscoPnniMaxAdminWeightPercentage = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(100, 2000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniMaxAdminWeightPercentage.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniMaxAdminWeightPercentage.setDescription('Specifies the maximum acceptable administrative weight for alternate routes as a percentage factor of the least administrative weight of any route to the destination. The constraint on administrative weight only takes effect when background route computation is enabled. The constraint on administrative weight increases network efficiency under heavy loads by preventing alternate routes that use too many network resources from being specified. This constraint provides a generalized form of a hop count limit. The distinguished value zero indicates that there is no constraint on administrative weight for alternate routes. All other valid values are greater than or equal to 100 percent.')
ciscoPnniRouteOptimizationThreshold = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 100)).clone(30)).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniRouteOptimizationThreshold.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniRouteOptimizationThreshold.setDescription('Specifies the percentage reduction in the administrative weight of the existing path required to trigger route optimization. When route optimization is enabled and the threshold is exceeded, the existing path is partially torn down and a new path is established.')
ciscoPnniNode = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 2))
ciscoPnniNodeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 2, 1), )
if mibBuilder.loadTexts: ciscoPnniNodeTable.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniNodeTable.setDescription('A table of cisco specific attributes that affect the operation of a PNNI logical node.')
ciscoPnniNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 2, 1, 1), )
pnniNodeEntry.registerAugmentions(("CISCO-PNNI-MIB", "ciscoPnniNodeEntry"))
ciscoPnniNodeEntry.setIndexNames(*pnniNodeEntry.getIndexNames())
if mibBuilder.loadTexts: ciscoPnniNodeEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniNodeEntry.setDescription('An entry in the table, containing cisco specific information about a node in this switching system.')
ciscoPnniNodeAutoSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 2, 1, 1, 1), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoPnniNodeAutoSummary.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniNodeAutoSummary.setDescription("Specifies whether automatic generation of internal summary address(es) based on the switch address(es) or node ID is enabled. Automatically generated summary addresses can only be removed by setting this object to `false'. They cannot be removed through the pnniSummaryTable in the ATM Forum PNNI MIB. For lowest-level nodes with auto-summary enabled, each switching system generates one or more 13-byte summary address prefixes based on the switch address(es). Switch addresses are configured in the ciscoAtmSwAddrTable.")
ciscoPnniNodeRedistributeStatic = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 2, 1, 1, 2), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoPnniNodeRedistributeStatic.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniNodeRedistributeStatic.setDescription('Specifies whether redistribution of ATM static routes to the PNNI routing domain is enabled. Exterior static routes are advertised in exterior reachable address PTSEs. Internal static routes are advertised in internal reachable address PTSEs.')
ciscoPnniNodePtseRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(32)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoPnniNodePtseRequest.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniNodePtseRequest.setDescription('Specifies the maximum number of PTSEs that can be requested in one PTSE request packet.')
ciscoPnniNodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 2, 1, 1, 4), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoPnniNodeName.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniNodeName.setDescription("Specifies the textual name of the PNNI node. The node name is distributed to all other nodes via PNNI flooding, using a cisco specific encoding in the System Capabilities information group. This allows all cisco PNNI nodes to use this node name to identify this PNNI node. The default value of the node name is the value of the switching system's host name.")
ciscoPnniNodeScopeMappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoPnniNodeScopeMappingMode.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniNodeScopeMappingMode.setDescription("Specifies the configuration mode of the mapping from organizational scope values (used at UNI interfaces) to PNNI scope (i.e., in terms of PNNI routing level indicators). In `automatic' mode, for each organizational scope value the corresponding PNNI level is the minimum of the ATM Forum PNNI 1.0 default value (see Section 5.3.6 of PNNI 1.0) and the level l of this node: org scope ATM Forum default level auto mode level 1-3 96 min(l,96) 4-5 80 min(l,80) 6-7 72 min(l,72) 8-10 64 min(l,64) 11-12 48 min(l,48) 13-14 32 min(l,32) 15(global) 0 0 Use of the `automatic' mode ensures that all organizational scope values cover an area at least as wide as this node's peer group. When this object is written with the value `automatic', objects in the pnniScopeMappingEntry for this node are overwritten. These objects cannot be modified while this object is set to `automatic'. When this object is written with the value `manual', the objects in the pnniScopeMappingEntry for this node are allowed to be modified.")
ciscoPnniInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3))
ciscoPnniIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1), )
if mibBuilder.loadTexts: ciscoPnniIfTable.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfTable.setDescription("A table of cisco specific attributes used to configure a physical interface or subinterface on a switching system which is capable of being used for PNNI routing. Interfaces may represent physical connection points (i.e. copper/fiber connection points) or VPCs which have been configured for PNNI's use.")
ciscoPnniIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1, 1), )
pnniIfEntry.registerAugmentions(("CISCO-PNNI-MIB", "ciscoPnniIfEntry"))
ciscoPnniIfEntry.setIndexNames(*pnniIfEntry.getIndexNames())
if mibBuilder.loadTexts: ciscoPnniIfEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfEntry.setDescription('An entry in the table, containing cisco specific PNNI information about an interface in this switching system.')
ciscoPnniIfLinkSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("adminWeightMinimize", 1), ("blockingMinimize", 2), ("transmitSpeedMaximize", 3), ("loadBalance", 4))).clone('blockingMinimize')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniIfLinkSelection.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfLinkSelection.setDescription("For CBR or VBR call setups, specifies a method for selecting one link out of multiple links with sufficient resources to the same neighbor node. Link selection applies whenever the port specified in the Designated Transit List (DTL) is zero and there are multiple interfaces to the next node. Valid values are: adminWeightMinimize - transmits call on the interface with the lowest administrative weight, blockingMinimize - Minimizes subsequent call blocking, transmitSpeedMaximize - Transmits call on highest speed parallel link, loadBalance - Balances calls across all parallel links. When multiple parallel links are configured inconsistently, the order of precedence of configured values is `adminWeightMinimize', `blockingMinimize', `transmitSpeedMaximize', and then `loadBalance'; i.e., if any of the links is configured as adminWeightMinimize, that is used for the entire link group. For Best Effort call setups (UBR or ABR), load balancing is always used.")
ciscoPnniIfRouteOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable", 1), ("soft", 2), ("switched", 3), ("switchedAndSoft", 4))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimization.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimization.setDescription("To enable or disable the route optimization (automatic rerouting) feature on an ATM interface. To disable route optimization on the interface, set this object to 'disable'. To enable route optimization only for ATM soft PVCs on the interface, set this object to 'soft'. To enable route optimization only for ATM switched PVCs on the interface, set this object to 'switched'. To enable route optimization for both ATM soft PVCs and SVCs on the interface, set this object to 'switchedAndSoft'.")
ciscoPnniIfRouteOptimInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 10000)).clone(60)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimInterval.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimInterval.setDescription("Specifies how often route optimization takes place on this interface. This object applies only when the object ciscoPnniIfRouteOptimization is NOT set to 'disable'.")
ciscoPnniIfRouteOptimStartHour = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setUnits('hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimStartHour.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimStartHour.setDescription("Specifies the start hour of Time-of-Day route optimization on an ATM interface. This object applies only when the object ciscoPnniIfRouteOptimization is NOT set to 'disable'.")
ciscoPnniIfRouteOptimStartMinute = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimStartMinute.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimStartMinute.setDescription("Specifies the start minute of Time-of-Day route optimization on an ATM interface. This object applies only when the object ciscoPnniIfRouteOptimization is NOT set to 'disable'.")
ciscoPnniIfRouteOptimEndHour = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setUnits('hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimEndHour.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimEndHour.setDescription("Specifies the end hour of Time-Of-Day route optimization on an ATM interface. This object applies only when the object ciscoPnniIfRouteOptimization is NOT set to 'disable'.")
ciscoPnniIfRouteOptimEndMinute = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimEndMinute.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniIfRouteOptimEndMinute.setDescription("Specifies the end minute of Time-Of-Day route optimization on an ATM interface. This object applies only when the object ciscoPnniIfRouteOptimization is NOT set to 'disable'.")
ciscoPnniPrecedence = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 4))
ciscoPnniPrecedenceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 4, 1), )
if mibBuilder.loadTexts: ciscoPnniPrecedenceTable.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniPrecedenceTable.setDescription('A table that specifies the precedence of different types of reachable addresses.')
ciscoPnniPrecedenceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-PNNI-MIB", "ciscoPnniPrecedenceAddressType"))
if mibBuilder.loadTexts: ciscoPnniPrecedenceEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniPrecedenceEntry.setDescription('An entry in the table, containing information about the precedence of a specific reachable address type. One row is created by the managed system for each reachable address type.')
ciscoPnniPrecedenceAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("staticLocalInternalWithMetrics", 1), ("staticLocalExterior", 2), ("staticLocalExteriorWithMetrics", 3), ("pnniRemoteInternal", 4), ("pnniRemoteInternalWithMetrics", 5), ("pnniRemoteExterior", 6), ("pnniRemoteExteriorWithMetrics", 7))))
if mibBuilder.loadTexts: ciscoPnniPrecedenceAddressType.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniPrecedenceAddressType.setDescription('The reachable address type for which the precedence is specified.')
ciscoPnniPrecedenceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciscoPnniPrecedenceValue.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniPrecedenceValue.setDescription('Specifies the precedence of a reachable address type. When there are multiple reachable address types associated with the longest match reachable address prefix, the route selection algorithm first attempts to find routes to reachable address types of greatest precedence. Among routes to the same longest match reachable address prefix with the same reachable address type, routes with the least total administrative weight are preferred. Smaller values take precedence over larger values. Local internal reachable addresses, whether learned through ILMI or as static routes, are given the highest priority (i.e. 1).')
ciscoPnniRouteAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 5))
ciscoPnniRouteAddrTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 5, 1), )
if mibBuilder.loadTexts: ciscoPnniRouteAddrTable.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniRouteAddrTable.setDescription('A table of cisco specific attributes used to configure cisco specific properties of ATM static routes.')
ciscoPnniRouteAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 5, 1, 1), )
pnniRouteAddrEntry.registerAugmentions(("CISCO-PNNI-MIB", "ciscoPnniRouteAddrEntry"))
ciscoPnniRouteAddrEntry.setIndexNames(*pnniRouteAddrEntry.getIndexNames())
if mibBuilder.loadTexts: ciscoPnniRouteAddrEntry.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniRouteAddrEntry.setDescription('An entry in the table, containing cisco specific PNNI information about a reachable address prefix.')
ciscoPnniRouteAddrForwardingE164Address = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 65, 1, 5, 1, 1, 1), E164Address().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciscoPnniRouteAddrForwardingE164Address.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniRouteAddrForwardingE164Address.setDescription("The native E.164 address used as the called party address when the call matching pnniRouteAddrAddress is forwarded across the interface identified by pnniRouteAddrIfIndex. If this address is specified, the received called party address is passed on as the called party subaddress, and the received calling party address (if any) is passed on as the calling party subaddress. The specified address is ignored if the value of pnniRouteAddrProto is `pnni', the value of pnniRouteAddrType is `reject', or the node identified by pnniRouteAddrAdvertisingNodeId is not instantiated in this switching system. If no address is specified, the received called party address and calling party address are passed on unchanged.")
ciscoPnniMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 3))
ciscoPnniMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 3, 1))
ciscoPnniMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 65, 3, 2))
ciscoPnniMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 65, 3, 1, 1)).setObjects(("CISCO-PNNI-MIB", "ciscoPnniBasicGroup"), ("CISCO-PNNI-MIB", "ciscoPnniRouteOptimizationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPnniMIBCompliance = ciscoPnniMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniMIBCompliance.setDescription('The compliance statement for entities which implement the Cisco PNNI MIB.')
ciscoPnniBasicGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 65, 3, 2, 1)).setObjects(("CISCO-PNNI-MIB", "ciscoPnniBackgroundRoutes"), ("CISCO-PNNI-MIB", "ciscoPnniBackgroundPollInterval"), ("CISCO-PNNI-MIB", "ciscoPnniBackgroundInsignificantThreshold"), ("CISCO-PNNI-MIB", "ciscoPnniResourceMgmtPollInterval"), ("CISCO-PNNI-MIB", "ciscoPnniAdminWeightMode"), ("CISCO-PNNI-MIB", "ciscoPnniMaxAdminWeightPercentage"), ("CISCO-PNNI-MIB", "ciscoPnniNodeAutoSummary"), ("CISCO-PNNI-MIB", "ciscoPnniNodeRedistributeStatic"), ("CISCO-PNNI-MIB", "ciscoPnniNodePtseRequest"), ("CISCO-PNNI-MIB", "ciscoPnniNodeName"), ("CISCO-PNNI-MIB", "ciscoPnniNodeScopeMappingMode"), ("CISCO-PNNI-MIB", "ciscoPnniIfLinkSelection"), ("CISCO-PNNI-MIB", "ciscoPnniPrecedenceValue"), ("CISCO-PNNI-MIB", "ciscoPnniRouteAddrForwardingE164Address"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPnniBasicGroup = ciscoPnniBasicGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniBasicGroup.setDescription('A collection of cisco specific MIB objects used for management of PNNI routing.')
ciscoPnniRouteOptimizationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 65, 3, 2, 2)).setObjects(("CISCO-PNNI-MIB", "ciscoPnniRouteOptimizationThreshold"), ("CISCO-PNNI-MIB", "ciscoPnniIfRouteOptimization"), ("CISCO-PNNI-MIB", "ciscoPnniIfRouteOptimInterval"), ("CISCO-PNNI-MIB", "ciscoPnniIfRouteOptimStartHour"), ("CISCO-PNNI-MIB", "ciscoPnniIfRouteOptimStartMinute"), ("CISCO-PNNI-MIB", "ciscoPnniIfRouteOptimEndHour"), ("CISCO-PNNI-MIB", "ciscoPnniIfRouteOptimEndMinute"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoPnniRouteOptimizationGroup = ciscoPnniRouteOptimizationGroup.setStatus('current')
if mibBuilder.loadTexts: ciscoPnniRouteOptimizationGroup.setDescription('A collection of cisco specific MIB objects used for management of route optimization.')
mibBuilder.exportSymbols("CISCO-PNNI-MIB", ciscoPnniPrecedenceAddressType=ciscoPnniPrecedenceAddressType, ciscoPnniRouteAddrEntry=ciscoPnniRouteAddrEntry, PYSNMP_MODULE_ID=ciscoPnniMIB, ciscoPnniAdminWeightMode=ciscoPnniAdminWeightMode, ciscoPnniMaxAdminWeightPercentage=ciscoPnniMaxAdminWeightPercentage, ciscoPnniResourceMgmtPollInterval=ciscoPnniResourceMgmtPollInterval, ciscoPnniIfRouteOptimEndMinute=ciscoPnniIfRouteOptimEndMinute, ciscoPnniBasicGroup=ciscoPnniBasicGroup, ciscoPnniNodeTable=ciscoPnniNodeTable, ciscoPnniBackgroundInsignificantThreshold=ciscoPnniBackgroundInsignificantThreshold, ciscoPnniRouteOptimizationGroup=ciscoPnniRouteOptimizationGroup, ciscoPnniNodeAutoSummary=ciscoPnniNodeAutoSummary, ciscoPnniPrecedence=ciscoPnniPrecedence, ciscoPnniNodeScopeMappingMode=ciscoPnniNodeScopeMappingMode, ciscoPnniNodeEntry=ciscoPnniNodeEntry, ciscoPnniPrecedenceValue=ciscoPnniPrecedenceValue, ciscoPnniRouteAddrTable=ciscoPnniRouteAddrTable, ciscoPnniIfRouteOptimInterval=ciscoPnniIfRouteOptimInterval, ciscoPnniMIBCompliances=ciscoPnniMIBCompliances, ciscoPnniIfRouteOptimEndHour=ciscoPnniIfRouteOptimEndHour, ciscoPnniIfTable=ciscoPnniIfTable, ciscoPnniNodePtseRequest=ciscoPnniNodePtseRequest, ciscoPnniNode=ciscoPnniNode, ciscoPnniRouteOptimizationThreshold=ciscoPnniRouteOptimizationThreshold, ciscoPnniIfRouteOptimStartMinute=ciscoPnniIfRouteOptimStartMinute, ciscoPnniBackgroundPollInterval=ciscoPnniBackgroundPollInterval, ciscoPnniMIBConformance=ciscoPnniMIBConformance, ciscoPnniPrecedenceEntry=ciscoPnniPrecedenceEntry, ciscoPnniInterface=ciscoPnniInterface, ciscoPnniMIB=ciscoPnniMIB, ciscoPnniIfEntry=ciscoPnniIfEntry, ciscoPnniPrecedenceTable=ciscoPnniPrecedenceTable, ciscoPnniMIBGroups=ciscoPnniMIBGroups, ciscoPnniBase=ciscoPnniBase, ciscoPnniIfRouteOptimStartHour=ciscoPnniIfRouteOptimStartHour, ciscoPnniMIBObjects=ciscoPnniMIBObjects, ciscoPnniRouteAddr=ciscoPnniRouteAddr, ciscoPnniNodeRedistributeStatic=ciscoPnniNodeRedistributeStatic, ciscoPnniIfLinkSelection=ciscoPnniIfLinkSelection, ciscoPnniRouteAddrForwardingE164Address=ciscoPnniRouteAddrForwardingE164Address, ciscoPnniMIBCompliance=ciscoPnniMIBCompliance, ciscoPnniBackgroundRoutes=ciscoPnniBackgroundRoutes, ciscoPnniIfRouteOptimization=ciscoPnniIfRouteOptimization, E164Address=E164Address, ciscoPnniNodeName=ciscoPnniNodeName)

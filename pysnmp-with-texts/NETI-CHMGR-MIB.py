#
# PySNMP MIB module NETI-CHMGR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NETI-CHMGR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:19:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint")
netiExperimentalGeneric, = mibBuilder.importSymbols("NETI-COMMON-MIB", "netiExperimentalGeneric")
DtmAddress, = mibBuilder.importSymbols("NETI-DTM-MIB", "DtmAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, Gauge32, Bits, TimeTicks, MibIdentifier, Integer32, Unsigned32, NotificationType, Counter32, ModuleIdentity, ObjectIdentity, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Gauge32", "Bits", "TimeTicks", "MibIdentifier", "Integer32", "Unsigned32", "NotificationType", "Counter32", "ModuleIdentity", "ObjectIdentity", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress")
RowPointer, MacAddress, TextualConvention, DisplayString, RowStatus, TimeStamp, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "MacAddress", "TextualConvention", "DisplayString", "RowStatus", "TimeStamp", "TruthValue")
netiChmgrMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14))
netiChmgrMIB.setRevisions(('2015-01-08 15:00', '2014-05-05 12:00', '2014-02-06 15:00', '2013-09-02 16:00', '2012-03-19 09:00', '2012-01-26 15:00', '2010-04-06 08:00', '2009-09-25 11:00', '2008-12-12 14:00', '2008-01-28 14:00', '2008-01-03 16:00', '2007-06-29 12:00', '2006-09-20 08:00', '2006-04-20 09:00', '2005-09-27 00:00', '2004-11-18 00:00', '2003-04-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: netiChmgrMIB.setRevisionsDescriptions(('Added object for Spare Capacity Utilization, a function that allows a channel to utilize otherwise unused link capacity: chmgrODescrOneHopSpareCapUtilization.', "Updated textual convention Dst with DST for updated JPEG2000 mapping of audio into MXF: `j2kHdSdi2(24)', `j2k3gSdi2(25)', `j2kSdSdi2(26)'.", 'Added objects for describing DCP version: chmgrODescrRequestedDcpVersion, chmgrOConnDcpVersion and chmgrTConnDcpVersion.', '- Added chmgrOConnForceSourceRoute to allow re-establishing a channels using a specified source route. - Removed unnecessary range limit on Unsinged32 when full range is used.', '- Added chmgrODescrAcceptableMbps and chmgrODescrRequestedMbps to allow setting of capacity larger than 4,294,967,295 bits per second. - Removed range limiter on chmgrODescrAcceptableSlots and chmgrODescrRequestedSlots to allow presentation of higher capacity.', "Updated textual convention Dst with DSTs for JPEG 2000: `j2kSdSdi(21)', `j2kHdSdi(22)', and `j2k3gSdi(23)'. ", 'Corrected description of chmgrOChanSourceRouteIndex.', 'Removed range limiter (0..4294967295) for chmgrODescrRequestedBps, chmgrODescrAcceptableBps and chmgrODescrChanSourceRoute. Added chmgrODescrSuppressAlarms.', "Changed label `dlt(1)' to `ets(1)', and `dit(2)' to `its(2)' for enumeration in chmgrODescrType.", 'Added chmgrODescrDestAdminStatus that will allow enabling and disabling of destinations for multicast connections. Added chmgrChanDestDsti and slightly modified chmgrChanDestOutgoingIfPort.', 'Added allowAlternative and allowZeroCapacity to chmgrODescrCapabilities. Added DST for Time Transfer Channel Protocol, and AES/EBU.', "Added chmgrChanCapacity. Changed label `dlt(8)' to `ets(8)' for textual convention Dst.", 'Updated Dsti textual convention to use range 0..32769, and to use display hint. Added textual convention DisplayId, and using this instead of using Unsigned32. Added textual convention Dst, and using this instead of Integer32. Added channel list support by adding chmgrChannelGroup. Corrected spelling errors in descriptions.', 'Added precedence object chmgrODescrPrecedence. Added allowAlternative to chmgrODescrCapabilities. Added objects for channel re-establishment chmgrOConnReestablish and chmgrOChanReestablish. Added statistical objects, 64-bit values for bitrate chmgrOStatDcap1Bitrate and chmgrTStatDcap1Bitrate, and per cent indicator objects chmgrOStatDcap1Load and chmgrTStatDcap1Load. Added dle as connection type to chmgrODescrType. Changed some formatting and typing errors in descriptions.', 'Updated descriptions. The chmgrTStatPMReferenceTable is deprecated.', 'The value that indicates that no source route shall be used is changed from 0 to max value. Changes only made in descriptions.', "Added operational state `dormant' for originating and terminating connections.",))
if mibBuilder.loadTexts: netiChmgrMIB.setLastUpdated('201501081500Z')
if mibBuilder.loadTexts: netiChmgrMIB.setOrganization('Net Insight AB')
if mibBuilder.loadTexts: netiChmgrMIB.setContactInfo('Net Insight AB Box 42093 SE-126 14 Stockholm Sweden Tel +46-8-685 0400 info@netinsight.se')
if mibBuilder.loadTexts: netiChmgrMIB.setDescription('MIB for the Channel Manager. The Channel Manager is a function that manages connections and their channels in a consistent manner, independently of the service that uses the connection. The Channel Manager provides a common method to configure the connections, and to present data about the connections and channels that exist.')
class Dst(TextualConvention, Integer32):
    description = 'The DST (DTM Service Type). The DST denotes a class of data for which a channel is used.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5, 8, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26))
    namedValues = NamedValues(("ctrl", 0), ("dleCrtlAndData", 1), ("pdh", 4), ("dleInterServer", 5), ("ets", 8), ("ping", 12), ("e1", 13), ("ds1", 14), ("sdi", 15), ("dvb", 16), ("sdh", 18), ("ttcp", 19), ("aesebu", 20), ("j2kSdSdi", 21), ("j2kHdSdi", 22), ("j2k3gSdi", 23), ("j2kHdSdi2", 24), ("j2k3gSdi2", 25), ("j2kSdSdi2", 26))

class Dsti(TextualConvention, Unsigned32):
    description = 'The DSTI (DTM Service Type Instance) is a number to identify an instance of a service within a service type. The number is used by the application to address the individual instance of the service between nodes.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 32769)

class ChannelId(TextualConvention, Unsigned32):
    description = "The identity of the a channel. This value is unique within the node where the channel originates. Together with the address (typically the MAC address) of the originating node, the channel's identity is unique within the entire DTM network."
    status = 'current'
    displayHint = 'x'

class DcapType(TextualConvention, Integer32):
    description = 'The DCAP (DTM Channel Adaptation Protocol) type for the connection. dcap0(1) DCAP-0 that provides an asynchronous streaming service. dcap1(2) DCAP-1 that provides an asynchronous packet service.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("dcap0", 1), ("dcap1", 2))

class DtmNode(TextualConvention, OctetString):
    description = "The DTM node is either the DTM address of a node, or the node's name. If the DtmNode is on the format of a DTM address, is assumed that it is the DTM address. If not, it is assumed that it is the name of the node. A DTM address has the format of eight groups of two characters each, separated by dots. Each group represents one octet in hexadecimal notation, e.g. '00.00.00.00.00.00.00.00' A node's name has the format of a string with printable, non-white space characters."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 64)

class DcpVersion(TextualConvention, Integer32):
    description = 'The DCP version.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("auto", 1), ("dcp2", 2), ("dcp3", 3))

chmgrObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1))
chmgrNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 2))
chmgrConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 3))
chmgrODescriptionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1))
chmgrTDescriptionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 2))
chmgrSourceRouteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3))
chmgrOConnectionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4))
chmgrTConnectionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5))
chmgrStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6))
chmgrChannelGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7))
chmgrODescriptionTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODescriptionTimeStamp.setStatus('current')
if mibBuilder.loadTexts: chmgrODescriptionTimeStamp.setDescription('Time stamp when any data in any of the tables in this group were last updated.')
chmgrODescriptionTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2), )
if mibBuilder.loadTexts: chmgrODescriptionTable.setStatus('current')
if mibBuilder.loadTexts: chmgrODescriptionTable.setDescription("Descriptions on originating connections. The creation and deletion of rows in the table is done by the application that provides the service on the connection. When a row is deleted, the associated rows in the destination table chmgrODescrDestinationTable and channel table chmgrODescrChannelTable are also deleted. The table contains information about the capabilities of the connections as well as the actual configuration of the connections. As the capabilities depends on the type of service, it is the service's application that is responsible for defining these. Changes made on a row in the table will take immediate effect. This could result in a re-establishment of the channel(s) using the new parameters.")
chmgrODescriptionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrODescrIndex"))
if mibBuilder.loadTexts: chmgrODescriptionEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrODescriptionEntry.setDescription('An entry in the table is representing the description and configuration of one connection.')
chmgrODescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: chmgrODescrIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrIndex.setDescription('Index for this entry.')
chmgrODescrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ets", 1), ("its", 2), ("dle", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODescrType.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrType.setDescription('This is the unique connection type identifier that defined the type of service that the connection description describes. ets(1). Ethernet Transport Service (DTM LAN Transport). its(2). Isochronous Transport Service (DTM Isochronous Transport). dle(3). DTM LAN Emulation.')
chmgrODescrCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 3), Bits().clone(namedValues=NamedValues(("allowCapacityInterval", 0), ("destination", 1), ("allowDynamicCapacity", 2), ("isMulticast", 3), ("allowEstablish", 4), ("allowProtection", 5), ("allowReestablish", 6), ("allowScheduling", 7), ("allowSourceRoute", 8), ("requireCapacity", 9), ("allowAlternative", 10), ("allowZeroCapacity", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODescrCapabilities.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrCapabilities.setDescription('Connection capabilities that indicate which parameters that are possible to configure in this connection description. allowCapacityInterval(0) Allows the configuration of capacity to have different values on requested and accepted capacity. destination(1) Describes if destinations shall be configured for this description. This is the normal case for most connections, but is some cases, the destination is decided by the application that is responsible for the service on the connection. allowDynamicCapacity(2) Allows the use of dynamic capacity adjustment. isMulticast(3) Describes if the connection is a multicast connection. This value is set by the application that is responsible for the service that uses the connection. allowEstablish(4) Allows the configuration of whether the connection shall be established using the capacity configurations of the connection or not. allowProtection(5) Allows the connection to be configured to be 1+1 protected by using two channels for the connection. allowReestablish(6) Allows configuration of the re- establishment algorithm. allowScheduling(7) Allows an external application, such as a scheduled, to alter the capacity and administrative state of the connection. allowSourceRoute(8) Allows configuration of source routed connections. requireCapacity(9) Requires the configuration of capacity. This is the normal case for most connections, but in some cases, the capacity is defaulted by the application. allowAlternative(10) Allows configuration of several alternative destinations. The unicast connection will be established using only one of the available destination. allowZeroCapacity(11). Allows configuration of zero capacity.')
chmgrODescrCustomerId = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODescrCustomerId.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrCustomerId.setDescription('This is a customer identifications number assigned by the application that is providing the service on the connection. The object has no functional use except to provide the information.')
chmgrODescrServiceReference = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODescrServiceReference.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrServiceReference.setDescription('This is a pointer to the application or service that owns this connection description, and that is responsible for the capabilities.')
chmgrODescrAcceptableBps = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 6), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrAcceptableBps.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrAcceptableBps.setDescription("The minimum payload capacity in bits per second for the service using the channel. If it is not possible to allocate this capacity, a channel will not be established. If the acceptable capacity is larger than the maximum value (4,294,967,295) bits per second, then the `chmgrODescrAcceptableMbps' must be used. If the capacity is greater than the maximum value of this object, then the this object should report the maximum value.")
chmgrODescrAcceptableSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODescrAcceptableSlots.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrAcceptableSlots.setDescription('The minimum capacity in number of 512 kbps DTM slots. The value is based on the chmgrAcceptableBps and the necessary overhead required by the service for delivering the payload capacity. The overhead is calculated by the service application.')
chmgrODescrRequestedBps = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 8), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrRequestedBps.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrRequestedBps.setDescription("The requested payload capacity in bits per second for the service using the channel. If the requested capacity is larger than the maximum value (4,294,967,295) bits per second, then the `chmgrODescrRequestedMbps' must be used. If the capacity is greater than the maximum value of this object, then the this object should report the maximum value.")
chmgrODescrRequestedSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODescrRequestedSlots.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrRequestedSlots.setDescription('The requested capacity in number of 512 kbps DTM slots. The value is based on the chmgrRequestedBps and the necessary overhead required by the service for delivering the payload capacity. The overhead is calculated by the service application.')
chmgrODescrReestablishMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("exponential", 1))).clone('exponential')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrReestablishMethod.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrReestablishMethod.setDescription('The type of algorithm or method used to re-establish channels that for some reason fail to be established or is torn down. The methods are: exponential(1) Establishment attempts are done at time interval that is doubled for each attempt, starting at chmgrMinInterval and increased to a maximum of chmgrMaxInterval, until a channel is successfully established. The value is only valid if the allowReestablish(6) bit in chmgrODescrCapabililties is set.')
chmgrODescrMinInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrMinInterval.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrMinInterval.setDescription('The minimum time in milliseconds between two attempts to establish the channel.')
chmgrODescrMaxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrMaxInterval.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrMaxInterval.setDescription('The maximum time in milliseconds between two attempts to establish the channel. This value must be larger than chmgrODescrMinInterval.')
chmgrODescrEstablish = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 13), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrEstablish.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrEstablish.setDescription("Describes if the connection shall be established with the defined parameters. The value is only valid if the allowEstablish(4) bit in chmgrODescrCapabilites is set. true(1) The connection is established. false(2) The connection is not established. The establishment of the connection is controlled by some other function outside the scope of this MIB. This could be a scheduler or timer specified in other MIB's.")
chmgrODescrNextDestTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODescrNextDestTableIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrNextDestTableIndex.setDescription('The value of the next available index for this connection description in the chmgrODescrDestinationTable.')
chmgrODescrPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrPrecedence.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrPrecedence.setDescription('A channel with precedence is established and torn down before any channel without precedence. true(1) The channel has precedence. false(2) The channel does not have precedence.')
chmgrODescrSuppressAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 16), Bits().clone(namedValues=NamedValues(("route", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrSuppressAlarms.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrSuppressAlarms.setDescription('Suppress generation of some alarms: route(0) Alarm raised if a service is not using its primary source route.')
chmgrODescrAcceptableMbps = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 17), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrAcceptableMbps.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrAcceptableMbps.setDescription("The minimum payload capacity in units of 1,000,000 bits per second for the service using the channel. If it is not possible to allocate this capacity, a channel will not be established. This object must be used when requesting a capacity larger than 4,294,967,295 bits per second. If a lower capacity is requested, then it is possible to use `chmgrODescrAcceptableBps'.")
chmgrODescrRequestedMbps = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 18), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrRequestedMbps.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrRequestedMbps.setDescription("The requested payload capacity in units of 1,000,000 bits per second for the service using the channel. This object must be used when requesting a capacity larger than 4,294,967,295 bits per second. If a lower capacity is requested, then it is possible to use `chmgrODescrRequestedBps'.")
chmgrODescrRequestedDcpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 19), DcpVersion()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrRequestedDcpVersion.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrRequestedDcpVersion.setDescription("The DCP version that should be used for channel established for this connection. `any' means try with DCP3 first and revert to DCP2 if unsuccessful because of node version mismatch.")
chmgrODescrOneHopSpareCapUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 2, 1, 20), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrODescrOneHopSpareCapUtilization.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrOneHopSpareCapUtilization.setDescription("Specifies if the the channel shall dynamically allocate spare capacity. When `true', then the channel is initially established with the acceptable capacity specified in chmgrODescrAcceptableBps (or chmgrODescrAcceptableMbps). The channel capacity is then monitored and automatically increased with available capacity up to the capacity specified in chmgrODescrRequestedBps (or chmgrODescrRequestedMbps). If another channel would request capacity, then the capacity of this channel is reduced as needed by the other channel, but not below the acceptable capacity. When set to `false', then spare capacity will not be used. This function requires use of DCP3, see chmgrODescrRequestedDcpVersion. This function requires use of ETS unicast. This function requires the channel destination to be a neighboring node.")
chmgrODescrDestinationTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 3), )
if mibBuilder.loadTexts: chmgrODescrDestinationTable.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrDestinationTable.setDescription('The table describes destinations for a connection. A unicast connection can normally only have one destination, while a multicast connection may have several destinations. If a unicast connection allows alternative destinations, as defined by the allowAlternative(10) bit in chmgrODescrCapabilities, it is allowed to define multiple destinations. At channel establishment, the destinations will be tried in succession until a channel is successfully established. It is possible to add, change and delete destinations while the connection is active. For a unicast connection, a changed destination is torn down as soon as it is changed, and established as soon as the changed information contains valid data. For a multicast connection, it is possible to add and delete destinations to an already established connection without affecting the connection to the other destinations. An added destination will be established as soon as it includes valid information, and will be re-established as soon as the information is changed. Note that a destination address with an empty string can be used to disable the destination. For a multicast connection a single destination can also be enabled and disabled using its administrative status. The bits allowAlternative(10), destination(1) and allowMulticast(3) in chmgrODescCapabilities describes if and how it is allowed to add a destination to a connection.')
chmgrODescrDestinationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 3, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrODescrIndex"), (0, "NETI-CHMGR-MIB", "chmgrODescrDestIndex"))
if mibBuilder.loadTexts: chmgrODescrDestinationEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrDestinationEntry.setDescription('An entry in the table represents one destination.')
chmgrODescrDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: chmgrODescrDestIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrDestIndex.setDescription('The index for this entry.')
chmgrODescrDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 3, 1, 2), DtmNode().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrODescrDestAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrDestAddress.setDescription('The DTM address for a destination termination point of the connection. The empty string indicates an unconfigured destination. The address should be the last object to configure to avoid unnecessary channel establishment while configuring the destination.')
chmgrODescrDestDsti = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 3, 1, 3), Dsti()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrODescrDestDsti.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrDestDsti.setDescription('The DSTI (DTM Service Type Instance) for the destination termination point of the connection.')
chmgrODescrDestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrODescrDestRowStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrDestRowStatus.setDescription('See SNMPv2-TC. The following values are supported: active(1) The object always reads active(1). createAndGo(4) A new conceptual row is created representing a new destination. destroy(6) The conceptual row representing the destination is deleted, and the connection to the destination is torn down. Connections to other destinations are not affected. Associated rows in the channel table chmgrODescrChannelTable will also be destroyed.')
chmgrODescrDestAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrODescrDestAdminStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrDestAdminStatus.setDescription('The administrative state of the destination. The value controls the desired state of the multicast connection to the destination. up(1). The connection shall be established to the destination. down(2). No connection shall be established to the destination.')
chmgrODescrChannelTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 4), )
if mibBuilder.loadTexts: chmgrODescrChannelTable.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrChannelTable.setDescription('The table describes relationships between destinations defined in the chmgrODescrDestinationTable, channels and source routes. To make a connection to a destination 1+1 protected, create two rows representing the two channels in the table. Note that this is only allowed if the bit allowProtection(5) is set in chmgrODescrCapabilities. If no conceptual row exists for a destination, it is assumed that there shall be only one channel to the destination and that no source route is shall be used. A channel to a destination may have its route through the DTM networks defined by one or many source routes. If multiple source routes are defined, any one of these source routes is chosen when the channel is established.')
chmgrODescrChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 4, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrODescrIndex"), (0, "NETI-CHMGR-MIB", "chmgrODescrDestIndex"), (0, "NETI-CHMGR-MIB", "chmgrODescrChanIndex"), (0, "NETI-CHMGR-MIB", "chmgrODescrChanSourceRouteIndex"))
if mibBuilder.loadTexts: chmgrODescrChannelEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrChannelEntry.setDescription('An entry in this table represents the relationship between one channel in the connection (defined in chmgrODescrDestinationTable) and one source route (defined in chmgrSourceRouteTable).')
chmgrODescrChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: chmgrODescrChanIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrChanIndex.setDescription('The index of the channel used by the connection.')
chmgrODescrChanSourceRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 4, 1, 2), Unsigned32())
if mibBuilder.loadTexts: chmgrODescrChanSourceRouteIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrChanSourceRouteIndex.setDescription('The index of the row describing the relationship to one source route.')
chmgrODescrChanSourceRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 4, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrODescrChanSourceRoute.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrChanSourceRoute.setDescription('The index in the chmgrOSourceRouteTable representing the desired source route for the channel to the destination. If no source route shall be used by the channel for this destination, delete the conceptual row or set the value to the max value (4294967295).')
chmgrODescrChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrODescrChanRowStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrODescrChanRowStatus.setDescription('See SNMPv2-TC. The following values are supported: active(1) The object always reads active(1). createAndGo(4) a new conceptual row is created representing a channel is added. destroy(6) The conceptual row representing the channel is deleted.')
chmgrSourceRouteTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrSourceRouteTimeStamp.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteTimeStamp.setDescription('Value of sysUpTime when any of the tables in this group were last updated.')
chmgrSourceRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 2), )
if mibBuilder.loadTexts: chmgrSourceRouteTable.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteTable.setDescription('Table listing source routes. A source route is a route through the DTM net that is defined at the source of the channel. The source routes may be used by many connections, making the connections using the same route through the DTM network. A source route may only be updated or deleted when it is not used by any established connection. Note that a source route set up as loose, with no intermediate nodes, and set up to use any outgoing interface is equivalent to a shortest path routing.')
chmgrSourceRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 2, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrSourceRouteIndex"))
if mibBuilder.loadTexts: chmgrSourceRouteEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteEntry.setDescription('An entry representing one source route.')
chmgrSourceRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: chmgrSourceRouteIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteIndex.setDescription('The index for this entry.')
chmgrSourceRouteName = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 2, 1, 2), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrSourceRouteName.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteName.setDescription('A string for administrative use that identifies or describes the source route. The string does not have to be unique.')
chmgrSourceRouteTypeOfRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("loose", 2))).clone('strict')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrSourceRouteTypeOfRoute.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteTypeOfRoute.setDescription('The type of source route that shall be used. strict(1) The channel must only pass the hops defined in the source route. loose(2) The channel must pass all the hops defined in the source route.')
chmgrSourceRouteFirstIfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 2, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrSourceRouteFirstIfBoard.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteFirstIfBoard.setDescription('The identity of the board where the DTM interface is located that shall be used for leaving the node. A value of zero (0) means that any board may be used. A DTM interface is identified by a board and a port on that board.')
chmgrSourceRouteFirstIfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 2, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrSourceRouteFirstIfPort.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteFirstIfPort.setDescription('The identity of the port on the board specified in chmgrSourceRouteFirstIfBoard that shall be used for leaving the node. A value of zero (0) means that any port may be used. A DTM interface is identified by a board and a port on that board.')
chmgrSourceRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrSourceRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteRowStatus.setDescription('Se SNMPv2-TC. Supports createAndGo(4) and destroy(6). createAndGo(4) A new row is created representing a new source route. destroy(6) A row is deleted. All rows in the chmgrSourceRouteHopTable that describes the route are also deleted. It is not possible to change or delete a source route that is in use by an established channel.')
chmgrSourceRouteHopTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 3), )
if mibBuilder.loadTexts: chmgrSourceRouteHopTable.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteHopTable.setDescription('Table describing the nodes and interfaces for intermediate nodes that a source route shall be using.')
chmgrSourceRouteHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 3, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrSourceRouteIndex"), (0, "NETI-CHMGR-MIB", "chmgrSourceRouteHopIndex"))
if mibBuilder.loadTexts: chmgrSourceRouteHopEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteHopEntry.setDescription('An entry describes one hop for a source route.')
chmgrSourceRouteHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: chmgrSourceRouteHopIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteHopIndex.setDescription('The index for this conceptual row.')
chmgrSourceRouteHopAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 3, 1, 2), DtmNode()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrSourceRouteHopAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteHopAddress.setDescription('The DTM address of the node.')
chmgrSourceRouteHopNextIfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 3, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrSourceRouteHopNextIfBoard.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteHopNextIfBoard.setDescription('The identity of the board where the DTM interface is located that shall be used for leaving the node. A value of zero (0) means that any board may be used. A DTM interface is identified by a card and a port on that board.')
chmgrSourceRouteHopNextIfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 3, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrSourceRouteHopNextIfPort.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteHopNextIfPort.setDescription('The identity of the port on the board specified in chmgrSourceRouteFirstIfCard that shall be used for leaving the node. A value of zero (0) means that any port may be used. A DTM interface is identified by a board and a port on that board.')
chmgrSourceRouteHopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 3, 3, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: chmgrSourceRouteHopRowStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrSourceRouteHopRowStatus.setDescription('See SNMPv2-TC. The following values are supported: active(1) The object always reads active(1). createAndGo(4) A new conceptual row is created. destroy(6) The conceptual row representing is deleted.')
chmgrOConnectionTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnectionTimeStamp.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnectionTimeStamp.setDescription('The value of sysUpTime when any of the tables in the group were last changed.')
chmgrOConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2), )
if mibBuilder.loadTexts: chmgrOConnectionTable.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnectionTable.setDescription('The table lists all the originating connections. The connections are configured in the chmgrODescriptionTable.')
chmgrOConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrOConnIndex"))
if mibBuilder.loadTexts: chmgrOConnectionEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnectionEntry.setDescription('An entry in the table representing one originating connection.')
chmgrOConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: chmgrOConnIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnIndex.setDescription('The index of the connection in the table.')
chmgrOConnCustomerId = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnCustomerId.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnCustomerId.setDescription('This is a customer identification number assigned by the application that is providing the service on the connection. The object has no functional use except to provide the information. This is the same value as chmgrODescrCustomerId.')
chmgrOConnODescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnODescrIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnODescrIndex.setDescription('A reference to the chmgrODescriptionTable. It is the index in the chmgrODescriptionTable for the description that describes the configuration of this connection.')
chmgrOConnServiceReference = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 4), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnServiceReference.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnServiceReference.setDescription("A reference to the service responsible for this connection. The object points to the instance of the service in the service's MIB. Its MIB shall have a table representing all the instances of the service.")
chmgrOConnAllocatedSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8389))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnAllocatedSlots.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnAllocatedSlots.setDescription('The number of 512 kbps DTM slots that is allocated by the connection. Note that for a connection with multiple channels, e.g. 1+1 protected connection, all the channels have the same capacity. To know how much capacity that is used by the connection, multiply the value with the number of active channels. The channels are listed in chmgrOChannelTable.')
chmgrOConnAllocatedSlotsChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnAllocatedSlotsChanged.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnAllocatedSlotsChanged.setDescription('The value of sysUpTime when the allocated capacity for the connection was last changed.')
chmgrOConnDcapType = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 7), DcapType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnDcapType.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnDcapType.setDescription('The DCAP (DTM Channel Adaptation Protocol) type for the connection.')
chmgrOConnDst = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 8), Dst()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnDst.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnDst.setDescription('The DST (DTM Service Type) of the service that uses the connection.')
chmgrOConnSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 9), DtmNode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnSourceAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnSourceAddress.setDescription('The DTM address of the originating node for the connection.')
chmgrOConnSourceDsti = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 10), Dsti()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnSourceDsti.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnSourceDsti.setDescription('The DSTI (DTM Service Type Instance) of the service at the originating node of the connection.')
chmgrOConnStatusLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnStatusLastChanged.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnStatusLastChanged.setDescription('The value of sysUpTime when the operational status of the connection was last changed.')
chmgrOConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnAdminStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnAdminStatus.setDescription('Information about the administrative state of the connection. The administrative state is controlled by the application that provides the service transported on the connection. The application sets the administrative state to up(1) when a connection shall be established, and down(2) when the connection shall be torn down.')
chmgrOConnOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("partial", 3), ("dormant", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnOperStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnOperStatus.setDescription('The operational state of the connection. In general, the operational state should follow the administrative state, chmgrOConnAdminStatus. up(1) The connection is up to all its destination on all its channels. For a unicast connection, this is the one configured destination. For a multicast connection, this is all the configured connections. For a 1+1 protected connection, this is both the channels. down(2) No channels are established for the connection. partial(3) The connection is partly established. The connection is not established to at least one of its configured destination on at least one of its channels. dormant(5) The establishment of the connection is pending an action from some other entity, e.g. a scheduler. This is not an error state.')
chmgrOConnReestablish = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notApplicable", 0), ("reestablish", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrOConnReestablish.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnReestablish.setDescription('Writing to this object immediately starts to re-establish the connection to all its destinations. The establishment of the connection will be done according to the current network topology and availability. If source routes are defined, the first source route will be tried first. notApplicable(0) Always reads this value. This value cannot be written. reestablish(1) Writing this value reestablishes the connection. ')
chmgrOConnForceSourceRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 15), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrOConnForceSourceRoute.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnForceSourceRoute.setDescription('Writing to this object immediately starts to re-establish the connection to the destinations and channels using the source route specified with the written value. The value written controls which source route to first try when re-establishing the channel. For each destination and channel for the connection, the written value is used as value for the index chmgrODescrChanSourceRouteIndex in the the chmgrODescrChannelTable. If the entry does not exist, or if the source route is already the one that used by the destination and channel, then no action is taken. Otherwise if the entry exists, then the channel for the destination is re-established, where the given source route is first attempted. Reading this always returns the value 0.')
chmgrOConnDcpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 2, 1, 16), DcpVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOConnDcpVersion.setStatus('current')
if mibBuilder.loadTexts: chmgrOConnDcpVersion.setDescription("Version of DCP that is used for this connection. `any(0)' means that a channel is not established.")
chmgrODestinationTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 3), )
if mibBuilder.loadTexts: chmgrODestinationTable.setStatus('current')
if mibBuilder.loadTexts: chmgrODestinationTable.setDescription('List of destinations per origination connection.')
chmgrODestinationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 3, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrOConnIndex"), (0, "NETI-CHMGR-MIB", "chmgrODescrDestIndex"))
if mibBuilder.loadTexts: chmgrODestinationEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrODestinationEntry.setDescription('An entry represents one destination for a connection.')
chmgrODestDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 3, 1, 1), DtmNode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODestDestinationAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrODestDestinationAddress.setDescription('The DTM address of a destination node.')
chmgrODestDestinationDsti = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 3, 1, 2), Dsti()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrODestDestinationDsti.setStatus('current')
if mibBuilder.loadTexts: chmgrODestDestinationDsti.setDescription('The DSTI (DTM Service Type Instance) of the service at the destination node.')
chmgrOChannelTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4), )
if mibBuilder.loadTexts: chmgrOChannelTable.setStatus('current')
if mibBuilder.loadTexts: chmgrOChannelTable.setDescription('Table that shows the status for all the originating channels, listed per connection and destination.')
chmgrOChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrOConnIndex"), (0, "NETI-CHMGR-MIB", "chmgrODescrDestIndex"), (0, "NETI-CHMGR-MIB", "chmgrODescrChanIndex"))
if mibBuilder.loadTexts: chmgrOChannelEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrOChannelEntry.setDescription('An entry per channel.')
chmgrOChanSourceRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOChanSourceRouteIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrOChanSourceRouteIndex.setDescription("The source route index that is referring to the source route currently used by the the channel. This is the value of the index chmgrODescrChanSourceRouteIndex in chmgrODescrChannelTable. A value of '0' would mean the 1st configured source route is used, '1' the 2nd, and so on. If no source route is used by the channel, then the value is 4294967295.")
chmgrOChanChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4, 1, 2), ChannelId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOChanChannelId.setStatus('current')
if mibBuilder.loadTexts: chmgrOChanChannelId.setDescription('The identity of the DTM channel. If no channel is established, the value is zero (0).')
chmgrOChanErrorMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOChanErrorMessage.setStatus('current')
if mibBuilder.loadTexts: chmgrOChanErrorMessage.setDescription('Contains a message describing the error if the channel is down due to an error. If there are no error, the objects returns an empty string.')
chmgrOChanErrorAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4, 1, 4), DtmNode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOChanErrorAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrOChanErrorAddress.setDescription('Contains the DTM address if the node that is reporting an error, described in chmgrOChanErrorMessage. If there are no error, the object returns the address 00.00.00.00.00.00.00.00.')
chmgrOChanOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOChanOperStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrOChanOperStatus.setDescription('The operational status of the channel. If the operational status of the connection is up, indicated in chmgrOConnOperStatus, a value of up(1) indicates that the channel is operational, and a value of down(2) indicates that the channel is not operational due to an error. The object chmgrOChanErrorMessage describes the problem. If the operational status of the connection is down, the value of the object is always down.')
chmgrOChanStatusChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOChanStatusChanged.setStatus('current')
if mibBuilder.loadTexts: chmgrOChanStatusChanged.setDescription('The sysUpTime when the status of the channel to the destination was last established or torn down.')
chmgrOChanReestablish = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 4, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notApplicable", 0), ("reestablish", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chmgrOChanReestablish.setStatus('current')
if mibBuilder.loadTexts: chmgrOChanReestablish.setDescription('Writing to this object re-establishes the channel to its destination without affecting other channels or destinations configured for this connection. The establishment of the channel will be done according to the current network topology and availability. If source routes are defined, the first source route will be tried first. notApplicable(0) Always reads this value. This value cannot be written. reestablish(1) Writing this value reestablishes the channel.')
chmgrTConnectionTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnectionTimeStamp.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnectionTimeStamp.setDescription('Time stamp, i.e. the value of sysUpTime when any for the tables in the group was last changed.')
chmgrTConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2), )
if mibBuilder.loadTexts: chmgrTConnectionTable.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnectionTable.setDescription('Table with termination connections. The table is managed by the applications that provide services transported on the connections.')
chmgrTConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrTConnIndex"))
if mibBuilder.loadTexts: chmgrTConnectionEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnectionEntry.setDescription('An entry represents one connection.')
chmgrTConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: chmgrTConnIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnIndex.setDescription('Index for this entry.')
chmgrTConnCustomerId = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnCustomerId.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnCustomerId.setDescription('This is a customer identification number assigned by the application that is providing the service on the connection. The object has no functional use except to provide the information.')
chmgrTConnNumberOfChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnNumberOfChannels.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnNumberOfChannels.setDescription('The number of channels this connection uses. A 1+1 protected connection uses two channels.')
chmgrTConnActiveChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnActiveChannel.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnActiveChannel.setDescription('The channel that is currently active. This is the index of the channel in the chmgrTChannelTable. If there is no active channel for the connection, the value is zero (0).')
chmgrTConnServiceReference = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnServiceReference.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnServiceReference.setDescription("A reference to the service responsible for this connection. The object points to the instance of the service in the service's MIB. Its MIB shall have a table representing all the instances of the service.")
chmgrTConnAllocatedSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8389))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnAllocatedSlots.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnAllocatedSlots.setDescription('The number of 512 kbps DTM slots that is allocated by the connection. Note that for a connection with multiple channels, e.g. 1+1 protected connection, all the channels have the same capacity. To know how much capacity that is used by the connection, multiply the value with the number of active channels. The channels are listed in chmgrTChannelTable.')
chmgrTConnAllocatedSlotsChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnAllocatedSlotsChanged.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnAllocatedSlotsChanged.setDescription('The value of sysUpTime when the capacity for the connection was last changed.')
chmgrTConnDcapType = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 8), DcapType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnDcapType.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnDcapType.setDescription('The DCAP (DTM Channel Adaptation Protocol) type for the connection.')
chmgrTConnDst = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 9), Dst()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnDst.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnDst.setDescription('The DST (DTM Service Type) of the service that uses the connection.')
chmgrTConnSourceDsti = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 10), Dsti()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnSourceDsti.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnSourceDsti.setDescription('The DSTI (DTM Service Type Instance) of the service at the originating node of the connection.')
chmgrTConnSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 11), DtmNode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnSourceAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnSourceAddress.setDescription("The DTM address of the connection's originating node.")
chmgrTConnDestinationDsti = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 12), Dsti()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnDestinationDsti.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnDestinationDsti.setDescription('The DSTI (DTM Service Type Instance) of the service at the terminating node of the connection.')
chmgrTConnDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 13), DtmNode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnDestinationAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnDestinationAddress.setDescription("The DTM address of the connection's terminating node.")
chmgrTConnStatusLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnStatusLastChanged.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnStatusLastChanged.setDescription('The value of sysUpTime when the operational status of the connection was last changed.')
chmgrTConnAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnAdminStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnAdminStatus.setDescription("The administrative state of the connection. The administrative state is controlled by the application that provides a service on the connection. It may be accessed in the service's MIB, where the instance is described by chmgrTConnServiceReference.")
chmgrTConnOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("dormant", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnOperStatus.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnOperStatus.setDescription("The operational state of the connection. It should follow the administrative state described in chmgrTConnAdminStatus. up(1) A channel has been established. down(2) No channels are established, and the connection's administrative state is down. dormant(5) No channels have been established. The connection's administrative state is up and the connection is pending a terminating channel.")
chmgrTConnDcpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 2, 1, 17), DcpVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTConnDcpVersion.setStatus('current')
if mibBuilder.loadTexts: chmgrTConnDcpVersion.setDescription("Version of DCP that is used for this connection. `any(0)' means that a channel is not established.")
chmgrTChannelTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 3), )
if mibBuilder.loadTexts: chmgrTChannelTable.setStatus('current')
if mibBuilder.loadTexts: chmgrTChannelTable.setDescription('The channels that exists on a terminating connection. The table is managed by the application that provides the service on the connection. A row is inserted when a new channel is established and is removed when a channel is torn down. For a 1+1 protected connection, there are two channels in a connection.')
chmgrTChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 3, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrTConnIndex"), (0, "NETI-CHMGR-MIB", "chmgrTChanIndex"))
if mibBuilder.loadTexts: chmgrTChannelEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrTChannelEntry.setDescription('An entry in the table represents a channel on a connection.')
chmgrTChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: chmgrTChanIndex.setStatus('current')
if mibBuilder.loadTexts: chmgrTChanIndex.setDescription('The index for the channel within the connection. If a connection is 1+1 protected, is consists of two channels.')
chmgrTChanChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 3, 1, 2), ChannelId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTChanChannelId.setStatus('current')
if mibBuilder.loadTexts: chmgrTChanChannelId.setDescription('The identity of the DTM channel. If no channel is established, the value is zero (0).')
chmgrTChanCreated = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 5, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTChanCreated.setStatus('current')
if mibBuilder.loadTexts: chmgrTChanCreated.setDescription('The sysUpTime when the channel was created.')
chmgrOStatDcap1Table = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1), )
if mibBuilder.loadTexts: chmgrOStatDcap1Table.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1Table.setDescription('The table shows statistics for originating DCAP-1 connections. It uses the same index as the chmgrOConnectionTable. Note that all connections are not of the type DCAP-1, and are hence not represented in this table.')
chmgrOStatDcap1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrOConnIndex"))
if mibBuilder.loadTexts: chmgrOStatDcap1Entry.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1Entry.setDescription('An entry represents statistics for one originating connection.')
chmgrOStatDcap1Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOStatDcap1Octets.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1Octets.setDescription('The total number of out-bound octets (bytes) on the connection.')
chmgrOStatDcap1Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOStatDcap1Packets.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1Packets.setDescription('The total number of out-bound packets on the connection.')
chmgrOStatDcap1UtilizedBps = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOStatDcap1UtilizedBps.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1UtilizedBps.setDescription('The utilization in bits per second on the connection as mean value during the last 30 seconds')
chmgrOStatDcap1DiscardOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOStatDcap1DiscardOctets.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1DiscardOctets.setDescription('The number of out-bound octets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
chmgrOStatDcap1DiscardPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOStatDcap1DiscardPackets.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1DiscardPackets.setDescription('The number of out-bound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
chmgrOStatDcap1Bitrate = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOStatDcap1Bitrate.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1Bitrate.setDescription('The utilization in bits per second on the connection as mean value measured during the last 30 seconds. This value is a 64-bit equivalent to chmgrOStatDcap1UtilizedBps.')
chmgrOStatDcap1Load = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrOStatDcap1Load.setStatus('current')
if mibBuilder.loadTexts: chmgrOStatDcap1Load.setDescription('The utilization (load) in percent on the connection as mean value measured during the last 30 seconds.')
chmgrTStatDcap1Table = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2), )
if mibBuilder.loadTexts: chmgrTStatDcap1Table.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1Table.setDescription('The table shows statistics for terminating DCAP-1 connections. It uses the same index as the chmgrTConnectionTable. Note that all connections are not of the type DCAP-1, and are hence not represented in this table.')
chmgrTStatDcap1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrTConnIndex"))
if mibBuilder.loadTexts: chmgrTStatDcap1Entry.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1Entry.setDescription('An entry representing statistics for one terminating connection.')
chmgrTStatDcap1Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1Octets.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1Octets.setDescription('The total number of in-bound octets (bytes) on the connection.')
chmgrTStatDcap1Packets = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1Packets.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1Packets.setDescription('The total number of in-bound packets on the connection.')
chmgrTStatDcap1UtilizedBps = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1UtilizedBps.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1UtilizedBps.setDescription('The utilization in bits per second on the connection as a mean value during the last 30 seconds.')
chmgrTStatDcap1DiscardOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1DiscardOctets.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1DiscardOctets.setDescription('The number of in-bound octets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
chmgrTStatDcap1DiscardPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1DiscardPackets.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1DiscardPackets.setDescription('The number of in-bound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
chmgrTStatDcap1ErrorCRC = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1ErrorCRC.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1ErrorCRC.setDescription('The number of CRC32 errors detected on in-bound packets for the connection.')
chmgrTStatDcap1ErrorLods = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1ErrorLods.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1ErrorLods.setDescription('The number of LODS errors detected on in-bound data.')
chmgrTStatDcap1Bitrate = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1Bitrate.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1Bitrate.setDescription('The utilization in bits per second on the connection as mean value measured during the last 30 seconds. This value is a 64-bit equivalent to chmgrTStatDcap1UtilizedBps.')
chmgrTStatDcap1Load = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 2, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatDcap1Load.setStatus('current')
if mibBuilder.loadTexts: chmgrTStatDcap1Load.setDescription('The utilization (load) in percent on the connection as mean value measured during the last 30 seconds.')
chmgrTStatPMReferenceTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 3), )
if mibBuilder.loadTexts: chmgrTStatPMReferenceTable.setStatus('deprecated')
if mibBuilder.loadTexts: chmgrTStatPMReferenceTable.setDescription('Table with reference to Performance Monitoring Data for the connections. It uses the same index as the chmgrOConnectionTable. Note that all connections are not represented in this table.')
chmgrTStatPMReferenceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 3, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrTConnIndex"))
if mibBuilder.loadTexts: chmgrTStatPMReferenceEntry.setStatus('deprecated')
if mibBuilder.loadTexts: chmgrTStatPMReferenceEntry.setDescription('An entry in the table.')
chmgrTStatPMReference = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 6, 3, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrTStatPMReference.setStatus('deprecated')
if mibBuilder.loadTexts: chmgrTStatPMReference.setDescription('A reference to a row in a table that shows performance data for the connection. The table is not part of this MIB.')
chmgrChannelTable = MibTable((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1), )
if mibBuilder.loadTexts: chmgrChannelTable.setStatus('current')
if mibBuilder.loadTexts: chmgrChannelTable.setDescription('Table with all channels, that is originating, transiting or terminating channels.')
chmgrChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1), ).setIndexNames((0, "NETI-CHMGR-MIB", "chmgrChanSourceMacAddress"), (0, "NETI-CHMGR-MIB", "chmgrChanChannelId"), (0, "NETI-CHMGR-MIB", "chmgrChanOutgoingIfBoard"), (0, "NETI-CHMGR-MIB", "chmgrChanOutgoingIfPort"))
if mibBuilder.loadTexts: chmgrChannelEntry.setStatus('current')
if mibBuilder.loadTexts: chmgrChannelEntry.setDescription('An entry represents one branch of the channel. There table has on entry for each channel branch that is transiting and terminating in the node.')
chmgrChanSourceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: chmgrChanSourceMacAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrChanSourceMacAddress.setDescription('The MAC address of the node where the channel originates.')
chmgrChanChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 2), ChannelId())
if mibBuilder.loadTexts: chmgrChanChannelId.setStatus('current')
if mibBuilder.loadTexts: chmgrChanChannelId.setDescription('The identity of the DTM channel.')
chmgrChanOutgoingIfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 3), Unsigned32())
if mibBuilder.loadTexts: chmgrChanOutgoingIfBoard.setStatus('current')
if mibBuilder.loadTexts: chmgrChanOutgoingIfBoard.setDescription('The identity of the board where the DTM interface is located on which this branch of the channel leaves this node. If the channel branch does not leave this node, then the value is 0.')
chmgrChanOutgoingIfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 4), Unsigned32())
if mibBuilder.loadTexts: chmgrChanOutgoingIfPort.setStatus('current')
if mibBuilder.loadTexts: chmgrChanOutgoingIfPort.setDescription('The identity of the port on the board specified in chmgrChanOutgoingIfBoard for the DTM interface, on which this branch of the channel leaves the this node. If the channel branch does not leave this node, then the value is the same as the value of chmgrChanDestDsti.')
chmgrChanOutgoingIfMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanOutgoingIfMacAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrChanOutgoingIfMacAddress.setDescription('The MAC address of the DTM interface on which this branch of the channel leaves this node.')
chmgrChanNextHopMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanNextHopMacAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrChanNextHopMacAddress.setDescription('The MAC address for the next-hop DTM node.')
chmgrChanNextHopDtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 7), DtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanNextHopDtmAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrChanNextHopDtmAddress.setDescription('The DTM address for the next-hop DTM node.')
chmgrChanIncomingIfBoard = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanIncomingIfBoard.setStatus('current')
if mibBuilder.loadTexts: chmgrChanIncomingIfBoard.setDescription('The identity of the board where the DTM interface is located on which this channel is entering this node. If the channel originates in this node, then the value is 0.')
chmgrChanIncomingIfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanIncomingIfPort.setStatus('current')
if mibBuilder.loadTexts: chmgrChanIncomingIfPort.setDescription('The identity of the port on the board specified in chmgrChanIncomingIfBoard for the DTM interface, on which this channels is entering this node. If the channel originates in this node, then the value is 0.')
chmgrChanSourceDtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 10), DtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanSourceDtmAddress.setStatus('current')
if mibBuilder.loadTexts: chmgrChanSourceDtmAddress.setDescription('The DTM address of the node where the channel originates.')
chmgrChanDst = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 11), Dst()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanDst.setStatus('current')
if mibBuilder.loadTexts: chmgrChanDst.setDescription('The DST (DTM Service Type) of the service that uses the channel.')
chmgrChanSourceDsti = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 12), Dsti()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanSourceDsti.setStatus('current')
if mibBuilder.loadTexts: chmgrChanSourceDsti.setDescription('The DSTI (DTM Service Type Instance) of the service at the originating node of the channel.')
chmgrChanIsMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanIsMulticast.setStatus('current')
if mibBuilder.loadTexts: chmgrChanIsMulticast.setDescription('Describes if the channel is a multicast or unicast type. true(1) The channel is a multicast channel. false(2) The channel is a unicast channel. ')
chmgrChanCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanCapacity.setStatus('current')
if mibBuilder.loadTexts: chmgrChanCapacity.setDescription('The capacity of the channel in 512 kbps slots.')
chmgrChanDestDsti = MibTableColumn((1, 3, 6, 1, 4, 1, 2928, 6, 2, 14, 1, 7, 1, 1, 15), Dsti()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chmgrChanDestDsti.setStatus('current')
if mibBuilder.loadTexts: chmgrChanDestDsti.setDescription('The DSTI (DTM Service Type Instance) of the terminating part of the service. This value is only valid for an entry describing a channel branch that is terminating on the node. Its value is 0 for an entry describing a channel branch that is continuing to another node.')
mibBuilder.exportSymbols("NETI-CHMGR-MIB", chmgrTConnServiceReference=chmgrTConnServiceReference, chmgrODescrServiceReference=chmgrODescrServiceReference, PYSNMP_MODULE_ID=netiChmgrMIB, ChannelId=ChannelId, chmgrTConnDcpVersion=chmgrTConnDcpVersion, chmgrSourceRouteTable=chmgrSourceRouteTable, chmgrConformance=chmgrConformance, chmgrSourceRouteHopAddress=chmgrSourceRouteHopAddress, chmgrOConnCustomerId=chmgrOConnCustomerId, chmgrChannelEntry=chmgrChannelEntry, chmgrODescrDestAdminStatus=chmgrODescrDestAdminStatus, chmgrOConnAllocatedSlotsChanged=chmgrOConnAllocatedSlotsChanged, chmgrChanIsMulticast=chmgrChanIsMulticast, chmgrODescrOneHopSpareCapUtilization=chmgrODescrOneHopSpareCapUtilization, chmgrOConnectionTimeStamp=chmgrOConnectionTimeStamp, chmgrChanIncomingIfPort=chmgrChanIncomingIfPort, chmgrODescriptionEntry=chmgrODescriptionEntry, chmgrTStatDcap1DiscardOctets=chmgrTStatDcap1DiscardOctets, chmgrTStatDcap1Octets=chmgrTStatDcap1Octets, chmgrChanNextHopDtmAddress=chmgrChanNextHopDtmAddress, chmgrTConnectionTable=chmgrTConnectionTable, chmgrSourceRouteFirstIfBoard=chmgrSourceRouteFirstIfBoard, chmgrOStatDcap1UtilizedBps=chmgrOStatDcap1UtilizedBps, chmgrSourceRouteHopNextIfBoard=chmgrSourceRouteHopNextIfBoard, chmgrSourceRouteRowStatus=chmgrSourceRouteRowStatus, chmgrODescrDestAddress=chmgrODescrDestAddress, chmgrOConnAdminStatus=chmgrOConnAdminStatus, chmgrTConnAllocatedSlots=chmgrTConnAllocatedSlots, chmgrOConnOperStatus=chmgrOConnOperStatus, chmgrOConnForceSourceRoute=chmgrOConnForceSourceRoute, chmgrODescrMaxInterval=chmgrODescrMaxInterval, chmgrTStatPMReference=chmgrTStatPMReference, chmgrOConnectionTable=chmgrOConnectionTable, chmgrODescrChannelTable=chmgrODescrChannelTable, chmgrODescrChanSourceRoute=chmgrODescrChanSourceRoute, chmgrStatisticsGroup=chmgrStatisticsGroup, chmgrODescrCapabilities=chmgrODescrCapabilities, chmgrSourceRouteTimeStamp=chmgrSourceRouteTimeStamp, chmgrOStatDcap1Packets=chmgrOStatDcap1Packets, chmgrTStatDcap1Packets=chmgrTStatDcap1Packets, chmgrChanSourceMacAddress=chmgrChanSourceMacAddress, chmgrTChanCreated=chmgrTChanCreated, chmgrODescriptionGroup=chmgrODescriptionGroup, chmgrTConnectionEntry=chmgrTConnectionEntry, chmgrChanDestDsti=chmgrChanDestDsti, chmgrOConnDst=chmgrOConnDst, chmgrTStatDcap1ErrorLods=chmgrTStatDcap1ErrorLods, chmgrOStatDcap1Bitrate=chmgrOStatDcap1Bitrate, chmgrNotifications=chmgrNotifications, chmgrOConnSourceDsti=chmgrOConnSourceDsti, chmgrTConnDcapType=chmgrTConnDcapType, chmgrTStatDcap1Table=chmgrTStatDcap1Table, chmgrODescrReestablishMethod=chmgrODescrReestablishMethod, chmgrODescrDestinationEntry=chmgrODescrDestinationEntry, chmgrODescrDestinationTable=chmgrODescrDestinationTable, chmgrODescrEstablish=chmgrODescrEstablish, chmgrODescrRequestedSlots=chmgrODescrRequestedSlots, chmgrSourceRouteHopNextIfPort=chmgrSourceRouteHopNextIfPort, chmgrOConnectionEntry=chmgrOConnectionEntry, chmgrSourceRouteHopTable=chmgrSourceRouteHopTable, DcapType=DcapType, chmgrSourceRouteIndex=chmgrSourceRouteIndex, chmgrODescrRequestedBps=chmgrODescrRequestedBps, chmgrTConnActiveChannel=chmgrTConnActiveChannel, chmgrTStatDcap1Load=chmgrTStatDcap1Load, chmgrODescrSuppressAlarms=chmgrODescrSuppressAlarms, chmgrOChanErrorMessage=chmgrOChanErrorMessage, chmgrTChannelTable=chmgrTChannelTable, chmgrTChannelEntry=chmgrTChannelEntry, chmgrSourceRouteGroup=chmgrSourceRouteGroup, chmgrODescrAcceptableBps=chmgrODescrAcceptableBps, chmgrOStatDcap1Octets=chmgrOStatDcap1Octets, chmgrChanIncomingIfBoard=chmgrChanIncomingIfBoard, chmgrTStatDcap1ErrorCRC=chmgrTStatDcap1ErrorCRC, chmgrOChanChannelId=chmgrOChanChannelId, chmgrSourceRouteName=chmgrSourceRouteName, DtmNode=DtmNode, chmgrTConnDestinationDsti=chmgrTConnDestinationDsti, chmgrODestinationEntry=chmgrODestinationEntry, Dsti=Dsti, chmgrOStatDcap1DiscardOctets=chmgrOStatDcap1DiscardOctets, chmgrTStatDcap1Bitrate=chmgrTStatDcap1Bitrate, chmgrOChanOperStatus=chmgrOChanOperStatus, chmgrObjects=chmgrObjects, DcpVersion=DcpVersion, chmgrTChanIndex=chmgrTChanIndex, chmgrTConnSourceAddress=chmgrTConnSourceAddress, chmgrTStatDcap1DiscardPackets=chmgrTStatDcap1DiscardPackets, chmgrSourceRouteFirstIfPort=chmgrSourceRouteFirstIfPort, chmgrChanOutgoingIfBoard=chmgrChanOutgoingIfBoard, chmgrOConnReestablish=chmgrOConnReestablish, chmgrTConnectionTimeStamp=chmgrTConnectionTimeStamp, chmgrODescrAcceptableSlots=chmgrODescrAcceptableSlots, chmgrOConnAllocatedSlots=chmgrOConnAllocatedSlots, chmgrSourceRouteTypeOfRoute=chmgrSourceRouteTypeOfRoute, chmgrOConnDcpVersion=chmgrOConnDcpVersion, chmgrChanOutgoingIfPort=chmgrChanOutgoingIfPort, chmgrTConnDst=chmgrTConnDst, chmgrTDescriptionGroup=chmgrTDescriptionGroup, chmgrChannelTable=chmgrChannelTable, chmgrOChanReestablish=chmgrOChanReestablish, chmgrODescrChannelEntry=chmgrODescrChannelEntry, chmgrChanOutgoingIfMacAddress=chmgrChanOutgoingIfMacAddress, chmgrTStatPMReferenceTable=chmgrTStatPMReferenceTable, chmgrODescrDestRowStatus=chmgrODescrDestRowStatus, chmgrODescrPrecedence=chmgrODescrPrecedence, chmgrOChannelTable=chmgrOChannelTable, chmgrSourceRouteEntry=chmgrSourceRouteEntry, chmgrODestDestinationAddress=chmgrODestDestinationAddress, chmgrOConnStatusLastChanged=chmgrOConnStatusLastChanged, chmgrODescrCustomerId=chmgrODescrCustomerId, chmgrODescrRequestedMbps=chmgrODescrRequestedMbps, chmgrODescrChanIndex=chmgrODescrChanIndex, chmgrOStatDcap1Table=chmgrOStatDcap1Table, chmgrSourceRouteHopRowStatus=chmgrSourceRouteHopRowStatus, chmgrChanSourceDtmAddress=chmgrChanSourceDtmAddress, chmgrTConnAdminStatus=chmgrTConnAdminStatus, chmgrODescrChanSourceRouteIndex=chmgrODescrChanSourceRouteIndex, chmgrOChanErrorAddress=chmgrOChanErrorAddress, chmgrChanCapacity=chmgrChanCapacity, chmgrChannelGroup=chmgrChannelGroup, chmgrTConnStatusLastChanged=chmgrTConnStatusLastChanged, chmgrOStatDcap1Entry=chmgrOStatDcap1Entry, chmgrTChanChannelId=chmgrTChanChannelId, chmgrOConnectionGroup=chmgrOConnectionGroup, chmgrODescrAcceptableMbps=chmgrODescrAcceptableMbps, chmgrODescrMinInterval=chmgrODescrMinInterval, chmgrOConnODescrIndex=chmgrOConnODescrIndex, chmgrODestinationTable=chmgrODestinationTable, Dst=Dst, chmgrTConnCustomerId=chmgrTConnCustomerId, chmgrOChannelEntry=chmgrOChannelEntry, chmgrODescrRequestedDcpVersion=chmgrODescrRequestedDcpVersion, chmgrODescrDestDsti=chmgrODescrDestDsti, chmgrODescrChanRowStatus=chmgrODescrChanRowStatus, chmgrChanNextHopMacAddress=chmgrChanNextHopMacAddress, chmgrTConnNumberOfChannels=chmgrTConnNumberOfChannels, chmgrOStatDcap1DiscardPackets=chmgrOStatDcap1DiscardPackets, chmgrChanSourceDsti=chmgrChanSourceDsti, chmgrTConnAllocatedSlotsChanged=chmgrTConnAllocatedSlotsChanged, chmgrODescrDestIndex=chmgrODescrDestIndex, chmgrOChanSourceRouteIndex=chmgrOChanSourceRouteIndex, chmgrTConnSourceDsti=chmgrTConnSourceDsti, chmgrTStatDcap1Entry=chmgrTStatDcap1Entry, chmgrTStatPMReferenceEntry=chmgrTStatPMReferenceEntry, chmgrTConnDestinationAddress=chmgrTConnDestinationAddress, chmgrOStatDcap1Load=chmgrOStatDcap1Load, chmgrOChanStatusChanged=chmgrOChanStatusChanged, chmgrSourceRouteHopEntry=chmgrSourceRouteHopEntry, chmgrTConnOperStatus=chmgrTConnOperStatus, chmgrODescrIndex=chmgrODescrIndex, chmgrODescrNextDestTableIndex=chmgrODescrNextDestTableIndex, chmgrChanDst=chmgrChanDst, chmgrTStatDcap1UtilizedBps=chmgrTStatDcap1UtilizedBps, chmgrOConnSourceAddress=chmgrOConnSourceAddress, chmgrOConnDcapType=chmgrOConnDcapType, netiChmgrMIB=netiChmgrMIB, chmgrOConnServiceReference=chmgrOConnServiceReference, chmgrSourceRouteHopIndex=chmgrSourceRouteHopIndex, chmgrODescriptionTable=chmgrODescriptionTable, chmgrODescrType=chmgrODescrType, chmgrODescriptionTimeStamp=chmgrODescriptionTimeStamp, chmgrChanChannelId=chmgrChanChannelId, chmgrTConnectionGroup=chmgrTConnectionGroup, chmgrTConnIndex=chmgrTConnIndex, chmgrOConnIndex=chmgrOConnIndex, chmgrODestDestinationDsti=chmgrODestDestinationDsti)

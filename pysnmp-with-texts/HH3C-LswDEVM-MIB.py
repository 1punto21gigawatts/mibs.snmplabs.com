#
# PySNMP MIB module HH3C-LswDEVM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-LswDEVM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:28:01 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
hh3cLswSlotIndex, hh3cLswFrameIndex = mibBuilder.importSymbols("HH3C-LSW-DEV-ADM-MIB", "hh3cLswSlotIndex", "hh3cLswFrameIndex")
hh3clswCommon, hh3cRhw = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3clswCommon", "hh3cRhw")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, Bits, Gauge32, TimeTicks, Unsigned32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Counter32, MibIdentifier, iso, Integer32, ObjectIdentity, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "Gauge32", "TimeTicks", "Unsigned32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Counter32", "MibIdentifier", "iso", "Integer32", "ObjectIdentity", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
hh3cLswdevMMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9))
hh3cLswdevMMib.setRevisions(('2001-06-29 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cLswdevMMib.setRevisionsDescriptions(('',))
if mibBuilder.loadTexts: hh3cLswdevMMib.setLastUpdated('200106290000Z')
if mibBuilder.loadTexts: hh3cLswdevMMib.setOrganization('Hangzhou H3C Tech. Co., Ltd.')
if mibBuilder.loadTexts: hh3cLswdevMMib.setContactInfo('Platform Team Hangzhou H3C Tech. Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085 ')
if mibBuilder.loadTexts: hh3cLswdevMMib.setDescription('')
hh3cDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 8))
hh3cCpuTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 8, 1), )
if mibBuilder.loadTexts: hh3cCpuTable.setStatus('current')
if mibBuilder.loadTexts: hh3cCpuTable.setDescription('A table of CPU statistics.')
hh3cCpuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 8, 1, 1), ).setIndexNames((0, "HH3C-LswDEVM-MIB", "hh3cCpuIndex"))
if mibBuilder.loadTexts: hh3cCpuEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cCpuEntry.setDescription('The Entries of hh3cCpuTable.')
hh3cCpuIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cCpuIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cCpuIndex.setDescription('Index of hh3cCpuTable. This integer is a uniq number to identify the CPU(s). We recommand two Number Plans in this paper, Logical Number or Phisical Number. For the first case, hh3cCpuIndex is a integer, range from 1 to the Maximum number, for example 1,2,3,4,5 ..., where 1 represents the first CPU, 2 represents the second CPU, etc. For the second case hh3cCpuIndex represents physical card position (Shelf Number, Frame Number, Slot Number, SubSlotNumber) where the CPU residing, for example, 0x01020304 represent the CPU on the 4th subslot of the 3th slot of the 2nd frame of the 1st Shelf. In the condition of multiple CPU system where CPU group coordinately process on one board, we see the CPUs as one CPU')
hh3cCpuCostRate = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCpuCostRate.setStatus('current')
if mibBuilder.loadTexts: hh3cCpuCostRate.setDescription('The overall CPU busy percentage in the last 5 second period. ')
hh3cCpuCostRatePer1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCpuCostRatePer1Min.setStatus('current')
if mibBuilder.loadTexts: hh3cCpuCostRatePer1Min.setDescription('The overall CPU cost percentage in the last 1 minute period. ')
hh3cCpuCostRatePer5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cCpuCostRatePer5Min.setStatus('current')
if mibBuilder.loadTexts: hh3cCpuCostRatePer5Min.setDescription('The overall CPU cost percentage in the last 5 minutes period. ')
hh3cMem = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2))
hh3cMemTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1), )
if mibBuilder.loadTexts: hh3cMemTable.setStatus('current')
if mibBuilder.loadTexts: hh3cMemTable.setDescription('This table contains memory information. ')
hh3cMemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1, 1), ).setIndexNames((0, "HH3C-LswDEVM-MIB", "hh3cMemModuleIndex"))
if mibBuilder.loadTexts: hh3cMemEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cMemEntry.setDescription('The Entries of hh3cMemTable')
hh3cMemModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cMemModuleIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cMemModuleIndex.setDescription('Index of hh3cMemTable. This integer is a uniq number to identify the memory module. We recommand two Number Plans in this paper, Logical Number or Phisical Number. For the first case, hh3cMemModuleIndex is a integer, range from 1 to the Maximum number, for example 1,2,3,4,5 ..., where 1 represents the first memory module, 2 represents the second memory module, etc. For the second case hh3cMemModuleIndex represents physical card position (Shelf Number, Frame Number, Slot Number, SubSlotNumber) where the memory module residing, for example, 0x01020304 represent the memory module on the 4th subslot of the 3th slot of the 2nd frame of the 1st Shelf. ')
hh3cMemSize = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMemSize.setStatus('current')
if mibBuilder.loadTexts: hh3cMemSize.setDescription('Indicates the total size of the memory module which is on the managed object.')
hh3cMemFree = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMemFree.setStatus('current')
if mibBuilder.loadTexts: hh3cMemFree.setDescription('Indicates the free size of the memory')
hh3cMemRawSliceUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMemRawSliceUsed.setStatus('current')
if mibBuilder.loadTexts: hh3cMemRawSliceUsed.setDescription('Indicates the used size of the raw slice memory')
hh3cMemLgFree = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMemLgFree.setStatus('current')
if mibBuilder.loadTexts: hh3cMemLgFree.setDescription('The largest free size of the contiguous area in the memory. The unit is byte.')
hh3cMemFail = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMemFail.setStatus('current')
if mibBuilder.loadTexts: hh3cMemFail.setDescription('The times of memory allocation failures')
hh3cMemFailNoMem = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cMemFailNoMem.setStatus('current')
if mibBuilder.loadTexts: hh3cMemFailNoMem.setDescription('The times of memory allocation failures due to no free memory.')
hh3cBufTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 2), )
if mibBuilder.loadTexts: hh3cBufTable.setStatus('current')
if mibBuilder.loadTexts: hh3cBufTable.setDescription('This table contains buffer information. ')
hh3cBufEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 2, 1), ).setIndexNames((0, "HH3C-LswDEVM-MIB", "hh3cBufModuleIndex"), (0, "HH3C-LswDEVM-MIB", "hh3cBufSize"))
if mibBuilder.loadTexts: hh3cBufEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cBufEntry.setDescription('The Entries of hh3cBufferTable')
hh3cBufModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: hh3cBufModuleIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cBufModuleIndex.setDescription('Index of hh3cBufferTable. This integer is a uniq number to identify the buffer module. We recommand two Number Plans in this paper, Logical Number or Phisical Number. For the first case, hh3cBufferModuleIndex is a integer, range from 1 to the Maximum number, for example 1,2,3,4,5 ..., where 1 represents the first buffer module, 2 represents the second buffer module, etc. For the second case hh3cBufferModuleIndex represents physical card position (Shelf Number, Frame Number, Slot Number, SubSlotNumber) where the buffer module residing, for example, 0x01020304 represent the buffer module on the 4th subslot of the 3th slot of the 2nd frame of the 1st Shelf. ')
hh3cBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 2, 1, 2), Integer32())
if mibBuilder.loadTexts: hh3cBufSize.setStatus('current')
if mibBuilder.loadTexts: hh3cBufSize.setDescription('The size of buffer,unit is byte.')
hh3cBufCurrentTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBufCurrentTotal.setStatus('current')
if mibBuilder.loadTexts: hh3cBufCurrentTotal.setDescription('The total number of buffer currently.')
hh3cBufCurrentUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 8, 2, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cBufCurrentUsed.setStatus('current')
if mibBuilder.loadTexts: hh3cBufCurrentUsed.setDescription('The number of used buffer currently.')
hh3cFlh = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 8, 8, 3))
hh3cFlhTotalSize = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 8, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhTotalSize.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhTotalSize.setDescription("The flash memory's total size, in kilobyte")
hh3cFlhTotalFree = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 8, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhTotalFree.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhTotalFree.setDescription('The free space in internal flash memory, in kilobyte')
hh3cFlhLastDelTime = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 8, 3, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhLastDelTime.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhLastDelTime.setDescription('The time since system up of the lastest deleting operation of flash memory.The value of Zero indicates there is no erasing operation since system up')
hh3cFlhDelState = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 8, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("executing", 1), ("ok", 2), ("error", 3), ("readOnly", 4), ("failtoopen", 5), ("blockMallocFail", 6), ("noneDelOperationSinceStart", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhDelState.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhDelState.setDescription('The state indicates the result of current or lastest flash memory deleting operation')
hh3cFlhState = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 8, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("busy", 1), ("free", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cFlhState.setStatus('current')
if mibBuilder.loadTexts: hh3cFlhState.setDescription('Busy indicates the flash memory is unavailable due to others may be using it, and free indicates the flash memory is available now')
hh3cLswdevMMibObject = ObjectIdentity((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1))
if mibBuilder.loadTexts: hh3cLswdevMMibObject.setStatus('current')
if mibBuilder.loadTexts: hh3cLswdevMMibObject.setDescription('Description.')
hh3cdevMFanStatusTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 1), )
if mibBuilder.loadTexts: hh3cdevMFanStatusTable.setStatus('current')
if mibBuilder.loadTexts: hh3cdevMFanStatusTable.setDescription(' Fan status description table ')
hh3cdevMFanStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 1, 1), ).setIndexNames((0, "HH3C-LswDEVM-MIB", "hh3cDevMFanNum"))
if mibBuilder.loadTexts: hh3cdevMFanStatusEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cdevMFanStatusEntry.setDescription(' Fan status description table entry ')
hh3cDevMFanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDevMFanNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDevMFanNum.setDescription(' Fan number ')
hh3cDevMFanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("deactive", 2), ("not-install", 3), ("unsupport", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDevMFanStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDevMFanStatus.setDescription(' Fan status: active (1), deactive (2) not installed (3) and unsupported (4)')
hh3cdevMPowerStatusTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 2), )
if mibBuilder.loadTexts: hh3cdevMPowerStatusTable.setStatus('current')
if mibBuilder.loadTexts: hh3cdevMPowerStatusTable.setDescription(' Power status description table ')
hh3cdevMPowerStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 2, 1), ).setIndexNames((0, "HH3C-LswDEVM-MIB", "hh3cDevMPowerNum"))
if mibBuilder.loadTexts: hh3cdevMPowerStatusEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cdevMPowerStatusEntry.setDescription(' Power status description table entry ')
hh3cDevMPowerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDevMPowerNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDevMPowerNum.setDescription('Power number ')
hh3cDevMPowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("deactive", 2), ("not-install", 3), ("unsupport", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDevMPowerStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDevMPowerStatus.setDescription(' Power status: active (1), deactive (2) not installed (3) and unsupported ')
hh3cdevMSlotEnvironmentTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 3), )
if mibBuilder.loadTexts: hh3cdevMSlotEnvironmentTable.setStatus('current')
if mibBuilder.loadTexts: hh3cdevMSlotEnvironmentTable.setDescription(' environment description table ')
hh3cdevMSlotEnvironmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 3, 1), ).setIndexNames((0, "HH3C-LSW-DEV-ADM-MIB", "hh3cLswFrameIndex"), (0, "HH3C-LSW-DEV-ADM-MIB", "hh3cLswSlotIndex"), (0, "HH3C-LswDEVM-MIB", "hh3cdevMSlotEnvironmentType"))
if mibBuilder.loadTexts: hh3cdevMSlotEnvironmentEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cdevMSlotEnvironmentEntry.setDescription(' environment description table entry ')
hh3cdevMSlotEnvironmentType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("temperature", 1), ("humidity", 2), ("fog", 3))))
if mibBuilder.loadTexts: hh3cdevMSlotEnvironmentType.setStatus('current')
if mibBuilder.loadTexts: hh3cdevMSlotEnvironmentType.setDescription('Environment type ')
hh3cDevMSlotEnvironmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("upper", 2), ("lower", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDevMSlotEnvironmentStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDevMSlotEnvironmentStatus.setDescription(' Environment status')
hh3cDevMSlotEnvironmentValue = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDevMSlotEnvironmentValue.setStatus('current')
if mibBuilder.loadTexts: hh3cDevMSlotEnvironmentValue.setDescription(' Environment value')
hh3cDevMSlotEnvironmentUpperLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDevMSlotEnvironmentUpperLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cDevMSlotEnvironmentUpperLimit.setDescription('Environment upper limit ')
hh3cDevMSlotEnvironmentLowerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDevMSlotEnvironmentLowerLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cDevMSlotEnvironmentLowerLimit.setDescription(' Environment Lower limit')
hh3cLinkUpDownTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enableBoth", 1), ("disableBoth", 2), ("enableLinkUpTrapOnly", 3), ("enableLinkDownTrapOnly", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cLinkUpDownTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hh3cLinkUpDownTrapEnable.setDescription('Enable/Disable linkUp/linkDown traps of the device, determining whether to enable linkUp/linkDown traps with that of the interface. When the value is enableBoth(1), the linkUp/linkDown traps are both enabled. When the value is disableBoth(2), the linkUp/linkDown traps are both disabled. When the value is enableLinkUpTrapOnly(3), the linkUp traps is enabled and the linkDown traps is disabled. When the value is enableLinkDownTrapOnly(4), the linkUp traps is disabled and the linkDown traps is enabled. ')
hh3cdot1qTpFdbLearnStatus = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cdot1qTpFdbLearnStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cdot1qTpFdbLearnStatus.setDescription(' Enable/Disable the address learning.')
hh3cCfmWriteFlash = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("write", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cCfmWriteFlash.setStatus('current')
if mibBuilder.loadTexts: hh3cCfmWriteFlash.setDescription(' Write the current effective configuration into the Flash memory. This object does not support read operation.')
hh3cCfmEraseFlash = MibScalar((1, 3, 6, 1, 4, 1, 25506, 8, 35, 9, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("erase", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cCfmEraseFlash.setStatus('current')
if mibBuilder.loadTexts: hh3cCfmEraseFlash.setDescription(' Delete the configuration from the Flash memory. This object does not support read operation.')
mibBuilder.exportSymbols("HH3C-LswDEVM-MIB", hh3cBufSize=hh3cBufSize, hh3cdevMPowerStatusEntry=hh3cdevMPowerStatusEntry, hh3cDevMPowerNum=hh3cDevMPowerNum, hh3cMem=hh3cMem, hh3cCpuEntry=hh3cCpuEntry, hh3cMemSize=hh3cMemSize, hh3cdevMFanStatusTable=hh3cdevMFanStatusTable, hh3cDevMFanStatus=hh3cDevMFanStatus, hh3cBufEntry=hh3cBufEntry, hh3cDevMFanNum=hh3cDevMFanNum, hh3cCpuCostRatePer5Min=hh3cCpuCostRatePer5Min, hh3cFlhState=hh3cFlhState, hh3cBufCurrentTotal=hh3cBufCurrentTotal, hh3cdevMSlotEnvironmentTable=hh3cdevMSlotEnvironmentTable, hh3cBufTable=hh3cBufTable, hh3cCfmWriteFlash=hh3cCfmWriteFlash, hh3cFlhTotalSize=hh3cFlhTotalSize, hh3cCpuIndex=hh3cCpuIndex, hh3cdevMPowerStatusTable=hh3cdevMPowerStatusTable, hh3cMemFree=hh3cMemFree, hh3cMemEntry=hh3cMemEntry, hh3cDevice=hh3cDevice, hh3cCfmEraseFlash=hh3cCfmEraseFlash, hh3cFlhDelState=hh3cFlhDelState, hh3cdevMSlotEnvironmentType=hh3cdevMSlotEnvironmentType, hh3cDevMSlotEnvironmentUpperLimit=hh3cDevMSlotEnvironmentUpperLimit, hh3cdot1qTpFdbLearnStatus=hh3cdot1qTpFdbLearnStatus, hh3cMemLgFree=hh3cMemLgFree, hh3cDevMSlotEnvironmentLowerLimit=hh3cDevMSlotEnvironmentLowerLimit, hh3cCpuTable=hh3cCpuTable, hh3cBufCurrentUsed=hh3cBufCurrentUsed, hh3cMemFailNoMem=hh3cMemFailNoMem, hh3cMemRawSliceUsed=hh3cMemRawSliceUsed, hh3cLswdevMMibObject=hh3cLswdevMMibObject, hh3cDevMPowerStatus=hh3cDevMPowerStatus, hh3cDevMSlotEnvironmentStatus=hh3cDevMSlotEnvironmentStatus, hh3cDevMSlotEnvironmentValue=hh3cDevMSlotEnvironmentValue, hh3cCpuCostRate=hh3cCpuCostRate, hh3cMemFail=hh3cMemFail, hh3cBufModuleIndex=hh3cBufModuleIndex, hh3cMemModuleIndex=hh3cMemModuleIndex, hh3cCpuCostRatePer1Min=hh3cCpuCostRatePer1Min, hh3cFlhLastDelTime=hh3cFlhLastDelTime, hh3cdevMFanStatusEntry=hh3cdevMFanStatusEntry, hh3cLinkUpDownTrapEnable=hh3cLinkUpDownTrapEnable, hh3cdevMSlotEnvironmentEntry=hh3cdevMSlotEnvironmentEntry, hh3cMemTable=hh3cMemTable, hh3cLswdevMMib=hh3cLswdevMMib, PYSNMP_MODULE_ID=hh3cLswdevMMib, hh3cFlhTotalFree=hh3cFlhTotalFree, hh3cFlh=hh3cFlh)

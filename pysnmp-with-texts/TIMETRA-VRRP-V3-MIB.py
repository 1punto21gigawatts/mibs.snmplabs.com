#
# PySNMP MIB module TIMETRA-VRRP-V3-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TIMETRA-VRRP-V3-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:23:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
IpAddress, Bits, ObjectIdentity, Unsigned32, Counter32, MibIdentifier, Gauge32, iso, Counter64, ModuleIdentity, NotificationType, Integer32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Bits", "ObjectIdentity", "Unsigned32", "Counter32", "MibIdentifier", "Gauge32", "iso", "Counter64", "ModuleIdentity", "NotificationType", "Integer32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
StorageType, RowStatus, TimeStamp, MacAddress, TimeInterval, DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "RowStatus", "TimeStamp", "MacAddress", "TimeInterval", "DisplayString", "TextualConvention", "TruthValue")
timetraSRMIBModules, = mibBuilder.importSymbols("TIMETRA-GLOBAL-MIB", "timetraSRMIBModules")
vrrpOperations, vrrpNotifications, vrrpStatistics, VrId, vrrpMIBCompliances, vrrpMIBGroups = mibBuilder.importSymbols("VRRP-MIB", "vrrpOperations", "vrrpNotifications", "vrrpStatistics", "VrId", "vrrpMIBCompliances", "vrrpMIBGroups")
timetraVrrpV3MibModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 57))
timetraVrrpV3MibModule.setRevisions(('1909-02-28 00:00', '2008-04-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: timetraVrrpV3MibModule.setRevisionsDescriptions(('Rev 7.0 28 Feb 2009 00:00 7.0 release of the TIMETRA-VRRP-V3-MIB.', 'This MIB describes objects used for managing Virtual Router Redundancy Protocol (VRRP) routers routers using version 3 of the VRRP protocol over IPv6. Initial version as published in RFC 2787.',))
if mibBuilder.loadTexts: timetraVrrpV3MibModule.setLastUpdated('0902280000Z')
if mibBuilder.loadTexts: timetraVrrpV3MibModule.setOrganization('Alcatel-Lucent')
if mibBuilder.loadTexts: timetraVrrpV3MibModule.setContactInfo('Alcatel-Lucent 7x50 Support Web: http://support.alcatel-lucent.com')
if mibBuilder.loadTexts: timetraVrrpV3MibModule.setDescription("This MIB is based on the draft-ietf-vrrp-unified-mib-06.txt and describes objects used for managing Virtual Router Redundancy Protocol (VRRP) over IPv6 protocol. A separate VRRP-MIB based on RFC2787 describes objects used for managing VRRP over IPv4 protocol. This MIB is subject to draft revisions and will be updated when an RFC number is assigned to it. Copyright (c) 2008-2011 Alcatel-Lucent. All rights reserved. Reproduction of this document is authorized on the condition that the foregoing copyright notice is included. This SNMP MIB module (Specification) embodies Alcatel-Lucent's proprietary intellectual property. Alcatel-Lucent retains all title and ownership in the Specification, including any revisions. Alcatel-Lucent grants all interested parties a non-exclusive license to use and distribute an unmodified copy of this Specification in connection with management of Alcatel-Lucent products, and without fee, provided this copyright notice and license appear on all copies. This Specification is supplied 'as is', and Alcatel-Lucent makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification.")
vrrpOperationsTable = MibTable((1, 3, 6, 1, 2, 1, 68, 1, 7), )
if mibBuilder.loadTexts: vrrpOperationsTable.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsTable.setDescription("Unified Operations table for a VRRP router which consists of a sequence (i.e., one or more conceptual rows) of 'vrrpOperationsEntry' items which describe the operational characteristics of a virtual router.")
vrrpOperationsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 68, 1, 7, 1), ).setIndexNames((0, "TIMETRA-VRRP-V3-MIB", "vrrpOperationsInetAddrType"), (0, "TIMETRA-VRRP-V3-MIB", "vrrpOperationsVrId"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: vrrpOperationsEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsEntry.setDescription("An entry in the vrrpOperationsTable containing the operational characteristics of a virtual router. On a VRRP router, a given virtual router is identified by a combination of the IP version, VRID and ifIndex. ifIndex represents a physical interface of the router. Note that rows in this table can be distinguished on a multi-stacked device running VRRP over IPv4 and IPv6 on the same physical interface. Rows in the table cannot be modified unless the value of 'vrrpOperationsState' has transitioned to 'initialize'")
vrrpOperationsInetAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 1), InetAddressType())
if mibBuilder.loadTexts: vrrpOperationsInetAddrType.setReference('RFC 4001')
if mibBuilder.loadTexts: vrrpOperationsInetAddrType.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsInetAddrType.setDescription('The IP address type of VrrpOperationsEntry. This value applies to both vrrpOperationsMasterIpAddr and vrrpOperationsPrimaryIpAddr.')
vrrpOperationsVrId = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 2), VrId())
if mibBuilder.loadTexts: vrrpOperationsVrId.setReference('RFC 4001')
if mibBuilder.loadTexts: vrrpOperationsVrId.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsVrId.setDescription('This object contains the Virtual Router Identifier (VRID).')
vrrpOperationsVirtualMacAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpOperationsVirtualMacAddr.setReference('STD 58 RFC 2578')
if mibBuilder.loadTexts: vrrpOperationsVirtualMacAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsVirtualMacAddr.setDescription("The virtual MAC address of the virtual router. Although this object can be derived from the 'vrrpOperationsVrId' object, it is defined so that it is easily obtainable by a management application and can be included in VRRP-related SNMP notifications.")
vrrpOperationsState = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("initialize", 1), ("backup", 2), ("master", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpOperationsState.setReference(' RFC 3768')
if mibBuilder.loadTexts: vrrpOperationsState.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsState.setDescription("The current state of the virtual router. This object has three defined values: - `initialize', which indicates that the virtual router is waiting for a startup event. - `backup', which indicates the virtual router is monitoring the availability of the master router. - `master', which indicates that the virtual router is forwarding packets for IP addresses that are associated with this router.")
vrrpOperationsPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpOperationsPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsPriority.setDescription("This object specifies the priority to be used for the virtual router master election process. Higher values imply higher priority. A priority of '0', although not settable, is sent by the master router to indicate that this router has ceased to participate in VRRP and a backup virtual router should transition to become a new master. A priority of 255 is used for the router that owns the associated IP address(es) for VRRP over IPv4 and hence not settable. A 'badValue(3)' should be returned when a user tries to set 0 or 255 for this object. ")
vrrpOperationsAddrCount = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpOperationsAddrCount.setReference('RFC 3768 section 5.3.5. Count IP Addrs')
if mibBuilder.loadTexts: vrrpOperationsAddrCount.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsAddrCount.setDescription('The number of IP addresses that are associated with this virtual router. This number is equal to the number of rows in the vrrpAssociatedIpAddrTable that correspond to a given IP version/VRID/ifIndex.')
vrrpOperationsMasterIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpOperationsMasterIpAddr.setReference(' RFC 3768')
if mibBuilder.loadTexts: vrrpOperationsMasterIpAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsMasterIpAddr.setDescription("The master router's real IP address. Master router would set this address to vrrpOperationsPrimaryIpAddr while transitioning to master state. For backup routers, this is the IP address listed as the source in VRRP advertisement last received by this virtual router.")
vrrpOperationsPrimaryIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 8), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpOperationsPrimaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsPrimaryIpAddr.setDescription("In the case where there are more than one IP Address (associated IP addresses) for a given `ifIndex', this object is used to specify the IP address that will become the 'vrrpOperationsMasterIpAddr', should the virtual router transition from backup state to master.")
vrrpOperationsAdvInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 9), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(100)).setUnits('centiseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpOperationsAdvInterval.setReference(' RFC 3768 section 5.3.7')
if mibBuilder.loadTexts: vrrpOperationsAdvInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsAdvInterval.setDescription('The time interval, in centiseconds, between sending advertisement messages. Only the master router sends VRRP advertisements.')
vrrpOperationsPreemptMode = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 10), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpOperationsPreemptMode.setReference(' RFC 3768 section 6.1')
if mibBuilder.loadTexts: vrrpOperationsPreemptMode.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsPreemptMode.setDescription('Controls whether a higher priority virtual router will preempt a lower priority master.')
vrrpOperationsAcceptMode = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpOperationsAcceptMode.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsAcceptMode.setDescription("Controls whether a virtual router in Master state will accept packets addressed to the address owner's IPv6 address as its own if it is not the IPv6 address owner. Default is False. This object is not relevant for rows representing VRRP over IPv4 and should be set to false.")
vrrpOperationsUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpOperationsUpTime.setReference(' RFC 3768 section 6.1')
if mibBuilder.loadTexts: vrrpOperationsUpTime.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsUpTime.setDescription("This is the value of the `sysUpTime' object when this virtual router (i.e., the `vrrpOperationsState') transitioned out of `initialized'.")
vrrpOperationsStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 13), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpOperationsStorageType.setReference(' RFC4181 section 4.6.4')
if mibBuilder.loadTexts: vrrpOperationsStorageType.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsStorageType.setDescription('The storage type for this conceptual row. Write access is not required. It is optional to support nonVolatile StorageType enumeration.')
vrrpOperationsRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 7, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpOperationsRowStatus.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsRowStatus.setDescription("The RowStatus variable should be used in accordance to installation and removal conventions for conceptual rows. When `vrrpOperationsRowStatus' is set to active(1), no other objects in the conceptual row can be modified. To create a row in this table, a manager sets this object to either createAndGo(4) or createAndWait(5). Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the `vrrpOperationsRowStatus' column will be read as notReady(3). In particular, a newly created row cannot be made active(1) until (minimally) the corresponding instance of vrrpOperationsInetAddrType, vrrpOperationsVrId and vrrpOperationsPrimaryIpAddr has been set and there is at least one active row in the `vrrpAssociatedIpAddrTable' defining an associated IP address. notInService(2) should be used to administratively bring the row down. A typical order of operation to add a row is: 1. Create a row in vrrpOperationsTable with createAndWait(5). 2. Create one or more corresponding rows in vrrpAssociatedIpAddrTable. 3. Populate the vrrpOperationsEntry. 4. set vrrpOperationsRowStatus to active(1). A typical order of operation to delete an entry is: 1. Set vrrpOperationsRowStatus to notInService(2). 2. Set the corresponding rows in vrrpAssociatedIpAddrTable to destroy(6) to delete the entry. 3. set vrrpOperationsRowStatus to destroy(6) to delete the entry.")
vrrpAssociatedIpAddrTable = MibTable((1, 3, 6, 1, 2, 1, 68, 1, 8), )
if mibBuilder.loadTexts: vrrpAssociatedIpAddrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpAssociatedIpAddrTable.setDescription('The table of addresses associated with this virtual router.')
vrrpAssociatedIpAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 68, 1, 8, 1), ).setIndexNames((0, "TIMETRA-VRRP-V3-MIB", "vrrpOperationsInetAddrType"), (0, "TIMETRA-VRRP-V3-MIB", "vrrpOperationsVrId"), (0, "IF-MIB", "ifIndex"), (0, "TIMETRA-VRRP-V3-MIB", "vrrpAssociatedIpAddr"))
if mibBuilder.loadTexts: vrrpAssociatedIpAddrEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpAssociatedIpAddrEntry.setDescription("An entry in the table contains an IP address that is associated with a virtual router. The number of rows for a given IP version, vrrpOperationsVrId and ifIndex will equal the number of IP addresses associated (e.g., backed up) by the virtual router (equivalent to 'vrrpOperationsIpAddrCount'). Rows in the table cannot be modified unless the value of `vrrpOperationsState' has transitioned to `initialize'.")
vrrpAssociatedIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 8, 1, 1), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: vrrpAssociatedIpAddr.setReference('RFC 3768 Section 5.3.9')
if mibBuilder.loadTexts: vrrpAssociatedIpAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpAssociatedIpAddr.setDescription('The assigned IP addresses that a virtual router is responsible for backing up. The size of this object is either 4 or 16 depending on vrrpOperationsInetAddrType.')
vrrpAssociatedStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 8, 1, 2), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpAssociatedStorageType.setReference(' RFC4181 section 4.6.4')
if mibBuilder.loadTexts: vrrpAssociatedStorageType.setStatus('current')
if mibBuilder.loadTexts: vrrpAssociatedStorageType.setDescription('The storage type for this conceptual row. Write access is not required. It is optional to support nonVolatile StorageType enumeration.')
vrrpAssociatedIpAddrRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 1, 8, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpAssociatedIpAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: vrrpAssociatedIpAddrRowStatus.setDescription('The RowStatus variable, used according to installation and removal conventions for conceptual rows. To create a row in this table, a manager sets this object to either createAndGo(4) or createAndWait(5). Setting this object to active(1) results in the addition of an associated address for a virtual router. Setting this object to notInService(2) results in administratively bringing down the row. Destroying the entry or setting it to destroy(6) removes the associated address from the virtual router. The use of other values is implementation-dependent. Only vrrpAssociatedStorageType can be modified when the row is in active(1) state for Implementations supporting write access to vrrpAssociatedStorageType Implementations should not allow deletion of the last row corresponding to an active row in vrrpOperationsTable. Refer to description of vrrpOperationsRowStatus for a typical row creation and deletion scenarios.')
vrrpRouterStatisticsTable = MibTable((1, 3, 6, 1, 2, 1, 68, 2, 5), )
if mibBuilder.loadTexts: vrrpRouterStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: vrrpRouterStatisticsTable.setDescription('Table of virtual router statistics.')
vrrpRouterStatisticsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 68, 2, 5, 1), )
vrrpOperationsEntry.registerAugmentions(("TIMETRA-VRRP-V3-MIB", "vrrpRouterStatisticsEntry"))
vrrpRouterStatisticsEntry.setIndexNames(*vrrpOperationsEntry.getIndexNames())
if mibBuilder.loadTexts: vrrpRouterStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpRouterStatisticsEntry.setDescription('An entry in the table, containing statistics information about a given virtual router.')
vrrpStatisticsMasterTransitions = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsMasterTransitions.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsMasterTransitions.setDescription("The total number of times that this virtual router's state has transitioned to MASTER. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.")
vrrpStatisticsRcvdAdvertisements = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsRcvdAdvertisements.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsRcvdAdvertisements.setDescription('The total number of VRRP advertisements received by this virtual router. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.')
vrrpStatisticsAdvIntervalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsAdvIntervalErrors.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsAdvIntervalErrors.setDescription('The total number of VRRP advertisement packets received for which the advertisement interval is different than the one configured for the local virtual router. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.')
vrrpStatisticsIpTtlErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsIpTtlErrors.setReference('RFC3768 Section 5.2.3')
if mibBuilder.loadTexts: vrrpStatisticsIpTtlErrors.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsIpTtlErrors.setDescription('The total number of VRRP packets received by the Virtual router with IPv4 TTL (for VRRP over IPv4) or IPv6 Hop Limit (for VRRP over IPv6) not equal to 255. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.')
vrrpStatisticsRcvdPriZeroPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsRcvdPriZeroPackets.setReference('RFC3768 Section 5.3.4')
if mibBuilder.loadTexts: vrrpStatisticsRcvdPriZeroPackets.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsRcvdPriZeroPackets.setDescription("The total number of VRRP packets received by the virtual router with a priority of '0'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.")
vrrpStatisticsSentPriZeroPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsSentPriZeroPackets.setReference('RFC3768 Section 5.3.4')
if mibBuilder.loadTexts: vrrpStatisticsSentPriZeroPackets.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsSentPriZeroPackets.setDescription("The total number of VRRP packets sent by the virtual router with a priority of '0'. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.")
vrrpStatisticsRcvdInvalidTypePkts = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsRcvdInvalidTypePkts.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsRcvdInvalidTypePkts.setDescription("The number of VRRP packets received by the virtual router with an invalid value in the 'type' field. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.")
vrrpStatisticsAddressListErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsAddressListErrors.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsAddressListErrors.setDescription('The total number of packets received for which the address list does not match the locally configured list for the virtual router. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.')
vrrpStatisticsPacketLengthErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsPacketLengthErrors.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsPacketLengthErrors.setDescription('The total number of packets received with a packet length less than the length of the VRRP header. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of vrrpStatisticsDiscontinuityTime.')
vrrpStatisticsRcvdInvalidAuthentications = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsRcvdInvalidAuthentications.setReference('RFC3768 Section 5.3.6')
if mibBuilder.loadTexts: vrrpStatisticsRcvdInvalidAuthentications.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsRcvdInvalidAuthentications.setDescription('The total number of packets received with an unknown authentication type.')
vrrpStatisticsDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this entry's counters suffered a discontinuity. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
vrrpStatisticsRefreshRate = MibTableColumn((1, 3, 6, 1, 2, 1, 68, 2, 5, 1, 12), Unsigned32()).setUnits('milli-seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatisticsRefreshRate.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsRefreshRate.setDescription('The minimum reasonable polling interval for this entry. This object provides an indication of the minimum Amount of time required to update the counters in this entry.')
vrrpNewMasterReason = MibScalar((1, 3, 6, 1, 2, 1, 68, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notmaster", 0), ("priority", 1), ("preempted", 2), ("masterNoResponse", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewMasterReason.setStatus('current')
if mibBuilder.loadTexts: vrrpNewMasterReason.setDescription('This indicates the reason for tVrrpTrapNewMaster trap. Used by tVrrpTrapNewMaster trap. The object can be polled if the tVrrpTrapNewMaster trap is lost to identify the reason for transmission. Backup router should return notmaster(0) when pooled. ')
vrrpTrapProtoErrReason = MibScalar((1, 3, 6, 1, 2, 1, 68, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("hopLimitError", 0), ("versionError", 1), ("checksumError", 2), ("vridError", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: vrrpTrapProtoErrReason.setStatus('current')
if mibBuilder.loadTexts: vrrpTrapProtoErrReason.setDescription('This indicates the reason for protocol error trap. Used by vrrpTrapProtoError trap.')
vrrpTrapProtoError = NotificationType((1, 3, 6, 1, 2, 1, 68, 0, 3)).setObjects(("TIMETRA-VRRP-V3-MIB", "vrrpTrapProtoErrReason"))
if mibBuilder.loadTexts: vrrpTrapProtoError.setStatus('current')
if mibBuilder.loadTexts: vrrpTrapProtoError.setDescription('The error trap indicates that the sending agent has encountered the protocol error indicated by vrrpTrapProtoErrReason.')
vrrpModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 68, 3, 1, 2)).setObjects(("TIMETRA-VRRP-V3-MIB", "vrrpOperationsGroup"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsGroup"), ("TIMETRA-VRRP-V3-MIB", "vrrpTrapInfoGroup"), ("TIMETRA-VRRP-V3-MIB", "vrrpNotificationsGroup"), ("TIMETRA-VRRP-V3-MIB", "vrrpNotifyObjsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    vrrpModuleFullCompliance = vrrpModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: vrrpModuleFullCompliance.setDescription('The compliance statement for both VRRP for IPv4 and VRRP for IPv6 implementations.')
vrrpModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 68, 3, 1, 3)).setObjects(("TIMETRA-VRRP-V3-MIB", "vrrpOperationsGroup"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsGroup"), ("TIMETRA-VRRP-V3-MIB", "vrrpTrapInfoGroup"), ("TIMETRA-VRRP-V3-MIB", "vrrpNotificationsGroup"), ("TIMETRA-VRRP-V3-MIB", "vrrpNotifyObjsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    vrrpModuleReadOnlyCompliance = vrrpModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: vrrpModuleReadOnlyCompliance.setDescription('When this MIB is implemented without support for read- create (i.e. in read-only mode), then such an implementation can claim read-only compliance. Such a device can then be monitored but can not be configured with this MIB.')
vrrpOperationsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 68, 3, 2, 5)).setObjects(("TIMETRA-VRRP-V3-MIB", "vrrpOperationsVirtualMacAddr"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsState"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsPriority"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsMasterIpAddr"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsAdvInterval"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsPreemptMode"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsAcceptMode"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsUpTime"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsStorageType"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsRowStatus"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsAddrCount"), ("TIMETRA-VRRP-V3-MIB", "vrrpOperationsPrimaryIpAddr"), ("TIMETRA-VRRP-V3-MIB", "vrrpAssociatedStorageType"), ("TIMETRA-VRRP-V3-MIB", "vrrpAssociatedIpAddrRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    vrrpOperationsGroup = vrrpOperationsGroup.setStatus('current')
if mibBuilder.loadTexts: vrrpOperationsGroup.setDescription('Conformance group for VRRP over IPv4 and IPv6 operations.')
vrrpStatisticsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 68, 3, 2, 6)).setObjects(("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsMasterTransitions"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsRcvdAdvertisements"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsAdvIntervalErrors"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsRcvdPriZeroPackets"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsSentPriZeroPackets"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsRcvdInvalidTypePkts"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsIpTtlErrors"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsAddressListErrors"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsPacketLengthErrors"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsRcvdInvalidAuthentications"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsDiscontinuityTime"), ("TIMETRA-VRRP-V3-MIB", "vrrpStatisticsRefreshRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    vrrpStatisticsGroup = vrrpStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: vrrpStatisticsGroup.setDescription('Conformance group for VRRP over IPv4 and IPv6 statistics.')
vrrpTrapInfoGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 68, 3, 2, 7)).setObjects(("TIMETRA-VRRP-V3-MIB", "vrrpNewMasterReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    vrrpTrapInfoGroup = vrrpTrapInfoGroup.setStatus('current')
if mibBuilder.loadTexts: vrrpTrapInfoGroup.setDescription('Conformance group for objects contained in VRRP notifications.')
vrrpNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 68, 3, 2, 8)).setObjects(("TIMETRA-VRRP-V3-MIB", "vrrpTrapProtoError"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    vrrpNotificationsGroup = vrrpNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: vrrpNotificationsGroup.setDescription('The VRRP MIB Notification Group.')
vrrpNotifyObjsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 68, 3, 2, 9)).setObjects(("TIMETRA-VRRP-V3-MIB", "vrrpTrapProtoErrReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    vrrpNotifyObjsGroup = vrrpNotifyObjsGroup.setStatus('current')
if mibBuilder.loadTexts: vrrpNotifyObjsGroup.setDescription('Conformance group for Notify objects contained in VRRP notifications.')
mibBuilder.exportSymbols("TIMETRA-VRRP-V3-MIB", vrrpStatisticsDiscontinuityTime=vrrpStatisticsDiscontinuityTime, timetraVrrpV3MibModule=timetraVrrpV3MibModule, vrrpOperationsPreemptMode=vrrpOperationsPreemptMode, vrrpTrapProtoError=vrrpTrapProtoError, vrrpModuleFullCompliance=vrrpModuleFullCompliance, vrrpOperationsPrimaryIpAddr=vrrpOperationsPrimaryIpAddr, vrrpOperationsAcceptMode=vrrpOperationsAcceptMode, vrrpRouterStatisticsTable=vrrpRouterStatisticsTable, vrrpOperationsUpTime=vrrpOperationsUpTime, vrrpOperationsPriority=vrrpOperationsPriority, vrrpStatisticsAddressListErrors=vrrpStatisticsAddressListErrors, vrrpAssociatedIpAddrTable=vrrpAssociatedIpAddrTable, vrrpOperationsState=vrrpOperationsState, vrrpOperationsAddrCount=vrrpOperationsAddrCount, vrrpAssociatedIpAddrEntry=vrrpAssociatedIpAddrEntry, vrrpStatisticsPacketLengthErrors=vrrpStatisticsPacketLengthErrors, vrrpOperationsVrId=vrrpOperationsVrId, vrrpTrapProtoErrReason=vrrpTrapProtoErrReason, vrrpOperationsRowStatus=vrrpOperationsRowStatus, vrrpOperationsInetAddrType=vrrpOperationsInetAddrType, vrrpTrapInfoGroup=vrrpTrapInfoGroup, vrrpNewMasterReason=vrrpNewMasterReason, vrrpStatisticsRcvdInvalidAuthentications=vrrpStatisticsRcvdInvalidAuthentications, vrrpStatisticsRcvdAdvertisements=vrrpStatisticsRcvdAdvertisements, vrrpStatisticsGroup=vrrpStatisticsGroup, vrrpRouterStatisticsEntry=vrrpRouterStatisticsEntry, vrrpOperationsTable=vrrpOperationsTable, vrrpStatisticsIpTtlErrors=vrrpStatisticsIpTtlErrors, PYSNMP_MODULE_ID=timetraVrrpV3MibModule, vrrpAssociatedIpAddrRowStatus=vrrpAssociatedIpAddrRowStatus, vrrpOperationsGroup=vrrpOperationsGroup, vrrpOperationsVirtualMacAddr=vrrpOperationsVirtualMacAddr, vrrpStatisticsSentPriZeroPackets=vrrpStatisticsSentPriZeroPackets, vrrpStatisticsAdvIntervalErrors=vrrpStatisticsAdvIntervalErrors, vrrpOperationsEntry=vrrpOperationsEntry, vrrpNotificationsGroup=vrrpNotificationsGroup, vrrpOperationsStorageType=vrrpOperationsStorageType, vrrpStatisticsRcvdPriZeroPackets=vrrpStatisticsRcvdPriZeroPackets, vrrpAssociatedIpAddr=vrrpAssociatedIpAddr, vrrpStatisticsMasterTransitions=vrrpStatisticsMasterTransitions, vrrpOperationsAdvInterval=vrrpOperationsAdvInterval, vrrpModuleReadOnlyCompliance=vrrpModuleReadOnlyCompliance, vrrpNotifyObjsGroup=vrrpNotifyObjsGroup, vrrpOperationsMasterIpAddr=vrrpOperationsMasterIpAddr, vrrpStatisticsRefreshRate=vrrpStatisticsRefreshRate, vrrpAssociatedStorageType=vrrpAssociatedStorageType, vrrpStatisticsRcvdInvalidTypePkts=vrrpStatisticsRcvdInvalidTypePkts)

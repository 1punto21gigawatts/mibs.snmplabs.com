#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-DpnRoutingMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-DpnRoutingMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
mscRtgIndex, mscRtg = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex", "mscRtg")
RowPointer, Unsigned32, Integer32, StorageType, DisplayString, RowStatus = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "RowPointer", "Unsigned32", "Integer32", "StorageType", "DisplayString", "RowStatus")
PassportCounter64, NonReplicated, AsciiString, AsciiStringIndex = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "PassportCounter64", "NonReplicated", "AsciiString", "AsciiStringIndex")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Gauge32, Unsigned32, Integer32, NotificationType, Counter32, IpAddress, Bits, TimeTicks, iso, ObjectIdentity, MibIdentifier, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Gauge32", "Unsigned32", "Integer32", "NotificationType", "Counter32", "IpAddress", "Bits", "TimeTicks", "iso", "ObjectIdentity", "MibIdentifier", "Counter64")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
dpnRoutingMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21))
mscRtgDpn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4))
mscRtgDpnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 1), )
if mibBuilder.loadTexts: mscRtgDpnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRowStatusTable.setDescription('This entry controls the addition and deletion of mscRtgDpn components.')
mscRtgDpnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"))
if mibBuilder.loadTexts: mscRtgDpnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpn component.')
mscRtgDpnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpn components. These components cannot be added nor deleted.')
mscRtgDpnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnStorageType.setDescription('This variable represents the storage type value for the mscRtgDpn tables.')
mscRtgDpnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscRtgDpnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnIndex.setDescription('This variable represents the index for the mscRtgDpn tables.')
mscRtgDpnProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11), )
if mibBuilder.loadTexts: mscRtgDpnProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnProvTable.setDescription('This group contains the provisioning data for the DpnAddressPlan. Attributes in this group must be set to allow the DpnAddressPlan component to function properly.')
mscRtgDpnProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"))
if mibBuilder.loadTexts: mscRtgDpnProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnProvEntry.setDescription('An entry in the mscRtgDpnProvTable.')
mscRtgDpnLogicalNetworkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLogicalNetworkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLogicalNetworkNumber.setDescription('This attribute specifies the Logical Network Number for the DpnAddressPlan. Since only one instance of this component can exist, this value is always set to one. It is provided here to be consistent with other address plans and so that it can be queried.')
mscRtgDpnRoutingId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnRoutingId.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRoutingId.setDescription('This attribute specifies the Routing Identifier (RID) associated with the Passport node. The RID is used to identify a group of one or more interconnected Passport nodes (called a subnet) supporting the transport of DPN traffic. Its value must be the same as that of the other Passport nodes in this subnet and different from that of all RMs and other Passport subnets in the network. The routingId must be set when a DpnAddressPlan component is configured on an Passport node. Changing the value of the routingId will cause the node to restart.')
mscRtgDpnModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1909))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnModuleId.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnModuleId.setDescription('This attribute specifies the Module Identifier (MID) associated with the Passport node. The MID is used to identify an Passport node supporting the transport of DPN traffic. Its value must be different from that of all MIDs assigned to Passport nodes in this RID subnet (interconnected Passport nodes sharing a RID) and AMs in clusters supported by this subnet. If routing zones are used, it must also be unique from all other MIDs in this zone. The moduleId must be set when a DpnAddressPlan component is configured on an Passport node. Changing the value of the moduleId will cause the node to restart.')
mscRtgDpnDelayMetricCutOff = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 250)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnDelayMetricCutOff.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnDelayMetricCutOff.setDescription('This attribute specifies the delay metric value beyond which a destination RID should be considered unreachable. That is, if a delay metric to a RID is equal to or greater than this value then the RID is considered to be unreachable in the delay class of service. Lowering this value has the effect of speeding up the detection of the loss of reachability to a RID. It also reduces the amount of Routing Table Update (RTU) traffic generated in this scenario. Care must be taken to ensure that the value chosen is big enough for the longest delay path in the network. This attribute is optional; a default of 128 is used when it is not set. It is recommended that all nodes in the network be provisioned with the same cut off value.')
mscRtgDpnThroughputMetricCutOff = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(128, 245)).clone(245)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnThroughputMetricCutOff.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnThroughputMetricCutOff.setDescription('This attribute specifies the throughput metric value beyond which a destination RID should be considered unreachable. That is, if a throughput metric to a RID is equal to or greater than this value then the RID will be considered to be unreachable in the throughput class of service. Lowering this value has the effect of speeding up the detection of the loss of reachability to a RID. It also reduces the amount of Routing Table Update (RTU) traffic generated in this scenario.Care must be taken to ensure that the value chosen is big enough for the longest throughput path in the network. This attribute is optional; a default of 245 is used when it is not set. It is recommended that all nodes in the network be provisioned with the same cut off value.')
mscRtgDpnForwardingPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("loadspread", 0), ("loadshare", 1), ("loadspreadFast", 2))).clone('loadspread')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnForwardingPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnForwardingPolicy.setDescription('This attribute specifies the forwarding policy used by packet forwarding to handle DPN traffic on a Passport module. When this attribute is set to loadshare, DPN traffic is shared among preferred links in a link group in proportion to the available bandwidth on each link; the traffic is not forwarded in an order- preserved manner and needs resequencing at the destination, but the available bandwidth in a link group is utilized efficiently. When this attribute is set to loadspread, DPN traffic is forwarded in an order-preserved manner along a randomly selected route; the traffic sticks to a particular link in a link group, and will not spill over to other links in the link group unless there is congestion on the selected link. When this attribute is set to loadspreadFast, DPN traffic is forwarded in an order-preserved manner along a randomly selected route; the traffic sticks to a particular link in a link group, and will not spill over to other links in the link group. Choosing this value may improve throughput but traffic may be discarded in the presence of congestion. It is recommended that all nodes in the network be provisioned with the same forwarding policy.')
mscRtgDpnDelayMetricRangeBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnDelayMetricRangeBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnDelayMetricRangeBoundary.setDescription('This attribute specifies the total path delay metric below which the variance value specified for delay COS and a low metric range is used, and at or above which the variance value specified for delay COS and a high metric range is used. This attribute defaults to 0, so that the variance value specified for delay COS and a high metric range is used for all delay paths. If this attribute is set to 2147483647, the variance value specified for delay COS and a low metric range is used for all delay paths.')
mscRtgDpnTputMetricRangeBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnTputMetricRangeBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnTputMetricRangeBoundary.setDescription('This attribute specifies the total path throughput metric below which the variance value specified for throughput COS and a low metric range is used, and at or above which the variance value specified for throughput COS and a high metric range is used. This attribute defaults to 0, so that the variance value specified for throughput COS and a high metric range is used for all delay paths. If this attribute is set to 2147483647, the variance value specified for throughput COS and a low metric range is used for all throughput paths.')
mscRtgDpnConStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 13), )
if mibBuilder.loadTexts: mscRtgDpnConStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnConStatsTable.setDescription('This group of attributes provides statistics about the behavior of the DpnAddressPlan component. The statistics concern the distribution of routing information, required to support the routing of DPN traffic, to all Passport nodes in the RID subnet.')
mscRtgDpnConStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"))
if mibBuilder.loadTexts: mscRtgDpnConStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnConStatsEntry.setDescription('An entry in the mscRtgDpnConStatsTable.')
mscRtgDpnControlPktTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnControlPktTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnControlPktTx.setDescription('This attribute counts the total number of internal Passport DPN control packets, originating from this node, sent to other Passport nodes in the RID subnet. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. The Packets received from a neighbor node and forwarded to other neighbors are not counted. The counter wraps around to zero when the maximum value is reached.')
mscRtgDpnControlPktRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnControlPktRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnControlPktRx.setDescription('This attribute counts the total number of internal Passport DPN control packets received from other Passport nodes in the RID subnet. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. The counter wraps around to zero when the maximum value is reached.')
mscRtgDpnControlBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnControlBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnControlBytesTx.setDescription('This attribute counts the total number of internal Passport DPN control packet bytes, originating from the node, sent to other Passport nodes in the RID subnet. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. Packet bytes received from a neighbor node and forwarded to other neighbors are not counted. The counter wraps around to zero when the maximum value is reached.')
mscRtgDpnControlBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnControlBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnControlBytesRx.setDescription('This attribute counts the total number of internal Passport DPN control packet bytes received from other Passport nodes in the RID subnet. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. The counter wraps around to zero when the maximum value is reached.')
mscRtgDpnOutOfSequencePkt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnOutOfSequencePkt.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnOutOfSequencePkt.setDescription('This attribute counts the total number of internal Passport DPN control packets received and rejected. These packets contained old sequence numbers. The packets contain DPN routing information required by the DpnAddressPlan component to support the transport of DPN traffic. The counter wraps around to zero when the maximum value is reached.')
mscRtgDpnFwdStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14), )
if mibBuilder.loadTexts: mscRtgDpnFwdStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnFwdStatsTable.setDescription('This group of attributes provides statistics for the traffic handled by DPN packet forwarding on this module. The statistics can be used to monitor the connectionless traffic profile on this module.')
mscRtgDpnFwdStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"))
if mibBuilder.loadTexts: mscRtgDpnFwdStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnFwdStatsEntry.setDescription('An entry in the mscRtgDpnFwdStatsTable.')
mscRtgDpnTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnTotalPackets.setDescription('This attribute counts the total number of delay and throughput packets handled by DPN packet forwarding on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnThroughputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnThroughputPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnThroughputPackets.setDescription('This attribute counts the throughput packets handled by DPN packet forwarding on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnDelayPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnDelayPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnDelayPackets.setDescription('This attribute counts the delay packets handled by DPN packet forwarding on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnNormalReliabilityPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnNormalReliabilityPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnNormalReliabilityPackets.setDescription('This attribute counts the normal reliability packets handled by DPN packet forwarding on this module when the forwardingPolicy attribute of Routing DpnAddressPlan is set to loadshare or loadspread. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnHighReliabilityPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnHighReliabilityPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnHighReliabilityPackets.setDescription('This attribute counts the high reliability packets handled by DPN packet forwarding on this module when the forwardingPolicy attribute of Routing DpnAddressPlan is set to loadshare or loadspread. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnDiscardNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnDiscardNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnDiscardNoRoute.setDescription('This attribute counts the packets discarded when DPN packet forwarding has failed to find a route to forward the packets on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnInterruptingPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnInterruptingPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnInterruptingPackets.setDescription('This attribute counts the total number of multimedia packets handled by DPN packet forwarding on this module. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnDiscardLpCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 14, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnDiscardLpCongested.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnDiscardLpCongested.setDescription('This attribute counts the packets that have been discarded by packet forwarding due to LP congestion on this module. A packet encounters LP congestion when there is insufficient shared memory. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnCallServerModuleRidsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 232), )
if mibBuilder.loadTexts: mscRtgDpnCallServerModuleRidsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCallServerModuleRidsTable.setDescription('This attribute indicates the RIDs of the Call Server Resource Modules (CSRMs) currently in use to support Call Server functions, such as SCR and DCR, for the Passport subnet. Up to two CSRMs can be in use to support such Call Server functions. Note that packets destined to Call Server functions are routed to the closest CSRM supporting the required server functionality.')
mscRtgDpnCallServerModuleRidsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 232, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCallServerModuleRidsValue"))
if mibBuilder.loadTexts: mscRtgDpnCallServerModuleRidsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCallServerModuleRidsEntry.setDescription('An entry in the mscRtgDpnCallServerModuleRidsTable.')
mscRtgDpnCallServerModuleRidsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 232, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 126))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCallServerModuleRidsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCallServerModuleRidsValue.setDescription('This variable represents both the value and the index for the mscRtgDpnCallServerModuleRidsTable.')
mscRtgDpnSubnetMidsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 233), )
if mibBuilder.loadTexts: mscRtgDpnSubnetMidsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnSubnetMidsTable.setDescription('This attribute indicates which of the ReachableMidInfo (Mid) components refer to MIDs which are members of the Passport subnet. This list does not include AMs connected to the subnet.')
mscRtgDpnSubnetMidsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 233, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnSubnetMidsValue"))
if mibBuilder.loadTexts: mscRtgDpnSubnetMidsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnSubnetMidsEntry.setDescription('An entry in the mscRtgDpnSubnetMidsTable.')
mscRtgDpnSubnetMidsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 233, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnSubnetMidsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnSubnetMidsValue.setDescription('This variable represents both the value and the index for the mscRtgDpnSubnetMidsTable.')
mscRtgDpnVarianceTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 343), )
if mibBuilder.loadTexts: mscRtgDpnVarianceTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnVarianceTable.setDescription('This attribute specifies the variance values for high and low metric ranges, for each class of service (COS). A variance value is the maximum allowed difference in metric between the best path and the second path, as a percentage of the best path metric. High and low metric ranges are defined for each COS by the delayMetricRangeBoundary and tputMetricRangeBoundary attributes, and refer to total path metrics. When a variance value for a certain COS and metric range is set to the default value of 0, only equal metric paths can be used under that COS when the best path metric is in that range. When it is set to a value greater than 0, an alternate path which is safe (that is, non-looping) and which has a metric within this percentage of the best path metric can be used as a multipath. The special value of 9999 signifies an infinite variance, so that any safe alternate path may be used in addition to the single best path, regardless of its metric.')
mscRtgDpnVarianceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 343, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnVarianceCosIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnVarianceMetricRangeIndex"))
if mibBuilder.loadTexts: mscRtgDpnVarianceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnVarianceEntry.setDescription('An entry in the mscRtgDpnVarianceTable.')
mscRtgDpnVarianceCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 343, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("delay", 0), ("throughput", 1))))
if mibBuilder.loadTexts: mscRtgDpnVarianceCosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnVarianceCosIndex.setDescription('This variable represents the next to last index for the mscRtgDpnVarianceTable.')
mscRtgDpnVarianceMetricRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 343, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("low", 0), ("high", 1))))
if mibBuilder.loadTexts: mscRtgDpnVarianceMetricRangeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnVarianceMetricRangeIndex.setDescription('This variable represents the final index for the mscRtgDpnVarianceTable.')
mscRtgDpnVarianceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 343, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 500), ValueRangeConstraint(9999, 9999), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnVarianceValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnVarianceValue.setDescription('This variable represents an individual value for the mscRtgDpnVarianceTable.')
mscRtgDpnRid = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2))
mscRtgDpnRidRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 1), )
if mibBuilder.loadTexts: mscRtgDpnRidRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRtgDpnRid components.')
mscRtgDpnRidRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnRid component.')
mscRtgDpnRidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnRid components. These components cannot be added nor deleted.')
mscRtgDpnRidComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnRidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnRid tables.')
mscRtgDpnRidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)))
if mibBuilder.loadTexts: mscRtgDpnRidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidIndex.setDescription('This variable represents the index for the mscRtgDpnRid tables.')
mscRtgDpnRidOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 10), )
if mibBuilder.loadTexts: mscRtgDpnRidOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes is maintained by the DpnAddressPlan component to provide information about the RIDs reachable in the network.')
mscRtgDpnRidOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidOperEntry.setDescription('An entry in the mscRtgDpnRidOperTable.')
mscRtgDpnRidDpnDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidDpnDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDpnDelayMetric.setDescription("This attribute indicates the minimum DPN delay metric to the destination RID. The delay metric associated with a path is computed by the routing system by translating the smallest delayMetric calculated for the destination. A path with a lower metric value is preferable to one with a higher value as it is associated with lower delay facilities. The metric displayed is that of the best path to the destination. This metric is advertised to neighbor RMs and Passports in a different RID subnet. A metric value of 255 means the RID is unreachable in the delay class of service. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID. A metric value of 252 indicates that the destination RID is that of a Network Module (NM).")
mscRtgDpnRidDpnTputMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidDpnTputMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDpnTputMetric.setDescription("This attribute indicates the minimum DPN throughput metric to the destination RID. The throughput metric associated with a path is computed by the routing system by translating the smallest tputMetric calculated for the destination. A path with a lower metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities. The metric displayed is that of the best path to the destination. This metric is advertised to neighbor RMs and Passports in a different RID subnet. A metric value of 255 means the RID is unreachable in the throughput class of service. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID.")
mscRtgDpnRidDelayNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 226), )
if mibBuilder.loadTexts: mscRtgDpnRidDelayNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayNextHopLinkGroupsTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the destination RID. DPN traffic will be spread across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest delay metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to an RM. If no link groups are listed then the destination is not reachable in the delay class of service (except in the case of the local node's RID). Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.")
mscRtgDpnRidDelayNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 226, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidDelayNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidDelayNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayNextHopLinkGroupsEntry.setDescription('An entry in the mscRtgDpnRidDelayNextHopLinkGroupsTable.')
mscRtgDpnRidDelayNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 226, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnRidDelayNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayNextHopLinkGroupsIndex.setDescription('This variable represents the index for the mscRtgDpnRidDelayNextHopLinkGroupsTable.')
mscRtgDpnRidDelayNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 226, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidDelayNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the mscRtgDpnRidDelayNextHopLinkGroupsTable.')
mscRtgDpnRidTputNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 227), )
if mibBuilder.loadTexts: mscRtgDpnRidTputNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputNextHopLinkGroupsTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the destination RID. DPN traffic will be spread across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest throughput metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to an RM. If no link groups are listed then the destination is not reachable in the throughput class of service (except in the case of the local node's RID). Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.")
mscRtgDpnRidTputNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 227, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidTputNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidTputNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputNextHopLinkGroupsEntry.setDescription('An entry in the mscRtgDpnRidTputNextHopLinkGroupsTable.')
mscRtgDpnRidTputNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 227, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnRidTputNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputNextHopLinkGroupsIndex.setDescription('This variable represents the index for the mscRtgDpnRidTputNextHopLinkGroupsTable.')
mscRtgDpnRidTputNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 227, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidTputNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the mscRtgDpnRidTputNextHopLinkGroupsTable.')
mscRtgDpnRidDelayPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 328), )
if mibBuilder.loadTexts: mscRtgDpnRidDelayPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total delay traffic flows to the destination which are sent over each delay path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
mscRtgDpnRidDelayPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 328, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidDelayPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidDelayPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayPathTrafficProportionsEntry.setDescription('An entry in the mscRtgDpnRidDelayPathTrafficProportionsTable.')
mscRtgDpnRidDelayPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 328, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnRidDelayPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayPathTrafficProportionsIndex.setDescription('This variable represents the index for the mscRtgDpnRidDelayPathTrafficProportionsTable.')
mscRtgDpnRidDelayPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 328, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidDelayPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayPathTrafficProportionsValue.setDescription('This variable represents an individual value for the mscRtgDpnRidDelayPathTrafficProportionsTable.')
mscRtgDpnRidTputPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 329), )
if mibBuilder.loadTexts: mscRtgDpnRidTputPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total throughput traffic flows to the destination which are sent over each throughput path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
mscRtgDpnRidTputPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 329, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidTputPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidTputPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputPathTrafficProportionsEntry.setDescription('An entry in the mscRtgDpnRidTputPathTrafficProportionsTable.')
mscRtgDpnRidTputPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 329, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnRidTputPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputPathTrafficProportionsIndex.setDescription('This variable represents the index for the mscRtgDpnRidTputPathTrafficProportionsTable.')
mscRtgDpnRidTputPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 329, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidTputPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputPathTrafficProportionsValue.setDescription('This variable represents an individual value for the mscRtgDpnRidTputPathTrafficProportionsTable.')
mscRtgDpnRidDelayMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 339), )
if mibBuilder.loadTexts: mscRtgDpnRidDelayMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayMetricTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay metrics of up to two paths to the destination RID. The delay metric associated with a path is computed by the routing system based on the sum of the delays associated with the links in the path to the destination. A path with a lower metric value is preferable to one with a higher value as it is associated with lower delay facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the RID is unreachable in the delay class of service. A metric value of 2147483647 for the second path only means that there is only one viable delay path to the destination. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID. Metric values of 2147483646 indicate that the destination RID is that of a Network Module (NM).")
mscRtgDpnRidDelayMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 339, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidDelayMetricIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidDelayMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayMetricEntry.setDescription('An entry in the mscRtgDpnRidDelayMetricTable.')
mscRtgDpnRidDelayMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 339, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnRidDelayMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayMetricIndex.setDescription('This variable represents the index for the mscRtgDpnRidDelayMetricTable.')
mscRtgDpnRidDelayMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 339, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidDelayMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidDelayMetricValue.setDescription('This variable represents an individual value for the mscRtgDpnRidDelayMetricTable.')
mscRtgDpnRidTputMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 340), )
if mibBuilder.loadTexts: mscRtgDpnRidTputMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputMetricTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput metrics of up to two paths to the destination RID. The throughput metric associated with a path is computed by the routing system based on the sum of the bandwidth associated with the links in the path to the destination. A path with a lower metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the RID is unreachable in the throughput class of service. A metric value of 2147483647 for the second path only means that there is only one viable throughput path to the destination. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID.")
mscRtgDpnRidTputMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 340, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidTputMetricIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidTputMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputMetricEntry.setDescription('An entry in the mscRtgDpnRidTputMetricTable.')
mscRtgDpnRidTputMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 340, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnRidTputMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputMetricIndex.setDescription('This variable represents the index for the mscRtgDpnRidTputMetricTable.')
mscRtgDpnRidTputMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 340, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidTputMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidTputMetricValue.setDescription('This variable represents an individual value for the mscRtgDpnRidTputMetricTable.')
mscRtgDpnRidMid = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 2))
mscRtgDpnRidMidRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 2, 1), )
if mibBuilder.loadTexts: mscRtgDpnRidMidRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidMidRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRtgDpnRidMid components.')
mscRtgDpnRidMidRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidMidIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidMidRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidMidRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnRidMid component.')
mscRtgDpnRidMidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidMidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidMidRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnRidMid components. These components cannot be added nor deleted.')
mscRtgDpnRidMidComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidMidComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidMidComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnRidMidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidMidStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidMidStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnRidMid tables.')
mscRtgDpnRidMidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2046)))
if mibBuilder.loadTexts: mscRtgDpnRidMidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidMidIndex.setDescription('This variable represents the index for the mscRtgDpnRidMid tables.')
mscRtgDpnMid = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3))
mscRtgDpnMidRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 1), )
if mibBuilder.loadTexts: mscRtgDpnMidRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRtgDpnMid components.')
mscRtgDpnMidRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidIndex"))
if mibBuilder.loadTexts: mscRtgDpnMidRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnMid component.')
mscRtgDpnMidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnMid components. These components cannot be added nor deleted.')
mscRtgDpnMidComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnMidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnMid tables.')
mscRtgDpnMidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2046)))
if mibBuilder.loadTexts: mscRtgDpnMidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidIndex.setDescription('This variable represents the index for the mscRtgDpnMid tables.')
mscRtgDpnMidOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 10), )
if mibBuilder.loadTexts: mscRtgDpnMidOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes is maintained by DpnAddressPlan component to provide information about the MIDs reachable, or once reachable, through the local RID subnet.')
mscRtgDpnMidOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidIndex"))
if mibBuilder.loadTexts: mscRtgDpnMidOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidOperEntry.setDescription('An entry in the mscRtgDpnMidOperTable.')
mscRtgDpnMidSubstituteRid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidSubstituteRid.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidSubstituteRid.setDescription("This attribute indicates the substitute RID in use for the MID. This RID will be substituted for the RID in DPN packets destined to the local node's RID and the MID in question when the MID is unreachable (when, for example, all links to an AM from the Passport subnet are down). It will also be used in the case where the path through the substitute RID is better than that available through the subnet's connection to the cluster containing the AM MID. Substitute RIDs are learned from AM clusters that are supported by two RIDs (the Passport subnet's RID and another one). The operator can check this value to determine if a possible back up route to an AM exists. When there are no delayNextHopLinkGroups or tputNextHopLinkGroups shown to reach the MID, the substitute RID will be used. A value of 128 indicates that no substitute RID is known.")
mscRtgDpnMidDelayNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 228), )
if mibBuilder.loadTexts: mscRtgDpnMidDelayNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayNextHopLinkGroupsTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the destination MID. DPN traffic will be spread across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest delay metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to an AM. If no link groups are listed then the destination is not reachable in the delay class of service (except in the case of the local node's MID, or when a substitute RID path is available). Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.")
mscRtgDpnMidDelayNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 228, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidDelayNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: mscRtgDpnMidDelayNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayNextHopLinkGroupsEntry.setDescription('An entry in the mscRtgDpnMidDelayNextHopLinkGroupsTable.')
mscRtgDpnMidDelayNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 228, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnMidDelayNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayNextHopLinkGroupsIndex.setDescription('This variable represents the index for the mscRtgDpnMidDelayNextHopLinkGroupsTable.')
mscRtgDpnMidDelayNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 228, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidDelayNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the mscRtgDpnMidDelayNextHopLinkGroupsTable.')
mscRtgDpnMidTputNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 229), )
if mibBuilder.loadTexts: mscRtgDpnMidTputNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputNextHopLinkGroupsTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the destination MID. DPN traffic will be spread across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest throughput metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to an AM. If no link groups are listed then the destination is not reachable in the throughput class of service (except in the case of the local node's MID, or when a substitute RID path is available). Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.")
mscRtgDpnMidTputNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 229, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidTputNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: mscRtgDpnMidTputNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputNextHopLinkGroupsEntry.setDescription('An entry in the mscRtgDpnMidTputNextHopLinkGroupsTable.')
mscRtgDpnMidTputNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 229, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnMidTputNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputNextHopLinkGroupsIndex.setDescription('This variable represents the index for the mscRtgDpnMidTputNextHopLinkGroupsTable.')
mscRtgDpnMidTputNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 229, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidTputNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the mscRtgDpnMidTputNextHopLinkGroupsTable.')
mscRtgDpnMidDelayMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 330), )
if mibBuilder.loadTexts: mscRtgDpnMidDelayMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayMetricTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay metrics of up to two paths to the destination MID. The delay metric associated with a path is computed by the routing system based on the sum of the delays associated with the links (or estimated delays for links to AMs) in the path to the destination. It is computed for every possible path to the destination and is used by the DpnAddressPlan component for path comparison purposes. A path with a lower metric value is preferable to one with a higher value as it is associated with lower delay facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the MID is unreachable in the delay class of service (though it might still be reachable via its substitute RID). A metric value of 2147483647 for the second path only means that there is only one viable delay path to the destination.A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's MID.")
mscRtgDpnMidDelayMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 330, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidDelayMetricIndex"))
if mibBuilder.loadTexts: mscRtgDpnMidDelayMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayMetricEntry.setDescription('An entry in the mscRtgDpnMidDelayMetricTable.')
mscRtgDpnMidDelayMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 330, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnMidDelayMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayMetricIndex.setDescription('This variable represents the index for the mscRtgDpnMidDelayMetricTable.')
mscRtgDpnMidDelayMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 330, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidDelayMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayMetricValue.setDescription('This variable represents an individual value for the mscRtgDpnMidDelayMetricTable.')
mscRtgDpnMidTputMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 331), )
if mibBuilder.loadTexts: mscRtgDpnMidTputMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputMetricTable.setDescription("*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput metrics to the destination MID. The throughput metric associated with a path is computed by the routing system based on the sum of the bandwidth associated with the links (or estimated bandwidth for links to AMs) in the path to the destination. It is computed for every possible path to the destination and is used by the DpnAddressPlan component for path comparison purposes. A path with a lower metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the MID is unreachable in the throughput class of service (though it might still be reachable via its substitute RID). A metric value of 2147483647 for the second path only means that there is only one viable throughput path to the destination. A value of 0 indicates that no cost is associated with the path to the destination. This would be the case for the local node's RID.")
mscRtgDpnMidTputMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 331, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidTputMetricIndex"))
if mibBuilder.loadTexts: mscRtgDpnMidTputMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputMetricEntry.setDescription('An entry in the mscRtgDpnMidTputMetricTable.')
mscRtgDpnMidTputMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 331, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnMidTputMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputMetricIndex.setDescription('This variable represents the index for the mscRtgDpnMidTputMetricTable.')
mscRtgDpnMidTputMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 331, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidTputMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputMetricValue.setDescription('This variable represents an individual value for the mscRtgDpnMidTputMetricTable.')
mscRtgDpnMidDelayPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 332), )
if mibBuilder.loadTexts: mscRtgDpnMidDelayPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total delay traffic flows to the destination which are sent over each delay path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
mscRtgDpnMidDelayPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 332, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidDelayPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: mscRtgDpnMidDelayPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayPathTrafficProportionsEntry.setDescription('An entry in the mscRtgDpnMidDelayPathTrafficProportionsTable.')
mscRtgDpnMidDelayPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 332, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnMidDelayPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayPathTrafficProportionsIndex.setDescription('This variable represents the index for the mscRtgDpnMidDelayPathTrafficProportionsTable.')
mscRtgDpnMidDelayPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 332, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidDelayPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidDelayPathTrafficProportionsValue.setDescription('This variable represents an individual value for the mscRtgDpnMidDelayPathTrafficProportionsTable.')
mscRtgDpnMidTputPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 333), )
if mibBuilder.loadTexts: mscRtgDpnMidTputPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total throughput traffic flows to the destination which are sent over each throughput path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
mscRtgDpnMidTputPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 333, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnMidTputPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: mscRtgDpnMidTputPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputPathTrafficProportionsEntry.setDescription('An entry in the mscRtgDpnMidTputPathTrafficProportionsTable.')
mscRtgDpnMidTputPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 333, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnMidTputPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputPathTrafficProportionsIndex.setDescription('This variable represents the index for the mscRtgDpnMidTputPathTrafficProportionsTable.')
mscRtgDpnMidTputPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 3, 333, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnMidTputPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnMidTputPathTrafficProportionsValue.setDescription('This variable represents an individual value for the mscRtgDpnMidTputPathTrafficProportionsTable.')
mscRtgDpnCs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4))
mscRtgDpnCsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 1), )
if mibBuilder.loadTexts: mscRtgDpnCsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRtgDpnCs components.')
mscRtgDpnCsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsIndex"))
if mibBuilder.loadTexts: mscRtgDpnCsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnCs component.')
mscRtgDpnCsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnCs components. These components cannot be added nor deleted.')
mscRtgDpnCsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnCsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnCs tables.')
mscRtgDpnCsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6, 7, 8, 10, 11, 12, 14))).clone(namedValues=NamedValues(("dcr", 1), ("nui", 4), ("crd", 5), ("lnui", 6), ("scr", 7), ("npm", 8), ("grman", 10), ("gscr", 11), ("gdcr", 12), ("lcr", 14))))
if mibBuilder.loadTexts: mscRtgDpnCsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsIndex.setDescription('This variable represents the index for the mscRtgDpnCs tables.')
mscRtgDpnCsDelayNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 230), )
if mibBuilder.loadTexts: mscRtgDpnCsDelayNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayNextHopLinkGroupsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay link group, or groups, that are being used to reach a neighbor which is the next hop in the path to the Call Server Resource Module (CSRM) supporting the server. DPN server traffic will be load shared across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest delay metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to a CSRM. If no link groups are listed then the server is not reachable in the delay class of service. Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.')
mscRtgDpnCsDelayNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 230, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsDelayNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: mscRtgDpnCsDelayNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayNextHopLinkGroupsEntry.setDescription('An entry in the mscRtgDpnCsDelayNextHopLinkGroupsTable.')
mscRtgDpnCsDelayNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 230, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnCsDelayNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayNextHopLinkGroupsIndex.setDescription('This variable represents the index for the mscRtgDpnCsDelayNextHopLinkGroupsTable.')
mscRtgDpnCsDelayNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 230, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsDelayNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the mscRtgDpnCsDelayNextHopLinkGroupsTable.')
mscRtgDpnCsTputNextHopLinkGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 231), )
if mibBuilder.loadTexts: mscRtgDpnCsTputNextHopLinkGroupsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputNextHopLinkGroupsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput link group, or groups, that are being used to reach a neighbor which is either the next hop in the path to the Call Server Resource Module (CSRM) supporting the server. DPN server traffic will be load shared across the links, in up to two link groups, when available. The link groups selected are those associated with the two loop-free paths with the lowest throughput metrics to the destination. The link group can be that of either a Passport node interconnection or a gateway to the CSRM. If no link groups are listed then the server is not reachable in the throughput class of service. Link group instances are managed by the TransportResource component. Further information about the links in the group can be obtained from it.')
mscRtgDpnCsTputNextHopLinkGroupsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 231, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsTputNextHopLinkGroupsIndex"))
if mibBuilder.loadTexts: mscRtgDpnCsTputNextHopLinkGroupsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputNextHopLinkGroupsEntry.setDescription('An entry in the mscRtgDpnCsTputNextHopLinkGroupsTable.')
mscRtgDpnCsTputNextHopLinkGroupsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 231, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnCsTputNextHopLinkGroupsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputNextHopLinkGroupsIndex.setDescription('This variable represents the index for the mscRtgDpnCsTputNextHopLinkGroupsTable.')
mscRtgDpnCsTputNextHopLinkGroupsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 231, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsTputNextHopLinkGroupsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputNextHopLinkGroupsValue.setDescription('This variable represents an individual value for the mscRtgDpnCsTputNextHopLinkGroupsTable.')
mscRtgDpnCsDelayMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 334), )
if mibBuilder.loadTexts: mscRtgDpnCsDelayMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayMetricTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the delay metrics of up to two paths to the server supported on a Call Server Resource Module (CSRM). The delay metric associated with a path is computed by the routing system based on the sum of the delays associated with the links in the path to the CSRM supporting the server. It is computed for every possible path to the server and is used by the DpnAddressPlan component for path comparison purposes. A path with a lower metric value is preferable to one with a higher value as it is associated with lower delay facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the server is unreachable in the delay class of service. A metric value of 2147483647 for the second path only means that there is only one viable delay path to the destination. A value of 0 indicates that no cost is associated with the path to the destination.')
mscRtgDpnCsDelayMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 334, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsDelayMetricIndex"))
if mibBuilder.loadTexts: mscRtgDpnCsDelayMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayMetricEntry.setDescription('An entry in the mscRtgDpnCsDelayMetricTable.')
mscRtgDpnCsDelayMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 334, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnCsDelayMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayMetricIndex.setDescription('This variable represents the index for the mscRtgDpnCsDelayMetricTable.')
mscRtgDpnCsDelayMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 334, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsDelayMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayMetricValue.setDescription('This variable represents an individual value for the mscRtgDpnCsDelayMetricTable.')
mscRtgDpnCsTputMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 335), )
if mibBuilder.loadTexts: mscRtgDpnCsTputMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputMetricTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the throughput metrics of up to two paths to reach the server supported on a Call Server Resource Module (CSRM). The throughput metric associated with a path is computed by the routing system based on the sum of the bandwidth associated with the links in the path to the CSRM supporting the server. It is computed for every possible path to the server and is used by the DpnAddressPlan component for path comparison purposes. A path with a lower metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities. The metrics displayed are those of the paths being used to reach the destination. Metric values of 2147483647 for both paths means the server is unreachable in the throughput class of service. A metric value of 2147483647 for the second path only means that there is only one viable throughput path to the destination. A value of 0 indicates that no cost is associated with the path to the destination.')
mscRtgDpnCsTputMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 335, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsTputMetricIndex"))
if mibBuilder.loadTexts: mscRtgDpnCsTputMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputMetricEntry.setDescription('An entry in the mscRtgDpnCsTputMetricTable.')
mscRtgDpnCsTputMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 335, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnCsTputMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputMetricIndex.setDescription('This variable represents the index for the mscRtgDpnCsTputMetricTable.')
mscRtgDpnCsTputMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 335, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsTputMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputMetricValue.setDescription('This variable represents an individual value for the mscRtgDpnCsTputMetricTable.')
mscRtgDpnCsDelayPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 336), )
if mibBuilder.loadTexts: mscRtgDpnCsDelayPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total delay traffic flows to the destination which are sent over each delay path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
mscRtgDpnCsDelayPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 336, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsDelayPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: mscRtgDpnCsDelayPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayPathTrafficProportionsEntry.setDescription('An entry in the mscRtgDpnCsDelayPathTrafficProportionsTable.')
mscRtgDpnCsDelayPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 336, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnCsDelayPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayPathTrafficProportionsIndex.setDescription('This variable represents the index for the mscRtgDpnCsDelayPathTrafficProportionsTable.')
mscRtgDpnCsDelayPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 336, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsDelayPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsDelayPathTrafficProportionsValue.setDescription('This variable represents an individual value for the mscRtgDpnCsDelayPathTrafficProportionsTable.')
mscRtgDpnCsTputPathTrafficProportionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 337), )
if mibBuilder.loadTexts: mscRtgDpnCsTputPathTrafficProportionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputPathTrafficProportionsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the target percentages of the total throughput traffic flows to the destination which are sent over each throughput path. These percentages are achieved when there is a large number of virtual circuits (VCs).')
mscRtgDpnCsTputPathTrafficProportionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 337, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnCsTputPathTrafficProportionsIndex"))
if mibBuilder.loadTexts: mscRtgDpnCsTputPathTrafficProportionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputPathTrafficProportionsEntry.setDescription('An entry in the mscRtgDpnCsTputPathTrafficProportionsTable.')
mscRtgDpnCsTputPathTrafficProportionsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 337, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscRtgDpnCsTputPathTrafficProportionsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputPathTrafficProportionsIndex.setDescription('This variable represents the index for the mscRtgDpnCsTputPathTrafficProportionsTable.')
mscRtgDpnCsTputPathTrafficProportionsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 4, 337, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnCsTputPathTrafficProportionsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnCsTputPathTrafficProportionsValue.setDescription('This variable represents an individual value for the mscRtgDpnCsTputPathTrafficProportionsTable.')
mscRtgDpnLg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5))
mscRtgDpnLgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 1), )
if mibBuilder.loadTexts: mscRtgDpnLgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRtgDpnLg components.')
mscRtgDpnLgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnLgIndex"))
if mibBuilder.loadTexts: mscRtgDpnLgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnLg component.')
mscRtgDpnLgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnLg components. These components cannot be added nor deleted.')
mscRtgDpnLgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnLgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnLg tables.')
mscRtgDpnLgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 12)))
if mibBuilder.loadTexts: mscRtgDpnLgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgIndex.setDescription('This variable represents the index for the mscRtgDpnLg tables.')
mscRtgDpnLgOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 3), )
if mibBuilder.loadTexts: mscRtgDpnLgOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes provides information about the gateways in use to reach Passports, RMs and AMs connected to this Passport node.')
mscRtgDpnLgOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 3, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnLgIndex"))
if mibBuilder.loadTexts: mscRtgDpnLgOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgOperEntry.setDescription('An entry in the mscRtgDpnLgOperTable.')
mscRtgDpnLgFarEndType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("em", 0), ("rm", 1), ("am", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLgFarEndType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgFarEndType.setDescription('This attribute indicates the type of the far end module (EM, AM or RM).')
mscRtgDpnLgFarEndRid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 126))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLgFarEndRid.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgFarEndRid.setDescription('This attribute indicates the far end neighbor RID. If the neighbor is an AM then the RID is that of the Passport node.')
mscRtgDpnLgFarEndMid = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1910))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLgFarEndMid.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgFarEndMid.setDescription('This attribute indicates the far end neighbor MID.')
mscRtgDpnLgDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 3, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLgDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgDelayMetric.setDescription('This attribute indicates the delay metric calculated for the link group. If the type of the far end switch is AM, the delay metric is calculated for MID routing, ranging from 1 to 2147483647. If the type of the far end switch is EM or RM, the delay metric, ranging from 1 to 255, is based on the measured round trip delay of the delay preferred links in the group. A link group with a low metric value is preferable to one with a higher value as it is associated with lower delay facilities.')
mscRtgDpnLgTputMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 5, 3, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLgTputMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLgTputMetric.setDescription('This attribute indicates the throughput metric calculated for the link group. If the type of the far end switch is AM, the throughput metric is calculated for MID routing, ranging from 1 to 2147483647. If the type of the far end switch is EM or RM, the throughput metric, ranging from 1 to 255, is based on the sum of the bandwidth available for all links in the group. A link group with a low metric value is preferable to one with a higher value as it is associated with higher bandwidth facilities.')
mscRtgDpnLpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6))
mscRtgDpnLpStatsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 1), )
if mibBuilder.loadTexts: mscRtgDpnLpStatsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRtgDpnLpStats components.')
mscRtgDpnLpStatsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnLpStatsIndex"))
if mibBuilder.loadTexts: mscRtgDpnLpStatsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnLpStats component.')
mscRtgDpnLpStatsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnLpStats components. These components cannot be added nor deleted.')
mscRtgDpnLpStatsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnLpStatsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnLpStats tables.')
mscRtgDpnLpStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscRtgDpnLpStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsIndex.setDescription('This variable represents the index for the mscRtgDpnLpStats tables.')
mscRtgDpnLpStatsFwdStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10), )
if mibBuilder.loadTexts: mscRtgDpnLpStatsFwdStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsFwdStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes provides DPN packet forwarding statistics for this LP. The statistics can be used to monitor the connectionless traffic profile on this LP.')
mscRtgDpnLpStatsFwdStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnLpStatsIndex"))
if mibBuilder.loadTexts: mscRtgDpnLpStatsFwdStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsFwdStatsEntry.setDescription('An entry in the mscRtgDpnLpStatsFwdStatsTable.')
mscRtgDpnLpStatsTotalPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsTotalPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsTotalPackets.setDescription('This attribute counts the total number of delay and throughput packets handled by DPN packet forwarding on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnLpStatsThroughputPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsThroughputPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsThroughputPackets.setDescription('This attribute counts the throughput packets handled by DPN packet forwarding on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnLpStatsDelayPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsDelayPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsDelayPackets.setDescription('This attribute counts the delay packets handled by DPN packet forwarding on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnLpStatsNormalReliabilityPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsNormalReliabilityPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsNormalReliabilityPackets.setDescription('This attribute counts the normal reliability packets handled by DPN packet forwarding on this LP when the forwardingPolicy attribute of Routing DpnAddressPlan is set to loadshare or loadspread. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnLpStatsHighReliabilityPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsHighReliabilityPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsHighReliabilityPackets.setDescription('This attribute counts the high reliability packets handled by DPN packet forwarding on this LP when the forwardingPolicy attribute of Routing DpnAddressPlan is set to loadshare or loadspread. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnLpStatsDiscardNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsDiscardNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsDiscardNoRoute.setDescription('This attribute counts the packets discarded when DPN packet forwarding has failed to find a route to forward the packets on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnLpStatsInterruptingPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsInterruptingPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsInterruptingPackets.setDescription('This attribute counts the total number of multimedia packets handled by DPN packet forwarding on this LP. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnLpStatsDiscardLpCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 6, 10, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnLpStatsDiscardLpCongested.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnLpStatsDiscardLpCongested.setDescription('This attribute counts the packets that have been discarded by DPN packet forwarding, on the entire module, due to congestion on this LP. This value is the sum of the packets discarded by all LPs due to insufficient shared memory on this one. Note that DPRS packets leaving the network at this module are not counted. The counter wraps to zero when the maximum value is exceeded.')
mscRtgDpnRidFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7))
mscRtgDpnRidFilterRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 1), )
if mibBuilder.loadTexts: mscRtgDpnRidFilterRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterRowStatusTable.setDescription('This entry controls the addition and deletion of mscRtgDpnRidFilter components.')
mscRtgDpnRidFilterRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidFilterIndex"))
if mibBuilder.loadTexts: mscRtgDpnRidFilterRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnRidFilter component.')
mscRtgDpnRidFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnRidFilterRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnRidFilter components. These components can be added and deleted.')
mscRtgDpnRidFilterComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidFilterComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnRidFilterStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnRidFilterStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnRidFilter tables.')
mscRtgDpnRidFilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 126)))
if mibBuilder.loadTexts: mscRtgDpnRidFilterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterIndex.setDescription('This variable represents the index for the mscRtgDpnRidFilter tables.')
mscRtgDpnRidFilterImportRidListTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 303), )
if mibBuilder.loadTexts: mscRtgDpnRidFilterImportRidListTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterImportRidListTable.setDescription('This attribute specifies the list of RIDs whose reachability information will be accepted from the instance RID. Information about RIDs which do not appear in this list will be ignored and this node considers those RIDs to be unreachable from the instance RID. Note that this also applies to the instance RID itself, that is, if the instance RID does not appear in the import list, this node considers the instance RID to be unreachable from the instance RID. By default this list contains all valid RIDs, meaning that information about all RIDs will be accepted from the instance RID. When this list is empty, no RID information is accepted from the instance RID, therefore, no RID traffic will be routed to it. A warning is generated when an empty import list is detected. RID 127 is the Network Services Sharing (NSS) RID, used to identify DPN-100 nodes running call servers which can be used for remote call processing. This RID can be filtered like any other using the import RID list.')
mscRtgDpnRidFilterImportRidListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 303, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidFilterIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidFilterImportRidListValue"))
if mibBuilder.loadTexts: mscRtgDpnRidFilterImportRidListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterImportRidListEntry.setDescription('An entry in the mscRtgDpnRidFilterImportRidListTable.')
mscRtgDpnRidFilterImportRidListValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 303, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnRidFilterImportRidListValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterImportRidListValue.setDescription('This variable represents both the value and the index for the mscRtgDpnRidFilterImportRidListTable.')
mscRtgDpnRidFilterImportRidListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 303, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscRtgDpnRidFilterImportRidListRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterImportRidListRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscRtgDpnRidFilterImportRidListTable.')
mscRtgDpnRidFilterExportRidListTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 304), )
if mibBuilder.loadTexts: mscRtgDpnRidFilterExportRidListTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterExportRidListTable.setDescription("This attribute specifies the list of RIDs whose true reachability is advertised to the instance RID. RIDs which do not appear in this list are advertised to the instance RID as being unreachable from this node. By default, this list contains all valid RIDs, meaning that true reachability information for all RIDs is advertised to the instance RID. When this list is empty, all RIDs will be advertised to the instance RID as unreachable, including this node's own RID, therefore the instance RID will not route any RID traffic to this RID. A warning is generated when an empty export list is detected. RID 127 is the Network Services Sharing (NSS) RID, used to identify DPN-100 nodes running call servers which can be used for remote call processing. This RID can be filtered like any other using the import RID list.")
mscRtgDpnRidFilterExportRidListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 304, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidFilterIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnRidFilterExportRidListValue"))
if mibBuilder.loadTexts: mscRtgDpnRidFilterExportRidListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterExportRidListEntry.setDescription('An entry in the mscRtgDpnRidFilterExportRidListTable.')
mscRtgDpnRidFilterExportRidListValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 304, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnRidFilterExportRidListValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterExportRidListValue.setDescription('This variable represents both the value and the index for the mscRtgDpnRidFilterExportRidListTable.')
mscRtgDpnRidFilterExportRidListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 7, 304, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscRtgDpnRidFilterExportRidListRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnRidFilterExportRidListRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscRtgDpnRidFilterExportRidListTable.')
mscRtgDpnArt = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9))
mscRtgDpnArtRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 1), )
if mibBuilder.loadTexts: mscRtgDpnArtRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtRowStatusTable.setDescription('This entry controls the addition and deletion of mscRtgDpnArt components.')
mscRtgDpnArtRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"))
if mibBuilder.loadTexts: mscRtgDpnArtRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnArt component.')
mscRtgDpnArtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnArt components. These components cannot be added nor deleted.')
mscRtgDpnArtComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnArtStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnArt tables.')
mscRtgDpnArtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscRtgDpnArtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtIndex.setDescription('This variable represents the index for the mscRtgDpnArt tables.')
mscRtgDpnArtProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 10), )
if mibBuilder.loadTexts: mscRtgDpnArtProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtProvTable.setDescription('This group of attributes provides information about the option(s) and parameter(s) that the operator can set to control the behavior of automatic route tester.')
mscRtgDpnArtProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"))
if mibBuilder.loadTexts: mscRtgDpnArtProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtProvEntry.setDescription('An entry in the mscRtgDpnArtProvTable.')
mscRtgDpnArtCosUnderTest = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("delayCosOnly", 1), ("tputCosOnly", 2), ("delayAndTputCos", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnArtCosUnderTest.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtCosUnderTest.setDescription("This attribute specifies the COS type(s) (delay, throughput, delay and throughput) for which the automatic route testing is conducted. A description of possible values for this attribute follows: none: Do not conduct route testing for any COS type (essentially the automatic route tester is turned off). delayCosOnly: Conduct route testing to each reachable RID and MID destination for delay COS only. tputCosOnly: Conduct route testing to each reachable RID and MID destination for throughput COS only. delayAndTputCos: Conduct route testing to each reachable RID and MID destination for delay and throughput COSs. Setting this attribute to 'none' allows the operator to turn off the automatic route tester. Using value 'delayCosOnly' or 'tputCosOnly' tells the automated route tester to only work on one COS of the operator's choice. Choosing value 'delayAndTputCos' when both the delay and throughput COSs are to be tested. The network resources consumption (such as CPU, memory, link bandwidth) of the automatic route tester working on two COSs will roughly be two times as much as working on only one COS. The time to complete a full cycle of route testing to every reachable destination is also expected to be twice as long when working on two COSs.")
mscRtgDpnArtTestInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 900)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscRtgDpnArtTestInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtTestInterval.setDescription('This attribute specifies the time interval between the successive testson different destinations. The automatic route tester periodically tries to test the route to a different reachable destination (RID or MID). In order not to put too heavy a load on the network, it will wait for a period of time equal to this interval before it will start working on another destination. The smaller the value of this attribute, the more frequently the automatic route tester gets invoked to work on route testing. On one hand, doing so will reduce the amount of time needed to complete a fully cycle of route testing to every reachable destination. One the other hand, this will increase the resource comsumption of the automatic route tester accordingly. During each testInterval, the automatic route tester will first retry the routes to each error destination, if any, to see if they have recovered. After the retries of all these error destinations, another RID/MID destination from the DPN routing table (not in the error destination list) will be chosen to conduct route testing only if the current number of error destinations is less than 10. If the number of error destinations has reached 10, no other destinations will be chosen and the automatic route tester will focus on retrying only these error destinations at each testInterval. However, if the routes to at least one error destination has recovered or has become unreachable, the number of error destinations will fall below 10, and the selection and conducting of route testing on another destination from the DPN routing table will resume.')
mscRtgDpnArtOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 11), )
if mibBuilder.loadTexts: mscRtgDpnArtOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtOperTable.setDescription('This group of attributes provides information about the outstanding error destinations discovered by the automatic route tester.')
mscRtgDpnArtOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"))
if mibBuilder.loadTexts: mscRtgDpnArtOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtOperEntry.setDescription('An entry in the mscRtgDpnArtOperTable.')
mscRtgDpnArtNumOfLoopDests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtNumOfLoopDests.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtNumOfLoopDests.setDescription('This attribute indicates the total number of RID and MID destinations to which a routing loop problem has been detected. Whenever a new error destination of routing loop type is found, this value is increased by one, and whenever the loop problem to one destination goes away or this destination has become unreachable, this value is decreased by one.')
mscRtgDpnArtNumOfTimeoutDests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtNumOfTimeoutDests.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtNumOfTimeoutDests.setDescription('This attribute indicates the total number of RID and MID destinations to which a timeout problem has been detected. Whenever a new error destination of timeout type is found, this value is increased by one, and whenever the timeout problem to one destination goes away or this destination has become unreachable, this value is decreased by one.')
mscRtgDpnArtErrRid = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2))
mscRtgDpnArtErrRidRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 1), )
if mibBuilder.loadTexts: mscRtgDpnArtErrRidRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRtgDpnArtErrRid components.')
mscRtgDpnArtErrRidRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrRidIndex"))
if mibBuilder.loadTexts: mscRtgDpnArtErrRidRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnArtErrRid component.')
mscRtgDpnArtErrRidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrRidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnArtErrRid components. These components cannot be added nor deleted.')
mscRtgDpnArtErrRidComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrRidComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnArtErrRidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrRidStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnArtErrRid tables.')
mscRtgDpnArtErrRidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)))
if mibBuilder.loadTexts: mscRtgDpnArtErrRidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidIndex.setDescription('This variable represents the index for the mscRtgDpnArtErrRid tables.')
mscRtgDpnArtErrRidOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 10), )
if mibBuilder.loadTexts: mscRtgDpnArtErrRidOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes provides information about a single error destination (RID or MID) discovered by the automatic route tester.')
mscRtgDpnArtErrRidOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrRidIndex"))
if mibBuilder.loadTexts: mscRtgDpnArtErrRidOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidOperEntry.setDescription('An entry in the mscRtgDpnArtErrRidOperTable.')
mscRtgDpnArtErrRidDelayCosErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noError", 0), ("timeout", 1), ("loop", 2))).clone('noError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrRidDelayCosErrType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidDelayCosErrType.setDescription('This attribute indicates the type of error that was found with the route to this destination (on delay COS) by the automatic route tester.')
mscRtgDpnArtErrRidThroughputCosErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noError", 0), ("timeout", 1), ("loop", 2))).clone('noError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrRidThroughputCosErrType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidThroughputCosErrType.setDescription('This attribute indicates the type of error that was found with this destination (on throughput COS) by the automatic route tester.')
mscRtgDpnArtErrRidDelayErrPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 688), )
if mibBuilder.loadTexts: mscRtgDpnArtErrRidDelayErrPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidDelayErrPathTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute provides hop-by-hop route information for a destination to which a routing loop problem (on delay COS) was found. For a timeout problem, this information is not provided.')
mscRtgDpnArtErrRidDelayErrPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 688, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrRidDelayErrPathValue"))
if mibBuilder.loadTexts: mscRtgDpnArtErrRidDelayErrPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidDelayErrPathEntry.setDescription('An entry in the mscRtgDpnArtErrRidDelayErrPathTable.')
mscRtgDpnArtErrRidDelayErrPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 688, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrRidDelayErrPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidDelayErrPathValue.setDescription('This variable represents both the value and the index for the mscRtgDpnArtErrRidDelayErrPathTable.')
mscRtgDpnArtErrRidTputErrPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 689), )
if mibBuilder.loadTexts: mscRtgDpnArtErrRidTputErrPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidTputErrPathTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute provides hop-by-hop route information for a destination to which a routing loop problem (on throughput COS) was found. For a timeout problem, this information is not provided.')
mscRtgDpnArtErrRidTputErrPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 689, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrRidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrRidTputErrPathValue"))
if mibBuilder.loadTexts: mscRtgDpnArtErrRidTputErrPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidTputErrPathEntry.setDescription('An entry in the mscRtgDpnArtErrRidTputErrPathTable.')
mscRtgDpnArtErrRidTputErrPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 2, 689, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrRidTputErrPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrRidTputErrPathValue.setDescription('This variable represents both the value and the index for the mscRtgDpnArtErrRidTputErrPathTable.')
mscRtgDpnArtErrMid = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3))
mscRtgDpnArtErrMidRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 1), )
if mibBuilder.loadTexts: mscRtgDpnArtErrMidRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscRtgDpnArtErrMid components.')
mscRtgDpnArtErrMidRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrMidIndex"))
if mibBuilder.loadTexts: mscRtgDpnArtErrMidRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidRowStatusEntry.setDescription('A single entry in the table represents a single mscRtgDpnArtErrMid component.')
mscRtgDpnArtErrMidRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrMidRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscRtgDpnArtErrMid components. These components cannot be added nor deleted.')
mscRtgDpnArtErrMidComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrMidComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscRtgDpnArtErrMidStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrMidStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidStorageType.setDescription('This variable represents the storage type value for the mscRtgDpnArtErrMid tables.')
mscRtgDpnArtErrMidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2046)))
if mibBuilder.loadTexts: mscRtgDpnArtErrMidIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidIndex.setDescription('This variable represents the index for the mscRtgDpnArtErrMid tables.')
mscRtgDpnArtErrMidOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 10), )
if mibBuilder.loadTexts: mscRtgDpnArtErrMidOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes provides information about a single error destination (RID or MID) discovered by the automatic route tester.')
mscRtgDpnArtErrMidOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrMidIndex"))
if mibBuilder.loadTexts: mscRtgDpnArtErrMidOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidOperEntry.setDescription('An entry in the mscRtgDpnArtErrMidOperTable.')
mscRtgDpnArtErrMidDelayCosErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noError", 0), ("timeout", 1), ("loop", 2))).clone('noError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrMidDelayCosErrType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidDelayCosErrType.setDescription('This attribute indicates the type of error that was found with the route to this destination (on delay COS) by the automatic route tester.')
mscRtgDpnArtErrMidThroughputCosErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noError", 0), ("timeout", 1), ("loop", 2))).clone('noError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrMidThroughputCosErrType.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidThroughputCosErrType.setDescription('This attribute indicates the type of error that was found with this destination (on throughput COS) by the automatic route tester.')
mscRtgDpnArtErrMidDelayErrPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 688), )
if mibBuilder.loadTexts: mscRtgDpnArtErrMidDelayErrPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidDelayErrPathTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute provides hop-by-hop route information for a destination to which a routing loop problem (on delay COS) was found. For a timeout problem, this information is not provided.')
mscRtgDpnArtErrMidDelayErrPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 688, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrMidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrMidDelayErrPathValue"))
if mibBuilder.loadTexts: mscRtgDpnArtErrMidDelayErrPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidDelayErrPathEntry.setDescription('An entry in the mscRtgDpnArtErrMidDelayErrPathTable.')
mscRtgDpnArtErrMidDelayErrPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 688, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrMidDelayErrPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidDelayErrPathValue.setDescription('This variable represents both the value and the index for the mscRtgDpnArtErrMidDelayErrPathTable.')
mscRtgDpnArtErrMidTputErrPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 689), )
if mibBuilder.loadTexts: mscRtgDpnArtErrMidTputErrPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidTputErrPathTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute provides hop-by-hop route information for a destination to which a routing loop problem (on throughput COS) was found. For a timeout problem, this information is not provided.')
mscRtgDpnArtErrMidTputErrPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 689, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BaseRoutingMIB", "mscRtgIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrMidIndex"), (0, "Nortel-MsCarrier-MscPassport-DpnRoutingMIB", "mscRtgDpnArtErrMidTputErrPathValue"))
if mibBuilder.loadTexts: mscRtgDpnArtErrMidTputErrPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidTputErrPathEntry.setDescription('An entry in the mscRtgDpnArtErrMidTputErrPathTable.')
mscRtgDpnArtErrMidTputErrPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 40, 4, 9, 3, 689, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscRtgDpnArtErrMidTputErrPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscRtgDpnArtErrMidTputErrPathValue.setDescription('This variable represents both the value and the index for the mscRtgDpnArtErrMidTputErrPathTable.')
dpnRoutingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21, 1))
dpnRoutingGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21, 1, 1))
dpnRoutingGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21, 1, 1, 3))
dpnRoutingGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21, 1, 1, 3, 2))
dpnRoutingCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21, 3))
dpnRoutingCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21, 3, 1))
dpnRoutingCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21, 3, 1, 3))
dpnRoutingCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 21, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-DpnRoutingMIB", mscRtgDpnMidSubstituteRid=mscRtgDpnMidSubstituteRid, mscRtgDpnMidTputNextHopLinkGroupsEntry=mscRtgDpnMidTputNextHopLinkGroupsEntry, mscRtgDpnRowStatusTable=mscRtgDpnRowStatusTable, mscRtgDpnControlPktTx=mscRtgDpnControlPktTx, mscRtgDpnMidTputMetricIndex=mscRtgDpnMidTputMetricIndex, mscRtgDpnRidFilterRowStatusEntry=mscRtgDpnRidFilterRowStatusEntry, mscRtgDpnCsDelayMetricEntry=mscRtgDpnCsDelayMetricEntry, mscRtgDpnLpStatsFwdStatsEntry=mscRtgDpnLpStatsFwdStatsEntry, mscRtgDpnCs=mscRtgDpnCs, mscRtgDpnCsTputMetricEntry=mscRtgDpnCsTputMetricEntry, mscRtgDpnArtErrMidComponentName=mscRtgDpnArtErrMidComponentName, mscRtgDpnCsTputPathTrafficProportionsEntry=mscRtgDpnCsTputPathTrafficProportionsEntry, mscRtgDpnMidDelayMetricTable=mscRtgDpnMidDelayMetricTable, mscRtgDpnArtErrMidOperEntry=mscRtgDpnArtErrMidOperEntry, mscRtgDpnRidFilterExportRidListEntry=mscRtgDpnRidFilterExportRidListEntry, mscRtgDpnCsTputNextHopLinkGroupsIndex=mscRtgDpnCsTputNextHopLinkGroupsIndex, mscRtgDpnMidOperEntry=mscRtgDpnMidOperEntry, mscRtgDpnIndex=mscRtgDpnIndex, mscRtgDpnRidDelayNextHopLinkGroupsTable=mscRtgDpnRidDelayNextHopLinkGroupsTable, mscRtgDpnLpStatsTotalPackets=mscRtgDpnLpStatsTotalPackets, mscRtgDpnLgFarEndType=mscRtgDpnLgFarEndType, mscRtgDpnModuleId=mscRtgDpnModuleId, mscRtgDpnLpStatsFwdStatsTable=mscRtgDpnLpStatsFwdStatsTable, mscRtgDpnCsTputPathTrafficProportionsIndex=mscRtgDpnCsTputPathTrafficProportionsIndex, mscRtgDpnMidDelayNextHopLinkGroupsValue=mscRtgDpnMidDelayNextHopLinkGroupsValue, mscRtgDpnCsDelayPathTrafficProportionsValue=mscRtgDpnCsDelayPathTrafficProportionsValue, mscRtgDpnArtErrRidTputErrPathTable=mscRtgDpnArtErrRidTputErrPathTable, mscRtgDpnLpStatsThroughputPackets=mscRtgDpnLpStatsThroughputPackets, mscRtgDpnRidTputPathTrafficProportionsValue=mscRtgDpnRidTputPathTrafficProportionsValue, mscRtgDpnLgRowStatusEntry=mscRtgDpnLgRowStatusEntry, mscRtgDpnMidTputPathTrafficProportionsValue=mscRtgDpnMidTputPathTrafficProportionsValue, mscRtgDpnRidFilterImportRidListRowStatus=mscRtgDpnRidFilterImportRidListRowStatus, mscRtgDpnRidFilterExportRidListRowStatus=mscRtgDpnRidFilterExportRidListRowStatus, mscRtgDpnLpStatsHighReliabilityPackets=mscRtgDpnLpStatsHighReliabilityPackets, mscRtgDpnArtErrMidDelayCosErrType=mscRtgDpnArtErrMidDelayCosErrType, mscRtgDpnMidDelayPathTrafficProportionsValue=mscRtgDpnMidDelayPathTrafficProportionsValue, mscRtgDpnMidStorageType=mscRtgDpnMidStorageType, mscRtgDpnRidFilterIndex=mscRtgDpnRidFilterIndex, mscRtgDpnArtErrMidOperTable=mscRtgDpnArtErrMidOperTable, mscRtgDpnCsDelayNextHopLinkGroupsValue=mscRtgDpnCsDelayNextHopLinkGroupsValue, mscRtgDpnArtCosUnderTest=mscRtgDpnArtCosUnderTest, mscRtgDpn=mscRtgDpn, dpnRoutingGroupCA02=dpnRoutingGroupCA02, mscRtgDpnCsDelayPathTrafficProportionsIndex=mscRtgDpnCsDelayPathTrafficProportionsIndex, mscRtgDpnRidMid=mscRtgDpnRidMid, mscRtgDpnArtIndex=mscRtgDpnArtIndex, mscRtgDpnLpStatsInterruptingPackets=mscRtgDpnLpStatsInterruptingPackets, mscRtgDpnRidMidComponentName=mscRtgDpnRidMidComponentName, mscRtgDpnLpStatsDiscardLpCongested=mscRtgDpnLpStatsDiscardLpCongested, mscRtgDpnArtErrMidTputErrPathValue=mscRtgDpnArtErrMidTputErrPathValue, mscRtgDpnArtErrRidTputErrPathValue=mscRtgDpnArtErrRidTputErrPathValue, mscRtgDpnVarianceEntry=mscRtgDpnVarianceEntry, mscRtgDpnCsTputNextHopLinkGroupsEntry=mscRtgDpnCsTputNextHopLinkGroupsEntry, mscRtgDpnMidDelayNextHopLinkGroupsEntry=mscRtgDpnMidDelayNextHopLinkGroupsEntry, mscRtgDpnCsDelayMetricValue=mscRtgDpnCsDelayMetricValue, mscRtgDpnArtErrRidDelayErrPathEntry=mscRtgDpnArtErrRidDelayErrPathEntry, mscRtgDpnControlPktRx=mscRtgDpnControlPktRx, mscRtgDpnDelayMetricCutOff=mscRtgDpnDelayMetricCutOff, mscRtgDpnRidTputMetricValue=mscRtgDpnRidTputMetricValue, mscRtgDpnArtErrRidStorageType=mscRtgDpnArtErrRidStorageType, mscRtgDpnRidFilterRowStatusTable=mscRtgDpnRidFilterRowStatusTable, mscRtgDpnArtProvEntry=mscRtgDpnArtProvEntry, mscRtgDpnHighReliabilityPackets=mscRtgDpnHighReliabilityPackets, mscRtgDpnMidComponentName=mscRtgDpnMidComponentName, mscRtgDpnMidDelayMetricValue=mscRtgDpnMidDelayMetricValue, mscRtgDpnCsTputMetricValue=mscRtgDpnCsTputMetricValue, mscRtgDpnLpStatsStorageType=mscRtgDpnLpStatsStorageType, mscRtgDpnRoutingId=mscRtgDpnRoutingId, mscRtgDpnSubnetMidsTable=mscRtgDpnSubnetMidsTable, dpnRoutingGroup=dpnRoutingGroup, mscRtgDpnArtErrMidTputErrPathEntry=mscRtgDpnArtErrMidTputErrPathEntry, mscRtgDpnRidStorageType=mscRtgDpnRidStorageType, mscRtgDpnRidDelayMetricEntry=mscRtgDpnRidDelayMetricEntry, mscRtgDpnVarianceTable=mscRtgDpnVarianceTable, mscRtgDpnMidDelayPathTrafficProportionsIndex=mscRtgDpnMidDelayPathTrafficProportionsIndex, mscRtgDpnRidDelayPathTrafficProportionsTable=mscRtgDpnRidDelayPathTrafficProportionsTable, mscRtgDpnCsTputPathTrafficProportionsTable=mscRtgDpnCsTputPathTrafficProportionsTable, mscRtgDpnMidIndex=mscRtgDpnMidIndex, mscRtgDpnMidOperTable=mscRtgDpnMidOperTable, mscRtgDpnArtErrRidIndex=mscRtgDpnArtErrRidIndex, mscRtgDpnLpStatsRowStatusTable=mscRtgDpnLpStatsRowStatusTable, mscRtgDpnLgOperEntry=mscRtgDpnLgOperEntry, mscRtgDpnRowStatusEntry=mscRtgDpnRowStatusEntry, dpnRoutingCapabilitiesCA02A=dpnRoutingCapabilitiesCA02A, mscRtgDpnRidDelayNextHopLinkGroupsValue=mscRtgDpnRidDelayNextHopLinkGroupsValue, mscRtgDpnRidFilterExportRidListTable=mscRtgDpnRidFilterExportRidListTable, mscRtgDpnRidFilter=mscRtgDpnRidFilter, mscRtgDpnArtErrMidDelayErrPathTable=mscRtgDpnArtErrMidDelayErrPathTable, mscRtgDpnArtErrRidDelayCosErrType=mscRtgDpnArtErrRidDelayCosErrType, mscRtgDpnLogicalNetworkNumber=mscRtgDpnLogicalNetworkNumber, mscRtgDpnCsTputNextHopLinkGroupsTable=mscRtgDpnCsTputNextHopLinkGroupsTable, mscRtgDpnRidMidIndex=mscRtgDpnRidMidIndex, mscRtgDpnMidRowStatusEntry=mscRtgDpnMidRowStatusEntry, mscRtgDpnLpStats=mscRtgDpnLpStats, mscRtgDpnRidTputNextHopLinkGroupsTable=mscRtgDpnRidTputNextHopLinkGroupsTable, mscRtgDpnRidDelayMetricTable=mscRtgDpnRidDelayMetricTable, mscRtgDpnMidTputPathTrafficProportionsIndex=mscRtgDpnMidTputPathTrafficProportionsIndex, mscRtgDpnMidDelayPathTrafficProportionsTable=mscRtgDpnMidDelayPathTrafficProportionsTable, mscRtgDpnCsDelayPathTrafficProportionsEntry=mscRtgDpnCsDelayPathTrafficProportionsEntry, mscRtgDpnMidTputNextHopLinkGroupsIndex=mscRtgDpnMidTputNextHopLinkGroupsIndex, mscRtgDpnArtErrRidComponentName=mscRtgDpnArtErrRidComponentName, mscRtgDpnRidTputMetricIndex=mscRtgDpnRidTputMetricIndex, mscRtgDpnRidDpnDelayMetric=mscRtgDpnRidDpnDelayMetric, mscRtgDpnRidComponentName=mscRtgDpnRidComponentName, mscRtgDpnRidTputNextHopLinkGroupsValue=mscRtgDpnRidTputNextHopLinkGroupsValue, mscRtgDpnTputMetricRangeBoundary=mscRtgDpnTputMetricRangeBoundary, mscRtgDpnRidDelayPathTrafficProportionsIndex=mscRtgDpnRidDelayPathTrafficProportionsIndex, mscRtgDpnMidDelayNextHopLinkGroupsIndex=mscRtgDpnMidDelayNextHopLinkGroupsIndex, mscRtgDpnArtErrMidIndex=mscRtgDpnArtErrMidIndex, dpnRoutingCapabilities=dpnRoutingCapabilities, mscRtgDpnLgFarEndRid=mscRtgDpnLgFarEndRid, dpnRoutingGroupCA02A=dpnRoutingGroupCA02A, mscRtgDpnLgStorageType=mscRtgDpnLgStorageType, mscRtgDpnRid=mscRtgDpnRid, mscRtgDpnRidDelayNextHopLinkGroupsEntry=mscRtgDpnRidDelayNextHopLinkGroupsEntry, mscRtgDpnStorageType=mscRtgDpnStorageType, mscRtgDpnRidTputPathTrafficProportionsEntry=mscRtgDpnRidTputPathTrafficProportionsEntry, mscRtgDpnCsTputNextHopLinkGroupsValue=mscRtgDpnCsTputNextHopLinkGroupsValue, mscRtgDpnArtStorageType=mscRtgDpnArtStorageType, mscRtgDpnMidTputPathTrafficProportionsEntry=mscRtgDpnMidTputPathTrafficProportionsEntry, mscRtgDpnMidDelayNextHopLinkGroupsTable=mscRtgDpnMidDelayNextHopLinkGroupsTable, mscRtgDpnMidTputNextHopLinkGroupsTable=mscRtgDpnMidTputNextHopLinkGroupsTable, mscRtgDpnConStatsTable=mscRtgDpnConStatsTable, mscRtgDpnMidTputMetricEntry=mscRtgDpnMidTputMetricEntry, mscRtgDpnThroughputMetricCutOff=mscRtgDpnThroughputMetricCutOff, mscRtgDpnCsDelayMetricTable=mscRtgDpnCsDelayMetricTable, mscRtgDpnRidFilterImportRidListValue=mscRtgDpnRidFilterImportRidListValue, mscRtgDpnMid=mscRtgDpnMid, dpnRoutingCapabilitiesCA=dpnRoutingCapabilitiesCA, mscRtgDpnArtErrMidRowStatus=mscRtgDpnArtErrMidRowStatus, mscRtgDpnRidMidRowStatusEntry=mscRtgDpnRidMidRowStatusEntry, mscRtgDpnCsTputPathTrafficProportionsValue=mscRtgDpnCsTputPathTrafficProportionsValue, mscRtgDpnLgRowStatus=mscRtgDpnLgRowStatus, mscRtgDpnRowStatus=mscRtgDpnRowStatus, mscRtgDpnCallServerModuleRidsValue=mscRtgDpnCallServerModuleRidsValue, mscRtgDpnFwdStatsEntry=mscRtgDpnFwdStatsEntry, mscRtgDpnCsDelayNextHopLinkGroupsEntry=mscRtgDpnCsDelayNextHopLinkGroupsEntry, mscRtgDpnRidIndex=mscRtgDpnRidIndex, mscRtgDpnLpStatsNormalReliabilityPackets=mscRtgDpnLpStatsNormalReliabilityPackets, dpnRoutingCapabilitiesCA02=dpnRoutingCapabilitiesCA02, mscRtgDpnCsIndex=mscRtgDpnCsIndex, mscRtgDpnCallServerModuleRidsTable=mscRtgDpnCallServerModuleRidsTable, mscRtgDpnDiscardLpCongested=mscRtgDpnDiscardLpCongested, mscRtgDpnRidOperEntry=mscRtgDpnRidOperEntry, mscRtgDpnLgComponentName=mscRtgDpnLgComponentName, mscRtgDpnLgOperTable=mscRtgDpnLgOperTable, mscRtgDpnArtErrRidRowStatus=mscRtgDpnArtErrRidRowStatus, mscRtgDpnArtRowStatusEntry=mscRtgDpnArtRowStatusEntry, mscRtgDpnArtNumOfLoopDests=mscRtgDpnArtNumOfLoopDests, mscRtgDpnRidRowStatusEntry=mscRtgDpnRidRowStatusEntry, mscRtgDpnMidRowStatus=mscRtgDpnMidRowStatus, mscRtgDpnRidRowStatus=mscRtgDpnRidRowStatus, mscRtgDpnRidTputPathTrafficProportionsTable=mscRtgDpnRidTputPathTrafficProportionsTable, mscRtgDpnCsTputMetricIndex=mscRtgDpnCsTputMetricIndex, mscRtgDpnMidTputNextHopLinkGroupsValue=mscRtgDpnMidTputNextHopLinkGroupsValue, mscRtgDpnCsRowStatusEntry=mscRtgDpnCsRowStatusEntry, mscRtgDpnCsDelayNextHopLinkGroupsIndex=mscRtgDpnCsDelayNextHopLinkGroupsIndex, mscRtgDpnCsDelayPathTrafficProportionsTable=mscRtgDpnCsDelayPathTrafficProportionsTable, mscRtgDpnArtErrRidThroughputCosErrType=mscRtgDpnArtErrRidThroughputCosErrType, mscRtgDpnRidTputMetricTable=mscRtgDpnRidTputMetricTable, mscRtgDpnVarianceValue=mscRtgDpnVarianceValue, mscRtgDpnLgFarEndMid=mscRtgDpnLgFarEndMid, mscRtgDpnArtErrRidDelayErrPathValue=mscRtgDpnArtErrRidDelayErrPathValue, mscRtgDpnNormalReliabilityPackets=mscRtgDpnNormalReliabilityPackets, mscRtgDpnCsComponentName=mscRtgDpnCsComponentName, mscRtgDpnRidDelayNextHopLinkGroupsIndex=mscRtgDpnRidDelayNextHopLinkGroupsIndex, dpnRoutingMIB=dpnRoutingMIB, mscRtgDpnOutOfSequencePkt=mscRtgDpnOutOfSequencePkt, mscRtgDpnControlBytesRx=mscRtgDpnControlBytesRx, mscRtgDpnConStatsEntry=mscRtgDpnConStatsEntry, mscRtgDpnComponentName=mscRtgDpnComponentName, mscRtgDpnCallServerModuleRidsEntry=mscRtgDpnCallServerModuleRidsEntry, mscRtgDpnArtErrRidRowStatusEntry=mscRtgDpnArtErrRidRowStatusEntry, mscRtgDpnArtErrRidDelayErrPathTable=mscRtgDpnArtErrRidDelayErrPathTable, mscRtgDpnSubnetMidsValue=mscRtgDpnSubnetMidsValue, mscRtgDpnRidDpnTputMetric=mscRtgDpnRidDpnTputMetric, mscRtgDpnCsDelayMetricIndex=mscRtgDpnCsDelayMetricIndex, mscRtgDpnArtErrMidStorageType=mscRtgDpnArtErrMidStorageType, mscRtgDpnCsRowStatusTable=mscRtgDpnCsRowStatusTable, mscRtgDpnArtErrRidTputErrPathEntry=mscRtgDpnArtErrRidTputErrPathEntry, mscRtgDpnRidDelayPathTrafficProportionsValue=mscRtgDpnRidDelayPathTrafficProportionsValue, mscRtgDpnLgTputMetric=mscRtgDpnLgTputMetric, mscRtgDpnArtErrRidOperEntry=mscRtgDpnArtErrRidOperEntry, mscRtgDpnArtErrRid=mscRtgDpnArtErrRid, mscRtgDpnArtErrMidRowStatusTable=mscRtgDpnArtErrMidRowStatusTable, mscRtgDpnVarianceCosIndex=mscRtgDpnVarianceCosIndex, mscRtgDpnRidMidRowStatusTable=mscRtgDpnRidMidRowStatusTable, mscRtgDpnFwdStatsTable=mscRtgDpnFwdStatsTable, mscRtgDpnLpStatsComponentName=mscRtgDpnLpStatsComponentName, mscRtgDpnMidTputMetricValue=mscRtgDpnMidTputMetricValue, mscRtgDpnArtErrMidDelayErrPathEntry=mscRtgDpnArtErrMidDelayErrPathEntry, mscRtgDpnProvEntry=mscRtgDpnProvEntry, mscRtgDpnArtErrMidTputErrPathTable=mscRtgDpnArtErrMidTputErrPathTable, mscRtgDpnLpStatsDiscardNoRoute=mscRtgDpnLpStatsDiscardNoRoute, mscRtgDpnRidTputMetricEntry=mscRtgDpnRidTputMetricEntry, mscRtgDpnArtOperTable=mscRtgDpnArtOperTable, mscRtgDpnVarianceMetricRangeIndex=mscRtgDpnVarianceMetricRangeIndex, mscRtgDpnRidTputPathTrafficProportionsIndex=mscRtgDpnRidTputPathTrafficProportionsIndex, dpnRoutingGroupCA=dpnRoutingGroupCA, mscRtgDpnMidTputMetricTable=mscRtgDpnMidTputMetricTable, mscRtgDpnInterruptingPackets=mscRtgDpnInterruptingPackets, mscRtgDpnRidDelayMetricValue=mscRtgDpnRidDelayMetricValue, mscRtgDpnArtErrRidRowStatusTable=mscRtgDpnArtErrRidRowStatusTable, mscRtgDpnCsStorageType=mscRtgDpnCsStorageType, mscRtgDpnDelayPackets=mscRtgDpnDelayPackets, mscRtgDpnRidOperTable=mscRtgDpnRidOperTable, mscRtgDpnCsRowStatus=mscRtgDpnCsRowStatus, mscRtgDpnLgIndex=mscRtgDpnLgIndex, mscRtgDpnLpStatsRowStatus=mscRtgDpnLpStatsRowStatus, mscRtgDpnArtProvTable=mscRtgDpnArtProvTable, mscRtgDpnControlBytesTx=mscRtgDpnControlBytesTx, mscRtgDpnRidFilterStorageType=mscRtgDpnRidFilterStorageType, mscRtgDpnRidFilterRowStatus=mscRtgDpnRidFilterRowStatus, mscRtgDpnForwardingPolicy=mscRtgDpnForwardingPolicy, mscRtgDpnMidDelayPathTrafficProportionsEntry=mscRtgDpnMidDelayPathTrafficProportionsEntry, mscRtgDpnThroughputPackets=mscRtgDpnThroughputPackets, mscRtgDpnRidRowStatusTable=mscRtgDpnRidRowStatusTable, mscRtgDpnDelayMetricRangeBoundary=mscRtgDpnDelayMetricRangeBoundary, mscRtgDpnSubnetMidsEntry=mscRtgDpnSubnetMidsEntry, mscRtgDpnTotalPackets=mscRtgDpnTotalPackets, mscRtgDpnRidDelayPathTrafficProportionsEntry=mscRtgDpnRidDelayPathTrafficProportionsEntry, mscRtgDpnRidDelayMetricIndex=mscRtgDpnRidDelayMetricIndex, mscRtgDpnProvTable=mscRtgDpnProvTable, mscRtgDpnMidTputPathTrafficProportionsTable=mscRtgDpnMidTputPathTrafficProportionsTable, mscRtgDpnArtOperEntry=mscRtgDpnArtOperEntry, mscRtgDpnLgRowStatusTable=mscRtgDpnLgRowStatusTable, mscRtgDpnRidTputNextHopLinkGroupsIndex=mscRtgDpnRidTputNextHopLinkGroupsIndex, mscRtgDpnRidMidRowStatus=mscRtgDpnRidMidRowStatus, mscRtgDpnMidRowStatusTable=mscRtgDpnMidRowStatusTable, mscRtgDpnCsDelayNextHopLinkGroupsTable=mscRtgDpnCsDelayNextHopLinkGroupsTable, mscRtgDpnLpStatsDelayPackets=mscRtgDpnLpStatsDelayPackets, mscRtgDpnArtErrMid=mscRtgDpnArtErrMid, mscRtgDpnLgDelayMetric=mscRtgDpnLgDelayMetric, mscRtgDpnArtErrMidRowStatusEntry=mscRtgDpnArtErrMidRowStatusEntry, mscRtgDpnRidFilterComponentName=mscRtgDpnRidFilterComponentName, mscRtgDpnRidFilterImportRidListEntry=mscRtgDpnRidFilterImportRidListEntry, mscRtgDpnArtComponentName=mscRtgDpnArtComponentName, mscRtgDpnMidDelayMetricIndex=mscRtgDpnMidDelayMetricIndex, mscRtgDpnArtErrMidThroughputCosErrType=mscRtgDpnArtErrMidThroughputCosErrType, mscRtgDpnArtErrRidOperTable=mscRtgDpnArtErrRidOperTable, mscRtgDpnLpStatsRowStatusEntry=mscRtgDpnLpStatsRowStatusEntry, mscRtgDpnDiscardNoRoute=mscRtgDpnDiscardNoRoute, mscRtgDpnMidDelayMetricEntry=mscRtgDpnMidDelayMetricEntry, mscRtgDpnArtRowStatusTable=mscRtgDpnArtRowStatusTable, mscRtgDpnArtRowStatus=mscRtgDpnArtRowStatus, mscRtgDpnArt=mscRtgDpnArt, mscRtgDpnArtErrMidDelayErrPathValue=mscRtgDpnArtErrMidDelayErrPathValue, mscRtgDpnArtNumOfTimeoutDests=mscRtgDpnArtNumOfTimeoutDests, mscRtgDpnCsTputMetricTable=mscRtgDpnCsTputMetricTable, mscRtgDpnLpStatsIndex=mscRtgDpnLpStatsIndex, mscRtgDpnRidMidStorageType=mscRtgDpnRidMidStorageType, mscRtgDpnRidFilterImportRidListTable=mscRtgDpnRidFilterImportRidListTable, mscRtgDpnLg=mscRtgDpnLg, mscRtgDpnArtTestInterval=mscRtgDpnArtTestInterval)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-DpnRoutingMIB", mscRtgDpnRidTputNextHopLinkGroupsEntry=mscRtgDpnRidTputNextHopLinkGroupsEntry, mscRtgDpnRidFilterExportRidListValue=mscRtgDpnRidFilterExportRidListValue)

#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:30:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
DisplayString, StorageType, Unsigned32, Counter32, InterfaceIndex, RowStatus, Integer32, RowPointer, Gauge32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "DisplayString", "StorageType", "Unsigned32", "Counter32", "InterfaceIndex", "RowStatus", "Integer32", "RowPointer", "Gauge32")
Unsigned64, PassportCounter64, Link, HexString, NonReplicated, DigitString, EnterpriseDateAndTime, Hex, AsciiString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "Unsigned64", "PassportCounter64", "Link", "HexString", "NonReplicated", "DigitString", "EnterpriseDateAndTime", "Hex", "AsciiString")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, iso, Unsigned32, Counter32, Bits, Integer32, TimeTicks, ModuleIdentity, ObjectIdentity, MibIdentifier, IpAddress, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "iso", "Unsigned32", "Counter32", "Bits", "Integer32", "TimeTicks", "ModuleIdentity", "ObjectIdentity", "MibIdentifier", "IpAddress", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
mpaNetworkLinkMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119))
mscMpanl = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123))
mscMpanlRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 1), )
if mibBuilder.loadTexts: mscMpanlRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanl components.')
mscMpanlRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanl component.')
mscMpanlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanl components. These components can be added and deleted.')
mscMpanlComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlStorageType.setDescription('This variable represents the storage type value for the mscMpanl tables.')
mscMpanlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mscMpanlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIndex.setDescription('This variable represents the index for the mscMpanl tables.')
mscMpanlCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 10), )
if mibBuilder.loadTexts: mscMpanlCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlCidDataTable.setDescription("This group contains the attribute for the MPANL component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscMpanlCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlCidDataEntry.setDescription('An entry in the mscMpanlCidDataTable.')
mscMpanlCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscMpanlProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 12), )
if mibBuilder.loadTexts: mscMpanlProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlProvTable.setDescription('This group contains provisionable attributes of the MPANL service.')
mscMpanlProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlProvEntry.setDescription('An entry in the mscMpanlProvTable.')
mscMpanlCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlCommentText.setDescription('This attribute specifies the name the customer wishes to associate with this MPANL interface.')
mscMpanlEmissionPriorityQsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 13), )
if mibBuilder.loadTexts: mscMpanlEmissionPriorityQsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlEmissionPriorityQsTable.setDescription('This group contains the provisionable attribute to specifie the number of Frame Relay egress emission priority queues to be used on that Frame Relay Interface')
mscMpanlEmissionPriorityQsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlEmissionPriorityQsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlEmissionPriorityQsEntry.setDescription('An entry in the mscMpanlEmissionPriorityQsTable.')
mscMpanlNumberOfEmissionQs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), )).clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlNumberOfEmissionQs.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlNumberOfEmissionQs.setDescription('This attribute specifies the number of egress emission priority queues that will be used for that Frame Relay interface. The possible values of this attribute are 2 or 4: For V.35, V.11, HSSI, E1, DS1, E3, DS3 or 8pDS1 the possible values are: 2 (in which case they are hardware queues), or 4 (in which case they are software queues). For DS1C, E1C or DS3C the possible values are 2, 4 (in all cases they are software queues).')
mscMpanlStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14), )
if mibBuilder.loadTexts: mscMpanlStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscMpanlStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlStateEntry.setDescription('An entry in the mscMpanlStateTable.')
mscMpanlAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMpanlOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMpanlUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMpanlAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscMpanlProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscMpanlControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscMpanlAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscMpanlStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscMpanlUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscMpanlStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 16), )
if mibBuilder.loadTexts: mscMpanlStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlStatsTable.setDescription('FrUni/n Statistics This group contains the statistics about the operational behavior of the service at the interface level.')
mscMpanlStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlStatsEntry.setDescription('An entry in the mscMpanlStatsTable.')
mscMpanlLastUnknownDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 16, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlLastUnknownDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLastUnknownDlci.setDescription('This attribute identifies the most recent DLCI which user frames were received on for which a DLCI has not been provisioned on the port.')
mscMpanlUnknownDlciFramesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlUnknownDlciFramesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlUnknownDlciFramesFromIf.setDescription('This attribute contains a count of the number of frames received from the interface with an unknown DLCI (DLCI which is not provisioned). When the maximum is reached the count wraps to zero.')
mscMpanlInvalidHeaderFramesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlInvalidHeaderFramesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlInvalidHeaderFramesFromIf.setDescription('This attribute counts the number of frames received from the interface with an invalid header format. When the maximum is reached the count wraps to zero.')
mscMpanlTrafficStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 17), )
if mibBuilder.loadTexts: mscMpanlTrafficStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlTrafficStatsTable.setDescription('This operational group provides the traffic statistics of the service at the interface level. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscMpanlTrafficStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlTrafficStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlTrafficStatsEntry.setDescription('An entry in the mscMpanlTrafficStatsTable.')
mscMpanlFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 17, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrmToIf.setDescription('This attribute counts frames transmitted to the interface. This count may differ from its framer couterpart because Voice over Frame Relay function may fragment and pack the Frame Relay frames before transmission. When the maximum is reached the count wraps to zero.')
mscMpanlOctetToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlOctetToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOctetToIf.setDescription('This attribute counts octets transmitted to the interface. This count may differ from its framer couterpart because Voice over Frame Relay function may fragment and pack the Frame Relay frames before transmission. When the maximum is reached the count wraps to zero.')
mscMpanlFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 17, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrmFromIf.setDescription('This attribute counts frames received from the interface. This count may differ from its framer couterpart because Voice over Frame Relay function may fragment and pack the Frame Relay frames before transmission. When the maximum is reached the count wraps to zero.')
mscMpanlOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 17, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlOctetFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOctetFromIf.setDescription('This attribute counts octets received from the interface. This count may differ from its framer couterpart because Voice over Frame Relay function may fragment and pack the Frame Relay frames before transmission. When the maximum is reached the count wraps to zero.')
mscMpanlIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 23), )
if mibBuilder.loadTexts: mscMpanlIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscMpanlIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 23, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIfEntryEntry.setDescription('An entry in the mscMpanlIfEntryTable.')
mscMpanlIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 23, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscMpanlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 23, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscMpanlOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 24), )
if mibBuilder.loadTexts: mscMpanlOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscMpanlOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 24, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOperStatusEntry.setDescription('An entry in the mscMpanlOperStatusTable.')
mscMpanlSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 24, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscMpanlOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 25), )
if mibBuilder.loadTexts: mscMpanlOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOperTable.setDescription('This group contains miscelleneous operational attributes of the MPANL service.')
mscMpanlOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 25, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOperEntry.setDescription('An entry in the mscMpanlOperTable.')
mscMpanlRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 25, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlRoundTripDelay.setDescription('This attribute indicates the round trip delay of the MPANL interface. The round trip delay measurement is only made when this attribute is displayed. The measured value is rounded up to the next millisecond. This attribute has the value 0, if the delay measurement cannot be made.')
mscMpanlFrmToIfByQueueTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 350), )
if mibBuilder.loadTexts: mscMpanlFrmToIfByQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrmToIfByQueueTable.setDescription('This attribute counts the total number of frames transmitted to the interface per egress emission priority queue since the component has been activated. There is potentially a maximum of 4 emission priority queues. The number of available egress queues varies according to the value of the provisionable attribute numberOfEmissionQs. Egress queue 0 has the lowest priority, while egress queue 3 has the highest priority.')
mscMpanlFrmToIfByQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 350, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFrmToIfByQueueIndex"))
if mibBuilder.loadTexts: mscMpanlFrmToIfByQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrmToIfByQueueEntry.setDescription('An entry in the mscMpanlFrmToIfByQueueTable.')
mscMpanlFrmToIfByQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 350, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscMpanlFrmToIfByQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrmToIfByQueueIndex.setDescription('This variable represents the index for the mscMpanlFrmToIfByQueueTable.')
mscMpanlFrmToIfByQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 350, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrmToIfByQueueValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrmToIfByQueueValue.setDescription('This variable represents an individual value for the mscMpanlFrmToIfByQueueTable.')
mscMpanlOctetToIfByQueueTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 351), )
if mibBuilder.loadTexts: mscMpanlOctetToIfByQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOctetToIfByQueueTable.setDescription('This attribute counts the total number of octets transmitted from the service to the interface per emission priority queue since the component has been activated. There is potentially a maximum of 4 emission priority queues. The number of available egress queues varies according to the value of the provisionable attribute numberOfEmissionQs. Egress queue 0 has the lowest priority, while egress queue 3 has the highest priority.')
mscMpanlOctetToIfByQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 351, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlOctetToIfByQueueIndex"))
if mibBuilder.loadTexts: mscMpanlOctetToIfByQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOctetToIfByQueueEntry.setDescription('An entry in the mscMpanlOctetToIfByQueueTable.')
mscMpanlOctetToIfByQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 351, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscMpanlOctetToIfByQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOctetToIfByQueueIndex.setDescription('This variable represents the index for the mscMpanlOctetToIfByQueueTable.')
mscMpanlOctetToIfByQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 351, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlOctetToIfByQueueValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlOctetToIfByQueueValue.setDescription('This variable represents an individual value for the mscMpanlOctetToIfByQueueTable.')
mscMpanlDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2))
mscMpanlDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 1), )
if mibBuilder.loadTexts: mscMpanlDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlDna components.')
mscMpanlDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDnaIndex"))
if mibBuilder.loadTexts: mscMpanlDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlDna component.')
mscMpanlDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlDna components. These components cannot be added nor deleted.')
mscMpanlDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaStorageType.setDescription('This variable represents the storage type value for the mscMpanlDna tables.')
mscMpanlDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaIndex.setDescription('This variable represents the index for the mscMpanlDna tables.')
mscMpanlDnaOutgoingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 11), )
if mibBuilder.loadTexts: mscMpanlDnaOutgoingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaOutgoingOptionsTable.setDescription('DnaOutOptionsProv group defines call options of a Dna for calls which are made out of the interface represented by Dna. All these options are not used for calls arriving to the interface represented by Dna.')
mscMpanlDnaOutgoingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDnaIndex"))
if mibBuilder.loadTexts: mscMpanlDnaOutgoingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaOutgoingOptionsEntry.setDescription('An entry in the mscMpanlDnaOutgoingOptionsTable.')
mscMpanlDnaDefaultTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlDnaDefaultTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaDefaultTransferPriority.setDescription('This attribute specifies the default transfer priority to network for all outgoing calls using this particular Dna. The transfer priority is a preference configured for an application according to its delay-sensitivity requirement. Frames with higher transfer priority are served by the network before the frames with lower priority. The transfer priority standard is defined to have 16 levels from 0 to 15. Each transfer priority n, where n indicates the transfer priority index, contains a default setting for routing class of service (multimedia, delay or throughput) and frame relay egress queue (depending on the number of supported egress queues on the remote end interface) specified by the routingClassOfService and emissionPriority attributes provisioned in the Mod Frs DprsNet Tpm/n component. The default mapping can be altered by a user if required. The default defaultTransferPriority is 0.')
mscMpanlDnaCallOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 13), )
if mibBuilder.loadTexts: mscMpanlDnaCallOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaCallOptionsTable.setDescription('DnaCallOptions group defines additional options for calls not related directly to direction of a call.')
mscMpanlDnaCallOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDnaIndex"))
if mibBuilder.loadTexts: mscMpanlDnaCallOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaCallOptionsEntry.setDescription('An entry in the mscMpanlDnaCallOptionsTable.')
mscMpanlDnaAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 13, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlDnaAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaAccountClass.setDescription('This attribute specifies the accounting class which is reserved for network operations usage. Its value is returned in the accounting record in the local and remote service type attributes. Use of this attribute is decided by network operator. This attribute is returned by the local VC in the accounting record for all calls setup using this particular DNA.')
mscMpanlDnaAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 13, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlDnaAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaAccountCollection.setDescription("This set attribute indicates that accounting records are to be collected by the network for the various reasons: billing, test, study, auditing. The last of the parameters, force, indicates that accounting records are to be collected irrespective of other collection reasons. The force option is available for X.75 Gateways only. If none of these reasons are set, then accounting will be suppressed. To set a specific accounting collection reason, the reason is entered and the corresponding bit in the structure is set to a value of 1. To turn off a specific accounting collection reason, the reason is entered preceeded with the '^' character, and the corresponding bit in the structure is set to a value of 0. The bit placement for the accounting collection reasons is as follows: Bit 0 - Bill Bit 1 - Test Bit 2 - Study Bit 3 - Audit Bit 4 - Force Description of bits: bill(0) test(1) study(2) audit(3) force(4)")
mscMpanlDnaServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 13, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlDnaServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaServiceExchange.setDescription('This attribute is an arbitrary number, Data Service Exchange, as entered by the network operator and reported in accounting record. It is converted into an internal 8-bit integer value for use in the accounting record as well as in various X.25 and X.75 Tariff utilities.')
mscMpanlDnaEgressAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 2, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlDnaEgressAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDnaEgressAccounting.setDescription('This attribute specifies if Egress accounting is enabled by the MPANL service. Disabling of Egress accounting means that only segment counts are collected by VC and there are no frame relay counts in accounting records for the MPANL service. Enabling of Egress accounting means that the accounting records for MPANL contain frame relay specific counts.')
mscMpanlFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3))
mscMpanlFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 1), )
if mibBuilder.loadTexts: mscMpanlFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlFramer components.')
mscMpanlFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFramerIndex"))
if mibBuilder.loadTexts: mscMpanlFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlFramer component.')
mscMpanlFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlFramer components. These components can be added and deleted.')
mscMpanlFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerStorageType.setDescription('This variable represents the storage type value for the mscMpanlFramer tables.')
mscMpanlFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerIndex.setDescription('This variable represents the index for the mscMpanlFramer tables.')
mscMpanlFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 10), )
if mibBuilder.loadTexts: mscMpanlFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscMpanlFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFramerIndex"))
if mibBuilder.loadTexts: mscMpanlFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerProvEntry.setDescription('An entry in the mscMpanlFramerProvTable.')
mscMpanlFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscMpanlFramerLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 11), )
if mibBuilder.loadTexts: mscMpanlFramerLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerLinkTable.setDescription('This group contains attributes defining the framing of data on the link interface.')
mscMpanlFramerLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFramerIndex"))
if mibBuilder.loadTexts: mscMpanlFramerLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerLinkEntry.setDescription('An entry in the mscMpanlFramerLinkTable.')
mscMpanlFramerDataInversion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 16))).clone(namedValues=NamedValues(("off", 0), ("on", 16))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlFramerDataInversion.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerDataInversion.setDescription("This attribute determines whether data bits are to be inverted (1 to 0 and 0 to 1) before transmission of frames to the interface. If the value of this attribute is On, the incoming data bits will also be inverted when frames are received from the link before being processed. This option is typically used in hdlc framing mode when inversion is used to guarantee 1's density. Note that aborts (in hdlc and interrupting modes) are corrupted when data is inverted. This attribute may only take its default value for non-MSA cards.")
mscMpanlFramerFrameCrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("crc16", 0), ("crc32", 1), ("noCrc", 2))).clone('crc16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlFramerFrameCrcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerFrameCrcType.setDescription('This attribute defines the type of CRC used. The CRC value calculated is appended to the end of the frames transmitted to the link. The CRC value is removed from the end of frames received from the link and checked for correctness. NoCrc means that CRC is not used. This attribute may take only its default value for non-MSA cards.')
mscMpanlFramerFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlFramerFlagsBetweenFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerFlagsBetweenFrames.setDescription('This attribute defines the number of flags that are inserted between frames sent to the link interface.')
mscMpanlFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 12), )
if mibBuilder.loadTexts: mscMpanlFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscMpanlFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFramerIndex"))
if mibBuilder.loadTexts: mscMpanlFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerStateEntry.setDescription('An entry in the mscMpanlFramerStateTable.')
mscMpanlFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscMpanlFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscMpanlFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscMpanlFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13), )
if mibBuilder.loadTexts: mscMpanlFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscMpanlFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFramerIndex"))
if mibBuilder.loadTexts: mscMpanlFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerStatsEntry.setDescription('An entry in the mscMpanlFramerStatsTable.')
mscMpanlFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerFrmToIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscMpanlFramerFrmToIf.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscMpanlFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerFrmFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscMpanlFramerFrmFromIf.setDescription('The number of frames received from the link interface by Framer.')
mscMpanlFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerOctetFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscMpanlFramerOctetFromIf.setDescription('The number of bytes received from the link interface by Framer.')
mscMpanlFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerAborts.setDescription('This attribute is the total number of aborts received.')
mscMpanlFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerCrcErrors.setDescription('This attribute is the total number of frames with CRC errors, occurring in the receive direction from the link.')
mscMpanlFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerLrcErrors.setDescription('This attribute is the total number of frames with LRC errors, occurring in the Tx link prior to transmission onto the link.')
mscMpanlFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerNonOctetErrors.setDescription('This attribute is the total number of frames that were non octet aligned.')
mscMpanlFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerOverruns.setDescription('This attribute is the total number of frames received from the link for which overruns occurred.')
mscMpanlFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerUnderruns.setDescription('This attribute is the total number of frames transmitted to the link for which underruns occurred.')
mscMpanlFramerLargeFrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerLargeFrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerLargeFrmErrors.setDescription('This attribute is the total number of frames received which were too large. The frame execeeded the maximumFrameLengthLimit provisioned attribute or it contained more than the 255 block hardware limit.')
mscMpanlFramerFrmModeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerFrmModeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerFrmModeErrors.setDescription('This attribute is the total number of frames detected with framing mode errors. A framingModeError is flagged when frames are inconsistent with the specified framingType, that is when interrupting frames are used while running in hdlc mode.')
mscMpanlFramerFrmToIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerFrmToIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerFrmToIf64.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscMpanlFramerFrmFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerFrmFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerFrmFromIf64.setDescription('The number of frames received from the link interface by Framer.')
mscMpanlFramerOctetFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 13, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerOctetFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerOctetFromIf64.setDescription('The number of bytes received from the link interface by Framer.')
mscMpanlFramerUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 14), )
if mibBuilder.loadTexts: mscMpanlFramerUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerUtilTable.setDescription('This group contains the link utilizaiton operational data for a Framer component.')
mscMpanlFramerUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFramerIndex"))
if mibBuilder.loadTexts: mscMpanlFramerUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerUtilEntry.setDescription('An entry in the mscMpanlFramerUtilTable.')
mscMpanlFramerNormPrioLinkUtilToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 14, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerNormPrioLinkUtilToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerNormPrioLinkUtilToIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) sent to the link as a percentage of the available bandwidth on the link. Note that this indluces traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscMpanlFramerNormPrioLinkUtilFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 3, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFramerNormPrioLinkUtilFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFramerNormPrioLinkUtilFromIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) received from the link as a percentage of the available bandwidth on the link. Note that this includes traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscMpanlPrefixDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 4))
mscMpanlPrefixDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 4, 1), )
if mibBuilder.loadTexts: mscMpanlPrefixDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlPrefixDnaRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscMpanlPrefixDna components.')
mscMpanlPrefixDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlPrefixDnaNumberingPlanIndicatorIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlPrefixDnaDataNetworkAddressIndex"))
if mibBuilder.loadTexts: mscMpanlPrefixDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlPrefixDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlPrefixDna component.')
mscMpanlPrefixDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlPrefixDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlPrefixDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlPrefixDna components. These components cannot be added nor deleted.')
mscMpanlPrefixDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlPrefixDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlPrefixDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlPrefixDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlPrefixDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlPrefixDnaStorageType.setDescription('This variable represents the storage type value for the mscMpanlPrefixDna tables.')
mscMpanlPrefixDnaNumberingPlanIndicatorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))))
if mibBuilder.loadTexts: mscMpanlPrefixDnaNumberingPlanIndicatorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlPrefixDnaNumberingPlanIndicatorIndex.setDescription('This variable represents an index for the mscMpanlPrefixDna tables.')
mscMpanlPrefixDnaDataNetworkAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 4, 1, 1, 11), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15)))
if mibBuilder.loadTexts: mscMpanlPrefixDnaDataNetworkAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlPrefixDnaDataNetworkAddressIndex.setDescription('This variable represents an index for the mscMpanlPrefixDna tables.')
mscMpanlDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5))
mscMpanlDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 1), )
if mibBuilder.loadTexts: mscMpanlDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscMpanlDlci components.')
mscMpanlDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"))
if mibBuilder.loadTexts: mscMpanlDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlDlci component.')
mscMpanlDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlDlci components. These components cannot be added nor deleted.')
mscMpanlDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciStorageType.setDescription('This variable represents the storage type value for the mscMpanlDlci tables.')
mscMpanlDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(17, 1007)))
if mibBuilder.loadTexts: mscMpanlDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciIndex.setDescription('This variable represents the index for the mscMpanlDlci tables.')
mscMpanlDlciStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10), )
if mibBuilder.loadTexts: mscMpanlDlciStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciStateTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscMpanlDlciStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"))
if mibBuilder.loadTexts: mscMpanlDlciStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciStateEntry.setDescription('An entry in the mscMpanlDlciStateTable.')
mscMpanlDlciAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMpanlDlciOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMpanlDlciUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscMpanlDlciAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscMpanlDlciProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscMpanlDlciControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscMpanlDlciAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscMpanlDlciStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscMpanlDlciUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscMpanlDlciCalldTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 11), )
if mibBuilder.loadTexts: mscMpanlDlciCalldTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciCalldTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group of attributes describes the characteristics of the call such as call type and call state.')
mscMpanlDlciCalldEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"))
if mibBuilder.loadTexts: mscMpanlDlciCalldEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciCalldEntry.setDescription('An entry in the mscMpanlDlciCalldTable.')
mscMpanlDlciQ933CallState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 6, 9, 10, 11, 12, 19, 20))).clone(namedValues=NamedValues(("null", 0), ("callInitiated", 1), ("outgoingCallProceeding", 3), ("callPresent", 6), ("incomingCallProceeding", 9), ("active", 10), ("disconnectRequest", 11), ("disconnectIndication", 12), ("releaseRequest", 19), ("notApplicable", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciQ933CallState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciQ933CallState.setDescription("This attribute indicates the Q.933 state of an SVC call. In the description that follows, 'local' refers to the user who has initiated the SETUP request, and 'remote' refers to the user to whom the local user wishes to connect. State description: In the null state, the network has neither received nor sent call setup requests for this DLCI. In the callInitiated state, the network has received a SETUP message from the local user. In the outgoingCallProceeding state, the network has sent a CALL PROCEEDING message to the local user in response to the SETUP message. In the callPresent state, the network has sent a SETUP message to the remote user. In the incomingCallProceeding state, the network has received a CALL PROCEEDING message from the remote user in response to a SETUP message. In the active state, either the network has sent a CONNECT message to the local user, or the network has received a CONNECT from the remote user. In the disconnectRequest state, the network has received a DISCONNECT message from the local user. In the disconnectIndication state, the network has sent a DISCONNECT to the local user. In the releaseRequest state, the network has sent out a RELEASE message to the local user. The notApplicable state indicates that this attribute is meaningless because the DLCI is a PVC.")
mscMpanlDlciQ933CallReference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciQ933CallReference.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciQ933CallReference.setDescription('This attribute indicates the Q.933 call reference number associated with this DLCI.')
mscMpanlDlciSpOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12), )
if mibBuilder.loadTexts: mscMpanlDlciSpOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciSpOpTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the service parameters specific to this instance of Dlci.')
mscMpanlDlciSpOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"))
if mibBuilder.loadTexts: mscMpanlDlciSpOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciSpOpEntry.setDescription('An entry in the mscMpanlDlciSpOpTable.')
mscMpanlDlciMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciMaximumFrameSize.setDescription('This attribute specifies the maximum number of octets which may be included in the information field. The frame relay header and CRC octets are not included in this definition. This attribute corresponds to the dN1 parameter described in the Frame Relay Vendor Forum Specification.')
mscMpanlDlciCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciCommittedBurstSize.setDescription('This attribute indicates the committed burst size (Bc) in bits. bc is the amount of data that a network agrees to transfer under normal conditions over a measurement interval (t). Data marked DE=1 is not accounted for in Bc. This attribute should be ignored when rateEnforcement is off.')
mscMpanlDlciExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciExcessBurstSize.setDescription('This attribute indicates the excess burst size (Be) in bits. Be is the amount of uncommitted data that the network will attempt to deliver over measurement interval T. Data marked DE=1 by the user or by the network is accounted for here. This attribute should be ignored when rateEnforcement is off.')
mscMpanlDlciAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciAccounting.setDescription('This attribute indicates whether accounting data collection and record generation is turned on at this DLCI. For accounting data collection and record generation to be occur, the accountingOn attribute must be on and at least one of the accountCollection options in the DataNetworkAddress component must be selected.')
mscMpanlDlciEmissionPriorityToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(3, 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciEmissionPriorityToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciEmissionPriorityToIf.setDescription('This attribute indicates the emission priority of frames sent to the interface. A larger value denotes a higher priority.')
mscMpanlDlciTransferPriToNwk = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciTransferPriToNwk.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciTransferPriToNwk.setDescription('This attribute indicates the priority at which data is transferred to the network. The transfer priority is a preference configured for an application according to its delay-sensitivity requirement. Frames with higher transfer priority are served by the network before the frames with lower priority. The transfer priority standard is defined to have 16 indices from 0 to 15. Each transfer priority n, where n specifies the transfer priority index, contains a default setting for routing class of service (multimedia, delay or throughput) and frame relay egress queue (depending on the number of supported egress queues on the remote end interface) specified by the routingClassOfService and emissionPriority attributes provisioned in the Mod Frs DprsNet Tpm/n component. The default mapping can be altered by a user if required.')
mscMpanlDlciTransferPriFromNwk = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciTransferPriFromNwk.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciTransferPriFromNwk.setDescription('This attribute indicates the priority at which data is transferred from the network. The transfer priority is a preference configured for an application according to its delay-sensitivity requirement. Frames with higher transfer priority are served by the network before the frames with lower priority. The transfer priority standard is defined to have 16 indices from 0 to 15. Each transfer priority n, where n specifies the transfer priority index, contains a default setting for routing class of service (multimedia, delay or throughput) and frame relay egress queue (depending on the number of supported egress queues on the remote end interface) specified by the routingClassOfService and emissionPriority attributes provisioned in the Mod Frs DprsNet Tpm/n component. The default mapping can be altered by a user if required.')
mscMpanlDlciStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13), )
if mibBuilder.loadTexts: mscMpanlDlciStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational statistics for the MPANL Data Link Connection Identifier.')
mscMpanlDlciStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"))
if mibBuilder.loadTexts: mscMpanlDlciStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciStatsEntry.setDescription('An entry in the mscMpanlDlciStatsTable.')
mscMpanlDlciFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciFrmToIf.setDescription('This attribute counts the frames sent out the interface. When the maximum count is reached the count wraps to zero.')
mscMpanlDlciFecnFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciFecnFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciFecnFrmToIf.setDescription('This attribute counts the frames sent to the interface with the Forward Explicit Congestion Notification (FECN) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciBecnFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciBecnFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciBecnFrmToIf.setDescription('This attribute counts the frames sent to the interface with the Backward Explicit Congestion Notification (BECN) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciBciToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciBciToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciBciToSubnet.setDescription('This attribute counts the frames sent into the network with the Backward Congestion Indication (BCI) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciDeFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDeFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDeFrmToIf.setDescription('This attribute counts the frames sent to the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciDiscCongestedToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscCongestedToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscCongestedToIf.setDescription('This attribute counts the number of frame discards at the MPANL service due to local congestion in the direction toward the interface. When this count reaches maximum, it wraps to zero.')
mscMpanlDlciDiscDeCongestedToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscDeCongestedToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscDeCongestedToIf.setDescription('This attribute counts the number of discarded frames, with the Discard Eligibility (DE) bit set, at the MPANL service, due to local congestion in the direction toward the interface. When this count reaches maximum, it wraps to zero.')
mscMpanlDlciFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciFrmFromIf.setDescription('This attribute counts the frames received from the interface. Frames that are discarded due to error or excess are not counted. When the maximum count is reached the count wraps to zero.')
mscMpanlDlciFecnFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciFecnFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciFecnFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Forward Explicit Congestion Notification (FECN) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciBecnFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciBecnFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciBecnFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Backward Explicit Congestion Notification (BECN) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciFciFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciFciFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciFciFromSubnet.setDescription('This attribute counts the frames received from the network with the Forward Congestion Indication (FCI) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciBciFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciBciFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciBciFromSubnet.setDescription('This attribute counts the frames received from the network with the Backward Congestion Indication (BCI) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciDeFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDeFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDeFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciExcessFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciExcessFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciExcessFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Discard Eligibility (DE) bit clear, but subsequently set by the network due to rate enforcement. When the count reaches maximum it wraps to zero.')
mscMpanlDlciDiscExcessFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscExcessFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscExcessFromIf.setDescription('This attribute counts the frames which were discarded due to rate enforcement. When the count reaches maximum it wraps to zero.')
mscMpanlDlciDiscFrameAbit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscFrameAbit.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscFrameAbit.setDescription('This attribute counts the number of frame discards at the MPANL Service, due to an inactive PVC status, in the direction toward the network. When this count reaches maximum, it wraps to zero.')
mscMpanlDlciDiscCongestedFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscCongestedFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscCongestedFromIf.setDescription('This attribute counts the number of frame discards at the MPANL service due to local congestion in the direction toward the network. When this count reaches maximum, it wraps to zero.')
mscMpanlDlciDiscDeCongestedFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscDeCongestedFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscDeCongestedFromIf.setDescription('This attribute counts the number of discarded frames, with the Discard Eligibility (DE) bit set, at the MPANL service, due to local congestion, in the direction toward the network. When this count reaches maximum, it wraps to zero.')
mscMpanlDlciErrorShortFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciErrorShortFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciErrorShortFrmFromIf.setDescription('This attribute counts the frames received with 0 octets in the information field. When the count reaches maximum it wraps to zero.')
mscMpanlDlciErrorLongFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciErrorLongFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciErrorLongFrmFromIf.setDescription('This attribute counts the frames received with number of octets in the information field greater than the subscribed maximum. When the count reaches maximum it wraps to zero. Frames whose lengths are greater than the hardware receive buffer are ignored by the hardware and are therefore not included in this count.')
mscMpanlDlciBecnFrmSetByService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciBecnFrmSetByService.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciBecnFrmSetByService.setDescription('This attribute counts the number of frames with BECN set by the MPANL service. It is incremented whenever the MPANL service sets BECN on a frame upon detecting local congestion. This count is incremented regardless of whether the frame already bears a set BECN bit since its use is to determine the place of congestion. When the count reaches maximum, it wraps to zero.')
mscMpanlDlciBytesToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciBytesToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciBytesToIf.setDescription('This attribute counts the bytes sent out the interface. When the maximum count is reached the count wraps to zero.')
mscMpanlDlciDeBytesToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDeBytesToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDeBytesToIf.setDescription('This attribute counts the bytes sent to the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciDiscCongestedToIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscCongestedToIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscCongestedToIfBytes.setDescription('This attribute counts the number of byte discards at the MPANL service due to local congestion in the direction toward the link. When this count reaches maximum, it wraps to zero.')
mscMpanlDlciDiscDeCongestedToIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscDeCongestedToIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscDeCongestedToIfBytes.setDescription('This attribute counts the number of discard eligible (DE=1) byte discards at the MPANL service due to local congestion in the direction toward the link. When the maximum count is reached the count wraps to zero.')
mscMpanlDlciBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciBytesFromIf.setDescription('This attribute counts the bytes received from the interface. Bytes that are discarded due to error or excess are not counted. When the maximum count is reached the count wraps to zero.')
mscMpanlDlciDeBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDeBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDeBytesFromIf.setDescription('This attribute counts the bytes received from the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscMpanlDlciExcessBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciExcessBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciExcessBytesFromIf.setDescription('This attribute counts the bytes received from the interface with the Discard Eligibility (DE) bit clear, but subsequently set by the network due to rate enforcement. When the count reaches maximum it wraps to zero.')
mscMpanlDlciDiscExcessFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscExcessFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscExcessFromIfBytes.setDescription('This attribute counts the bytes which were discarded due to rate enforcement. When the count reaches maximum it wraps to zero.')
mscMpanlDlciDiscByteAbit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscByteAbit.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscByteAbit.setDescription('This attribute counts the bytes which were discarded due to aBit turned off.')
mscMpanlDlciDiscCongestedFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscCongestedFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscCongestedFromIfBytes.setDescription('This attribute counts the number of byte discards at the MPANL service due to local congestion in the direction toward the network. When this count reaches maximum, it wraps to zero.')
mscMpanlDlciDiscDeCongestedFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscDeCongestedFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscDeCongestedFromIfBytes.setDescription('This attribute counts the number of discard eligible (DE=1) byte discards at the MPANL service due to local congestion in the direction toward the network. When the maximum count is reached the count wraps to zero.')
mscMpanlDlciErrorLongBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 34), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciErrorLongBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciErrorLongBytesFromIf.setDescription('This attribute counts the bytes received with number of octets in the information field greater than the subscribed maximum. When the count reaches maximum it wraps to zero. Bytes whose lengths are greater than the hardware receive buffer are ignored by the hardware and are therefore not included in this count.')
mscMpanlDlciTransferPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciTransferPriorityToNetwork.setStatus('obsolete')
if mibBuilder.loadTexts: mscMpanlDlciTransferPriorityToNetwork.setDescription('This attribute is obsolete. It is replaced by attribute transferPriorityToNetwork under group FrsNniDataLinkConnectionIdentifierServiceParametersOp.')
mscMpanlDlciTransferPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 13, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciTransferPriorityFromNetwork.setStatus('obsolete')
if mibBuilder.loadTexts: mscMpanlDlciTransferPriorityFromNetwork.setDescription('This attribute is obsolete. It is replaced by attribute transferPriorityFromNetwork under group FrsNniDataLinkConnectionIdentifierServiceParametersOp.')
mscMpanlDlciIntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14), )
if mibBuilder.loadTexts: mscMpanlDlciIntTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciIntTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational statistics for the MPANL Data Link Connection Identifier interval data.')
mscMpanlDlciIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"))
if mibBuilder.loadTexts: mscMpanlDlciIntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciIntEntry.setDescription('An entry in the mscMpanlDlciIntTable.')
mscMpanlDlciStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 1), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciStartTime.setDescription('This attribute indicates the start time of this interval period. If the Vc spans 12 hour time or time of day change, startTime reflects new time as recorded at 12 hour periods or time of day changes. A new interval period is started each time an accounting record is generated.')
mscMpanlDlciTotalIngressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 2), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciTotalIngressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciTotalIngressBytes.setDescription('This attribute counts the total bytes received from the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciTotalEgressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 3), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciTotalEgressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciTotalEgressBytes.setDescription('This attribute counts the total bytes sent to the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciEirIngressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 4), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciEirIngressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciEirIngressBytes.setDescription('This attribute counts the total bytes with the Discard Eligibility (DE) bit set sent to the subnet since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciEirEgressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 5), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciEirEgressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciEirEgressBytes.setDescription('This attribute counts the total bytes with the Discard Eligibility (DE) bit set sent to the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciDiscardedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 6), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscardedBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscardedBytes.setDescription('This attribute counts the total bytes in invalid frames received from the interface and discarded at the DLCI since the start of the interval period. This count is a sum of octets in frames discarded due to the number of octets in the information field greater than the subscribed maximum or equal to 0, due to aBit turned off, or due to rate enforcement. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciTotalIngressSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciTotalIngressSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciTotalIngressSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the total number of segments in frames received from the interface since the start of the interval period. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the total number of frames received from the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciTotalEgressSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciTotalEgressSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciTotalEgressSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the total number of segments in frames sent to the interface since the start of the interval period. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the total number of frames sent to the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciEirIngressSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciEirIngressSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciEirIngressSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the number of segments in frames with the Discard Eligibility (DE) bit set sent to the subnet since the start of the interval period. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the number of frames with the Discard Eligibility (DE) bit set sent to the subnet since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciEirEgressSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciEirEgressSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciEirEgressSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the number of segments in frames with the Discard Eligibility (DE) bit set sent to the interface since the start of the interval period. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the number of frames with the Discard Eligibility (DE) bit set sent to the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscMpanlDlciDiscardedSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciDiscardedSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciDiscardedSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the number of segments in invalid frames received from the interface and discarded at the DLCI. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the number of invalid frames received from the interface and discarded at the DLCI. Segments of frames are counted since the start of the interval period. The count is reset to zero when an accounting record is generated. The count is a sum of segments in frames or frames discarded due to the number of octets in the information field greater than the subscribed maximum or equal to 0, due to aBit turned off, or due to rate enforcement.')
mscMpanlDlciCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciCallReferenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciCallReferenceNumber.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscMpanlDlciElapsedDifference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 14, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciElapsedDifference.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciElapsedDifference.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since the call started.')
mscMpanlDlciAbitTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 15), )
if mibBuilder.loadTexts: mscMpanlDlciAbitTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciAbitTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the A-Bit status information for this Data Link Connection Identifier. A-Bit status information is only applicable for SPVCs. For SVCs, the values of attributes under this group are all notApplicable.')
mscMpanlDlciAbitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"))
if mibBuilder.loadTexts: mscMpanlDlciAbitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciAbitEntry.setDescription('An entry in the mscMpanlDlciAbitTable.')
mscMpanlDlciABitStatusToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1), ("notApplicable", 2))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciABitStatusToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciABitStatusToIf.setDescription('This attribute is the most recent A-Bit status sent to the interface. The A-Bit status is originated from the SPVC end point at the remote end of the Passport subnet and it is relayed to the interface by Mpanl. When an inactive setting is sent out, Mpanl will discard any data offered from the interface. When an active setting is sent out, Mpanl will try to relay all data offered from the interface to the other end of the SPVC.')
mscMpanlDlciABitReasonToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("remoteLmiError", 3), ("remoteLinkDown", 5), ("vcDown", 6))).clone('vcDown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciABitReasonToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciABitReasonToIf.setDescription('This attribute provides the reason (if any) for an inactive status to be sent to the interface. This reason is not applicable for an active status. A-Bit status reason description: The A-Bit status reason is notApplicable when the A-Bit status is active. The A-Bit status reason is remoteUserSignaled if the SPVC end point originating the A-Bit status has detected that the virtual circuit is down at the remote network through the LMI protocol. The SPVC end point must be running network site LMI protocol for this A-Bit status reason to be sent. The A-Bit status reason is remoteLmiError if the LMI protocol is down at the SPVC end point originating this A-Bit status reason. The A-Bit status reason is remoteLinkDown if the physical interface is disabled at the SPVC end point originating this A-Bit status reason. The A-Bit reason is vcDown if no A-Bit status has been sent to the interface (i.e., no A-Bit status has been relayed).')
mscMpanlDlciABitStatusFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1), ("notApplicable", 2))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciABitStatusFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciABitStatusFromIf.setDescription('This attribute is the most recent A-Bit status received from the interface. It is an indication from the equipment attached to the interface on whether it is ready to accept data. Mpanl relays the A- Bit status from interface to the other end of the SPVC. When an inactive setting is received, Mpanl will discard any data offered from the subnet. When an active setting is received, Mpanl will try to relay all data offered from the subnet to the interface.')
mscMpanlDlciABitReasonFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 5, 6))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("remoteLmiError", 3), ("remoteLinkDown", 5), ("vcDown", 6))).clone('vcDown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciABitReasonFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciABitReasonFromIf.setDescription('This attribute provides the reason (if any) for an inactive status to be sent to the subnet. This reason is not applicable for an active status. A-Bit status reason description: The A-Bit status reason is notApplicable when the A-Bit status is active. The A-Bit status reason is remoteUserSignaled if the SPVC end point originating the A-Bit status has detected that the DLCI is inactive at the remote network through the LMI protocol. The SPVC end point must be running network site LMI protocol for this A-Bit status reason to be sent. The A-Bit status reason is remoteLmiError if the LMI protocol is down at the SPVC end point originating this A-Bit status reason. The A-Bit status reason is remoteLinkDown if the physical interface is disabled at the SPVC end point originating this A-Bit status reason. The A-Bit reason is vcDown if no A-Bit status has been received from the interface (i.e., no A-Bit status has been relayed).')
mscMpanlDlciLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLoopbackState.setDescription('This attribute has the value on when the DLCI is in loopback mode and off otherwise. This loopback command verbs start and stop are used to initiate and terminate the loopback mode for a DLCI. While loopbackState is on, an active A-bit signal will be reliably propagated across the subnet to the remote DLCI.')
mscMpanlDlciLb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2))
mscMpanlDlciLbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 1), )
if mibBuilder.loadTexts: mscMpanlDlciLbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscMpanlDlciLb components.')
mscMpanlDlciLbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciLbIndex"))
if mibBuilder.loadTexts: mscMpanlDlciLbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlDlciLb component.')
mscMpanlDlciLbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlDlciLb components. These components cannot be added nor deleted.')
mscMpanlDlciLbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlDlciLbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbStorageType.setDescription('This variable represents the storage type value for the mscMpanlDlciLb tables.')
mscMpanlDlciLbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlDlciLbIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbIndex.setDescription('This variable represents the index for the mscMpanlDlciLb tables.')
mscMpanlDlciLbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10), )
if mibBuilder.loadTexts: mscMpanlDlciLbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all the statistics for the data loopback tool.')
mscMpanlDlciLbStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciLbIndex"))
if mibBuilder.loadTexts: mscMpanlDlciLbStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbStatsEntry.setDescription('An entry in the mscMpanlDlciLbStatsTable.')
mscMpanlDlciLbLocalTotalFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbLocalTotalFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbLocalTotalFrm.setDescription('This attribute records the number of frames looped back to the link since loopback was last started.')
mscMpanlDlciLbLocalTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbLocalTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbLocalTotalBytes.setDescription('This attribute records the number of bytes looped back to the link since loopback mode was started.')
mscMpanlDlciLbLocalFecnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbLocalFecnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbLocalFecnFrm.setDescription('This attribute records the number of frames with the Forward Explicit Congestion Notification (FECN) bit set, looped back to the link since the loopback mode was started.')
mscMpanlDlciLbLocalBecnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbLocalBecnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbLocalBecnFrm.setDescription('This attribute records the number of frames with the Backward Explicit Congestion Notification (BECN) bit set, looped back to the link since the loopback mode was started.')
mscMpanlDlciLbLocalDeFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbLocalDeFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbLocalDeFrm.setDescription('This attribute records the number of frames with the Discard Eligibility (DE) bit set, looped back to the link since the loopback mode was started.')
mscMpanlDlciLbLocalDeBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbLocalDeBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbLocalDeBytes.setDescription('This attribute records the number of bytes in frames with the Discard Eligibility (DE) bit set, looped back to the link since the loopback mode was started.')
mscMpanlDlciLbRemoteTotalFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteTotalFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteTotalFrm.setDescription('This attribute records the number of frames looped back to the subnet since loopback was last started.')
mscMpanlDlciLbRemoteTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteTotalBytes.setDescription('This attribute records the number of bytes looped back to the subnet since loopback was last started.')
mscMpanlDlciLbRemoteFecnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteFecnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteFecnFrm.setDescription('This attribute records the number of frames with the Forward Explicit Congestion Notification (FECN) bit set, looped back to the subnet since the loopback mode was started.')
mscMpanlDlciLbRemoteBecnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteBecnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteBecnFrm.setDescription('This attribute records the number of frames with the Backward Explicit Congestion Notification (BECN) bit set, looped back to the subnet since the loopback mode was started.')
mscMpanlDlciLbRemoteDeFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteDeFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteDeFrm.setDescription('This attribute records the number of frames with the Discard Eligibility (DE) bit set, looped back to the subnet since the loopback mode was started.')
mscMpanlDlciLbRemoteDeBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 2, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteDeBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLbRemoteDeBytes.setDescription('This attribute records the number of bytes in frames with the Discard Eligibility (DE) bit set, looped back to the subnet since the loopback mode was started.')
mscMpanlDlciVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3))
mscMpanlDlciVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 1), )
if mibBuilder.loadTexts: mscMpanlDlciVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscMpanlDlciVc components.')
mscMpanlDlciVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciVcIndex"))
if mibBuilder.loadTexts: mscMpanlDlciVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlDlciVc component.')
mscMpanlDlciVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlDlciVc components. These components cannot be added nor deleted.')
mscMpanlDlciVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlDlciVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcStorageType.setDescription('This variable represents the storage type value for the mscMpanlDlciVc tables.')
mscMpanlDlciVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlDlciVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcIndex.setDescription('This variable represents the index for the mscMpanlDlciVc tables.')
mscMpanlDlciVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10), )
if mibBuilder.loadTexts: mscMpanlDlciVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCadTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group represents operational call data related to Frame Relay Vc. It can be displayed only for Frame Relay Vc which is created by application.')
mscMpanlDlciVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciVcIndex"))
if mibBuilder.loadTexts: mscMpanlDlciVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCadEntry.setDescription('An entry in the mscMpanlDlciVcCadTable.')
mscMpanlDlciVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1), ("spvc", 2), ("frf10spvc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcType.setDescription('This attribute displays the type of call, pvc,svc,spvc or frf10spvc.')
mscMpanlDlciVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
mscMpanlDlciVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
mscMpanlDlciVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscMpanlDlciVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscMpanlDlciVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
mscMpanlDlciVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
mscMpanlDlciVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
mscMpanlDlciVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
mscMpanlDlciVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
mscMpanlDlciVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
mscMpanlDlciVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
mscMpanlDlciVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
mscMpanlDlciVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPathReliability.setDescription('This attribute displays the path reliability.')
mscMpanlDlciVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
mscMpanlDlciVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
mscMpanlDlciVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
mscMpanlDlciVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcMaxSubnetPktSize.setDescription('This attribute indicates the maximum packet size allowed on the Vc.')
mscMpanlDlciVcRcosToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcRcosToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcRcosToNetwork.setDescription('This attribute indicates the routing metric routing class of service to the network.')
mscMpanlDlciVcRcosFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcRcosFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcRcosFromNetwork.setDescription('This attribute displays the routing metric Routing Class of Service from the Network.')
mscMpanlDlciVcEmissionPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcEmissionPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcEmissionPriorityToNetwork.setDescription('This attribute displays the network internal emission priotity to the network.')
mscMpanlDlciVcEmissionPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcEmissionPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcEmissionPriorityFromNetwork.setDescription('This attribute displays the network internal emission priotity from the network.')
mscMpanlDlciVcDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 10, 1, 32), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcDataPath.setDescription('This attribute indicates the data path used by the connection. The data path is provisioned in Dna and DirectCall components. The displayed value of this attribute can be different from the provisioned value. If the connection is using dprsOnly data path, the string dprsOnly is displayed. (dynamic packet routing system) If the connection is using dprsMcsOnly data path, the string dprsMcsOnly is displayed. If the connection is using dprsMcsFirst data path, the string dprsMcsFirst is displayed.')
mscMpanlDlciVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 11), )
if mibBuilder.loadTexts: mscMpanlDlciVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcIntdTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
mscMpanlDlciVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciVcIndex"))
if mibBuilder.loadTexts: mscMpanlDlciVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcIntdEntry.setDescription('An entry in the mscMpanlDlciVcIntdTable.')
mscMpanlDlciVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCallReferenceNumber.setStatus('obsolete')
if mibBuilder.loadTexts: mscMpanlDlciVcCallReferenceNumber.setDescription('This attribute is obsolete. It is replaced by the callReferenceNumber attribute to display the call reference number in decimal. The SNMP reference for the callReferenceNumber attribute is callReferenceNumberDecimal.')
mscMpanlDlciVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
mscMpanlDlciVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
mscMpanlDlciVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
mscMpanlDlciVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
mscMpanlDlciVcCallReferenceNumberDecimal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCallReferenceNumberDecimal.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCallReferenceNumberDecimal.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscMpanlDlciVcFrdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12), )
if mibBuilder.loadTexts: mscMpanlDlciVcFrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcFrdTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group defines Frame Relay attributes collected by Frame Relay Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods. Frame Relay Vc uses a best effort data packet delivery protocol and a different packet segmentation and combination methods from the General Vc. The Frame Relay Vc uses the same call setup and control mechanism (e.g. the support of non-flow control data packets) as in a General Vc. Most General Vc statistics and internal variables are used in a Frame Relay Vc and are displayed by software developers')
mscMpanlDlciVcFrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciVcIndex"))
if mibBuilder.loadTexts: mscMpanlDlciVcFrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcFrdEntry.setDescription('An entry in the mscMpanlDlciVcFrdTable.')
mscMpanlDlciVcFrmCongestedToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcFrmCongestedToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcFrmCongestedToSubnet.setDescription('This attribute displays the number of frames from link discarded due to lack of resources. It keeps track of the number of frames from link that have to be discarded. The discard reasons include insufficient memory for splitting the frame into smaller subnet packet size.')
mscMpanlDlciVcCannotForwardToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCannotForwardToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCannotForwardToSubnet.setDescription('This attribute displays the number of discarded packets that can not be forwarded into the subnet because of subnet congestion. Number of frames from link discarded due to failure in forwarding a packet from Vc into the subnet.- This attribute is increased when packet forwarding fails to forward a packet into the subnet. If a frame is split into multiple subnet packets and a partial packet has to be discarded, all subsequent partial packets that have not yet been delivered to the subnet will be discarded as well.')
mscMpanlDlciVcNotDataXferToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcNotDataXferToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcNotDataXferToSubnet.setDescription('This attribute records the number of frames from link discarded when the Vc tries to recover from internal path failure.')
mscMpanlDlciVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcOutOfRangeFrmFromSubnet.setDescription('This attribute displays the number of frames from subnet discarded due to out of sequence range for arriving too late.')
mscMpanlDlciVcCombErrorsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcCombErrorsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcCombErrorsFromSubnet.setDescription('This attribute records the number of subnet packets discarded at the sink Vc due to the Vc segmentation and combination protocol error. Usually, this occurs when the subnet discards packets and thus this statistics can be used to guest the number of subnet packets that are not delivered to the Vc. It cannot be used as an actual measure because some subnet packets may have been delivered to Vc but have to be discarded because these are partial packets to a frame in which some other partial packets have not been properly delivered to Vc')
mscMpanlDlciVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcDuplicatesFromSubnet.setDescription('This attribute displays the number of subnet packets discarded due to duplication. Although packets are not retransmitted by the Frame Relay Vc, it is possible for the subnet to retransmit packets. When packets are out-of-sequenced and copies of the same packets arrive, then this attribute is increased.')
mscMpanlDlciVcNotDataXferFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcNotDataXferFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcNotDataXferFromSubnet.setDescription('This attribute displays the number of subnet packets discarded when data transfer is suspended in Vc recovery.')
mscMpanlDlciVcFrmLossTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcFrmLossTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcFrmLossTimeouts.setDescription('This attribute displays the number of lost frame timer expiries. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscMpanlDlciVcOoSeqByteCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcOoSeqByteCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcOoSeqByteCntExceeded.setDescription('This attribute displays the number times that the out of sequence byte threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscMpanlDlciVcPeakOoSeqPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPeakOoSeqPktCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPeakOoSeqPktCount.setDescription('This attribute displays the frame relay peak packet count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscMpanlDlciVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPeakOoSeqFrmForwarded.setDescription('This attribute displays the frame relay peak size of the sequence packet queue. The subnet may deliver packets out-of- sequenced. These packets are then queued in an out-of-sequenced queue, waiting for a packet with the expected sequence number to come. When that packet arrives, this attribute records the maximum number of packets that were out-of-sequenced, but now have become in-sequenced. The statistics is used to measure expected queue size due to normal subnet packet disorder (not due to subnet packet discard). Current implementation also uses this statistics to set a maximum size for the out-of-sequenced queue.')
mscMpanlDlciVcSendSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcSendSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcSendSequenceNumber.setDescription("This attribute displays the Vc internal packet's send sequence number. Note that a 'packet' in this context, may be either a user data packet, or an OAM frame.")
mscMpanlDlciVcPktRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPktRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPktRetryTimeouts.setDescription('This attribute displays the number of packets which have retransmission time-outs. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscMpanlDlciVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPeakRetryQueueSize.setDescription('This attribute displays the peak size of retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. Records the largest body of unacknowledged packets.')
mscMpanlDlciVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcSubnetRecoveries.setDescription('This attribute displays the number of successful Vc recovery attempts.')
mscMpanlDlciVcOoSeqPktCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcOoSeqPktCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcOoSeqPktCntExceeded.setDescription('This attribute displays the number times that the out of sequence packet threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscMpanlDlciVcPeakOoSeqByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 12, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcPeakOoSeqByteCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcPeakOoSeqByteCount.setDescription('This attribute displays the frame relay peak byte count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscMpanlDlciVcDmepTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 417), )
if mibBuilder.loadTexts: mscMpanlDlciVcDmepTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcDmepTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute displays the data path used by the connection. Data path is provisioned in Dna and DirectCall components. If the connection is using dprsOnly data path, this attribute is empty. If the connection is using dprsMcsOnly or dprsMcsFirst data path, this attribute displays component name of the dprsMcsEndPoint.')
mscMpanlDlciVcDmepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 417, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciVcIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciVcDmepValue"))
if mibBuilder.loadTexts: mscMpanlDlciVcDmepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcDmepEntry.setDescription('An entry in the mscMpanlDlciVcDmepTable.')
mscMpanlDlciVcDmepValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 3, 417, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciVcDmepValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciVcDmepValue.setDescription('This variable represents both the value and the index for the mscMpanlDlciVcDmepTable.')
mscMpanlDlciLCo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4))
mscMpanlDlciLCoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 1), )
if mibBuilder.loadTexts: mscMpanlDlciLCoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscMpanlDlciLCo components.')
mscMpanlDlciLCoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciLCoIndex"))
if mibBuilder.loadTexts: mscMpanlDlciLCoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlDlciLCo component.')
mscMpanlDlciLCoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlDlciLCo components. These components cannot be added nor deleted.')
mscMpanlDlciLCoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlDlciLCoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoStorageType.setDescription('This variable represents the storage type value for the mscMpanlDlciLCo tables.')
mscMpanlDlciLCoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlDlciLCoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoIndex.setDescription('This variable represents the index for the mscMpanlDlciLCo tables.')
mscMpanlDlciLCoPathDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10), )
if mibBuilder.loadTexts: mscMpanlDlciLCoPathDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPathDataTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all operational attributes for the path oriented LCo.')
mscMpanlDlciLCoPathDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciLCoIndex"))
if mibBuilder.loadTexts: mscMpanlDlciLCoPathDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPathDataEntry.setDescription('An entry in the mscMpanlDlciLCoPathDataTable.')
mscMpanlDlciLCoState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("pathDown", 0), ("selectingRoute", 1), ("connecting", 2), ("pathUp", 3), ("pathDownRetrying", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoState.setDescription('This attribute reflects the current state of the connection. The pathDown state indicates that the application has not yet signalled for a path. The selectingRoute state occurs when a request has been sent to the route selector and it has not yet responded. The connectingState occurs while a path is being established. The pathUp state is the normal operational state of a path. The pathDownRetrying state indicates a path that attempted route selection but received no route and is now waiting to retry route selection again.')
mscMpanlDlciLCoEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("calling", 0), ("called", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoEnd.setDescription('This attribute identifies whether this is the calling or called end of the path.')
mscMpanlDlciLCoCostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoCostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoCostMetric.setDescription("This attribute gives the route's total cost metric. It is calculated as the sum of the cost metric of all trunks in the path at the time the connection was established. The cost metric of a trunk is defined by the trunkCost attribute of the Trunk component. The costMetric for an LCo that is originated and terminated on the same module is 0.")
mscMpanlDlciLCoDelayMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoDelayMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoDelayMetric.setDescription('This attribute gives the total delay of the route as the one way delay for a 512 byte packet. It is calculated as the sum of the delays of all trunks in the path stored in topology at the time the connection was established. The delay for an LCo that is originated and terminated on the same module is 0.')
mscMpanlDlciLCoRoundTripDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoRoundTripDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRoundTripDelay.setDescription('This attribute contains the time taken for a packet (cell) of 44 bytes to be transmitted to the remote LCo and return to this LCo. The number reported is given in milliseconds to the nearest millisecond. A value of one millisecond is reported if the time is less than 1 millisecond even though the delay may be less than 1 millisecond when the LCo is originated and terminated on the same module.')
mscMpanlDlciLCoSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoSetupPriority.setDescription('This attribute gives the priority at which the current path is established. Zero is the highest priority and four is the lowest. The holdingPriority, a complementary attribute of this component, indicates the priority a path maintains once it is established.')
mscMpanlDlciLCoHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoHoldingPriority.setDescription('This attribute gives the priority at which a path holds its current path once the path is established. Zero is the highest priority and four is the lowest. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time.')
mscMpanlDlciLCoRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredTxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of the trunks of its route. This attribute represents the bandwidth for traffic outgoing to the remote end point. The originating end of the connection determines this value.')
mscMpanlDlciLCoRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredRxBandwidth.setDescription('This attribute gives the actual bandwidth (in bits per second) reserved by this path on each of trunks of its route. This attribute represents the bandwidth for traffic incoming from the remote end point. The originating end of the connection determines this value')
mscMpanlDlciLCoRequiredTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("voice", 0), ("data", 1), ("video", 2), ("trafficType1", 3), ("trafficType2", 4), ("trafficType3", 5), ("trafficType4", 6), ("trafficType5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredTrafficType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredTrafficType.setDescription('This operational attribute indicates the type of traffic transmitted over the path. There are eight possible traffic types, and the path can transmit only one of them. The originating end of the connection determines the type. These are arbitrary designations for traffic type. The voice, data and video traffic types are defined, and five other arbitrary traffic types can be defined by the network administration. This attribute is used in the route selection process to restrict the route to trunks that support this traffic type. The supportedTrafficType trunk attribute lists all the types of traffic allowed on the trunk. For example, if requiredTrafficType is specified as trafficType1 then only trunks that include trafficType1 in supportedTrafficType, will be candidates for this connection.')
mscMpanlDlciLCoPermittedTrunkTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoPermittedTrunkTypes.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPermittedTrunkTypes.setDescription("This operational attribute lists up to eight types of trunk that can be used on the route. The originating end of the connection determines the types. The terrestrial and satellite trunk types have been defined, leaving six remaining arbitrary types that can be defined by the network administration. The trunk's type is indicated in the trunkType attribute of the Trunk component. When selecting a route, PORS only chooses trunks whose trunkType are in the permittedTrunkTypes for the path. Description of bits: terrestrial(0) satellite(1) trunkType1(2) trunkType2(3) trunkType3(4) trunkType4(5) trunkType5(6) trunkType6(7)")
mscMpanlDlciLCoRequiredSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredSecurity.setDescription("This attribute indicates the required minimum level of security of the trunks on the route. Zero represents the most secure and seven represents the least secure. The trunk's security is indicated by the trunkSecurity attribute of the Trunk component, and has values identical in range and meaning to the requiredSecurity attribute. PORS ensures that any route selected does not contain a trunk whose trunkSecurity attribute is numerically greater than the requiredSecurity.")
mscMpanlDlciLCoRequiredCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRequiredCustomerParameter.setDescription('This attribute indicates the allowed customer defined parameter of the trunks on the route.The originating end of the connection determines the customer defined parameter. Its value, a number from zero to seven, is chosen by a network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary trunk attribute, customerParameter, also has a value from zero to seven. The route selection process does not consider trunks whose customerParameter is greater than the requiredCustomerParameter of the path.')
mscMpanlDlciLCoEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoEmissionPriority.setDescription('This attribute indicates the urgency with which packets on the path are emitted by the trunks on the route. The originating end of the connection selects the emissionPriority. EmissionPriority of zero indicates the highest emission priority, while two indicates the lowest emission priority. Packets with a higher emissionPriority (or numerically less) are serviced and sent out before the packets of lower emissionPriority (or numerically higher).')
mscMpanlDlciLCoDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path.The originating end of the connection sets discardPriority. One is used for paths carrying the most important traffic, and three is used for paths carrying the least important traffic. Packets with lower discardPriority(numerically lower) are discarded after packets with a higher discardPriority(numerically higher).')
mscMpanlDlciLCoRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoRetryCount.setDescription('This attribute is the count of the number of times the path chosen during route selection could not be instantiated. This count should be three or below if the network is performing adequately. A high value indicates that the route selection is often performed using an out-of-date view of available network bandwidth and/or topology. This attribute will only increase at the calling end of the connection. This attribute is reset each time a path reconnects and stops counting when it reaches its maximum value.')
mscMpanlDlciLCoPathFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoPathFailureCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPathFailureCount.setDescription('This attribute is the count of the number of times the path has successfully reconnected. It is set to zero the first time the path is up. If a path fails anytime after connecting, this count will be incremented when the path is up again. Failed route requests do not count in this statistic. See retryCount(rcount) - page 78. This attribute stops counting at its maximum value.')
mscMpanlDlciLCoReasonForNoRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("none", 0), ("destinationNameTooLong", 1), ("destinationNotSpecified", 2), ("unknownDestinationName", 3), ("incorrectDestination", 4), ("incorrectDestinationEndPoint", 5), ("unknownSource", 6), ("unknownDestination", 7), ("sameNode", 8), ("routeCostTooMuch", 9), ("routesDelayTooLong", 10), ("attributesNotMet", 11), ("anError", 12), ("attributeProfileProblem", 13), ("manualPathIndexProblem", 14))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoReasonForNoRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoReasonForNoRoute.setDescription("This attribute is the route selection's reasonForNoRoute and provides a brief reason for which a route was not selected. The reasons are essentially self-explanatory.")
mscMpanlDlciLCoLastTearDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("none", 0), ("normalShutDown", 1), ("insufficientTxLcOrBandwidth", 2), ("insufficientRxLcOrBandwidth", 3), ("trunkFailure", 4), ("trunkCardFailure", 5), ("operatorForced", 6), ("lostLcnClash", 7), ("networkCongestion", 8), ("trunkNotFound", 9), ("farEndNotFound", 10), ("wrongModuleReached", 11), ("farEndBusy", 12), ("callLoopedBack", 13), ("unknownReason", 14), ("farEndNotReady", 15), ("remoteNameMismatch", 16), ("serviceTypeMismatch", 17), ("reconnectFromFarEnd", 18), ("bumped", 19), ("accessCardFailure", 20), ("optimized", 21), ("overrideRemoteName", 22))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoLastTearDownReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoLastTearDownReason.setDescription("This attribute reflects the last tear down reason for a connection (LCo). In many cases this displays the reason for a momentary service interruption. This attribute applies to the last path failure only. If a path is no longer up, this may indicate why the path has failed. In many cases an alarm will also be generated with more specific information. The following is a brief description of the reasons: none - This path has no information for the teardown. normalShutDown - This path has gone down due to normal call termination. insufficientTxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the transmit direction. insufficientRxLcOrBandwidth - At present there is either no available bandwidth or logical channel numbers available on one or more of the trunks for this path in the receive direction. trunkFailure- A trunk on the path has failed or has gone down due to a provisioning change of a critical attribute. trunkCardFailure- A trunk FP card has failed along the path. accessCardFailure- The FP on which the peer access service was running has failed. operatorForced- The path has terminated due to the operator locking a trunk along the path. lostLcnClash- The path has terminated because the PAs at both ends of an intermediate trunk have allocated the same LC to different calls. When this happens both calls must go down and then try to come up again a fraction of a second later (effectively ensuring that they will now be assigned different LCs). It is normal to get the odd clash especially when the PA's usedLC is approaching the PA's maxLC. networkCongestion - The path has failed due to control information being lost and not recoverable. trunkNotFound - Occurs on a manual path usually. Check for trunks not up or names provisioned incorrectly. farEndNotFound - The far end is not provisioned or is not up. Check remote Name. wrongModuleReached - This may occur on a manual path. Check provisioning for correct trunk and service names. For a normal path, the network Topology may be changing. Check remote provisioned DNA. farEndBusy - The far end has been reached but it is busy. Check remote provisioned DNA and remote end provisioning. unknownReason - The failure was not resolved. farEndNotReady - The remote end was reached but the connection was refused due to the remote end not being enabled. serviceTypeMismatch - The remote service type does not match this service type. Check provisioning. reconnectFromFarEnd - The remote end re-established this connection. Check the remote end lastTearDownReason to determine the real reason. bumped - Another call bumped this path from a trunk to get bandwidth (or an LC) which it required to come up. This other path had a higher setupPriority than this path's holdingPriority, hence it was allowed to steal the bandwidth (or LC) from this path. optimized - This call has been rerouted due to the optimization feature. The call is still active; this just indicates why the path changed.")
mscMpanlDlciLCoPathFailureAction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnectConnection", 0), ("reRoutePath", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoPathFailureAction.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPathFailureAction.setDescription('This attribute displays whether the application is set to tolerate a momentary interruption of a path while a new path is selected. If disconnectConnection is displayed, the application is informed as soon as possible about a failure by disconnection. If the attribute displays reRoutePath, the path may attempt an immediate reroute, provided the failure is a recoverable failure. If rerouting fails the application is informed of the failure. With this option set to reRoutePath the LCo may wait up to 30 seconds before informing the service of complete disconnection in order to allow both ends to attempt to reconnect. All pathTypes respect this attribute. Also, on a manualPath with both ends provisioned with independent paths (at least with respect to the failure) this option will have the desired effect that the path is rerouted without complete disconnection at both ends.')
mscMpanlDlciLCoBumpPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bumpWhenNecessary", 0), ("bumpToObtainBestRoute", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoBumpPreference.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoBumpPreference.setDescription("This attribute specifies when bumping will occur during the route selection process. Bumping may occur when necessary or always. It will be necessary for a connection to bump if there is not enough resources for the connection to be established and these resources are occupied by a connection whose holdingPriority is lower (numerically higher) than the connection's setupPriority. A connection may also always bump in order to obtain the best route.")
mscMpanlDlciLCoOptimization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoOptimization.setDescription('This attribute is used to specify whether this connection should attempt to optimize its path when requested by the routing PORS component. Every path is as optimal as it can be when it is established, but as network traffic patterns and configurations change this path may no longer be as optimal as it could be. The PORS connection manager on a module requests circuits to optimize at the optimization interval.')
mscMpanlDlciLCoPathUpDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 10, 1, 25), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoPathUpDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPathUpDateTime.setDescription('This is the time stamp when the current path was established or reestablished.')
mscMpanlDlciLCoStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 11), )
if mibBuilder.loadTexts: mscMpanlDlciLCoStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational statistics attributes for the path oriented LCo.')
mscMpanlDlciLCoStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciLCoIndex"))
if mibBuilder.loadTexts: mscMpanlDlciLCoStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoStatsEntry.setDescription('An entry in the mscMpanlDlciLCoStatsTable.')
mscMpanlDlciLCoPktsToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoPktsToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPktsToNetwork.setDescription('This attribute counts the number of packets transmitted to the network over this Logical Connection.')
mscMpanlDlciLCoBytesToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoBytesToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoBytesToNetwork.setDescription('This attribute counts the number of bytes sent to the network over this Logical Connection.')
mscMpanlDlciLCoPktsFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 11, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoPktsFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPktsFromNetwork.setDescription('This attribute counts the number of packets received from the remote LCo via the network. This attribute wraps to 0.')
mscMpanlDlciLCoBytesFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoBytesFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoBytesFromNetwork.setDescription('This attribute counts the number of bytes received from the remote LCo via the network. This attribute wraps to 0.')
mscMpanlDlciLCoCallDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 12), )
if mibBuilder.loadTexts: mscMpanlDlciLCoCallDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoCallDataTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all operational attributes for the path oriented LCo.')
mscMpanlDlciLCoCallDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciLCoIndex"))
if mibBuilder.loadTexts: mscMpanlDlciLCoCallDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoCallDataEntry.setDescription('An entry in the mscMpanlDlciLCoCallDataTable.')
mscMpanlDlciLCoCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 12, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
mscMpanlDlciLCoCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 12, 1, 28), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoCallingDna.setDescription('This attribute displays the Data Network Address (DNA) of the calling end.')
mscMpanlDlciLCoElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 12, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoElapsedTimeTillNow.setDescription('This attribute displays the total duration in tenths of miliseconds that a connection has been up for a call.')
mscMpanlDlciLCoCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 12, 1, 31), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoCallReferenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoCallReferenceNumber.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscMpanlDlciLCoCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 12, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoCalledNpi.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the called end.')
mscMpanlDlciLCoCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 12, 1, 34), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoCalledDna.setDescription('This attribute indicates the Data Network Address (DNA) of the called (destination) DTE to which this call is sent. This address if defined at the receiving end will complete the logical connection.')
mscMpanlDlciLCoPathTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 401), )
if mibBuilder.loadTexts: mscMpanlDlciLCoPathTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPathTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute contains the trunk component names over which the path has been instantiated and the remote end point name terminating the path.')
mscMpanlDlciLCoPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 401, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciLCoIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciLCoPathValue"))
if mibBuilder.loadTexts: mscMpanlDlciLCoPathEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPathEntry.setDescription('An entry in the mscMpanlDlciLCoPathTable.')
mscMpanlDlciLCoPathValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 4, 401, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciLCoPathValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciLCoPathValue.setDescription('This variable represents both the value and the index for the mscMpanlDlciLCoPathTable.')
mscMpanlDlciJvc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5))
mscMpanlDlciJvcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 1), )
if mibBuilder.loadTexts: mscMpanlDlciJvcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscMpanlDlciJvc components.')
mscMpanlDlciJvcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciJvcIndex"))
if mibBuilder.loadTexts: mscMpanlDlciJvcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlDlciJvc component.')
mscMpanlDlciJvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlDlciJvc components. These components cannot be added nor deleted.')
mscMpanlDlciJvcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlDlciJvcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcStorageType.setDescription('This variable represents the storage type value for the mscMpanlDlciJvc tables.')
mscMpanlDlciJvcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlDlciJvcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcIndex.setDescription('This variable represents the index for the mscMpanlDlciJvc tables.')
mscMpanlDlciJvcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10), )
if mibBuilder.loadTexts: mscMpanlDlciJvcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of the Jvc component.')
mscMpanlDlciJvcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciJvcIndex"))
if mibBuilder.loadTexts: mscMpanlDlciJvcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcOperEntry.setDescription('An entry in the mscMpanlDlciJvcOperTable.')
mscMpanlDlciJvcCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("null", 0), ("callRequest", 1), ("callIndication", 2), ("callBlockPresent", 3), ("active", 4), ("discInitiated", 5), ("discPktPresent", 6), ("callDisconnected", 7), ("callTerminated", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcCurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcCurrentState.setDescription('This attribute indicates the current state of the JVC process. The state can be one of: null: waiting for an incoming call or a call request from MPANL, callRequest: waiting for the call connected from MPANL, callIndication: waiting for the call packet from MPANL, callBlockPresent: waiting for the Raccept packet from the subnet, active: relaying packets between the subnet and MPANL, discInitiated: not used by the DCE JVC, discPktPresent: not used by the DCE JVC, callDisconnected: waiting for the termination request from MPANL, callTerminated: waiting for the termination by MPANL.')
mscMpanlDlciJvcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("null", 0), ("callRequest", 1), ("callIndication", 2), ("callBlockPresent", 3), ("active", 4), ("discInitiated", 5), ("discPktPresent", 6), ("callDisconnected", 7), ("callTerminated", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcPreviousState.setDescription('This attribute indicates the previous state of the JVC process. The state can be one of: null: waiting for an incoming call or a call request from MPANL, callRequest: waiting for the call connected from MPANL, callIndication: waiting for the call packet from MPANL, callBlockPresent: waiting for the Raccept packet from the subnet, active: relaying packets between the subnet and MPANL, discInitiated: not used by the DCE JVC, discPktPresent: not used by the DCE JVC, callDisconnected: waiting for the termination request from MPANL, callTerminated: waiting for the termination by MPANL.')
mscMpanlDlciJvcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcCallingNpi.setDescription('This attribute contains the numbering plan indicator of the calling address. This attribute value is retrieved from the call packet.')
mscMpanlDlciJvcCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcCallingAddress.setDescription('This attribute contains the calling DataNetworkAddress of the interface. It includes the DNIC (first 4 digits) for X.121, and the CC (Country Code) for the E.164 address of the calling end. The maximum length of this attribute is 15 digits. This attribute value is retrieved from the call packet.')
mscMpanlDlciJvcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcCallingLcn.setDescription('This attribute contains the calling LCN (logical channel number) of the interface. This number is assigned to the call request at the calling end. This attribute value is retrieved from the call packet.')
mscMpanlDlciJvcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcCalledNpi.setDescription('This attribute contains the numbering plan indicator of the called address. This attribute value is retrieved from the call packet.')
mscMpanlDlciJvcCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcCalledAddress.setDescription('This attribute contains the called DataNetworkAddress of the interface. It includes the DNIC (first 4 digits) for X.121, and the CC (Country Code) for the E.164 address of the called end. The maximum length of this attribute is 15 digits. This attribute value is retrieved from the Raccept packet.')
mscMpanlDlciJvcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcCalledLcn.setDescription('This attribute contains the called LCN (logical channel number) of the interface. This number is assigned to the call request at the called end. This attribute value is retrieved from the Raccept packet.')
mscMpanlDlciJvcStatTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 11), )
if mibBuilder.loadTexts: mscMpanlDlciJvcStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcStatTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the statistics collected by the Jvc component.')
mscMpanlDlciJvcStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlDlciJvcIndex"))
if mibBuilder.loadTexts: mscMpanlDlciJvcStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcStatEntry.setDescription('An entry in the mscMpanlDlciJvcStatTable.')
mscMpanlDlciJvcPacketsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcPacketsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcPacketsFromSubnet.setDescription('This attribute counts all packets including control packets received from the subnet. This number reflects also the packets sent to the MPANL process since the JVC does not drop or generate packets in this direction.The value of this attribute wraps to 0 when the maximum value is reached.')
mscMpanlDlciJvcPacketsToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcPacketsToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcPacketsToSubnet.setDescription('This attribute counts all packets including control packets sent into the subnet. This number includes Renew Call Timer Packets that are generated by the JVC. The value of this attribute wraps to 0 when the maximum value is reached.')
mscMpanlDlciJvcPacketsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcPacketsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcPacketsDiscarded.setDescription('This attribute counts discarded packets that can not be forwarded into the subnet because of subnet congestion. This attribute is increased when packet forwarding fails to forward a packet into the subnet.')
mscMpanlDlciJvcProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 5, 5, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlDlciJvcProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlDlciJvcProtocolErrors.setDescription('This attribute counts the number of protocol errors detected by the JVC in both the MPANL and the subnet directions. A protocol error is counted in the following cases: - reception of a packet from MPANL while waiting for a Raccept packet from the subnet, - reception of a packet from the subnet following a call packet and before the callAccepted is received from MPANL, - reception of a packet from the subnet or from MPANL that is shorter than the subnet header. The value of this attribute wraps to 0 when the maximum value is reached.')
mscMpanlSig = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6))
mscMpanlSigRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 1), )
if mibBuilder.loadTexts: mscMpanlSigRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlSig components.')
mscMpanlSigRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigIndex"))
if mibBuilder.loadTexts: mscMpanlSigRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlSig component.')
mscMpanlSigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlSig components. These components cannot be added nor deleted.')
mscMpanlSigComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlSigStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigStorageType.setDescription('This variable represents the storage type value for the mscMpanlSig tables.')
mscMpanlSigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlSigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigIndex.setDescription('This variable represents the index for the mscMpanlSig tables.')
mscMpanlSigSysParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 13), )
if mibBuilder.loadTexts: mscMpanlSigSysParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigSysParmsTable.setDescription('This group contains the provisionable Q.933 system parameters.')
mscMpanlSigSysParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigIndex"))
if mibBuilder.loadTexts: mscMpanlSigSysParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigSysParmsEntry.setDescription('An entry in the mscMpanlSigSysParmsTable.')
mscMpanlSigCallSetupTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigCallSetupTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigCallSetupTimer.setDescription('This attribute specifies the time the network will wait for a response to the SETUP message sent to the called user. Upon timer expiry, the SETUP message is retransmitted. The second expiry of this timer causes the call to be cleared. This value is specified in seconds.')
mscMpanlSigDisconnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigDisconnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigDisconnectTimer.setDescription('This attribute specifies the time the network will wait for a response to the DISCONNECT message sent to the user. Upon timer expiry, the RELEASE message is sent. This value is specified in seconds.')
mscMpanlSigReleaseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigReleaseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigReleaseTimer.setDescription('This attribute specifies the time the network will wait for a response to the RELEASE message sent to the user. Upon timer expiry, the RELEASE message is retransmitted. The second expiry of the timer causes the call to be released. This value is specified in seconds.')
mscMpanlSigCallProceedingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigCallProceedingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigCallProceedingTimer.setDescription('This attribute specifies the time the network will wait for the CONNECT message from the called user after the network has received the optional CALL PROCEEDING message from the called user. Upon timer expiry, the call is cleared. This value is specified in seconds.')
mscMpanlSigNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("private", 1), ("public", 2))).clone('private')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigNetworkType.setDescription('This attribute specifies whether this Frame Relay service is running on a public or a private network. This value is used solely in populating applicable information elements within those Q.933 messages that require a public or private network indication.')
mscMpanlSigLapfSysTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 14), )
if mibBuilder.loadTexts: mscMpanlSigLapfSysTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLapfSysTable.setDescription('This group contains the provisionable attributes for the SVC data link layer. The data link layer is governed primarily through ITU specification Q.922, and operates over DLCI 0..')
mscMpanlSigLapfSysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigIndex"))
if mibBuilder.loadTexts: mscMpanlSigLapfSysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLapfSysEntry.setDescription('An entry in the mscMpanlSigLapfSysTable.')
mscMpanlSigWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 14, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigWindowSize.setDescription('This attribute specifies the window size. This is the maximum number of unacknowledged sequenced frames that may be outstanding from or to this interface at any one time.')
mscMpanlSigRetransmitLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 14, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 20)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigRetransmitLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigRetransmitLimit.setDescription('This attribute specifies the number of times a frame can be retransmitted by the SVC data link layer before appropriate recovery action is taken.')
mscMpanlSigAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 14, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 10000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigAckTimer.setDescription('This attribute specifies the period in milliseconds that the network will wait for an acknowledgment to a sent frame. The value set for ackTimer must be less than the value set for idleProbeTimer.')
mscMpanlSigAckDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 14, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigAckDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigAckDelayTimer.setDescription('This attribute specifies the maximum period in milliseconds that the network will wait before sending an acknowledgment for a received in-sequence I-frame. A value of 0 means there will be no delay in acknowledgment.')
mscMpanlSigIdleProbeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 14, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535000)).clone(30000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigIdleProbeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigIdleProbeTimer.setDescription("This attribute specifies the time period in milliseconds the link will be permitted to remain idle (that is, no frames are exchanged on the data link). Upon expiry of this timer, the network's side link layer polls its peer for status. The value set for idleProbeTimer must be greater than the value set for ackTimer.")
mscMpanlSigSvcaccTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 15), )
if mibBuilder.loadTexts: mscMpanlSigSvcaccTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigSvcaccTable.setDescription('This group contains the provisionable attribute to define the defaultAccounting attribute..')
mscMpanlSigSvcaccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigIndex"))
if mibBuilder.loadTexts: mscMpanlSigSvcaccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigSvcaccEntry.setDescription('An entry in the mscMpanlSigSvcaccTable.')
mscMpanlSigDefaultAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlSigDefaultAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigDefaultAccounting.setDescription('This attribute specifies whether accounting data collection and record generation is turned on at this DLCI. For accounting data collection and record generation to be turned on, the defaultAccounting bit and at least one of the accountCollection bits in the FrsDataNetworkAddress component must be set to on.')
mscMpanlSigStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 16), )
if mibBuilder.loadTexts: mscMpanlSigStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscMpanlSigStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigIndex"))
if mibBuilder.loadTexts: mscMpanlSigStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigStateEntry.setDescription('An entry in the mscMpanlSigStateTable.')
mscMpanlSigAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscMpanlSigOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscMpanlSigUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscMpanlSigStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17), )
if mibBuilder.loadTexts: mscMpanlSigStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigStatsTable.setDescription('This group contains the statistics related to the SVC signaling layer at the interface level.')
mscMpanlSigStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigIndex"))
if mibBuilder.loadTexts: mscMpanlSigStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigStatsEntry.setDescription('An entry in the mscMpanlSigStatsTable.')
mscMpanlSigCurrentNumberOfSvcCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 991))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigCurrentNumberOfSvcCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigCurrentNumberOfSvcCalls.setDescription('This attribute shows the number of Frame Relay SVCs currently existing on this interface.')
mscMpanlSigInCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigInCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigInCalls.setDescription('This attribute indicates the current number of incoming SVCs on this interface (that is, the number of SVCs for which this interface represents the destination end of the call).')
mscMpanlSigInCallsRefused = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigInCallsRefused.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigInCallsRefused.setDescription('This attribute counts the number of incoming SVC call requests that are rejected by either this interface or by the called user. When this count reaches maximum, it wraps to zero.')
mscMpanlSigOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigOutCalls.setDescription('This attribute shows the current number of outgoing SVCs on this interface (that is, the number of SVCs for which this interface represents the source end of the call).')
mscMpanlSigOutCallsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigOutCallsFailed.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigOutCallsFailed.setDescription('This attribute counts the number of outgoing SVC call requests that are rejected by either this interface, or by the network side of the destination end, or by the called user. When this count reaches maximum, it wraps to zero.')
mscMpanlSigProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigProtocolErrors.setDescription('This attribute counts the number of times a Q.933 protocol error has occurred. Any one of the following events constitutes a protocol error: 1. In the user-signaled Link Layer Core Parameters IE within the SETUP or CONNECT messages, Cir, Bc and Be are all zero; 2. In the user-signaled Link Layer Core Parameters IE within the SETUP or CONNECT messages, Cir is zero but Bc is non-zero, or Bc is zero but Cir is non-zero; 3. In the user-signaled Link Layer Core Parameters IE within the SETUP or CONNECT messages, the minimum acceptable Cir is greater than Cir; 4. At the destination end, any of the destination to source direction link layer core parameters has been increased in the CONNECT message from the called user; 5. At the destination end, the destination to source direction Cir in the CONNECT message is smaller than the corresponding minimum acceptable Cir signaled to the called user; 6. At the source end, any of the source to destination direction link layer core parameters in the CONNECT message from the destination end has been increased; 7. At the source end, the source to destination direction Cir, after negotiation, is smaller than the corresponding minimum acceptable Cir; 8. The network has received a STATUS message from the user with an incompatible Q.933 state. When this count reaches maximum, it wraps to zero.')
mscMpanlSigQualityOfServiceNotAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigQualityOfServiceNotAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigQualityOfServiceNotAvailable.setDescription('This attribute counts the number of incoming and outgoing SVCs that are rejected because the quality of service requested cannot be met by the network. When this count reaches maximum, it wraps to zero.')
mscMpanlSigSetupTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigSetupTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigSetupTimeout.setDescription('This attribute counts the number of times the T303 setup timer has expired. When this count reaches maximum, it wraps to zero.')
mscMpanlSigLastCauseInStatusMsgReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigLastCauseInStatusMsgReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLastCauseInStatusMsgReceived.setDescription("This attribute shows the cause value in the last received user's STATUS message to an existing call. The DLCI to which this STATUS message applies is specified in the lastDlciReceivedStatus attribute. The initial value of this attribute is 0 which means that no STATUS message has been received for an existing call.")
mscMpanlSigLastStateInStatusMsgReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63))).clone(namedValues=NamedValues(("null", 0), ("callInitiated", 1), ("n2", 2), ("outgoingCallProceeding", 3), ("n4", 4), ("n5", 5), ("callPresent", 6), ("n7", 7), ("n8", 8), ("incomingCallProceeding", 9), ("active", 10), ("disconnectRequest", 11), ("disconnectIndication", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("n16", 16), ("n17", 17), ("n18", 18), ("releaseRequest", 19), ("notApplicable", 20), ("n21", 21), ("n22", 22), ("n23", 23), ("n24", 24), ("n25", 25), ("n26", 26), ("n27", 27), ("n28", 28), ("n29", 29), ("n30", 30), ("n31", 31), ("n32", 32), ("n33", 33), ("n34", 34), ("n35", 35), ("n36", 36), ("n37", 37), ("n38", 38), ("n39", 39), ("n40", 40), ("n41", 41), ("n42", 42), ("n43", 43), ("n44", 44), ("n45", 45), ("n46", 46), ("n47", 47), ("n48", 48), ("n49", 49), ("n50", 50), ("n51", 51), ("n52", 52), ("n53", 53), ("n54", 54), ("n55", 55), ("n56", 56), ("n57", 57), ("n58", 58), ("n59", 59), ("n60", 60), ("n61", 61), ("n62", 62), ("n63", 63)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigLastStateInStatusMsgReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLastStateInStatusMsgReceived.setDescription("This attribute shows the state value in the last received user's STATUS message to an existing call. The DLCI to which this STATUS message applies is specified in the lastDlciReceivedStatus attribute. The initial value of this attribute is notApplicable.")
mscMpanlSigLastDlciReceivedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(17, 1007), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigLastDlciReceivedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLastDlciReceivedStatus.setDescription('This attribute shows the value of the DLCI that has most recently received a STATUS message from the user. The initial value of this attribute is 0.')
mscMpanlSigLastQ933StateReceivedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 6, 9, 10, 11, 12, 19, 20))).clone(namedValues=NamedValues(("null", 0), ("callInitiated", 1), ("outgoingCallProceeding", 3), ("callPresent", 6), ("incomingCallProceeding", 9), ("active", 10), ("disconnectRequest", 11), ("disconnectIndication", 12), ("releaseRequest", 19), ("notApplicable", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigLastQ933StateReceivedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLastQ933StateReceivedStatus.setDescription('This attribute shows the network Q.933 state of the DLCI that has most recently received a STATUS message from the user. The DLCI to which this STATUS message applies is specified in the lastDlciReceivedStatus attribute. The initial value of this attribute is notApplicable.')
mscMpanlSigLastTimeMsgBlockCongested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 15), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigLastTimeMsgBlockCongested.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLastTimeMsgBlockCongested.setDescription('This attribute displays the most recent time that an SVC DLCI has failed to get a message block due to message block congestion. Exceptional behavior can occur due to this. The DLCI that has most recently encountered this is indicated by the lastDlciWithMsgBlockCongestion attribute. However, all SVC DLCIs may be affected. The initial value of this attribute is 0000-00-00 00:00.')
mscMpanlSigLastDlciWithMsgBlockCongestion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 17, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(16, 1007), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigLastDlciWithMsgBlockCongestion.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLastDlciWithMsgBlockCongestion.setDescription('This attribute shows the value of the DLCI that has most recently failed to get a message block due to message block congestion. The initial value of this attribute is 0.')
mscMpanlSigLapfStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 18), )
if mibBuilder.loadTexts: mscMpanlSigLapfStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLapfStatusTable.setDescription('This group contains the Q.922 SVC data link layer status.')
mscMpanlSigLapfStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigIndex"))
if mibBuilder.loadTexts: mscMpanlSigLapfStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLapfStatusEntry.setDescription('An entry in the mscMpanlSigLapfStatusTable.')
mscMpanlSigCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 7))).clone(namedValues=NamedValues(("disconnected", 1), ("linkSetup", 2), ("disconnectRequest", 4), ("informationTransfer", 5), ("waitingAck", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigCurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigCurrentState.setDescription('This attribute shows the current state of the SVC data link layer interface.')
mscMpanlSigLastStateChangeReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 6, 7, 8, 9, 10, 12, 13))).clone(namedValues=NamedValues(("notStarted", 1), ("abmeEntered", 3), ("abmeReset", 5), ("dmReceived", 6), ("dmSent", 7), ("discReceived", 8), ("discSent", 9), ("frmrReceived", 10), ("n200RetranTimeOut", 12), ("other", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigLastStateChangeReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLastStateChangeReason.setDescription('This attribute shows the reason for the most recent state change. notStarted - this is the default state after SVC data link has just been created. abmeEntered - SVC data link has entered Asynchronous Balanced Mode after SABME or UA has been received. abmeReset - the data link has been reset. dmReceived - DM response received. dmSent - DM sent. discReceived - DISC response received. discSent - DISC sent. frmrReceived - FRMR received. n200RetranTimeOut - retransmitLimit has been exceeded. other - unspecified state change reasons. The most likely reason for this is the transition from state waitingAck to state informationTransfer.')
mscMpanlSigFrmrReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 18, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigFrmrReceive.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigFrmrReceive.setDescription('This attribute shows the information field of the FRMR most recently received.')
mscMpanlSigCurrentQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigCurrentQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigCurrentQueueSize.setDescription('This attribute shows the current number of frames in the SVC data link layer transmit queue.')
mscMpanlSigLapfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19), )
if mibBuilder.loadTexts: mscMpanlSigLapfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLapfStatsTable.setDescription('This group contains the statistics for the SVC data link layer.')
mscMpanlSigLapfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigIndex"))
if mibBuilder.loadTexts: mscMpanlSigLapfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigLapfStatsEntry.setDescription('An entry in the mscMpanlSigLapfStatsTable.')
mscMpanlSigStateChange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigStateChange.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigStateChange.setDescription('This attribute counts the number of times the SVC data link layer interface has changed state. Frequent state changes may indicate a problem with the line quality. While the data link layer is in informationTransfer state, this counter will increment on each expiry of idleProbeTimer as its state goes from informationTransfer to waitingAck and back. When this count reaches maximum, it wraps to zero.')
mscMpanlSigRemoteBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigRemoteBusy.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigRemoteBusy.setDescription('This attribute counts the number of times transmission of an I-frame was unsuccessful due to a perceived remote busy condition (window closed or remote busy). When this count reaches maximum, it wraps to zero.')
mscMpanlSigReceiveRejectFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigReceiveRejectFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigReceiveRejectFrame.setDescription('This attribute counts the number of REJ frames received by the interface. When this count reaches maximum, it wraps to zero.')
mscMpanlSigAckTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigAckTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigAckTimeout.setDescription('This attribute counts the number of times the ackTimer has expired. Frequent increments of this counter indicate a problem at the link or improper values have been chosen for ackTimer and ackDelayTimer between the local and remote sides. When this count reaches maximum, it wraps to zero.')
mscMpanlSigIFramesTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigIFramesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigIFramesTransmitted.setDescription('This attribute counts the number of SVC I-frames transmitted to the interface on DLCI 0. An I-frame may be counted more than once if there are retransmissions at the SVC data link layer. When this count reaches maximum, it wraps to zero.')
mscMpanlSigIFramesTxDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigIFramesTxDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigIFramesTxDiscarded.setDescription('This attribute counts the number of SVC I-frames that are bound for the link but have been discarded. Discard reasons may be one of the following: 1. the frame length is beyond allow limit. 2. the SVC data link layer is in disconnected state. 3. the transmit queue has been purged because the queue length has reached the reset threshold. 4. the transmit queue or the queue waiting for acknowledgment has been purged because the link cannot be re-established. When this count reaches maximum, it wraps to zero.')
mscMpanlSigIFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigIFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigIFramesReceived.setDescription('This attribute counts the number of SVC I-frames received from the interface. When this count reaches maximum, it wraps to zero.')
mscMpanlSigIFramesRcvdDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 6, 19, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigIFramesRcvdDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigIFramesRcvdDiscarded.setDescription('This attribute counts the number of SVC I-frames received but have been discarded. The discard reasons are: 1. incorrect frame size 2. frame is out of sequence 3. frame received while the network side of the SVC data link layer is not in the informationTransfer or waitingAck state. When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanl = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7))
mscMpanlSigMpanlRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 1), )
if mibBuilder.loadTexts: mscMpanlSigMpanlRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlSigMpanl components.')
mscMpanlSigMpanlRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlSigMpanlRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlSigMpanl component.')
mscMpanlSigMpanlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlSigMpanl components. These components cannot be added nor deleted.')
mscMpanlSigMpanlComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlSigMpanlStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlStorageType.setDescription('This variable represents the storage type value for the mscMpanlSigMpanl tables.')
mscMpanlSigMpanlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlSigMpanlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlIndex.setDescription('This variable represents the index for the mscMpanlSigMpanl tables.')
mscMpanlSigMpanlStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 10), )
if mibBuilder.loadTexts: mscMpanlSigMpanlStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscMpanlSigMpanlStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlSigMpanlStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlStateEntry.setDescription('An entry in the mscMpanlSigMpanlStateTable.')
mscMpanlSigMpanlAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscMpanlSigMpanlOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscMpanlSigMpanlUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscMpanlSigMpanlProfileTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 11), )
if mibBuilder.loadTexts: mscMpanlSigMpanlProfileTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlProfileTable.setDescription('This group contains attributes which are populated by the information received from the MPA in the Profile Association command of the MPANL protocol.')
mscMpanlSigMpanlProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlSigMpanlProfileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlProfileEntry.setDescription('An entry in the mscMpanlSigMpanlProfileTable.')
mscMpanlSigMpanlDteCustomerId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlDteCustomerId.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlDteCustomerId.setDescription('This attribute indicates the Customer ID of the MPA connected to this Mpanl interface.')
mscMpanlSigMpanlDteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlDteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlDteNodeId.setDescription('This attribute indicates the nodeId that uniquely identifies the MPA connected to this Mpanl interface.')
mscMpanlSigMpanlDteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 11, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlDteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlDteComponentName.setDescription('This attribute indicates the component name provided by the MPA connected to this MPANL interface.')
mscMpanlSigMpanlHighestDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(17, 1007), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlHighestDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlHighestDlci.setDescription('This gives the highest DLCI that the Mpanl interface will assign to an SVC. This value is populated by information provided in the DLCI Range Information Element of the MPANL Profile Association command received from the MPA.')
mscMpanlSigMpanlStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 12), )
if mibBuilder.loadTexts: mscMpanlSigMpanlStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlStatsTable.setDescription('This group contains the statistics related to the Mpanl signaling layer at the interface level.')
mscMpanlSigMpanlStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlSigMpanlStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlStatsEntry.setDescription('An entry in the mscMpanlSigMpanlStatsTable.')
mscMpanlSigMpanlProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlProtocolErrors.setDescription('This attribute counts the number of times an Mpanl protocol error has occurred. Any one of the following events constitutes a protocol error: 1. DNA association before profile association. 2. Mandatory IE absent in SAPcommands. 3. Invalid length of IE/sub-info fields in SAP command. When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanlSap0CommandsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlSap0CommandsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlSap0CommandsRx.setDescription('This attribute counts the number of SAP-0 commands received on the MPANL DLCI 16. This counter wraps to zero.')
mscMpanlSigMpanlSap0CommandsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlSap0CommandsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlSap0CommandsTx.setDescription('This attribute counts the number of SAP-0 commands sent on the MPANL DLCI 16. This counter wraps to zero.')
mscMpanlSigMpanlSapXCommandsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlSapXCommandsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlSapXCommandsRx.setDescription('This attribute counts the number of SAP-X commands received on the MPANL DLCI 16. This counter wraps to zero.')
mscMpanlSigMpanlSapXCommandsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlSapXCommandsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlSapXCommandsTx.setDescription('This attribute counts the number of SAP-X commands sent on the MPANL DLCI 16. This counter wraps to zero.')
mscMpanlSigMpanlLapfStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 13), )
if mibBuilder.loadTexts: mscMpanlSigMpanlLapfStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlLapfStatusTable.setDescription('This group contains the Q.922 SVC data link layer status.')
mscMpanlSigMpanlLapfStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlSigMpanlLapfStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlLapfStatusEntry.setDescription('An entry in the mscMpanlSigMpanlLapfStatusTable.')
mscMpanlSigMpanlCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 7))).clone(namedValues=NamedValues(("disconnected", 1), ("linkSetup", 2), ("disconnectRequest", 4), ("informationTransfer", 5), ("waitingAck", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlCurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlCurrentState.setDescription('This attribute shows the current state of the SVC data link layer interface.')
mscMpanlSigMpanlLastStateChangeReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 6, 7, 8, 9, 10, 12, 13))).clone(namedValues=NamedValues(("notStarted", 1), ("abmeEntered", 3), ("abmeReset", 5), ("dmReceived", 6), ("dmSent", 7), ("discReceived", 8), ("discSent", 9), ("frmrReceived", 10), ("n200RetranTimeOut", 12), ("other", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlLastStateChangeReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlLastStateChangeReason.setDescription('This attribute shows the reason for the most recent state change. notStarted - this is the default state after SVC data link has just been created. abmeEntered - SVC data link has entered Asynchronous Balanced Mode after SABME or UA has been received. abmeReset - the data link has been reset. dmReceived - DM response received. dmSent - DM sent. discReceived - DISC response received. discSent - DISC sent. frmrReceived - FRMR received. n200RetranTimeOut - retransmitLimit has been exceeded. other - unspecified state change reasons. The most likely reason for this is the transition from state waitingAck to state informationTransfer.')
mscMpanlSigMpanlFrmrReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 13, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlFrmrReceive.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlFrmrReceive.setDescription('This attribute shows the information field of the FRMR most recently received.')
mscMpanlSigMpanlCurrentQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlCurrentQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlCurrentQueueSize.setDescription('This attribute shows the current number of frames in the SVC data link layer transmit queue.')
mscMpanlSigMpanlLapfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14), )
if mibBuilder.loadTexts: mscMpanlSigMpanlLapfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlLapfStatsTable.setDescription('This group contains the statistics for the SVC data link layer.')
mscMpanlSigMpanlLapfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlSigMpanlIndex"))
if mibBuilder.loadTexts: mscMpanlSigMpanlLapfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlLapfStatsEntry.setDescription('An entry in the mscMpanlSigMpanlLapfStatsTable.')
mscMpanlSigMpanlStateChange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlStateChange.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlStateChange.setDescription('This attribute counts the number of times the SVC data link layer interface has changed state. Frequent state changes may indicate a problem with the line quality. While the data link layer is in informationTransfer state, this counter will increment on each expiry of idleProbeTimer as its state goes from informationTransfer to waitingAck and back. When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanlRemoteBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlRemoteBusy.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlRemoteBusy.setDescription('This attribute counts the number of times transmission of an I-frame was unsuccessful due to a perceived remote busy condition (window closed or remote busy). When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanlReceiveRejectFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlReceiveRejectFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlReceiveRejectFrame.setDescription('This attribute counts the number of REJ frames received by the interface. When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanlAckTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlAckTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlAckTimeout.setDescription('This attribute counts the number of times the ackTimer has expired. Frequent increments of this counter indicate a problem at the link or improper values have been chosen for ackTimer and ackDelayTimer between the local and remote sides. When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanlIFramesTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlIFramesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlIFramesTransmitted.setDescription('This attribute counts the number of SVC I-frames transmitted to the interface on DLCI 0. An I-frame may be counted more than once if there are retransmissions at the SVC data link layer. When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanlIFramesTxDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlIFramesTxDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlIFramesTxDiscarded.setDescription('This attribute counts the number of SVC I-frames that are bound for the link but have been discarded. Discard reasons may be one of the following: 1. the frame length is beyond allow limit. 2. the SVC data link layer is in disconnected state. 3. the transmit queue has been purged because the queue length has reached the reset threshold. 4. the transmit queue or the queue waiting for acknowledgment has been purged because the link cannot be re-established. When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanlIFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlIFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlIFramesReceived.setDescription('This attribute counts the number of SVC I-frames received from the interface. When this count reaches maximum, it wraps to zero.')
mscMpanlSigMpanlIFramesRcvdDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 7, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlSigMpanlIFramesRcvdDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlSigMpanlIFramesRcvdDiscarded.setDescription('This attribute counts the number of SVC I-frames received but have been discarded. The discard reasons are: 1. incorrect frame size 2. frame is out of sequence 3. frame received while the network side of the SVC data link layer is not in the informationTransfer or waitingAck state. When this count reaches maximum, it wraps to zero.')
mscMpanlLmi = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8))
mscMpanlLmiRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 1), )
if mibBuilder.loadTexts: mscMpanlLmiRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlLmi components.')
mscMpanlLmiRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlLmiIndex"))
if mibBuilder.loadTexts: mscMpanlLmiRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlLmi component.')
mscMpanlLmiRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlLmiRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlLmi components. These components cannot be added nor deleted.')
mscMpanlLmiComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlLmiComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlLmiStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlLmiStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiStorageType.setDescription('This variable represents the storage type value for the mscMpanlLmi tables.')
mscMpanlLmiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlLmiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiIndex.setDescription('This variable represents the index for the mscMpanlLmi tables.')
mscMpanlLmiParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 10), )
if mibBuilder.loadTexts: mscMpanlLmiParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiParmsTable.setDescription('This group contains the provisionable attributes of the Local Management Interface component.')
mscMpanlLmiParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlLmiIndex"))
if mibBuilder.loadTexts: mscMpanlLmiParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiParmsEntry.setDescription('An entry in the mscMpanlLmiParmsTable.')
mscMpanlLmiProcedures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("vendorForum", 1), ("ansi", 2), ("ccitt", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlLmiProcedures.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiProcedures.setDescription('This attribute selects the procedures to be used for the Local Management Interface. For the MPANL service this attribute is always set to none. none : no Local Management Interface procedures are running on this interface. This accomodates MPANL user equipment that have not implemented any LMI procedures. The remaining attributes of this group will be ignored. vendorForum : Local Management Interface procedures from the Vendor Forum specification are supported on this interface. DLCI 1023 is used for the LMI protocol. ansi: Local Management Interface procedures from the ANSI specification are supported. DLCI 0 is used for the LMI protocol. ccitt: Local Management Interface procedures from the CCITT specification are supported. DLCI 0 is used for the LMI protocol.')
mscMpanlLmiStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 12), )
if mibBuilder.loadTexts: mscMpanlLmiStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscMpanlLmiStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlLmiIndex"))
if mibBuilder.loadTexts: mscMpanlLmiStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiStateEntry.setDescription('An entry in the mscMpanlLmiStateTable.')
mscMpanlLmiAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlLmiAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscMpanlLmiOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlLmiOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscMpanlLmiUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 8, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlLmiUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlLmiUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscMpanlVoFr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18))
mscMpanlVoFrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 1), )
if mibBuilder.loadTexts: mscMpanlVoFrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlVoFr components.')
mscMpanlVoFrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlVoFrIndex"))
if mibBuilder.loadTexts: mscMpanlVoFrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlVoFr component.')
mscMpanlVoFrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlVoFrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlVoFr components. These components cannot be added nor deleted.')
mscMpanlVoFrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlVoFrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlVoFrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlVoFrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrStorageType.setDescription('This variable represents the storage type value for the mscMpanlVoFr tables.')
mscMpanlVoFrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlVoFrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrIndex.setDescription('This variable represents the index for the mscMpanlVoFr tables.')
mscMpanlVoFrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 10), )
if mibBuilder.loadTexts: mscMpanlVoFrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrOperTable.setDescription('This group contains operational attributes of the VoFr component.')
mscMpanlVoFrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlVoFrIndex"))
if mibBuilder.loadTexts: mscMpanlVoFrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrOperEntry.setDescription('An entry in the mscMpanlVoFrOperTable.')
mscMpanlVoFrMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlVoFrMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrMaximumFrameSize.setDescription('This attribute indicates the maximum size of VoFr frames transmitted to MPA. The size excludes HDLC flags and CRC octets. MPA signals the required value as part of the MPANL initial staging, which is then used to set the value of this attribute. Default value is used before MPANL staging is completed.')
mscMpanlVoFrTransmitInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlVoFrTransmitInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrTransmitInformationRate.setDescription('This attribute indicates the maximum information rate towards MPA. Value may change over time, as signalled by MPA. Default value is used before MPANL staging is completed.')
mscMpanlVoFrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 11), )
if mibBuilder.loadTexts: mscMpanlVoFrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrStatsTable.setDescription('This group contains statistics attributes of the VoFr component.')
mscMpanlVoFrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlVoFrIndex"))
if mibBuilder.loadTexts: mscMpanlVoFrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrStatsEntry.setDescription('An entry in the mscMpanlVoFrStatsTable.')
mscMpanlVoFrFragmentedHighestPriorityFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlVoFrFragmentedHighestPriorityFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrFragmentedHighestPriorityFrames.setDescription('This attribute counts egress frames with the highest priority, which had to be fragmented because they were larger than maximumFrameSize. This could happen when a data call is setup to use the highest emission priority, or MPA is provisioned with too low maximum frame size. When the maximum is reached the count wraps to zero.')
mscMpanlVoFrLostFragmentsFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlVoFrLostFragmentsFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrLostFragmentsFromIf.setDescription('This attribute counts lost VoFr fragments from the interface. Presence of lost fragments indicates a link problem. Note that lost whole frames cannot be detected. When the maximum is reached the count wraps to zero.')
mscMpanlVoFrProtocolViolationsFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 18, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlVoFrProtocolViolationsFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlVoFrProtocolViolationsFromIf.setDescription('This attribute counts VoFr protocol violations detected in the data from the interface. When the maximum is reached the count wraps to zero.')
mscMpanlFrMuxSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19))
mscMpanlFrMuxSetupRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 1), )
if mibBuilder.loadTexts: mscMpanlFrMuxSetupRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlFrMuxSetup components.')
mscMpanlFrMuxSetupRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFrMuxSetupIndex"))
if mibBuilder.loadTexts: mscMpanlFrMuxSetupRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlFrMuxSetup component.')
mscMpanlFrMuxSetupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlFrMuxSetup components. These components can be added and deleted.')
mscMpanlFrMuxSetupComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlFrMuxSetupStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupStorageType.setDescription('This variable represents the storage type value for the mscMpanlFrMuxSetup tables.')
mscMpanlFrMuxSetupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlFrMuxSetupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupIndex.setDescription('This variable represents the index for the mscMpanlFrMuxSetup tables.')
mscMpanlFrMuxSetupOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 11), )
if mibBuilder.loadTexts: mscMpanlFrMuxSetupOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupOpTable.setDescription('This group contains the following operational parameters: committedInformationRate of the PVC connection used for tunnelling the MPANL traffic, and the component name of the Dlci which carries the traffic for this MPANL.')
mscMpanlFrMuxSetupOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFrMuxSetupIndex"))
if mibBuilder.loadTexts: mscMpanlFrMuxSetupOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupOpEntry.setDescription('An entry in the mscMpanlFrMuxSetupOpTable.')
mscMpanlFrMuxSetupCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16000, 4294967295)).clone(16000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupCommittedInformationRate.setDescription('This attribute specifies, in bit/s, the committed information rate (CIR) to which the traffic transmitted towards the interface is shaped.')
mscMpanlFrMuxSetupDlciCompName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 11, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupDlciCompName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupDlciCompName.setDescription('This attribute specifies the component name of the Dlci with which the application using this FrMuxSetup component is associated. The name is a string FrMux/n Dlci/m. For a PVC this is the same component name as provisioned under the subcomponent FrMuxPvcSetup.')
mscMpanlFrMuxSetupPvcSetup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2))
mscMpanlFrMuxSetupPvcSetupRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 1), )
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlFrMuxSetupPvcSetup components.')
mscMpanlFrMuxSetupPvcSetupRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFrMuxSetupIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFrMuxSetupPvcSetupIndex"))
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlFrMuxSetupPvcSetup component.')
mscMpanlFrMuxSetupPvcSetupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlFrMuxSetupPvcSetup components. These components cannot be added nor deleted.')
mscMpanlFrMuxSetupPvcSetupComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlFrMuxSetupPvcSetupStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupStorageType.setDescription('This variable represents the storage type value for the mscMpanlFrMuxSetupPvcSetup tables.')
mscMpanlFrMuxSetupPvcSetupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupIndex.setDescription('This variable represents the index for the mscMpanlFrMuxSetupPvcSetup tables.')
mscMpanlFrMuxSetupPvcSetupProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 10), )
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupProvTable.setDescription('This group contains provisionable attributes for setting up a Dlci associated with the application using the FrMuxSetup component. The Dlci is of the PVC type.')
mscMpanlFrMuxSetupPvcSetupProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFrMuxSetupIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlFrMuxSetupPvcSetupIndex"))
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupProvEntry.setDescription('An entry in the mscMpanlFrMuxSetupPvcSetupProvTable.')
mscMpanlFrMuxSetupPvcSetupDlciName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 19, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupDlciName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlFrMuxSetupPvcSetupDlciName.setDescription('This attribute is the link to the Dlci which is associated with the application using the FrMuxSetup component.')
mscMpanlIsdn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22))
mscMpanlIsdnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 1), )
if mibBuilder.loadTexts: mscMpanlIsdnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnRowStatusTable.setDescription('This entry controls the addition and deletion of mscMpanlIsdn components.')
mscMpanlIsdnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIsdnIndex"))
if mibBuilder.loadTexts: mscMpanlIsdnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnRowStatusEntry.setDescription('A single entry in the table represents a single mscMpanlIsdn component.')
mscMpanlIsdnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlIsdnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscMpanlIsdn components. These components can be added and deleted.')
mscMpanlIsdnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlIsdnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscMpanlIsdnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlIsdnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnStorageType.setDescription('This variable represents the storage type value for the mscMpanlIsdn tables.')
mscMpanlIsdnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscMpanlIsdnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnIndex.setDescription('This variable represents the index for the mscMpanlIsdn tables.')
mscMpanlIsdnProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 11), )
if mibBuilder.loadTexts: mscMpanlIsdnProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnProvTable.setDescription('This group contains the provisionable attributes of the Isdn component.')
mscMpanlIsdnProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIsdnIndex"))
if mibBuilder.loadTexts: mscMpanlIsdnProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnProvEntry.setDescription('An entry in the mscMpanlIsdnProvTable.')
mscMpanlIsdnT320 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlIsdnT320.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnT320.setDescription('This attribute specifies the waiting time for a silent B-Channel (no active VCs associated with the Mpanl) to be disconnected and made available. Default is 60 seconds. 0 means t320 will never timeout.')
mscMpanlIsdnAddressSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("isdnDna", 0), ("normalBehavior", 1))).clone('normalBehavior')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscMpanlIsdnAddressSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnAddressSignalling.setDescription('This attribute defines whether the ISDN Calling Party Number is to be signalled to the remote DTE during an SVC call establishment. Otherwise, no changes to the current behavior of SVC call establishement (i.e., Passport Dna is used in the calling party number information element).')
mscMpanlIsdnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 12), )
if mibBuilder.loadTexts: mscMpanlIsdnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnOperTable.setDescription('This group contains the operational attributes of the Isdn component.')
mscMpanlIsdnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIndex"), (0, "Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", "mscMpanlIsdnIndex"))
if mibBuilder.loadTexts: mscMpanlIsdnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnOperEntry.setDescription('An entry in the mscMpanlIsdnOperTable.')
mscMpanlIsdnDataSigChan = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlIsdnDataSigChan.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnDataSigChan.setDescription('This attribute indicates the instance number of the dataSigChan component controlling the allocation of this Mpanl Isdn component.')
mscMpanlIsdnBChannelState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("busy", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlIsdnBChannelState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnBChannelState.setDescription('This attribute indicates the state of the B-Channel. If the value is idle it means that no VCs are connected and this B-Channel is available. If the value is busy it means this B-Channel has been allocated and is not available. If the value is disabled it means the application interface or the port is locked or disabled.')
mscMpanlIsdnLastUsedCgpn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 12, 1, 3), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlIsdnLastUsedCgpn.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnLastUsedCgpn.setDescription('This attribute indicates the calling party number currently using the B-Channel. When the B-Channel is free, the null string is displayed.')
mscMpanlIsdnBChanIntState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("isdnInit", 0), ("waitAccEnable", 1), ("waitLnsResponse", 2), ("waitFramerData", 3), ("enabling", 4), ("waitAccRegAck", 5), ("up", 6), ("down", 7), ("releasing", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlIsdnBChanIntState.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnBChanIntState.setDescription('Debug information')
mscMpanlIsdnActiveVirtualCircuitsCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 123, 22, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscMpanlIsdnActiveVirtualCircuitsCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscMpanlIsdnActiveVirtualCircuitsCount.setDescription('Current number of virtual circuits (switched and permanent) in data transfer.')
mpaNetworkLinkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119, 1))
mpaNetworkLinkGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119, 1, 1))
mpaNetworkLinkGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119, 1, 1, 3))
mpaNetworkLinkGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119, 1, 1, 3, 2))
mpaNetworkLinkCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119, 3))
mpaNetworkLinkCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119, 3, 1))
mpaNetworkLinkCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119, 3, 1, 3))
mpaNetworkLinkCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 119, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", mscMpanlDnaOutgoingOptionsTable=mscMpanlDnaOutgoingOptionsTable, mscMpanlDlciLCoHoldingPriority=mscMpanlDlciLCoHoldingPriority, mscMpanlStateEntry=mscMpanlStateEntry, mscMpanlSigRowStatusEntry=mscMpanlSigRowStatusEntry, mscMpanlSigMpanlLapfStatsEntry=mscMpanlSigMpanlLapfStatsEntry, mscMpanlLmiIndex=mscMpanlLmiIndex, mscMpanlFramerOverruns=mscMpanlFramerOverruns, mscMpanlSigSysParmsEntry=mscMpanlSigSysParmsEntry, mscMpanlDlciJvcRowStatusEntry=mscMpanlDlciJvcRowStatusEntry, mscMpanlDlciQ933CallReference=mscMpanlDlciQ933CallReference, mscMpanlDlciLCoRowStatus=mscMpanlDlciLCoRowStatus, mscMpanlDlciVcComponentName=mscMpanlDlciVcComponentName, mscMpanlDlciDeFrmToIf=mscMpanlDlciDeFrmToIf, mscMpanlFrmToIfByQueueIndex=mscMpanlFrmToIfByQueueIndex, mscMpanlDlciLCoPathFailureAction=mscMpanlDlciLCoPathFailureAction, mscMpanlDlciControlStatus=mscMpanlDlciControlStatus, mscMpanlDlciBecnFrmToIf=mscMpanlDlciBecnFrmToIf, mscMpanlDlciJvcOperTable=mscMpanlDlciJvcOperTable, mscMpanlStatsTable=mscMpanlStatsTable, mscMpanlDlciVcCalledLcn=mscMpanlDlciVcCalledLcn, mscMpanlDlciLCoPktsToNetwork=mscMpanlDlciLCoPktsToNetwork, mscMpanlDlciRowStatus=mscMpanlDlciRowStatus, mscMpanlFrmToIf=mscMpanlFrmToIf, mscMpanlFrMuxSetupRowStatusEntry=mscMpanlFrMuxSetupRowStatusEntry, mscMpanlIsdnT320=mscMpanlIsdnT320, mscMpanlSigMpanlRowStatus=mscMpanlSigMpanlRowStatus, mscMpanlIndex=mscMpanlIndex, mscMpanlSigMpanlIFramesRcvdDiscarded=mscMpanlSigMpanlIFramesRcvdDiscarded, mscMpanlSigMpanlIndex=mscMpanlSigMpanlIndex, mscMpanlDlciVcIndex=mscMpanlDlciVcIndex, mscMpanlOperStatusEntry=mscMpanlOperStatusEntry, mscMpanlDlciVcAccountingEnabled=mscMpanlDlciVcAccountingEnabled, mscMpanlDlciVcCombErrorsFromSubnet=mscMpanlDlciVcCombErrorsFromSubnet, mscMpanlFrMuxSetup=mscMpanlFrMuxSetup, mscMpanlFramerUtilTable=mscMpanlFramerUtilTable, mscMpanlDlciDiscFrameAbit=mscMpanlDlciDiscFrameAbit, mscMpanlFrMuxSetupPvcSetupRowStatus=mscMpanlFrMuxSetupPvcSetupRowStatus, mscMpanlSigLastStateChangeReason=mscMpanlSigLastStateChangeReason, mscMpanlIsdnComponentName=mscMpanlIsdnComponentName, mscMpanlFramerStateTable=mscMpanlFramerStateTable, mscMpanlOperTable=mscMpanlOperTable, mscMpanlOperEntry=mscMpanlOperEntry, mscMpanlOctetToIfByQueueEntry=mscMpanlOctetToIfByQueueEntry, mscMpanlDlci=mscMpanlDlci, mscMpanlFramerFrmToIf=mscMpanlFramerFrmToIf, mscMpanlFramerRowStatusEntry=mscMpanlFramerRowStatusEntry, mscMpanlDlciAlarmStatus=mscMpanlDlciAlarmStatus, mscMpanlLmiUsageState=mscMpanlLmiUsageState, mscMpanlVoFr=mscMpanlVoFr, mscMpanlDlciVcCallReferenceNumberDecimal=mscMpanlDlciVcCallReferenceNumberDecimal, mscMpanlSigStateTable=mscMpanlSigStateTable, mscMpanlDlciTotalIngressBytes=mscMpanlDlciTotalIngressBytes, mscMpanlRoundTripDelay=mscMpanlRoundTripDelay, mscMpanlFramerRowStatusTable=mscMpanlFramerRowStatusTable, mscMpanlDlciVcFrmLossTimeouts=mscMpanlDlciVcFrmLossTimeouts, mscMpanlTrafficStatsTable=mscMpanlTrafficStatsTable, mscMpanlDlciVcFrdEntry=mscMpanlDlciVcFrdEntry, mscMpanlDlciJvcRowStatus=mscMpanlDlciJvcRowStatus, mscMpanlDlciLCoBytesToNetwork=mscMpanlDlciLCoBytesToNetwork, mscMpanlFramerLinkEntry=mscMpanlFramerLinkEntry, mscMpanlDlciFrmToIf=mscMpanlDlciFrmToIf, mscMpanlDlciBciToSubnet=mscMpanlDlciBciToSubnet, mscMpanlFramerDataInversion=mscMpanlFramerDataInversion, mscMpanlSigComponentName=mscMpanlSigComponentName, mscMpanlDlciLbStatsEntry=mscMpanlDlciLbStatsEntry, mscMpanlIsdnRowStatusTable=mscMpanlIsdnRowStatusTable, mscMpanlPrefixDnaRowStatus=mscMpanlPrefixDnaRowStatus, mscMpanlDlciErrorShortFrmFromIf=mscMpanlDlciErrorShortFrmFromIf, mscMpanlSigMpanlStateChange=mscMpanlSigMpanlStateChange, mscMpanlSigStatsTable=mscMpanlSigStatsTable, mscMpanlIsdnLastUsedCgpn=mscMpanlIsdnLastUsedCgpn, mscMpanlSigMpanlRowStatusEntry=mscMpanlSigMpanlRowStatusEntry, mscMpanlDlciDiscExcessFromIf=mscMpanlDlciDiscExcessFromIf, mscMpanlDlciEirEgressBytes=mscMpanlDlciEirEgressBytes, mscMpanlPrefixDnaDataNetworkAddressIndex=mscMpanlPrefixDnaDataNetworkAddressIndex, mscMpanlProvTable=mscMpanlProvTable, mscMpanlDlciLb=mscMpanlDlciLb, mscMpanlDlciExcessBytesFromIf=mscMpanlDlciExcessBytesFromIf, mscMpanlSigMpanlDteComponentName=mscMpanlSigMpanlDteComponentName, mscMpanlDlciVcRcosFromNetwork=mscMpanlDlciVcRcosFromNetwork, mscMpanlStateTable=mscMpanlStateTable, mscMpanlDlciVcMaxSubnetPktSize=mscMpanlDlciVcMaxSubnetPktSize, mscMpanlDlciRowStatusEntry=mscMpanlDlciRowStatusEntry, mscMpanlDlciDiscDeCongestedToIf=mscMpanlDlciDiscDeCongestedToIf, mscMpanlDlciDiscardedSegFrm=mscMpanlDlciDiscardedSegFrm, mscMpanlDlciLCoStorageType=mscMpanlDlciLCoStorageType, mscMpanlSigAdminState=mscMpanlSigAdminState, mscMpanlFramerStatsTable=mscMpanlFramerStatsTable, mscMpanlIsdn=mscMpanlIsdn, mscMpanlSigSvcaccTable=mscMpanlSigSvcaccTable, mscMpanlOctetToIfByQueueValue=mscMpanlOctetToIfByQueueValue, mscMpanlFrMuxSetupPvcSetupDlciName=mscMpanlFrMuxSetupPvcSetupDlciName, mscMpanlDlciBytesToIf=mscMpanlDlciBytesToIf, mscMpanlSnmpOperStatus=mscMpanlSnmpOperStatus, mscMpanlDlciVcSegmentsSent=mscMpanlDlciVcSegmentsSent, mscMpanlDlciStateTable=mscMpanlDlciStateTable, mscMpanlDnaComponentName=mscMpanlDnaComponentName, mscMpanlSigMpanl=mscMpanlSigMpanl, mscMpanlFrMuxSetupOpEntry=mscMpanlFrMuxSetupOpEntry, mscMpanlFrMuxSetupDlciCompName=mscMpanlFrMuxSetupDlciCompName, mscMpanlDnaAccountClass=mscMpanlDnaAccountClass, mscMpanlDlciDeBytesFromIf=mscMpanlDlciDeBytesFromIf, mscMpanlDnaCallOptionsTable=mscMpanlDnaCallOptionsTable, mscMpanlOctetFromIf=mscMpanlOctetFromIf, mscMpanlDnaRowStatusTable=mscMpanlDnaRowStatusTable, mscMpanlPrefixDnaRowStatusEntry=mscMpanlPrefixDnaRowStatusEntry, mscMpanlDlciTransferPriFromNwk=mscMpanlDlciTransferPriFromNwk, mscMpanlDlciFrmFromIf=mscMpanlDlciFrmFromIf, mscMpanlFrMuxSetupOpTable=mscMpanlFrMuxSetupOpTable, mscMpanlSigFrmrReceive=mscMpanlSigFrmrReceive, mscMpanlDlciLCoStatsTable=mscMpanlDlciLCoStatsTable, mscMpanlIsdnAddressSignalling=mscMpanlIsdnAddressSignalling, mscMpanlIsdnBChanIntState=mscMpanlIsdnBChanIntState, mscMpanlDlciLCoStatsEntry=mscMpanlDlciLCoStatsEntry, mscMpanlDlciLCoRoundTripDelay=mscMpanlDlciLCoRoundTripDelay, mscMpanlDnaRowStatusEntry=mscMpanlDnaRowStatusEntry, mscMpanlDlciVcRowStatus=mscMpanlDlciVcRowStatus, mscMpanlSigMpanlSap0CommandsRx=mscMpanlSigMpanlSap0CommandsRx, mscMpanlFrMuxSetupPvcSetupComponentName=mscMpanlFrMuxSetupPvcSetupComponentName, mscMpanlSigRowStatusTable=mscMpanlSigRowStatusTable, mscMpanlDlciJvcStatEntry=mscMpanlDlciJvcStatEntry, mscMpanlLmiComponentName=mscMpanlLmiComponentName, mscMpanlDlciLCoEnd=mscMpanlDlciLCoEnd, mscMpanlDlciLbRowStatusTable=mscMpanlDlciLbRowStatusTable, mscMpanlFramerFrmToIf64=mscMpanlFramerFrmToIf64, mscMpanlSigLapfStatsEntry=mscMpanlSigLapfStatsEntry, mscMpanlDlciStandbyStatus=mscMpanlDlciStandbyStatus, mscMpanlIsdnRowStatus=mscMpanlIsdnRowStatus, mscMpanlDlciJvcCallingNpi=mscMpanlDlciJvcCallingNpi, mscMpanlSigCallProceedingTimer=mscMpanlSigCallProceedingTimer, mscMpanlDlciLCoDelayMetric=mscMpanlDlciLCoDelayMetric, mscMpanlDlciVcDiagnosticCode=mscMpanlDlciVcDiagnosticCode, mscMpanlDlciJvcRowStatusTable=mscMpanlDlciJvcRowStatusTable, mscMpanlDlciVcType=mscMpanlDlciVcType, mscMpanlDlciVcOutOfRangeFrmFromSubnet=mscMpanlDlciVcOutOfRangeFrmFromSubnet, mscMpanlCustomerIdentifier=mscMpanlCustomerIdentifier, mscMpanlDlciVcNotDataXferToSubnet=mscMpanlDlciVcNotDataXferToSubnet, mscMpanlDlciDiscDeCongestedToIfBytes=mscMpanlDlciDiscDeCongestedToIfBytes, mscMpanlVoFrMaximumFrameSize=mscMpanlVoFrMaximumFrameSize, mscMpanlSigMpanlAckTimeout=mscMpanlSigMpanlAckTimeout, mscMpanlDlciLbStatsTable=mscMpanlDlciLbStatsTable, mscMpanlDlciJvcCalledNpi=mscMpanlDlciJvcCalledNpi, mscMpanlProceduralStatus=mscMpanlProceduralStatus, mscMpanlFrMuxSetupPvcSetupStorageType=mscMpanlFrMuxSetupPvcSetupStorageType, mscMpanlDna=mscMpanlDna, mscMpanlDlciLCoPermittedTrunkTypes=mscMpanlDlciLCoPermittedTrunkTypes, mscMpanlDlciLbLocalFecnFrm=mscMpanlDlciLbLocalFecnFrm, mscMpanlDlciTransferPriToNwk=mscMpanlDlciTransferPriToNwk, mscMpanlSigMpanlLapfStatusEntry=mscMpanlSigMpanlLapfStatusEntry, mscMpanlDlciLCoPktsFromNetwork=mscMpanlDlciLCoPktsFromNetwork, mscMpanlDlciLbStorageType=mscMpanlDlciLbStorageType, mscMpanlDlciVcPreviousState=mscMpanlDlciVcPreviousState, mscMpanlDlciLCo=mscMpanlDlciLCo, mscMpanlFrMuxSetupPvcSetupIndex=mscMpanlFrMuxSetupPvcSetupIndex, mscMpanlIsdnOperEntry=mscMpanlIsdnOperEntry, mscMpanlDnaIndex=mscMpanlDnaIndex, mscMpanlLmiStorageType=mscMpanlLmiStorageType, mscMpanlDlciStatsEntry=mscMpanlDlciStatsEntry, mscMpanlDlciProceduralStatus=mscMpanlDlciProceduralStatus, mscMpanlSigDisconnectTimer=mscMpanlSigDisconnectTimer, mscMpanlDlciLCoRequiredRxBandwidth=mscMpanlDlciLCoRequiredRxBandwidth, mscMpanlFramerProvEntry=mscMpanlFramerProvEntry, mscMpanlSigMpanlStateTable=mscMpanlSigMpanlStateTable, mscMpanlDlciJvcCalledAddress=mscMpanlDlciJvcCalledAddress, mscMpanlSigMpanlStateEntry=mscMpanlSigMpanlStateEntry, mscMpanlSigMpanlIFramesReceived=mscMpanlSigMpanlIFramesReceived, mscMpanlSigStateChange=mscMpanlSigStateChange, mscMpanlDlciVcSendSequenceNumber=mscMpanlDlciVcSendSequenceNumber, mscMpanlFramerNonOctetErrors=mscMpanlFramerNonOctetErrors, mscMpanlDlciVcRcosToNetwork=mscMpanlDlciVcRcosToNetwork, mscMpanlVoFrRowStatusEntry=mscMpanlVoFrRowStatusEntry, mpaNetworkLinkGroup=mpaNetworkLinkGroup, mscMpanlDlciVcCadTable=mscMpanlDlciVcCadTable, mscMpanlSigLastQ933StateReceivedStatus=mscMpanlSigLastQ933StateReceivedStatus, mscMpanlFramerRowStatus=mscMpanlFramerRowStatus, mscMpanlDlciLbIndex=mscMpanlDlciLbIndex, mscMpanlDlciAccounting=mscMpanlDlciAccounting, mscMpanlOctetToIf=mscMpanlOctetToIf, mscMpanlDlciLbRemoteDeFrm=mscMpanlDlciLbRemoteDeFrm, mscMpanlInvalidHeaderFramesFromIf=mscMpanlInvalidHeaderFramesFromIf, mscMpanlSigOutCalls=mscMpanlSigOutCalls, mscMpanlDlciLCoOptimization=mscMpanlDlciLCoOptimization, mscMpanlDlciVcStartTime=mscMpanlDlciVcStartTime, mscMpanlFramerCrcErrors=mscMpanlFramerCrcErrors, mscMpanlIfIndex=mscMpanlIfIndex, mscMpanlComponentName=mscMpanlComponentName, mscMpanlDlciJvcPacketsFromSubnet=mscMpanlDlciJvcPacketsFromSubnet, mscMpanlDlciJvcCallingLcn=mscMpanlDlciJvcCallingLcn, mscMpanlDlciDiscCongestedFromIfBytes=mscMpanlDlciDiscCongestedFromIfBytes, mscMpanlFramerStatsEntry=mscMpanlFramerStatsEntry, mscMpanlDlciBciFromSubnet=mscMpanlDlciBciFromSubnet, mscMpanlPrefixDna=mscMpanlPrefixDna, mscMpanlDlciVcRowStatusTable=mscMpanlDlciVcRowStatusTable, mscMpanlDlciVcPeakRetryQueueSize=mscMpanlDlciVcPeakRetryQueueSize, mscMpanlSigLapfStatusTable=mscMpanlSigLapfStatusTable, mscMpanlDlciIndex=mscMpanlDlciIndex, mscMpanlDlciCallReferenceNumber=mscMpanlDlciCallReferenceNumber, mscMpanlDlciJvcPacketsToSubnet=mscMpanlDlciJvcPacketsToSubnet, mscMpanlDlciExcessFrmFromIf=mscMpanlDlciExcessFrmFromIf, mscMpanlDlciOperationalState=mscMpanlDlciOperationalState, mscMpanlDlciLbRemoteTotalFrm=mscMpanlDlciLbRemoteTotalFrm, mscMpanlDlciLbRemoteDeBytes=mscMpanlDlciLbRemoteDeBytes, mscMpanlFramerFlagsBetweenFrames=mscMpanlFramerFlagsBetweenFrames, mscMpanlDlciVcCallingLcn=mscMpanlDlciVcCallingLcn, mscMpanlSigMpanlLapfStatsTable=mscMpanlSigMpanlLapfStatsTable, mscMpanlDlciDeFrmFromIf=mscMpanlDlciDeFrmFromIf, mscMpanlDlciJvc=mscMpanlDlciJvc, mscMpanlRowStatus=mscMpanlRowStatus, mscMpanlDlciLbRemoteTotalBytes=mscMpanlDlciLbRemoteTotalBytes, mscMpanlSigMpanlCurrentQueueSize=mscMpanlSigMpanlCurrentQueueSize, mscMpanlDlciDeBytesToIf=mscMpanlDlciDeBytesToIf, mscMpanlDlciLbRowStatus=mscMpanlDlciLbRowStatus, mscMpanlDlciVcCadEntry=mscMpanlDlciVcCadEntry, mscMpanlIfEntryTable=mscMpanlIfEntryTable, mscMpanlDnaOutgoingOptionsEntry=mscMpanlDnaOutgoingOptionsEntry, mscMpanlDlciVcCalledDna=mscMpanlDlciVcCalledDna, mscMpanlDlciVcPreviousDiagnosticCode=mscMpanlDlciVcPreviousDiagnosticCode, mscMpanlFrMuxSetupCommittedInformationRate=mscMpanlFrMuxSetupCommittedInformationRate, mscMpanlSigLastStateInStatusMsgReceived=mscMpanlSigLastStateInStatusMsgReceived, mscMpanlDlciVcPktRetryTimeouts=mscMpanlDlciVcPktRetryTimeouts, mscMpanlDlciABitStatusToIf=mscMpanlDlciABitStatusToIf, mscMpanlDlciLbRowStatusEntry=mscMpanlDlciLbRowStatusEntry, mscMpanlDlciTotalIngressSegFrm=mscMpanlDlciTotalIngressSegFrm, mscMpanlDlciIntTable=mscMpanlDlciIntTable, mscMpanlDlciLCoCalledDna=mscMpanlDlciLCoCalledDna, mscMpanlDlciLCoPathFailureCount=mscMpanlDlciLCoPathFailureCount, mscMpanlLmiRowStatusTable=mscMpanlLmiRowStatusTable, mscMpanlStorageType=mscMpanlStorageType, mpaNetworkLinkCapabilitiesCA02A=mpaNetworkLinkCapabilitiesCA02A, mscMpanlDlciJvcCallingAddress=mscMpanlDlciJvcCallingAddress, mscMpanlFramerFrmModeErrors=mscMpanlFramerFrmModeErrors, mscMpanlFrmToIfByQueueTable=mscMpanlFrmToIfByQueueTable, mscMpanlSigProtocolErrors=mscMpanlSigProtocolErrors, mscMpanlFramerStorageType=mscMpanlFramerStorageType, mscMpanlDlciVcFrmCongestedToSubnet=mscMpanlDlciVcFrmCongestedToSubnet, mscMpanlDlciLCoSetupPriority=mscMpanlDlciLCoSetupPriority, mscMpanlDlciLCoPathTable=mscMpanlDlciLCoPathTable, mscMpanlDlciFecnFrmToIf=mscMpanlDlciFecnFrmToIf, mscMpanlSigInCallsRefused=mscMpanlSigInCallsRefused, mscMpanlDlciABitStatusFromIf=mscMpanlDlciABitStatusFromIf, mscMpanlDlciJvcPacketsDiscarded=mscMpanlDlciJvcPacketsDiscarded, mscMpanlDlciLCoReasonForNoRoute=mscMpanlDlciLCoReasonForNoRoute, mscMpanlDlciVcNotDataXferFromSubnet=mscMpanlDlciVcNotDataXferFromSubnet, mscMpanlDlciStatsTable=mscMpanlDlciStatsTable, mscMpanlDlciVcOoSeqPktCntExceeded=mscMpanlDlciVcOoSeqPktCntExceeded, mscMpanlDlciVcSubnetRecoveries=mscMpanlDlciVcSubnetRecoveries, mscMpanlDlciDiscDeCongestedFromIf=mscMpanlDlciDiscDeCongestedFromIf, mscMpanlIsdnIndex=mscMpanlIsdnIndex, mscMpanlDnaCallOptionsEntry=mscMpanlDnaCallOptionsEntry, mscMpanlDlciBytesFromIf=mscMpanlDlciBytesFromIf, mscMpanlSigIndex=mscMpanlSigIndex, mscMpanlDlciABitReasonToIf=mscMpanlDlciABitReasonToIf, mscMpanlStatsEntry=mscMpanlStatsEntry, mscMpanlDlciLCoCostMetric=mscMpanlDlciLCoCostMetric)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", mscMpanlSigLapfSysTable=mscMpanlSigLapfSysTable, mpaNetworkLinkGroupCA02A=mpaNetworkLinkGroupCA02A, mscMpanlDlciDiscCongestedToIf=mscMpanlDlciDiscCongestedToIf, mscMpanlSigMpanlStatsTable=mscMpanlSigMpanlStatsTable, mscMpanlFrMuxSetupPvcSetup=mscMpanlFrMuxSetupPvcSetup, mscMpanlDlciUsageState=mscMpanlDlciUsageState, mscMpanlDlciComponentName=mscMpanlDlciComponentName, mscMpanlDlciUnknownStatus=mscMpanlDlciUnknownStatus, mscMpanlSigUsageState=mscMpanlSigUsageState, mscMpanlSigMpanlReceiveRejectFrame=mscMpanlSigMpanlReceiveRejectFrame, mscMpanlSigLapfStatsTable=mscMpanlSigLapfStatsTable, mscMpanlIsdnProvTable=mscMpanlIsdnProvTable, mscMpanlDnaDefaultTransferPriority=mscMpanlDnaDefaultTransferPriority, mscMpanlDlciDiscExcessFromIfBytes=mscMpanlDlciDiscExcessFromIfBytes, mscMpanlLmiRowStatus=mscMpanlLmiRowStatus, mscMpanlOperStatusTable=mscMpanlOperStatusTable, mscMpanlDlciJvcPreviousState=mscMpanlDlciJvcPreviousState, mscMpanlDlciLbLocalTotalFrm=mscMpanlDlciLbLocalTotalFrm, mscMpanlIsdnProvEntry=mscMpanlIsdnProvEntry, mscMpanlDlciVcRowStatusEntry=mscMpanlDlciVcRowStatusEntry, mscMpanlVoFrOperEntry=mscMpanlVoFrOperEntry, mscMpanlDlciJvcStatTable=mscMpanlDlciJvcStatTable, mscMpanlDlciVcStorageType=mscMpanlDlciVcStorageType, mscMpanlSigMpanlStorageType=mscMpanlSigMpanlStorageType, mscMpanlDlciLCoElapsedTimeTillNow=mscMpanlDlciLCoElapsedTimeTillNow, mscMpanlPrefixDnaComponentName=mscMpanlPrefixDnaComponentName, mscMpanlSigMpanlDteCustomerId=mscMpanlSigMpanlDteCustomerId, mscMpanlDlciVcSegmentsRx=mscMpanlDlciVcSegmentsRx, mscMpanlSigMpanlCurrentState=mscMpanlSigMpanlCurrentState, mscMpanlFramerLinkTable=mscMpanlFramerLinkTable, mscMpanlFramerLrcErrors=mscMpanlFramerLrcErrors, mscMpanlSigMpanlStatsEntry=mscMpanlSigMpanlStatsEntry, mscMpanlSigRemoteBusy=mscMpanlSigRemoteBusy, mscMpanlFramerFrmFromIf64=mscMpanlFramerFrmFromIf64, mscMpanlSigMpanlDteNodeId=mscMpanlSigMpanlDteNodeId, mscMpanlSigMpanlSapXCommandsRx=mscMpanlSigMpanlSapXCommandsRx, mscMpanlDlciDiscCongestedToIfBytes=mscMpanlDlciDiscCongestedToIfBytes, mscMpanlDlciEirEgressSegFrm=mscMpanlDlciEirEgressSegFrm, mscMpanlSig=mscMpanlSig, mscMpanlDlciVcDataPath=mscMpanlDlciVcDataPath, mscMpanlDlciVcCallingDna=mscMpanlDlciVcCallingDna, mscMpanlLmiParmsTable=mscMpanlLmiParmsTable, mscMpanlFrMuxSetupPvcSetupProvTable=mscMpanlFrMuxSetupPvcSetupProvTable, mscMpanlFrmToIfByQueueEntry=mscMpanlFrmToIfByQueueEntry, mscMpanlVoFrStatsEntry=mscMpanlVoFrStatsEntry, mscMpanlControlStatus=mscMpanlControlStatus, mscMpanlNumberOfEmissionQs=mscMpanlNumberOfEmissionQs, mscMpanlSigSvcaccEntry=mscMpanlSigSvcaccEntry, mscMpanlOperationalState=mscMpanlOperationalState, mpaNetworkLinkCapabilitiesCA02=mpaNetworkLinkCapabilitiesCA02, mscMpanlDlciLCoIndex=mscMpanlDlciLCoIndex, mscMpanlDlciVcFastSelectCall=mscMpanlDlciVcFastSelectCall, mscMpanlSigMpanlProfileTable=mscMpanlSigMpanlProfileTable, mscMpanlSigCurrentState=mscMpanlSigCurrentState, mpaNetworkLinkMIB=mpaNetworkLinkMIB, mscMpanlDnaRowStatus=mscMpanlDnaRowStatus, mscMpanlDlciLCoCalledNpi=mscMpanlDlciLCoCalledNpi, mscMpanlDlciVcDuplicatesFromSubnet=mscMpanlDlciVcDuplicatesFromSubnet, mscMpanlDlciCommittedBurstSize=mscMpanlDlciCommittedBurstSize, mscMpanlDlciQ933CallState=mscMpanlDlciQ933CallState, mscMpanlSigRowStatus=mscMpanlSigRowStatus, mscMpanlIsdnOperTable=mscMpanlIsdnOperTable, mscMpanlStandbyStatus=mscMpanlStandbyStatus, mscMpanlDlciLCoCallingDna=mscMpanlDlciLCoCallingDna, mscMpanlSigIFramesRcvdDiscarded=mscMpanlSigIFramesRcvdDiscarded, mscMpanlDlciSpOpEntry=mscMpanlDlciSpOpEntry, mscMpanlDlciLCoCallDataTable=mscMpanlDlciLCoCallDataTable, mscMpanlDlciLCoRequiredCustomerParameter=mscMpanlDlciLCoRequiredCustomerParameter, mscMpanlDlciVcPeakOoSeqPktCount=mscMpanlDlciVcPeakOoSeqPktCount, mscMpanlSigLapfSysEntry=mscMpanlSigLapfSysEntry, mscMpanlDlciLCoCallingNpi=mscMpanlDlciLCoCallingNpi, mscMpanlSigCallSetupTimer=mscMpanlSigCallSetupTimer, mscMpanlDlciVcCallReferenceNumber=mscMpanlDlciVcCallReferenceNumber, mscMpanlDlciLCoComponentName=mscMpanlDlciLCoComponentName, mscMpanlSigOperationalState=mscMpanlSigOperationalState, mscMpanlDlciLoopbackState=mscMpanlDlciLoopbackState, mscMpanlFramerFrameCrcType=mscMpanlFramerFrameCrcType, mscMpanlFrMuxSetupIndex=mscMpanlFrMuxSetupIndex, mscMpanlRowStatusTable=mscMpanlRowStatusTable, mscMpanlSigAckTimer=mscMpanlSigAckTimer, mscMpanlSigStateEntry=mscMpanlSigStateEntry, mscMpanlSigReleaseTimer=mscMpanlSigReleaseTimer, mscMpanlFrMuxSetupPvcSetupRowStatusTable=mscMpanlFrMuxSetupPvcSetupRowStatusTable, mscMpanlDlciLCoState=mscMpanlDlciLCoState, mscMpanlVoFrTransmitInformationRate=mscMpanlVoFrTransmitInformationRate, mscMpanlPrefixDnaStorageType=mscMpanlPrefixDnaStorageType, mpaNetworkLinkGroupCA=mpaNetworkLinkGroupCA, mscMpanlSigMpanlProfileEntry=mscMpanlSigMpanlProfileEntry, mscMpanlDlciJvcOperEntry=mscMpanlDlciJvcOperEntry, mscMpanlDlciSpOpTable=mscMpanlDlciSpOpTable, mscMpanlDlciLCoRequiredSecurity=mscMpanlDlciLCoRequiredSecurity, mscMpanlDlciDiscardedBytes=mscMpanlDlciDiscardedBytes, mscMpanlSigCurrentNumberOfSvcCalls=mscMpanlSigCurrentNumberOfSvcCalls, mscMpanlDlciLCoBytesFromNetwork=mscMpanlDlciLCoBytesFromNetwork, mscMpanlDlciVc=mscMpanlDlciVc, mscMpanlFrMuxSetupRowStatus=mscMpanlFrMuxSetupRowStatus, mscMpanlDlciVcDmepEntry=mscMpanlDlciVcDmepEntry, mscMpanlDlciVcFrdTable=mscMpanlDlciVcFrdTable, mscMpanlDlciBecnFrmFromIf=mscMpanlDlciBecnFrmFromIf, mscMpanlLmiStateEntry=mscMpanlLmiStateEntry, mscMpanlIsdnRowStatusEntry=mscMpanlIsdnRowStatusEntry, mscMpanlDnaServiceExchange=mscMpanlDnaServiceExchange, mscMpanlDlciJvcIndex=mscMpanlDlciJvcIndex, mscMpanlCidDataEntry=mscMpanlCidDataEntry, mscMpanlCidDataTable=mscMpanlCidDataTable, mscMpanlAdminState=mscMpanlAdminState, mscMpanlFrMuxSetupRowStatusTable=mscMpanlFrMuxSetupRowStatusTable, mscMpanlFramerNormPrioLinkUtilToIf=mscMpanlFramerNormPrioLinkUtilToIf, mscMpanlDlciVcPriority=mscMpanlDlciVcPriority, mscMpanlSigLapfStatusEntry=mscMpanlSigLapfStatusEntry, mscMpanlDlciLCoBumpPreference=mscMpanlDlciLCoBumpPreference, mscMpanlSigQualityOfServiceNotAvailable=mscMpanlSigQualityOfServiceNotAvailable, mscMpanlDlciFciFromSubnet=mscMpanlDlciFciFromSubnet, mscMpanlDlciLbRemoteBecnFrm=mscMpanlDlciLbRemoteBecnFrm, mscMpanlDlciLCoPathUpDateTime=mscMpanlDlciLCoPathUpDateTime, mscMpanlOctetToIfByQueueIndex=mscMpanlOctetToIfByQueueIndex, mscMpanlDlciBecnFrmSetByService=mscMpanlDlciBecnFrmSetByService, mscMpanlDlciLCoCallReferenceNumber=mscMpanlDlciLCoCallReferenceNumber, mscMpanlDlciVcCalledNpi=mscMpanlDlciVcCalledNpi, mscMpanlVoFrFragmentedHighestPriorityFrames=mscMpanlVoFrFragmentedHighestPriorityFrames, mscMpanlUnknownStatus=mscMpanlUnknownStatus, mscMpanlDlciStartTime=mscMpanlDlciStartTime, mscMpanlFramerStateEntry=mscMpanlFramerStateEntry, mscMpanlPrefixDnaNumberingPlanIndicatorIndex=mscMpanlPrefixDnaNumberingPlanIndicatorIndex, mscMpanlSigMpanlAdminState=mscMpanlSigMpanlAdminState, mscMpanlFrMuxSetupComponentName=mscMpanlFrMuxSetupComponentName, mscMpanlIsdnStorageType=mscMpanlIsdnStorageType, mscMpanlDlciVcPeakOoSeqByteCount=mscMpanlDlciVcPeakOoSeqByteCount, mscMpanlDlciVcCallingNpi=mscMpanlDlciVcCallingNpi, mscMpanlDlciLCoPathValue=mscMpanlDlciLCoPathValue, mscMpanlSigStatsEntry=mscMpanlSigStatsEntry, mscMpanlDlciStateEntry=mscMpanlDlciStateEntry, mscMpanlFrMuxSetupPvcSetupRowStatusEntry=mscMpanlFrMuxSetupPvcSetupRowStatusEntry, mscMpanlDlciExcessBurstSize=mscMpanlDlciExcessBurstSize, mscMpanlDlciFecnFrmFromIf=mscMpanlDlciFecnFrmFromIf, mscMpanlDlciVcPeakOoSeqFrmForwarded=mscMpanlDlciVcPeakOoSeqFrmForwarded, mscMpanlFramerAdminState=mscMpanlFramerAdminState, mscMpanlLmiOperationalState=mscMpanlLmiOperationalState, mscMpanlFramerUtilEntry=mscMpanlFramerUtilEntry, mscMpanlFramerFrmFromIf=mscMpanlFramerFrmFromIf, mscMpanlLastUnknownDlci=mscMpanlLastUnknownDlci, mscMpanlDnaEgressAccounting=mscMpanlDnaEgressAccounting, mscMpanlSigInCalls=mscMpanlSigInCalls, mscMpanlEmissionPriorityQsEntry=mscMpanlEmissionPriorityQsEntry, mscMpanlDlciJvcComponentName=mscMpanlDlciJvcComponentName, mscMpanlSigMpanlLapfStatusTable=mscMpanlSigMpanlLapfStatusTable, mscMpanlDlciVcEmissionPriorityToNetwork=mscMpanlDlciVcEmissionPriorityToNetwork, mscMpanlSigMpanlUsageState=mscMpanlSigMpanlUsageState, mscMpanlDnaStorageType=mscMpanlDnaStorageType, mscMpanlDlciRowStatusTable=mscMpanlDlciRowStatusTable, mscMpanlSigDefaultAccounting=mscMpanlSigDefaultAccounting, mscMpanlDlciABitReasonFromIf=mscMpanlDlciABitReasonFromIf, mscMpanlFramerComponentName=mscMpanlFramerComponentName, mscMpanlSigLastDlciWithMsgBlockCongestion=mscMpanlSigLastDlciWithMsgBlockCongestion, mscMpanlDlciLCoRowStatusTable=mscMpanlDlciLCoRowStatusTable, mscMpanlSigWindowSize=mscMpanlSigWindowSize, mscMpanlUnknownDlciFramesFromIf=mscMpanlUnknownDlciFramesFromIf, mscMpanlSigMpanlIFramesTxDiscarded=mscMpanlSigMpanlIFramesTxDiscarded, mscMpanlSigRetransmitLimit=mscMpanlSigRetransmitLimit, mscMpanlSigReceiveRejectFrame=mscMpanlSigReceiveRejectFrame, mscMpanlOctetToIfByQueueTable=mscMpanlOctetToIfByQueueTable, mscMpanlDlciMaximumFrameSize=mscMpanlDlciMaximumFrameSize, mscMpanlFrmToIfByQueueValue=mscMpanlFrmToIfByQueueValue, mscMpanlDlciVcPathReliability=mscMpanlDlciVcPathReliability, mscMpanlFramerAborts=mscMpanlFramerAborts, mscMpanlDlciElapsedDifference=mscMpanlDlciElapsedDifference, mscMpanlSigMpanlLastStateChangeReason=mscMpanlSigMpanlLastStateChangeReason, mscMpanlDlciVcIntdEntry=mscMpanlDlciVcIntdEntry, mscMpanlSigAckTimeout=mscMpanlSigAckTimeout, mscMpanlVoFrStorageType=mscMpanlVoFrStorageType, mscMpanlDlciJvcCurrentState=mscMpanlDlciJvcCurrentState, mscMpanlVoFrRowStatusTable=mscMpanlVoFrRowStatusTable, mscMpanlDlciAvailabilityStatus=mscMpanlDlciAvailabilityStatus, mscMpanlDlciLCoRequiredTxBandwidth=mscMpanlDlciLCoRequiredTxBandwidth, mscMpanlSigIFramesTxDiscarded=mscMpanlSigIFramesTxDiscarded, mpaNetworkLinkGroupCA02=mpaNetworkLinkGroupCA02, mscMpanlSigStorageType=mscMpanlSigStorageType, mscMpanlDlciLCoRequiredTrafficType=mscMpanlDlciLCoRequiredTrafficType, mscMpanlFramerUnderruns=mscMpanlFramerUnderruns, mscMpanlDlciAdminState=mscMpanlDlciAdminState, mscMpanlDlciTransferPriorityFromNetwork=mscMpanlDlciTransferPriorityFromNetwork, mscMpanlDlciLCoDiscardPriority=mscMpanlDlciLCoDiscardPriority, mscMpanlVoFrStatsTable=mscMpanlVoFrStatsTable, mscMpanlLmiProcedures=mscMpanlLmiProcedures, mscMpanlFramerNormPrioLinkUtilFromIf=mscMpanlFramerNormPrioLinkUtilFromIf, mscMpanlDlciLCoLastTearDownReason=mscMpanlDlciLCoLastTearDownReason, mscMpanlFramerUsageState=mscMpanlFramerUsageState, mscMpanlDlciIntEntry=mscMpanlDlciIntEntry, mscMpanlDlciLbLocalDeFrm=mscMpanlDlciLbLocalDeFrm, mscMpanlIfEntryEntry=mscMpanlIfEntryEntry, mscMpanlFramerOctetFromIf64=mscMpanlFramerOctetFromIf64, mscMpanlSigMpanlHighestDlci=mscMpanlSigMpanlHighestDlci, mscMpanlDlciJvcStorageType=mscMpanlDlciJvcStorageType, mscMpanlDlciVcState=mscMpanlDlciVcState, mscMpanlDlciTotalEgressBytes=mscMpanlDlciTotalEgressBytes, mscMpanlDlciAbitTable=mscMpanlDlciAbitTable, mscMpanlDlciLCoPathDataTable=mscMpanlDlciLCoPathDataTable, mscMpanlDnaAccountCollection=mscMpanlDnaAccountCollection, mscMpanlVoFrComponentName=mscMpanlVoFrComponentName, mscMpanlAlarmStatus=mscMpanlAlarmStatus, mscMpanlDlciLbLocalTotalBytes=mscMpanlDlciLbLocalTotalBytes, mscMpanlDlciLCoRetryCount=mscMpanlDlciLCoRetryCount, mpaNetworkLinkCapabilities=mpaNetworkLinkCapabilities, mscMpanlVoFrLostFragmentsFromIf=mscMpanlVoFrLostFragmentsFromIf, mscMpanlDlciEirIngressSegFrm=mscMpanlDlciEirIngressSegFrm, mscMpanlVoFrRowStatus=mscMpanlVoFrRowStatus, mscMpanlRowStatusEntry=mscMpanlRowStatusEntry, mscMpanlDlciDiscDeCongestedFromIfBytes=mscMpanlDlciDiscDeCongestedFromIfBytes, mscMpanlFrmFromIf=mscMpanlFrmFromIf, mscMpanlDlciVcElapsedTimeTillNow=mscMpanlDlciVcElapsedTimeTillNow, mscMpanlDlciVcDmepValue=mscMpanlDlciVcDmepValue, mscMpanlDlciEmissionPriorityToIf=mscMpanlDlciEmissionPriorityToIf, mscMpanlIfAdminStatus=mscMpanlIfAdminStatus, mscMpanlDlciAbitEntry=mscMpanlDlciAbitEntry, mpaNetworkLinkCapabilitiesCA=mpaNetworkLinkCapabilitiesCA, mscMpanlDlciDiscCongestedFromIf=mscMpanlDlciDiscCongestedFromIf, mscMpanlDlciVcIntdTable=mscMpanlDlciVcIntdTable, mscMpanlDlciVcDmepTable=mscMpanlDlciVcDmepTable, mscMpanlDlciLCoCallDataEntry=mscMpanlDlciLCoCallDataEntry, mscMpanl=mscMpanl, mscMpanlDlciVcSegmentSize=mscMpanlDlciVcSegmentSize, mscMpanlFramerInterfaceName=mscMpanlFramerInterfaceName, mscMpanlSigOutCallsFailed=mscMpanlSigOutCallsFailed, mscMpanlDlciLCoEmissionPriority=mscMpanlDlciLCoEmissionPriority, mscMpanlSigMpanlFrmrReceive=mscMpanlSigMpanlFrmrReceive, mscMpanlSigMpanlIFramesTransmitted=mscMpanlSigMpanlIFramesTransmitted, mscMpanlFramerOctetFromIf=mscMpanlFramerOctetFromIf, mscMpanlDlciCalldEntry=mscMpanlDlciCalldEntry, mscMpanlDlciLbRemoteFecnFrm=mscMpanlDlciLbRemoteFecnFrm, mscMpanlFramer=mscMpanlFramer, mscMpanlFramerLargeFrmErrors=mscMpanlFramerLargeFrmErrors, mscMpanlCommentText=mscMpanlCommentText, mscMpanlDlciJvcProtocolErrors=mscMpanlDlciJvcProtocolErrors, mscMpanlSigMpanlSap0CommandsTx=mscMpanlSigMpanlSap0CommandsTx, mscMpanlDlciJvcCalledLcn=mscMpanlDlciJvcCalledLcn, mscMpanlDlciErrorLongBytesFromIf=mscMpanlDlciErrorLongBytesFromIf, mscMpanlSigSetupTimeout=mscMpanlSigSetupTimeout, mscMpanlDlciVcAccountingEnd=mscMpanlDlciVcAccountingEnd, mscMpanlDlciVcCannotForwardToSubnet=mscMpanlDlciVcCannotForwardToSubnet, mscMpanlUsageState=mscMpanlUsageState, mscMpanlFrMuxSetupStorageType=mscMpanlFrMuxSetupStorageType, mscMpanlSigIFramesTransmitted=mscMpanlSigIFramesTransmitted, mscMpanlSigMpanlOperationalState=mscMpanlSigMpanlOperationalState, mscMpanlIsdnBChannelState=mscMpanlIsdnBChannelState, mscMpanlDlciStorageType=mscMpanlDlciStorageType, mscMpanlFramerProvTable=mscMpanlFramerProvTable, mscMpanlSigMpanlProtocolErrors=mscMpanlSigMpanlProtocolErrors, mscMpanlDlciLbLocalBecnFrm=mscMpanlDlciLbLocalBecnFrm, mscMpanlIsdnActiveVirtualCircuitsCount=mscMpanlIsdnActiveVirtualCircuitsCount, mscMpanlLmiAdminState=mscMpanlLmiAdminState, mscMpanlSigMpanlRemoteBusy=mscMpanlSigMpanlRemoteBusy, mscMpanlSigSysParmsTable=mscMpanlSigSysParmsTable, mscMpanlIsdnDataSigChan=mscMpanlIsdnDataSigChan, mscMpanlFramerIndex=mscMpanlFramerIndex)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-MpaNetworkLinkMIB", mscMpanlDlciLCoPathEntry=mscMpanlDlciLCoPathEntry, mscMpanlSigCurrentQueueSize=mscMpanlSigCurrentQueueSize, mscMpanlSigIdleProbeTimer=mscMpanlSigIdleProbeTimer, mscMpanlDlciLbComponentName=mscMpanlDlciLbComponentName, mscMpanlDlciVcEmissionPriorityFromNetwork=mscMpanlDlciVcEmissionPriorityFromNetwork, mscMpanlSigMpanlRowStatusTable=mscMpanlSigMpanlRowStatusTable, mscMpanlSigLastCauseInStatusMsgReceived=mscMpanlSigLastCauseInStatusMsgReceived, mscMpanlDlciLCoRowStatusEntry=mscMpanlDlciLCoRowStatusEntry, mscMpanlDlciErrorLongFrmFromIf=mscMpanlDlciErrorLongFrmFromIf, mscMpanlVoFrIndex=mscMpanlVoFrIndex, mscMpanlDlciTotalEgressSegFrm=mscMpanlDlciTotalEgressSegFrm, mscMpanlSigLastDlciReceivedStatus=mscMpanlSigLastDlciReceivedStatus, mscMpanlLmiRowStatusEntry=mscMpanlLmiRowStatusEntry, mscMpanlLmi=mscMpanlLmi, mscMpanlAvailabilityStatus=mscMpanlAvailabilityStatus, mscMpanlDlciLbLocalDeBytes=mscMpanlDlciLbLocalDeBytes, mscMpanlVoFrProtocolViolationsFromIf=mscMpanlVoFrProtocolViolationsFromIf, mscMpanlDlciDiscByteAbit=mscMpanlDlciDiscByteAbit, mscMpanlSigLastTimeMsgBlockCongested=mscMpanlSigLastTimeMsgBlockCongested, mscMpanlSigMpanlComponentName=mscMpanlSigMpanlComponentName, mscMpanlPrefixDnaRowStatusTable=mscMpanlPrefixDnaRowStatusTable, mscMpanlDlciEirIngressBytes=mscMpanlDlciEirIngressBytes, mscMpanlDlciCalldTable=mscMpanlDlciCalldTable, mscMpanlDlciVcOoSeqByteCntExceeded=mscMpanlDlciVcOoSeqByteCntExceeded, mscMpanlTrafficStatsEntry=mscMpanlTrafficStatsEntry, mscMpanlLmiParmsEntry=mscMpanlLmiParmsEntry, mscMpanlFramerOperationalState=mscMpanlFramerOperationalState, mscMpanlDlciTransferPriorityToNetwork=mscMpanlDlciTransferPriorityToNetwork, mscMpanlProvEntry=mscMpanlProvEntry, mscMpanlDlciLCoPathDataEntry=mscMpanlDlciLCoPathDataEntry, mscMpanlSigAckDelayTimer=mscMpanlSigAckDelayTimer, mscMpanlSigMpanlSapXCommandsTx=mscMpanlSigMpanlSapXCommandsTx, mscMpanlFrMuxSetupPvcSetupProvEntry=mscMpanlFrMuxSetupPvcSetupProvEntry, mscMpanlSigNetworkType=mscMpanlSigNetworkType, mscMpanlSigIFramesReceived=mscMpanlSigIFramesReceived, mscMpanlLmiStateTable=mscMpanlLmiStateTable, mscMpanlEmissionPriorityQsTable=mscMpanlEmissionPriorityQsTable, mscMpanlVoFrOperTable=mscMpanlVoFrOperTable)

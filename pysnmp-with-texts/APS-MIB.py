#
# PySNMP MIB module APS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:24:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
InterfaceIndex, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
transmission, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, Gauge32, Counter64, Unsigned32, Bits, IpAddress, TimeTicks, ObjectIdentity, iso, NotificationType, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "transmission", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "Gauge32", "Counter64", "Unsigned32", "Bits", "IpAddress", "TimeTicks", "ObjectIdentity", "iso", "NotificationType", "MibIdentifier")
TimeStamp, DisplayString, TextualConvention, StorageType, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "TextualConvention", "StorageType", "RowStatus")
apsMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 49))
apsMIB.setRevisions(('2003-02-28 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: apsMIB.setRevisionsDescriptions(('Initial version of this MIB, published as RFC 3498.',))
if mibBuilder.loadTexts: apsMIB.setLastUpdated('200302280000Z')
if mibBuilder.loadTexts: apsMIB.setOrganization('IETF AToMMIB Working Group')
if mibBuilder.loadTexts: apsMIB.setContactInfo(' Jim Kuhfeld Postal: RedBack Networks. Inc. 300 Holger Way San Jose, CA 95134-1362 Tel: +1 408 750 5465 Email: jkuhfeld@redback.com Jeff Johnson Postal: RedBack Networks. Inc. 300 Holger Way San Jose, CA 95134-1362 Tel: +1 408 750 5460 Email: jeff@redback.com Michael Thatcher Postal: RedBack Networks. Inc. 300 Holger Way San Jose, CA 95134-1362 Tel: +1 408 750 5449 Email: thatcher@redback.com')
if mibBuilder.loadTexts: apsMIB.setDescription('This management information module supports the configuration and management of SONET linear APS groups. The definitions and descriptions used in this MIB have been derived from Synchronous Optical Network (SONET) Transport Systems: Common Generic Criteria, GR-253-CORE Issue 3, September 2000, section 5.3. The MIB is also consistent with the Multiplex Section Protection (MSP) protocol as specified in ITU-T Recommendation G.783, Characteristics of synchronous digital hierarchy (SDH) equipment function blocks, Annex A and B. Copyright (C) The Internet Society (2003). This version of this MIB module is part of RFC 3498; see the RFC itself for full legal notices. ')
apsMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 49, 1))
apsMIBNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 49, 2))
apsMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 49, 3))
class ApsK1K2(TextualConvention, OctetString):
    reference = 'Bellcore (Telcordia Technologies) GR-253-CORE, Issue 3, September 2000, 5.3.5.'
    description = 'This Textual Convention describes an object that stores a SONET K1 and K2 byte APS protocol field. K1 is located in the first octet, K2 is located in the second octet. Bits are numbered from left to right. Bits 1-4 of the K1 byte indicate a request. 1111 Lockout of Protection 1110 Forced Switch 1101 SF - High Priority 1100 SF - Low Priority 1011 SD - High Priority 1010 SD - Low Priority 1001 not used 1000 Manual Switch 0111 not used 0110 Wait-to-Restore 0101 not used 0100 Exercise 0011 not used 0010 Reverse Request 0001 Do Not Revert 0000 No Request Bits 5-8 of the K1 byte indicate the channel associated with the request defined in bits 1-4. 0000 is the Null channel. 1-14 are working channels. 15 is the extra traffic channel Bits 1-4 of the K2 byte indicate a channel. The channel is defined with the same syntax as K1 Bits 5-8. Bit 5 of the K2 byte indicates the architecture. 0 if the architecture is 1+1 1 if the architecture is 1:n Bits 6-8 of the K2 byte indicates the mode. 000 - 011 are reserved for future use 100 indicates the mode is unidirectional 101 indicates the mode is bidirectional 110 RDI-L 111 AIS-L '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 2)
    fixedLength = 2

class ApsSwitchCommand(TextualConvention, Integer32):
    description = 'An APS switch command allows a user to perform protection switch actions. If the APS switch command cannot be executed because an equal or higher priority request is in effect, an inconsistentValue error is returned. The Switch command values are: noCmd This value should be returned by a read request when no switch command has been written to the object in question since initialization. This value may not be used in a write operation. If noCmd is used in a write operation a wrongValue error is returned. clear Clears all of the switch commands listed below for the specified channel. lockoutOfProtection Prevents any of the working channels from switching to the protection line. The specified channel should be the protection channel, otherwise an inconsistentValue error is returned. forcedSwitchWorkToProtect Switches the specified working channel to the protection line. If the protection channel is specified an inconsistentValue error is returned. forcedSwitchProtectToWork Switches the working channel back from the protection line to the working line. The specified channel should be the protection channel, otherwise an inconsistentValue error is returned. manualSwitchWorkToProtect Switches the specified working channel to the protection line. If the protection channel is specified an inconsistentValue error is returned. manualSwitchProtectToWork Switches the working channel back from the protection line to the working line. The specified channel should be the protection channel, otherwise an inconsistentValue error is returned. exercise Exercises the protocol for a protection switch of the specified channel by issuing an Exercise request for that channel and checking the response on the APS channel. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("noCmd", 1), ("clear", 2), ("lockoutOfProtection", 3), ("forcedSwitchWorkToProtect", 4), ("forcedSwitchProtectToWork", 5), ("manualSwitchWorkToProtect", 6), ("manualSwitchProtectToWork", 7), ("exercise", 8))

class ApsControlCommand(TextualConvention, Integer32):
    description = 'An APS control command applies only to LTE that support the 1:n architecture and performs the following actions. The Control command values are: noCmd This value should be returned by a read request when no control command has been written to the object in question since initialization. This value may not be used in a write operation. If noCmd is used in a write operation a wrongValue error is returned. lockoutWorkingChannel Prevents the specified working channel from switching to the protection line. If the protection line is specified an inconsistentValue error is returned. clearLockoutWorkingChannel Clears the lockout a working channel command for the channel specified. If the protection line is specified an inconsistentValue error is returned.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("noCmd", 1), ("lockoutWorkingChannel", 2), ("clearLockoutWorkingChannel", 3))

apsConfig = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 49, 1, 1))
apsConfigGroups = MibScalar((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsConfigGroups.setStatus('current')
if mibBuilder.loadTexts: apsConfigGroups.setDescription('The count of APS groups. This count includes all rows in apsConfigTable, regardless of the value of apsConfigRowStatus.')
apsConfigTable = MibTable((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2), )
if mibBuilder.loadTexts: apsConfigTable.setStatus('current')
if mibBuilder.loadTexts: apsConfigTable.setDescription('This table lists the APS groups that have been configured on the system.')
apsConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1), ).setIndexNames((1, "APS-MIB", "apsConfigName"))
if mibBuilder.loadTexts: apsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apsConfigEntry.setDescription('A conceptual row in the apsConfigTable.')
apsConfigName = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: apsConfigName.setStatus('current')
if mibBuilder.loadTexts: apsConfigName.setDescription('A textual name for the APS group.')
apsConfigRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: apsConfigRowStatus.setDescription('The status of this APS group entry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Also, all associated apsChanConfigEntry rows must represent a set of consecutive channel numbers beginning with 0 or 1, depending on the selected architecture. When set to notInService changes may be made to apsConfigMode, apsConfigRevert, apsConfigDirection, apsConfigExtraTraffic, apsConfigSdBerThreshold, apsConfigSfBerThreshold, and apsConfigWaitToRestore. Also, associated apsChanConfigTable objects may be added, deleted and modified.')
apsConfigMode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("onePlusOne", 1), ("oneToN", 2), ("onePlusOneCompatible", 3), ("onePlusOneOptimized", 4))).clone('onePlusOne')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigMode.setStatus('current')
if mibBuilder.loadTexts: apsConfigMode.setDescription('The architecture of the APS group. onePlusOne The 1+1 architecture permanently bridges the working line to the protection line. oneToN The 1:n architecture allows one protection channel to protect up to n working channels. When a fault is detected on one of the n working channels that channel is bridged over the protection channel. onePlusOneCompatible This refers to 1 + 1 bidirectional switching compatible with 1:n bidirectional switching as specified in ITU-T Recommendation G.783 (04/97) section A.3.4.1. Since this mode necessitates bidirectional switching, apsConfigDirection must be set to bidirectional whenever onePlusOneCompatible is set. onePlusOneOptimized This refers to 1 + 1 bidirectional switching optimized for a network using predominantly 1 + 1 bidirectional switching as specified in ITU-T Recommendation G.783 (04/97) section B.1. Since this mode necessitates bidirectional switching, apsConfigDirection must be set to bidirectional whenever onePlusOneOptimized is set. This object may not be modified if the associated apsConfigRowStatus object is equal to active(1).')
apsConfigRevert = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonrevertive", 1), ("revertive", 2))).clone('nonrevertive')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigRevert.setStatus('current')
if mibBuilder.loadTexts: apsConfigRevert.setDescription('The revertive mode of the APS group. nonrevertive Traffic remains on the protection line until another switch request is received. revertive When the condition that caused a switch to the protection line has been cleared the signal is switched back to the working line. Since switching is revertive with the 1:n architecture, apsConfigRevert must be set to revertive if apsConfigMode is set to oneToN. Switching may optionally be revertive with the 1+1 architecture. This object may not be modified if the associated apsConfigRowStatus object is equal to active(1). ')
apsConfigDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unidirectional", 1), ("bidirectional", 2))).clone('unidirectional')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigDirection.setStatus('current')
if mibBuilder.loadTexts: apsConfigDirection.setDescription('The directional mode of the APS group. unidirectional The unidirectional mode provides protection in one direction. bidirectional The bidirectional mode provides protection in both directions. This object may not be modified if the associated apsConfigRowStatus object is equal to active(1). ')
apsConfigExtraTraffic = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigExtraTraffic.setStatus('current')
if mibBuilder.loadTexts: apsConfigExtraTraffic.setDescription("This object enables or disables the transfer of extra traffic on the protection channel in a 1:n architecture. This object must be set to disabled if the architecture is 1+1. It may be necessary to disable this in order to interwork with other SONET network elements that don't support extra traffic. This object may not be modified if the associated apsConfigRowStatus object is equal to active(1). ")
apsConfigSdBerThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 9)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigSdBerThreshold.setStatus('current')
if mibBuilder.loadTexts: apsConfigSdBerThreshold.setDescription('The Signal Degrade Bit Error Rate. The negated value of this number is used as the exponent of 10 for computing the threshold value for the Bit Error Rate (BER). For example, a value of 5 indicates a BER threshold of 10^-5. This object may be modified if the associated apsConfigRowStatus object is equal to active(1).')
apsConfigSfBerThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 5)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigSfBerThreshold.setStatus('current')
if mibBuilder.loadTexts: apsConfigSfBerThreshold.setDescription('The Signal Failure Bit Error Rate. The negated value of this number is used as the exponent of 10 for computing the threshold value for the Bit Error Rate (BER). For example, a value of 5 indicates a BER threshold of 10^-5. This object may be modified if the associated apsConfigRowStatus object is equal to active(1).')
apsConfigWaitToRestore = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 720)).clone(300)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigWaitToRestore.setStatus('current')
if mibBuilder.loadTexts: apsConfigWaitToRestore.setDescription('The Wait To Restore period in seconds. After clearing of a condition that necessitated an automatic switch, the wait to restore period must elapse before reverting. This is intended to avoid rapid switch oscillations. GR-253-CORE specifies a Wait To Restore range of 5 to 12 minutes. G.783 defines a 5 to 12 minute Wait To Restore range in section 5.4.1.1.3, but also allows for a shorter WTR period in Table 2-1, WaitToRestore value (MI_WTRtime: 0..(5)..12 minutes). This object may not be modified if the associated apsConfigRowStatus object is equal to active(1).')
apsConfigCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsConfigCreationTime.setStatus('current')
if mibBuilder.loadTexts: apsConfigCreationTime.setDescription('The value of sysUpTime at the time the row was created')
apsConfigStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 1, 2, 1, 11), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsConfigStorageType.setStatus('current')
if mibBuilder.loadTexts: apsConfigStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
apsStatusTable = MibTable((1, 3, 6, 1, 2, 1, 10, 49, 1, 2), )
if mibBuilder.loadTexts: apsStatusTable.setStatus('current')
if mibBuilder.loadTexts: apsStatusTable.setDescription('This table provides status information about APS groups that have been configured on the system.')
apsStatusEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1), )
apsConfigEntry.registerAugmentions(("APS-MIB", "apsStatusEntry"))
apsStatusEntry.setIndexNames(*apsConfigEntry.getIndexNames())
if mibBuilder.loadTexts: apsStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apsStatusEntry.setDescription('A conceptual row in the apsStatusTable.')
apsStatusK1K2Rcv = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 1), ApsK1K2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusK1K2Rcv.setStatus('current')
if mibBuilder.loadTexts: apsStatusK1K2Rcv.setDescription('The current value of the K1 and K2 bytes received on the protection channel.')
apsStatusK1K2Trans = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 2), ApsK1K2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusK1K2Trans.setStatus('current')
if mibBuilder.loadTexts: apsStatusK1K2Trans.setDescription('The current value of the K1 and K2 bytes transmitted on the protection channel.')
apsStatusCurrent = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 3), Bits().clone(namedValues=NamedValues(("modeMismatch", 0), ("channelMismatch", 1), ("psbf", 2), ("feplf", 3), ("extraTraffic", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusCurrent.setStatus('current')
if mibBuilder.loadTexts: apsStatusCurrent.setDescription('The current status of the APS group. modeMismatch Modes other than 1+1 unidirectional monitor protection line K2 bit 5, which indicates the architecture and K2 bits 6-8, which indicate if the mode is unidirectional or bidirectional. A conflict between the current local mode and the received K2 mode information constitutes a mode mismatch. channelMismatch This bit indicates a mismatch between the transmitted K1 channel and the received K2 channel has been detected. psbf This bit indicates a Protection Switch Byte Failure (PSBF) is in effect. This condition occurs when either an inconsistent APS byte or an invalid code is detected. An inconsistent APS byte occurs when no three consecutive K1 bytes of the last 12 successive frames are identical, starting with the last frame containing a previously consistent byte. An invalid code occurs when the incoming K1 byte contains an unused code or a code irrelevant for the specific switching operation (e.g., Reverse Request while no switching request is outstanding) in three consecutive frames. An invalid code also occurs when the incoming K1 byte contains an invalid channel number in three consecutive frames. feplf Modes other than 1+1 unidirectional monitor the K1 byte for Far-End Protection-Line failures. A Far-End Protection-Line defect is declared based on receiving SF on the protection line. extraTraffic This bit indicates whether extra traffic is currently being accepted on the protection line. ')
apsStatusModeMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusModeMismatches.setStatus('current')
if mibBuilder.loadTexts: apsStatusModeMismatches.setDescription('A count of Mode Mismatch conditions. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of apsStatusDiscontinuityTime.')
apsStatusChannelMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusChannelMismatches.setStatus('current')
if mibBuilder.loadTexts: apsStatusChannelMismatches.setDescription('A count of Channel Mismatch conditions. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of apsStatusDiscontinuityTime.')
apsStatusPSBFs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusPSBFs.setStatus('current')
if mibBuilder.loadTexts: apsStatusPSBFs.setDescription('A count of Protection Switch Byte Failure conditions. This condition occurs when either an inconsistent APS byte or an invalid code is detected. An inconsistent APS byte occurs when no three consecutive K1 bytes of the last 12 successive frames are identical, starting with the last frame containing a previously consistent byte. An invalid code occurs when the incoming K1 byte contains an unused code or a code irrelevant for the specific switching operation (e.g., Reverse Request while no switching request is outstanding) in three consecutive frames. An invalid code also occurs when the incoming K1 byte contains an invalid channel number in three consecutive frames. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of apsStatusDiscontinuityTime.')
apsStatusFEPLFs = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusFEPLFs.setStatus('current')
if mibBuilder.loadTexts: apsStatusFEPLFs.setDescription('A count of Far-End Protection-Line Failure conditions. This condition is declared based on receiving SF on the protection line in the K1 byte. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of apsStatusDiscontinuityTime.')
apsStatusSwitchedChannel = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusSwitchedChannel.setStatus('current')
if mibBuilder.loadTexts: apsStatusSwitchedChannel.setDescription('This field is set to the number of the channel that is currently switched to protection. The value 0 indicates no channel is switched to protection. The values 1-14 indicate that working channel is switched to protection.')
apsStatusDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 2, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsStatusDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: apsStatusDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this APS group's counters suffered a discontinuity. The relevant counters are the specific instances associated with this APS group of any Counter32 object contained in apsStatusTable. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
apsMap = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 49, 1, 3))
apsChanLTEs = MibScalar((1, 3, 6, 1, 2, 1, 10, 49, 1, 3, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanLTEs.setStatus('current')
if mibBuilder.loadTexts: apsChanLTEs.setDescription('The count of SONET LTE interfaces on the system. Each interface that is included has an ifType value of sonet(39).')
apsMapTable = MibTable((1, 3, 6, 1, 2, 1, 10, 49, 1, 3, 2), )
if mibBuilder.loadTexts: apsMapTable.setStatus('current')
if mibBuilder.loadTexts: apsMapTable.setDescription('This table lists the SONET LTE interfaces on the system. Each interface that is listed has an ifType value of sonet(39).')
apsMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 49, 1, 3, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: apsMapEntry.setStatus('current')
if mibBuilder.loadTexts: apsMapEntry.setDescription('A conceptual row in the apsMapTable.')
apsMapGroupName = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 3, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsMapGroupName.setStatus('current')
if mibBuilder.loadTexts: apsMapGroupName.setDescription('A textual name for the APS group which this channel is included in. If the channel is not part of an APS group this value is set to a string of size 0. When an instance of apsChanConfigIfIndex is set equal to an instance of ifIndex that has an ifType value of sonet(39), apsMapGroupName is set equal to the corresponding value of apsChanConfigGroupName. If an instance of ifIndex that has an ifType value of sonet(39) ceases to be equal to an instance of apsChanConfigIfIndex, either because of a change in the value of apsChanConfigIfIndex, or because of row deletion in the ApsChanConfigTable, apsMapGroupName is set to a string of size 0.')
apsMapChanNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsMapChanNumber.setStatus('current')
if mibBuilder.loadTexts: apsMapChanNumber.setDescription('This field is set to a unique channel number within an APS group. The value 0 indicates the null channel. The values 1-14 define a working channel. If the SONET LTE is not part of an APS group this value is set to -1. When an instance of apsChanConfigIfIndex is set equal to an instance of ifIndex that has an ifType value of sonet(39), apsMapChanNumber is set equal to the corresponding value of apsChanConfigNumber. If an instance of ifIndex that has an ifType value of sonet(39) ceases to be equal to an instance of apsChanConfigIfIndex, either because of a change in the value of apsChanConfigIfIndex, or because of row deletion in the ApsChanConfigTable, apsMapChanNumber is set to -1.')
apsChanConfigTable = MibTable((1, 3, 6, 1, 2, 1, 10, 49, 1, 4), )
if mibBuilder.loadTexts: apsChanConfigTable.setStatus('current')
if mibBuilder.loadTexts: apsChanConfigTable.setDescription('This table lists the APS channels that have been configured in APS groups.')
apsChanConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 49, 1, 4, 1), ).setIndexNames((0, "APS-MIB", "apsChanConfigGroupName"), (0, "APS-MIB", "apsChanConfigNumber"))
if mibBuilder.loadTexts: apsChanConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apsChanConfigEntry.setDescription('A conceptual row in the apsChanConfigTable.')
apsChanConfigGroupName = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 4, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: apsChanConfigGroupName.setStatus('current')
if mibBuilder.loadTexts: apsChanConfigGroupName.setDescription('A textual name for the APS group which this channel is included in.')
apsChanConfigNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14)))
if mibBuilder.loadTexts: apsChanConfigNumber.setStatus('current')
if mibBuilder.loadTexts: apsChanConfigNumber.setDescription('This field is set to a unique channel number within an APS group. The value 0 indicates the null channel. The values 1-14 define a working channel. This field must be assigned a unique number within the group.')
apsChanConfigRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsChanConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: apsChanConfigRowStatus.setDescription('The status of this APS channel entry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. A row in the apsChanConfigTable may not be created, deleted, set to notInService or otherwise modified if the apsChanConfigGroupName value is equal to an apsConfigName value and the associated apsConfigRowStatus object is equal to active. However, if the apsConfigRowStatus object is equal to notInService, a row may be created, deleted or modified. In other words, a channel may not be added, deleted or modified if the group is active. A row may be created with an apsChanConfigGroupName value that is not equal to any existing instance of apsConfigName. This action is the initial step in adding a SONET LTE to a new APS group. If this object is set to destroy, the associated instance of apsMapGroupName will be set to a string of size 0 and the apsMapChanNumber will be set to -1. The channel status entry will also be deleted by this action. apsChanConfigNumber must be set to a unique channel number within the APS group. The value 0 indicates the null channel. The values 1-14 define a working channel. When an attempt is made to set the corresponding apsConfigRowStatus field to active the apsChanConfigNumber values of all entries with equal apsChanConfigGroupName fields must represent a set of consecutive integer values beginning with 0 or 1, depending on the architecture of the group, and ending with n, where n is greater than or equal to 1 and less than or equal to 14. Otherwise, the error inconsistentValue is returned to the apsConfigRowStatus set attempt.')
apsChanConfigIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 4, 1, 4), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsChanConfigIfIndex.setStatus('current')
if mibBuilder.loadTexts: apsChanConfigIfIndex.setDescription('The Interface Index assigned to a SONET LTE. This is an interface with ifType sonet(39). The value of this object must be unique among all instances of apsChanConfigIfIndex. In other words, a particular SONET LTE can only be configured in one APS group. This object cannot be set if the apsChanConfigGroupName instance associated with this row is equal to an instance of apsConfigName and the corresponding apsConfigRowStatus object is set to active. In other words this value cannot be changed if the APS group is active. However, this value may be changed if the apsConfigRowStatus value is equal to notInService.')
apsChanConfigPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2))).clone('low')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsChanConfigPriority.setStatus('current')
if mibBuilder.loadTexts: apsChanConfigPriority.setDescription('The priority of the channel. This field determines whether high or low priority SD and SF codes are used in K1 requests. This field is only applicable if the channel is to be included in a group using the 1:n architecture. It is not applicable if the channel is to be included in a group using the 1+1 architecture, and is ignored in that case. This object cannot be set if the apsChanConfigGroupName instance associated with this row is equal to an instance of apsConfigName and the corresponding apsConfigRowStatus object is set to active. In other words this value cannot be changed if the APS group is active. However, this value may be changed if the apsConfigRowStatus value is equal to notInService.')
apsChanConfigStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 4, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: apsChanConfigStorageType.setStatus('current')
if mibBuilder.loadTexts: apsChanConfigStorageType.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
apsCommandTable = MibTable((1, 3, 6, 1, 2, 1, 10, 49, 1, 5), )
if mibBuilder.loadTexts: apsCommandTable.setStatus('current')
if mibBuilder.loadTexts: apsCommandTable.setDescription('This table allows commands to be sent to configured APS groups.')
apsCommandEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 49, 1, 5, 1), ).setIndexNames((0, "APS-MIB", "apsChanConfigGroupName"), (0, "APS-MIB", "apsChanConfigNumber"))
if mibBuilder.loadTexts: apsCommandEntry.setStatus('current')
if mibBuilder.loadTexts: apsCommandEntry.setDescription('A conceptual row in the apsCommandTable. This row exists only if the associated apsConfigEntry is active.')
apsCommandSwitch = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 5, 1, 1), ApsSwitchCommand()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsCommandSwitch.setStatus('current')
if mibBuilder.loadTexts: apsCommandSwitch.setDescription('Allows the initiation of an APS switch command on the APS group and channel specified by the index values. When read this object returns the last command written or noCmd if no command has been written to this channel since initialization. The return of the last command written does not imply that this command is currently in effect. This request may have been preempted by a higher priority local or remote request. In order to determine the current state of the APS group it is necessary to read the objects apsStatusK1K2Rcv and apsStatusK1K2Trans. The value lockoutOfProtection should only be applied to the protection line channel since that switch command prevents any of the working channels from switching to the protection line. Following the same logic, forcedSwitchProtectToWork and manualSwitchProtectToWork should only be applied to the protection line channel. forcedSwitchWorkToProtect and manualSwitchWorkToProtect should only be applied to a working channel.')
apsCommandControl = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 5, 1, 2), ApsControlCommand()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsCommandControl.setStatus('current')
if mibBuilder.loadTexts: apsCommandControl.setDescription('Allows the initiation of an APS control command on the APS group and channel specified by the index values. When read this object returns the last command written or noCmd if no command has been written to this channel since initialization. This object does not apply to the protection line.')
apsChanStatusTable = MibTable((1, 3, 6, 1, 2, 1, 10, 49, 1, 6), )
if mibBuilder.loadTexts: apsChanStatusTable.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusTable.setDescription('This table contains status information for all SONET LTE interfaces that are included in APS groups.')
apsChanStatusEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 49, 1, 6, 1), )
apsChanConfigEntry.registerAugmentions(("APS-MIB", "apsChanStatusEntry"))
apsChanStatusEntry.setIndexNames(*apsChanConfigEntry.getIndexNames())
if mibBuilder.loadTexts: apsChanStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusEntry.setDescription('A conceptual row in the apsChanStatusTable.')
apsChanStatusCurrent = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 6, 1, 1), Bits().clone(namedValues=NamedValues(("lockedOut", 0), ("sd", 1), ("sf", 2), ("switched", 3), ("wtr", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanStatusCurrent.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusCurrent.setDescription('Indicates the current state of the port. lockedOut This bit, when applied to a working channel, indicates that the channel is prevented from switching to the protection line. When applied to the null channel, this bit indicates that no working channel may switch to the protection line. sd A signal degrade condition is in effect. sf A signal failure condition is in effect. switched The switched bit is applied to a working channel if that channel is currently switched to the protection line. wtr A Wait-to-Restore state is in effect.')
apsChanStatusSignalDegrades = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanStatusSignalDegrades.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusSignalDegrades.setDescription('A count of Signal Degrade conditions. This condition occurs when the line Bit Error Rate exceeds the currently configured value of the relevant instance of apsConfigSdBerThreshold. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of apsChanStatusDiscontinuityTime.')
apsChanStatusSignalFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanStatusSignalFailures.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusSignalFailures.setDescription('A count of Signal Failure conditions that have been detected on the incoming signal. This condition occurs when a loss of signal, loss of frame, AIS-L or a Line bit error rate exceeding the currently configured value of the relevant instance of apsConfigSfBerThreshold. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of apsChanStatusDiscontinuityTime.')
apsChanStatusSwitchovers = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanStatusSwitchovers.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusSwitchovers.setDescription('When queried with index value apsChanConfigNumber other than 0, this object will return the number of times this channel has switched to the protection line. When queried with index value apsChanConfigNumber set to 0, which is the protection line, this object will return the number of times that any working channel has been switched back to the working line from this protection line. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of apsChanStatusDiscontinuityTime.')
apsChanStatusLastSwitchover = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 6, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanStatusLastSwitchover.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusLastSwitchover.setDescription('When queried with index value apsChanConfigNumber other than 0, this object will return the value of sysUpTime when this channel last completed a switch to the protection line. If this channel has never switched to the protection line, the value 0 will be returned. When queried with index value apsChanConfigNumber set to 0, which is the protection line, this object will return the value of sysUpTime the last time that a working channel was switched back to the working line from this protection line. If no working channel has ever switched back to the working line from this protection line, the value 0 will be returned.')
apsChanStatusSwitchoverSeconds = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanStatusSwitchoverSeconds.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusSwitchoverSeconds.setDescription('The cumulative Protection Switching Duration (PSD) time in seconds. For a working channel, this is the cumulative number of seconds that service was carried on the protection line. For the protection line, this is the cumulative number of seconds that the protection line has been used to carry any working channel traffic. This information is only valid if revertive switching is enabled. The value 0 will be returned otherwise. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of apsChanStatusDiscontinuityTime. For example, if the value of an instance of apsChanStatusSwitchoverSeconds changes from a non-zero value to zero due to revertive switching being disabled, it is expected that the corresponding value of apsChanStatusDiscontinuityTime will be updated to reflect the time of the configuration change. ')
apsChanStatusDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 49, 1, 6, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apsChanStatusDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: apsChanStatusDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this channel's counters suffered a discontinuity. The relevant counters are the specific instances associated with this channel of any Counter32 object contained in apsChanStatusTable. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
apsNotificationEnable = MibScalar((1, 3, 6, 1, 2, 1, 10, 49, 1, 7), Bits().clone(namedValues=NamedValues(("switchover", 0), ("modeMismatch", 1), ("channelMismatch", 2), ("psbf", 3), ("feplf", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsNotificationEnable.setStatus('current')
if mibBuilder.loadTexts: apsNotificationEnable.setDescription('Provides the ability to enable and disable notifications defined in this MIB. switchover Indicates apsEventSwitchover notifications should be generated. modeMismatch Indicates apsEventModeMismatch notifications should be generated. channelMismatch Indicates apsEventChannelMismatch notifications should be generated. psbf Indicates apsEventPSBF notifications should be generated. feplf Indicates apsEventFEPLF notifications should be generated. ')
apsNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 49, 2, 0))
apsEventSwitchover = NotificationType((1, 3, 6, 1, 2, 1, 10, 49, 2, 0, 1)).setObjects(("APS-MIB", "apsChanStatusSwitchovers"), ("APS-MIB", "apsChanStatusCurrent"))
if mibBuilder.loadTexts: apsEventSwitchover.setStatus('current')
if mibBuilder.loadTexts: apsEventSwitchover.setDescription('An apsEventSwitchover notification is sent when the value of an instance of apsChanStatusSwitchovers increments.')
apsEventModeMismatch = NotificationType((1, 3, 6, 1, 2, 1, 10, 49, 2, 0, 2)).setObjects(("APS-MIB", "apsStatusModeMismatches"), ("APS-MIB", "apsStatusCurrent"))
if mibBuilder.loadTexts: apsEventModeMismatch.setStatus('current')
if mibBuilder.loadTexts: apsEventModeMismatch.setDescription('An apsEventModeMismatch notification is sent when the value of an instance of apsStatusModeMismatches increments.')
apsEventChannelMismatch = NotificationType((1, 3, 6, 1, 2, 1, 10, 49, 2, 0, 3)).setObjects(("APS-MIB", "apsStatusChannelMismatches"), ("APS-MIB", "apsStatusCurrent"))
if mibBuilder.loadTexts: apsEventChannelMismatch.setStatus('current')
if mibBuilder.loadTexts: apsEventChannelMismatch.setDescription('An apsEventChannelMismatch notification is sent when the value of an instance of apsStatusChannelMismatches increments.')
apsEventPSBF = NotificationType((1, 3, 6, 1, 2, 1, 10, 49, 2, 0, 4)).setObjects(("APS-MIB", "apsStatusPSBFs"), ("APS-MIB", "apsStatusCurrent"))
if mibBuilder.loadTexts: apsEventPSBF.setStatus('current')
if mibBuilder.loadTexts: apsEventPSBF.setDescription('An apsEventPSBF notification is sent when the value of an instance of apsStatusPSBFs increments.')
apsEventFEPLF = NotificationType((1, 3, 6, 1, 2, 1, 10, 49, 2, 0, 5)).setObjects(("APS-MIB", "apsStatusFEPLFs"), ("APS-MIB", "apsStatusCurrent"))
if mibBuilder.loadTexts: apsEventFEPLF.setStatus('current')
if mibBuilder.loadTexts: apsEventFEPLF.setDescription('An apsEventFEPLFs notification is sent when the value of an instance of apsStatusFEPLFs increments.')
apsGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 49, 3, 1))
apsCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 49, 3, 2))
apsFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 49, 3, 2, 1)).setObjects(("APS-MIB", "apsConfigGeneral"), ("APS-MIB", "apsStatusGeneral"), ("APS-MIB", "apsChanGeneral"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsFullCompliance = apsFullCompliance.setStatus('current')
if mibBuilder.loadTexts: apsFullCompliance.setDescription('When this MIB is implemented with support for read-create, then such an implementation can claim read/write compliance. Linear APS groups can then be both monitored and configured with this MIB. Note that An agent is not required to process SNMP Set Requests that affect multiple control objects within this MIB. This is intended to simplify the processing of Set Requests for the various control tables by eliminating the possibility that a single Set PDU will contain multiple varbinds which are in conflict. ')
apsReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 49, 3, 2, 2)).setObjects(("APS-MIB", "apsConfigGeneral"), ("APS-MIB", "apsStatusGeneral"), ("APS-MIB", "apsChanGeneral"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsReadOnlyCompliance = apsReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: apsReadOnlyCompliance.setDescription('When this MIB is implemented without support for read-create (i.e. in read-only mode), then that implementation can claim read-only compliance. In that case, linear APS groups can be monitored but cannot be configured with this MIB.')
apsConfigGeneral = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 1)).setObjects(("APS-MIB", "apsConfigMode"), ("APS-MIB", "apsConfigRevert"), ("APS-MIB", "apsConfigDirection"), ("APS-MIB", "apsConfigExtraTraffic"), ("APS-MIB", "apsConfigSdBerThreshold"), ("APS-MIB", "apsConfigSfBerThreshold"), ("APS-MIB", "apsConfigCreationTime"), ("APS-MIB", "apsConfigRowStatus"), ("APS-MIB", "apsConfigStorageType"), ("APS-MIB", "apsNotificationEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsConfigGeneral = apsConfigGeneral.setStatus('current')
if mibBuilder.loadTexts: apsConfigGeneral.setDescription('A collection of apsConfigTable objects providing configuration information applicable to all linear APS groups.')
apsConfigWtr = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 2)).setObjects(("APS-MIB", "apsConfigWaitToRestore"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsConfigWtr = apsConfigWtr.setStatus('current')
if mibBuilder.loadTexts: apsConfigWtr.setDescription('The apsConfigTable object that provides information which is applicable to groups supporting a configurable WTR period.')
apsCommandOnePlusOne = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 3)).setObjects(("APS-MIB", "apsCommandSwitch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsCommandOnePlusOne = apsCommandOnePlusOne.setStatus('current')
if mibBuilder.loadTexts: apsCommandOnePlusOne.setDescription('The apsCommandTable object which is applicable to groups implementing the linear APS 1+1 architecture. Also, set operations must be supported.')
apsCommandOneToN = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 4)).setObjects(("APS-MIB", "apsCommandSwitch"), ("APS-MIB", "apsCommandControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsCommandOneToN = apsCommandOneToN.setStatus('current')
if mibBuilder.loadTexts: apsCommandOneToN.setDescription('A collection of apsCommandTable objects which are applicable to groups implementing the linear APS 1:n architecture. Also, set operations must be supported.')
apsStatusGeneral = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 5)).setObjects(("APS-MIB", "apsStatusK1K2Rcv"), ("APS-MIB", "apsStatusK1K2Trans"), ("APS-MIB", "apsStatusCurrent"), ("APS-MIB", "apsStatusModeMismatches"), ("APS-MIB", "apsStatusChannelMismatches"), ("APS-MIB", "apsStatusPSBFs"), ("APS-MIB", "apsStatusFEPLFs"), ("APS-MIB", "apsStatusSwitchedChannel"), ("APS-MIB", "apsStatusDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsStatusGeneral = apsStatusGeneral.setStatus('current')
if mibBuilder.loadTexts: apsStatusGeneral.setDescription('A collection of apsStatusTable objects providing status information applicable to all linear APS groups.')
apsChanGeneral = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 6)).setObjects(("APS-MIB", "apsChanConfigIfIndex"), ("APS-MIB", "apsChanConfigRowStatus"), ("APS-MIB", "apsChanConfigStorageType"), ("APS-MIB", "apsChanStatusCurrent"), ("APS-MIB", "apsChanStatusSignalDegrades"), ("APS-MIB", "apsChanStatusSignalFailures"), ("APS-MIB", "apsChanStatusSwitchovers"), ("APS-MIB", "apsChanStatusLastSwitchover"), ("APS-MIB", "apsChanStatusSwitchoverSeconds"), ("APS-MIB", "apsChanStatusDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsChanGeneral = apsChanGeneral.setStatus('current')
if mibBuilder.loadTexts: apsChanGeneral.setDescription('A collection of channel objects providing information applicable to all linear APS channels.')
apsChanOneToN = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 7)).setObjects(("APS-MIB", "apsChanConfigPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsChanOneToN = apsChanOneToN.setStatus('current')
if mibBuilder.loadTexts: apsChanOneToN.setDescription('The apsChanConfigTable object that provides information which is only applicable to groups implementing the linear APS 1:n architecture.')
apsTotalsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 8)).setObjects(("APS-MIB", "apsConfigGroups"), ("APS-MIB", "apsChanLTEs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsTotalsGroup = apsTotalsGroup.setStatus('current')
if mibBuilder.loadTexts: apsTotalsGroup.setDescription('A collection of objects providing optional counts of configured APS groups and SONET LTE interfaces.')
apsMapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 9)).setObjects(("APS-MIB", "apsMapGroupName"), ("APS-MIB", "apsMapChanNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsMapGroup = apsMapGroup.setStatus('current')
if mibBuilder.loadTexts: apsMapGroup.setDescription('A collection of apsMapTable objects providing a mapping from sonet(39) InterfaceIndex to group name and channel number for assigned APS channels and a list of unassigned sonet(39) interfaces.')
apsEventGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 49, 3, 1, 10)).setObjects(("APS-MIB", "apsEventSwitchover"), ("APS-MIB", "apsEventModeMismatch"), ("APS-MIB", "apsEventChannelMismatch"), ("APS-MIB", "apsEventPSBF"), ("APS-MIB", "apsEventFEPLF"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apsEventGroup = apsEventGroup.setStatus('current')
if mibBuilder.loadTexts: apsEventGroup.setDescription('A collection of SONET linear APS notifications.')
mibBuilder.exportSymbols("APS-MIB", apsChanStatusSwitchovers=apsChanStatusSwitchovers, apsEventSwitchover=apsEventSwitchover, apsConfigGeneral=apsConfigGeneral, apsNotificationsPrefix=apsNotificationsPrefix, apsStatusEntry=apsStatusEntry, apsConfigStorageType=apsConfigStorageType, apsStatusK1K2Trans=apsStatusK1K2Trans, apsEventChannelMismatch=apsEventChannelMismatch, apsGroups=apsGroups, apsConfigSdBerThreshold=apsConfigSdBerThreshold, apsMapGroupName=apsMapGroupName, apsMIB=apsMIB, apsConfigRowStatus=apsConfigRowStatus, apsStatusTable=apsStatusTable, apsEventPSBF=apsEventPSBF, apsChanStatusTable=apsChanStatusTable, ApsSwitchCommand=ApsSwitchCommand, PYSNMP_MODULE_ID=apsMIB, apsChanConfigTable=apsChanConfigTable, apsEventFEPLF=apsEventFEPLF, apsCommandSwitch=apsCommandSwitch, apsChanConfigEntry=apsChanConfigEntry, apsConfigDirection=apsConfigDirection, apsMIBObjects=apsMIBObjects, apsChanStatusSignalFailures=apsChanStatusSignalFailures, apsCommandEntry=apsCommandEntry, apsChanConfigIfIndex=apsChanConfigIfIndex, apsMIBNotifications=apsMIBNotifications, apsStatusModeMismatches=apsStatusModeMismatches, apsConfigSfBerThreshold=apsConfigSfBerThreshold, apsCommandOnePlusOne=apsCommandOnePlusOne, apsCommandOneToN=apsCommandOneToN, apsConfigGroups=apsConfigGroups, apsEventGroup=apsEventGroup, apsChanConfigPriority=apsChanConfigPriority, apsConfigTable=apsConfigTable, apsCommandControl=apsCommandControl, apsStatusDiscontinuityTime=apsStatusDiscontinuityTime, apsCompliances=apsCompliances, apsTotalsGroup=apsTotalsGroup, apsStatusSwitchedChannel=apsStatusSwitchedChannel, apsStatusPSBFs=apsStatusPSBFs, apsChanStatusSwitchoverSeconds=apsChanStatusSwitchoverSeconds, apsChanLTEs=apsChanLTEs, apsReadOnlyCompliance=apsReadOnlyCompliance, apsChanStatusEntry=apsChanStatusEntry, apsChanStatusCurrent=apsChanStatusCurrent, apsChanStatusDiscontinuityTime=apsChanStatusDiscontinuityTime, apsConfigName=apsConfigName, apsConfig=apsConfig, apsChanConfigNumber=apsChanConfigNumber, apsMIBConformance=apsMIBConformance, apsMapChanNumber=apsMapChanNumber, apsChanConfigRowStatus=apsChanConfigRowStatus, apsConfigEntry=apsConfigEntry, apsChanStatusLastSwitchover=apsChanStatusLastSwitchover, apsStatusFEPLFs=apsStatusFEPLFs, ApsControlCommand=ApsControlCommand, apsStatusCurrent=apsStatusCurrent, apsConfigWtr=apsConfigWtr, apsStatusGeneral=apsStatusGeneral, apsChanGeneral=apsChanGeneral, apsMapGroup=apsMapGroup, apsChanOneToN=apsChanOneToN, apsConfigRevert=apsConfigRevert, apsChanStatusSignalDegrades=apsChanStatusSignalDegrades, apsNotificationEnable=apsNotificationEnable, apsConfigCreationTime=apsConfigCreationTime, apsConfigExtraTraffic=apsConfigExtraTraffic, apsStatusChannelMismatches=apsStatusChannelMismatches, apsCommandTable=apsCommandTable, apsMap=apsMap, apsMapEntry=apsMapEntry, apsChanConfigGroupName=apsChanConfigGroupName, apsChanConfigStorageType=apsChanConfigStorageType, apsFullCompliance=apsFullCompliance, apsConfigWaitToRestore=apsConfigWaitToRestore, apsMapTable=apsMapTable, apsEventModeMismatch=apsEventModeMismatch, apsStatusK1K2Rcv=apsStatusK1K2Rcv, ApsK1K2=ApsK1K2, apsConfigMode=apsConfigMode)

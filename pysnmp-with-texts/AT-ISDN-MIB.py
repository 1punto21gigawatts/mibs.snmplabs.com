#
# PySNMP MIB module AT-ISDN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AT-ISDN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:30:17 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint")
DisplayStringUnsized, modules = mibBuilder.importSymbols("AT-SMI-MIB", "DisplayStringUnsized", "modules")
ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, Integer32, Bits, TimeTicks, ObjectIdentity, IpAddress, NotificationType, iso, ModuleIdentity, Counter64, Gauge32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Integer32", "Bits", "TimeTicks", "ObjectIdentity", "IpAddress", "NotificationType", "iso", "ModuleIdentity", "Counter64", "Gauge32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32")
DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention")
cc = ModuleIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37))
cc.setRevisions(('2006-06-28 12:22',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cc.setRevisionsDescriptions(('Initial Revision',))
if mibBuilder.loadTexts: cc.setLastUpdated('200606281222Z')
if mibBuilder.loadTexts: cc.setOrganization('Allied Telesis, Inc')
if mibBuilder.loadTexts: cc.setContactInfo('http://www.alliedtelesis.com')
if mibBuilder.loadTexts: cc.setDescription('This MIB file contains definitions of managed objects for the CC module. ')
ccDetailsTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1), )
if mibBuilder.loadTexts: ccDetailsTable.setStatus('current')
if mibBuilder.loadTexts: ccDetailsTable.setDescription('The table of call details parameters.')
ccDetailsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1), ).setIndexNames((0, "AT-ISDN-MIB", "ccDetailsIndex"))
if mibBuilder.loadTexts: ccDetailsEntry.setStatus('current')
if mibBuilder.loadTexts: ccDetailsEntry.setDescription('A single entry of ISDN call details. This contains the parameters of a single ISDN call details.')
ccDetailsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccDetailsIndex.setStatus('current')
if mibBuilder.loadTexts: ccDetailsIndex.setDescription('The index of the call details entry in the call details table. When an entry is created in this table, the index does not have to be written. However, to reference the values that are written, an unused index must be found by reading the index values of the table until a no such object error is returned. Attempting to create a row by using an already used index will result in simply changing the parameters of an existing call details entry.')
ccDetailsName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 2), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsName.setStatus('current')
if mibBuilder.loadTexts: ccDetailsName.setDescription("The name of the ISDN call details. This must be unique for all ISDN call details, when comparisons are done ignoring the case of letters. Valid characters in the ISDN call name include 0-9, a-z, A-Z and '-'. A name consisting of all digits is not valid. Setting this object is current on row creation. However, this object cannot be set for an existing call. This is because for the command line interface calls are identified by name. There is one exception. Setting ccDetailsName to an empty string will cause the call details to be deleted.")
ccDetailsRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 3), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRemoteName.setStatus('current')
if mibBuilder.loadTexts: ccDetailsRemoteName.setDescription("The remote ISDN call name. This name can be referenced by certain other call details parameters related with setting up the Q.931 SETUP message for outgoing calls, or searching for calls for incoming calls. Valid characters in the ISDN remote call name include 0-9, a-z, A-Z and '-'. A remote name consisting of all digits is valid.")
ccDetailsCalledNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 4), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsCalledNumber.setStatus('current')
if mibBuilder.loadTexts: ccDetailsCalledNumber.setDescription('The number called when this call details is activated. The number should include all telephone network access codes, country codes and area codes required to make a call from the particular ISDN interface. Setting this object is current on row creation.')
ccDetailsCallingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 5), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsCallingNumber.setStatus('current')
if mibBuilder.loadTexts: ccDetailsCallingNumber.setDescription('The number used as the calling number when this call is activated. The calling number can optionally be placed in the outgoing SETUP message.')
ccDetailsAlternateNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 6), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsAlternateNumber.setStatus('current')
if mibBuilder.loadTexts: ccDetailsAlternateNumber.setDescription('The number called when all retries with the main called number have failed. In this event, the router tries once with the alternate number, then checks the ccDetailsKeepup object to determine whether to try again with the main number.')
ccDetailsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsEnabled.setStatus('current')
if mibBuilder.loadTexts: ccDetailsEnabled.setDescription('Whether this ISDN call is enabled or disabled for incoming and outgoing calls. If the call details entry is disabled, all existing active calls based on this call details entry are left active.')
ccDetailsDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inOnly", 1), ("outOnly", 2), ("both", 3))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsDirection.setStatus('current')
if mibBuilder.loadTexts: ccDetailsDirection.setDescription('The direction for which calls may be made or received using this call details entry.')
ccDetailsPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in", 1), ("out", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPrecedence.setStatus('current')
if mibBuilder.loadTexts: ccDetailsPrecedence.setDescription('The precedence of this call details entry in the event of call collision. Call collision occurs when an incoming call for a given details entry is detected while an outgoing call is waiting to complete. This object configures whether the router treats the incoming or outgoing call as having precedence. Since the device at the other end will also probably be experiencing a call collision, the precedence should be configured to the opposite value at the other end. Setting this object is current on row creation.')
ccDetailsHoldupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsHoldupTime.setStatus('current')
if mibBuilder.loadTexts: ccDetailsHoldupTime.setDescription('The time, in seconds, that active calls created from this call details should be held up after initial activation. The call will be held up for at least this time, unless cleared from the network. Thus, for example, PPP idle timeouts will not bring the call down.')
ccDetailsPreferredIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 11), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPreferredIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccDetailsPreferredIfIndex.setDescription('The ifIndex of an ISDN interface on this router which is the preferred ISDN interface on which to make an outgoing call using this call details entry. The ifIndex, if not 0, should reference the ifEntry which contains information about the entire ISDN interface, at the lowest layer. If a channel is not available on this interface, the call can try other interfaces in order to make the call. This object is not used on incoming calls. If the value of this object is set to 0, no interface will be preferred over any other. If the value of this object does not reference the ifEntry for the entire ISDN interface, no interface will be preferred.')
ccDetailsRequiredIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 12), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRequiredIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccDetailsRequiredIfIndex.setDescription('The ifIndex of an ISDN interface on this router which is the required ISDN interface on which to make an outgoing call using this call details entry. The ifIndex, if not 0, must reference the ifEntry which contains information about the entire ISDN interface, at the lowest layer. If a channel is not available on this interface, the call fails. This object is not used on incoming calls. If the value of this object is set to 0, no interface will be required. If the value of this object does not reference the ifEntry for the entire ISDN interface, no interface will be required.')
ccDetailsPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPriority.setStatus('current')
if mibBuilder.loadTexts: ccDetailsPriority.setDescription('The priority of calls generated from this call details entry. The priority determines whether calls can be bumped for higher priority calls. The value of priority falls into ranges: 0-19 - call bumped by incoming or outgoing, voice or data calls 20-39 - call bumped by outgoing voice and incoming or outgoing data calls 40-59 - call bumped by emergency voice calls or incoming or outgoing data calls 60-99 - call bumped by emergency voice calls or outgoing data calls. Note that when the call is bumped by a data call, the data call must have higher priority than the call being bumped.')
ccDetailsRetryT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 120)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRetryT1.setStatus('current')
if mibBuilder.loadTexts: ccDetailsRetryT1.setDescription('The time in seconds between retries of calls generated from this call details entry.')
ccDetailsRetryN1 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRetryN1.setStatus('current')
if mibBuilder.loadTexts: ccDetailsRetryN1.setDescription('The number of retries in a retry group for calls generated from this call details entry. Note that the default value means that by default the call will not be retried.')
ccDetailsRetryT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 1200)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRetryT2.setStatus('current')
if mibBuilder.loadTexts: ccDetailsRetryT2.setDescription('The time in seconds between retry groups for retries of calls generated from this call details entry.')
ccDetailsRetryN2 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRetryN2.setStatus('current')
if mibBuilder.loadTexts: ccDetailsRetryN2.setDescription('The number of retry groups for calls generated from this call details entry. Note that the default value means that by default no retry groups will be attempted.')
ccDetailsKeepup = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsKeepup.setStatus('current')
if mibBuilder.loadTexts: ccDetailsKeepup.setDescription("A flag indicating whether calls generated from this call details entry should be kept up always. Inspection of this flag takes place when a call is cleared from an external source. If set to 'yes', the call will be retried.")
ccDetailsOutSetupCli = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("calling", 2), ("interface", 3), ("nonumber", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsOutSetupCli.setStatus('current')
if mibBuilder.loadTexts: ccDetailsOutSetupCli.setDescription("The CLI information placed into outgoing SETUP messages when this call details is used to generate an outgoing call. The value 'off' means that no CLI information in placed in the SETUP message. The value 'calling' means that the calling number from the call details entry is placed in the SETUP message. The value 'interface' means that the Q.931 interface number for the interface and DLC on which the call is made is placed in the SETUP message. The value 'nonumber' means that the CLI information element is placed in the SETUP message with no number information. The network will fill the number in.")
ccDetailsOutSetupUser = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsOutSetupUser.setStatus('current')
if mibBuilder.loadTexts: ccDetailsOutSetupUser.setDescription("The user-user information placed into outgoing SETUP messages when this call details is used to generate an outgoing call. The value 'off' means that no user-user information in placed in the SETUP message. The value 'local' means that the call name from the call details entry is placed in the SETUP message. The value 'remote' means that the remote call name from the call details entry is placed in the SETUP message.")
ccDetailsOutSetupCalledSub = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsOutSetupCalledSub.setStatus('current')
if mibBuilder.loadTexts: ccDetailsOutSetupCalledSub.setDescription("The called subaddress information placed into outgoing SETUP messages when this call details is used to generate an outgoing call. The value 'off' means that no called subaddress information in placed in the SETUP message. The value 'local' means that the call name from the call details entry is placed in the SETUP message. The value 'remote' means that the remote call name from the call details entry is placed in the SETUP message. Note that the action of this object is overridden by the value of the object ccDetailsOutSubaddress.")
ccDetailsOutSubaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 22), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsOutSubaddress.setStatus('current')
if mibBuilder.loadTexts: ccDetailsOutSubaddress.setDescription('This object gives a way to override the called subaddress information placed into outgoing SETUP messages when this call details is used to generate an outgoing call, as given by the ccDetailsOutSetupCalledSub object. The object is an arbitrary string of ASCII characters, from 0 to 31 characters long.')
ccDetailsCallback = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsCallback.setStatus('current')
if mibBuilder.loadTexts: ccDetailsCallback.setDescription("A flag indicating whether or not to call back the caller when an incoming call is generated from this call details entry. If set to 'yes', the incoming call will be cleared, and after a short delay, an outgoing call will be activated for this call details entry.")
ccDetailsCallbackDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(41)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsCallbackDelay.setStatus('current')
if mibBuilder.loadTexts: ccDetailsCallbackDelay.setDescription('The time, in tenths of a second, which the router will wait after clearing an incoming call whose call details entry specified that the caller should be called back before making the return call. The purpose of this object is to allow the user to specify a delay in callback which will allow the network to properly clear the call at both this end and the remote end.')
ccDetailsInSetupCalledSubSearch = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCalledSubSearch.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInSetupCalledSubSearch.setDescription("Determines whether this call details entry is used in a search of call details for an incoming call based on the contents of the called subaddress information in the incoming SETUP message. The value 'off' means that this call details entry is not used in the search. The value 'local' means that the call details entry is used in the search and the called subaddress information is compared with the call details entry name. The value 'remote' means that the call details entry is used in the search and the called subaddress information is compared with the call details entry remote name. A number of searches are carried out until a matching call is found. First a search against the called subaddress in the SETUP message, then a search against the user-user information in the SETUP message, then a search against the calling number information in the SETUP message, then a search for any call that is configured to respond to any incoming call.")
ccDetailsInSetupUserSearch = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupUserSearch.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInSetupUserSearch.setDescription("Determines whether this call details entry is used in a search of call details for an incoming call based on the contents of the user-user information in the incoming SETUP message. The value 'off' means that this call details entry is not used in the search. The value 'local' means that the call details entry is used in the search and the user-user information is compared with the call details entry name. The value 'remote' means that the call details entry is used in the search and the user-user information is compared with the call details entry remote name. A number of searches are carried out until a matching call is found. First a search against the called subaddress in the SETUP message, then a search against the user-user information in the SETUP message, then a search against the calling number information in the SETUP message, then a search for any call that is configured to respond to any incoming call.")
ccDetailsInSetupCliSearch = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("list", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCliSearch.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInSetupCliSearch.setDescription("Determines whether this call details entry is used in a search of call details for an incoming call based on the contents of the calling number information in the incoming SETUP message. The value 'off' means that this call details entry is not used in the search. The value 'on' means that the call details entry is used in the search and the calling number information is compared with the call details entry called number. The value 'list' means that the call details entry is used in the search and the calling number information is compared with the numbers on the CLI list reference by the object ccDetailsInSetupCliSearchList. The value 'list' cannot be set by an SNMP management entity. Rather the ccDetailsInSetupCliSearchList object should be set to a non-zero value, which will automatically set this object to 'list'. A number of searches are carried out until a matching call is found. First a search against the called subaddress in the SETUP message, then a search against the user-user information in the SETUP message, then a search against the calling number information in the SETUP message, then a search for any call that is configured to respond to any incoming call.")
ccDetailsInSetupCliSearchList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCliSearchList.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInSetupCliSearchList.setDescription("If the ccDetailsInSetupCliSearch object is set to 'list', this object gives the index of the CLI list to search. The value of CLI list indices is 1..100. The value 0 is returned when the ccDetailsInSetupCliSearch object is not set to 'list'. If the value of this object is set to 0 via SNMP, then the ccDetailsInSetupCliSearch object will be internally set to 'off'. Subsequently setting the value of this object to a non-zero value will set the ccDetailsInSetupCliSearch object to 'list'. Note that when using the command line interface, CLI list indices range from 0 to 99, but when using SNMP they range from 1 to 100. This is because SNMP will not allow a table index to have the value 0, and the command line usage of indices from 0 to 99 is too well established to change.")
ccDetailsInAnyFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInAnyFlag.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInAnyFlag.setDescription("Determines whether this call details entry will match any incoming call. After all searched for incoming calls have been carried out based on called subaddress, user-user information and calling number, a search is carried out for the first call found with this flag set to 'yes'.")
ccDetailsInSetupCalledSubCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCalledSubCheck.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInSetupCalledSubCheck.setDescription("Determines whether to perform a check when an incoming call matches this call details entry based on the contents of the called subaddress information in the incoming SETUP message. The value 'off' means that the check is not carried out. The value 'local' means that the check is carried out and the called subaddress information is compared with the call details entry name. The value 'remote' means that the check is carried out and the called subaddress information is compared with the call details entry remote name. A number of checks are optionally carried out once a matching call is found. The first check is against the called subaddress in the SETUP message, then against the user-user information in the SETUP message, then against the calling number information in the SETUP message.")
ccDetailsInSetupUserCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupUserCheck.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInSetupUserCheck.setDescription("Determines whether to perform a check when an incoming call matches this call details entry based on the contents of the user-user information in the incoming SETUP message. The value 'off' means that the check is not carried out. The value 'local' means that the check is carried out and the user-user information is compared with the call details entry name. The value 'remote' means that the check is carried out and the user-user information is compared with the call details entry remote name. A number of checks are optionally carried out once a matching call is found. The first check is against the called subaddress in the SETUP message, then against the user-user information in the SETUP message, then against the calling number information in the SETUP message.")
ccDetailsInSetupCliCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("present", 2), ("required", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCliCheck.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInSetupCliCheck.setDescription("Determines whether to perform a check and which check to perform when an incoming call matches this call details entry based on the contents of the calling number information in the incoming SETUP message. The value 'off' means that the check is not carried out. The value 'present' means that the check is carried out only if calling number information is present. The value 'required' means that the calling number must be present for the check to pass. When the check is carried out, the calling number information is compared with the numbers in the CLI list referenced by the object ccDetailsInSetupCliCheckList. A number of checks are optionally carried out once a matching call is found. The first check is against the called subaddress in the SETUP message, then against the user-user information in the SETUP message, then against the calling number information in the SETUP message.")
ccDetailsInSetupCliCheckList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCliCheckList.setStatus('current')
if mibBuilder.loadTexts: ccDetailsInSetupCliCheckList.setDescription("If the ccDetailsInSetupCliCheck object is set to 'present' or 'required', this object gives the index of the CLI list to check against. The value of CLI list indices is 1..100. The value 0 means that no list to check against is defined and the check immediately fails. Note that when using the command line interface, CLI list indices range from 0 to 99, but when using SNMP they range from 1 to 100. This is because SNMP will not allow a table index to have the value 0, and the command line usage of indices from 0 to 99 is too well established to change.")
ccDetailsUserType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("attach", 1), ("ppp", 2))).clone('attach')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsUserType.setStatus('current')
if mibBuilder.loadTexts: ccDetailsUserType.setDescription("The type of user of this call. The value 'attach' means that users have to attach to this call before the call can be used for outgoing or incoming calls. The value 'ppp' means that for incoming calls only dynamic PPP interfaces will be created whenever this call details entry is matched.")
ccDetailsLoginType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("userdb", 2), ("radius", 3), ("papTacacs", 4), ("chap", 5), ("papRadius", 6), ("tacacs", 7), ("all", 8))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsLoginType.setStatus('current')
if mibBuilder.loadTexts: ccDetailsLoginType.setDescription("The type of login for calls generated using this call details entry, for incoming calls only. Incoming calls can be configured to go through a logging in phase before the call is brought up. This object defines which login types are used. The value 'none' means don't do a login phase. The value 'userdb' means use the user database on the router to check login parameters. The value 'radius' means use the router's configured RADIUS servers to check the login parameters. The values 'pap-tacacs', 'chap' and 'pap-radius' apply only when the user is 'ppp' and determine how the dynamic PPP interface are configured for authentication. The value 'pap-tacacs' means use PAP to authenticate and use the TACACS server to check the login parameters. The value 'pap-radius' means use PAP to authenticate and use the RADIUS server to check the login parameters. The value 'chap' means use CHAP to authenticate. The value 'tacacs' means use the TACACS server to check login parameters. The value 'all' means use the user database, TACACS and RADIUS to check the login parameters. The login parameters for values 'userdb', 'radius', 'tacacs' and 'all' are determined by the ccDetailsUsername and ccDetailsPassword objects.")
ccDetailsUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("cli", 2), ("calledsub", 3), ("useruser", 4), ("callname", 5))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsUsername.setStatus('current')
if mibBuilder.loadTexts: ccDetailsUsername.setDescription("The source of the username when the ccDetailsLoginType object has a value of 'userdb', 'radius', 'tacacs' or 'all'. The value 'none' means no username is defined. The value 'cli' means take the username from the calling number information in the SETUP message. The value 'calledsub' means take the username from the called subaddress information in the SETUP message. The value 'useruser' means take the username from the user-user information in the SETUP message. The value 'callname' means take the username from the call details entry name.")
ccDetailsPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("cli", 2), ("calledsub", 3), ("useruser", 4), ("callname", 5))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPassword.setStatus('current')
if mibBuilder.loadTexts: ccDetailsPassword.setDescription("The source of the password when the ccDetailsLoginType object has a value of 'userdb', 'radius', 'tacacs' or 'all'. The value 'none' means no password is defined. The value 'cli' means take the password from the calling number information in the SETUP message. The value 'calledsub' means take the password from the called subaddress information in the SETUP message. The value 'useruser' means take the password from the user-user information in the SETUP message. The value 'callname' means take the password from the call details entry name.")
ccDetailsBumpDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsBumpDelay.setStatus('current')
if mibBuilder.loadTexts: ccDetailsBumpDelay.setDescription('The time, in tenths of a second, which the router will wait after clearing an existing call which has been bumped to make way for a call based on this call details entry.')
ccDetailsDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rate-64k", 1), ("rate-56k", 2))).clone('rate-64k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsDataRate.setStatus('current')
if mibBuilder.loadTexts: ccDetailsDataRate.setDescription('The data rate to use for active calls based on this call details entry. The actual data rate for outgoing calls is determined by both this object and the data rate parameter for the Q.931 interface chosen for the call. If either this object or the interface object specify a rate of 56k, then 56k will be the rate for the call. Otherwise, the default rate of 64k will be used. This allows interoperability between ISDNs which only allow 56k of data on a B channel.')
ccDetailsPppTemplate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 33)).clone(33)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPppTemplate.setStatus('current')
if mibBuilder.loadTexts: ccDetailsPppTemplate.setDescription('The PPP template to use when creating dynamic PPP interfaces for calls generated from this call details entry. The value 33 represents a default PPP template, the values 1 to 32 represent PPP templates that are currently defined in the router. Note that when using the command line interface, PPP template indices range from 0 to 31, but when using SNMP they range from 1 to 32. This is because SNMP will not allow a table index to have the value 0. While there is no PPP template table accessible via SNMP, if there was, the indices of the table would have to range from 1 to 32.')
ccDetailsUserModule = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccDetailsUserModule.setStatus('current')
if mibBuilder.loadTexts: ccDetailsUserModule.setDescription('The module ID of the user module currently attached to this ISDN call details entry.')
ccDetailsNumberAttachments = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccDetailsNumberAttachments.setStatus('current')
if mibBuilder.loadTexts: ccDetailsNumberAttachments.setDescription('The number of attachments from the user module currently attached to this call details entry. The ccAttachmentsTable gives the actual attachments for each call details entry.')
ccCliListTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2), )
if mibBuilder.loadTexts: ccCliListTable.setStatus('current')
if mibBuilder.loadTexts: ccCliListTable.setDescription('The table of CLI list entries.')
ccCliListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2, 1), ).setIndexNames((0, "AT-ISDN-MIB", "ccCliListListIndex"), (0, "AT-ISDN-MIB", "ccCliListEntryIndex"))
if mibBuilder.loadTexts: ccCliListEntry.setStatus('current')
if mibBuilder.loadTexts: ccCliListEntry.setDescription('A single entry in the CLI list table. This contains a single number, as well as index information.')
ccCliListListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCliListListIndex.setStatus('current')
if mibBuilder.loadTexts: ccCliListListIndex.setDescription('The index of the CLI list. CLI lists from 1 to 100 are defined in the router.')
ccCliListEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCliListEntryIndex.setStatus('current')
if mibBuilder.loadTexts: ccCliListEntryIndex.setDescription('The index of the CLI list entry within the CLI list. The minimum CLI list entry is 1. CLI lists are unlimited in length, although internal memory requirements could result in failure to create a given entry. When creating a row in this table, the entry index should be set to index the first empty row. Only one CLI list row in a given list should be created in any one SNMP message. Attempting to create more than one row will result in failure.')
ccCliListNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2, 1, 3), DisplayStringUnsized().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCliListNumber.setStatus('current')
if mibBuilder.loadTexts: ccCliListNumber.setDescription('The number for this CLI list entry. Setting the number to a zero length string removes the entry from the CLI list, with consequent reshuffling of CLI entry indices. Thus the easiest way to delete an entire CLI list is to repeatedly set the first element in the list to a zero length string. A failure to SET will occur when this is attempted on an empty list.')
ccActiveCallTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3), )
if mibBuilder.loadTexts: ccActiveCallTable.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallTable.setDescription('The table of ISDN active calls.')
ccActiveCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1), ).setIndexNames((0, "AT-ISDN-MIB", "ccActiveCallIndex"))
if mibBuilder.loadTexts: ccActiveCallEntry.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallEntry.setDescription('A single entry in the active call table.')
ccActiveCallIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallIndex.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallIndex.setDescription('The index of the active call. There are 128 possible active calls in the router simultaneously.')
ccActiveCallDetailsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallDetailsIndex.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallDetailsIndex.setDescription('The index of the call details entry which generated this active call. Thus the index into the ccDetailsTable for this call.')
ccActiveCallIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallIfIndex.setDescription("The interface index of the interface on which this active call is being made or received. A value of zero indicates that the active has not yet had an interface assigned to it. The ifEntry indexed by this object is the ifEntry for the entire ISDN interface, not the ifEntry for the active call's B channel.")
ccActiveCallDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rate-64k", 1), ("rate-56k", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallDataRate.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallDataRate.setDescription('The data rate in use for this active call. This is determined by the call details setting of data rate, the ISDN interface setting for data rate, and the contents of the bearer capability information in the incoming SETUP message.')
ccActiveCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("null", 1), ("off", 2), ("try", 3), ("on", 4), ("wait", 5), ("await1", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallState.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallState.setDescription("The state of this active call. The value 'null' indicates that this active call does not actually exist, in other words it is in the process of being created or destroyed. The value 'off' means that the active call is just being activated. The value 'try' means that the active call is attempting to establish. The value 'on' means that the active call is established. The value 'wait' means that the active call is waiting to retry. The value 'await1' means that the active call is waiting for authentication to succeed before becoming established.")
ccActiveCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("undefined", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallDirection.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallDirection.setDescription("The direction of this active call. The value 'in' indicates that this active call is an incoming call, the value 'out' indicates that the active call is an outgoing call. The value 'undefined' indicates that the active call has just been created and a direction has not been assigned to it yet.")
ccActiveCallUserModule = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallUserModule.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallUserModule.setDescription('The module ID of the user module attached to this ISDN active call.')
ccActiveCallUserInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallUserInstance.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallUserInstance.setDescription('The instance of the user module attached to this ISDN active call.')
ccActiveCallBchannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallBchannelIndex.setStatus('current')
if mibBuilder.loadTexts: ccActiveCallBchannelIndex.setDescription("The B channel number for this active entry. BRI interfaces have B channels in the range 1..2, PRI interfaces have B channels in the range 1..31, excluding a channel which is the D channel. A value of 0 for this entry means that either a B channel is not currently allocated for this call, or that more than one B channel is allocated. In the second case, the management client will have to walk the B channel allocation table looking for channels with the same active call index as this call's.")
ccCallLogTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4), )
if mibBuilder.loadTexts: ccCallLogTable.setStatus('current')
if mibBuilder.loadTexts: ccCallLogTable.setDescription('The table of ISDN call log entries.')
ccCallLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1), ).setIndexNames((0, "AT-ISDN-MIB", "ccCallLogIndex"))
if mibBuilder.loadTexts: ccCallLogEntry.setStatus('current')
if mibBuilder.loadTexts: ccCallLogEntry.setDescription('A single entry in the ISDN call log table.')
ccCallLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogIndex.setStatus('current')
if mibBuilder.loadTexts: ccCallLogIndex.setDescription('The index of the call log entry. Since the call log table is dynamic, there is no guarantee that this index will continue to refer to the same log entry over time.')
ccCallLogName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogName.setStatus('current')
if mibBuilder.loadTexts: ccCallLogName.setDescription('The name of the call details entry which generated the active call for which this is the log entry.')
ccCallLogState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("initial", 1), ("active", 2), ("disconnected", 3), ("cleared", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogState.setStatus('current')
if mibBuilder.loadTexts: ccCallLogState.setDescription("The state of the log entry. The value 'initial' means that the call is being established. The value 'active' means that the call is currently established. The value 'disconnected' means that the call was disconnected after being established for some time. The value 'cleared' means that the call was cleared abormally while in the establishment phase.")
ccCallLogTimeStarted = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogTimeStarted.setStatus('current')
if mibBuilder.loadTexts: ccCallLogTimeStarted.setDescription("A string in the format 'dd-mmm-yyyy hh:mm:ss' which gives the start time of the call for which this is the log entry. If the call never reached or has not yet reached the active state, this object will be a zero-length string.")
ccCallLogDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in", 1), ("out", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogDirection.setStatus('current')
if mibBuilder.loadTexts: ccCallLogDirection.setDescription('The direction of the call for which this is the log entry.')
ccCallLogDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogDuration.setStatus('current')
if mibBuilder.loadTexts: ccCallLogDuration.setDescription('The duration in seconds, of the call for which this is the log entry. A value of 0 in this field means either that the call has just started, that the call was cleared before becoming established, or that the call is still active. In other words, a non-zero value is present in this object only for calls which reach establishment and have since been cleared.')
ccCallLogRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogRemoteNumber.setStatus('current')
if mibBuilder.loadTexts: ccCallLogRemoteNumber.setDescription('For incoming calls, the calling number, if this was made available in the SETUP message. For outgoing calls, the number dialed. If the number was not available, this object is a zero length string.')
ccAttachmentTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5), )
if mibBuilder.loadTexts: ccAttachmentTable.setStatus('current')
if mibBuilder.loadTexts: ccAttachmentTable.setDescription('The table of call detail attachment entries.')
ccAttachmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1), ).setIndexNames((0, "AT-ISDN-MIB", "ccAttachmentDetailsIndex"), (0, "AT-ISDN-MIB", "ccAttachmentEntryIndex"))
if mibBuilder.loadTexts: ccAttachmentEntry.setStatus('current')
if mibBuilder.loadTexts: ccAttachmentEntry.setDescription('A single entry in the attachment table.')
ccAttachmentDetailsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAttachmentDetailsIndex.setStatus('current')
if mibBuilder.loadTexts: ccAttachmentDetailsIndex.setDescription('The index of the call details entry to which this attachment entry belongs.')
ccAttachmentEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAttachmentEntryIndex.setStatus('current')
if mibBuilder.loadTexts: ccAttachmentEntryIndex.setDescription('The index of the attachment entry within the attachment list.')
ccAttachmentActiveCallIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAttachmentActiveCallIndex.setStatus('current')
if mibBuilder.loadTexts: ccAttachmentActiveCallIndex.setDescription('The index of the active call for this attachment. A value of 0 indicates that there is currently no active call for this attachment. A value of 1 to 128 references the active call currently in place for this attachment.')
ccAttachmentUserInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAttachmentUserInstance.setStatus('current')
if mibBuilder.loadTexts: ccAttachmentUserInstance.setDescription('The instance of the user module attached to the ISDN active call for this attachment. This object should return the same value as the object ccActiveCallUserInstance for the active call indexed by ccAttachmentActiveCallIndex, if this is not 0.')
ccBchannelTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6), )
if mibBuilder.loadTexts: ccBchannelTable.setStatus('current')
if mibBuilder.loadTexts: ccBchannelTable.setDescription('The table of B channel attachment entries.')
ccBchannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1), ).setIndexNames((0, "AT-ISDN-MIB", "ccBchannelIfIndex"), (0, "AT-ISDN-MIB", "ccBchannelChannelIndex"))
if mibBuilder.loadTexts: ccBchannelEntry.setStatus('current')
if mibBuilder.loadTexts: ccBchannelEntry.setDescription('A single entry in the B channel attachment table.')
ccBchannelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccBchannelIfIndex.setDescription("The interface index of the interface which this B channel entry is on. The ifEntry indexed by this object is the ifEntry for the entire ISDN interface, not the ifEntry for the active call's B channel.")
ccBchannelChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelChannelIndex.setStatus('current')
if mibBuilder.loadTexts: ccBchannelChannelIndex.setDescription('The B channel number for this B channel entry. BRI interfaces have B channels in the range 1..2, PRI interfaces have B channels in the range 1..31, excluding a channel which is the D channel.')
ccBchannelAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelAllocated.setStatus('current')
if mibBuilder.loadTexts: ccBchannelAllocated.setDescription('A flag indicating whether this B channel is actually allocated to a call or not.')
ccBchannelCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 1), ("data", 2), ("voice", 3), ("x25", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelCallType.setStatus('current')
if mibBuilder.loadTexts: ccBchannelCallType.setDescription('The type of call on this B channel. If the B channel is not allocated, the call type will be undefined.')
ccBchannelActiveCallIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelActiveCallIndex.setStatus('current')
if mibBuilder.loadTexts: ccBchannelActiveCallIndex.setDescription('The index of the active call which is currently attached to this B channel. If the value of this object is 0 the channel is either not allocated, or is not allocated to a data call.')
ccBchannelPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelPriority.setStatus('current')
if mibBuilder.loadTexts: ccBchannelPriority.setDescription('The priority of the call which has this B channel allocated to it. This is in the range 0..99 for data calls, 150 for voice calls and 200 for emergency voice calls. A B channel which is not allocated will have a priority of 0.')
ccBchannelDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("unallocated", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelDirection.setStatus('current')
if mibBuilder.loadTexts: ccBchannelDirection.setDescription("The direction of the call which has this B channel allocated to it. If this B channel is not allocated the value will be 'unallocated'.")
mibBuilder.exportSymbols("AT-ISDN-MIB", ccDetailsCallingNumber=ccDetailsCallingNumber, ccDetailsInSetupUserSearch=ccDetailsInSetupUserSearch, ccDetailsRetryT1=ccDetailsRetryT1, ccAttachmentEntry=ccAttachmentEntry, ccDetailsRequiredIfIndex=ccDetailsRequiredIfIndex, ccAttachmentUserInstance=ccAttachmentUserInstance, ccDetailsUserModule=ccDetailsUserModule, ccDetailsOutSubaddress=ccDetailsOutSubaddress, ccActiveCallIfIndex=ccActiveCallIfIndex, ccCallLogRemoteNumber=ccCallLogRemoteNumber, ccActiveCallBchannelIndex=ccActiveCallBchannelIndex, ccDetailsInSetupCalledSubSearch=ccDetailsInSetupCalledSubSearch, ccDetailsRemoteName=ccDetailsRemoteName, ccDetailsCalledNumber=ccDetailsCalledNumber, ccDetailsCallbackDelay=ccDetailsCallbackDelay, ccAttachmentEntryIndex=ccAttachmentEntryIndex, ccDetailsEntry=ccDetailsEntry, ccDetailsUsername=ccDetailsUsername, ccDetailsOutSetupCli=ccDetailsOutSetupCli, ccDetailsDirection=ccDetailsDirection, ccDetailsTable=ccDetailsTable, ccDetailsPreferredIfIndex=ccDetailsPreferredIfIndex, ccDetailsInSetupCliCheckList=ccDetailsInSetupCliCheckList, ccDetailsCallback=ccDetailsCallback, ccCallLogDirection=ccCallLogDirection, ccDetailsInSetupUserCheck=ccDetailsInSetupUserCheck, ccActiveCallTable=ccActiveCallTable, ccActiveCallIndex=ccActiveCallIndex, ccBchannelActiveCallIndex=ccBchannelActiveCallIndex, ccDetailsHoldupTime=ccDetailsHoldupTime, ccDetailsInAnyFlag=ccDetailsInAnyFlag, ccDetailsNumberAttachments=ccDetailsNumberAttachments, ccActiveCallDetailsIndex=ccActiveCallDetailsIndex, ccDetailsName=ccDetailsName, ccDetailsInSetupCliSearchList=ccDetailsInSetupCliSearchList, ccDetailsLoginType=ccDetailsLoginType, ccBchannelDirection=ccBchannelDirection, ccCliListTable=ccCliListTable, ccDetailsPrecedence=ccDetailsPrecedence, ccBchannelCallType=ccBchannelCallType, ccBchannelIfIndex=ccBchannelIfIndex, ccCallLogDuration=ccCallLogDuration, ccActiveCallUserInstance=ccActiveCallUserInstance, ccDetailsOutSetupUser=ccDetailsOutSetupUser, ccCliListEntry=ccCliListEntry, ccActiveCallEntry=ccActiveCallEntry, ccDetailsPassword=ccDetailsPassword, ccActiveCallState=ccActiveCallState, ccBchannelTable=ccBchannelTable, ccCliListNumber=ccCliListNumber, ccDetailsInSetupCalledSubCheck=ccDetailsInSetupCalledSubCheck, ccDetailsRetryN1=ccDetailsRetryN1, ccCliListListIndex=ccCliListListIndex, ccActiveCallUserModule=ccActiveCallUserModule, ccBchannelEntry=ccBchannelEntry, ccBchannelPriority=ccBchannelPriority, ccCliListEntryIndex=ccCliListEntryIndex, ccAttachmentActiveCallIndex=ccAttachmentActiveCallIndex, ccDetailsPriority=ccDetailsPriority, PYSNMP_MODULE_ID=cc, ccCallLogEntry=ccCallLogEntry, ccAttachmentDetailsIndex=ccAttachmentDetailsIndex, ccAttachmentTable=ccAttachmentTable, ccCallLogTimeStarted=ccCallLogTimeStarted, ccCallLogName=ccCallLogName, ccCallLogState=ccCallLogState, ccDetailsInSetupCliCheck=ccDetailsInSetupCliCheck, ccCallLogIndex=ccCallLogIndex, ccDetailsKeepup=ccDetailsKeepup, ccBchannelChannelIndex=ccBchannelChannelIndex, ccDetailsRetryT2=ccDetailsRetryT2, ccActiveCallDirection=ccActiveCallDirection, cc=cc, ccBchannelAllocated=ccBchannelAllocated, ccDetailsAlternateNumber=ccDetailsAlternateNumber, ccDetailsEnabled=ccDetailsEnabled, ccDetailsIndex=ccDetailsIndex, ccCallLogTable=ccCallLogTable, ccDetailsPppTemplate=ccDetailsPppTemplate, ccActiveCallDataRate=ccActiveCallDataRate, ccDetailsOutSetupCalledSub=ccDetailsOutSetupCalledSub, ccDetailsInSetupCliSearch=ccDetailsInSetupCliSearch, ccDetailsRetryN2=ccDetailsRetryN2, ccDetailsDataRate=ccDetailsDataRate, ccDetailsBumpDelay=ccDetailsBumpDelay, ccDetailsUserType=ccDetailsUserType)

#
# PySNMP MIB module ATM-SOFT-PVC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATM-SOFT-PVC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:22 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
atmVclVci, atmVclVpi, atmVplVpi = mibBuilder.importSymbols("ATM-MIB", "atmVclVci", "atmVclVpi", "atmVplVpi")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, Bits, ObjectIdentity, Counter32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, IpAddress, Unsigned32, TimeTicks, NotificationType, enterprises, Gauge32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Bits", "ObjectIdentity", "Counter32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "IpAddress", "Unsigned32", "TimeTicks", "NotificationType", "enterprises", "Gauge32", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
TruthValue, RowStatus, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC-v1", "TruthValue", "RowStatus", "TimeStamp")
atmSoftPvcMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1))
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfSoftPvc = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5))
atmSoftPvcMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1))
atmSoftPvcMIBTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 2))
atmSoftPvcBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1))
atmSoftPvcTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 2, 1))
atmSoftPvcTrapsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 2, 1, 0))
atmSoftPvcMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3))
atmSoftPvcMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 1))
atmSoftPvcMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2))
class AtmAddr(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), )
atmSoftPvcCallFailuresTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPvcCallFailuresTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPvcCallFailuresTrapEnable.setDescription("Allows the generation of traps in response to call failures. By default, this object is set to 'false'.")
atmSoftPvcCallFailures = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPvcCallFailures.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPvcCallFailures.setDescription('The number of times a series of call attempts has failed to establish a Soft PVCC or Soft PVPC. The number of call attempts in a series is determined by atmSoftPVccRetryThreshold or atmSoftPVpcRetryThreshold, respectively.')
atmSoftPvcCurrentlyFailingSoftPVccs = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPvcCurrentlyFailingSoftPVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPvcCurrentlyFailingSoftPVccs.setDescription("The current number of Soft PVCCs for which there is an active row in the atmSoftPVccTable having an atmSoftPVccOperStatus with a value other than 'connected'.")
atmSoftPvcCurrentlyFailingSoftPVpcs = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPvcCurrentlyFailingSoftPVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPvcCurrentlyFailingSoftPVpcs.setDescription("The current number of Soft PVPCs for which there is an active row in the atmSoftPVpcTable having an atmSoftPVpcOperStatus with a value other than 'connected'.")
atmSoftPvcNotificationInterval = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPvcNotificationInterval.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPvcNotificationInterval.setDescription('The minimum interval between the sending of atmSoftPvcCallFailuresTrap notifications.')
atmSoftPVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2), )
if mibBuilder.loadTexts: atmSoftPVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccTable.setDescription('The (conceptual) table used to manage Soft Permanent Virtual Channel Connections (Soft PVCCs). The Soft PVCC table is applicable only to switches.')
atmSoftPVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "ATM-SOFT-PVC-MIB", "atmSoftPVccLeafReference"))
if mibBuilder.loadTexts: atmSoftPVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccEntry.setDescription('Each entry in this table represents a Soft Permanent Virtual Channel Connection (Soft PVCC) originating at a switch interface. A Soft PVCC is a VCC that is: - provisioned at the originating (source) interface of the connection - established by signalling procedures across a network to a destination interface. A row in the atmVclTable must be created, defining a VCL on the source interface, prior to creating an atmSoftPVccEntry row. The row in the atmVclTable must be active prior to activating the atmSoftPVccEntry row. The contents of this table reflect only the characteristics unique to a Soft PVCC. The traffic parameters are defined in the VCL row for the source interface, as specified in the ATOMMIB (RFC1695) and the forthcoming addition, the Supplemental ATOMMIB. Note that the atmSigDescrParamTable contains some objects such as the AAL parameters, Broadband high layer information and Broadband low layer information elements which are used to carry end-to-end information. For this reason, these objects are not relevant to Soft PVCCs. When a row is made active, an attempt is made to set up a switched connection to an interface at the destination switch. No objects (other than atmSoftPVccRowStatus) can be set while the row is active. At the destination, the VCL may be defined (but not cross-connected) prior to arrival of the Setup request. The combination of ifIndex, atmVclVpi, and atmVclVci specified in the index clause of this entry serves to identify the VCL on the source interface. The atmSoftPVccLeafReference object aids in distinguishing between leaves of a point-to-multipoint Soft PVCC.')
atmSoftPVccLeafReference = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: atmSoftPVccLeafReference.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccLeafReference.setDescription("An arbitrary integer which, in the case of the source VCL having an atmVclCastType of 'p2mpRoot', serves to distinguish between the multiple leaves attached to a root of a point-to-multipoint Soft PVCC. If the atmVclCastType is not 'p2mpRoot' the value 1 shall be used.")
atmSoftPVccTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 2), AtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccTargetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccTargetAddress.setDescription('The target ATM Address of this Soft PVCC. If no address is supplied, no attempts to establish the Soft PVCC are initiated.')
atmSoftPVccTargetSelectType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("required", 1), ("any", 2))).clone('required')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccTargetSelectType.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccTargetSelectType.setDescription("Indicates whether the target VPI/VCI values are to be used at the destination. If the value 'any' is specified, the destination switch will choose the VPI/VCI values. In such a case, once the Soft PVCC atmSoftPVccOperStatus value is 'connected', the value of this object changes to 'required', such that the same VPI/VCI values will continue to be used even if the connection is subsequently torn down and re-established. The VPI/VCI values chosen will be available for reading in atmSoftPVccTargetVpi and atmSoftPVccTargetVci. If the value 'required' is specified, then values must be supplied for objects atmSoftPVccTargetVpi and atmSoftPVccTargetVci prior to activation of the row. These values are then to be used at the destination.")
atmSoftPVccTargetVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccTargetVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccTargetVpi.setDescription("The VPI value of the VCL used at the target interface. This value is not relevant when the value of atmSoftPVccTargetSelectType is 'any'.")
atmSoftPVccTargetVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccTargetVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccTargetVci.setDescription("The VCI value of the VCL used at the target interface. This value must be filled in when the atmSoftPVccTargetSelectType is set to 'required'.This value is not relevant when the value of atmSoftPVccTargetSelectType is 'any'.")
atmSoftPVccLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccLastReleaseCause.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccLastReleaseCause.setDescription('Value of the Cause field of the Cause Information Element in the last RELEASE signalling message received for this Soft PVCC. Indicates the reason for the Release.')
atmSoftPVccLastReleaseDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccLastReleaseDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccLastReleaseDiagnostic.setDescription('Value of the first 8 bytes of diagnostic information from the Cause field of the Cause Information Element in the last RELEASE signalling message received for this Soft PVCC.')
atmSoftPVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("establishmentInProgress", 2), ("connected", 3), ("retriesExhausted", 4), ("noAddressSupplied", 5), ("lowerLayerDown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccOperStatus.setDescription("Describes the status of the Soft PVCC. Valid values are: other - none of the types specified below establishmentInProgress - connection or party is not operational, but setup or add party attempts are ongoing connected - connection or party is currently operational retriesExhausted - retry limit has been reached and setup or add party attempts have ceased noAddressSupplied - no remote address has been configured, so no setup or add party attempts are initiated lowerLayerDown - underlying ATM interface is not operational When the row is not 'active', the value of this object is 'other'.")
atmSoftPVccRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccRestart.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccRestart.setDescription("When the value is set to 'restart' the Soft PVCC is released if necessary and a new setup procedure is begun. As a result of this action, the atmSoftPVccOperStatus object transitions to 'establishmentInProgress' (if not already in this state) and the atmSoftPVccRetryFailures object is cleared When the value is set to 'noop' no operation is performed. When read, the value 'noop' is returned.")
atmSoftPVccRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccRetryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccRetryInterval.setDescription('Defines the period to wait before attempting to establish the Soft PVCC after the first failed call attempt. The time to wait between subsequent call attempts may differ to implement a backoff scheme. Zero represents an infinite interval indicating no retries.')
atmSoftPVccRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccRetryTimer.setDescription('Indicates the current value of the retry timer for this connection. When the value reaches zero an attempt will be made to establish the Soft PVCC. When the timer is not running, the value zero shall be returned.')
atmSoftPVccRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccRetryThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccRetryThreshold.setDescription('Indicates the number of consecutive call setup attempts for the same Soft PVCC which need to fail before the atmSoftPvcCallFailures object is incremented. A value of zero indicates that an infinite number of call attempts are required to increment the atmSoftPvcCallFailures object and thus disables alarms for the Soft PVCC.')
atmSoftPVccRetryFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccRetryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccRetryFailures.setDescription('Indicates how many attempts to establish the connection have failed. This count is reset whenever a connection is successfully established or the Soft PVCC is restarted.')
atmSoftPVccRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccRetryLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccRetryLimit.setDescription("Sets a maximum limit on how many consecutive unsuccessful call setup attempts can be made before stopping the attempt to set up the connection. If this limit is reached then management action will be required (e.g. setting atmSoftPVccRestart to 'restart') to initiate a new attempt to establish the connection. A value of zero indicates no limit - the attempts will continue until successful.")
atmSoftPVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 15), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVccRowStatus.setDescription("Used to create and delete a Soft PVCC. When this object is set to 'active' an attempt is made to set up the Soft PVCC. When this object has the value 'active' and is set to another value, any set-up or connection in-progress is released.")
atmSoftPVpcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3), )
if mibBuilder.loadTexts: atmSoftPVpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcTable.setDescription('The (conceptual) table used to manage Soft Permanent Virtual Path Connections (Soft PVPCs) The Soft PVPC table is applicable only to switches.')
atmSoftPVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"), (0, "ATM-SOFT-PVC-MIB", "atmSoftPVpcLeafReference"))
if mibBuilder.loadTexts: atmSoftPVpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcEntry.setDescription('Each entry in this table represents a Soft Permanent Virtual Path Connection (Soft PVPC) originating at a switch interface. A Soft PVPC is a VPC that is: - provisioned at the originating (source) interface of the connection - established by signalling procedures across a network to a destination interface. A row in the atmVplTable must be created, defining a VPL on the source interface, prior to creating an atmSoftPVpcEntry row. The row in the atmVplTable must be active prior to activating the atmSoftPVpcEntry row. The contents of this table reflect only the characteristics unique to a Soft PVPC. The traffic parameters are defined in the VPL row for the source interface, as specified in the ATOMMIB (RFC1695) and the forthcoming addition, the Supplemental ATOMMIB. Note that the atmSigDescrParamTable contains some objects such as the AAL parameters, Broadband high layer information, and Broadband low layer information elements which are used to carry end-to-end information. For this reason, these objects are not relevant to Soft PVPCs. When a row is made active, an attempt is made to set up a switched connection to an interface at the destination switch. No objects (other than atmSoftPVpcRowStatus) can be set while the row is active. At the destination, the VPL may be defined (but not cross-connected) prior to arrival of the Setup request. The combination of ifIndex, atmVplVpi specified in the index clause of this entry serves to identify the VPL on the source interface. The atmSoftPVpcLeafReference object aids in distinguishing between leaves of a point-to-multipoint Soft PVPC.')
atmSoftPVpcLeafReference = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63535)))
if mibBuilder.loadTexts: atmSoftPVpcLeafReference.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcLeafReference.setDescription("An arbitrary integer which, in the case of the source VPL having a atmVplCastType of 'p2mpRoot', serves to distinguish between the multiple leaves attached to a root of a point-to-multipoint Soft PVPC. If the atmVplCastType is not 'p2mpRoot', the value 1 shall be used.")
atmSoftPVpcTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 2), AtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVpcTargetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcTargetAddress.setDescription('The target ATM Address of this Soft PVPC. If no address is supplied, no attempts to establish the Soft PVPC are initiated.')
atmSoftPVpcTargetSelectType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("required", 1), ("any", 2))).clone('required')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVpcTargetSelectType.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcTargetSelectType.setDescription("Indicates whether the target VPI value is to be used at the destination. If the value 'any' is specified, the destination switch will choose the VPI value. In such a case, once the Soft PVPC atmSoftPVpcOperStatus value is 'connected', the value of this object changes to 'required', such that the same VPI value will continue to be used even if the connection is subsequently torn down and re-established. The VPI value chosen will be available for reading in atmSoftPVpcTargetVpi. If the value 'required' is specified, then a value must be supplied for object atmSoftPVpcTargetVpi prior to activation of the row. This value is then to be used at the destination.")
atmSoftPVpcTargetVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVpcTargetVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcTargetVpi.setDescription("The VPI value of the VPL used at the target interface. This value must be filled in when the atmSoftPVpcTargetSelectType is set to 'required'. This value is not relevant when the value of atmSoftPVpcTargetSelectType is 'any'.")
atmSoftPVpcLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcLastReleaseCause.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcLastReleaseCause.setDescription('Value of the Cause field of the Cause Information Element in the last RELEASE signalling message received for this Soft PVPC. Indicates the reason for the Release.')
atmSoftPVpcLastReleaseDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcLastReleaseDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcLastReleaseDiagnostic.setDescription('Value of the first 8 bytes of diagnostic information from the Cause field of the Cause Information Element in the last RELEASE signalling message received for this Soft PVPC.')
atmSoftPVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("establishmentInProgress", 2), ("connected", 3), ("retriesExhausted", 4), ("noAddressSupplied", 5), ("lowerLayerDown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcOperStatus.setDescription("Describes the status of the Soft PVPC. other - none of the types specified below establishmentInProgress - connection or party is not operational, but setup or add party attempts are ongoing connected - connection or party is currently operational retriesExhausted - retry limit has been reached and setup or add party attempts have ceased noAddressSupplied - no remote address has been configured, so no setup or add party attempts are initiated lowerLayerDown - underlying ATM interface is not operational When the row is not 'active', the value of this object is 'other'.")
atmSoftPVpcRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVpcRestart.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcRestart.setDescription("When the value is set to 'restart', the Soft PVPC is released if necessary and a new setup procedure is begun. As a result of this action, the atmSoftPVpcOperStatus object transitions to 'establishmentInProgress' (if not already in this state) and the atmSoftPVpcRetryFailures object is cleared. When the value is set to 'noop', no operation is performed. When read, the value 'noop' is returned.")
atmSoftPVpcRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVpcRetryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcRetryInterval.setDescription('Defines the period to wait before attempting to establish the Soft PVPC after the first failed call attempt. The time to wait between subsequent call attempts may differ to implement a backoff scheme. Zero represents an infinite interval indicating no retries.')
atmSoftPVpcRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcRetryTimer.setDescription('Indicates the current value of the retry timer for this connection. When the value reaches zero an attempt will be made to establish the Soft PVPC. When the timer is not running, the value zero shall be returned.')
atmSoftPVpcRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVpcRetryThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcRetryThreshold.setDescription('Indicates the number of consecutive call setup attempts for the same Soft PVPC which need to fail before the atmSoftPvcCallFailures object is incremented. A value of zero indicates that an infinite number of call attempts are required to increment the atmSoftPvcCallFailures object and thus disables alarms for the Soft PVPC.')
atmSoftPVpcRetryFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcRetryFailures.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcRetryFailures.setDescription('Indicates how many attempts to establish the connection have failed. This count is reset whenever a connection is successfully established or the Soft PVPC is restarted.')
atmSoftPVpcRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVpcRetryLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcRetryLimit.setDescription("Sets a maximum limit on how many consecutive unsuccessful call setup attempts can be made before stopping the attempt to set up the connection. If this limit is reached then management action will be required (e.g. setting atmSoftPVpcRestart to 'restart') to initiate a new attempt to establish the connection. A value of zero indicates no limit - the attempts will continue until successful.")
atmSoftPVpcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 14), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPVpcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmSoftPVpcRowStatus.setDescription("Used to create and delete a Soft PVPC. When this object is set to 'active' an attempt is made to set up the Soft PVPC. When this object has the value 'active' and is set to another value, any set-up or connection in-progress is released.")
atmInterfaceSoftPvcAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 4), )
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressTable.setDescription('This table is used to configure ATM addresses at an ATM interface on this node prior to setting up Soft PVPCs or Soft PVPCs at that interface.')
atmInterfaceSoftPvcAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-SOFT-PVC-MIB", "atmInterfaceSoftPvcAddress"))
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressEntry.setDescription('ATM address entry for configuring Soft PVCCs or Soft PVPCs at an ATM interface.')
atmInterfaceSoftPvcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 4, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddress.setDescription('Specifies the address that can be used to establish a Soft PVCC or Soft PVPC to this interface.')
atmInterfaceSoftPvcAddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 4, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressRowStatus.setDescription('Used to create and delete an ATM address at this interface for setting up Soft PVCCs or Soft PVPCs.')
atmCurrentlyFailingSoftPVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 5), )
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccTable.setDescription("A table indicating all Soft Permanent Virtual Channel Connections (Soft PVCCs) for which the atmSoftPVccRowStatus is 'active' and the atmSoftPVccOperStatus is other than 'connected'.")
atmCurrentlyFailingSoftPVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "ATM-SOFT-PVC-MIB", "atmSoftPVccLeafReference"))
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccEntry.setDescription("Each entry in this table represents a Soft Permanent Virtual Channel Connection (Soft PVCC) for which the atmSoftPVccRowStatus is 'active' and the atmSoftPVccOperStatus is other than 'connected'.")
atmCurrentlyFailingSoftPVccTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 5, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccTimeStamp.setDescription('The time at which this Soft PVCC began to fail.')
atmCurrentlyFailingSoftPVpcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 6), )
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcTable.setDescription("A table indicating all Soft Permanent Virtual Path Connections (Soft PVPCs) for which the atmSoftPVpcRowStatus is 'active' and the atmSoftPVpcOperStatus is other than 'connected'.")
atmCurrentlyFailingSoftPVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-SOFT-PVC-MIB", "atmSoftPVpcLeafReference"))
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcEntry.setDescription("Each entry in this table represents a Soft Permanent Virtual Path Connection (Soft PVPC) for which the atmSoftPVpcRowStatus is 'active' and the atmSoftPVpcOperStatus is other than 'connected'.")
atmCurrentlyFailingSoftPVpcTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 6, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcTimeStamp.setDescription('The time at which this Soft PVPC began to fail.')
atmSoftPvcCallFailuresTrap = NotificationType((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 2, 1) + (0,1)).setObjects(("ATM-SOFT-PVC-MIB", "atmSoftPvcCallFailures"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcCurrentlyFailingSoftPVccs"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcCurrentlyFailingSoftPVpcs"))
if mibBuilder.loadTexts: atmSoftPvcCallFailuresTrap.setDescription('A notification indicating that one or more series of call attempts in trying to establish a Soft PVPC or Soft PVCC have failed since the last atmSoftPvcCallFailureTrap was sent. If this trap has not been sent for the last atmSoftPvcNotificationInterval, then it will be sent on the next increment of atmSoftPvcCallFailures.')
atmSoftPvcBaseMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 1))
atmSoftPvcVccMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 2))
atmSoftPvcVpcMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 3))
atmSoftPvcAddressMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 4))
atmCurrentlyFailingSoftPVccMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 5))
atmCurrentlyFailingSoftPVpcMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 6))
atmSoftPvcMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 1, 1))
mibBuilder.exportSymbols("ATM-SOFT-PVC-MIB", AtmAddr=AtmAddr, atmCurrentlyFailingSoftPVccEntry=atmCurrentlyFailingSoftPVccEntry, atmSoftPVccLeafReference=atmSoftPVccLeafReference, atmSoftPVpcTargetAddress=atmSoftPVpcTargetAddress, atmSoftPvcCallFailuresTrapEnable=atmSoftPvcCallFailuresTrapEnable, atmSoftPVccTargetSelectType=atmSoftPVccTargetSelectType, atmSoftPVpcRetryTimer=atmSoftPVpcRetryTimer, atmCurrentlyFailingSoftPVpcTable=atmCurrentlyFailingSoftPVpcTable, atmInterfaceSoftPvcAddress=atmInterfaceSoftPvcAddress, atmSoftPVccLastReleaseDiagnostic=atmSoftPVccLastReleaseDiagnostic, atmSoftPvcAddressMIBGroup=atmSoftPvcAddressMIBGroup, atmSoftPVccRetryThreshold=atmSoftPVccRetryThreshold, atmSoftPVccRetryTimer=atmSoftPVccRetryTimer, atmSoftPVccTargetAddress=atmSoftPVccTargetAddress, atmSoftPvcMIBObjects=atmSoftPvcMIBObjects, atmSoftPVccRetryFailures=atmSoftPVccRetryFailures, atmSoftPVccTargetVci=atmSoftPVccTargetVci, atmSoftPVpcLeafReference=atmSoftPVpcLeafReference, atmSoftPVpcRetryLimit=atmSoftPVpcRetryLimit, atmCurrentlyFailingSoftPVccTimeStamp=atmCurrentlyFailingSoftPVccTimeStamp, atmSoftPVpcLastReleaseCause=atmSoftPVpcLastReleaseCause, atmSoftPvcCurrentlyFailingSoftPVccs=atmSoftPvcCurrentlyFailingSoftPVccs, atmCurrentlyFailingSoftPVccTable=atmCurrentlyFailingSoftPVccTable, atmSoftPVpcRetryInterval=atmSoftPVpcRetryInterval, atmSoftPVpcEntry=atmSoftPVpcEntry, atmInterfaceSoftPvcAddressRowStatus=atmInterfaceSoftPvcAddressRowStatus, atmSoftPVpcRestart=atmSoftPVpcRestart, atmCurrentlyFailingSoftPVpcTimeStamp=atmCurrentlyFailingSoftPVpcTimeStamp, atmSoftPvcBaseGroup=atmSoftPvcBaseGroup, atmSoftPvcMIBCompliance=atmSoftPvcMIBCompliance, atmForumNetworkManagement=atmForumNetworkManagement, atmSoftPVccOperStatus=atmSoftPVccOperStatus, atmSoftPvcBaseMIBGroup=atmSoftPvcBaseMIBGroup, atmSoftPVpcTargetSelectType=atmSoftPVpcTargetSelectType, atmSoftPVccRowStatus=atmSoftPVccRowStatus, atmSoftPvcMIBCompliances=atmSoftPvcMIBCompliances, atmInterfaceSoftPvcAddressTable=atmInterfaceSoftPvcAddressTable, atmForum=atmForum, atmSoftPVccLastReleaseCause=atmSoftPVccLastReleaseCause, atmCurrentlyFailingSoftPVpcEntry=atmCurrentlyFailingSoftPVpcEntry, atmSoftPvcCallFailuresTrap=atmSoftPvcCallFailuresTrap, atmSoftPvcVpcMIBGroup=atmSoftPvcVpcMIBGroup, atmSoftPvcMIBGroups=atmSoftPvcMIBGroups, atmSoftPVpcRetryThreshold=atmSoftPVpcRetryThreshold, atmSoftPvcNotificationInterval=atmSoftPvcNotificationInterval, atmSoftPVccTargetVpi=atmSoftPVccTargetVpi, atmSoftPVpcTable=atmSoftPVpcTable, atmSoftPvcTraps=atmSoftPvcTraps, atmfSoftPvc=atmfSoftPvc, atmSoftPVpcRetryFailures=atmSoftPVpcRetryFailures, atmSoftPVpcLastReleaseDiagnostic=atmSoftPVpcLastReleaseDiagnostic, atmSoftPvcCallFailures=atmSoftPvcCallFailures, atmSoftPVpcRowStatus=atmSoftPVpcRowStatus, atmSoftPVpcOperStatus=atmSoftPVpcOperStatus, atmSoftPvcMIBConformance=atmSoftPvcMIBConformance, atmSoftPVccEntry=atmSoftPVccEntry, atmSoftPVccRestart=atmSoftPVccRestart, atmSoftPvcVccMIBGroup=atmSoftPvcVccMIBGroup, atmCurrentlyFailingSoftPVpcMIBGroup=atmCurrentlyFailingSoftPVpcMIBGroup, atmSoftPVpcTargetVpi=atmSoftPVpcTargetVpi, atmSoftPvcTrapsPrefix=atmSoftPvcTrapsPrefix, atmSoftPVccRetryInterval=atmSoftPVccRetryInterval, atmInterfaceSoftPvcAddressEntry=atmInterfaceSoftPvcAddressEntry, atmSoftPvcMIB=atmSoftPvcMIB, atmSoftPvcMIBTraps=atmSoftPvcMIBTraps, atmSoftPVccTable=atmSoftPVccTable, atmCurrentlyFailingSoftPVccMIBGroup=atmCurrentlyFailingSoftPVccMIBGroup, atmSoftPvcCurrentlyFailingSoftPVpcs=atmSoftPvcCurrentlyFailingSoftPVpcs, atmSoftPVccRetryLimit=atmSoftPVccRetryLimit)

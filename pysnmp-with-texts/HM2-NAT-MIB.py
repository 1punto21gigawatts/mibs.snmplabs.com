#
# PySNMP MIB module HM2-NAT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-NAT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:31:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
HmTimeSeconds1970, HmActionValue, hm2ConfigurationMibs = mibBuilder.importSymbols("HM2-TC-MIB", "HmTimeSeconds1970", "HmActionValue", "hm2ConfigurationMibs")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Integer32, Unsigned32, Counter32, NotificationType, iso, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Bits, Gauge32, IpAddress, ModuleIdentity, TimeTicks, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Unsigned32", "Counter32", "NotificationType", "iso", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Bits", "Gauge32", "IpAddress", "ModuleIdentity", "TimeTicks", "MibIdentifier")
RowStatus, TextualConvention, TruthValue, StorageType, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue", "StorageType", "DisplayString")
hm2NatMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 80))
hm2NatMib.setRevisions(('2011-11-30 00:00', '2011-10-24 00:00', '2011-09-13 00:00', '2011-07-01 00:00', '2011-05-31 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2NatMib.setRevisionsDescriptions(('- Added missing protocol information - Changed stats to 64bit values ', 'Removed all address types to be in sync with the FW MIB. The address type is now determined by the parser automatically. ', '- Added commit and pending actions variables - Added interface mapping tables - Use HmActionValue instead of TruthValue ', '- Modifications to address representation ', 'Initial version.',))
if mibBuilder.loadTexts: hm2NatMib.setLastUpdated('201111300000Z')
if mibBuilder.loadTexts: hm2NatMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2NatMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 - 7127 -14 -0 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2NatMib.setDescription('This MIB defines the SNMP interface for Hirschmann DNAT/SNAT/ Double NAT/1:1 NAT implementations Copyright (C) ')
hm2NatNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 0))
hm2NatObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1))
hm2NatConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 2))
hm2NatGeneralSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 1))
hm2DnatMaxRules = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatMaxRules.setStatus('current')
if mibBuilder.loadTexts: hm2DnatMaxRules.setDescription('Maximum number of allowed rules for DNAT.')
hm2OneToOneNatMaxRules = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2OneToOneNatMaxRules.setStatus('current')
if mibBuilder.loadTexts: hm2OneToOneNatMaxRules.setDescription('Maximum number of allowed rules for 1:1 NAT.')
hm2MasqMaxRules = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqMaxRules.setStatus('current')
if mibBuilder.loadTexts: hm2MasqMaxRules.setDescription('Maximum number of allowed rules for Masquerading.')
hm2DoubleNatMaxRules = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DoubleNatMaxRules.setStatus('current')
if mibBuilder.loadTexts: hm2DoubleNatMaxRules.setDescription('Maximum number of allowed rules for Double NAT.')
hm2NatResetStatistics = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 1, 6), HmActionValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2NatResetStatistics.setStatus('current')
if mibBuilder.loadTexts: hm2NatResetStatistics.setDescription('Setting this value to action(2) will reset the statistics of the whole NAT module. It will be set to noop(1) automatically after reset.')
hm2DnatRuleAppliedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 80, 0, 1)).setObjects(("HM2-NAT-MIB", "hm2DnatRuleIndex"))
if mibBuilder.loadTexts: hm2DnatRuleAppliedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleAppliedTrap.setDescription('A rule of DNAT was applied. The rule is identified by the given rule index of the rule table.')
hm2DnatRuleAppliedAndLoggedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 80, 0, 2)).setObjects(("HM2-NAT-MIB", "hm2DnatRuleIndex"))
if mibBuilder.loadTexts: hm2DnatRuleAppliedAndLoggedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleAppliedAndLoggedTrap.setDescription('A rule of DNAT was applied and logged according to the current logging mechanism. The rule is identified by the given rule index of the rule table.')
hm2Dnat = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2))
hm2DnatRules = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1))
hm2DnatRulesObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 1))
hm2DnatRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleCount.setDescription('Number of current DNAT rules')
hm2DnatIfMappingRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatIfMappingRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2DnatIfMappingRuleCount.setDescription('Number of current DNAT IF mapping entries.')
hm2DnatRulePendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatRulePendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRulePendingActions.setDescription('This value describes, whether the DNAT rule table was modified but not yet written to the firewall implementation (set to true). After writing all modifications to the firewall, the value switches automatically back to false.')
hm2DnatCommitPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 1, 4), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DnatCommitPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DnatCommitPendingActions.setDescription('Setting this value to action(2) writes not yet committed changes to the firewall (DNAT and Interface Mapping Table). After writing all modifications, the value switches automatically back to noop(1).')
hm2DnatRulesTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2))
hm2DnatRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1), )
if mibBuilder.loadTexts: hm2DnatRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleTable.setDescription('The list of DNAT rules for this firewall.')
hm2DnatRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2DnatRuleIndex"))
if mibBuilder.loadTexts: hm2DnatRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleEntry.setDescription('DNAT rule entry.')
hm2DnatRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2DnatRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleIndex.setDescription('Rule index of this DNAT rule.')
hm2DnatSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatSourceAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DnatSourceAddress.setDescription("Source address of packets to be NATed. Can be: - Single address (a.b.c.d), - address range in CIDR notation (a.b.c.d/n) - the name of a Netobject ($NetobjectName) - 'any' for no filtering at all - a prepending '!' selects the complement set")
hm2DnatSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatSourcePort.setStatus('current')
if mibBuilder.loadTexts: hm2DnatSourcePort.setDescription("The source port of the packet to reroute. Allowed formats are: - keyword 'any' for no filtering or a protocol without ports - single port ('10') - port range with first and last port separated by hyphen ('10-15') - comma separated list of ports ('1235,25,123') - combination of the points above ('10,25-30,125,1993') The number of named ports (1 for each individual port, 2 for port ranges) must not exceed 15.")
hm2DnatTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatTargetAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DnatTargetAddress.setDescription("Destination address of packets to be NATed. Can be: - Single address (a.b.c.d), - address range in CIDR notation (a.b.c.d/n) - the name of a Netobject ($NetobjectName) - 'any' for no filtering at all - a prepending '!' selects the complement set")
hm2DnatTargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatTargetPort.setStatus('current')
if mibBuilder.loadTexts: hm2DnatTargetPort.setDescription("The target port of the packet to reroute. Allowed formats are: - keyword 'any' - single port ('10') - port range with first and last port separated by hyphen ('10-15') - comma separated list of ports ('1235,25,123') - combination of the points above ('10,25-30,125,1993') The number of named ports (1 for each individual port, 2 for port ranges) must not exceed 15.")
hm2DnatNewTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatNewTargetAddress.setStatus('current')
if mibBuilder.loadTexts: hm2DnatNewTargetAddress.setDescription('The IP address of the machine to reroute packets to. Must be a single IP address (a.b.c.d).')
hm2DnatNewTargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatNewTargetPort.setStatus('current')
if mibBuilder.loadTexts: hm2DnatNewTargetPort.setDescription("The port to reroute packets to. Must be a single port or 'any'.")
hm2DnatProto = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("icmp", 1), ("igmp", 2), ("ipip", 3), ("tcp", 4), ("udp", 5), ("esp", 6), ("ah", 7), ("icmpv6", 8), ("any", 9))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatProto.setStatus('current')
if mibBuilder.loadTexts: hm2DnatProto.setDescription('The IP protocol (RFC 791) for protocol-independent filtering. The following values are currently supported: o icmp(1): Internet Control Message Protocol (RFC 792) o igmp(2): Internet Group Management Protocol o ipip(3): IP in IP tunneling (RFC 1853) o tcp(4): Transmission Control Protocol (RFC 793) o udp(5): User Datagram Protocol (RFC 768) o esp(6): IPsec Encapsulated Security Payload (RFC 2406) o ah(7): IPsec Authentication Header (RFC 2402) o icmpv6(8): Internet Control Message Protocol for IPv6 o any(9): apply to all protocols')
hm2DnatRuleParams = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatRuleParams.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleParams.setDescription("Additional parameters to this rule as string. Currently only the value 'none' is valid. Reserved for future use.")
hm2DnatLog = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatLog.setStatus('current')
if mibBuilder.loadTexts: hm2DnatLog.setDescription('Set to true if application of this rule shall be logged.')
hm2DnatTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DnatTrap.setDescription('Set to true if application of this rule shall send a trap.')
hm2DnatRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRowStatus.setDescription('This is a standard row status value: - active(1): The rule is active. Note that until committed, the rule will not be applied. - notInService(2): The rule is inactive because of user action. - notReady(3):The rule is inactive because it has an incomplete configuration. - createAndGo(4): Create the rule with default parameters activated. - createAndWait(5): Create the rule inactive. - destroy(6): Delete the rule. You cannot delete a rule with interface mappings to it.')
hm2DnatDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatDescription.setStatus('current')
if mibBuilder.loadTexts: hm2DnatDescription.setDescription('User defined textual description related to this rule.')
hm2DnatRuleIfMappingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 2), )
if mibBuilder.loadTexts: hm2DnatRuleIfMappingTable.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleIfMappingTable.setDescription('Table for mapping DNAT rules to interfaces.')
hm2DnatRuleIfMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 2, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2DnatIfmInterface"), (0, "HM2-NAT-MIB", "hm2DnatIfmDirection"), (0, "HM2-NAT-MIB", "hm2DnatIfmRuleIndex"))
if mibBuilder.loadTexts: hm2DnatRuleIfMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DnatRuleIfMappingEntry.setDescription('Entry in rule interface mapping table.')
hm2DnatIfmRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048)))
if mibBuilder.loadTexts: hm2DnatIfmRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DnatIfmRuleIndex.setDescription('The index of the DNAT rule this mapping entry is assigned to.')
hm2DnatIfmDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2), ("both", 3))))
if mibBuilder.loadTexts: hm2DnatIfmDirection.setStatus('current')
if mibBuilder.loadTexts: hm2DnatIfmDirection.setDescription('For DNAT, this can only be set to ingress, which is the interface on which a packet that is to be forwarded will arrive.')
hm2DnatIfmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatIfmPriority.setStatus('current')
if mibBuilder.loadTexts: hm2DnatIfmPriority.setDescription("The priority is the sorting key for rules in the chain to this interface. They don't need to be unique per interface, but in that case, no clear order can be assumed. Priorities are processed in ascending order (0 highest priority).")
hm2DnatIfmInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 2, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: hm2DnatIfmInterface.setStatus('current')
if mibBuilder.loadTexts: hm2DnatIfmInterface.setDescription('The interface this mapping entry is assigned to. This has to be either an hm2AgentSwitchIpInterfaceIfIndex or an hm2AgentSwitchIpVlanIfIndex. Note that for physical interfaces this only works if the corresponding hm2AgentSwitchIpInterfaceRoutingMode is set to enable.')
hm2DnatIfmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 1, 2, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DnatIfmRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DnatIfmRowStatus.setDescription('The RowStatus value for this entry with the usual meanings: - active(1): The interface mapping is in place - notInService(2): The interface mapping is not in place because the user said so - notReady(3): The interface mapping is not in place because the agent said so - createAndGo(4): Create this mapping with the default priority and activate it. - createAndWait(5): Create this mapping deactivated. - destroy(6): Destroy this interface mapping.')
hm2DnatStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2))
hm2DnatGlobalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 1))
hm2DnatStatsTotalPck = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatStatsTotalPck.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsTotalPck.setDescription('Total number of packets processed by the DNAT firewall.')
hm2DnatStatsTotalPckSize = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatStatsTotalPckSize.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsTotalPckSize.setDescription('Total number of bytes processed by the DNAT firewall.')
hm2DnatStatsTotalPckDenDrop = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatStatsTotalPckDenDrop.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsTotalPckDenDrop.setDescription('Total number of packets dropped or denied by the DNAT firewall.')
hm2DnatStatsTotalPckAccepted = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatStatsTotalPckAccepted.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsTotalPckAccepted.setDescription('Total number of packets accepted by the DNAT firewall.')
hm2DnatRuleStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 2))
hm2DnatStatsRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 2, 1), )
if mibBuilder.loadTexts: hm2DnatStatsRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsRuleTable.setDescription('Table of per-rule statistics of the DNAT firewall.')
hm2DnatStatsRuleTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 2, 1, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2DnatRuleIndex"))
if mibBuilder.loadTexts: hm2DnatStatsRuleTableEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsRuleTableEntry.setDescription('Statistics table entry for DNAT.')
hm2DnatStatsPckCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 2, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatStatsPckCount.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsPckCount.setDescription('Number of packets DNATed.')
hm2DnatStatsPckSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatStatsPckSize.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsPckSize.setDescription('Number of bytes DNATed.')
hm2DnatStatsLastApplied = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 2, 2, 2, 1, 1, 3), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DnatStatsLastApplied.setStatus('current')
if mibBuilder.loadTexts: hm2DnatStatsLastApplied.setDescription('Time of last application of the rule in seconds since 1.1.1970.')
hm21to1RuleAppliedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 80, 0, 5)).setObjects(("HM2-NAT-MIB", "hm21to1RuleIndex"))
if mibBuilder.loadTexts: hm21to1RuleAppliedTrap.setStatus('current')
if mibBuilder.loadTexts: hm21to1RuleAppliedTrap.setDescription('A rule of 1:1 NAT was applied. The rule is identified by the given rule index of the rule table.')
hm21to1RuleAppliedAndLoggedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 80, 0, 6)).setObjects(("HM2-NAT-MIB", "hm21to1RuleIndex"))
if mibBuilder.loadTexts: hm21to1RuleAppliedAndLoggedTrap.setStatus('current')
if mibBuilder.loadTexts: hm21to1RuleAppliedAndLoggedTrap.setDescription('A rule of 1:1 NAT was applied and logged according the current logging mechanism. The rule is identified by the given rule index of the rule table.')
hm21to1 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4))
hm21to1RuleObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 1))
hm21to1RuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1RuleCount.setStatus('current')
if mibBuilder.loadTexts: hm21to1RuleCount.setDescription('Number of current 1:1 NAT rules.')
hm21to1IfMappingRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1IfMappingRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm21to1IfMappingRuleCount.setDescription('Number of current 1:1 NAT IF mapping entries.')
hm21to1RulePendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1RulePendingActions.setStatus('current')
if mibBuilder.loadTexts: hm21to1RulePendingActions.setDescription('This value describes, whether the 1:1 NAT rule table was modified but not yet written to the firewall implementation (set to true). After writing all modifications to the firewall, the value switches automatically back to false.')
hm21to1CommitPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 1, 4), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm21to1CommitPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm21to1CommitPendingActions.setDescription('Setting this value to action(2) writes not yet committed changes to the firewall (1:1 NAT and Interface Mapping Table). After writing all modifications, the value switches automatically back to noop(1).')
hm21to1Alg = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 1, 5), Bits().clone(namedValues=NamedValues(("ftp", 0), ("icmp", 1))).clone(namedValues=NamedValues(("icmp", 1), ("ftp", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm21to1Alg.setStatus('current')
if mibBuilder.loadTexts: hm21to1Alg.setDescription('Global bitmask for application level gateway of all the 1:1 NAT rules.')
hm21to1PublicIntf = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm21to1PublicIntf.setStatus('current')
if mibBuilder.loadTexts: hm21to1PublicIntf.setDescription('The index of the public interface defined on the uplink port.')
hm21to1RuleTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2))
hm21to1RuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1), )
if mibBuilder.loadTexts: hm21to1RuleTable.setStatus('current')
if mibBuilder.loadTexts: hm21to1RuleTable.setDescription('The list of 1:1 NAT rules for this firewall.')
hm21to1RuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm21to1RuleIndex"))
if mibBuilder.loadTexts: hm21to1RuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm21to1RuleEntry.setDescription('1:1 NAT rule entry.')
hm21to1RuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm21to1RuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm21to1RuleIndex.setDescription('Rule index of this 1:1 NAT rule.')
hm21to1TargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1TargetAddress.setStatus('current')
if mibBuilder.loadTexts: hm21to1TargetAddress.setDescription("Destination address of packets to be NATed. Can be: - Single address (a.b.c.d), - address range in CIDR notation (a.b.c.d/n) - the name of a Netobject ($NetobjectName) - 'any' for no filtering at all")
hm21to1NewTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1NewTargetAddress.setStatus('current')
if mibBuilder.loadTexts: hm21to1NewTargetAddress.setDescription("New Destination address of packets to be NATed. Can be: - Single address (a.b.c.d), - address range in CIDR notation (a.b.c.d/n) - the name of a Netobject ($NetobjectName) - 'any' for no filtering at all")
hm21to1RuleParams = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1RuleParams.setStatus('current')
if mibBuilder.loadTexts: hm21to1RuleParams.setDescription("Additional parameters to this rule as string. Currently only the value 'none' is valid. Reserved for future use.")
hm21to1Log = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1Log.setStatus('current')
if mibBuilder.loadTexts: hm21to1Log.setDescription('Set to true if application of this rule shall be logged.')
hm21to1Trap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1Trap.setStatus('current')
if mibBuilder.loadTexts: hm21to1Trap.setDescription('Set to true if application of this rule shall send a trap.')
hm21to1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1RowStatus.setStatus('current')
if mibBuilder.loadTexts: hm21to1RowStatus.setDescription('This is a standard row status value: - active(1): The rule is active. Note that until committed, the rule will not be applied. - notInService(2): The rule is inactive because of user action. - notReady(3):The rule is inactive because it has an incomplete configuration. - createAndGo(4): Create the rule with default parameters activated. - createAndWait(5): Create the rule inactive. - destroy(6): Delete the rule. You cannot delete a rule with interface mappings to it.')
hm21to1Description = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1Description.setStatus('current')
if mibBuilder.loadTexts: hm21to1Description.setDescription('User defined textual description related to this rule.')
hm21to1IngressIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 9), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1IngressIntf.setStatus('current')
if mibBuilder.loadTexts: hm21to1IngressIntf.setDescription('The index of the interface on which packets going to the target address will arrive. This has to be either an hm2AgentSwitchIpInterfaceIfIndex or an hm2AgentSwitchIpVlanIfIndex. Note that for physical interfaces this only works if the corresponding hm2AgentSwitchIpInterfaceRoutingMode is set to enable.')
hm21to1EgressIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 10), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1EgressIntf.setStatus('current')
if mibBuilder.loadTexts: hm21to1EgressIntf.setDescription('The index of the interface from which the new target address can be reached. This has to be either an hm2AgentSwitchIpInterfaceIfIndex or an hm2AgentSwitchIpVlanIfIndex. Note that for physical interfaces this only works if the corresponding hm2AgentSwitchIpInterfaceRoutingMode is set to enable.')
hm21to1Priority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 11), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1Priority.setStatus('current')
if mibBuilder.loadTexts: hm21to1Priority.setDescription("The priority is the sorting key for rules in the chain to this interface. They don't need to be unique per interface, but in that case, no clear order can be assumed. Priorities are processed in ascending order (0 highest priority).")
hm21to1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 2, 1, 1, 12), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm21to1StorageType.setStatus('current')
if mibBuilder.loadTexts: hm21to1StorageType.setDescription("The storage type for this row. Rows having the value 'volatile' are not saved.")
hm21to1Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3))
hm21to1GeneralStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 1))
hm21to1StatsTotalPck = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1StatsTotalPck.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsTotalPck.setDescription('Total number of packets processed by 1:1 NAT.')
hm21to1StatsTotalPckSize = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1StatsTotalPckSize.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsTotalPckSize.setDescription('Total number of bytes processed by the 1:1 NAT.')
hm21to1StatsTotalPckDenDrop = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1StatsTotalPckDenDrop.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsTotalPckDenDrop.setDescription('Total number of packets dropped or denied by 1:1 NAT.')
hm21to1StatsTotalPckAccepted = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1StatsTotalPckAccepted.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsTotalPckAccepted.setDescription('Total number of packets accepted by 1:1 NAT.')
hm21to1StatsTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 2))
hm21to1StatsRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 2, 1), )
if mibBuilder.loadTexts: hm21to1StatsRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsRuleTable.setDescription('Table of per-rule statistics of 1:1 NAT.')
hm21to1StatsRuleTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 2, 1, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm21to1RuleIndex"))
if mibBuilder.loadTexts: hm21to1StatsRuleTableEntry.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsRuleTableEntry.setDescription('Statistics table entry for 1:1 NAT.')
hm21to1StatsPckCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 2, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1StatsPckCount.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsPckCount.setDescription('Number of packets matched by this rule.')
hm21to1StatsPckSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1StatsPckSize.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsPckSize.setDescription('Number of bytes processed by this rule.')
hm21to1StatsLastApplied = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 4, 3, 2, 1, 1, 3), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm21to1StatsLastApplied.setStatus('current')
if mibBuilder.loadTexts: hm21to1StatsLastApplied.setDescription('Time of last application of the rule in seconds since 1.1.1970.')
hm2MasqRuleAppliedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 80, 0, 7)).setObjects(("HM2-NAT-MIB", "hm2MasqRuleIndex"))
if mibBuilder.loadTexts: hm2MasqRuleAppliedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleAppliedTrap.setDescription('A rule of masquerading was applied. The rule is identified by the given rule index of the rule table.')
hm2MasqRuleAppliedAndLoggedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 80, 0, 8)).setObjects(("HM2-NAT-MIB", "hm2MasqRuleIndex"))
if mibBuilder.loadTexts: hm2MasqRuleAppliedAndLoggedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleAppliedAndLoggedTrap.setDescription('A rule of masquerading was applied and logged according the current logging mechanism. The rule is identified by the given rule index of the rule table.')
hm2Masquerading = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5))
hm2MasqRuleObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 1))
hm2MasqRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleCount.setDescription('Number of current masquerading rules.')
hm2MasqIfMappingRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqIfMappingRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2MasqIfMappingRuleCount.setDescription('Number of current masquerading IF mapping entries.')
hm2MasqRulePendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqRulePendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRulePendingActions.setDescription('This value describes, whether the masquerading rule table was modified but not yet written to the firewall implementation (set to true). After writing all modifications to the firewall, the value switches automatically back to false.')
hm2MasqCommitPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 1, 4), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2MasqCommitPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2MasqCommitPendingActions.setDescription('Setting this value to action(2) writes not yet committed changes to the firewall (DNAT and Interface Mapping Table). After writing all modifications, the value switches automatically back to noop(1).')
hm2MasqRuleTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2))
hm2MasqRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1), )
if mibBuilder.loadTexts: hm2MasqRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleTable.setDescription('The list of masquerading rules for this firewall.')
hm2MasqRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2MasqRuleIndex"))
if mibBuilder.loadTexts: hm2MasqRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleEntry.setDescription('Masquerading rule entry.')
hm2MasqRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2MasqRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleIndex.setDescription('Rule index of this masquerading rule.')
hm2MasqSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqSourceAddress.setStatus('current')
if mibBuilder.loadTexts: hm2MasqSourceAddress.setDescription("The source address of the packets to reroute. Allowed formats are: - keyword 'any' - IP address ('10.0.0.1') - IP address range ('10.0.0.0/8') - a prepending '!' selects the complement set ")
hm2MasqSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50)).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqSourcePort.setStatus('current')
if mibBuilder.loadTexts: hm2MasqSourcePort.setDescription("The source port of the packet to reroute. Allowed formats are: - keyword 'any' - single ('10') - range with first and last separated by hyphen ('10-15') - comma separated list of s ('1235,25,123') - combination of the points above ('10,25-30,125,1993') The number of named ports (1 for each individual port, 2 for port ranges) must not exceed 15.")
hm2MasqProto = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 9))).clone(namedValues=NamedValues(("tcp", 4), ("udp", 5), ("any", 9))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqProto.setStatus('current')
if mibBuilder.loadTexts: hm2MasqProto.setDescription('The IP protocol (RFC 791) for protocol-independent filtering. The following values are currently supported: o tcp(4): transmission control protocol (RFC 793) o udp(5): user datagram protocol (RFC 768) o any(9): apply to all protocols')
hm2MasqRuleParams = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqRuleParams.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleParams.setDescription("Additional parameters to this rule as string. Currently only the value 'none' is valid. Reserved for future use.")
hm2MasqLog = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqLog.setStatus('current')
if mibBuilder.loadTexts: hm2MasqLog.setDescription('Set to true if application of this rule shall be logged.')
hm2MasqTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqTrap.setStatus('current')
if mibBuilder.loadTexts: hm2MasqTrap.setDescription('Set to true if application of this rule shall send a trap.')
hm2MasqRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRowStatus.setDescription('This is a standard row status value: - active(1): The rule is active. Note that until committed, the rule will not be applied. - notInService(2): The rule is inactive because of user action. - notReady(3):The rule is inactive because it has an incomplete configuration. - createAndGo(4): Create the rule with default parameters activated. - createAndWait(5): Create the rule inactive. - destroy(6): Delete the rule. You cannot delete a rule with interface mappings to it.')
hm2MasqDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqDescription.setStatus('current')
if mibBuilder.loadTexts: hm2MasqDescription.setDescription('User defined textual description related to this rule.')
hm2MasqIpsecExempt = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqIpsecExempt.setStatus('current')
if mibBuilder.loadTexts: hm2MasqIpsecExempt.setDescription('Set to true if application of this rule should ignore IPsec traffic.')
hm2MasqRuleIfMappingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 2), )
if mibBuilder.loadTexts: hm2MasqRuleIfMappingTable.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleIfMappingTable.setDescription('Table for mapping masquerading rules to interfaces.')
hm2MasqRuleIfMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 2, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2MasqIfmInterface"), (0, "HM2-NAT-MIB", "hm2MasqIfmDirection"), (0, "HM2-NAT-MIB", "hm2MasqIfmRuleIndex"))
if mibBuilder.loadTexts: hm2MasqRuleIfMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2MasqRuleIfMappingEntry.setDescription('Entry in rule interface mapping table.')
hm2MasqIfmRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048)))
if mibBuilder.loadTexts: hm2MasqIfmRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2MasqIfmRuleIndex.setDescription('The index of the 1:1 NAT rule this mapping entry is assigned to.')
hm2MasqIfmDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2), ("both", 3))))
if mibBuilder.loadTexts: hm2MasqIfmDirection.setStatus('current')
if mibBuilder.loadTexts: hm2MasqIfmDirection.setDescription('For masquerading, this can only be set to egress which is the interface packets will be masqueraded to.')
hm2MasqIfmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqIfmPriority.setStatus('current')
if mibBuilder.loadTexts: hm2MasqIfmPriority.setDescription("The priority is the sorting key for rules in the chain to this interface. They don't need to be unique per interface, but in that case, no clear order can be assumed. Priorities are processed in ascending order (0 highest priority).")
hm2MasqIfmInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 2, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: hm2MasqIfmInterface.setStatus('current')
if mibBuilder.loadTexts: hm2MasqIfmInterface.setDescription('The interface this mapping entry is assigned to. This has to be either an hm2AgentSwitchIpInterfaceIfIndex or an hm2AgentSwitchIpVlanIfIndex. Note that for physical interfaces this only works if the corresponding hm2AgentSwitchIpInterfaceRoutingMode is set to enable.')
hm2MasqIfmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 2, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MasqIfmRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2MasqIfmRowStatus.setDescription('The RowStatus value for this entry with the usual meanings: - active(1): The interface mapping is in place - notInService(2): The interface mapping is not in place because the user said so - notReady(3): The interface mapping is not in place because the agent said so - createAndGo(4): Create this mapping with the default priority and activate it. - createAndWait(5): Create this mapping deactivated. - destroy(6): Destroy this interface mapping.')
hm2MasqStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3))
hm2MasqGeneralStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 1))
hm2MasqStatsTotalPck = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqStatsTotalPck.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsTotalPck.setDescription('Total number of packets processed by Masquerading')
hm2MasqStatsTotalPckSize = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqStatsTotalPckSize.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsTotalPckSize.setDescription('Total number of bytes processed by Masquerading')
hm2MasqStatsTotalPckDenDrop = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqStatsTotalPckDenDrop.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsTotalPckDenDrop.setDescription('Total number of packets dropped or denied by Masquerading')
hm2MasqStatsTotalPckAccepted = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqStatsTotalPckAccepted.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsTotalPckAccepted.setDescription('Total number of packets accepted by masquerading.')
hm2MasqStatsRuleTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 2))
hm2MasqStatsRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 2, 1), )
if mibBuilder.loadTexts: hm2MasqStatsRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsRuleTable.setDescription('Table of per-rule statistics of masquerading.')
hm2MasqStatsRuleTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 2, 1, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2MasqRuleIndex"))
if mibBuilder.loadTexts: hm2MasqStatsRuleTableEntry.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsRuleTableEntry.setDescription('Statistics table entry for masquerading.')
hm2MasqStatsPckCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 2, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqStatsPckCount.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsPckCount.setDescription('Number of packets matched by this rule.')
hm2MasqStatsPckSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqStatsPckSize.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsPckSize.setDescription('Number of bytes processed by this rule.')
hm2MasqStatsLastApplied = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 5, 3, 2, 1, 1, 3), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MasqStatsLastApplied.setStatus('current')
if mibBuilder.loadTexts: hm2MasqStatsLastApplied.setDescription('Time of last application of the rule in seconds since 1.1.1970')
hm2DonatRuleAppliedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 80, 0, 9)).setObjects(("HM2-NAT-MIB", "hm2DonatRuleIndex"))
if mibBuilder.loadTexts: hm2DonatRuleAppliedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRuleAppliedTrap.setDescription('A rule of double NAT was applied. The rule is identified by the given rule index of the rule table.')
hm2DonatRuleAppliedAndLoggedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 80, 0, 10)).setObjects(("HM2-NAT-MIB", "hm2DonatRuleIndex"))
if mibBuilder.loadTexts: hm2DonatRuleAppliedAndLoggedTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRuleAppliedAndLoggedTrap.setDescription('A rule of double NAT was applied and logged according the current logging mechanism. The rule is identified by the given rule index of the rule table.')
hm2DoubleNat = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6))
hm2DoubleNatRuleObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 1))
hm2DoubleNatRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DoubleNatRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2DoubleNatRuleCount.setDescription('Current number of rules for double NAT.')
hm2DoubleNatIfMappingRuleCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DoubleNatIfMappingRuleCount.setStatus('current')
if mibBuilder.loadTexts: hm2DoubleNatIfMappingRuleCount.setDescription('Number of current double NAT IF mapping entries.')
hm2DoubleNatRulePendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DoubleNatRulePendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DoubleNatRulePendingActions.setDescription('This value describes, whether the double NAT rule table was modified but not yet written to the firewall implementation (set to true). After writing all modifications to the firewall, the value switches automatically back to false.')
hm2DoubleNatCommitPendingActions = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 1, 4), HmActionValue().clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2DoubleNatCommitPendingActions.setStatus('current')
if mibBuilder.loadTexts: hm2DoubleNatCommitPendingActions.setDescription('Setting this value to action(2) writes not yet committed changes to the firewall (double NAT and interface mapping table). After writing all modifications, the value switches automatically back to noop(1).')
hm2DoubleNatRuleTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2))
hm2DoubleNatRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1), )
if mibBuilder.loadTexts: hm2DoubleNatRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2DoubleNatRuleTable.setDescription('Table of double NAT rules.')
hm2DoubleNatRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2DonatRuleIndex"))
if mibBuilder.loadTexts: hm2DoubleNatRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DoubleNatRuleEntry.setDescription('Entry within double NAT rule table.')
hm2DonatRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2DonatRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRuleIndex.setDescription('Index of the rule within table.')
hm2DonatLocalInternalIp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatLocalInternalIp.setStatus('current')
if mibBuilder.loadTexts: hm2DonatLocalInternalIp.setDescription("The real IP address of the first net/machine you want to double NAT. Allowed formats are: - keyword 'any' - IP address ('10.0.0.1') - IP address range ('10.0.0.0/8')")
hm2DonatLocalExternalIp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatLocalExternalIp.setStatus('current')
if mibBuilder.loadTexts: hm2DonatLocalExternalIp.setDescription("The IP address where you want the first net/machine to be reachable from the second net/machine. Allowed formats are: - keyword 'any' - IP address ('10.0.0.1') - IP address range ('10.0.0.0/8')")
hm2DonatRemoteInternalIp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatRemoteInternalIp.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRemoteInternalIp.setDescription("The real IP address of the second net/machine you want to double NAT. Allowed formats are: - keyword 'any' - IP address ('10.0.0.1') - IP address range ('10.0.0.0/8')")
hm2DonatRemoteExternalIp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatRemoteExternalIp.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRemoteExternalIp.setDescription("The IP address where you want the second net/machine to be reachable from the first net/machine. Allowed formats are: - keyword 'any' - IP address ('10.0.0.1') - IP address range ('10.0.0.0/8')")
hm2DonatRuleParams = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatRuleParams.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRuleParams.setDescription("Additional parameters to this rule as string. Currently only the value 'none' is valid. Reserved for future use.")
hm2DonatLog = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatLog.setStatus('current')
if mibBuilder.loadTexts: hm2DonatLog.setDescription('Set to true if application of this rule shall be logged.')
hm2DonatTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatTrap.setStatus('current')
if mibBuilder.loadTexts: hm2DonatTrap.setDescription('Set to true if application of this rule shall send a trap.')
hm2DonatRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRowStatus.setDescription('This is a standard row status value: - active(1): The rule is active. Note that until committed, the rule will not be applied. - notInService(2): The rule is inactive because of user action. - notReady(3):The rule is inactive because it has an incomplete configuration. - createAndGo(4): Create the rule with default parameters activated. - createAndWait(5): Create the rule inactive. - destroy(6): Delete the rule. You cannot delete a rule with interface mappings to it.')
hm2DonatDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatDescription.setStatus('current')
if mibBuilder.loadTexts: hm2DonatDescription.setDescription('User defined textual description related to this rule.')
hm2DonatRuleIfMappingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 2), )
if mibBuilder.loadTexts: hm2DonatRuleIfMappingTable.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRuleIfMappingTable.setDescription('Table for mapping double NAT rules to interfaces.')
hm2DonatRuleIfMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 2, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2DonatIfmInterface"), (0, "HM2-NAT-MIB", "hm2DonatIfmDirection"), (0, "HM2-NAT-MIB", "hm2DonatIfmRuleIndex"))
if mibBuilder.loadTexts: hm2DonatRuleIfMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DonatRuleIfMappingEntry.setDescription('Entry in rule interface mapping table.')
hm2DonatIfmRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048)))
if mibBuilder.loadTexts: hm2DonatIfmRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2DonatIfmRuleIndex.setDescription('The index of the double NAT rule this mapping entry is assigned to.')
hm2DonatIfmDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2), ("both", 3))))
if mibBuilder.loadTexts: hm2DonatIfmDirection.setStatus('current')
if mibBuilder.loadTexts: hm2DonatIfmDirection.setDescription('Meanings: - ingress(1): The first net/machine can be reached through this interface - egress(2): The second net/machine can be reached through this interface - both(3): Both machines/nets can be reached through this interface')
hm2DonatIfmPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatIfmPriority.setStatus('current')
if mibBuilder.loadTexts: hm2DonatIfmPriority.setDescription("The priority is the sorting key for rules in the chain to this interface. They don't need to be unique per interface, but in that case, no clear order can be assumed. Priorities are processed in ascending order (0 highest priority).")
hm2DonatIfmInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 2, 1, 4), InterfaceIndex())
if mibBuilder.loadTexts: hm2DonatIfmInterface.setStatus('current')
if mibBuilder.loadTexts: hm2DonatIfmInterface.setDescription('The interface this mapping entry is assigned to. This has to be either an hm2AgentSwitchIpInterfaceIfIndex or an hm2AgentSwitchIpVlanIfIndex. Note that for physical interfaces this only works if the corresponding hm2AgentSwitchIpInterfaceRoutingMode is set to enable.')
hm2DonatIfmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 2, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2DonatIfmRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2DonatIfmRowStatus.setDescription('The RowStatus value for this entry with the usual meanings: - active(1): The interface mapping is in place - notInService(2): The interface mapping is not in place because the user said so - notReady(3): The interface mapping is not in place because the agent said so - createAndGo(4): Create this mapping with the default priority and activate it. - createAndWait(5): Create this mapping deactivated. - destroy(6): Destroy this interface mapping.')
hm2DonatStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3))
hm2DonatGeneralStats = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 1))
hm2DonatStatsTotalPck = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DonatStatsTotalPck.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsTotalPck.setDescription('Total number of packets processed by double NAT.')
hm2DonatStatsTotalPckSize = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DonatStatsTotalPckSize.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsTotalPckSize.setDescription('Total number of bytes processed by double NAT.')
hm2DonatStatsTotalPckDenDrop = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DonatStatsTotalPckDenDrop.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsTotalPckDenDrop.setDescription('Total number of packets dropped or denied by double NAT.')
hm2DonatStatsTotalPckAcc = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DonatStatsTotalPckAcc.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsTotalPckAcc.setDescription('Total number of packets accepted by double NAT.')
hm2DonatStatsRuleTables = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 2))
hm2DonatStatsRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 2, 1), )
if mibBuilder.loadTexts: hm2DonatStatsRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsRuleTable.setDescription('Table of per-rule statistics of double NAT.')
hm2DonatStatsRuleTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 2, 1, 1), ).setIndexNames((0, "HM2-NAT-MIB", "hm2DonatRuleIndex"))
if mibBuilder.loadTexts: hm2DonatStatsRuleTableEntry.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsRuleTableEntry.setDescription('Statistics table entry for double NAT.')
hm2DonatStatsPckCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 2, 1, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DonatStatsPckCount.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsPckCount.setDescription('Number of packets matched by this rule.')
hm2DonatStatsPckSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 2, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DonatStatsPckSize.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsPckSize.setDescription('Number of bytes processed by this rule.')
hm2DonatStatsLastApplied = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 80, 1, 6, 3, 2, 1, 1, 3), HmTimeSeconds1970()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2DonatStatsLastApplied.setStatus('current')
if mibBuilder.loadTexts: hm2DonatStatsLastApplied.setDescription('Time of last application of the rule in seconds since 1.1.1970.')
hm2NatCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 2, 1))
hm2NatGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 80, 2, 2))
hm2NatCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 248, 11, 80, 2, 1, 1)).setObjects(("HM2-NAT-MIB", "hm2NatGeneralGroup"), ("HM2-NAT-MIB", "hm2NatNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2NatCompliance = hm2NatCompliance.setStatus('current')
if mibBuilder.loadTexts: hm2NatCompliance.setDescription('The compliance statement for an SNMP entity which implements the Hirschmann NAT MIB.')
hm2NatGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 11, 80, 2, 2, 1)).setObjects(("HM2-NAT-MIB", "hm2DnatMaxRules"), ("HM2-NAT-MIB", "hm2OneToOneNatMaxRules"), ("HM2-NAT-MIB", "hm2DoubleNatMaxRules"), ("HM2-NAT-MIB", "hm2MasqMaxRules"), ("HM2-NAT-MIB", "hm2NatResetStatistics"), ("HM2-NAT-MIB", "hm2DnatIfMappingRuleCount"), ("HM2-NAT-MIB", "hm2DnatRulePendingActions"), ("HM2-NAT-MIB", "hm2DnatCommitPendingActions"), ("HM2-NAT-MIB", "hm2DnatRuleCount"), ("HM2-NAT-MIB", "hm2DnatRuleIndex"), ("HM2-NAT-MIB", "hm2DnatSourceAddress"), ("HM2-NAT-MIB", "hm2DnatSourcePort"), ("HM2-NAT-MIB", "hm2DnatTargetAddress"), ("HM2-NAT-MIB", "hm2DnatTargetPort"), ("HM2-NAT-MIB", "hm2DnatNewTargetAddress"), ("HM2-NAT-MIB", "hm2DnatNewTargetPort"), ("HM2-NAT-MIB", "hm2DnatProto"), ("HM2-NAT-MIB", "hm2DnatRuleParams"), ("HM2-NAT-MIB", "hm2DnatLog"), ("HM2-NAT-MIB", "hm2DnatTrap"), ("HM2-NAT-MIB", "hm2DnatDescription"), ("HM2-NAT-MIB", "hm2DnatRowStatus"), ("HM2-NAT-MIB", "hm2DnatIfmPriority"), ("HM2-NAT-MIB", "hm2DnatIfmRowStatus"), ("HM2-NAT-MIB", "hm2DnatStatsPckCount"), ("HM2-NAT-MIB", "hm2DnatStatsPckSize"), ("HM2-NAT-MIB", "hm2DnatStatsLastApplied"), ("HM2-NAT-MIB", "hm2DnatStatsTotalPck"), ("HM2-NAT-MIB", "hm2DnatStatsTotalPckSize"), ("HM2-NAT-MIB", "hm2DnatStatsTotalPckDenDrop"), ("HM2-NAT-MIB", "hm2DnatStatsTotalPckAccepted"), ("HM2-NAT-MIB", "hm21to1IfMappingRuleCount"), ("HM2-NAT-MIB", "hm21to1RulePendingActions"), ("HM2-NAT-MIB", "hm21to1CommitPendingActions"), ("HM2-NAT-MIB", "hm21to1RuleCount"), ("HM2-NAT-MIB", "hm21to1RuleIndex"), ("HM2-NAT-MIB", "hm21to1TargetAddress"), ("HM2-NAT-MIB", "hm21to1NewTargetAddress"), ("HM2-NAT-MIB", "hm21to1RuleParams"), ("HM2-NAT-MIB", "hm21to1Log"), ("HM2-NAT-MIB", "hm21to1Trap"), ("HM2-NAT-MIB", "hm21to1Description"), ("HM2-NAT-MIB", "hm21to1IngressIntf"), ("HM2-NAT-MIB", "hm21to1EgressIntf"), ("HM2-NAT-MIB", "hm21to1Priority"), ("HM2-NAT-MIB", "hm21to1RowStatus"), ("HM2-NAT-MIB", "hm21to1StatsPckCount"), ("HM2-NAT-MIB", "hm21to1StatsPckSize"), ("HM2-NAT-MIB", "hm21to1StatsLastApplied"), ("HM2-NAT-MIB", "hm21to1StatsTotalPck"), ("HM2-NAT-MIB", "hm21to1StatsTotalPckSize"), ("HM2-NAT-MIB", "hm21to1StatsTotalPckDenDrop"), ("HM2-NAT-MIB", "hm21to1StatsTotalPckAccepted"), ("HM2-NAT-MIB", "hm2MasqIfMappingRuleCount"), ("HM2-NAT-MIB", "hm2MasqRulePendingActions"), ("HM2-NAT-MIB", "hm2MasqCommitPendingActions"), ("HM2-NAT-MIB", "hm2MasqRuleCount"), ("HM2-NAT-MIB", "hm2MasqRuleIndex"), ("HM2-NAT-MIB", "hm2MasqSourceAddress"), ("HM2-NAT-MIB", "hm2MasqSourcePort"), ("HM2-NAT-MIB", "hm2MasqProto"), ("HM2-NAT-MIB", "hm2MasqRuleParams"), ("HM2-NAT-MIB", "hm2MasqLog"), ("HM2-NAT-MIB", "hm2MasqTrap"), ("HM2-NAT-MIB", "hm2MasqDescription"), ("HM2-NAT-MIB", "hm2MasqRowStatus"), ("HM2-NAT-MIB", "hm2MasqIfmPriority"), ("HM2-NAT-MIB", "hm2MasqIfmRowStatus"), ("HM2-NAT-MIB", "hm2MasqStatsPckCount"), ("HM2-NAT-MIB", "hm2MasqStatsPckSize"), ("HM2-NAT-MIB", "hm2MasqStatsLastApplied"), ("HM2-NAT-MIB", "hm2MasqStatsTotalPck"), ("HM2-NAT-MIB", "hm2MasqStatsTotalPckSize"), ("HM2-NAT-MIB", "hm2MasqStatsTotalPckDenDrop"), ("HM2-NAT-MIB", "hm2MasqStatsTotalPckAccepted"), ("HM2-NAT-MIB", "hm2DoubleNatIfMappingRuleCount"), ("HM2-NAT-MIB", "hm2DoubleNatRulePendingActions"), ("HM2-NAT-MIB", "hm2DoubleNatCommitPendingActions"), ("HM2-NAT-MIB", "hm2DoubleNatRuleCount"), ("HM2-NAT-MIB", "hm2DonatRuleIndex"), ("HM2-NAT-MIB", "hm2DonatLocalInternalIp"), ("HM2-NAT-MIB", "hm2DonatLocalExternalIp"), ("HM2-NAT-MIB", "hm2DonatRemoteInternalIp"), ("HM2-NAT-MIB", "hm2DonatRemoteExternalIp"), ("HM2-NAT-MIB", "hm2DonatRuleParams"), ("HM2-NAT-MIB", "hm2DonatLog"), ("HM2-NAT-MIB", "hm2DonatTrap"), ("HM2-NAT-MIB", "hm2DonatDescription"), ("HM2-NAT-MIB", "hm2DonatIfmPriority"), ("HM2-NAT-MIB", "hm2DonatIfmRowStatus"), ("HM2-NAT-MIB", "hm2DonatRowStatus"), ("HM2-NAT-MIB", "hm2DonatStatsPckCount"), ("HM2-NAT-MIB", "hm2DonatStatsPckSize"), ("HM2-NAT-MIB", "hm2DonatStatsLastApplied"), ("HM2-NAT-MIB", "hm2DonatStatsTotalPck"), ("HM2-NAT-MIB", "hm2DonatStatsTotalPckSize"), ("HM2-NAT-MIB", "hm2DonatStatsTotalPckDenDrop"), ("HM2-NAT-MIB", "hm2DonatStatsTotalPckAcc"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2NatGeneralGroup = hm2NatGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: hm2NatGeneralGroup.setDescription('A collection of all Hirschmann objects provided by the Firewall module.')
hm2NatNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 248, 11, 80, 2, 2, 2)).setObjects(("HM2-NAT-MIB", "hm2DnatRuleAppliedTrap"), ("HM2-NAT-MIB", "hm2DnatRuleAppliedAndLoggedTrap"), ("HM2-NAT-MIB", "hm21to1RuleAppliedTrap"), ("HM2-NAT-MIB", "hm21to1RuleAppliedAndLoggedTrap"), ("HM2-NAT-MIB", "hm2MasqRuleAppliedTrap"), ("HM2-NAT-MIB", "hm2MasqRuleAppliedAndLoggedTrap"), ("HM2-NAT-MIB", "hm2DonatRuleAppliedTrap"), ("HM2-NAT-MIB", "hm2DonatRuleAppliedAndLoggedTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2NatNotificationsGroup = hm2NatNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: hm2NatNotificationsGroup.setDescription('A collection of all Hirschmann notifications provided by the NAT module.')
mibBuilder.exportSymbols("HM2-NAT-MIB", hm2DnatStatsTotalPckAccepted=hm2DnatStatsTotalPckAccepted, hm2DnatRuleStats=hm2DnatRuleStats, hm2DonatRowStatus=hm2DonatRowStatus, hm2MasqIfmRowStatus=hm2MasqIfmRowStatus, hm2NatResetStatistics=hm2NatResetStatistics, hm2MasqStatsRuleTables=hm2MasqStatsRuleTables, hm2DonatRemoteExternalIp=hm2DonatRemoteExternalIp, hm2MasqStatsTotalPckAccepted=hm2MasqStatsTotalPckAccepted, hm2MasqGeneralStats=hm2MasqGeneralStats, hm21to1Log=hm21to1Log, hm2DnatNewTargetPort=hm2DnatNewTargetPort, hm21to1CommitPendingActions=hm21to1CommitPendingActions, hm2MasqRulePendingActions=hm2MasqRulePendingActions, hm2DoubleNatRulePendingActions=hm2DoubleNatRulePendingActions, hm2MasqIfmPriority=hm2MasqIfmPriority, hm2DonatStatsTotalPckDenDrop=hm2DonatStatsTotalPckDenDrop, hm2DnatRuleIndex=hm2DnatRuleIndex, hm2DonatStatsTotalPckSize=hm2DonatStatsTotalPckSize, hm2MasqTrap=hm2MasqTrap, hm2DnatRuleIfMappingEntry=hm2DnatRuleIfMappingEntry, hm2DnatIfmDirection=hm2DnatIfmDirection, hm2DonatStatsRuleTableEntry=hm2DonatStatsRuleTableEntry, hm2DoubleNatIfMappingRuleCount=hm2DoubleNatIfMappingRuleCount, hm2NatMib=hm2NatMib, PYSNMP_MODULE_ID=hm2NatMib, hm2DoubleNatRuleTable=hm2DoubleNatRuleTable, hm21to1RuleTable=hm21to1RuleTable, hm2DnatStatsLastApplied=hm2DnatStatsLastApplied, hm2DonatIfmDirection=hm2DonatIfmDirection, hm2DnatRuleAppliedAndLoggedTrap=hm2DnatRuleAppliedAndLoggedTrap, hm2DonatIfmPriority=hm2DonatIfmPriority, hm2MasqRuleAppliedAndLoggedTrap=hm2MasqRuleAppliedAndLoggedTrap, hm2DnatTargetPort=hm2DnatTargetPort, hm21to1StatsTotalPck=hm21to1StatsTotalPck, hm2DnatStatsPckCount=hm2DnatStatsPckCount, hm2NatObjects=hm2NatObjects, hm2DnatStatsTotalPckSize=hm2DnatStatsTotalPckSize, hm2MasqRuleIndex=hm2MasqRuleIndex, hm2MasqRuleEntry=hm2MasqRuleEntry, hm2MasqStatsLastApplied=hm2MasqStatsLastApplied, hm2DoubleNatRuleObjects=hm2DoubleNatRuleObjects, hm2NatGroups=hm2NatGroups, hm21to1StorageType=hm21to1StorageType, hm2NatNotifications=hm2NatNotifications, hm2MasqStatsPckSize=hm2MasqStatsPckSize, hm2DnatMaxRules=hm2DnatMaxRules, hm2DnatRowStatus=hm2DnatRowStatus, hm2DonatStatsPckCount=hm2DonatStatsPckCount, hm2DnatLog=hm2DnatLog, hm2DonatStatsTotalPckAcc=hm2DonatStatsTotalPckAcc, hm2DonatLog=hm2DonatLog, hm2DnatRuleParams=hm2DnatRuleParams, hm21to1Description=hm21to1Description, hm2DoubleNatCommitPendingActions=hm2DoubleNatCommitPendingActions, hm21to1RuleCount=hm21to1RuleCount, hm21to1RuleEntry=hm21to1RuleEntry, hm2MasqStatsRuleTable=hm2MasqStatsRuleTable, hm2DnatStatsTotalPck=hm2DnatStatsTotalPck, hm2DonatStatsTotalPck=hm2DonatStatsTotalPck, hm21to1IfMappingRuleCount=hm21to1IfMappingRuleCount, hm2DnatStatsPckSize=hm2DnatStatsPckSize, hm21to1EgressIntf=hm21to1EgressIntf, hm2DnatTrap=hm2DnatTrap, hm2DnatRuleAppliedTrap=hm2DnatRuleAppliedTrap, hm2DnatStatsRuleTableEntry=hm2DnatStatsRuleTableEntry, hm2Masquerading=hm2Masquerading, hm2MasqRuleTables=hm2MasqRuleTables, hm2DonatLocalExternalIp=hm2DonatLocalExternalIp, hm2DonatRuleAppliedAndLoggedTrap=hm2DonatRuleAppliedAndLoggedTrap, hm2MasqRuleTable=hm2MasqRuleTable, hm2DnatStatsRuleTable=hm2DnatStatsRuleTable, hm2DonatTrap=hm2DonatTrap, hm2DonatStatsPckSize=hm2DonatStatsPckSize, hm21to1Stats=hm21to1Stats, hm2DonatIfmRowStatus=hm2DonatIfmRowStatus, hm2DnatRuleTable=hm2DnatRuleTable, hm2MasqIfMappingRuleCount=hm2MasqIfMappingRuleCount, hm21to1Trap=hm21to1Trap, hm2MasqRuleParams=hm2MasqRuleParams, hm2DnatDescription=hm2DnatDescription, hm2MasqSourceAddress=hm2MasqSourceAddress, hm21to1RuleAppliedTrap=hm21to1RuleAppliedTrap, hm21to1RuleTables=hm21to1RuleTables, hm2MasqStatsRuleTableEntry=hm2MasqStatsRuleTableEntry, hm2DnatStats=hm2DnatStats, hm2MasqRuleAppliedTrap=hm2MasqRuleAppliedTrap, hm2NatNotificationsGroup=hm2NatNotificationsGroup, hm2NatCompliance=hm2NatCompliance, hm21to1StatsTables=hm21to1StatsTables, hm2DonatIfmInterface=hm2DonatIfmInterface, hm2DnatRulePendingActions=hm2DnatRulePendingActions, hm2DonatRuleParams=hm2DonatRuleParams, hm2DnatGlobalStats=hm2DnatGlobalStats, hm2DnatRuleEntry=hm2DnatRuleEntry, hm2MasqRuleIfMappingTable=hm2MasqRuleIfMappingTable, hm2Dnat=hm2Dnat, hm2MasqSourcePort=hm2MasqSourcePort, hm2DoubleNatRuleEntry=hm2DoubleNatRuleEntry, hm2DonatRuleIndex=hm2DonatRuleIndex, hm21to1StatsRuleTableEntry=hm21to1StatsRuleTableEntry, hm2DnatIfmRuleIndex=hm2DnatIfmRuleIndex, hm2DonatStatsRuleTable=hm2DonatStatsRuleTable, hm2DnatSourcePort=hm2DnatSourcePort, hm2MasqIfmDirection=hm2MasqIfmDirection, hm21to1GeneralStats=hm21to1GeneralStats, hm2DonatStats=hm2DonatStats, hm2MasqCommitPendingActions=hm2MasqCommitPendingActions, hm2MasqStatsTotalPckSize=hm2MasqStatsTotalPckSize, hm21to1Alg=hm21to1Alg, hm2DnatStatsTotalPckDenDrop=hm2DnatStatsTotalPckDenDrop, hm2MasqStatsPckCount=hm2MasqStatsPckCount, hm21to1Priority=hm21to1Priority, hm21to1StatsTotalPckAccepted=hm21to1StatsTotalPckAccepted, hm2DnatTargetAddress=hm2DnatTargetAddress, hm2DonatRemoteInternalIp=hm2DonatRemoteInternalIp, hm21to1RuleIndex=hm21to1RuleIndex, hm2NatConformance=hm2NatConformance, hm2DnatIfmInterface=hm2DnatIfmInterface, hm2MasqLog=hm2MasqLog, hm2NatGeneralGroup=hm2NatGeneralGroup, hm2DnatCommitPendingActions=hm2DnatCommitPendingActions, hm2DoubleNatMaxRules=hm2DoubleNatMaxRules, hm2DnatProto=hm2DnatProto, hm21to1RulePendingActions=hm21to1RulePendingActions, hm21to1NewTargetAddress=hm21to1NewTargetAddress, hm21to1=hm21to1, hm21to1TargetAddress=hm21to1TargetAddress, hm2MasqRuleObjects=hm2MasqRuleObjects, hm2DonatRuleIfMappingTable=hm2DonatRuleIfMappingTable, hm21to1RuleAppliedAndLoggedTrap=hm21to1RuleAppliedAndLoggedTrap, hm2DnatIfmRowStatus=hm2DnatIfmRowStatus, hm21to1PublicIntf=hm21to1PublicIntf, hm2MasqRuleCount=hm2MasqRuleCount, hm2DnatIfmPriority=hm2DnatIfmPriority, hm2MasqRowStatus=hm2MasqRowStatus, hm21to1RuleParams=hm21to1RuleParams, hm2MasqStatsTotalPckDenDrop=hm2MasqStatsTotalPckDenDrop, hm2DonatDescription=hm2DonatDescription, hm2DnatRuleCount=hm2DnatRuleCount, hm2MasqIfmInterface=hm2MasqIfmInterface, hm2DonatLocalInternalIp=hm2DonatLocalInternalIp, hm2DnatRulesTables=hm2DnatRulesTables, hm21to1StatsRuleTable=hm21to1StatsRuleTable, hm2DnatRuleIfMappingTable=hm2DnatRuleIfMappingTable, hm21to1StatsTotalPckSize=hm21to1StatsTotalPckSize, hm2NatCompliances=hm2NatCompliances, hm2OneToOneNatMaxRules=hm2OneToOneNatMaxRules, hm2DoubleNatRuleCount=hm2DoubleNatRuleCount, hm2MasqIfmRuleIndex=hm2MasqIfmRuleIndex, hm2MasqRuleIfMappingEntry=hm2MasqRuleIfMappingEntry, hm2DonatIfmRuleIndex=hm2DonatIfmRuleIndex, hm21to1StatsLastApplied=hm21to1StatsLastApplied, hm2DnatSourceAddress=hm2DnatSourceAddress, hm2DnatIfMappingRuleCount=hm2DnatIfMappingRuleCount, hm2DnatRulesObjects=hm2DnatRulesObjects, hm2DonatStatsRuleTables=hm2DonatStatsRuleTables, hm2DnatRules=hm2DnatRules, hm2DoubleNatRuleTables=hm2DoubleNatRuleTables, hm2DonatRuleAppliedTrap=hm2DonatRuleAppliedTrap, hm21to1RuleObjects=hm21to1RuleObjects, hm2NatGeneralSettings=hm2NatGeneralSettings, hm2DnatNewTargetAddress=hm2DnatNewTargetAddress, hm21to1StatsTotalPckDenDrop=hm21to1StatsTotalPckDenDrop, hm2DonatGeneralStats=hm2DonatGeneralStats, hm2DonatStatsLastApplied=hm2DonatStatsLastApplied, hm2MasqMaxRules=hm2MasqMaxRules, hm2MasqDescription=hm2MasqDescription, hm21to1RowStatus=hm21to1RowStatus, hm21to1IngressIntf=hm21to1IngressIntf, hm2DonatRuleIfMappingEntry=hm2DonatRuleIfMappingEntry, hm21to1StatsPckSize=hm21to1StatsPckSize, hm2MasqStatsTotalPck=hm2MasqStatsTotalPck, hm21to1StatsPckCount=hm21to1StatsPckCount, hm2MasqStats=hm2MasqStats, hm2MasqIpsecExempt=hm2MasqIpsecExempt, hm2MasqProto=hm2MasqProto, hm2DoubleNat=hm2DoubleNat)

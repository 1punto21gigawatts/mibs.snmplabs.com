#
# PySNMP MIB module SMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:46:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
OwnerString, rmon = mibBuilder.importSymbols("RMON-MIB", "OwnerString", "rmon")
probeConfig, DataSource, LastCreateTime, rmonConformance = mibBuilder.importSymbols("RMON2-MIB", "probeConfig", "DataSource", "LastCreateTime", "rmonConformance")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
ModuleIdentity, iso, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, MibIdentifier, Unsigned32, Bits, NotificationType, Integer32, Counter32, Counter64, Gauge32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "iso", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "MibIdentifier", "Unsigned32", "Bits", "NotificationType", "Integer32", "Counter32", "Counter64", "Gauge32", "TimeTicks")
TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus")
switchRMON = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 22))
if mibBuilder.loadTexts: switchRMON.setLastUpdated('9812160000Z')
if mibBuilder.loadTexts: switchRMON.setOrganization('IETF RMON MIB Working Group')
if mibBuilder.loadTexts: switchRMON.setContactInfo('IETF RMONMIB WG Mailing list: rmonmib@cisco.com Rich Waterman Allot Networks Inc. Tel: +1-408-559-0253 Email: rich@allot.com Bill Lahaye Xylan Corp. Tel: +1-800-995-2612 Email: lahaye@ctron.com Dan Romascanu Lucent Technologies Tel: +972-3-645-8414 Email: dromasca@lucent.com Steven Waldbusser International Network Services Tel: +1-415-254-4251 Email: waldbusser@ins.com')
if mibBuilder.loadTexts: switchRMON.setDescription('The MIB module for managing remote monitoring device implementations for Switched Networks')
smonMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 22, 1))
dataSourceCaps = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 22, 1, 1))
smonStats = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 22, 1, 2))
portCopyConfig = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 22, 1, 3))
smonRegistrationPoints = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 22, 1, 4))
class SmonDataSource(TextualConvention, ObjectIdentifier):
    description = "Identifies the source of the data that the associated function is configured to analyze. This Textual Convention extends the DataSource Textual Convention defined by RMON 2 to the following data source types: - ifIndex.<I> DataSources of this traditional form are called 'port-based', but only if ifType.<I> is not equal to 'propVirtual(53)'. - smonVlanDataSource.<V> A dataSource of this form refers to a 'Packet-based VLAN' and is called a 'VLAN-based' dataSource. <V> is the VLAN ID as defined by the IEEE 802.1Q standard [19]. The value is between 1 and 4094 inclusive, and it represents an 802.1Q VLAN-ID with global scope within a given bridged domain, as defined by [19]. - entPhysicalEntry.<N> A dataSource of this form refers to a physical entity within the agent (e.g. entPhysicalClass = backplane(4)) and is called an 'entity-based' dataSource."
    status = 'current'

smonCapabilities = MibScalar((1, 3, 6, 1, 2, 1, 16, 19, 15), Bits().clone(namedValues=NamedValues(("smonVlanStats", 0), ("smonPrioStats", 1), ("dataSource", 2), ("smonUnusedBit", 3), ("portCopy", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smonCapabilities.setStatus('current')
if mibBuilder.loadTexts: smonCapabilities.setDescription('An indication of the SMON MIB groups supported by this agent.')
dataSourceCapsTable = MibTable((1, 3, 6, 1, 2, 1, 16, 22, 1, 1, 1), )
if mibBuilder.loadTexts: dataSourceCapsTable.setStatus('current')
if mibBuilder.loadTexts: dataSourceCapsTable.setDescription("This table describes RMON data sources and port copy capabilities. An NMS MAY use this table to discover the identity and attributes of the data sources on a given agent implementation. Similar to the probeCapabilities object, actual row-creation operations will succeed or fail based on the resources available and parameter values used in each row-creation operation. Upon restart of the RMON agent, the dataSourceTable, ifTable, and perhaps entPhysicalTable are initialized for the available dataSources. For each dataSourceCapsEntry representing a VLAN or entPhysicalEntry the agent MUST create an associated ifEntry with a ifType value of 'propVirtual(53)'. This ifEntry will be used as the actual value in RMON control table dataSource objects. The assigned ifIndex value is copied into the associated dataSourceCapsIfIndex object. It is understood that dataSources representing VLANs may not always be instantiated immediately upon restart, but rather as VLAN usage is detected by the agent. The agent SHOULD attempt to create dataSource and interface entries for all dataSources as soon as possible.")
dataSourceCapsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 22, 1, 1, 1, 1), ).setIndexNames((1, "SMON-MIB", "dataSourceCapsObject"))
if mibBuilder.loadTexts: dataSourceCapsEntry.setStatus('current')
if mibBuilder.loadTexts: dataSourceCapsEntry.setDescription('Entries per data source containing descriptions of data source and port copy capabilities. This table is populated by the SMON agent with one entry for each supported data source.')
dataSourceCapsObject = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 1, 1, 1, 1), SmonDataSource())
if mibBuilder.loadTexts: dataSourceCapsObject.setStatus('current')
if mibBuilder.loadTexts: dataSourceCapsObject.setDescription('Defines an object that can be a SMON data source or a source or a destination for a port copy operation.')
dataSourceRmonCaps = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 1, 1, 1, 2), Bits().clone(namedValues=NamedValues(("countErrFrames", 0), ("countAllGoodFrames", 1), ("countAnyRmonTables", 2), ("babyGiantsCountAsGood", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataSourceRmonCaps.setStatus('current')
if mibBuilder.loadTexts: dataSourceRmonCaps.setDescription(" General attributes of the specified dataSource. Note that these are static attributes, which SHOULD NOT be adjusted because of current resources or configuration. - countErrFrames(0) The agent sets this bit for the dataSource if errored frames received on this dataSource can actually be monitored by the agent The agent clears this bit if any errored frames are not visible to the RMON data collector. - countAllGoodFrames(1) The agent sets this bit for the dataSource if all good frames received on this dataSource can actually be monitored by the agent. The agent clears this bit if any good frames are not visible for RMON collection, e.g., the dataSource is a non-promiscuous interface or an internal switch interface which may not receive frames which were switched in hardware or dropped by the bridge forwarding function. - countAnyRmonTables(2) The agent sets this bit if this dataSource can actually be used in any of the implemented RMON tables, resources notwithstanding. The agent clears this bit if this dataSourceCapsEntry is present simply to identify a dataSource that may only be used as portCopySource and/or a portCopyDest, but not the source of an actual RMON data collection. - babyGiantsCountAsGood(3) The agent sets this bit if it can distinguish, for counting purposes, between true giant frames and frames that exceed Ethernet maximum frame size 1518 due to VLAN tagging ('baby giants'). Specifically, this BIT means that frames up to 1522 octets are counted as good. Agents not capable of detecting 'baby giants' will clear this bit and will view all frames less than or equal to 1518 octets as 'good frames' and all frames larger than 1518 octets as 'bad frames' for the purpose of counting in the smonVlanIdStats and smonPrioStats tables. Agents capable of detecting 'baby giants' SHALL consider them as 'good frames' for the purpose of counting in the smonVlanIdStats and smonPrioStats tables.")
dataSourceCopyCaps = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 1, 1, 1, 3), Bits().clone(namedValues=NamedValues(("copySourcePort", 0), ("copyDestPort", 1), ("copySrcTxTraffic", 2), ("copySrcRxTraffic", 3), ("countDestDropEvents", 4), ("copyErrFrames", 5), ("copyUnalteredFrames", 6), ("copyAllGoodFrames", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataSourceCopyCaps.setStatus('current')
if mibBuilder.loadTexts: dataSourceCopyCaps.setDescription('PortCopy function capabilities of the specified dataSource. Note that these are static capabilities, which SHOULD NOT be adjusted because of current resources or configuration. - copySourcePort(0) The agent sets this bit if this dataSource is capable of acting as a source of a portCopy operation. The agent clears this bit otherwise. - copyDestPort(1) The agent sets this bit if this dataSource is capable of acting as a destination of a portCopy operation. The agent clears this bit otherwise. - copySrcTxTraffic(2) If the copySourcePort bit is set: The agent sets this bit if this dataSource is capable of copying frames transmitted out this portCopy source. The agent clears this bit otherwise. This function is needed to support full-duplex ports. Else: this bit SHOULD be cleared. - copySrcRxTraffic(3) If the copySourcePort bit is set: The agent sets this bit if this dataSource is capable of copying frames received on this portCopy source. The agent clears this bit otherwise. This function is needed to support full-duplex ports. Else: this bit SHOULD be cleared. - countDestDropEvents(4) If the copyDestPort bit is set: The agent sets this bit if it is capable of incrementing portCopyDestDropEvents, when this dataSource is the target of a portCopy operation and a frame destined to this dataSource is dropped (for RMON counting purposes). Else: this BIT SHOULD be cleared. - copyErrFrames(5) If the copySourcePort bit is set: The agent sets this bit if it is capable of copying all errored frames from this portCopy source-port, for errored frames received on this dataSource. Else: this BIT SHOULD be cleared. - copyUnalteredFrames(6) If the copySourcePort bit is set: The agent sets the copyUnalteredFrames bit If it is capable of copying all frames from this portCopy source-port without alteration in any way; Else: this bit SHOULD be cleared. - copyAllGoodFrames(7) If the copySourcePort bit is set: The agent sets this bit for the dataSource if all good frames received on this dataSource are normally capable of being copied by the agent. The agent clears this bit if any good frames are not visible for the RMON portCopy operation, e.g., the dataSource is a non-promiscuous interface or an internal switch interface which may not receive frames which were switched in hardware or dropped by the bridge forwarding function. Else: this bit SHOULD be cleared.')
dataSourceCapsIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 1, 1, 1, 4), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataSourceCapsIfIndex.setStatus('current')
if mibBuilder.loadTexts: dataSourceCapsIfIndex.setDescription("This object contains the ifIndex value of the ifEntry associated with this smonDataSource. The agent MUST create 'propVirtual' ifEntries for each dataSourceCapsEntry of type VLAN or entPhysicalEntry.")
smonVlanStatsControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 1), )
if mibBuilder.loadTexts: smonVlanStatsControlTable.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsControlTable.setDescription('Controls the setup of VLAN statistics tables. The statistics collected represent a distribution based on the IEEE 802.1Q VLAN-ID (VID), for each good frame attributed to the data source for the collection.')
smonVlanStatsControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 1, 1), ).setIndexNames((0, "SMON-MIB", "smonVlanStatsControlIndex"))
if mibBuilder.loadTexts: smonVlanStatsControlEntry.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsControlEntry.setDescription('A conceptual row in the smonVlanStatsControlTable.')
smonVlanStatsControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: smonVlanStatsControlIndex.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsControlIndex.setDescription('A unique arbitrary index for this smonVlanStatsControlEntry.')
smonVlanStatsControlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 1, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smonVlanStatsControlDataSource.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsControlDataSource.setDescription('The source of data for this set of VLAN statistics. This object MAY NOT be modified if the associated smonVlanStatsControlStatus object is equal to active(1).')
smonVlanStatsControlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 1, 1, 3), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanStatsControlCreateTime.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsControlCreateTime.setDescription('The value of sysUpTime when this control entry was last activated. This object allows to a management station to detect deletion and recreation cycles between polls.')
smonVlanStatsControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 1, 1, 4), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smonVlanStatsControlOwner.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsControlOwner.setDescription('Administratively assigned named of the owner of this entry. It usually defines the entity that created this entry and is therefore using the resources assigned to it, though there is no enforcement mechanism, nor assurance that rows created are ever used.')
smonVlanStatsControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smonVlanStatsControlStatus.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsControlStatus.setDescription('The status of this row. An entry MAY NOT exist in the active state unless all objects in the entry have an appropriate value. If this object is not equal to active(1), all associated entries in the smonVlanIdStatsTable SHALL be deleted.')
smonVlanIdStatsTable = MibTable((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2), )
if mibBuilder.loadTexts: smonVlanIdStatsTable.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsTable.setDescription('Contains the VLAN statistics data. The statistics collected represent a distribution based on the IEEE 802.1Q VLAN-ID (VID), for each good frame attributed to the data source for the collection. This function applies the same rules for attributing frames to VLAN-based collections. RMON VLAN statistics are collected after the Ingress Rules defined in section 3.13 of the VLAN Specification [20] are applied. It is possible that entries in this table will be garbage-collected, based on agent resources, and VLAN configuration. Agents are encouraged to support all 4094 index values and not garbage collect this table.')
smonVlanIdStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1), ).setIndexNames((0, "SMON-MIB", "smonVlanStatsControlIndex"), (0, "SMON-MIB", "smonVlanIdStatsId"))
if mibBuilder.loadTexts: smonVlanIdStatsEntry.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsEntry.setDescription('A conceptual row in smonVlanIdStatsTable.')
smonVlanIdStatsId = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: smonVlanIdStatsId.setReference('Draft Standard for Virtual Bridged Local Area Networks, P802.1Q/D10, chapter 3.13')
if mibBuilder.loadTexts: smonVlanIdStatsId.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsId.setDescription('The unique identifier of the VLAN monitored for this specific statistics collection. Tagged packets match the VID for the range between 1 and 4094. An external RMON probe MAY detect VID=0 on an Inter Switch Link, in which case the packet belongs to a VLAN determined by the PVID of the ingress port. The VLAN to which such a packet belongs can be determined only by a RMON probe internal to the switch.')
smonVlanIdStatsTotalPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 2), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsTotalPkts.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsTotalPkts.setDescription('The total number of packets counted on this VLAN.')
smonVlanIdStatsTotalOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 3), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsTotalOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsTotalOverflowPkts.setDescription('The number of times the associated smonVlanIdStatsTotalPkts counter has overflowed.')
smonVlanIdStatsTotalHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 4), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsTotalHCPkts.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsTotalHCPkts.setDescription('The total number of packets counted on this VLAN.')
smonVlanIdStatsTotalOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 5), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsTotalOctets.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsTotalOctets.setDescription('The total number of octets counted on this VLAN.')
smonVlanIdStatsTotalOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 6), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsTotalOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsTotalOverflowOctets.setDescription('The number of times the associated smonVlanIdStatsTotalOctets counter has overflowed.')
smonVlanIdStatsTotalHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 7), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsTotalHCOctets.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsTotalHCOctets.setDescription('The total number of octets counted on this VLAN.')
smonVlanIdStatsNUcastPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 8), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsNUcastPkts.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsNUcastPkts.setDescription('The total number of non-unicast packets counted on this VLAN.')
smonVlanIdStatsNUcastOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 9), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsNUcastOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsNUcastOverflowPkts.setDescription('The number of times the associated smonVlanIdStatsNUcastPkts counter has overflowed.')
smonVlanIdStatsNUcastHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 10), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsNUcastHCPkts.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsNUcastHCPkts.setDescription('The total number of non-unicast packets counted on this VLAN.')
smonVlanIdStatsNUcastOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 11), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsNUcastOctets.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsNUcastOctets.setDescription('The total number of non-unicast octets counted on this VLAN.')
smonVlanIdStatsNUcastOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 12), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsNUcastOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsNUcastOverflowOctets.setDescription('The number of times the associated smonVlanIdStatsNUcastOctets counter has overflowed.')
smonVlanIdStatsNUcastHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 13), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsNUcastHCOctets.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsNUcastHCOctets.setDescription('The total number of Non-unicast octets counted on this VLAN.')
smonVlanIdStatsCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 2, 1, 14), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smonVlanIdStatsCreateTime.setStatus('current')
if mibBuilder.loadTexts: smonVlanIdStatsCreateTime.setDescription('The value of sysUpTime when this entry was last activated. This object allows to a management station to detect deletion and recreation cycles between polls.')
smonPrioStatsControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 3), )
if mibBuilder.loadTexts: smonPrioStatsControlTable.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsControlTable.setDescription('Controls the setup of priority statistics tables. The smonPrioStatsControlTable allows configuration of collections based on the value of the 3-bit user priority field encoded in the Tag Control Information (TCI) field according to [19],[20]. Note that this table merely reports priority as encoded in the VLAN headers, not the priority (if any) given to the frame for the actual switching purposes.')
smonPrioStatsControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 3, 1), ).setIndexNames((0, "SMON-MIB", "smonPrioStatsControlIndex"))
if mibBuilder.loadTexts: smonPrioStatsControlEntry.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsControlEntry.setDescription('A conceptual row in the smonPrioStatsControlTable.')
smonPrioStatsControlIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: smonPrioStatsControlIndex.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsControlIndex.setDescription('A unique arbitrary index for this smonPrioStatsControlEntry.')
smonPrioStatsControlDataSource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 3, 1, 2), DataSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smonPrioStatsControlDataSource.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsControlDataSource.setDescription('The source of data for this set of VLAN statistics. This object MAY NOT be modified if the associated smonPrioStatsControlStatus object is equal to active(1).')
smonPrioStatsControlCreateTime = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 3, 1, 3), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smonPrioStatsControlCreateTime.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsControlCreateTime.setDescription('The value of sysUpTime when this entry was created. This object allows to a management station to detect deletion and recreation cycles between polls.')
smonPrioStatsControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 3, 1, 4), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smonPrioStatsControlOwner.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsControlOwner.setDescription('Administratively assigned named of the owner of this entry. It usually defines the entity that created this entry and is therefore using the resources assigned to it, though there is no enforcement mechanism, nor assurance that rows created are ever used.')
smonPrioStatsControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 3, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smonPrioStatsControlStatus.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsControlStatus.setDescription('The status of this row. An entry MAY NOT exist in the active state unless all objects in the entry have an appropriate value. If this object is not equal to active(1), all associated entries in the smonPrioStatsTable SHALL be deleted.')
smonPrioStatsTable = MibTable((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4), )
if mibBuilder.loadTexts: smonPrioStatsTable.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsTable.setDescription('Contains the priority statistics. The collections are based on the value of the 3-bit user priority field encoded in the Tag Control Information (TCI) field according to [19], [20]. Note that this table merely reports priority as encoded in the VLAN headers, not the priority (if any) given to the frame for the actual switching purposes. No garbage collection is designed for this table, as there always are at most eight rows per statistical set, and the low memory requirements do not justify the implementation of such a mechanism.')
smonPrioStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4, 1), ).setIndexNames((0, "SMON-MIB", "smonPrioStatsControlIndex"), (0, "SMON-MIB", "smonPrioStatsId"))
if mibBuilder.loadTexts: smonPrioStatsEntry.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsEntry.setDescription('A conceptual row in smonPrioStatsTable.')
smonPrioStatsId = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: smonPrioStatsId.setReference(' Draft Standard for Virtual Bridged Local Area Networks, P802.1Q/D10, chapter 4.3.2.1')
if mibBuilder.loadTexts: smonPrioStatsId.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsId.setDescription('The unique identifier of the priority level monitored for this specific statistics collection.')
smonPrioStatsPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4, 1, 2), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonPrioStatsPkts.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsPkts.setDescription('The total number of packets counted on this priority level.')
smonPrioStatsOverflowPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4, 1, 3), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonPrioStatsOverflowPkts.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsOverflowPkts.setDescription('The number of times the associated smonPrioStatsPkts counter has overflowed.')
smonPrioStatsHCPkts = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4, 1, 4), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonPrioStatsHCPkts.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsHCPkts.setDescription('The total number of packets counted on this priority level.')
smonPrioStatsOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4, 1, 5), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonPrioStatsOctets.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsOctets.setDescription('The total number of octets counted on this priority level.')
smonPrioStatsOverflowOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4, 1, 6), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonPrioStatsOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsOverflowOctets.setDescription('The number of times the associated smonPrioStatsOctets counter has overflowed.')
smonPrioStatsHCOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 2, 4, 1, 7), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smonPrioStatsHCOctets.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsHCOctets.setDescription('The total number of octets counted on this priority level.')
portCopyTable = MibTable((1, 3, 6, 1, 2, 1, 16, 22, 1, 3, 1), )
if mibBuilder.loadTexts: portCopyTable.setStatus('current')
if mibBuilder.loadTexts: portCopyTable.setDescription(" Port Copy provides the ability to copy all frames from a specified source to specified destination within a switch. Source and destinations MUST be ifEntries, as defined by [22]. One to one, one to many, many to one and many to many source to destination relationships may be configured. Applicable counters on the destination will increment for all packets transiting the port, be it by normal bridging/switching or due to packet copy. Note that this table manages no RMON data collection by itself, and an agent may possibly implement no RMON objects except objects related to the port copy operation defined by the portCopyCompliance conformance macro. That allows for a switch with no other embedded RMON capability to perform port copy operations to a destination port at which a different external RMON probe is connected. One to one, many to one and one to many source to destination relationships may be configured. Each row that exists in this table defines such a relationship. By disabling a row in this table the port copy relationship no longer exists. The number of entries and the types of port copies (1-1, many-1, 1-many) are implementation specific and could possibly be dynamic due to changing resource availability. In order to configure a source to destination portCopy relationship, both source and destination interfaces MUST be present as an ifEntry in the ifTable and their respective ifAdminStatus and ifOperStatus values MUST be equal to 'up(1)'. If the value of any of those two objects changes after the portCopyEntry is activated, portCopyStatus will transition to 'notReady(3)'. The capability of an interface to be source or destination of a port copy operation is described by the 'copySourcePort(0)' and 'copyDestPort(1)' bits in dataSourceCopyCaps. Those bits SHOULD be appropriately set by the agent, in order to allow for a portCopyEntry to be created. Applicable counters on the destination will increment for all packets transmitted, be it by normal bridging/switching or due to packet copy.")
portCopyEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 22, 1, 3, 1, 1), ).setIndexNames((0, "SMON-MIB", "portCopySource"), (0, "SMON-MIB", "portCopyDest"))
if mibBuilder.loadTexts: portCopyEntry.setStatus('current')
if mibBuilder.loadTexts: portCopyEntry.setDescription('Describes a particular port copy entry.')
portCopySource = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 3, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: portCopySource.setStatus('current')
if mibBuilder.loadTexts: portCopySource.setDescription('The ifIndex of the source which will have all packets redirected to the destination as defined by portCopyDest.')
portCopyDest = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 3, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: portCopyDest.setStatus('current')
if mibBuilder.loadTexts: portCopyDest.setDescription('Defines the ifIndex destination for the copy operation.')
portCopyDestDropEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 3, 1, 1, 3), Counter32()).setUnits('events').setMaxAccess("readonly")
if mibBuilder.loadTexts: portCopyDestDropEvents.setStatus('current')
if mibBuilder.loadTexts: portCopyDestDropEvents.setDescription('The total number of events in which port copy packets were dropped by the switch at the destination port due to lack of resources. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected. A single dropped event counter is maintained for each portCopyDest. Thus all instances associated with a given portCopyDest will have the same portCopyDestDropEvents value.')
portCopyDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("copyRxOnly", 1), ("copyTxOnly", 2), ("copyBoth", 3))).clone('copyBoth')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyDirection.setStatus('current')
if mibBuilder.loadTexts: portCopyDirection.setDescription("This object affects the way traffic is copied from a switch source port, for the indicated port copy operation. If this object has the value 'copyRxOnly(1)', then only traffic received on the indicated source port will be copied to the indicated destination port. If this object has the value 'copyTxOnly(2)', then only traffic transmitted out the indicated source port will be copied to the indicated destination port. If this object has the value 'copyBoth(3)', then all traffic received or transmitted on the indicated source port will be copied to the indicated destination port. The creation and deletion of instances of this object is controlled by the portCopyRowStatus object. Note that there is no guarantee that changes in the value of this object performed while the associated portCopyRowStatus object is equal to active will not cause traffic discontinuities in the packet stream.")
portCopyStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 22, 1, 3, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portCopyStatus.setStatus('current')
if mibBuilder.loadTexts: portCopyStatus.setDescription("Defines the status of the port copy entry. In order to configure a source to destination portCopy relationship, both source and destination interfaces MUST be present as an ifEntry in the ifTable and their respective ifAdminStatus and ifOperStatus values MUST be equal to 'up(1)'. If the value of any of those two objects changes after the portCopyEntry is activated, portCopyStatus will transition to 'notReady(3)'. The capability of an interface to be source or destination of a port copy operation is described by the 'copySourcePort(0)' and 'copyDestPort(1)' bits in dataSourceCopyCaps. Those bits SHOULD be appropriately set by the agent, in order to allow for a portCopyEntry to be created.")
smonVlanDataSource = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 22, 1, 4, 1))
smonMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20, 3))
smonMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 20, 4))
smonMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 3, 1)).setObjects(("SMON-MIB", "dataSourceCapsGroup"), ("SMON-MIB", "smonVlanStatsGroup"), ("SMON-MIB", "smonPrioStatsGroup"), ("SMON-MIB", "portCopyConfigGroup"), ("SMON-MIB", "smonInformationGroup"), ("SMON-MIB", "smonHcTo100mbGroup"), ("SMON-MIB", "smonHc100mbPlusGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonMIBCompliance = smonMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: smonMIBCompliance.setDescription('Describes the requirements for full conformance with the SMON MIB')
smonMIBVlanStatsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 3, 2)).setObjects(("SMON-MIB", "dataSourceCapsGroup"), ("SMON-MIB", "smonVlanStatsGroup"), ("SMON-MIB", "smonInformationGroup"), ("SMON-MIB", "hcVlanTo100mbGroup"), ("SMON-MIB", "hcVlan100mbPlusGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonMIBVlanStatsCompliance = smonMIBVlanStatsCompliance.setStatus('current')
if mibBuilder.loadTexts: smonMIBVlanStatsCompliance.setDescription('Describes the requirements for conformance with the SMON MIB with support for VLAN Statistics. Mandatory for a SMON probe in environment where IEEE 802.1Q bridging is implemented.')
smonMIBPrioStatsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 3, 3)).setObjects(("SMON-MIB", "dataSourceCapsGroup"), ("SMON-MIB", "smonPrioStatsGroup"), ("SMON-MIB", "smonInformationGroup"), ("SMON-MIB", "hcPrioTo100mbGroup"), ("SMON-MIB", "hcPrio100mbPlusGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonMIBPrioStatsCompliance = smonMIBPrioStatsCompliance.setStatus('current')
if mibBuilder.loadTexts: smonMIBPrioStatsCompliance.setDescription('Describes the requirements for conformance with the SMON MIB with support for priority level Statistics. Mandatory for a SMON probe in a environment where IEEE 802.1p priority-switching is implemented.')
portCopyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 20, 3, 4)).setObjects(("SMON-MIB", "dataSourceCapsGroup"), ("SMON-MIB", "portCopyConfigGroup"), ("SMON-MIB", "smonInformationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    portCopyCompliance = portCopyCompliance.setStatus('current')
if mibBuilder.loadTexts: portCopyCompliance.setDescription('Describes the requirements for conformance with the port copy functionality defined by the SMON MIB')
dataSourceCapsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 1)).setObjects(("SMON-MIB", "dataSourceRmonCaps"), ("SMON-MIB", "dataSourceCopyCaps"), ("SMON-MIB", "dataSourceCapsIfIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dataSourceCapsGroup = dataSourceCapsGroup.setStatus('current')
if mibBuilder.loadTexts: dataSourceCapsGroup.setDescription('Defines the objects that describe the capabilities of RMON data sources.')
smonVlanStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 2)).setObjects(("SMON-MIB", "smonVlanStatsControlDataSource"), ("SMON-MIB", "smonVlanStatsControlCreateTime"), ("SMON-MIB", "smonVlanStatsControlOwner"), ("SMON-MIB", "smonVlanStatsControlStatus"), ("SMON-MIB", "smonVlanIdStatsTotalPkts"), ("SMON-MIB", "smonVlanIdStatsTotalOctets"), ("SMON-MIB", "smonVlanIdStatsNUcastPkts"), ("SMON-MIB", "smonVlanIdStatsCreateTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonVlanStatsGroup = smonVlanStatsGroup.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsGroup.setDescription('Defines the switch monitoring specific statistics - per VLAN Id on interfaces of 10MB or less.')
smonPrioStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 3)).setObjects(("SMON-MIB", "smonPrioStatsControlDataSource"), ("SMON-MIB", "smonPrioStatsControlCreateTime"), ("SMON-MIB", "smonPrioStatsControlOwner"), ("SMON-MIB", "smonPrioStatsControlStatus"), ("SMON-MIB", "smonPrioStatsPkts"), ("SMON-MIB", "smonPrioStatsOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonPrioStatsGroup = smonPrioStatsGroup.setStatus('current')
if mibBuilder.loadTexts: smonPrioStatsGroup.setDescription('Defines the switch monitoring specific statistics - per VLAN Id on interface.')
smonHcTo100mbGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 4)).setObjects(("SMON-MIB", "smonVlanIdStatsTotalOverflowOctets"), ("SMON-MIB", "smonVlanIdStatsTotalHCOctets"), ("SMON-MIB", "smonPrioStatsOverflowOctets"), ("SMON-MIB", "smonPrioStatsHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonHcTo100mbGroup = smonHcTo100mbGroup.setStatus('current')
if mibBuilder.loadTexts: smonHcTo100mbGroup.setDescription('Defines the additional high capacity statistics needed to be kept on interfaces with ifSpeed greater than 10MB/sec and less than or equal to 100MB/sec.')
smonHc100mbPlusGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 5)).setObjects(("SMON-MIB", "smonVlanIdStatsTotalOverflowPkts"), ("SMON-MIB", "smonVlanIdStatsTotalHCPkts"), ("SMON-MIB", "smonVlanIdStatsTotalOverflowOctets"), ("SMON-MIB", "smonVlanIdStatsTotalHCOctets"), ("SMON-MIB", "smonVlanIdStatsNUcastOverflowPkts"), ("SMON-MIB", "smonVlanIdStatsNUcastHCPkts"), ("SMON-MIB", "smonPrioStatsOverflowPkts"), ("SMON-MIB", "smonPrioStatsHCPkts"), ("SMON-MIB", "smonPrioStatsOverflowOctets"), ("SMON-MIB", "smonPrioStatsHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonHc100mbPlusGroup = smonHc100mbPlusGroup.setStatus('current')
if mibBuilder.loadTexts: smonHc100mbPlusGroup.setDescription('Defines the additional high capacity statistics needed to be kept on interfaces with ifSpeed of more than 100MB/sec. These statistics MUST also be kept on smonDataSources of type VLAN or entPhysicalEntry.')
hcVlanTo100mbGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 6)).setObjects(("SMON-MIB", "smonVlanIdStatsTotalOverflowOctets"), ("SMON-MIB", "smonVlanIdStatsTotalHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hcVlanTo100mbGroup = hcVlanTo100mbGroup.setStatus('current')
if mibBuilder.loadTexts: hcVlanTo100mbGroup.setDescription('Defines the additional high capacity VLAN statistics needed to be kept on interfaces with ifSpeed greater than 10MB/sec and less than or equal to 100MB/sec.')
hcVlan100mbPlusGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 7)).setObjects(("SMON-MIB", "smonVlanIdStatsTotalOverflowPkts"), ("SMON-MIB", "smonVlanIdStatsTotalHCPkts"), ("SMON-MIB", "smonVlanIdStatsTotalOverflowOctets"), ("SMON-MIB", "smonVlanIdStatsTotalHCOctets"), ("SMON-MIB", "smonVlanIdStatsNUcastOverflowPkts"), ("SMON-MIB", "smonVlanIdStatsNUcastHCPkts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hcVlan100mbPlusGroup = hcVlan100mbPlusGroup.setStatus('current')
if mibBuilder.loadTexts: hcVlan100mbPlusGroup.setDescription('Defines the additional high capacity VLAN statistics needed to be kept on interfaces with ifSpeed of more than 100MB/sec. These statistics MUST also be kept on smonDataSources of type VLAN or entPhysicalEntry.')
hcPrioTo100mbGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 8)).setObjects(("SMON-MIB", "smonPrioStatsOverflowOctets"), ("SMON-MIB", "smonPrioStatsHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hcPrioTo100mbGroup = hcPrioTo100mbGroup.setStatus('current')
if mibBuilder.loadTexts: hcPrioTo100mbGroup.setDescription('Defines the additional high capacity VLAN priority statistics needed to be kept on interfaces with ifSpeed of greater than 10MB/sec and less than or equal to 100MB/sec.')
hcPrio100mbPlusGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 9)).setObjects(("SMON-MIB", "smonPrioStatsOverflowPkts"), ("SMON-MIB", "smonPrioStatsHCPkts"), ("SMON-MIB", "smonPrioStatsOverflowOctets"), ("SMON-MIB", "smonPrioStatsHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hcPrio100mbPlusGroup = hcPrio100mbPlusGroup.setStatus('current')
if mibBuilder.loadTexts: hcPrio100mbPlusGroup.setDescription('Defines the additional high capacity VLAN priority statistics needed to be kept on interfaces with ifSpeed of greater than 100MB/sec. These statistics MUST also be kept on smonDataSources of type VLAN or entPhysicalEntry.')
smonVlanStatsExtGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 10)).setObjects(("SMON-MIB", "smonVlanIdStatsNUcastOctets"), ("SMON-MIB", "smonVlanIdStatsNUcastOverflowOctets"), ("SMON-MIB", "smonVlanIdStatsNUcastHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonVlanStatsExtGroup = smonVlanStatsExtGroup.setStatus('current')
if mibBuilder.loadTexts: smonVlanStatsExtGroup.setDescription('Defines the switch monitoring specific statistics for systems capable of counting non-unicast octets for a given dataSource (as described in the dataSourceRmonCaps object).')
smonInformationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 11)).setObjects(("SMON-MIB", "smonCapabilities"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smonInformationGroup = smonInformationGroup.setStatus('current')
if mibBuilder.loadTexts: smonInformationGroup.setDescription('An indication of the SMON capabilities supported by this agent.')
portCopyConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 20, 4, 12)).setObjects(("SMON-MIB", "portCopyDestDropEvents"), ("SMON-MIB", "portCopyDirection"), ("SMON-MIB", "portCopyStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    portCopyConfigGroup = portCopyConfigGroup.setStatus('current')
if mibBuilder.loadTexts: portCopyConfigGroup.setDescription('Defines the control objects for copy port operations.')
mibBuilder.exportSymbols("SMON-MIB", dataSourceCapsIfIndex=dataSourceCapsIfIndex, smonPrioStatsPkts=smonPrioStatsPkts, smonVlanIdStatsTotalHCOctets=smonVlanIdStatsTotalHCOctets, smonVlanStatsExtGroup=smonVlanStatsExtGroup, smonPrioStatsOctets=smonPrioStatsOctets, smonVlanStatsControlOwner=smonVlanStatsControlOwner, smonVlanStatsControlEntry=smonVlanStatsControlEntry, portCopyDest=portCopyDest, smonVlanIdStatsNUcastHCPkts=smonVlanIdStatsNUcastHCPkts, smonPrioStatsControlStatus=smonPrioStatsControlStatus, smonPrioStatsControlIndex=smonPrioStatsControlIndex, smonPrioStatsControlDataSource=smonPrioStatsControlDataSource, smonVlanIdStatsNUcastOctets=smonVlanIdStatsNUcastOctets, smonVlanStatsControlStatus=smonVlanStatsControlStatus, dataSourceCapsObject=dataSourceCapsObject, smonVlanIdStatsCreateTime=smonVlanIdStatsCreateTime, smonPrioStatsHCPkts=smonPrioStatsHCPkts, smonMIBCompliances=smonMIBCompliances, smonMIBGroups=smonMIBGroups, portCopyCompliance=portCopyCompliance, hcPrioTo100mbGroup=hcPrioTo100mbGroup, switchRMON=switchRMON, smonVlanStatsControlDataSource=smonVlanStatsControlDataSource, smonVlanIdStatsId=smonVlanIdStatsId, smonMIBObjects=smonMIBObjects, smonMIBVlanStatsCompliance=smonMIBVlanStatsCompliance, dataSourceCopyCaps=dataSourceCopyCaps, portCopyTable=portCopyTable, hcPrio100mbPlusGroup=hcPrio100mbPlusGroup, smonVlanIdStatsTable=smonVlanIdStatsTable, smonCapabilities=smonCapabilities, smonVlanDataSource=smonVlanDataSource, portCopySource=portCopySource, hcVlan100mbPlusGroup=hcVlan100mbPlusGroup, smonPrioStatsGroup=smonPrioStatsGroup, smonPrioStatsEntry=smonPrioStatsEntry, smonVlanIdStatsTotalOverflowOctets=smonVlanIdStatsTotalOverflowOctets, portCopyEntry=portCopyEntry, smonInformationGroup=smonInformationGroup, dataSourceCapsTable=dataSourceCapsTable, dataSourceCapsEntry=dataSourceCapsEntry, smonPrioStatsControlOwner=smonPrioStatsControlOwner, smonPrioStatsHCOctets=smonPrioStatsHCOctets, smonMIBCompliance=smonMIBCompliance, smonVlanStatsControlCreateTime=smonVlanStatsControlCreateTime, smonVlanIdStatsNUcastOverflowOctets=smonVlanIdStatsNUcastOverflowOctets, smonPrioStatsTable=smonPrioStatsTable, SmonDataSource=SmonDataSource, smonHcTo100mbGroup=smonHcTo100mbGroup, dataSourceCapsGroup=dataSourceCapsGroup, smonPrioStatsOverflowPkts=smonPrioStatsOverflowPkts, dataSourceRmonCaps=dataSourceRmonCaps, smonVlanStatsControlTable=smonVlanStatsControlTable, PYSNMP_MODULE_ID=switchRMON, smonPrioStatsId=smonPrioStatsId, portCopyDestDropEvents=portCopyDestDropEvents, smonVlanIdStatsTotalPkts=smonVlanIdStatsTotalPkts, portCopyDirection=portCopyDirection, smonPrioStatsControlTable=smonPrioStatsControlTable, smonMIBPrioStatsCompliance=smonMIBPrioStatsCompliance, smonPrioStatsControlEntry=smonPrioStatsControlEntry, smonHc100mbPlusGroup=smonHc100mbPlusGroup, smonVlanIdStatsTotalHCPkts=smonVlanIdStatsTotalHCPkts, smonVlanIdStatsNUcastPkts=smonVlanIdStatsNUcastPkts, smonVlanIdStatsTotalOctets=smonVlanIdStatsTotalOctets, smonVlanIdStatsEntry=smonVlanIdStatsEntry, smonRegistrationPoints=smonRegistrationPoints, smonVlanIdStatsTotalOverflowPkts=smonVlanIdStatsTotalOverflowPkts, smonVlanIdStatsNUcastOverflowPkts=smonVlanIdStatsNUcastOverflowPkts, smonVlanIdStatsNUcastHCOctets=smonVlanIdStatsNUcastHCOctets, hcVlanTo100mbGroup=hcVlanTo100mbGroup, smonStats=smonStats, dataSourceCaps=dataSourceCaps, portCopyConfig=portCopyConfig, smonVlanStatsGroup=smonVlanStatsGroup, smonPrioStatsOverflowOctets=smonPrioStatsOverflowOctets, smonVlanStatsControlIndex=smonVlanStatsControlIndex, smonPrioStatsControlCreateTime=smonPrioStatsControlCreateTime, portCopyConfigGroup=portCopyConfigGroup, portCopyStatus=portCopyStatus)

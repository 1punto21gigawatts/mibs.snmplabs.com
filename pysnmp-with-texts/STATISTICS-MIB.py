#
# PySNMP MIB module STATISTICS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/STATISTICS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:11:05 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
hpSwitch, = mibBuilder.importSymbols("HP-ICF-OID", "hpSwitch")
VidList, HpSwitchPortType = mibBuilder.importSymbols("HP-ICF-TC", "VidList", "HpSwitchPortType")
InetPortNumber, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddressType", "InetAddress")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, Counter32, ModuleIdentity, Unsigned32, MibIdentifier, Counter64, NotificationType, IpAddress, Bits, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Gauge32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Counter32", "ModuleIdentity", "Unsigned32", "MibIdentifier", "Counter64", "NotificationType", "IpAddress", "Bits", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Gauge32", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
hpSwitchStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9))
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class VlanID(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 65535)

hpSwitchIpxStat = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 1))
hpSwitchIpxStatTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 1, 1), )
if mibBuilder.loadTexts: hpSwitchIpxStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchIpxStatTable.setDescription('A table that contains information about the operational IPX status of the virtual LAN in this device.')
hpSwitchIpxStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 1, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchIpxStatIndex"))
if mibBuilder.loadTexts: hpSwitchIpxStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchIpxStatEntry.setDescription('Information about the operational IPX status of a virtual LAN in this device.')
hpSwitchIpxStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 1, 1, 1, 1), VlanID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpxStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchIpxStatIndex.setDescription('An index that uniquely identifies the operational IPX status of a virtual LAN for which this entry contains information.')
hpSwitchIpxStatNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 1, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpxStatNodeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchIpxStatNodeAddr.setDescription('The current IPX node address of this virtual LAN.')
hpSwitchIpxStatGatewayAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 1, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpxStatGatewayAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchIpxStatGatewayAddr.setDescription('The current IPX node address of the gateway for this virtual LAN.')
hpSwitchIpxStatGatewayEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ethernetII", 1), ("ieee8022", 2), ("snap", 3), ("ieee8023Raw", 4), ("noGateway", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpxStatGatewayEncap.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchIpxStatGatewayEncap.setDescription('The current type of encapsulation of the gateway.')
hpSwitchIpxStatAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpxStatAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchIpxStatAdminStatus.setDescription('The operational status of the IPX protocol entity.')
hpSwitchIpStat = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2))
hpSwitchIpStatTimepAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpStatTimepAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatTimepAdminStatus.setDescription('The operational status of the Time protocol.')
hpSwitchIpStatTimepServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpStatTimepServerAddr.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatTimepServerAddr.setDescription('The current IP address of the Time server.')
hpSwitchIpStatTimepPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpStatTimepPollInterval.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatTimepPollInterval.setDescription('The current client poll interval of the Time server in minute.')
hpSwitchIpStatTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 4), )
if mibBuilder.loadTexts: hpSwitchIpStatTable.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatTable.setDescription('A table that contains information about the current IP status of the virtual LAN in this device.')
hpSwitchIpStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 4, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchIpStatIndex"))
if mibBuilder.loadTexts: hpSwitchIpStatEntry.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatEntry.setDescription('Information about the IP status of a specific virtual LAN in this device.')
hpSwitchIpStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 4, 1, 1), VlanID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpStatIndex.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatIndex.setDescription('An index that uniquely identifies the IP status of a virtual LAN for which this entry contains information.')
hpSwitchIpStatAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpStatAddr.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatAddr.setDescription('The current IP address of this Virtual LAN.')
hpSwitchIpStatMask = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpStatMask.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatMask.setDescription('The current IP subnet mask of this virtual LAN.')
hpSwitchIpStatGatewayAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 4, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpStatGatewayAddr.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatGatewayAddr.setDescription('The current IP address of the gateway for this virtual LAN.')
hpSwitchIpStatAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("bootp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchIpStatAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: hpSwitchIpStatAdminStatus.setDescription('The operational status of the IP protocol for this virtual LAN. If the value of this variable is 3, the IP protocol entity will utilize BOOTP during initialization.')
hpSwitchFdbInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4))
hpSwitchVlanFdbAddrTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 1), )
if mibBuilder.loadTexts: hpSwitchVlanFdbAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchVlanFdbAddrTable.setDescription('A table that contains information about unicast entries for which the VLAN has forwarding and/or filtering information. This information is used by the VLAN bridging function in determining how to propagate a received frame.')
hpSwitchVlanFdbAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchVlanFdbId"), (0, "STATISTICS-MIB", "hpSwitchVlanFdbAddress"))
if mibBuilder.loadTexts: hpSwitchVlanFdbAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchVlanFdbAddrEntry.setDescription('Information about a specific unicast MAC address for which the VLAN has some forwarding and/or filtering information.')
hpSwitchVlanFdbId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 1, 1, 1), VlanID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchVlanFdbId.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchVlanFdbId.setDescription('An index that uniquely identifies a virtual LAN for which this entry contains information.')
hpSwitchVlanFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchVlanFdbAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchVlanFdbAddress.setDescription('A unicast MAC address for which the VLAN has forwarding and/or filtering information.')
hpSwitchVlanFdbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchVlanFdbPort.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchVlanFdbPort.setDescription('The port number of the port on which a frame having a source address equal to the value of the corresponding instance of hpSwitchVlanFdbAddress has been seen.')
hpSwitchPortFdbAddrTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 2), )
if mibBuilder.loadTexts: hpSwitchPortFdbAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPortFdbAddrTable.setDescription('A table that contains information about unicast entries for which the port has forwarding and/or filtering information. This information is used by the bridging function in determining how to propagate a received frame.')
hpSwitchPortFdbAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 2, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchPortFdbId"), (0, "STATISTICS-MIB", "hpSwitchPortFdbAddress"))
if mibBuilder.loadTexts: hpSwitchPortFdbAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPortFdbAddrEntry.setDescription('Information about a specific unicast MAC address for which the port has some forwarding and/or filtering information.')
hpSwitchPortFdbId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchPortFdbId.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPortFdbId.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table. The corresponding row in the Interfaces Table must exist prior to the index being used in this table.')
hpSwitchPortFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchPortFdbAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPortFdbAddress.setDescription('A unicast MAC address for which the port has forwarding and/or filtering information.')
hpSwitchPortFdbVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 2, 1, 3), VlanID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchPortFdbVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: hpSwitchPortFdbVlanId.setDescription('The VLAN ID to which this entry belongs. Deprecated - hpSwitchPortFdbVidList should be used instead.')
hpSwitchPortFdbVidList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 4, 2, 1, 4), VidList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchPortFdbVidList.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPortFdbVidList.setDescription('A VidList of VLAN IDs to which this entry belongs.')
hpSwitchStpStat = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 5))
hpSwitchStpStatAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchStpStatAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchStpStatAdminStatus.setDescription('The operational status of the spanning tree protocol.')
hpSwitchMiscStat = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 6))
hpSwitchCpuStat = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchCpuStat.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchCpuStat.setDescription('The CPU utilization in percent(%).')
hpSwitchFddiIpFragStat = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 7))
hpSwitchFddiIpFragStatTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 7, 1), )
if mibBuilder.loadTexts: hpSwitchFddiIpFragStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiIpFragStatTable.setDescription('A list of IP fragmentation statistics for the FDDI cards in the switch.')
hpSwitchFddiIpFragStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 7, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchFddiIpFragStatIndex"))
if mibBuilder.loadTexts: hpSwitchFddiIpFragStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiIpFragStatEntry.setDescription('An Fddi IP fragmentation entry which is containing statistics for the FDDI cards in the switch.')
hpSwitchFddiIpFragStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiIpFragStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiIpFragStatIndex.setDescription("A unique value for each FDDI Card. The value for each FDDI card must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
hpSwitchFddiIpFragFramesFragmented = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 7, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiIpFragFramesFragmented.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiIpFragFramesFragmented.setDescription('Number of FDDI Frames which get fragmented when they are larger than Ethernet Frame size, 1518 bytes.')
hpSwitchFddiIpFragFramesCreated = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 7, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiIpFragFramesCreated.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiIpFragFramesCreated.setDescription('Number of inbound FDDI frames which get created when they larger than Ethernet Frame size, 1518 bytes.')
hpSwitchFddiIpFragFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 7, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiIpFragFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiIpFragFrameErrors.setDescription('Number of large inbound FDDI frames that contains error which preventing them from being fragmented when they are larger than Ethernet Frame size, 1518 bytes. Or number of large frames which are dropped because the FDDI IP fragmentation is disabled ')
hpSwitchFddiSystemStat = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8))
hpSwitchFddiSystemStatTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1), )
if mibBuilder.loadTexts: hpSwitchFddiSystemStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemStatTable.setDescription('A list of system infomations and statistics for the FDDI cards in the switch.')
hpSwitchFddiSystemStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchFddiSystemStatIndex"))
if mibBuilder.loadTexts: hpSwitchFddiSystemStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemStatEntry.setDescription('An Fddi system entry which is containing statistics for the FDDI cards in the switch.')
hpSwitchFddiSystemStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemStatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemStatIndex.setDescription("A unique value for each FDDI Card. The value for each FDDI card must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
hpSwitchFddiSystemOsVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemOsVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemOsVersion.setDescription('Contains the operating code version number (also known as software or firmware). For example, a software version such as A.08.01 is described as follows: A the function set available in your switch 08 the common release number 01 updates to the current common release')
hpSwitchFddiSystemRomVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemRomVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemRomVersion.setDescription('Contains the ROM version number (such as A.08.01 is described as follows: A the function set available in your router 08 the common release number 01 updates to the current common release')
hpSwitchFddiSystemMemoryTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemMemoryTotal.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemMemoryTotal.setDescription('The number of currently installed bytes.')
hpSwitchFddiSystemMemoryFree = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemMemoryFree.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemMemoryFree.setDescription('The number of available (unallocated) bytes.')
hpSwitchFddiSystemCpuUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemCpuUtil.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemCpuUtil.setDescription('The CPU utilization in percent(%).')
hpSwitchFddiSystemBuildDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(80, 80)).setFixedLength(80)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemBuildDirectory.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemBuildDirectory.setDescription('The Build directory the FDDI firmware image ')
hpSwitchFddiSystemBuildDate = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemBuildDate.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemBuildDate.setDescription('The Build date and time of the FDDI firmware image')
hpSwitchFddiSystemBuildNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 8, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFddiSystemBuildNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFddiSystemBuildNumber.setDescription('The Build number of the FDDI firmware image')
hpABCStats = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9))
hpABCStatsTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1), )
if mibBuilder.loadTexts: hpABCStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsTable.setDescription('A table that contains statistic information about Automatic Broadcast Control on any given VLAN on the switch.')
hpABCStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpABCStatsVlanIndex"), (0, "STATISTICS-MIB", "hpABCStatsPortIndex"))
if mibBuilder.loadTexts: hpABCStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsEntry.setDescription('The information associated with each row in the ABC Statistics Table.')
hpABCStatsVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1, 1, 1), VlanID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpABCStatsVlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsVlanIndex.setDescription('The value which uniquely identifies configuration of a virtual LAN for which entry contains information.')
hpABCStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpABCStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsPortIndex.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table.')
hpABCStatsPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1, 1, 3), HpSwitchPortType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpABCStatsPortType.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsPortType.setDescription('The type of port.')
hpABCStatsArpReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpABCStatsArpReplies.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsArpReplies.setDescription('This counter reports the number of ARP responses sent out by the switch (running ABC) to proxy respond for hosts learned in the switch ARP cashe.')
hpABCStatsIpxReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpABCStatsIpxReplies.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsIpxReplies.setDescription('This counter reports the number of RIP and SAP responses sent out by the switch (running ABC) to proxy respond for routes and services learned by switch.')
hpABCStatsIpRipControl = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("notforwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpABCStatsIpRipControl.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsIpRipControl.setDescription('This status field shows if IP RIP packets are being forwarded or not forwarded on the ports shown.')
hpABCStatsIpxRipSapControl = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("notforwarding", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpABCStatsIpxRipSapControl.setStatus('mandatory')
if mibBuilder.loadTexts: hpABCStatsIpxRipSapControl.setDescription('This status field shows if IPX RIP and/or IPX SAP packets are being forwarded or not forwarded on the ports shown.')
hpIgmpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10))
hpIgmpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 1), )
if mibBuilder.loadTexts: hpIgmpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsTable.setDescription('A table that contains statistic information about Multicast Groups on any given VLAN on the switch.')
hpIgmpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpIgmpStatsVlanIndex"), (0, "STATISTICS-MIB", "hpIgmpStatsActiveGroupAddr"))
if mibBuilder.loadTexts: hpIgmpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsEntry.setDescription('The information associated with each member in particular multicast group.')
hpIgmpStatsVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 1, 1, 1), VlanID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsVlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsVlanIndex.setDescription('The value which uniquely identifies configuration of a virtual LAN for which entry contains information.')
hpIgmpStatsActiveGroupAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsActiveGroupAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsActiveGroupAddr.setDescription('An IP Multicast Group Membership address that has been sent, via IGMP Membership Reports, through the switch to querier.')
hpIgmpStatsReports = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsReports.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsReports.setDescription('The number of IGMP report packets that the switch has seen for this group address.')
hpIgmpStatsQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsQueries.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsQueries.setDescription("The number of IGMP query packets the switch has seen for this group address. Note: This object is based on a group, thus if a query is heard before this object's group joins, the value will be zero. It will be non-zero when an all host query, or group specific query for the associated group, is heard after the associated group has joined.")
hpIgmpStatsQuerierAccessPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsQuerierAccessPort.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsQuerierAccessPort.setDescription('The port on which the switch detects IGMP query packets from the querier (device sending out query packets). If no queries are heard, the value of the object is zero and we are querier or electing to be querier. Anytime a querier besides our switch is heard the value of the object becomes the port number on which the other querier was heard and the query election process will be halted if currently running.')
hpIgmpStatsPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 2), )
if mibBuilder.loadTexts: hpIgmpStatsPortTable.setStatus('deprecated')
if mibBuilder.loadTexts: hpIgmpStatsPortTable.setDescription('A table that contains information about status of the IGMP port configurations on this switch.')
hpIgmpStatsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 2, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpIgmpStatsActiveGroupAddr"), (0, "STATISTICS-MIB", "hpIgmpStatsPortIndex"))
if mibBuilder.loadTexts: hpIgmpStatsPortEntry.setStatus('deprecated')
if mibBuilder.loadTexts: hpIgmpStatsPortEntry.setDescription('The information associated with status of each IGMP port configuration.')
hpIgmpStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsPortIndex.setStatus('deprecated')
if mibBuilder.loadTexts: hpIgmpStatsPortIndex.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table.')
hpIgmpStatsPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 2, 1, 2), HpSwitchPortType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsPortType.setStatus('deprecated')
if mibBuilder.loadTexts: hpIgmpStatsPortType.setDescription('The type of port.')
hpIgmpStatsPortAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("host", 1), ("router", 2), ("host-router", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsPortAccess.setStatus('deprecated')
if mibBuilder.loadTexts: hpIgmpStatsPortAccess.setDescription('If this value is host then this port has seen IGMP report packets for this active group address. If this value is router then this port has detected IGMP query packets from the querier (device sending out query packets). If this value is host-router then this port has seen report packets, and IGMP query packets from the querier.')
hpIgmpStatsPortTable2 = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 3), )
if mibBuilder.loadTexts: hpIgmpStatsPortTable2.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsPortTable2.setDescription('A table that contains information about status of the IGMP port configurations on this switch. This table2 is supersedes hpIgmpStatsPortTable for switches which support multiple vlans per port.')
hpIgmpStatsPortEntry2 = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 3, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpIgmpStatsVlanIndex"), (0, "STATISTICS-MIB", "hpIgmpStatsActiveGroupAddr"), (0, "STATISTICS-MIB", "hpIgmpStatsPortIndex2"))
if mibBuilder.loadTexts: hpIgmpStatsPortEntry2.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsPortEntry2.setDescription('The information associated with status of each IGMP port configuration.')
hpIgmpStatsPortIndex2 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsPortIndex2.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsPortIndex2.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table.')
hpIgmpStatsPortType2 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 3, 1, 2), HpSwitchPortType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsPortType2.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsPortType2.setDescription('The type of port.')
hpIgmpStatsPortAccess2 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("host", 1), ("router", 2), ("host-router", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsPortAccess2.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsPortAccess2.setDescription('If this value is host then this port has seen IGMP report packets for this active group address. If this value is router then this port has detected IGMP query packets from the querier (device sending out query packets). If this value is host-router then this port has seen report packets, and IGMP query packets from the querier.')
hpIgmpStatsPortAgeTimer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsPortAgeTimer2.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsPortAgeTimer2.setDescription('The timer is set when the switch hears a report and is waiting for the group queries. If the timer expires the group is considered non-active on the specific port. The value returned shows how many seconds left before the timer expires or 0 if the timer has expired.')
hpIgmpStatsPortLeaveTimer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 10, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpIgmpStatsPortLeaveTimer2.setStatus('mandatory')
if mibBuilder.loadTexts: hpIgmpStatsPortLeaveTimer2.setDescription('The timer is set when the switch is waiting for a report response for queries. If the timer expires the group is considered non-active on the specific port. The value returned shows how many seconds left before the timer expires or 0 if the timer has expired.')
hpLdbalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11))
hpLdbalStatsPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11, 1), )
if mibBuilder.loadTexts: hpLdbalStatsPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpLdbalStatsPortTable.setDescription('A table that contains information about the operational status of the load balancing ports on this switch.')
hpLdbalStatsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpLdbalStatsPortIndex"))
if mibBuilder.loadTexts: hpLdbalStatsPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpLdbalStatsPortEntry.setDescription('The information associated with ports configured for load balancing.')
hpLdbalStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpLdbalStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpLdbalStatsPortIndex.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table.')
hpLdbalStatsPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("error", 2), ("initial", 3), ("notEstablished", 4), ("established", 5), ("topologyError", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpLdbalStatsPortState.setStatus('mandatory')
if mibBuilder.loadTexts: hpLdbalStatsPortState.setDescription('This variable describes the load balancing port state. A disabled state indicates the port does not have a link beat. An initial state indicates the port has recently established a link beat and is detecting whether or not it is in the load balancing domain. An established state indicates that the port is inside the load balancing domain, directly connected to another load balancing port, and learning addresses via the reception of MAC address learn information packets. A notEstablished state indicates that the port is outside the load balancing domain, not directly connected to a load balancing port, and learning MAC address by receiving unknown source address packets. An error state indicates the port has detected a direct connection to more than one load balancing port and is blocked, only accepting load balancing protocol packets. When the error condition clears, the port transitions either into the established or not established state.')
hpLdbalStatsAdjacentSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpLdbalStatsAdjacentSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: hpLdbalStatsAdjacentSwitch.setDescription('The switch identifier of the adjacent switch connected to the corresponding load balancing established port. If load balancing has not been established on this port then this value is void.')
hpLdbalStatsPeerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11, 1, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpLdbalStatsPeerPort.setStatus('mandatory')
if mibBuilder.loadTexts: hpLdbalStatsPeerPort.setDescription('The port identifier of the peer port connected to the corresponding load balancing established port. If load balancing has not been established on this port then this value is void.')
hpLdbalStatsAdjacentHost = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpLdbalStatsAdjacentHost.setStatus('mandatory')
if mibBuilder.loadTexts: hpLdbalStatsAdjacentHost.setDescription('The name of the adjacent Host')
hpLdbalStatsMeshWarningStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpLdbalStatsMeshWarningStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpLdbalStatsMeshWarningStatus.setDescription('This variable provides a high level summary of any mismatch in the mesh configuration and remind users to check the log for any mesh warning messages. If it is Yes then there is at least one warning message and will be No if there are no warning messages')
hpSwitchMacStats = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 12))
hpSwitchFdbAddressCount = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFdbAddressCount.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFdbAddressCount.setDescription('Keep a counter for the total number of MAC Addresses currently learnt on the box.')
hpSwitchFlowControlStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 13))
hpSwitchFlowControlStatusTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 13, 1), )
if mibBuilder.loadTexts: hpSwitchFlowControlStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFlowControlStatusTable.setDescription('A table that contains information about the operational status of flow control on this switch.')
hpSwitchFlowControlStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 13, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchFlowControlStatusPortIndex"))
if mibBuilder.loadTexts: hpSwitchFlowControlStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFlowControlStatusEntry.setDescription('The flow control status per port basis.')
hpSwitchFlowControlStatusPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFlowControlStatusPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFlowControlStatusPortIndex.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table.')
hpSwitchFlowControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("on-rx", 3), ("on-tx", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchFlowControlState.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchFlowControlState.setDescription('Gets the current Flow Control State from hardware.')
hpFECStatsTrunk = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 14))
hpFECStatsTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 14, 1), )
if mibBuilder.loadTexts: hpFECStatsTrunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsTrunkTable.setDescription('A table that contains information about the operational status of flow control on this switch.')
hpFECStatsTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 14, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpFECStatsTrunkIndex"))
if mibBuilder.loadTexts: hpFECStatsTrunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsTrunkEntry.setDescription('The flow control status per port basis.')
hpFECStatsTrunkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsTrunkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsTrunkIndex.setDescription('The trunk Index value which uniquely identifies a row in the Trunk Table.')
hpFECStatsTrunkName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsTrunkName.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsTrunkName.setDescription('The name of the trunk group')
hpFECStatsTrunkNegotiationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 14, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("successful", 1), ("failed", 2), ("initialized", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsTrunkNegotiationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsTrunkNegotiationStatus.setDescription('Whether the trunk has been successfully negotiated')
hpFECStatsTrunkForwardingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 14, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sa-only", 1), ("sa-da", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsTrunkForwardingMode.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsTrunkForwardingMode.setDescription('Whether the trunk has been successfully negotiated')
hpFECStatsTrunkFlushPktsEchoed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 14, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsTrunkFlushPktsEchoed.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsTrunkFlushPktsEchoed.setDescription('The number of FEC flush packets echoed')
hpFECStatsPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15))
hpFECStatsPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1), )
if mibBuilder.loadTexts: hpFECStatsPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortTable.setDescription('A table that contains information about the operational status of flow control on this switch.')
hpFECStatsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpFECStatsPortIndex"))
if mibBuilder.loadTexts: hpFECStatsPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortEntry.setDescription('The flow control status per port basis.')
hpFECStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortIndex.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table.')
hpFECStatsPortTrunkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortTrunkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortTrunkNumber.setDescription('The internal trunk ID')
hpFECStatsPortTrunkName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortTrunkName.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortTrunkName.setDescription('The name of the trunk group')
hpFECStatsPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("down", 1), ("forwarding", 2), ("blocking", 3), ("up", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortMode.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortMode.setDescription('FEC port mode')
hpFECStatsPortNegotiationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("successful", 1), ("failed", 2), ("initialized", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortNegotiationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortNegotiationStatus.setDescription('FEC port negotiation state')
hpFECStatsPortHellosSent = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortHellosSent.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortHellosSent.setDescription('The number of FEC hello packets sent')
hpFECStatsPortHellosReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortHellosReceived.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortHellosReceived.setDescription('The number of FEC hello packets received')
hpFECStatsPortMySlowHello = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fast", 1), ("slow", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortMySlowHello.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortMySlowHello.setDescription('Currently running fast or slow FEC hello state')
hpFECStatsPortMyAutoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("desirable", 1), ("auto", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortMyAutoMode.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortMyAutoMode.setDescription('Silent partner mode')
hpFECStatsPortPartner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 10), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortPartner.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortPartner.setDescription('The address of the adjacent device(switch, router, server, etc.)')
hpFECStatsPortFlushPktsEchoed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 15, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpFECStatsPortFlushPktsEchoed.setStatus('mandatory')
if mibBuilder.loadTexts: hpFECStatsPortFlushPktsEchoed.setDescription('The number of FEC flush packets echoed')
hpGvrpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 16))
hpGvrpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 16, 1), )
if mibBuilder.loadTexts: hpGvrpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpGvrpStatsTable.setDescription('A table that contains statistic information about GVRP on any given VLAN on the switch.')
hpGvrpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 16, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpGvrpStatsVlanIndex"), (0, "STATISTICS-MIB", "hpGvrpStatsPortIndex"))
if mibBuilder.loadTexts: hpGvrpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpGvrpStatsEntry.setDescription('The information associated with each row in the GVRP Statistics Table.')
hpGvrpStatsVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 16, 1, 1, 1), VlanID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGvrpStatsVlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpGvrpStatsVlanIndex.setDescription('The value which uniquely identifies configuration of a virtual LAN for which entry contains information.')
hpGvrpStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 16, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGvrpStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpGvrpStatsPortIndex.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table.')
hpGvrpStatsPortVlanMember = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 16, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pending", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGvrpStatsPortVlanMember.setStatus('mandatory')
if mibBuilder.loadTexts: hpGvrpStatsPortVlanMember.setDescription('This value reflects the state of the port with respect to its membership in a VLAN')
hpGvrpPortIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpGvrpPortIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpGvrpPortIfOperStatus.setDescription('The current operational state of the interface.')
hpPortGvrpCtrlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 16, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("learn", 1), ("block", 2), ("disable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpPortGvrpCtrlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hpPortGvrpCtrlStatus.setDescription('The status of Gvrp Control on this port.')
hpSshStats = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17))
hpSshStatsTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1), )
if mibBuilder.loadTexts: hpSshStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSshStatsTable.setDescription('A table that contains statistic information about SSH connections on the switch.')
hpSshStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSshStatsSesIndex"))
if mibBuilder.loadTexts: hpSshStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSshStatsEntry.setDescription('The information associated with each row in the SSH Statistics Table.')
hpSshStatsSesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSshStatsSesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpSshStatsSesIndex.setDescription('The value which uniquely identifies a row in the SSH Statistics Table.')
hpSshStatsSesType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("console", 1), ("telnet", 2), ("ssh", 3), ("inactive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSshStatsSesType.setStatus('mandatory')
if mibBuilder.loadTexts: hpSshStatsSesType.setDescription('The type of session on the switch.')
hpSshStatsSourceIpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 21))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSshStatsSourceIpPort.setStatus('deprecated')
if mibBuilder.loadTexts: hpSshStatsSourceIpPort.setDescription('Contains the information about source ip address and port number of active SSH session (e.g. 192.168.31.114:1722). This object has been deprecated as its not big enough to store IPv6 addresses. It is loosely replaced by hpSshStatsSourceIpAddress and hpSshStatsSourceIpPortNum')
hpSshStatsSesVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("version1", 1), ("version2", 2), ("noConnect", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSshStatsSesVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hpSshStatsSesVersion.setDescription('Specifies the SSH protocol version in use for a given session.')
hpSshStatsSourceIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSshStatsSourceIpType.setStatus('mandatory')
if mibBuilder.loadTexts: hpSshStatsSourceIpType.setDescription('Specifies the Address type of source ip address of active SSH session.')
hpSshStatsSourceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSshStatsSourceIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hpSshStatsSourceIpAddress.setDescription('Specifies the source ip address of active SSH session.')
hpSshStatsSourceIpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 17, 1, 1, 7), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSshStatsSourceIpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: hpSshStatsSourceIpPortNum.setDescription('Specifies the source port number of active SSH session.')
hpSwitchPhysicalPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 18))
hpSwitchPhysicalPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 18, 1), )
if mibBuilder.loadTexts: hpSwitchPhysicalPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPhysicalPortTable.setDescription('A table that contains information about the physical ports of this device.')
hpSwitchPhysicalPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 18, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchPhysicalPortIndex"))
if mibBuilder.loadTexts: hpSwitchPhysicalPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPhysicalPortEntry.setDescription('Information about the physical ports of this device.')
hpSwitchPhysicalPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchPhysicalPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPhysicalPortIndex.setDescription('An index that uniquely identifies a row in the physical port table.')
hpSwitchPhysicalPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 18, 1, 1, 2), HpSwitchPortType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchPhysicalPortType.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchPhysicalPortType.setDescription('The type for this port.')
hpSwitchCosStats = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 19))
hpSwitchQueueWatchStatsTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 19, 1), )
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsTable.setDescription('A table that contains statistic information about Egress Queue drops on the switch.')
hpSwitchQueueWatchStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 19, 1, 1), ).setIndexNames((0, "STATISTICS-MIB", "hpSwitchQueueWatchStatsPortIndex"), (0, "STATISTICS-MIB", "hpSwitchQueueWatchStatsQueueIndex"))
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsEntry.setDescription('The information associated with each row in the Queue Watch Statistics Table.')
hpSwitchQueueWatchStatsPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsPortIndex.setDescription('The ifIndex value which uniquely identifies a row in the Interfaces Table.')
hpSwitchQueueWatchStatsQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsQueueIndex.setDescription('The specific value which uniquely identifies a specific port queue.')
hpSwitchQueueWatchStatsQueueDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 9, 19, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsQueueDrops.setStatus('mandatory')
if mibBuilder.loadTexts: hpSwitchQueueWatchStatsQueueDrops.setDescription('The number of packets dropped for a particular egress port queue.')
mibBuilder.exportSymbols("STATISTICS-MIB", hpSwitchFddiIpFragStatEntry=hpSwitchFddiIpFragStatEntry, hpSwitchFddiSystemBuildNumber=hpSwitchFddiSystemBuildNumber, hpIgmpStatsQueries=hpIgmpStatsQueries, hpSwitchFddiIpFragStatIndex=hpSwitchFddiIpFragStatIndex, hpABCStatsEntry=hpABCStatsEntry, hpLdbalStatsPortIndex=hpLdbalStatsPortIndex, hpSwitchFlowControlStatusPortIndex=hpSwitchFlowControlStatusPortIndex, hpLdbalStatsAdjacentHost=hpLdbalStatsAdjacentHost, hpFECStatsPortTrunkName=hpFECStatsPortTrunkName, hpSwitchIpxStatIndex=hpSwitchIpxStatIndex, hpSwitchIpStatEntry=hpSwitchIpStatEntry, hpSshStatsSourceIpPortNum=hpSshStatsSourceIpPortNum, hpABCStats=hpABCStats, hpFECStatsPort=hpFECStatsPort, hpGvrpStats=hpGvrpStats, hpSshStatsSesType=hpSshStatsSesType, hpIgmpStats=hpIgmpStats, hpSwitchVlanFdbId=hpSwitchVlanFdbId, hpIgmpStatsPortType=hpIgmpStatsPortType, hpLdbalStats=hpLdbalStats, hpSwitchIpStatGatewayAddr=hpSwitchIpStatGatewayAddr, hpFECStatsPortMySlowHello=hpFECStatsPortMySlowHello, VlanID=VlanID, hpSwitchQueueWatchStatsEntry=hpSwitchQueueWatchStatsEntry, hpABCStatsIpxReplies=hpABCStatsIpxReplies, hpSwitchPhysicalPortIndex=hpSwitchPhysicalPortIndex, hpFECStatsTrunkTable=hpFECStatsTrunkTable, hpIgmpStatsPortIndex=hpIgmpStatsPortIndex, hpSwitchFddiIpFragFramesFragmented=hpSwitchFddiIpFragFramesFragmented, hpIgmpStatsPortAgeTimer2=hpIgmpStatsPortAgeTimer2, hpSwitchFlowControlStatusTable=hpSwitchFlowControlStatusTable, hpSshStats=hpSshStats, hpSwitchFddiSystemStat=hpSwitchFddiSystemStat, hpSwitchIpxStatAdminStatus=hpSwitchIpxStatAdminStatus, hpFECStatsPortTable=hpFECStatsPortTable, hpIgmpStatsPortTable=hpIgmpStatsPortTable, hpSwitchStpStatAdminStatus=hpSwitchStpStatAdminStatus, hpABCStatsPortIndex=hpABCStatsPortIndex, hpFECStatsTrunkNegotiationStatus=hpFECStatsTrunkNegotiationStatus, hpSwitchStpStat=hpSwitchStpStat, hpSwitchVlanFdbAddress=hpSwitchVlanFdbAddress, hpFECStatsPortEntry=hpFECStatsPortEntry, hpSwitchIpxStatGatewayEncap=hpSwitchIpxStatGatewayEncap, hpSwitchCosStats=hpSwitchCosStats, hpSwitchFddiIpFragFramesCreated=hpSwitchFddiIpFragFramesCreated, hpSwitchIpStatAddr=hpSwitchIpStatAddr, hpSwitchQueueWatchStatsTable=hpSwitchQueueWatchStatsTable, hpIgmpStatsPortEntry2=hpIgmpStatsPortEntry2, hpSwitchFddiSystemStatIndex=hpSwitchFddiSystemStatIndex, hpSwitchPortFdbAddrEntry=hpSwitchPortFdbAddrEntry, hpFECStatsPortTrunkNumber=hpFECStatsPortTrunkNumber, hpSwitchQueueWatchStatsQueueIndex=hpSwitchQueueWatchStatsQueueIndex, hpSwitchFddiSystemCpuUtil=hpSwitchFddiSystemCpuUtil, hpSwitchFlowControlStatusEntry=hpSwitchFlowControlStatusEntry, hpSshStatsSourceIpType=hpSshStatsSourceIpType, hpABCStatsIpxRipSapControl=hpABCStatsIpxRipSapControl, hpSwitchFddiSystemStatTable=hpSwitchFddiSystemStatTable, hpIgmpStatsActiveGroupAddr=hpIgmpStatsActiveGroupAddr, hpSwitchCpuStat=hpSwitchCpuStat, hpSwitchPhysicalPort=hpSwitchPhysicalPort, hpFECStatsPortNegotiationStatus=hpFECStatsPortNegotiationStatus, hpABCStatsArpReplies=hpABCStatsArpReplies, hpIgmpStatsReports=hpIgmpStatsReports, hpFECStatsPortMode=hpFECStatsPortMode, hpSwitchVlanFdbPort=hpSwitchVlanFdbPort, hpSshStatsSesVersion=hpSshStatsSesVersion, hpSwitchIpxStatEntry=hpSwitchIpxStatEntry, hpIgmpStatsPortAccess=hpIgmpStatsPortAccess, hpSwitchMiscStat=hpSwitchMiscStat, hpSwitchQueueWatchStatsQueueDrops=hpSwitchQueueWatchStatsQueueDrops, hpSwitchFddiIpFragStatTable=hpSwitchFddiIpFragStatTable, hpSwitchVlanFdbAddrTable=hpSwitchVlanFdbAddrTable, hpSwitchFddiSystemOsVersion=hpSwitchFddiSystemOsVersion, hpSwitchIpStatTable=hpSwitchIpStatTable, hpGvrpStatsPortVlanMember=hpGvrpStatsPortVlanMember, hpSwitchIpxStatGatewayAddr=hpSwitchIpxStatGatewayAddr, hpSwitchPortFdbAddress=hpSwitchPortFdbAddress, hpGvrpStatsEntry=hpGvrpStatsEntry, hpSwitchFddiIpFragStat=hpSwitchFddiIpFragStat, hpSwitchFdbAddressCount=hpSwitchFdbAddressCount, hpIgmpStatsPortLeaveTimer2=hpIgmpStatsPortLeaveTimer2, hpLdbalStatsPortTable=hpLdbalStatsPortTable, hpFECStatsTrunkForwardingMode=hpFECStatsTrunkForwardingMode, hpSshStatsSourceIpPort=hpSshStatsSourceIpPort, hpIgmpStatsEntry=hpIgmpStatsEntry, hpSwitchPortFdbVlanId=hpSwitchPortFdbVlanId, hpFECStatsPortHellosSent=hpFECStatsPortHellosSent, hpFECStatsPortIndex=hpFECStatsPortIndex, hpSwitchPhysicalPortTable=hpSwitchPhysicalPortTable, hpSwitchFlowControlStatus=hpSwitchFlowControlStatus, hpSwitchFlowControlState=hpSwitchFlowControlState, hpSwitchFddiSystemRomVersion=hpSwitchFddiSystemRomVersion, hpSwitchIpxStatTable=hpSwitchIpxStatTable, hpSwitchFddiSystemMemoryTotal=hpSwitchFddiSystemMemoryTotal, hpSwitchFddiSystemBuildDirectory=hpSwitchFddiSystemBuildDirectory, hpFECStatsTrunkFlushPktsEchoed=hpFECStatsTrunkFlushPktsEchoed, hpLdbalStatsPeerPort=hpLdbalStatsPeerPort, hpSwitchFddiSystemBuildDate=hpSwitchFddiSystemBuildDate, hpLdbalStatsPortEntry=hpLdbalStatsPortEntry, hpSshStatsSourceIpAddress=hpSshStatsSourceIpAddress, hpSwitchPortFdbVidList=hpSwitchPortFdbVidList, hpSwitchIpStatTimepPollInterval=hpSwitchIpStatTimepPollInterval, hpSwitchIpStatIndex=hpSwitchIpStatIndex, hpSwitchFdbInfo=hpSwitchFdbInfo, hpSwitchIpStatTimepAdminStatus=hpSwitchIpStatTimepAdminStatus, hpIgmpStatsPortType2=hpIgmpStatsPortType2, hpLdbalStatsAdjacentSwitch=hpLdbalStatsAdjacentSwitch, hpSwitchQueueWatchStatsPortIndex=hpSwitchQueueWatchStatsPortIndex, hpSwitchIpxStatNodeAddr=hpSwitchIpxStatNodeAddr, hpIgmpStatsQuerierAccessPort=hpIgmpStatsQuerierAccessPort, hpGvrpStatsVlanIndex=hpGvrpStatsVlanIndex, hpABCStatsVlanIndex=hpABCStatsVlanIndex, hpSwitchStatistics=hpSwitchStatistics, hpLdbalStatsMeshWarningStatus=hpLdbalStatsMeshWarningStatus, hpSwitchPhysicalPortType=hpSwitchPhysicalPortType, hpSwitchIpStat=hpSwitchIpStat, hpFECStatsPortFlushPktsEchoed=hpFECStatsPortFlushPktsEchoed, hpABCStatsPortType=hpABCStatsPortType, hpSwitchPortFdbId=hpSwitchPortFdbId, hpFECStatsTrunkIndex=hpFECStatsTrunkIndex, hpSwitchPhysicalPortEntry=hpSwitchPhysicalPortEntry, hpFECStatsPortPartner=hpFECStatsPortPartner, hpSwitchVlanFdbAddrEntry=hpSwitchVlanFdbAddrEntry, hpFECStatsTrunkEntry=hpFECStatsTrunkEntry, hpIgmpStatsPortTable2=hpIgmpStatsPortTable2, hpABCStatsTable=hpABCStatsTable, hpIgmpStatsPortAccess2=hpIgmpStatsPortAccess2, hpPortGvrpCtrlStatus=hpPortGvrpCtrlStatus, hpIgmpStatsPortEntry=hpIgmpStatsPortEntry, hpSwitchFddiIpFragFrameErrors=hpSwitchFddiIpFragFrameErrors, hpFECStatsPortMyAutoMode=hpFECStatsPortMyAutoMode, hpSwitchMacStats=hpSwitchMacStats, hpLdbalStatsPortState=hpLdbalStatsPortState, hpSwitchIpStatAdminStatus=hpSwitchIpStatAdminStatus, hpFECStatsPortHellosReceived=hpFECStatsPortHellosReceived, hpSshStatsTable=hpSshStatsTable, hpSwitchFddiSystemMemoryFree=hpSwitchFddiSystemMemoryFree, hpIgmpStatsVlanIndex=hpIgmpStatsVlanIndex, hpGvrpStatsPortIndex=hpGvrpStatsPortIndex, hpFECStatsTrunkName=hpFECStatsTrunkName, hpGvrpStatsTable=hpGvrpStatsTable, hpSwitchFddiSystemStatEntry=hpSwitchFddiSystemStatEntry, hpGvrpPortIfOperStatus=hpGvrpPortIfOperStatus, hpABCStatsIpRipControl=hpABCStatsIpRipControl, hpSwitchIpxStat=hpSwitchIpxStat, hpFECStatsTrunk=hpFECStatsTrunk, hpSshStatsSesIndex=hpSshStatsSesIndex, hpIgmpStatsTable=hpIgmpStatsTable, hpSwitchIpStatTimepServerAddr=hpSwitchIpStatTimepServerAddr, hpIgmpStatsPortIndex2=hpIgmpStatsPortIndex2, MacAddress=MacAddress, hpSwitchIpStatMask=hpSwitchIpStatMask, hpSwitchPortFdbAddrTable=hpSwitchPortFdbAddrTable, hpSshStatsEntry=hpSshStatsEntry)

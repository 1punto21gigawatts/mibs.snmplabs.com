#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-FrameRelayNniMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-FrameRelayNniMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:30:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
DisplayString, Integer32, InterfaceIndex, Gauge32, RowPointer, RowStatus, Unsigned32, StorageType, Counter32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "DisplayString", "Integer32", "InterfaceIndex", "Gauge32", "RowPointer", "RowStatus", "Unsigned32", "StorageType", "Counter32")
DigitString, AsciiString, Hex, Link, PassportCounter64, FixedPoint3, EnterpriseDateAndTime, Unsigned64, NonReplicated, HexString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "DigitString", "AsciiString", "Hex", "Link", "PassportCounter64", "FixedPoint3", "EnterpriseDateAndTime", "Unsigned64", "NonReplicated", "HexString")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Integer32, iso, Counter64, ObjectIdentity, NotificationType, ModuleIdentity, MibIdentifier, Unsigned32, Bits, Gauge32, Counter32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Integer32", "iso", "Counter64", "ObjectIdentity", "NotificationType", "ModuleIdentity", "MibIdentifier", "Unsigned32", "Bits", "Gauge32", "Counter32", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
frameRelayNniMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23))
mscFrNni = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70))
mscFrNniRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 1), )
if mibBuilder.loadTexts: mscFrNniRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNni components.')
mscFrNniRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"))
if mibBuilder.loadTexts: mscFrNniRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNni component.')
mscFrNniRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNni components. These components can be added and deleted.')
mscFrNniComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniStorageType.setDescription('This variable represents the storage type value for the mscFrNni tables.')
mscFrNniIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mscFrNniIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniIndex.setDescription('This variable represents the index for the mscFrNni tables.')
mscFrNniCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 10), )
if mibBuilder.loadTexts: mscFrNniCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscFrNniCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"))
if mibBuilder.loadTexts: mscFrNniCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCidDataEntry.setDescription('An entry in the mscFrNniCidDataTable.')
mscFrNniCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscFrNniStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11), )
if mibBuilder.loadTexts: mscFrNniStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscFrNniStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"))
if mibBuilder.loadTexts: mscFrNniStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniStateEntry.setDescription('An entry in the mscFrNniStateTable.')
mscFrNniAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrNniOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrNniUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrNniAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscFrNniProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscFrNniControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscFrNniAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscFrNniStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscFrNniUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscFrNniStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 12), )
if mibBuilder.loadTexts: mscFrNniStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniStatsTable.setDescription('This group contains the statistics about the operational behaviour of the service at the interface level.')
mscFrNniStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"))
if mibBuilder.loadTexts: mscFrNniStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniStatsEntry.setDescription('An entry in the mscFrNniStatsTable.')
mscFrNniLastUnknownDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLastUnknownDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLastUnknownDlci.setDescription('This attribute identifies the most recent DLCI which user frames were received on for which a DLCI has not been provisioned on the port.')
mscFrNniUnknownDlciFramesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniUnknownDlciFramesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniUnknownDlciFramesFromIf.setDescription('This attribute contains a count of the number of frames received from the interface with an unknown DLCI (DLCI which is not provisioned). When the maximum is exceeded the count wraps to zero.')
mscFrNniInvalidHeaderFramesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniInvalidHeaderFramesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniInvalidHeaderFramesFromIf.setDescription('This attribute counts the number of frames received from the interface with an invalid header format. When the maximum is exceeded the count wraps to zero.')
mscFrNniIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 13), )
if mibBuilder.loadTexts: mscFrNniIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscFrNniIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"))
if mibBuilder.loadTexts: mscFrNniIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniIfEntryEntry.setDescription('An entry in the mscFrNniIfEntryTable.')
mscFrNniIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscFrNniIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscFrNniOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 14), )
if mibBuilder.loadTexts: mscFrNniOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscFrNniOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"))
if mibBuilder.loadTexts: mscFrNniOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniOperStatusEntry.setDescription('An entry in the mscFrNniOperStatusTable.')
mscFrNniSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscFrNniEmissionPriorityQsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 15), )
if mibBuilder.loadTexts: mscFrNniEmissionPriorityQsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniEmissionPriorityQsTable.setDescription('This group contains the provisionable attribute to specifie the number of Frame Relay egress emission priority queues to be used on that Frame Relay Interface')
mscFrNniEmissionPriorityQsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"))
if mibBuilder.loadTexts: mscFrNniEmissionPriorityQsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniEmissionPriorityQsEntry.setDescription('An entry in the mscFrNniEmissionPriorityQsTable.')
mscFrNniNumberOfEmissionQs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniNumberOfEmissionQs.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniNumberOfEmissionQs.setDescription('This attribute specifies the number of egress emission priority queues that will be used for that Frame Relay interface. The possible values of this attribute are 2 or 4: For V.35, V.11, HSSI, E1, DS1, E3, DS3 or 8pDS1 the possible values are: 2 (in which case they are hardware queues), or 4 (in which case they are software queues). For DS1C, E1C or DS3C the possible values are 2, 4 (in all cases they are software queues).')
mscFrNniFrmToIfByQueueTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 341), )
if mibBuilder.loadTexts: mscFrNniFrmToIfByQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFrmToIfByQueueTable.setDescription('This attribute counts the total number of frames transmitted to the interface per egress emission priority queue since the component has been activated. There is potientially a maximum of 4 emission priority queues. The number of available egress queues varies according to the value of the provisionable attribute numberOfEmissionQs. Egress queue 0 has the lowest priority, while egress queue 3 has the highest priority. The queue values are only indicated when the numberOfEmissionQs is set to 4 queues.')
mscFrNniFrmToIfByQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 341, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniFrmToIfByQueueIndex"))
if mibBuilder.loadTexts: mscFrNniFrmToIfByQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFrmToIfByQueueEntry.setDescription('An entry in the mscFrNniFrmToIfByQueueTable.')
mscFrNniFrmToIfByQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 341, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscFrNniFrmToIfByQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFrmToIfByQueueIndex.setDescription('This variable represents the index for the mscFrNniFrmToIfByQueueTable.')
mscFrNniFrmToIfByQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 341, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFrmToIfByQueueValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFrmToIfByQueueValue.setDescription('This variable represents an individual value for the mscFrNniFrmToIfByQueueTable.')
mscFrNniOctetToIfByQueueTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 342), )
if mibBuilder.loadTexts: mscFrNniOctetToIfByQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniOctetToIfByQueueTable.setDescription('This attribute counts the total number of octets transmitted from the service to the interface per emission priority queue since the component has been activated. There is potientially a maximum of 4 emission priority queues. The number of available egress queues varies according to the value of the provisionable attribute numberOfEmissionQs. Egress queue 0 has the lowest priority, while egress queue 3 has the highest priority.')
mscFrNniOctetToIfByQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 342, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniOctetToIfByQueueIndex"))
if mibBuilder.loadTexts: mscFrNniOctetToIfByQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniOctetToIfByQueueEntry.setDescription('An entry in the mscFrNniOctetToIfByQueueTable.')
mscFrNniOctetToIfByQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 342, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscFrNniOctetToIfByQueueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniOctetToIfByQueueIndex.setDescription('This variable represents the index for the mscFrNniOctetToIfByQueueTable.')
mscFrNniOctetToIfByQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 342, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniOctetToIfByQueueValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniOctetToIfByQueueValue.setDescription('This variable represents an individual value for the mscFrNniOctetToIfByQueueTable.')
mscFrNniDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2))
mscFrNniDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 1), )
if mibBuilder.loadTexts: mscFrNniDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDna components.')
mscFrNniDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"))
if mibBuilder.loadTexts: mscFrNniDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDna component.')
mscFrNniDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDna components. These components cannot be added nor deleted.')
mscFrNniDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaStorageType.setDescription('This variable represents the storage type value for the mscFrNniDna tables.')
mscFrNniDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaIndex.setDescription('This variable represents the index for the mscFrNniDna tables.')
mscFrNniDnaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 10), )
if mibBuilder.loadTexts: mscFrNniDnaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaAddressTable.setDescription('This group contains attributes common to all DNAs. Every DNA used in the network is defined with this group of 2 attributes.')
mscFrNniDnaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"))
if mibBuilder.loadTexts: mscFrNniDnaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaAddressEntry.setDescription('An entry in the mscFrNniDnaAddressTable.')
mscFrNniDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the DNA that is entered. Address may belong to X.121 or E.164 plans. X.121 is used in packet switched data networks.')
mscFrNniDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaDataNetworkAddress.setDescription("This attribute indicates the customer's unique identifier. It is the equivalent of the telephone number in the telephone network.")
mscFrNniDnaOutgoingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11), )
if mibBuilder.loadTexts: mscFrNniDnaOutgoingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaOutgoingOptionsTable.setDescription('This group defines DNA call options for calls made from the interface. These options are not used for calls arriving to the interface represented by this DNA.')
mscFrNniDnaOutgoingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"))
if mibBuilder.loadTexts: mscFrNniDnaOutgoingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaOutgoingOptionsEntry.setDescription('An entry in the mscFrNniDnaOutgoingOptionsTable.')
mscFrNniDnaOutDefaultPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaOutDefaultPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaOutDefaultPriority.setDescription('This attribute indicates the default priority of outgoing calls from the DTE to the network. It can be overridden by the discardPriority under DLCI Direct Call subcomponent. This option can be also included in X.25 signalling, in such case it will be overruled.')
mscFrNniDnaOutDefaultPathSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1))).clone('throughput')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaOutDefaultPathSensitivity.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaOutDefaultPathSensitivity.setDescription('This attribute specifies the default class of path sensitivity to network for all outgoing calls that use this DNA. The chosen default class of path sensitivity applies to all outgoing calls established using this DNA. This attribute, if set to throughput, indicates that the default class is throughput sensitive. If set to delay, then the default class is delay sensitive. The default of outDefaultPathSensitivity is throughput.')
mscFrNniDnaOutPathSensitivityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaOutPathSensitivityOverRide.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaOutPathSensitivityOverRide.setDescription('If this attribute is set to yes in the call request, the called end will use the calling end provisioning data on path sensitivity to override its own provisioning data. The default of outPathSensitivityOverRide is yes.')
mscFrNniDnaOutDefaultPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaOutDefaultPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaOutDefaultPathReliability.setDescription('This attribute specifies the default class of routing for reliability routing for all outgoing calls (from the DTE to the network) using this particular DNA. The chosen default class of routing applies to all outgoing calls established using this DNA, and applies to the packets travelling in both directions on all outgoing calls (local to remote, and remote to local). For incoming calls, the default class of routing is chosen by the calling party (as opposed to DPN, where either end of the call can choose the default routing class). This attribute, if set to a value of normal, indicates that the default class of routing is normal reliability routing. If set to a value of high, then the default class of routing is high reliability routing. High reliability is the standard choice for most DPN and Passport services. It usually indicates that packets are overflowed or retransmitted at various routing levels. Typically high reliability results in duplication and disordering of packets in the network when errors are detected or during link congestion. However, the VC handles the duplication and disordering to ensure that packets are delivered to the DTE properly. For the Frame Relay service, duplication of packets is not desired, in which case, normal reliability may be chosen as the preferred class of routing.')
mscFrNniDnaOutAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaOutAccess.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaOutAccess.setDescription("This attribute is an extension of the Closed User Group (CUG) facility, as follows: This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE to the network) to the open (non-CUG) part of the network are permitted. It also permits outgoing calls to DTEs that have Incoming Access capabilities. If set to a value of disallowed, then such calls cannot be made using this DNA. Such calls will be cleared by the local DCE. This attribute corresponds to the ITU-T 'Closed User Group with Outgoing Access' feature for DNAs in that outgoing access is granted if this attribute is set to a value of allowed.")
mscFrNniDnaDefaultTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaDefaultTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaDefaultTransferPriority.setDescription('This attribute specifies the default transfer priority for all outgoing calls using this particular DNA. It can be overridden by the transferPriority provisioned in the Dlci DirectCall sub-component. The transfer priority is a preference configured for an application according to its delay-sensitivity requirement. Frames with higher transfer priority are served by the network before the frames with lower priority. The transfer priority standard is defined to have 16 levels from 0 to 15. Each transfer priority n, where n indicates the transfer priority index, contains a default setting for routing class of service (multimedia, delay or throughput) and frame relay egress queue (depending on the number of supported egress queues on the remote end interface) specified by the routingClassOfService and emissionPriority attributes provisioned in the Mod Frs DprsNet Tpm/n component. The default mapping can be altered by a user if required. The default defaultTransferPriority is 0.')
mscFrNniDnaTransferPriorityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaTransferPriorityOverRide.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaTransferPriorityOverRide.setDescription('When this attribute is set to yes in the call request, the called end will use the calling end provisioning data on transfer priority to override its own provisioning data. If it is set no, the called end will use its own provisioning data on transfer priority. This attribute is not applicable for Frame Relay SVCs. For more information about transfer priority, please refer to the previous attribute defaultTransferPriority. The default of transferPriorityOverRide is yes.')
mscFrNniDnaIncomingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 12), )
if mibBuilder.loadTexts: mscFrNniDnaIncomingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaIncomingOptionsTable.setDescription('This group defines options for incoming calls. These options are used for calls arriving to the interface represented by this DNA. For calls originated from the interface, IncomingOptions attributes are not used.')
mscFrNniDnaIncomingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"))
if mibBuilder.loadTexts: mscFrNniDnaIncomingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaIncomingOptionsEntry.setDescription('An entry in the mscFrNniDnaIncomingOptionsTable.')
mscFrNniDnaIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaIncAccess.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaIncAccess.setDescription("This attribute, if set to a value of allowed specifies that incoming calls (from the network to the DTE) from the open (non-CUG) part of the network are permitted. It also permits incoming calls from DTEs that have outgoing access capabilities. If set to a value of disallowed, such calls cannot be made to this DNA. They will be cleared by the local DCE. This attribute corresponds to the CCITT 'Closed User Group with Incoming Access' feature for DNAs in that incoming access is granted if this attribute is set to a value of allowed.")
mscFrNniDnaCallOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 13), )
if mibBuilder.loadTexts: mscFrNniDnaCallOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaCallOptionsTable.setDescription('This group defines additional all options for not related to direction of the call.')
mscFrNniDnaCallOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"))
if mibBuilder.loadTexts: mscFrNniDnaCallOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaCallOptionsEntry.setDescription('An entry in the mscFrNniDnaCallOptionsTable.')
mscFrNniDnaAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 13, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaAccountClass.setDescription('This attribute specifies the accounting class which is reserved for network operations usage. Its value is returned in the accounting record in the local and remote service type attributes. Use of this attribute is decided by network operator. This attribute is returned by the local VC in the accounting record for all calls that are set up using this particular DNA.')
mscFrNniDnaAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 13, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaAccountCollection.setDescription("This attribute indicates that accounting records are to be collected by the network for the various reasons: billing, test, study, auditing. The last of the parameters, force, indicates that accounting records are to be collected irrespective of other collection reasons. The force option is available for X.75 Gateways only. If none of these reasons are set, then accounting will be suppressed. To set a specific accounting collection reason, the reason is entered and the corresponding bit in the structure is set to a value of 1. To turn off a specific accounting collection reason, the reason is entered preceded with the '~' character, and the corresponding bit in the structure is set to a value of 0. The bit placement for the accounting collection reasons is as follows: Bit 0 - Bill Bit 1 - Test Bit 2 - Study Bit 3 - Audit Bit 4 - Force Description of bits: bill(0) test(1) study(2) audit(3) force(4)")
mscFrNniDnaServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 13, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaServiceExchange.setDescription('This attribute is an arbitrary number, Data Service Exchange, as entered by the network operator and reported in accounting record. It is converted into an internal 8-bit integer value for use in the accounting record as well as in various X.25 and X.75 Tariff utilities.')
mscFrNniDnaEgressAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaEgressAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaEgressAccounting.setDescription('This attribute specifies if egress accounting is enabled by the frame relay service. If egress accounting is disabled, only segment counts are collected by the VC. No frame relay counts appear in the accounting records for the frame relay service. If egress accounting is enabled, the accounting records for the frame relay service will contain frame relay specific counts.')
mscFrNniDnaDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 13, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("dprsOnly", 0), ("dprsMcsOnly", 1), ("dprsMcsFirst", 2))).clone('dprsOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaDataPath.setDescription('This attribute specifies the data path to be used by Virtual Circuits on this interface. If the connection has a DirectCall component then the value can be overridden by the dataPath attribute of the DirectCall component. This value applies to the connection after data transfer state is reached. All the data and control trafic will be sent using this data path. If the provisioned dataPath is not available the connection is not established. The value of the dataPath is signalled by both ends of the connection. If this value is not the same at both ends dprsOnly is used for the duration of the connection. A virtual circuit connection is always established using dprsOnly even if this attribute is provisioned as some other value. dprsOnly - dynamic packet routing system is used dprsMcsOnly - dprs Multi-Service Cut-Through Switching path is used. dprsMcsFirst - dprs Multi-Service Cut-Through Switching path is used if it is available. If it is not avaliable dprsOnly is used.')
mscFrNniDnaCug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2))
mscFrNniDnaCugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 1), )
if mibBuilder.loadTexts: mscFrNniDnaCugRowStatusTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDnaCug components.')
mscFrNniDnaCugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaCugIndex"))
if mibBuilder.loadTexts: mscFrNniDnaCugRowStatusEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDnaCug component.')
mscFrNniDnaCugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaCugRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDnaCug components. These components can be added and deleted.')
mscFrNniDnaCugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaCugComponentName.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDnaCugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaCugStorageType.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugStorageType.setDescription('This variable represents the storage type value for the mscFrNniDnaCug tables.')
mscFrNniDnaCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: mscFrNniDnaCugIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugIndex.setDescription('This variable represents the index for the mscFrNniDnaCug tables.')
mscFrNniDnaCugCugOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 10), )
if mibBuilder.loadTexts: mscFrNniDnaCugCugOptionsTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugCugOptionsTable.setDescription("Attributes in this group define ClosedUserGroup options associated with interlockCode. DNA's with the same CUG (interlockCode) can make calls within this group. Various combinations which permit or prevent calls in the same CUG group are defined here.")
mscFrNniDnaCugCugOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaCugIndex"))
if mibBuilder.loadTexts: mscFrNniDnaCugCugOptionsEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugCugOptionsEntry.setDescription('An entry in the mscFrNniDnaCugCugOptionsTable.')
mscFrNniDnaCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("national", 0), ("international", 1))).clone('national')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaCugType.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugType.setDescription('This attribute specifies the CUG type - the CUG is either a national CUG, or an international CUG. International closed user groups are usually established between DTEs for which there is an X.75 Gateway between; whereas national closed user groups are usually established between DTEs for which there is no X.75 Gateway between. (National CUGs cannot normally traverse an X.75 Gateway). If this attribute is set to national, then the CUG is a national CUG, in which case, the dnic should be left at its default value since it is not part of a national CUG. If this attribute is set to international, then the CUG is an international CUG, in which case, the dnic should be set appropriately as part of the CUG interlockCode.')
mscFrNniDnaCugDnic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="30303030")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaCugDnic.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugDnic.setDescription('This attribute specifies the dnic (Data Network ID Code) of the CUG by which packet networks are identified. This attribute is not applicable if the CUG is a national CUG, as specified by the CUG type attribute. There are usually 1 or 2 dnics assigned per country, for public networks. The U.S. is an exception where each BOC has a dnic. Also, a group of private networks can have its own dnic. dnic value is not an arbitrary number. It is assigned by international agreement and controlled by CCITT.')
mscFrNniDnaCugInterlockCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaCugInterlockCode.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugInterlockCode.setDescription("This attribute specifies the CUG identifier of a national or international CUG call. It is an arbitrary number and it also can be called CUG in some descriptions. Interfaces (DNA's) defined with this number can make calls to DNA's with the same interlockCode.")
mscFrNniDnaCugPreferential = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaCugPreferential.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugPreferential.setDescription("The attribute 'preferential', if set to yes indicates that this CUG is the SIMPLE CUG (as defined in ITU X.36 [10/96]), in which case it will be used during the call establishment phase if the DTE has not explicitly specified a CUG index in the call request packet. If set to no, then this CUG is not the SIMPLE CUG, but an instance of the SELECTABLE CUG. The attribute 'preferential' is set to no by CAS when a CUG instance is created. If only one CUG instance exists under a DNA, and if this CUG's attributes 'incCalls' and 'outCall' are both set to allowed, then this CUG instance can be changed to a SIMPLE CUG by setting the attribute 'preferential' to yes. If more than one CUG instances exist under a DNA, none of the CUGs can be set by the user as 'preferential'. Essentially, the attribute 'preferential' distinguishes a SIMPLE CUG from a SELECTABLE CUG. In the case of a FRUNI DNA with a single CUG instance, the CUG can be a SIMPLE CUG (preferential = yes) or the only instance of a SELECTABLE CUG (preferential = no).")
mscFrNniDnaCugOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaCugOutCalls.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugOutCalls.setDescription("This attribute, if set to allowed indicates that outgoing calls (from the DTE into the network) can be made using this particular CUG. If set to a value of disallowed, then outgoing calls cannot be made using this CUG - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Outgoing Calls Barred' feature for CUGs in that outgoing calls are barred if this attribute is set to a value of disallowed.")
mscFrNniDnaCugIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaCugIncCalls.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaCugIncCalls.setDescription("This attribute, if set to allowed indicates that incoming calls (from the network to the DTE) can be made using this particular CUG. If set to disallowed, then incoming calls cannot be made using this CUG - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Incoming Calls Barred' feature for CUGs in that incoming calls are barred if this attribute is set to a value of disallowed.")
mscFrNniDnaHgM = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3))
mscFrNniDnaHgMRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 1), )
if mibBuilder.loadTexts: mscFrNniDnaHgMRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDnaHgM components.')
mscFrNniDnaHgMRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaHgMIndex"))
if mibBuilder.loadTexts: mscFrNniDnaHgMRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDnaHgM component.')
mscFrNniDnaHgMRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaHgMRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDnaHgM components. These components can be added and deleted.')
mscFrNniDnaHgMComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDnaHgMStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMStorageType.setDescription('This variable represents the storage type value for the mscFrNniDnaHgM tables.')
mscFrNniDnaHgMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniDnaHgMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMIndex.setDescription('This variable represents the index for the mscFrNniDnaHgM tables.')
mscFrNniDnaHgMIfTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 10), )
if mibBuilder.loadTexts: mscFrNniDnaHgMIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMIfTable.setDescription('This group contains the interface parameters between the HuntGroupMember and the hunt group server.')
mscFrNniDnaHgMIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaHgMIndex"))
if mibBuilder.loadTexts: mscFrNniDnaHgMIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMIfEntry.setDescription('An entry in the mscFrNniDnaHgMIfTable.')
mscFrNniDnaHgMAvailabilityUpdateThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2048, 16777216)).clone(8192)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailabilityUpdateThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailabilityUpdateThreshold.setDescription('This attribute specifies how much availableAggregateCIR can change before an Availability Message Packet (AMP) is sent to the hunt group server informing it of the change. If the value specified is not a multiple of 2048, the value actually used as the threshold will be the next higher multiple of 2048.')
mscFrNniDnaHgMOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 11), )
if mibBuilder.loadTexts: mscFrNniDnaHgMOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMOpTable.setDescription('This group contains the operational attributes of the HuntGroupMember component.')
mscFrNniDnaHgMOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaHgMIndex"))
if mibBuilder.loadTexts: mscFrNniDnaHgMOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMOpEntry.setDescription('An entry in the mscFrNniDnaHgMOpTable.')
mscFrNniDnaHgMMaximumAvailableAggregateCir = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMMaximumAvailableAggregateCir.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaHgMMaximumAvailableAggregateCir.setDescription('This attribute indicates the maximum available bandwidth for this hunt group member. This value represents the total sum of the sixteen egress bandwidth pools. It is the sum of the sixteen indices of the FrNni Ca egressBandwidthPool attribute multiplied by the link speed.')
mscFrNniDnaHgMAvailableAggregateCir = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailableAggregateCir.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailableAggregateCir.setDescription('This attribute indicates the current total available bandwidth reported to the hunt group server in the Availability Message Packet (AMP). This value represents the sum of the sixteen currently available egress bandwidth pools. It is the sum of the sixteen indices of the FrNni Ca egressPoolAvailableBandwidth attribute. It increments when a connection is released. It decrements when a connection is accepted. Both this attribute and the availableDlcis attribute must be non zero for this interface to receive calls on a hunt group.')
mscFrNniDnaHgMAvailabilityDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-16777216, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailabilityDelta.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailabilityDelta.setDescription('This attribute indicates the net change in the available aggregate CIR since the last Availability Message Packet (AMP) was sent to the Hunt Group. Once the absolute value of this attribute reaches the availabilityUpdateThreshold an AMP is sent to the hunt group server(s) and the availabilityDelta is re-computed.')
mscFrNniDnaHgMAvailableDlcis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailableDlcis.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailableDlcis.setDescription('This attribute indicates the number of DLCIs available for SVCs on the interface associated with this DNA. If this value reaches 0, an AMP with zero availability is sent to the hunt group server(s). Both this attribute and the availableAggregateCir attribute must be non zero for this DNA to receive calls on the hunt group.')
mscFrNniDnaHgMMaximumAvailableAggregateCir64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 11, 1, 6), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMMaximumAvailableAggregateCir64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMMaximumAvailableAggregateCir64.setDescription('This attribute indicates the maximum available bandwidth for this hunt group member. This value represents the total sum of the sixteen egress bandwidth pools. It is the sum of the sixteen indices of the FrNni Ca egressBandwidthPool attribute multiplied by the link speed.')
mscFrNniDnaHgMAvailableAggregateCir64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 11, 1, 7), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailableAggregateCir64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMAvailableAggregateCir64.setDescription('This attribute indicates the current total available bandwidth reported to the hunt group server in the Availability Message Packet (AMP). This value represents the sum of the sixteen currently available egress bandwidth pools. It is the sum of the sixteen indices of the FrNni Ca egressPoolAvailableBandwidth attribute. It increments when a connection is released. It decrements when a connection is accepted. Both this attribute and the availableDlcis attribute must be non zero for this interface to receive calls on a hunt group.')
mscFrNniDnaHgMHgAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2))
mscFrNniDnaHgMHgAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 1), )
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDnaHgMHgAddr components.')
mscFrNniDnaHgMHgAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaHgMIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaHgMHgAddrIndex"))
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDnaHgMHgAddr component.')
mscFrNniDnaHgMHgAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDnaHgMHgAddr components. These components can be added and deleted.')
mscFrNniDnaHgMHgAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDnaHgMHgAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrStorageType.setDescription('This variable represents the storage type value for the mscFrNniDnaHgMHgAddr tables.')
mscFrNniDnaHgMHgAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrIndex.setDescription('This variable represents the index for the mscFrNniDnaHgMHgAddr tables.')
mscFrNniDnaHgMHgAddrAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 10), )
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrAddrTable.setDescription('This group contains attributes common to all DNAs. Every DNA used in the network is defined with this group of 2 attributes.')
mscFrNniDnaHgMHgAddrAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaHgMIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDnaHgMHgAddrIndex"))
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrAddrEntry.setDescription('An entry in the mscFrNniDnaHgMHgAddrAddrTable.')
mscFrNniDnaHgMHgAddrNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the DNA. The address may belong to X.121 or E.164 plans.')
mscFrNniDnaHgMHgAddrDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 2, 3, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDnaHgMHgAddrDataNetworkAddress.setDescription('This attribute contains digits which form the unique identifier of the customer interface. It can be compared (approximation only) to a telephone number where the phone number identifies a unique telephone set. DNA digits are selected and assigned by network operators.')
mscFrNniFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3))
mscFrNniFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 1), )
if mibBuilder.loadTexts: mscFrNniFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniFramer components.')
mscFrNniFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniFramerIndex"))
if mibBuilder.loadTexts: mscFrNniFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniFramer component.')
mscFrNniFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniFramer components. These components can be added and deleted.')
mscFrNniFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerStorageType.setDescription('This variable represents the storage type value for the mscFrNniFramer tables.')
mscFrNniFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerIndex.setDescription('This variable represents the index for the mscFrNniFramer tables.')
mscFrNniFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 10), )
if mibBuilder.loadTexts: mscFrNniFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscFrNniFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniFramerIndex"))
if mibBuilder.loadTexts: mscFrNniFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerProvEntry.setDescription('An entry in the mscFrNniFramerProvTable.')
mscFrNniFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscFrNniFramerLinkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 11), )
if mibBuilder.loadTexts: mscFrNniFramerLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerLinkTable.setDescription('This group contains attributes defining the framing of data on the link interface.')
mscFrNniFramerLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniFramerIndex"))
if mibBuilder.loadTexts: mscFrNniFramerLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerLinkEntry.setDescription('An entry in the mscFrNniFramerLinkTable.')
mscFrNniFramerDataInversion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 16))).clone(namedValues=NamedValues(("off", 0), ("on", 16))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniFramerDataInversion.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerDataInversion.setDescription("This attribute determines whether data bits are to be inverted (1 to 0 and 0 to 1) before transmission of frames to the interface. If the value of this attribute is On, the incoming data bits will also be inverted when frames are received from the link before being processed. This option is typically used in hdlc framing mode when inversion is used to guarantee 1's density. Note that aborts (in hdlc and interrupting modes) are corrupted when data is inverted. This attribute may only take its default value for non-MSA cards.")
mscFrNniFramerFrameCrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("crc16", 0), ("crc32", 1), ("noCrc", 2))).clone('crc16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniFramerFrameCrcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerFrameCrcType.setDescription('This attribute defines the type of CRC used. The CRC value calculated is appended to the end of the frames transmitted to the link. The CRC value is removed from the end of frames received from the link and checked for correctness. NoCrc means that CRC is not used. This attribute may take only its default value for non-MSA cards.')
mscFrNniFramerFlagsBetweenFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniFramerFlagsBetweenFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerFlagsBetweenFrames.setDescription('This attribute defines the number of flags that are inserted between frames sent to the link interface.')
mscFrNniFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 12), )
if mibBuilder.loadTexts: mscFrNniFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrNniFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniFramerIndex"))
if mibBuilder.loadTexts: mscFrNniFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerStateEntry.setDescription('An entry in the mscFrNniFramerStateTable.')
mscFrNniFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrNniFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrNniFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrNniFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13), )
if mibBuilder.loadTexts: mscFrNniFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscFrNniFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniFramerIndex"))
if mibBuilder.loadTexts: mscFrNniFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerStatsEntry.setDescription('An entry in the mscFrNniFramerStatsTable.')
mscFrNniFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerFrmToIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniFramerFrmToIf.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscFrNniFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerFrmFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniFramerFrmFromIf.setDescription('The number of frames received from the link interface by Framer.')
mscFrNniFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerOctetFromIf.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniFramerOctetFromIf.setDescription('The number of bytes received from the link interface by Framer.')
mscFrNniFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerAborts.setDescription('This attribute is the total number of aborts received.')
mscFrNniFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerCrcErrors.setDescription('This attribute is the total number of frames with CRC errors, occurring in the receive direction from the link.')
mscFrNniFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerLrcErrors.setDescription('This attribute is the total number of frames with LRC errors, occurring in the Tx link prior to transmission onto the link.')
mscFrNniFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerNonOctetErrors.setDescription('This attribute is the total number of frames that were non octet aligned.')
mscFrNniFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerOverruns.setDescription('This attribute is the total number of frames received from the link for which overruns occurred.')
mscFrNniFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerUnderruns.setDescription('This attribute is the total number of frames transmitted to the link for which underruns occurred.')
mscFrNniFramerLargeFrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerLargeFrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerLargeFrmErrors.setDescription('This attribute is the total number of frames received which were too large. The frame execeeded the maximumFrameLengthLimit provisioned attribute or it contained more than the 255 block hardware limit.')
mscFrNniFramerFrmModeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerFrmModeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerFrmModeErrors.setDescription('This attribute is the total number of frames detected with framing mode errors. A framingModeError is flagged when frames are inconsistent with the specified framingType, that is when interrupting frames are used while running in hdlc mode.')
mscFrNniFramerFrmToIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerFrmToIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerFrmToIf64.setDescription('The number of frames transmitted to the link interface by Framer. Note: This does not include the number of frames transmitted directly to the hardware queue, thus bypassing the Framer component.')
mscFrNniFramerFrmFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerFrmFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerFrmFromIf64.setDescription('The number of frames received from the link interface by Framer.')
mscFrNniFramerOctetFromIf64 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 13, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerOctetFromIf64.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerOctetFromIf64.setDescription('The number of bytes received from the link interface by Framer.')
mscFrNniFramerUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 14), )
if mibBuilder.loadTexts: mscFrNniFramerUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerUtilTable.setDescription('This group contains the link utilizaiton operational data for a Framer component.')
mscFrNniFramerUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniFramerIndex"))
if mibBuilder.loadTexts: mscFrNniFramerUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerUtilEntry.setDescription('An entry in the mscFrNniFramerUtilTable.')
mscFrNniFramerNormPrioLinkUtilToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 14, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerNormPrioLinkUtilToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerNormPrioLinkUtilToIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) sent to the link as a percentage of the available bandwidth on the link. Note that this indluces traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscFrNniFramerNormPrioLinkUtilFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 3, 14, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniFramerNormPrioLinkUtilFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniFramerNormPrioLinkUtilFromIf.setDescription('This attribute is the utilization of the normal and high priority data traffic (interruptable traffic) received from the link as a percentage of the available bandwidth on the link. Note that this includes traffic with Transfer Priorities (TP) of 0, 6 and 9 and/or Emission Priority of 2 and 3. The utilization is the average for the last minute.')
mscFrNniLmi = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4))
mscFrNniLmiRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 1), )
if mibBuilder.loadTexts: mscFrNniLmiRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniLmi components.')
mscFrNniLmiRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLmiIndex"))
if mibBuilder.loadTexts: mscFrNniLmiRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniLmi component.')
mscFrNniLmiRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniLmi components. These components cannot be added nor deleted.')
mscFrNniLmiComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniLmiStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiStorageType.setDescription('This variable represents the storage type value for the mscFrNniLmi tables.')
mscFrNniLmiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniLmiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiIndex.setDescription('This variable represents the index for the mscFrNniLmi tables.')
mscFrNniLmiParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 10), )
if mibBuilder.loadTexts: mscFrNniLmiParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiParmsTable.setDescription('This group contains the provisionable attributes of the Local Management Interface component.')
mscFrNniLmiParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLmiIndex"))
if mibBuilder.loadTexts: mscFrNniLmiParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiParmsEntry.setDescription('An entry in the mscFrNniLmiParmsTable.')
mscFrNniLmiProcedures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("ansi", 2), ("itu", 3), ("autoConfigure", 4))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLmiProcedures.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiProcedures.setDescription("This attribute selects the procedures to be used for the Local Management Interface. The following are the supported procedures: none: Local Management Interface procedures are not running on this interface. This accommodates Frame Relay user equipment which didn't implement any LMI procedures. In this case, the remaining attributes of this group are ignored. ansi: Local Management Interface procedures from the ANSI specification are supported. DLCI 0 is used for the LMI protocol. itu: Local Management Interface procedures from the ITU-T specification are supported. DLCI 0 is used for the LMI protocol. Was previously ccitt. autoConfigure: The interface determines automatically which Local Management Interface procedures to use. The procedures currently being used can be seen in the operational attribute opProcedures.")
mscFrNniLmiAsyncStatusReport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLmiAsyncStatusReport.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiAsyncStatusReport.setDescription('This attribute selects the use of asynchronous PVC status report procedures as specified in ANSI and CCITT specification.')
mscFrNniLmiErrorEventThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLmiErrorEventThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiErrorEventThreshold.setDescription('For the network-side-procedure, an event is defined as follows: (1) receipt of a STATUS ENQUIRY message, or (2) expiration of timer T392. An error event is (1) nonreceipt of STATUS ENQUIRY in T392 seconds; (2) invalid format of a LMI message; (3) invalid receive sequence number. For the user-side-procedure, an event is defined as a polling cycle or a status enquiry and status report exchange. An error event is (1) non-receipt of a STATUS within the polling cycle, or (2) invalid format of a LMI message, or (3) invalid sequence number This attribute specifies the number of error events which, if they occur within eventCount events, will cause a protocol error condition. The condition is cleared after eventCount sequential correct events occur. It must be less than or equal to eventCount (n393)')
mscFrNniLmiEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLmiEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiEventCount.setDescription('This attribute specifies the number of contiguous events within which no more than eventErrorThreshold error events are allowed. It must be greater than or equal to errorEventThreshold (n392).')
mscFrNniLmiCheckPointTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(15, 15), ValueRangeConstraint(20, 20), ValueRangeConstraint(25, 25), ValueRangeConstraint(30, 30), )).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLmiCheckPointTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiCheckPointTimer.setDescription('This attribute selects the time (in seconds) within which a STATUS ENQUIRY message is expected. It must be greater than linkVerificationTimer (t391).')
mscFrNniLmiIgnoreActiveBit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLmiIgnoreActiveBit.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiIgnoreActiveBit.setDescription('This attribute specifies whether the Frame Relay LMI Active Bit (A-bit) has a bearing on the transfer of user data across this Frame Relay interface for both directions of traffic flow. When this attribute is set to yes, the A-bit status of a user DLCI connection does not affect data transfer. When this attribute is set to no, data received from the local interface is discarded if an A-bit =0 condition exists towards the local user. Data being sent to the local interface is discarded if an A- bit = 0 condition exists towards the local user.')
mscFrNniLmiNniParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 11), )
if mibBuilder.loadTexts: mscFrNniLmiNniParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiNniParmsTable.setDescription('This group contains the provisionable attributes of the Local Management Interface component which are unique to NNI.')
mscFrNniLmiNniParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLmiIndex"))
if mibBuilder.loadTexts: mscFrNniLmiNniParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiNniParmsEntry.setDescription('An entry in the mscFrNniLmiNniParmsTable.')
mscFrNniLmiFullStatusPollingCycles = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLmiFullStatusPollingCycles.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiFullStatusPollingCycles.setDescription('This attribute specifies how frequently the Frame Relay NNI service should initiate a Status Enquiry for a full PVC status report. A polling cycle is a Status Enquiry and Status Report exchange.')
mscFrNniLmiLinkVerificationTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(15, 15), ValueRangeConstraint(20, 20), ValueRangeConstraint(25, 25), ValueRangeConstraint(30, 30), )).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLmiLinkVerificationTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiLinkVerificationTimer.setDescription('This attribute specifies how frequently the Frame Relay NNI service should initiate a Status Enquiry for link integrity verification. It must be less than checkPointTimer (t392).')
mscFrNniLmiStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 12), )
if mibBuilder.loadTexts: mscFrNniLmiStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrNniLmiStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLmiIndex"))
if mibBuilder.loadTexts: mscFrNniLmiStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiStateEntry.setDescription('An entry in the mscFrNniLmiStateTable.')
mscFrNniLmiAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrNniLmiOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrNniLmiUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrNniLmiPsiTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 13), )
if mibBuilder.loadTexts: mscFrNniLmiPsiTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiPsiTable.setDescription('This group provides the protocol status of the Local Management Interface.')
mscFrNniLmiPsiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLmiIndex"))
if mibBuilder.loadTexts: mscFrNniLmiPsiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiPsiEntry.setDescription('An entry in the mscFrNniLmiPsiTable.')
mscFrNniLmiProtocolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("errorCondition", 0), ("normalCondition", 1), ("configuring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiProtocolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiProtocolStatus.setDescription('This attribute indicates whether the LMI is in an error condition or whether the LMI procedures are behaving normally. When operating with no LMI protocol, this attribute is always set to normalCondition. When operating with LMI procedures, this attribute is set to errorCondition after n392 of the last n393 events are in error. The consequence of an errorCondition is that all DLCIs on this interface will become inactive in both directions. The errorCondition is lifted and a normalCondition is indicated when a sufficient number of events have occurred without error. In ANSI, this occurs when n393 consecutive good events take place. If the procedures attribute is set to autoConfigure, this attribute is se to configuring while adaptive LMI determines which LMI procedures are running on the link. A single LMI error event during auto configuration causes the attribute value to change to errorCondition. If during configuring no LMI message is received, an LMI errorCondition is raised after n392 x t392 seconds.')
mscFrNniLmiOpProcedures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("ansi", 2), ("itu", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiOpProcedures.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiOpProcedures.setDescription('This attribute indicates the procedures being used for the Local Management Interface. This attribute should be ignored if protocolStatus is not normalCondition. The following procedures are supported: none: Local Management Interface procedures are not running on this interface. This accommodates Frame Relay user equipment that has not implemented any LMI procedures. ansi: Local Management Interface procedures from the ANSI specification are running. DLCI 0 is used for the LMI protocol. itu: Local Management Interface procedures from the ITU-T specification are running. DLCI 0 is used for the LMI protocol. Was previously ccitt. unknown: Local Management Interface procedures have yet to be determined by Adaptive LMI.')
mscFrNniLmiStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14), )
if mibBuilder.loadTexts: mscFrNniLmiStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiStatsTable.setDescription('This group contains the operational statistics for the Frame Relay NNI Local Management Interface.')
mscFrNniLmiStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLmiIndex"))
if mibBuilder.loadTexts: mscFrNniLmiStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiStatsEntry.setDescription('An entry in the mscFrNniLmiStatsTable.')
mscFrNniLmiKeepAliveStatusToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiKeepAliveStatusToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiKeepAliveStatusToIf.setDescription('This attribute counts the number of Local Management Interface keep alive status messages sent to the external network in response to a status enquiry for keep alive status. When the maximum count is exceeded it wraps to zero.')
mscFrNniLmiFullStatusToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiFullStatusToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiFullStatusToIf.setDescription('This attribute counts the number of Local Management Interface full status messages sent to the external network in response to a status enquiry for keep alive or full status. When the maximum count is exceeded it wraps to zero.')
mscFrNniLmiKeepAliveStatusEnqFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiKeepAliveStatusEnqFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiKeepAliveStatusEnqFromIf.setDescription('This attribute counts the number of Local Management Interface valid keep alive status enquiry messages received from the external network. When the maximum count is exceeded it wraps to zero.')
mscFrNniLmiFullStatusEnqFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiFullStatusEnqFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiFullStatusEnqFromIf.setDescription('This attribute counts the number of Local Management Interface valid full status enquiry messages received from the external network. When the maximum count is exceeded it wraps to zero.')
mscFrNniLmiNetworkSideEventHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiNetworkSideEventHistory.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiNetworkSideEventHistory.setDescription("This attribute displays the Local Management Interface network side procedure event history in order of occurrence. An event is represented by a single symbol. A '+' symbol indicates a good event. An 'X' symbol indicates a protocol error event. The leftmost event is the most recent to occur. The provisioned eventCount (nN3/ N393) dictates the maximum number of events displayed. A good event is triggered by receipt of a valid status enquiry message. An error event is either a nT2/T392 timer expiry or receipt of a status enquiry with bad sequence numbers.")
mscFrNniLmiUserSideEventHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 6), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiUserSideEventHistory.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiUserSideEventHistory.setDescription("This attribute displays the Local Management Interface user side procedure event history in order of occurrence. An event is represented by a single symbol. A '+' symbol indicates a good event. An 'X' symbol indicates a protocol error event. The leftmost event is the most recent to occur. The provisioned eventCount (nN3/ N393) dictates the maximum number of events displayed. A good event is triggered by receipt of a valid status message. An error event is either a nT1/T391 timer expiry or receipt of a status message with bad sequence numbers.")
mscFrNniLmiProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiProtocolErrors.setDescription('This attribute counts the number of Local Management Interface protocol errors. It is the sum of the sequence (sequenceErrors and statusSequenceErrors) and timeout (pollingVerifTimeouts and noStatusReportCount) errors. When the maximum count is exceeded it wraps to zero.')
mscFrNniLmiUnexpectedIes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiUnexpectedIes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiUnexpectedIes.setDescription('This attribute counts the number of Local Management Interface frames received with an Information Element identifier that is unknown or unexpected. An unexpected Information Element is not a protocol error. When the maximum count is exceeded, this counter wraps to zero.')
mscFrNniLmiSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiSequenceErrors.setDescription('This attribute counts the number of Local Management Interface Status Enquiry message sequence errors. A sequence error is receipt of a Status Enquiry message with a receive sequence number not equal to the last send sequence number. When the maximum count is exceeded the counter wraps to zero.')
mscFrNniLmiStatusSequenceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiStatusSequenceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiStatusSequenceErrors.setDescription('This attribute counts the number of Local Management Interface Status message sequence errors. A sequence error is receipt of a Status message with a receive sequence number not equal to the last send sequence number. When the maximum count is exceeded the counter wraps to zero.')
mscFrNniLmiUnexpectedReports = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiUnexpectedReports.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiUnexpectedReports.setDescription('This attribute counts the number of Local Management Interface frames received with an unknown or unexpected report type. An unexpected report type is not a protocol error. When the maximum count is exceeded the counter wraps to zero.')
mscFrNniLmiPollingVerifTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiPollingVerifTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiPollingVerifTimeouts.setDescription('This attribute counts the number of checkPointTImer (t392) timer expiries occurring on the Local Management Interface. When the maximum count is exceeded the counter wraps to zero.')
mscFrNniLmiNoStatusReportCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 4, 14, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLmiNoStatusReportCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLmiNoStatusReportCount.setDescription('This attribute counts the number of times when no status report or an invalid status report comes from the external network. This attribute is incremented in two cases: i) after a status enquiry is sent out and T391 timer expires without having a status report received. ii) an invalid status report is received. When the maximum count is exceeded it wraps to zero.')
mscFrNniDlci = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5))
mscFrNniDlciRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 1), )
if mibBuilder.loadTexts: mscFrNniDlciRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDlci components.')
mscFrNniDlciRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"))
if mibBuilder.loadTexts: mscFrNniDlciRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDlci component.')
mscFrNniDlciRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDlci components. These components can be added and deleted.')
mscFrNniDlciComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDlciStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciStorageType.setDescription('This variable represents the storage type value for the mscFrNniDlci tables.')
mscFrNniDlciIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1007)))
if mibBuilder.loadTexts: mscFrNniDlciIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciIndex.setDescription('This variable represents the index for the mscFrNniDlci tables.')
mscFrNniDlciStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10), )
if mibBuilder.loadTexts: mscFrNniDlciStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscFrNniDlciStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"))
if mibBuilder.loadTexts: mscFrNniDlciStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciStateEntry.setDescription('An entry in the mscFrNniDlciStateTable.')
mscFrNniDlciAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrNniDlciOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrNniDlciUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscFrNniDlciAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscFrNniDlciProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscFrNniDlciControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscFrNniDlciAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscFrNniDlciStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscFrNniDlciUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscFrNniDlciAbitTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 12), )
if mibBuilder.loadTexts: mscFrNniDlciAbitTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciAbitTable.setDescription('This group contains the A-Bit status information for this Data Link Connection Identifier.')
mscFrNniDlciAbitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"))
if mibBuilder.loadTexts: mscFrNniDlciAbitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciAbitEntry.setDescription('An entry in the mscFrNniDlciAbitTable.')
mscFrNniDlciABitStatusToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1), ("notApplicable", 2))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciABitStatusToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciABitStatusToIf.setDescription('This attribute is the most recent A-bit status sent to the interface. The A-bit status is part of the LMI protocol, and indicates willingness to accept data from the local interface. inactive - the Frame Relay service discards all data offered from the local interface. active - the Frame Relay service tries to process all data offered from the local interface. notApplicable - the DLCI is switched, so this attribute is ignored.')
mscFrNniDlciABitReasonToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 8, 9, 10))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("localLmiError", 2), ("remoteLmiError", 3), ("localLinkDown", 4), ("remoteLinkDown", 5), ("pvcSpvcDown", 6), ("userNotAuthorized", 8), ("resourceNotAvailable", 9), ("dlciCollisionAtNni", 10))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciABitReasonToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciABitReasonToIf.setDescription('This attribute provides the reason (if any) for an inactive status to be sent to the interface. This reason is notApplicable for an active status.')
mscFrNniDlciABitStatusFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1), ("notApplicable", 2))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciABitStatusFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciABitStatusFromIf.setDescription('This attribute is the most recent A-Bit status received from the interface. inactive - the Frame Relay service informs the remote DLCI not to send user data to this interface. active - the Frame Relay service informs the remote DLCI that it is okay to send user data to this interface. notApplicable - the DLCI is switched, so this attribute is ignored.')
mscFrNniDlciABitReasonFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4, 7))).clone(namedValues=NamedValues(("notApplicable", 0), ("remoteUserSignaled", 1), ("localLmiError", 2), ("localLinkDown", 4), ("missingFromLmiReport", 7))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciABitReasonFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciABitReasonFromIf.setDescription('This attribute provides the reason (if any) for an inactive status to be sent to the subnet. This reason is notApplicable for an active status.')
mscFrNniDlciLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLoopbackState.setDescription('This attribute has the value on when the DLCI is in loopback mode and off otherwise. The loopback command verbs start and stop are used to initiate and terminate the loopback mode for a DLCI. While loopbackState is on, the local LMI will report to the interface the A- bit status as active. Also an active A-bit signal will be reliably propagated across the subnet to the remote DLCI.')
mscFrNniDlciSpOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13), )
if mibBuilder.loadTexts: mscFrNniDlciSpOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpOpTable.setDescription('This group defines the service and traffic parameters specific to this instance of DLCI. In the case of permanent (PVC and P-SPVC) DLCIs, the values of attributes with the exception of the measurementInterval reflect the provisioning under the FrNni Dlci Sp component. In the case of switched (SVC and S-SPVC) DLCIs, the values of attributes reflect the service parameter negotiations between what is provisioned under the FrNni Sig component and the signaled parameters.')
mscFrNniDlciSpOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"))
if mibBuilder.loadTexts: mscFrNniDlciSpOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpOpEntry.setDescription('An entry in the mscFrNniDlciSpOpTable.')
mscFrNniDlciMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8187))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciMaximumFrameSize.setDescription('This attribute indicates the maximum number of octets which may be included in the information field. The frame relay header and CRC octets are not included in this definition. This attribute corresponds to the dN1 parameter described in the Vendor Forum Specification.')
mscFrNniDlciRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciRateEnforcement.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciRateEnforcement.setDescription('This attribute is obsolete. It provided the information which is now represented by the provisionable attribute rateEnforcement under the ServiceParameters component.')
mscFrNniDlciCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCommittedInformationRate.setDescription('This attribute indicates the committed information rate (CIR) in bits per second (bit/s). When rateEnforcement is set to on, cir is the rate at which the network agrees to transfer information under normal conditions. This rate is measured over a measurement interval (t) that is determined internally based on CIR and the committed burst size (Bc). An exception to this occurs when CIR is provisioned to be zero, in which case the measurement interval (t) must be provisioned explicitly. This attribute should be ignored when rateEnforcement is off.')
mscFrNniDlciCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCommittedBurstSize.setDescription('This attribute indicates the committed burst size (Bc) in bits. bc is the amount of data that a network agrees to transfer under normal conditions over a measurement interval (t). Data marked DE=1 is not accounted for in Bc. This attribute should be ignored when rateEnforcement is off.')
mscFrNniDlciExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciExcessBurstSize.setDescription('This attribute indicates the excess burst size (Be) in bits. Be is the amount of uncommitted data that the network will attempt to deliver over measurement interval T. Data marked DE=1 by the user or by the network is accounted for here. This attribute should be ignored when rateEnforcement is off.')
mscFrNniDlciMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciMeasurementInterval.setDescription('This attribute indicates the time interval (in milliseconds) over which rates and burst sizes are measured. This attribute should be ignored when rateEnforcement is off.')
mscFrNniDlciRateAdaptation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("eirOnly", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciRateAdaptation.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciRateAdaptation.setDescription('This attribute is obsolete. It provided the information which is now represented by the provisionable attribute rateAdaptation under the ServiceParameters component.')
mscFrNniDlciAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciAccounting.setDescription('This attribute indicates whether accounting data collection and record generation is turned on at this DLCI. For accounting data collection and record generation to be turned on, the accountingOn bit and at least one of the accountCollection bits in the DataNetworkAddress component must be set to on.')
mscFrNniDlciEmissionPriorityToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(3, 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEmissionPriorityToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEmissionPriorityToIf.setDescription('This attribute indicates the emission priority of frames sent to the interface. A larger value denotes a higher priority.')
mscFrNniDlciTransferPriToNwk = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciTransferPriToNwk.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciTransferPriToNwk.setDescription('This attribute indicates the priority at which data is transferred to the network. The transfer priority is a preference configured for an application according to its delay-sensitivity requirement. Frames with higher transfer priority are served by the network before the frames with lower priority. The transfer priority standard is defined to have 16 indices from 0 to 15. Each transfer priority n, where n specifies the transfer priority index, contains a default setting for routing class of service (multimedia, delay, or throughput) and frame relay egress queue (depending on the number of supported egress queues on the remote end interface) specified by the routingClassOfService and emissionPriority attributes provisioned in the Mod Frs DprsNet Tpm/n component. The default mapping can be altered by a user if required.')
mscFrNniDlciTransferPriFromNwk = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 13, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciTransferPriFromNwk.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciTransferPriFromNwk.setDescription('This attribute indicates the priority at which data is transferred from the network. The transfer priority is a preference configured for an application according to its delay-sensitivity requirement. Frames with higher transfer priority are served by the network before the frames with lower priority. The transfer priority standard is defined to have 16 indices from 0 to 15. Each transfer priority n, where n specifies the transfer priority index, contains a default setting for routing class of service (multimedia, delay, or throughput) and frame relay egress queue (depending on the number of supported egress queues on the remote end interface) specified by the routingClassOfService and emissionPriority attributes provisioned in the Mod Frs DprsNet Tpm/n component. The default mapping can be altered by a user if required.')
mscFrNniDlciStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14), )
if mibBuilder.loadTexts: mscFrNniDlciStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciStatsTable.setDescription('This group contains the operational statistics for the Frame Relay Data Link Connection Identifier.')
mscFrNniDlciStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"))
if mibBuilder.loadTexts: mscFrNniDlciStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciStatsEntry.setDescription('An entry in the mscFrNniDlciStatsTable.')
mscFrNniDlciFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciFrmToIf.setDescription('This attribute counts the frames sent out the interface. When the maximum count is reached the count wraps to zero.')
mscFrNniDlciFecnFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciFecnFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciFecnFrmToIf.setDescription('This attribute counts the frames sent to the interface with the Forward Explicit Congestion Notification (FECN) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciBecnFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciBecnFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciBecnFrmToIf.setDescription('This attribute counts the frames sent to the interface with the Backward Explicit Congestion Notification (BECN) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciBciToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciBciToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciBciToSubnet.setDescription('This attribute counts the frames sent into the local network with the Backward Congestion Indication (BCI) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciDeFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDeFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDeFrmToIf.setDescription('This attribute counts the frames sent to the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciDiscCongestedToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscCongestedToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscCongestedToIf.setDescription('This attribute counts the number of frame discards at the Frame Relay service due to local congestion in the direction toward the interface. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciDiscDeCongestedToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscDeCongestedToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscDeCongestedToIf.setDescription('This attribute counts the number of discarded frames, with the Discard Eligibility (DE) bit set, at the Frame Relay service, due to local congestion in the direction toward the interface. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciFrmFromIf.setDescription('This attribute counts the frames received from the interface. It includes the frames that are discarded due to error or excess. When the maximum count is reached the count wraps to zero.')
mscFrNniDlciFecnFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciFecnFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciFecnFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Forward Explicit Congestion Notification (FECN) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciBecnFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciBecnFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciBecnFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Backward Explicit Congestion Notification (BECN) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciFciFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciFciFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciFciFromSubnet.setDescription('This attribute counts the frames received from the network with the Forward Congestion Indication (FCI) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciBciFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciBciFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciBciFromSubnet.setDescription('This attribute counts the frames received from the network with the Backward Congestion Indication (BCI) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciDeFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDeFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDeFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciExcessFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciExcessFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciExcessFrmFromIf.setDescription('This attribute counts the frames received from the interface with the Discard Eligibility (DE) bit clear, but subsequently set by the network due to rate enforcement. When the count reaches maximum it wraps to zero.')
mscFrNniDlciDiscExcessFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscExcessFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscExcessFromIf.setDescription('This attribute counts the frames which were discarded due to rate enforcement. When the count reaches maximum it wraps to zero.')
mscFrNniDlciDiscFrameAbit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscFrameAbit.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscFrameAbit.setDescription('This attribute counts the number of frame discards at the Frame Relay Service, due to an inactive PVC status, in the direction toward the local network. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciDiscCongestedFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscCongestedFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscCongestedFromIf.setDescription('This attribute counts the number of frame discards at the Frame Relay service due to local congestion in the direction toward the network. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciDiscDeCongestedFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscDeCongestedFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscDeCongestedFromIf.setDescription('This attribute counts the number of discarded frames, with the Discard Eligibility (DE) bit set, at the Frame Relay service, due to local congestion, in the direction toward the local network. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciErrorShortFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciErrorShortFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciErrorShortFrmFromIf.setDescription('This attribute counts the frames received with 0 octets in the information field. When the count reaches maximum it wraps to zero.')
mscFrNniDlciErrorLongFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciErrorLongFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciErrorLongFrmFromIf.setDescription('This attribute counts the frames received with number of octets in the information field greater than the subscribed maximum. When the count reaches maximum it wraps to zero. Frames whose lengths are greater than the hardware receive buffer are ignored by the hardware and are therefore not included in this count.')
mscFrNniDlciBecnFrmSetByService = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciBecnFrmSetByService.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciBecnFrmSetByService.setDescription('This attribute counts the number of frames with BECN set by the Frame Relay service. It is incremented whenever the Frame Relay service sets BECN on a frame upon detecting local congestion. This count is incremented regardless of whether the frame already bears a set BECN bit since its use is to determine the place of congestion. When the count reaches maximum, it wraps to zero.')
mscFrNniDlciBytesToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciBytesToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciBytesToIf.setDescription('This attribute counts the bytes sent out the interface. When the maximum count is reached the count wraps to zero.')
mscFrNniDlciDeBytesToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDeBytesToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDeBytesToIf.setDescription('This attribute counts the bytes sent to the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciDiscCongestedToIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscCongestedToIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscCongestedToIfBytes.setDescription('This attribute counts the number of byte discards at the Frame Relay service due to local congestion in the direction toward the link. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciDiscDeCongestedToIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscDeCongestedToIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscDeCongestedToIfBytes.setDescription('This attribute counts the number of discard eligible (DE=1) byte discards at the Frame Relay service due to local congestion in the direction toward the link. When the maximum count is reached the count wraps to zero.')
mscFrNniDlciBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciBytesFromIf.setDescription('This attribute counts the bytes received from the interface. Bytes that are discarded due to error or excess are not counted. When the maximum count is reached the count wraps to zero.')
mscFrNniDlciDeBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDeBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDeBytesFromIf.setDescription('This attribute counts the bytes received from the interface with the Discard Eligibility (DE) bit set. When the count reaches maximum it wraps to zero.')
mscFrNniDlciExcessBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciExcessBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciExcessBytesFromIf.setDescription('This attribute counts the bytes received from the interface with the Discard Eligibility (DE) bit clear, but subsequently set by the network due to rate enforcement. When the count reaches maximum it wraps to zero.')
mscFrNniDlciDiscExcessFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscExcessFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscExcessFromIfBytes.setDescription('This attribute counts the bytes which were discarded due to rate enforcement. When the count reaches maximum it wraps to zero.')
mscFrNniDlciDiscByteAbit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscByteAbit.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscByteAbit.setDescription('This attribute counts the bytes which were discarded due to aBit turned off.')
mscFrNniDlciDiscCongestedFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscCongestedFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscCongestedFromIfBytes.setDescription('This attribute counts the number of byte discards at the Frame Relay service due to local congestion in the direction toward the network. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciDiscDeCongestedFromIfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscDeCongestedFromIfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscDeCongestedFromIfBytes.setDescription('This attribute counts the number of discard eligible (DE=1) byte discards at the Frame Relay service due to local congestion in the direction toward the network. When the maximum count is reached the count wraps to zero.')
mscFrNniDlciErrorShortBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciErrorShortBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciErrorShortBytesFromIf.setDescription('This attribute counts the bytes received with 0 octets in the information field. When the count reaches maximum it wraps to zero.')
mscFrNniDlciErrorLongBytesFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 34), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciErrorLongBytesFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciErrorLongBytesFromIf.setDescription('This attribute counts the bytes received with number of octets in the information field greater than the subscribed maximum. When the count reaches maximum it wraps to zero. Bytes whose lengths are greater than the hardware receive buffer are ignored by the hardware and are therefore not included in this count.')
mscFrNniDlciRateAdaptReduct = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 35), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciRateAdaptReduct.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciRateAdaptReduct.setDescription('This attribute counts the number of rate reductions due to rate adaptation. Rate adaptation causes the allowed rate to be reduced in steps. After each reduction, a period of time is awaited before further action is taken. At the end of this period, the allowed rate is further reduced if congestion is still prevalent. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciRateAdaptReductPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciRateAdaptReductPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciRateAdaptReductPeriod.setDescription('This attribute provides a cumulative count of the amount of time that rate adaptation procedures have been in effect. When this count reaches maximum, it wraps to zero.')
mscFrNniDlciTransferPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciTransferPriorityToNetwork.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciTransferPriorityToNetwork.setDescription('This attribute is obsolete. It is replaced by attribute transferPriorityToNetwork under group FrsNniDataLinkConnectionIdentifierServiceParametersOp.')
mscFrNniDlciTransferPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciTransferPriorityFromNetwork.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciTransferPriorityFromNetwork.setDescription('This attribute is obsolete. It is replaced by attribute transferPriorityFromNetwork under group FrsNniDataLinkConnectionIdentifierServiceParametersOp.')
mscFrNniDlciCirPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 39), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCirPresent.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCirPresent.setDescription('This attribute provides the actual Committed Information Rate (CIR) enforced for this DLCI. This number is in units of 800 bits/ sec, since that is the internal resolution of Passport rate enforcement. If rateEnforcement is off, then this number does not have meaning. Normally, this attribute matches the provisioned CIR for the DLCI. But when Rate Adaptation is active, then this number will vary to represent the actual Allowed CIR at the moment that this attribute is collected.')
mscFrNniDlciEirPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 14, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEirPresent.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEirPresent.setDescription('This attribute provides the actual Excess Information Rate (EIR) enforced for this DLCI. This number is in units of 800 bits/sec, since that is the internal resolution of Passport rate enforcement. If rateEnforcement is off, then this number does not have meaning. Normally, this attribute matches the provisioned EIR for the DLCI. But when Rate Adaptation is active, then this number will vary to represent the actual Allowed EIR at the moment that this attribute is collected.')
mscFrNniDlciIntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15), )
if mibBuilder.loadTexts: mscFrNniDlciIntTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciIntTable.setDescription('This group contains the operational statistics for the Frame Relay Data Link Connection Identifier interval data (accounting data).')
mscFrNniDlciIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"))
if mibBuilder.loadTexts: mscFrNniDlciIntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciIntEntry.setDescription('An entry in the mscFrNniDlciIntTable.')
mscFrNniDlciStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 1), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciStartTime.setDescription('This attribute indicates the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes. A new interval period is started each time an accounting record is generated.')
mscFrNniDlciTotalIngressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 2), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciTotalIngressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciTotalIngressBytes.setDescription('This attribute counts the total bytes received from the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscFrNniDlciTotalEgressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 3), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciTotalEgressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciTotalEgressBytes.setDescription('This attribute counts the total bytes sent to the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscFrNniDlciEirIngressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 4), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEirIngressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEirIngressBytes.setDescription('This attribute counts the total bytes with the Discard Eligibility (DE) bit set sent to the subnet since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscFrNniDlciEirEgressBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 5), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEirEgressBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEirEgressBytes.setDescription('This attribute counts the total bytes with the Discard Eligibility (DE) bit set sent to the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscFrNniDlciDiscardedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 6), Unsigned64().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscardedBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscardedBytes.setDescription('This attribute counts the total bytes in invalid frames received from the interface and discarded at the DLCI since the start of the interval period. This count is a sum of octets in frames discarded due to the number of octets in the information field greater than the subscribed maximum or equal to 0, due to aBit turned off, or due to rate enforcement. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscFrNniDlciTotalIngressSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciTotalIngressSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciTotalIngressSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the total number of segments in frames received from the interface since the start of the interval period. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the total number of frames received from the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscFrNniDlciTotalEgressSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciTotalEgressSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciTotalEgressSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the total number of segments in frames sent to the interface since the start of the interval period. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the total number of frames sent to the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscFrNniDlciEirIngressSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEirIngressSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEirIngressSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the number of segments in frames with the Discard Eligibility (DE) bit set sent to the subnet since the start of the interval period. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the number of frames with the Discard Eligibility (DE) bit set sent to the subnet since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated.')
mscFrNniDlciEirEgressSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEirEgressSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEirEgressSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the number of segments in frames with the Discard Eligibility (DE) bit set sent to the interface since the start of the interval period. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the number of frames with the Discard Eligibility (DE) bit set sent to the interface since the start of the interval period. The start of the interval period is captured in the startTime attribute. The count is reset to zero when an accounting record is generated')
mscFrNniDlciDiscardedSegFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDiscardedSegFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDiscardedSegFrm.setDescription('If the value of the unitsCounted attribute in moduleData component is segments, this attribute counts the number of segments in invalid frames received from the interface and discarded at the DLCI. If the value of the unitsCounted attribute in moduleData component is frames, this attribute counts the number of invalid frames received from the interface and discarded at the DLCI. Segments of frames are counted since the start of the interval period. The count is reset to zero when an accounting record is generated. The count is a sum of segments in frames or frames discarded due to the number of octets in the information field greater than the subscribed maximum or equal to 0, due to aBit turned off, or due to rate enforcement.')
mscFrNniDlciCirPresentObs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCirPresentObs.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciCirPresentObs.setDescription('This attribute has moved to the statistics subgroup. See cirPresent..')
mscFrNniDlciEirPresentObs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEirPresentObs.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciEirPresentObs.setDescription('This attribute has moved to the statistics group. See eirPresent.')
mscFrNniDlciRateEnforcementPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciRateEnforcementPresent.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciRateEnforcementPresent.setDescription('This attribute is obsolete. See the provisionable rateEnforcement attribute.')
mscFrNniDlciRateAdaptationPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciRateAdaptationPresent.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciRateAdaptationPresent.setDescription('This attribute is obsolete. See the provisionable rateAdaptation attribute.')
mscFrNniDlciLocalRateAdaptOccurred = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLocalRateAdaptOccurred.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLocalRateAdaptOccurred.setDescription('This attribute indicates whether rate adaptation has occurred on this user Data Link Connection on this Frame Relay interface. The value is set to no when an accounting record is generated.')
mscFrNniDlciCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 17), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCallReferenceNumber.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciCallReferenceNumber.setDescription('This attribute is obsoleted and replaced by callRefNumber.')
mscFrNniDlciElapsedDifference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciElapsedDifference.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciElapsedDifference.setDescription('This attribute indicates the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since the call started.')
mscFrNniDlciCallRefNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 15, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCallRefNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCallRefNumber.setDescription('This attribute indicates the call reference number which is a unique number generated by the switch. The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the connection.')
mscFrNniDlciCalldTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 16), )
if mibBuilder.loadTexts: mscFrNniDlciCalldTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCalldTable.setDescription('This group of attributes describes the characteristics of the call such as call type and call state.')
mscFrNniDlciCalldEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"))
if mibBuilder.loadTexts: mscFrNniDlciCalldEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCalldEntry.setDescription('An entry in the mscFrNniDlciCalldTable.')
mscFrNniDlciCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("pvc", 0), ("svc", 1), ("spvc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCallType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCallType.setDescription('This attribute indicates whether this DLCI is a permancent virtual circuit (PVC), a switched virtual circuit (SVC), or a switched permament virtual circuit (SPVC).')
mscFrNniDlciCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 6, 9, 10, 11, 12, 20, 61, 62))).clone(namedValues=NamedValues(("null", 0), ("callInitiated", 1), ("callProceedingSent", 3), ("callPresent", 6), ("callProceedingReceived", 9), ("active", 10), ("releaseRequest", 11), ("releaseIndication", 12), ("notApplicable", 20), ("restartRequest", 61), ("restart", 62)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCallState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCallState.setDescription("This attribute indicates the FRF.10 state of a switched call. The value of this attribute for a permanent (PVC and P-SPVC) DLCI is always notApplicable. In the description that follows, 'calling STE' refers to the network who has initiated the SETUP request, and 'called STE' refers to the network that receives the request. State description: In the null state, the network has neither received nor sent call setup requests for this DLCI. In the callInitiated state, the called STE has received a SETUP message from the calling STE. In the callProceedingSent state, the called STE has sent a CALL PROCEEDING message to the calling STE in response to the SETUP message. In the callPresent state, the calling STE has sent a SETUP message to the called STE but has not received a response. In the callProceedingReceived state, the calling STE has received a CALL PROCEEDING message from the called STE in response to a SETUP message. In the active state, either the called STE has sent a CONNECT message to the calling STE, or the calling STE has received a CONNECT from the called STE. In the releaseRequest state, the STE has sent a RELEASE message to release the call and is waiting for a RELEASE COMPLETE message. In the releaseIndication state, the STE has received a RELEASE and sends a RELEASE COMPLETE message after releasing the relevant call resources. In the restartRequest state, the STE has sent a RESTART request to the other STE and is waiting for an acknowledgement. In the restart state, the STE has received a request for a restart from the other STE and this STE has not returned an acknowledgement.")
mscFrNniDlciCallReference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciCallReference.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciCallReference.setDescription('This attribute indicates the FRF.10 call reference number associated with this DLCI. The value of this attribute for a provisioned (PVC or P-SPVC) DLCI is always 0.')
mscFrNniDlciDc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2))
mscFrNniDlciDcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 1), )
if mibBuilder.loadTexts: mscFrNniDlciDcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDlciDc components.')
mscFrNniDlciDcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciDcIndex"))
if mibBuilder.loadTexts: mscFrNniDlciDcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDlciDc component.')
mscFrNniDlciDcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDlciDc components. These components cannot be added nor deleted.')
mscFrNniDlciDcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDlciDcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciDcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcStorageType.setDescription('This variable represents the storage type value for the mscFrNniDlciDc tables.')
mscFrNniDlciDcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniDlciDcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcIndex.setDescription('This variable represents the index for the mscFrNniDlciDc tables.')
mscFrNniDlciDcOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10), )
if mibBuilder.loadTexts: mscFrNniDlciDcOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcOptionsTable.setDescription('This group defines attributes associated with a direct call. It defines connection in terms of path and call option parameters. This connection can be permanent (PVC), switched (SVC), or switched permanent (SPVC). It can have four facilities: - CCITT Facilities - DTE Facilities - National Facilities - International Facilities The total number of bytes of facilities including the facility codes and all of the facility data from all of the four classes of facilities must not exceed 512 bytes.')
mscFrNniDlciDcOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciDcIndex"))
if mibBuilder.loadTexts: mscFrNniDlciDcOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcOptionsEntry.setDescription('An entry in the mscFrNniDlciDcOptionsTable.')
mscFrNniDlciDcRemoteNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcRemoteNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcRemoteNpi.setDescription('This attribute specifies the Numbering Plan Indicator (NPI) of the remoteDna.')
mscFrNniDlciDcRemoteDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcRemoteDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcRemoteDna.setDescription('This attribute specifies the Data Network Address (DNA) of the service at the remote end of the DLCI. This is the called (destination) DCE address (DNA) of this PVC.')
mscFrNniDlciDcRemoteDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 1007))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcRemoteDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcRemoteDlci.setDescription('This attribute specifies the remote DLCI of the PVC connection.')
mscFrNniDlciDcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("permanentMaster", 1), ("permanentSlave", 2), ("permanentBackupSlave", 3), ("permanentSlaveWithBackup", 4), ("spvcMaster", 5), ("spvcSlave", 6), ("spvcBackupSlave", 7), ("spvcSlaveWithBackup", 8))).clone('permanentMaster')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcType.setDescription('This attribute specifies the type of VC call. If the value is set to permanentMaster, then a permanent connection will be established between two ends. The remote end must be defined as a permanentSlave, permanentBackupSlave, or permanentSlaveWithBackup. The connection cannot be established if the remote end is defined as anything else. The end defined as permanentMaster always initiates the calls. It attempts to call once per minute. If the value is set to permanentSlave then a permanent connection will be established between two ends. The remote end must be defined as a permanentMaster. The connection cannot be established if the remote end is defined as anything else. The permanentSlave end attempts to call once per minute. If the value is set to permanentSlaveWithBackup then a permanent connection will be established between the two ends. The remote end must be defined as a permanentMaster. The connection cannot be established if the remote interface is defined as anything else. The permanentSlaveWithBackup attempts to call once per minute. When type is set to permanentSlaveWithBackup, the connection is cleared if the interface becomes unavailable. This enables a retry of the connection which can be redirected to the permanentBackupSlave. If the value is set to permanentBackupSlave then a permanent connection is established between the two ends only if the permanentMaster end is disconnected from the permanentSlaveWithBackup end and a backup call is established by the call redirection system. If the permanentSlaveWithBackup interface becomes available again, the permanentBackupSlave end is disconnected and the permanentSlaveWithBackup end is reconnected to the permanentMaster end. The permanentBackupSlave end does not try to establish a call. If the value is set to spvcMaster, then a permanent connection is established between two ends, with resiliency at the NNI), if the connection transits across two or more networks. The remote end, which may be in the same network, or an external network that is reachable via Frame Relay NNIs, must be defined as either a spvcSlave, spvcBackupSlave or spvcSlaveWithBackup. The connection cannot be established if the remote end is defined as anything else. The end defined as spvcMaster always initiates the call. It attempts to call once per minute. The call is attempted by the spvcMaster and accepted by the remote end only if all of the following conditions are satisfied, at both ends: 1. The physical layer must be operational. 2. The LMI procedures must be in normalCondition (that is, no service affecting condition). 3. If the LMI side attribute is provisioned to both, the A-bit received from the interface must be Active. If the LMI side attribute is not provisioned to both, this condition does not apply. After a call is cleared, the spvcMaster end attempts to retry the call according to the rule for the clear cause. If the call is cleared or rejected due to the failure of one of the three conditions indicated above, or due to unavailability of resources along any point in the connection path, the call will be retried after 60 seconds. For all other causes, such as loss of service at an NNI, the call will be retried immediately. If the value is set to spvcSlave then an SPVC connection is established between two ends. The remote end must be defined as an spvcMaster. The connection cannot be established if the remote end is defined as anything else. The spvcSlave end does not attempt to call. If the value is set to spvcSlaveWithBackup then a SPVC connection is established between the two ends. The remote end must be defined as an spvcMaster. The connection cannot be established if the remote interface end is defined as anything else. Unlike a permanentSlaveWithBackup end, the spvcSlaveWithBackup end does not attempt to call. If the value is set to spvcSlaveWithBackup, the connection is cleared if the interface becomes unavailable. This enables a retry of the connection by the spvcMaster end, which may be redirected to an end that is set to spvcBackupSlave. If the value is set to spvcBackupSlave then an SPVC connection is established between the two ends only if the spvcMaster end is disconnected from the spvcSlaveWithBackup end, and a backup call is redirected by the call redirection system. Unlike the PVC connection, if the spvcSlaveWithBackup interface becomes available again, the spvcBackupSlave end is not disconnected and the spvcSlaveWithBackup end is not reconnected to the spvcMaster end. Neither the spvcBackupSlave nor the spvcSlaveWithBackup ends try to establish an SPVC call.')
mscFrNniDlciDcTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 255))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("useDnaDefTP", 255))).clone('useDnaDefTP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcTransferPriority.setDescription('This attribute specifies the transfer priority to the local network for the outgoing calls using this particular DLCI. It overrides the defaultTransferPriority provisioned in its associated Dna component. The transfer priority is a preference configured for an application according to its delay-sensitivity requirement. Frames with higher transfer priority are served by the network before the frames with lower priority. The transfer priority standard is defined to have 16 levels from 0 to 15. Each transfer priority n, where n is the transfer priority index, has a default setting for routing class of service (multimedia, delay, or throughput) and Frame Relay egress queue (depending on the number of supported egress queues on the remote end interface). These settings are specified by the routingClassOfService and emissionPriority attributes provisioned under the Mod Frs DprsNet Tpm/n component. Specifying useDnaDefTP means using the value given by defaultTransferPriority in the associated Dna for this DLCI.')
mscFrNniDlciDcDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("useDnaDefPriority", 3))).clone('useDnaDefPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcDiscardPriority.setDescription('This attribute specifies the discard priority for outgoing call using this DLCI. The discard priority has three provisioning values: normal, high, and useDnaDefPriority. Under congestion conditions, traffic with normal priority is discarded before traffic with high priority. The Dna default value (provisioned by outDefaultPriority) is taken if this attribute is set to the value useDnaDefPriority.')
mscFrNniDlciDcDeDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("lowest", 0), ("determinedByDiscardPriority", 1))).clone('determinedByDiscardPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcDeDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcDeDiscardPriority.setDescription('This attribute specifies whether the discardPriority applies to DE frames for this DLCI. When set to determinedByDiscardPriority, traffic with DE bit set will be discarded according to the setting of the discardPriority. When set to lowest, all traffic with DE bit set is treated the same and is sent to the subnet at the lowest discard priority.')
mscFrNniDlciDcDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("dprsOnly", 0), ("dprsMcsOnly", 1), ("dprsMcsFirst", 2), ("useDnaValue", 3))).clone('useDnaValue')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcDataPath.setDescription('This attribute specifies the data path to be used by Virtual Circuits on this interface. The value of the dataPath attribute in the Dna component is overridden by this attribute if the value is not useDnaValue. This value applies to the connection after data transfer state is reached. All the data and control traffic will be sent using this data path. If the provisioned dataPath is not available the connection is not established. The value of the dataPath is signalled by both ends of the connection. If this value is not the same at both ends dprsOnly is used for the duration of the connection. A virtual circuit connection is always established using dprsOnly even if this attribute is provisioned as some other value. dprsOnly - The dynamic packet routing system is used. dprsMcsOnly - The DPRS Multi-Service Cut-Through Switching path is used. dprsMcsFirst - The DPRS Multi-Service Cut-Through Switching path is used if it is available. If it is not available, dprsOnly is used. useDnaValue - The routing system used is based on the value provisioned in the Dna component.')
mscFrNniDlciDcCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcCugIndex.setDescription('This attribute specifies the CUG index which is to be signalled in PVC and SPVC call requests to the remote end. The type of CUG signalling is defined in attribute cugType in this component.')
mscFrNniDlciDcCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 9))).clone(namedValues=NamedValues(("doNotSignal", 0), ("cug", 3), ("cugOa", 9))).clone('doNotSignal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcCugType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcCugType.setDescription('This attribute specifies the type of CUG signalling to be used in PVC and SPVC call requests. Index of CUG to be used is defined in attribute cugIndex in this component. Possible values are: cug - signal CUG cugOa - signal CUG with outgoing access doNotSignal - no CUG in call request')
mscFrNniDlciDcMapIpCosToFrQos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcMapIpCosToFrQos.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciDcMapIpCosToFrQos.setDescription('This attribute specifies whether an IP TOS value is mapped to an FR QOS. The mapping used is provisioned in the Mod Frs IpCosToFrQos component. When this attribute is set to yes, at Frame Relay egress, the IP TOS byte in each frame is checked. The TOS value determines the egress emission queue and the discard priority for that frame. When this attribute is set to no, FR QOS is determined by the provisioned discard priority and transfer priority.')
mscFrNniDlciDcNfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 202), )
if mibBuilder.loadTexts: mscFrNniDlciDcNfaTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciDcNfaTable.setDescription("This is the i'th National facility required for this direct call. Within the provisioning system, the user specifies the facility code along with the facility parameters. The facility is represented internally as a hexadecimal string following the X.25 ITU-T representation for facility data. Two explicit attributes discardPriority and pathSensitivity are created to replace H.01 and H.30 in the group VcsDirectCallOptionsProv of this file. The migrate escape here (DcComponent::migrateFaxEscape) propagates the old provisioning data under H.01 and H.30 into discardPriority and transferPriority. The rule of the above propagation are: 0 in H.01 is equivalent to discardPriority 0; 1 in H.01 is equivalent to discardPriority 1. And 0 in H.30 is equivalent to transferPriority throughput; 1 in H.30 is equivalent to pathSensitivity delay. Please refer to discardPriority and pathSensitivity for more information on how to use them.")
mscFrNniDlciDcNfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 202, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciDcIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciDcNfaIndex"))
if mibBuilder.loadTexts: mscFrNniDlciDcNfaEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciDcNfaEntry.setDescription('An entry in the mscFrNniDlciDcNfaTable.')
mscFrNniDlciDcNfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 202, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(48, 48), )))
if mibBuilder.loadTexts: mscFrNniDlciDcNfaIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciDcNfaIndex.setDescription('This variable represents the index for the mscFrNniDlciDcNfaTable.')
mscFrNniDlciDcNfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 202, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciDcNfaValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciDcNfaValue.setDescription('This variable represents an individual value for the mscFrNniDlciDcNfaTable.')
mscFrNniDlciDcNfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 2, 202, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscFrNniDlciDcNfaRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciDcNfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscFrNniDlciDcNfaTable.')
mscFrNniDlciVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3))
mscFrNniDlciVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 1), )
if mibBuilder.loadTexts: mscFrNniDlciVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDlciVc components.')
mscFrNniDlciVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciVcIndex"))
if mibBuilder.loadTexts: mscFrNniDlciVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDlciVc component.')
mscFrNniDlciVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDlciVc components. These components cannot be added nor deleted.')
mscFrNniDlciVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDlciVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcStorageType.setDescription('This variable represents the storage type value for the mscFrNniDlciVc tables.')
mscFrNniDlciVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniDlciVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcIndex.setDescription('This variable represents the index for the mscFrNniDlciVc tables.')
mscFrNniDlciVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10), )
if mibBuilder.loadTexts: mscFrNniDlciVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCadTable.setDescription('This group represents operational call data related to Frame Relay Vc. It can be displayed only for Frame Relay Vc which is created by application.')
mscFrNniDlciVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciVcIndex"))
if mibBuilder.loadTexts: mscFrNniDlciVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCadEntry.setDescription('An entry in the mscFrNniDlciVcCadTable.')
mscFrNniDlciVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1), ("spvc", 2), ("frf10spvc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcType.setDescription('This attribute displays the type of call, pvc,svc,spvc or frf10spvc.')
mscFrNniDlciVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
mscFrNniDlciVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
mscFrNniDlciVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscFrNniDlciVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscFrNniDlciVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
mscFrNniDlciVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
mscFrNniDlciVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
mscFrNniDlciVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
mscFrNniDlciVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
mscFrNniDlciVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
mscFrNniDlciVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
mscFrNniDlciVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
mscFrNniDlciVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPathReliability.setDescription('This attribute displays the path reliability.')
mscFrNniDlciVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
mscFrNniDlciVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
mscFrNniDlciVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
mscFrNniDlciVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcMaxSubnetPktSize.setDescription('This attribute indicates the maximum packet size allowed on the Vc.')
mscFrNniDlciVcRcosToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcRcosToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcRcosToNetwork.setDescription('This attribute indicates the routing metric routing class of service to the network.')
mscFrNniDlciVcRcosFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcRcosFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcRcosFromNetwork.setDescription('This attribute displays the routing metric Routing Class of Service from the Network.')
mscFrNniDlciVcEmissionPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcEmissionPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcEmissionPriorityToNetwork.setDescription('This attribute displays the network internal emission priotity to the network.')
mscFrNniDlciVcEmissionPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcEmissionPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcEmissionPriorityFromNetwork.setDescription('This attribute displays the network internal emission priotity from the network.')
mscFrNniDlciVcDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 10, 1, 32), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcDataPath.setDescription('This attribute indicates the data path used by the connection. The data path is provisioned in Dna and DirectCall components. The displayed value of this attribute can be different from the provisioned value. If the connection is using dprsOnly data path, the string dprsOnly is displayed. (dynamic packet routing system) If the connection is using dprsMcsOnly data path, the string dprsMcsOnly is displayed. If the connection is using dprsMcsFirst data path, the string dprsMcsFirst is displayed.')
mscFrNniDlciVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 11), )
if mibBuilder.loadTexts: mscFrNniDlciVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcIntdTable.setDescription('This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
mscFrNniDlciVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciVcIndex"))
if mibBuilder.loadTexts: mscFrNniDlciVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcIntdEntry.setDescription('An entry in the mscFrNniDlciVcIntdTable.')
mscFrNniDlciVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCallReferenceNumber.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniDlciVcCallReferenceNumber.setDescription('This attribute is obsolete. It is replaced by the callReferenceNumber attribute to display the call reference number in decimal. The SNMP reference for the callReferenceNumber attribute is callReferenceNumberDecimal.')
mscFrNniDlciVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
mscFrNniDlciVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
mscFrNniDlciVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
mscFrNniDlciVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
mscFrNniDlciVcCallReferenceNumberDecimal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCallReferenceNumberDecimal.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCallReferenceNumberDecimal.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscFrNniDlciVcFrdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12), )
if mibBuilder.loadTexts: mscFrNniDlciVcFrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcFrdTable.setDescription('This group defines Frame Relay attributes collected by Frame Relay Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods. Frame Relay Vc uses a best effort data packet delivery protocol and a different packet segmentation and combination methods from the General Vc. The Frame Relay Vc uses the same call setup and control mechanism (e.g. the support of non-flow control data packets) as in a General Vc. Most General Vc statistics and internal variables are used in a Frame Relay Vc and are displayed by software developers')
mscFrNniDlciVcFrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciVcIndex"))
if mibBuilder.loadTexts: mscFrNniDlciVcFrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcFrdEntry.setDescription('An entry in the mscFrNniDlciVcFrdTable.')
mscFrNniDlciVcFrmCongestedToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcFrmCongestedToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcFrmCongestedToSubnet.setDescription('This attribute displays the number of frames from link discarded due to lack of resources. It keeps track of the number of frames from link that have to be discarded. The discard reasons include insufficient memory for splitting the frame into smaller subnet packet size.')
mscFrNniDlciVcCannotForwardToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCannotForwardToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCannotForwardToSubnet.setDescription('This attribute displays the number of discarded packets that can not be forwarded into the subnet because of subnet congestion. Number of frames from link discarded due to failure in forwarding a packet from Vc into the subnet.- This attribute is increased when packet forwarding fails to forward a packet into the subnet. If a frame is split into multiple subnet packets and a partial packet has to be discarded, all subsequent partial packets that have not yet been delivered to the subnet will be discarded as well.')
mscFrNniDlciVcNotDataXferToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcNotDataXferToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcNotDataXferToSubnet.setDescription('This attribute records the number of frames from link discarded when the Vc tries to recover from internal path failure.')
mscFrNniDlciVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcOutOfRangeFrmFromSubnet.setDescription('This attribute displays the number of frames from subnet discarded due to out of sequence range for arriving too late.')
mscFrNniDlciVcCombErrorsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcCombErrorsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcCombErrorsFromSubnet.setDescription('This attribute records the number of subnet packets discarded at the sink Vc due to the Vc segmentation and combination protocol error. Usually, this occurs when the subnet discards packets and thus this statistics can be used to guest the number of subnet packets that are not delivered to the Vc. It cannot be used as an actual measure because some subnet packets may have been delivered to Vc but have to be discarded because these are partial packets to a frame in which some other partial packets have not been properly delivered to Vc')
mscFrNniDlciVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcDuplicatesFromSubnet.setDescription('This attribute displays the number of subnet packets discarded due to duplication. Although packets are not retransmitted by the Frame Relay Vc, it is possible for the subnet to retransmit packets. When packets are out-of-sequenced and copies of the same packets arrive, then this attribute is increased.')
mscFrNniDlciVcNotDataXferFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcNotDataXferFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcNotDataXferFromSubnet.setDescription('This attribute displays the number of subnet packets discarded when data transfer is suspended in Vc recovery.')
mscFrNniDlciVcFrmLossTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcFrmLossTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcFrmLossTimeouts.setDescription('This attribute displays the number of lost frame timer expiries. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscFrNniDlciVcOoSeqByteCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcOoSeqByteCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcOoSeqByteCntExceeded.setDescription('This attribute displays the number times that the out of sequence byte threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscFrNniDlciVcPeakOoSeqPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPeakOoSeqPktCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPeakOoSeqPktCount.setDescription('This attribute displays the frame relay peak packet count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscFrNniDlciVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPeakOoSeqFrmForwarded.setDescription('This attribute displays the frame relay peak size of the sequence packet queue. The subnet may deliver packets out-of- sequenced. These packets are then queued in an out-of-sequenced queue, waiting for a packet with the expected sequence number to come. When that packet arrives, this attribute records the maximum number of packets that were out-of-sequenced, but now have become in-sequenced. The statistics is used to measure expected queue size due to normal subnet packet disorder (not due to subnet packet discard). Current implementation also uses this statistics to set a maximum size for the out-of-sequenced queue.')
mscFrNniDlciVcSendSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcSendSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcSendSequenceNumber.setDescription("This attribute displays the Vc internal packet's send sequence number. Note that a 'packet' in this context, may be either a user data packet, or an OAM frame.")
mscFrNniDlciVcPktRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPktRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPktRetryTimeouts.setDescription('This attribute displays the number of packets which have retransmission time-outs. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscFrNniDlciVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPeakRetryQueueSize.setDescription('This attribute displays the peak size of retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. Records the largest body of unacknowledged packets.')
mscFrNniDlciVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcSubnetRecoveries.setDescription('This attribute displays the number of successful Vc recovery attempts.')
mscFrNniDlciVcOoSeqPktCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcOoSeqPktCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcOoSeqPktCntExceeded.setDescription('This attribute displays the number times that the out of sequence packet threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscFrNniDlciVcPeakOoSeqByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 12, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcPeakOoSeqByteCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcPeakOoSeqByteCount.setDescription('This attribute displays the frame relay peak byte count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscFrNniDlciVcDmepTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 417), )
if mibBuilder.loadTexts: mscFrNniDlciVcDmepTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcDmepTable.setDescription('This attribute displays the data path used by the connection. Data path is provisioned in Dna and DirectCall components. If the connection is using dprsOnly data path, this attribute is empty. If the connection is using dprsMcsOnly or dprsMcsFirst data path, this attribute displays component name of the dprsMcsEndPoint.')
mscFrNniDlciVcDmepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 417, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciVcIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciVcDmepValue"))
if mibBuilder.loadTexts: mscFrNniDlciVcDmepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcDmepEntry.setDescription('An entry in the mscFrNniDlciVcDmepTable.')
mscFrNniDlciVcDmepValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 3, 417, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciVcDmepValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciVcDmepValue.setDescription('This variable represents both the value and the index for the mscFrNniDlciVcDmepTable.')
mscFrNniDlciSp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4))
mscFrNniDlciSpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 1), )
if mibBuilder.loadTexts: mscFrNniDlciSpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDlciSp components.')
mscFrNniDlciSpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciSpIndex"))
if mibBuilder.loadTexts: mscFrNniDlciSpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDlciSp component.')
mscFrNniDlciSpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciSpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDlciSp components. These components cannot be added nor deleted.')
mscFrNniDlciSpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciSpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDlciSpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciSpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpStorageType.setDescription('This variable represents the storage type value for the mscFrNniDlciSp tables.')
mscFrNniDlciSpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniDlciSpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpIndex.setDescription('This variable represents the index for the mscFrNniDlciSp tables.')
mscFrNniDlciSpParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11), )
if mibBuilder.loadTexts: mscFrNniDlciSpParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpParmsTable.setDescription('This group contains the provisionable attributes for the Data Link Connection Identifier. These attributes reflect the service parameters specific to this instance of DLCI . The congestion control attributes in this group are defined in T1.606 Addendum 1.')
mscFrNniDlciSpParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciSpIndex"))
if mibBuilder.loadTexts: mscFrNniDlciSpParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpParmsEntry.setDescription('An entry in the mscFrNniDlciSpParmsTable.')
mscFrNniDlciSpMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8187)).clone(2100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpMaximumFrameSize.setDescription('This attribute specifies the maximum number of octets which may be included in the information field. The frame relay header and CRC octets are not included in this definition. This attribute corresponds to the dN1 parameter described in the Vendor Forum Specification.')
mscFrNniDlciSpRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpRateEnforcement.setDescription('This attribute specifies whether rate enforcement is in effect for this user Data Link Connection on this Frame Relay interface. Turning on rate enforcement means that CIR and DE=1 traffic will be measured and enforced. Turning off rate enforcement means that all frames from the user will be accepted and no modifications to the frame with respect to the DE bit will be made.')
mscFrNniDlciSpCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpCommittedInformationRate.setDescription('This attribute specifies the committed information rate (CIR) in bits per second (bit/s). When rateEnforcement is set to on, cir is the rate at which the network agrees to transfer information under normal conditions. This rate is measured over a measurement interval (t) that is determined internally based on CIR and the committed burst size (Bc). An exception to this occurs when CIR is provisioned to be zero, in which case the measurement interval (t) must be provisioned explicitly. This attribute is ignored when rateEnforcement is off. If rateEnforcement is on and this attribute is 0, Bc must also be 0.')
mscFrNniDlciSpCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpCommittedBurstSize.setDescription('This attribute specifies the committed burst size (Bc) in bits. bc is the amount of data that a network agrees to transfer under normal conditions over a measurement interval (t). Data marked DE=1 is not accounted for in Bc. This attribute is ignored when rateEnforcement is off. If rateEnforcement is on and this attribute is 0, cir must also be 0.')
mscFrNniDlciSpExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpExcessBurstSize.setDescription('This attribute specifies the excess burst size (Be) in bits. Be is the amount of uncommitted data that the network will attempt to deliver over measurement interval T. Data marked DE=1 by the user or by the network is accounted for here. CIR, Bc, and Be cannot all be zero when rateEnforcement is on.')
mscFrNniDlciSpMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 25500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpMeasurementInterval.setDescription('When cir and bc are zero and rateEnforcement is on, this attribute must be provisioned to specify the time interval (in milliseconds) over which rates and burst sizes are measured. When cir and bc are non-zero, the time interval is internally calculated and is not shown. In that situation, this field is ignored, and is not representative of the time interval. This attribute is ignored when rateEnforcement is off, or when cir and bc are non-zero. If rateEnforcement is on and both cir and bc are zero, this field must be non-zero.')
mscFrNniDlciSpRateAdaptation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("eirOnly", 2), ("cirProportionate", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpRateAdaptation.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpRateAdaptation.setDescription('This attribute specifies whether rate adaptation is in effect for this user Data Link Connection on this Frame Relay interface. Rate adaptation is a feature that, in periods of congestion, adapts the rate at which the user is allowed to send data into the network to that which the network is able to handle at that time. This pro-active measure of handling congestion optimizes network resources by causing the ingress to discard frames that would otherwise be discarded in the network. If this attribute is set to on, then, at the onset of congestion, the excess information rate (EIR) is reduced to a very low rate. If congestion persists, then the allowed CIR is reduced geometrically by 25% of the current value at that time. The minimum to which CIR can be reduced is 1/16th (6.25%) of the provisioned value. As congestion alleviates, CIR is increased linearly by 6.25% of the provisioned value specified in committedInformationRate. If set to eirOnly, then rate adaptation will only apply to the excess information rate (EIR). At the onset of congestion, the allowed EIR is reduced by 25% of its provisioned value. If congestion persists, EIR is reduced geometrically by 25% of the current value at that time. As congestion alleviates, EIR is gradually increased linearly by 6.25% of the provisioned EIR. If set to cirProportionate, then rate adaptation will also only apply to the excess information rate (EIR). At the onset of congestion the initial allowed EIR is set to a multiple of the provisioned CIR. If congestion persists, the allowed EIR is reduced geometrically by 25% of the current value at that time. As congestion alleviates, EIR is gradually increased linearly by 6.25% of the provisioned EIR. Note that the allowed EIR may be set higher than the provisioned EIR, since it is calculated initially using another parameter, the provisioned CIR. If the allowed EIR at the moment is higher than the provisioned EIR, then the provisioned EIR is used instead. This attribute can only be set to on eirOnly or cirProportionate if rateEnforcement is turned on.')
mscFrNniDlciSpAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpAccounting.setDescription('This attribute specifies whether accounting data collection and record generation is turned on at this DLCI. For accounting data collection and record generation to be turned on, the accountingOn bit and at least one of the accountCollection bits in the DataNetworkAddress component must be set to on.')
mscFrNniDlciSpRaSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpRaSensitivity.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpRaSensitivity.setDescription('This attribute specifies the sensitivity of the rate adaptation system. A higher number indicates a higher sensitivity and therefore a quicker reaction time to network conditions. A quicker reaction time allows the network to discard frames at the access and protect network resources, but can lead to false alarms and a greater fluctuation of the allowed rate. A higher setting therefore tends to favour the protection of the network over the allowed throughput of the user. A lower number indicates a lower sensitivity and therefore a slower reaction to network conditions. A slower reaction time results in a greater amount of user traffic allowed into the network, but can lead to a waste of network bandwidth since the traffic may be discarded at the congested resource. A lower setting therefore tends to favour the allowed throughput of the user over the protection of the network. This attribute is applicable for adapting EIR when rateAdaptation is eirOnly or cirProportionate, or CIR when rateAdaptation is on. This attribute is ignored if rateAdaptation is turned off.')
mscFrNniDlciSpUpdateBCI = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 4, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciSpUpdateBCI.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciSpUpdateBCI.setDescription('This attribute specifies whether internal Backward Congestion Indication (BCI) bits will report congestion external to the Passport network, as communicated through incoming BECN bits. If updateBCI is set to on, then BCI bits for incoming frames will be set if the BECN on the frame is set. If updatBCI is set to off, then incoming BECN bits will have no effect. Setting updateBCI on for a DLCI means that the remote end of the DLCI, which is specified by the remotedna and remotedlci attributes of the dc component of the dlci, may perform Rate Adaptation using the flow of incoming BECN bits, in addition to internal Passport congestion management systems. If the rateAdaptation attribute of the remote dlci is provisioned as eirOnly, cirProportionate, or on, then congestion from another network connected to a Passport network may trigger dynamic congestion management. If the rateAdaptation attribute of the remote dlci is provisioned to off, then the setting of updateBCI attribute here will have no effect..')
mscFrNniDlciLb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5))
mscFrNniDlciLbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 1), )
if mibBuilder.loadTexts: mscFrNniDlciLbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDlciLb components.')
mscFrNniDlciLbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciLbIndex"))
if mibBuilder.loadTexts: mscFrNniDlciLbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDlciLb component.')
mscFrNniDlciLbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDlciLb components. These components cannot be added nor deleted.')
mscFrNniDlciLbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDlciLbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbStorageType.setDescription('This variable represents the storage type value for the mscFrNniDlciLb tables.')
mscFrNniDlciLbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniDlciLbIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbIndex.setDescription('This variable represents the index for the mscFrNniDlciLb tables.')
mscFrNniDlciLbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10), )
if mibBuilder.loadTexts: mscFrNniDlciLbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbStatsTable.setDescription('This group contains all the statistics for the data loopback tool.')
mscFrNniDlciLbStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciLbIndex"))
if mibBuilder.loadTexts: mscFrNniDlciLbStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbStatsEntry.setDescription('An entry in the mscFrNniDlciLbStatsTable.')
mscFrNniDlciLbLocalTotalFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbLocalTotalFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbLocalTotalFrm.setDescription('This attribute records the number of frames looped back to the link since loopback was last started.')
mscFrNniDlciLbLocalTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbLocalTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbLocalTotalBytes.setDescription('This attribute records the number of bytes looped back to the link since loopback mode was started.')
mscFrNniDlciLbLocalFecnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbLocalFecnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbLocalFecnFrm.setDescription('This attribute records the number of frames with the Forward Explicit Congestion Notification (FECN) bit set, looped back to the link since the loopback mode was started.')
mscFrNniDlciLbLocalBecnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbLocalBecnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbLocalBecnFrm.setDescription('This attribute records the number of frames with the Backward Explicit Congestion Notification (BECN) bit set, looped back to the link since the loopback mode was started.')
mscFrNniDlciLbLocalDeFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbLocalDeFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbLocalDeFrm.setDescription('This attribute records the number of frames with the Discard Eligibility (DE) bit set, looped back to the link since the loopback mode was started.')
mscFrNniDlciLbLocalDeBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbLocalDeBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbLocalDeBytes.setDescription('This attribute records the number of bytes in frames with the Discard Eligibility (DE) bit set, looped back to the link since the loopback mode was started.')
mscFrNniDlciLbRemoteTotalFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteTotalFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteTotalFrm.setDescription('This attribute records the number of frames looped back to the subnet since loopback was last started.')
mscFrNniDlciLbRemoteTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteTotalBytes.setDescription('This attribute records the number of bytes looped back to the subnet since loopback was last started.')
mscFrNniDlciLbRemoteFecnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteFecnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteFecnFrm.setDescription('This attribute records the number of frames with the Forward Explicit Congestion Notification (FECN) bit set, looped back to the subnet since the loopback mode was started.')
mscFrNniDlciLbRemoteBecnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteBecnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteBecnFrm.setDescription('This attribute records the number of frames with the Backward Explicit Congestion Notification (BECN) bit set, looped back to the subnet since the loopback mode was started.')
mscFrNniDlciLbRemoteDeFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteDeFrm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteDeFrm.setDescription('This attribute records the number of frames with the Discard Eligibility (DE) bit set, looped back to the subnet since the loopback mode was started.')
mscFrNniDlciLbRemoteDeBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 5, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteDeBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciLbRemoteDeBytes.setDescription('This attribute records the number of bytes in frames with the Discard Eligibility (DE) bit set, looped back to the subnet since the loopback mode was started.')
mscFrNniDlciEgressSp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6))
mscFrNniDlciEgressSpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 1), )
if mibBuilder.loadTexts: mscFrNniDlciEgressSpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniDlciEgressSp components.')
mscFrNniDlciEgressSpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciEgressSpIndex"))
if mibBuilder.loadTexts: mscFrNniDlciEgressSpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniDlciEgressSp component.')
mscFrNniDlciEgressSpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEgressSpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniDlciEgressSp components. These components cannot be added nor deleted.')
mscFrNniDlciEgressSpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEgressSpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniDlciEgressSpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniDlciEgressSpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpStorageType.setDescription('This variable represents the storage type value for the mscFrNniDlciEgressSp tables.')
mscFrNniDlciEgressSpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniDlciEgressSpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpIndex.setDescription('This variable represents the index for the mscFrNniDlciEgressSp tables.')
mscFrNniDlciEgressSpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 10), )
if mibBuilder.loadTexts: mscFrNniDlciEgressSpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpProvTable.setDescription('This group contains the provisionable attributes for this component.')
mscFrNniDlciEgressSpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniDlciEgressSpIndex"))
if mibBuilder.loadTexts: mscFrNniDlciEgressSpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpProvEntry.setDescription('An entry in the mscFrNniDlciEgressSpProvTable.')
mscFrNniDlciEgressSpCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 50000000), ValueRangeConstraint(50000001, 50000001), )).clone(50000001)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciEgressSpCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpCommittedInformationRate.setDescription('This attribute specifies the committed information rate (CIR) for the egress direction. It is used for Call Admission Control (CAC) at the egress link. If the value is set to sameAsSp, the value of this attribute is the same as the committedInformationRate attribute under the ServiceParameters component. VALUES ( 50000001 = sameAsServiceParameters )')
mscFrNniDlciEgressSpCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 50000000), ValueRangeConstraint(50000001, 50000001), )).clone(50000001)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciEgressSpCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpCommittedBurstSize.setDescription('This attribute specifies the committed burst size (Bc) for the egress direction. It is used for performing Call Admission Control (CAC) at the egress link. If the value is set to sameAsSp, the value of this attribute is the same as the committedBurstSize attribute under the ServiceParameters component. VALUES ( 50000001 = sameAsServiceParameters )')
mscFrNniDlciEgressSpExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 50000000), ValueRangeConstraint(50000001, 50000001), )).clone(50000001)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciEgressSpExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpExcessBurstSize.setDescription('This attribute specifies the excess burst size (Be) for the egress direction. It is used for Call Admission Control (CAC) function towards the egress link. If the value is set to sameAsSp, the value of this attribute is the same as the excessBurstSize attribute under the ServiceParameters component. VALUES ( 50000001 = sameAsServiceParameters )')
mscFrNniDlciEgressSpMeasurementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 5, 6, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 25500), ValueRangeConstraint(25501, 25501), )).clone(25501)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniDlciEgressSpMeasurementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniDlciEgressSpMeasurementInterval.setDescription('This attribute specifies the time interval over which rates and burst sizes are measured in the egress direction. It is used for bandwidth reservation for Call Admission Control (CAC) towards the egress link. If the value is set to sameAsSp, the value of this attribute is the same as the measurementInterval attribute under the ServiceParameters component. VALUES ( 25501 = sameAsServiceParameters )')
mscFrNniVFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6))
mscFrNniVFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 1), )
if mibBuilder.loadTexts: mscFrNniVFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniVFramer components.')
mscFrNniVFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniVFramerIndex"))
if mibBuilder.loadTexts: mscFrNniVFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniVFramer component.')
mscFrNniVFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniVFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniVFramer components. These components can be added and deleted.')
mscFrNniVFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniVFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniVFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniVFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerStorageType.setDescription('This variable represents the storage type value for the mscFrNniVFramer tables.')
mscFrNniVFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniVFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerIndex.setDescription('This variable represents the index for the mscFrNniVFramer tables.')
mscFrNniVFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 10), )
if mibBuilder.loadTexts: mscFrNniVFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerProvTable.setDescription('This group contains provisionable attributes for the VirtualFramer component.')
mscFrNniVFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniVFramerIndex"))
if mibBuilder.loadTexts: mscFrNniVFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerProvEntry.setDescription('An entry in the mscFrNniVFramerProvTable.')
mscFrNniVFramerOtherVirtualFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniVFramerOtherVirtualFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerOtherVirtualFramer.setDescription('This attribute specifies the other VirtualFramer to which the service is linked, for example, FrUni/n VirtualFramer, FrDte/n VirtualFramer.')
mscFrNniVFramerLogicalProcessor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 10, 1, 2), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniVFramerLogicalProcessor.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerLogicalProcessor.setDescription('This attribute specifies the logical processor on which the service component will reside.')
mscFrNniVFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 11), )
if mibBuilder.loadTexts: mscFrNniVFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrNniVFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniVFramerIndex"))
if mibBuilder.loadTexts: mscFrNniVFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerStateEntry.setDescription('An entry in the mscFrNniVFramerStateTable.')
mscFrNniVFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniVFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrNniVFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniVFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrNniVFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniVFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrNniVFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 12), )
if mibBuilder.loadTexts: mscFrNniVFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerStatsTable.setDescription('This group contains the operational statistics data for a VirtualFramer component.')
mscFrNniVFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniVFramerIndex"))
if mibBuilder.loadTexts: mscFrNniVFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerStatsEntry.setDescription('An entry in the mscFrNniVFramerStatsTable.')
mscFrNniVFramerFrmToOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 12, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniVFramerFrmToOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerFrmToOtherVFramer.setDescription('This attribute counts the frames transmitted to the otherVirtualFramer.')
mscFrNniVFramerFrmFromOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 12, 1, 3), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniVFramerFrmFromOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerFrmFromOtherVFramer.setDescription('This attribute counts the frames received from the otherVirtualFramer.')
mscFrNniVFramerOctetFromOtherVFramer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 6, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniVFramerOctetFromOtherVFramer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniVFramerOctetFromOtherVFramer.setDescription('This attribute counts the octets received from the otherVirtualFramer.')
mscFrNniSig = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8))
mscFrNniSigRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 1), )
if mibBuilder.loadTexts: mscFrNniSigRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniSig components.')
mscFrNniSigRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniSig component.')
mscFrNniSigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniSig components. These components can be added and deleted.')
mscFrNniSigComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniSigStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigStorageType.setDescription('This variable represents the storage type value for the mscFrNniSig tables.')
mscFrNniSigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniSigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigIndex.setDescription('This variable represents the index for the mscFrNniSig tables.')
mscFrNniSigProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 11), )
if mibBuilder.loadTexts: mscFrNniSigProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigProvTable.setDescription('This group contains common provisionable attributes for signaling at the interface.')
mscFrNniSigProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigProvEntry.setDescription('An entry in the mscFrNniSigProvTable.')
mscFrNniSigDlciAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("fromLowEnd", 0), ("fromHighEnd", 1))).clone('fromLowEnd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigDlciAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigDlciAllocation.setDescription('This attribute specifies the order in which DLCIs are dynamically allocated for SVCs. The purpose of this attribute is to prevent DLCI collisions between SVCs initiated by two FrNni interfaces talking to each other. This is achieved by provisioning a different value for this attribute at each end of the NNI link. A value of fromLowEnd specifies that the DLCI number assignment for SVC connections is initiated from the lowest value of the range (that is, highestPvcDlci+1 up to 1007). A value of fromHighEnd specifies that the DLCI number assignment for SVC connections is initiated from the highest value of the range (that is, 1007 down to highestPvcDlci+1).')
mscFrNniSigHighestPermanentDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(16, 1007), )).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigHighestPermanentDlci.setStatus('obsolete')
if mibBuilder.loadTexts: mscFrNniSigHighestPermanentDlci.setDescription('This attribute specifies the highest DLCI value that can be provisioned for a permanent connection. It partitions the DLCI space into permanent and switched connections. Permanent DLCI numbers higher than this value cannot be provisioned. The value 0 is used to indicate that no permanent connections are allowed on this interface. The value 1007 indicates that no switched connections are allowed on this interface.')
mscFrNniSigHighestPvcDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(16, 1007), )).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigHighestPvcDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigHighestPvcDlci.setDescription('This attribute specifies the highest DLCI value that can be provisioned for a permanent connection. It partitions the DLCI space into permanent and switched connections. Permanent DLCI numbers higher than this value cannot be provisioned. The value 0 is used to indicate that no permanent connections are allowed on this interface. The value 1007 indicates that no switched connections are allowed on this interface.')
mscFrNniSigServParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12), )
if mibBuilder.loadTexts: mscFrNniSigServParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigServParmsTable.setDescription('This group contains the provisionable service parameters.')
mscFrNniSigServParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigServParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigServParmsEntry.setDescription('An entry in the mscFrNniSigServParmsTable.')
mscFrNniSigMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8187)).clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigMaximumFrameSize.setDescription('This attribute specifies the maximum number of octets that may be included in the information field of the user DLCI of any switched connections using this interface. Its value must not be smaller than the value of defaultMaximumFrameSize.')
mscFrNniSigDefaultMaximumFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8187)).clone(2100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigDefaultMaximumFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigDefaultMaximumFrameSize.setDescription("This attribute specifies the default maximum number of octets that may be included in the information field of the user DLCI assigned for any switched connections using this interface. This value is used during call parameter negotiation for switched calls on this interface when the maximum frame size is not specified in the user's SETUP message. The value of this attribute must not exceed the value of the maximumFrameSize attribute.")
mscFrNniSigDefaultCommittedInformationRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigDefaultCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigDefaultCommittedInformationRate.setDescription("This attribute specifies the default user to network direction CIR. This value is used during call parameter negotiation for switched calls on this interface when the CIR is not specified in the user's SETUP message.")
mscFrNniSigDefaultCommittedBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000)).clone(64000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigDefaultCommittedBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigDefaultCommittedBurstSize.setDescription("This attribute specifies the default user to network direction Bc. This value is used during call parameter negotiation for switched calls on this interface when the Bc is not specified in the user's SETUP message.")
mscFrNniSigDefaultExcessBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigDefaultExcessBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigDefaultExcessBurstSize.setDescription("This attribute specifies the default user to network direction Be. This value is used during call parameter negotiation for switched calls on this interface when the Be is not specified in the user's SETUP message.")
mscFrNniSigRateEnforcement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigRateEnforcement.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRateEnforcement.setDescription('This attribute specifies whether rate enforcement is in effect for SVCs on this interface.')
mscFrNniSigRateAdaptation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("eirOnly", 2), ("cirProportionate", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigRateAdaptation.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRateAdaptation.setDescription('This attribute specifies whether closed-loop rate adaptation is in effect for SVCs on this interface. Rate adaptation is a feature that, in periods of congestion, adapts the rate at which the user is allowed to send data into the network to that which the network is able to handle at that time. This proactive measure of handling congestion optimizes network resources by causing the ingress to discard frames that would otherwise be discarded in the network. If this attribute is set to on, then, at the onset of congestion, the excess information rate (EIR) is reduced to a very low rate. If congestion persists, then the allowed CIR is reduced geometrically by 25% of the current value at that time. The minimum to which CIR can be reduced is 1/16th (6.25%) of the provisioned value. As congestion alleviates, CIR is increased linearly by 6.25% of the provisioned value specified in committedInformationRate. If set to eirOnly, then rate adaptation will only apply to the excess information rate (EIR). At the onset of congestion, the allowed EIR is reduced by 25% of its provisioned value. If congestion persists, EIR is reduced geometrically by 25% of the current value at that time. As congestion alleviates, EIR is gradually increased linearly by 6.25% of the provisioned EIR. If set to cirProportionate, then rate adaptation will also only apply to the excess information rate (EIR). At the onset of congestion the initial allowed EIR is set to a multiple of the provisioned CIR. If congestion persists, the allowed EIR is reduced geometrically by 25% of the current value at that time. As congestion alleviates, EIR is gradually increased linearly by 6.25% of the provisioned EIR. Note that the allowed EIR may be set higher than the provisioned EIR, since it is calculated initially using another parameter, the provisioned CIR. If the allowed EIR at the moment is higher than the provisioned EIR, then the provisioned EIR is used instead. This attribute can only be set to on or eirOnly if rateEnforcement is set to on.')
mscFrNniSigRaSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigRaSensitivity.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRaSensitivity.setDescription('This attribute specifies the sensitivity of the rate adaptation system for all switched connections on this interface. A higher number indicates a higher sensitivity and therefore a quicker reaction time to network conditions. A quicker reaction time allows the network to discard frames at the access and protect network resources, but can lead to false alarms and a greater fluctuation of the allowed rate. A higher setting therefore tends to favor the protection of the network over the allowed throughput of the user. A lower number indicates a lower sensitivity and therefore a slower reaction to network conditions. A slower reaction time results in a greater amount of user traffic allowed into the network, but can lead to a waste of network bandwidth since the traffic may be discarded at the congested resource. A lower setting therefore tends to favour the allowed throughput of the user over the protection of the network. This attribute is applicable for adapting EIR when rateAdaptation is eirOnly or cirProportionate, or CIR when rateAdaptation is on. This attribute is ignored if rateAdaptation is off.')
mscFrNniSigUpdateBCI = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigUpdateBCI.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigUpdateBCI.setDescription('This attribute specifies whether internal Backward Congestion Indication (BCI) bits will report congestion external to the Passport network, as communicated through incoming BECN bits. If updateBCI is set to on, then BCI bits for incoming frames will be set if the BECN on the frame is set. If updateBCI is set to off, then incoming BECN bits has no effect. Setting updateBCI on for a DLCI means that the remote end of the DLCI, which is specified by the remoteDna and remoteDlci attributes of the Dc component of the Dlci, may perform Rate Adaptation using the flow of incoming BECN bits, in addition to internal Passport congestion management systems. If the rateAdaptation attribute of the remote DLCI is provisioned as eirOnly, cirProportionate, or on, then congestion from another network connected to a Passport network may trigger dynamic congestion management. If there is no rate adaptation at the other end, then the setting of updateBCI attribute here will have no effect.')
mscFrNniSigSysParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13), )
if mibBuilder.loadTexts: mscFrNniSigSysParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigSysParmsTable.setDescription('This group contains the provisionable FRF.10 system parameters.')
mscFrNniSigSysParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigSysParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigSysParmsEntry.setDescription('An entry in the mscFrNniSigSysParmsTable.')
mscFrNniSigCallSetupTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigCallSetupTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigCallSetupTimer.setDescription('This attribute specifies the time this interface waits for a response to the SETUP message sent to the adjacent network. Upon timer expiry, the SETUP message is retransmitted. The second expiry of this timer causes the call to be cleared.')
mscFrNniSigReleaseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigReleaseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigReleaseTimer.setDescription('This attribute specifies the time this interface waits for a response to the RELEASE message sent to the adjacent network. Upon timer expiry, the RELEASE message is retransmitted. The second expiry of the timer causes the call to be released.')
mscFrNniSigCallProceedingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigCallProceedingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigCallProceedingTimer.setDescription('This attribute specifies the time this interface waits for the CONNECT message from the adjacent network after the network has received the optional CALL PROCEEDING message from the adjacent network. Upon timer expiry, the call is cleared.')
mscFrNniSigRestartReqTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigRestartReqTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRestartReqTimer.setDescription('This attribute specifies the time this interface waits for the RESTART ACKNOWLEDGE message from the adjacent network after sending a first RESTART message. Upon timer expiry, another RESTART message is sent. After the second expiry, the interface is treated as idle. If the restartReqTimer attribute is set to the default value, then the interface is treated as idle when it receives an indication that the link is up and does not send a RESTART message.')
mscFrNniSigRestartRcvTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(110)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigRestartRcvTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRestartRcvTimer.setDescription('This attribute specifies the time this interface waits for the processing of a RESTART message received by the interface. Upon expiry of this timer, an alarm will be displayed to report the problem. The timer value must be less than the restartReqTimer provisioned value at the adjacent node.')
mscFrNniSigStatusEnqTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigStatusEnqTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigStatusEnqTimer.setDescription('This attribute specifies the time the network waits for the requested STATUS message from the adjacent network. Upon expiry of this timer, another STATUS ENQUIRY message will be sent.')
mscFrNniSigNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("private", 1), ("public", 2))).clone('private')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigNetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigNetworkType.setDescription('This attribute specifies whether this Frame Relay service is running on a public or a private network. This value is used solely in populating applicable information elements within those signaling messages that require a public or private network indication.')
mscFrNniSigLapfSysTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 14), )
if mibBuilder.loadTexts: mscFrNniSigLapfSysTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLapfSysTable.setDescription('This group contains the provisionable attributes for the SVC data link layer. The data link layer is governed primarily through ITU specification Q.922, and operates over DLCI 0.')
mscFrNniSigLapfSysEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigLapfSysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLapfSysEntry.setDescription('An entry in the mscFrNniSigLapfSysTable.')
mscFrNniSigWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 14, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigWindowSize.setDescription('This attribute specifies the window size. This is the maximum number of unacknowledged sequenced frames that may be outstanding from or to this interface at any one time.')
mscFrNniSigRetransmitLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 14, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 20)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigRetransmitLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRetransmitLimit.setDescription('This attribute specifies the number of times a frame can be retransmitted by the SVC data link layer before appropriate recovery action is taken.')
mscFrNniSigAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 14, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 10000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigAckTimer.setDescription('This attribute specifies how long the layer 2 protocol waits for an acknowledgment to a sent frame. The value set for ackTimer must be less than the value set for idleProbeTimer.')
mscFrNniSigAckDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 14, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigAckDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigAckDelayTimer.setDescription('This attribute specifies how long the network waits before sending an acknowledgment for a received in-sequence I-frame. A value of 0 means that every frame is acknowledged and there will be no delay in acknowledgment. A non-zero value means that one acknowledgement is sent for a number of frames.')
mscFrNniSigIdleProbeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 14, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 65535000)).clone(30000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigIdleProbeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigIdleProbeTimer.setDescription("This attribute specifies how long the link is permitted to remain idle (that is, no frames are exchanged on the data link). Upon expiry of this timer, the network side's link layer polls its peer for status. The value set for idleProbeTimer must be greater than the value set for ackTimer.")
mscFrNniSigCodesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 15), )
if mibBuilder.loadTexts: mscFrNniSigCodesTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigCodesTable.setDescription('This group contains the remote data network address, the last SVC clear cause and the last SVC diagnostic code coming from the subnet or the local VC.')
mscFrNniSigCodesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigCodesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigCodesEntry.setDescription('An entry in the mscFrNniSigCodesTable.')
mscFrNniSigLastClearRemoteDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 15, 1, 1), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigLastClearRemoteDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLastClearRemoteDataNetworkAddress.setDescription('This attribute indicates the Data Network Address (DNA) of the remote (the other end of the SVC connection) of the call which cleared last and whose clear and diagnostic codes were recorded.')
mscFrNniSigLastClearCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 15, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigLastClearCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLastClearCause.setDescription('This attribute indicates the last SVC clear cause signalled at the end of the connection or failure to connect. It is updated only if the clear request comes from the subnet or the call is rejected locally by the VC. The same set of possible values provides the clear cause field in the accounting record.')
mscFrNniSigLastDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 15, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigLastDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLastDiagnosticCode.setDescription('This attribute indicates the last SVC diagnostic code signalled at the end of the connection or failure to connect. It is updated if the clear request comes from the subnet or the call is rejected locally by the VC. The same set of possible values provides the diagnostic code field in the accounting record.')
mscFrNniSigStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 16), )
if mibBuilder.loadTexts: mscFrNniSigStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscFrNniSigStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigStateEntry.setDescription('An entry in the mscFrNniSigStateTable.')
mscFrNniSigAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscFrNniSigOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscFrNniSigUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscFrNniSigStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17), )
if mibBuilder.loadTexts: mscFrNniSigStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigStatsTable.setDescription('This group contains the statistics related to the SVC signaling layer at the interface level.')
mscFrNniSigStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigStatsEntry.setDescription('An entry in the mscFrNniSigStatsTable.')
mscFrNniSigCurrentNumberOfSvcCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 992))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigCurrentNumberOfSvcCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigCurrentNumberOfSvcCalls.setDescription('This attribute indicates the number of Frame Relay SVCs currently existing on this interface.')
mscFrNniSigInCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 992))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigInCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigInCalls.setDescription('This attribute indicates the current number of incoming SVCs on this interface (that is, the number of SVCs for which this interface represents the destination end of the call).')
mscFrNniSigInCallsRefused = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigInCallsRefused.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigInCallsRefused.setDescription('This attribute counts the incoming SVC call requests that are rejected by either this interface or by the called user. When this count exceeds the maximum, it wraps to zero.')
mscFrNniSigOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 992))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigOutCalls.setDescription('This attribute indicates the current number of outgoing SVCs on this interface (that is, the number of SVCs for which this interface represents the source end of the call).')
mscFrNniSigOutCallsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigOutCallsFailed.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigOutCallsFailed.setDescription('This attribute counts the outgoing SVC call requests that are rejected by either this interface, or by the network side of the destination end, or by the called user. When this count exceeds the maximum, it wraps to zero.')
mscFrNniSigProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigProtocolErrors.setDescription('This attribute counts the number of times a FRF.10 protocol error has occurred. Any one of the following events constitutes a protocol error: 1. In the user-signaled Link Layer Core Parameters IE within the SETUP or CONNECT messages, Cir, Bc and Be are all zero; 2. In the user-signaled Link Layer Core Parameters IE within the SETUP or CONNECT messages, Cir is zero but Bc is non-zero, or Bc is zero but Cir is non-zero; 3. In the user-signaled Link Layer Core Parameters IE within the SETUP or CONNECT messages, the Minimum Acceptable CIR is greater than Cir; 4. At the destination end, any of the destination to source direction link layer core parameters has been increased in the CONNECT message from the called user; 5. At the destination end, the destination to source direction Cir in the CONNECT message is smaller than the corresponding minimum acceptable Cir signaled to the called user; 6. At the source end, any of the source to destination direction link layer core parameters in the CONNECT message from the destination end has been increased; 7. At the source end, the source to destination direction Cir, after negotiation, is smaller than the corresponding minimum acceptable Cir; 8. The network has received a STATUS message from the user with an incompatible FRF.10 state. When this count reaches maximum, it wraps to zero.')
mscFrNniSigQualityOfServiceNotAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigQualityOfServiceNotAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigQualityOfServiceNotAvailable.setDescription('This attribute counts the number of incoming and outgoing SVCs that are rejected because the quality of service requested cannot be met by the network. When this count reaches maximum, it wraps to zero.')
mscFrNniSigSetupTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigSetupTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigSetupTimeout.setDescription('This attribute counts the number of times the T303 setup timer has expired. When this count reaches maximum, it wraps to zero.')
mscFrNniSigLastCauseInStatusMsgReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigLastCauseInStatusMsgReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLastCauseInStatusMsgReceived.setDescription("This attribute indicates the cause value in the last received user's STATUS message to an existing call. The DLCI to which this STATUS message applies is specified in the lastDlciReceivedStatus attribute. The initial value of this attribute is 0 which means that no STATUS message has been received for an existing call yet.")
mscFrNniSigLastStateInStatusMsgReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63))).clone(namedValues=NamedValues(("null", 0), ("callInitiated", 1), ("n2", 2), ("outgoingCallProceeding", 3), ("n4", 4), ("n5", 5), ("callPresent", 6), ("n7", 7), ("n8", 8), ("incomingCallProceeding", 9), ("active", 10), ("releaseRequest", 11), ("releaseIndication", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("n16", 16), ("n17", 17), ("n18", 18), ("n19", 19), ("notApplicable", 20), ("n21", 21), ("n22", 22), ("n23", 23), ("n24", 24), ("n25", 25), ("n26", 26), ("n27", 27), ("n28", 28), ("n29", 29), ("n30", 30), ("n31", 31), ("n32", 32), ("n33", 33), ("n34", 34), ("n35", 35), ("n36", 36), ("n37", 37), ("n38", 38), ("n39", 39), ("n40", 40), ("n41", 41), ("n42", 42), ("n43", 43), ("n44", 44), ("n45", 45), ("n46", 46), ("n47", 47), ("n48", 48), ("n49", 49), ("n50", 50), ("n51", 51), ("n52", 52), ("n53", 53), ("n54", 54), ("n55", 55), ("n56", 56), ("n57", 57), ("n58", 58), ("n59", 59), ("n60", 60), ("restartRequest", 61), ("restart", 62), ("n63", 63))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigLastStateInStatusMsgReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLastStateInStatusMsgReceived.setDescription("This attribute indicates the state value in the last received user's STATUS message to an existing call. The DLCI to which this STATUS message applies is specified in the lastDlciReceivedStatus attribute. The initial value of this attribute is notApplicable.")
mscFrNniSigLastDlciReceivedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(16, 1007), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigLastDlciReceivedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLastDlciReceivedStatus.setDescription('This attribute shows the value of the DLCI that has most recently received a STATUS message from the user. The initial value of this attribute is 0.')
mscFrNniSigLastStateReceivedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 6, 9, 10, 11, 12, 20, 61, 62))).clone(namedValues=NamedValues(("null", 0), ("callInitiated", 1), ("outgoingCallProceeding", 3), ("callPresent", 6), ("incomingCallProceeding", 9), ("active", 10), ("releaseRequest", 11), ("releaseIndication", 12), ("notApplicable", 20), ("restartRequest", 61), ("restart", 62))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigLastStateReceivedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLastStateReceivedStatus.setDescription('This attribute shows the network FRF.10 state of the DLCI that has most recently received a STATUS message from the user. The DLCI to which this STATUS message applies is specified in the lastDlciReceivedStatus attribute. The initial value of this attribute is notApplicable.')
mscFrNniSigDlciCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 17, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigDlciCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigDlciCollisions.setDescription('This attribute counts the number of call failures due to DLCI collisions.')
mscFrNniSigLapfStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 18), )
if mibBuilder.loadTexts: mscFrNniSigLapfStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLapfStatusTable.setDescription('This group contains the Q.922 SVC data link layer status.')
mscFrNniSigLapfStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigLapfStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLapfStatusEntry.setDescription('An entry in the mscFrNniSigLapfStatusTable.')
mscFrNniSigCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 7))).clone(namedValues=NamedValues(("disconnected", 1), ("linkSetup", 2), ("disconnectRequest", 4), ("informationTransfer", 5), ("waitingAck", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigCurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigCurrentState.setDescription('This attribute shows the current state of the SVC data link layer interface.')
mscFrNniSigLastStateChangeReason = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5, 6, 7, 8, 9, 10, 12, 13))).clone(namedValues=NamedValues(("notStarted", 1), ("abmeEntered", 3), ("abmeReset", 5), ("dmReceived", 6), ("dmSent", 7), ("discReceived", 8), ("discSent", 9), ("frmrReceived", 10), ("n200RetranTimeOut", 12), ("other", 13))).clone('notStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigLastStateChangeReason.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLastStateChangeReason.setDescription('This attribute shows the reason for the most recent state change. notStarted - this is the default state after SVC data link has just been created. abmeEntered - SVC data link has entered Asynchronous Balanced Mode after SABME or UA has been received. abmeReset - the data link has been reset. dmReceived - DM response received. dmSent - DM sent. discReceived - DISC response received. discSent - DISC sent. frmrReceived - FRMR received. n200RetranTimeOut - retransmitLimit has been exceeded. other - unspecified state change reasons. The most likely reason for this is the transition from state waitingAck to state informationTransfer.')
mscFrNniSigFrmrReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 18, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigFrmrReceive.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigFrmrReceive.setDescription('This attribute shows the information field of the Frame Reject (FRMR) most recently received.')
mscFrNniSigCurrentQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigCurrentQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigCurrentQueueSize.setDescription('This attribute shows the current number of frames in the SVC data link layer transmit queue.')
mscFrNniSigLapfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19), )
if mibBuilder.loadTexts: mscFrNniSigLapfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLapfStatsTable.setDescription('This group contains the statistics for the SVC data link layer.')
mscFrNniSigLapfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigLapfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigLapfStatsEntry.setDescription('An entry in the mscFrNniSigLapfStatsTable.')
mscFrNniSigRemoteBusy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigRemoteBusy.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigRemoteBusy.setDescription('This attribute counts the number of times transmission of an I-frame was unsuccessful due to a perceived remote busy condition (window closed or remote busy). When this count reaches maximum, it wraps to zero.')
mscFrNniSigReceiveRejectFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigReceiveRejectFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigReceiveRejectFrame.setDescription('This attribute counts the number of REJ frames received by the interface. When this count reaches maximum, it wraps to zero.')
mscFrNniSigAckTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigAckTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigAckTimeout.setDescription('This attribute counts the number of times the ackTimer has expired. Frequent increments of this counter indicate a problem at the link or improper values have been chosen for ackTimer and ackDelayTimer between the local and remote sides. When this count reaches maximum, it wraps to zero.')
mscFrNniSigIFramesTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigIFramesTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigIFramesTransmitted.setDescription('This attribute counts the number of SVC I-frames transmitted to the interface on DLCI 0. An I-frame may be counted more than once if there are retransmissions at the SVC data link layer. When this count reaches maximum, it wraps to zero.')
mscFrNniSigIFramesTxDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigIFramesTxDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigIFramesTxDiscarded.setDescription('This attribute counts the number of SVC I-frames that are bound for the link but have been discarded. Discard reasons may be one of the following: 1. the frame length is beyond the allowed limit. 2. the SVC data link layer is in disconnected state. 3. the transmit queue has been purged because the queue length has reached the reset threshold. 4. the transmit queue or the queue waiting for acknowledgment has been purged because the link cannot be re-established. When this count reaches maximum, it wraps to zero.')
mscFrNniSigIFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigIFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigIFramesReceived.setDescription('This attribute counts the number of SVC I-frames received from the interface. When this count reaches maximum, it wraps to zero.')
mscFrNniSigIFramesRcvdDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigIFramesRcvdDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigIFramesRcvdDiscarded.setDescription('This attribute counts the number of SVC I-frames received but have been discarded. The discard reasons are: 1. incorrect frame size 2. frame is out of sequence 3. frame received while the network side of the SVC data link layer is not in the informationTransfer or waitingAck state. When this count reaches maximum, it wraps to zero.')
mscFrNniSigStateChange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 19, 1, 8650), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigStateChange.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigStateChange.setDescription('This attribute counts the number of times the SVC data link layer interface has changed state. While the data link layer is in informationTransfer state, this counter will increment on each expiry of idleProbeTimer as its state goes from informationTransfer to waitingAck and back. When this count exceeds the maximum, it wraps to zero.')
mscFrNniSigSvcaccTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 20), )
if mibBuilder.loadTexts: mscFrNniSigSvcaccTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigSvcaccTable.setDescription('This group contains the provisionable attribute which controls accounting for this interface.')
mscFrNniSigSvcaccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 20, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"))
if mibBuilder.loadTexts: mscFrNniSigSvcaccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigSvcaccEntry.setDescription('An entry in the mscFrNniSigSvcaccTable.')
mscFrNniSigDefaultAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniSigDefaultAccounting.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigDefaultAccounting.setDescription('This attribute specifies whether accounting data collection and record generation is turned on for switched connections at this interface. For accounting data collection and record generation to occur, this attribute must be on and at least one of the accountCollection reasons in the Dna component must be present.')
mscFrNniSigBandwidthNotAvailableTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 672), )
if mibBuilder.loadTexts: mscFrNniSigBandwidthNotAvailableTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigBandwidthNotAvailableTable.setDescription('This attribute counts the number of call failures for each bandwidth pool due to the requested bandwidth not being available.')
mscFrNniSigBandwidthNotAvailableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 672, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniSigBandwidthNotAvailableIndex"))
if mibBuilder.loadTexts: mscFrNniSigBandwidthNotAvailableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigBandwidthNotAvailableEntry.setDescription('An entry in the mscFrNniSigBandwidthNotAvailableTable.')
mscFrNniSigBandwidthNotAvailableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 672, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniSigBandwidthNotAvailableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigBandwidthNotAvailableIndex.setDescription('This variable represents the mscFrNniSigBandwidthNotAvailableTable specific index for the mscFrNniSigBandwidthNotAvailableTable.')
mscFrNniSigBandwidthNotAvailableValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 8, 672, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniSigBandwidthNotAvailableValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniSigBandwidthNotAvailableValue.setDescription('This variable represents an individual value for the mscFrNniSigBandwidthNotAvailableTable.')
mscFrNniLts = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9))
mscFrNniLtsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 1), )
if mibBuilder.loadTexts: mscFrNniLtsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniLts components.')
mscFrNniLtsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"))
if mibBuilder.loadTexts: mscFrNniLtsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniLts component.')
mscFrNniLtsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniLts components. These components can be added and deleted.')
mscFrNniLtsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniLtsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsStorageType.setDescription('This variable represents the storage type value for the mscFrNniLts tables.')
mscFrNniLtsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniLtsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsIndex.setDescription('This variable represents the index for the mscFrNniLts tables.')
mscFrNniLtsSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 10), )
if mibBuilder.loadTexts: mscFrNniLtsSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsSetupTable.setDescription('This attribute group contains the parameters used to configure the behavior of the Frame Relay Load Test System.')
mscFrNniLtsSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"))
if mibBuilder.loadTexts: mscFrNniLtsSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsSetupEntry.setDescription('An entry in the mscFrNniLtsSetupTable.')
mscFrNniLtsDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 10, 1, 200), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsDuration.setDescription('This attribute specifies the duration of the test in milliseconds. The test will run until the duration expires or the STOP command is issued. A value of 0 is used to indicate infinity.')
mscFrNniLtsAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 10, 1, 201), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("continousBurst", 0), ("intervalBurst", 1), ("delayBurst", 2), ("fixedBurst", 3))).clone('continousBurst')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsAlgorithm.setDescription('This attribute specifies which algorithm is used to generate the frames. ContinuousBurst This mode of traffic generation creates traffic at the maximum rate possible until all of the frames have been sent. The generator then waits until the end of the timeInterval to begin again. IntervalBurst This algorithm attempts to generate 10 ms bursts of burstSize frames. It will generate as many of the burstSize frames as it can per sub-interval. DelayedBurst This algorithm generates bursts of burstSize frames separated by 10 ms delays. FixedBurst This aglorithm is similar to IntervalBurst, except a fixed burst size of 12 frames is used. delayMeasurement This algorithm is used to measure delay. The specified number of frames in the indicated pattern are generated, one at a time, with a maximum wait of maxDelay before sending the next frame. This algorithm is not implemented yet.')
mscFrNniLtsBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 10, 1, 204), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 250)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsBurstSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsBurstSize.setDescription('This attribute specifies the number of frames per burst under the delayedBurst and intervalBurst algorithms.')
mscFrNniLtsTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 10, 1, 205), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsTimeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsTimeInterval.setDescription('This attribute specifies the time interval to the specified number of seconds. Granuality is in centiseconds. Maximum is 1 minute.')
mscFrNniLtsStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 11), )
if mibBuilder.loadTexts: mscFrNniLtsStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsStateTable.setDescription('This group contains the operation statistics of the load generator.')
mscFrNniLtsStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"))
if mibBuilder.loadTexts: mscFrNniLtsStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsStateEntry.setDescription('An entry in the mscFrNniLtsStateTable.')
mscFrNniLtsGeneratorState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 11, 1, 200), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("stopped", 0), ("running", 1))).clone('stopped')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsGeneratorState.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsGeneratorState.setDescription('This attribute indicates whether the Lts is generating traffic.')
mscFrNniLtsCycleIncomplete = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 11, 1, 201), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsCycleIncomplete.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsCycleIncomplete.setDescription('This attribute indicates whether the time required to generate all of the enabled patterns is more than timeInterval by a true value. Otherwise, this flag is set to false. Default is True.')
mscFrNniLtsLastActiveInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 11, 1, 202), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsLastActiveInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsLastActiveInterval.setDescription('This attribute indicates the actual time it took to generate all of the enabled patterns in the last cycle. If cycleIncomplete is true, this value should be zero.')
mscFrNniLtsLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 11, 1, 204), FixedPoint3().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsLoad.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsLoad.setDescription('This attribute indicates the load being generated. This value represents that calculated using the set number of ticks. The actual burstTimeInterval may differ. One entire cycle of the patterns is completed in activeInterval and thus most of the load may be concentrated early in the set interval.')
mscFrNniLtsElapsedGenerationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 11, 1, 205), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsElapsedGenerationTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsElapsedGenerationTime.setDescription('This attribute indicates how many milliseconds have elapsed since the start of this test.')
mscFrNniLtsResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 12), )
if mibBuilder.loadTexts: mscFrNniLtsResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsResultsTable.setDescription('This group contains the frame counting attributes for the LTS component.')
mscFrNniLtsResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"))
if mibBuilder.loadTexts: mscFrNniLtsResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsResultsEntry.setDescription('An entry in the mscFrNniLtsResultsTable.')
mscFrNniLtsFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 12, 1, 200), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsFramesTx.setDescription('This attribute specifies the number of frames send to the network since the last time these statistics were cleared. This is similar to the framesToIf attribute of the FRAMER component.')
mscFrNniLtsBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 12, 1, 204), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsBytesTx.setDescription('This attribute indicates the number of bytes sent.')
mscFrNniLtsBitRateTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 12, 1, 208), FixedPoint3().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsBitRateTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsBitRateTx.setDescription('This attribute indicates the bit rate being sent to the link. It should only differ from the load if the burstTimeInterval would be >= the timeInterval or burstSize frames cannot be generated in 10ms (intervalBurst algorithm).')
mscFrNniLtsFrameRateTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 12, 1, 209), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsFrameRateTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsFrameRateTx.setDescription('This attribute indicates the frame rate being sent to the link. It is calculated using the number of frames sent to the link in one cycle of the patterns.')
mscFrNniLtsPat = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2))
mscFrNniLtsPatRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 1), )
if mibBuilder.loadTexts: mscFrNniLtsPatRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniLtsPat components.')
mscFrNniLtsPatRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsPatIndex"))
if mibBuilder.loadTexts: mscFrNniLtsPatRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniLtsPat component.')
mscFrNniLtsPatRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniLtsPat components. These components can be added and deleted.')
mscFrNniLtsPatComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsPatComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniLtsPatStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsPatStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatStorageType.setDescription('This variable represents the storage type value for the mscFrNniLtsPat tables.')
mscFrNniLtsPatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 29)))
if mibBuilder.loadTexts: mscFrNniLtsPatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatIndex.setDescription('This variable represents the index for the mscFrNniLtsPat tables.')
mscFrNniLtsPatDefaultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10), )
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultsTable.setDescription('This attribute group contains the specifications of the pattern.')
mscFrNniLtsPatDefaultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsPatIndex"))
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultsEntry.setDescription('An entry in the mscFrNniLtsPatDefaultsTable.')
mscFrNniLtsPatDefaultDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 200), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 1007)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultDlci.setDescription('This attribute specifies for which dlci (on the local end) the frames are destined.')
mscFrNniLtsPatDefaultNumFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 201), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultNumFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultNumFrames.setDescription('This attribute specifies the number of frames in this pattern. This is the number of frames of this type which will be generated in one timeInterval.')
mscFrNniLtsPatDefaultDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 202), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8200)).clone(512)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultDataSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultDataSize.setDescription('This attribute specifies the payload size of each frame in bytes. This is in excess to the header.')
mscFrNniLtsPatDefaultHeaderBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 203), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultHeaderBits.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultHeaderBits.setDescription('This attribute specifies whether the following bits are on/off in the header of each frame. The following bits can be set: BeCn, C/R, De, FeCn Description of bits: becn(0) fecn(1) cr(2) de(3)')
mscFrNniLtsPatDefaultHeaderLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 204), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultHeaderLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultHeaderLength.setDescription('This attribute specifies the size of the frame relay header in bytes. Passport currently only supports a 2-byte header.')
mscFrNniLtsPatDefaultEABits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 205), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultEABits.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultEABits.setDescription('This attribute specifies how the address field extension bits are set in the frame header. Consider the value to be a four bit binary number. For example, 4 = 0100. Only the first headerLength bits are used. For instance, suppose headerLength is 3, then the appropriate EABits is 2, or 0010. This attribute can be used to create a header of length greater than two bytes or to specify incorrect EABits in the header.')
mscFrNniLtsPatDefaultPayloadPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 206), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 12)).clone(hexValue="55")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultPayloadPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultPayloadPattern.setDescription('This attribute specifies the payload of each frame. The value specified is in hexadecimal, where every two digits represent a byte. A maximum of 24 digits (12 bytes) may be set, after which the pattern will repeat in the payload (depending on repeatPattern attribute). NOTE: If a RFC 1490 header is specified, via the 1490Header attribute, the specified pattern will begin following the header (i.e. at the 9th byte in the payload).')
mscFrNniLtsPatDefaultRfc1490Header = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 207), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("n16", 16), ("n17", 17), ("none", 18))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultRfc1490Header.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultRfc1490Header.setDescription('This attribute specifies the appropriate RFC 1490 encapsulated header of the frame. A value of 0 indicates no 1490 header. NOTE: This header resides in the first 8 bytes of the payload. If the specified value is non-zero, then the payload pattern provisioned will begin at the 9th byte.')
mscFrNniLtsPatDefaultUseBadLrc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 10, 1, 208), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultUseBadLrc.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDefaultUseBadLrc.setDescription('This attribute specifies whether the frames from this pattern are to have a bad LRC prior to being sent to the framer. The LRC is checked while the frame is being put onto the link and the failure should cause an abort frame to be sent.')
mscFrNniLtsPatSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11), )
if mibBuilder.loadTexts: mscFrNniLtsPatSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatSetupTable.setDescription('This attribute group contains the specifications of the pattern.')
mscFrNniLtsPatSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsPatIndex"))
if mibBuilder.loadTexts: mscFrNniLtsPatSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatSetupEntry.setDescription('An entry in the mscFrNniLtsPatSetupTable.')
mscFrNniLtsPatDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 200), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 1007)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDlci.setDescription('This attribute specifies for which dlci (on the local end) the frames are destined.')
mscFrNniLtsPatNumFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 201), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatNumFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatNumFrames.setDescription('This attribute specifies the number of frames in this pattern. This is the number of frames of this type which will be generated in one timeInterval.')
mscFrNniLtsPatDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 202), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8200)).clone(512)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatDataSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatDataSize.setDescription('This attribute specifies the payload size of each frame in bytes. This is in excess to the header.')
mscFrNniLtsPatHeaderBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 203), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatHeaderBits.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatHeaderBits.setDescription('This attribute specifies whether the following bits are on/off in the header of each frame. The following bits can be set: BeCn, C/R, De, FeCn Description of bits: becn(0) fecn(1) cr(2) de(3)')
mscFrNniLtsPatHeaderLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 204), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 4), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatHeaderLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatHeaderLength.setDescription('This attribute specifies the size of the frame relay header in bytes. Passport currently only supports a 2-byte header. Valid values are 0, 2, 3, 4. 0 indicates to use no header. That is, the frame will start with either the payload or rfc1490 header.')
mscFrNniLtsPatEaBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 205), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatEaBits.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatEaBits.setDescription('This attribute specifies how the address field extension bits are set in the frame header. Consider the value to be a four bit binary number. For example, 4 = 0100. Only the first headerLength bits are used. For instance, suppose headerLength is 3, then the appropriate eaBits is 2, or 0010. This attribute can be used to create a header of length greater than two bytes or to specify incorrect eaBits in the header.')
mscFrNniLtsPatPayloadPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 206), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 12)).clone(hexValue="55")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatPayloadPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatPayloadPattern.setDescription('This attribute specifies the payload of each frame. The value specified is in hexadecimal, where every two digits represent a byte. A maximum of 24 digits (12 bytes) may be set, after which the pattern will repeat in the payload (depending on repeatPattern attribute). NOTE: If a RFC 1490 header is specified, via the 1490Header attribute, the specified pattern will begin following the header (i.e. at the 9th byte in the payload).')
mscFrNniLtsPatRfc1490Header = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 207), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("n10", 10), ("n11", 11), ("n12", 12), ("n13", 13), ("n14", 14), ("n15", 15), ("n16", 16), ("n17", 17), ("none", 18))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatRfc1490Header.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatRfc1490Header.setDescription('This attribute specifies the appropriate RFC 1490 encapsulated header of the frame. A value of 0 indicates no 1490 header. NOTE: This header resides in the first 8 bytes of the payload. If the specified value is non-zero, then the payload pattern provisioned will begin at the 9th byte.')
mscFrNniLtsPatUseBadLrc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 11, 1, 208), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatUseBadLrc.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatUseBadLrc.setDescription('This attribute specifies whether the frames from this pattern are to have a bad LRC prior to being sent to the framer. The LRC is checked while the frame is being put onto the link and the failure should cause an abort frame to be sent.')
mscFrNniLtsPatOpDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 12), )
if mibBuilder.loadTexts: mscFrNniLtsPatOpDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatOpDataTable.setDescription('This group contains the operational attributes which allow changing the pattern outside of provisioning mode.')
mscFrNniLtsPatOpDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsPatIndex"))
if mibBuilder.loadTexts: mscFrNniLtsPatOpDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatOpDataEntry.setDescription('An entry in the mscFrNniLtsPatOpDataTable.')
mscFrNniLtsPatFramePattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 12, 1, 200), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsPatFramePattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatFramePattern.setDescription('This attribute displays the first 20 to 24 bytes of the frame payload, depending on the frame relay header size selected. This attribute represents the frame if it were at least 20 to 24 bytes in size. That is, the actual frame may be smaller.')
mscFrNniLtsPatHdlcBitsInserted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 12, 1, 201), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsPatHdlcBitsInserted.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatHdlcBitsInserted.setDescription('This attribute displays how many times a zero bit will be inserted after 5 consecutive 1 bits when a frame from this pattern is sent out.')
mscFrNniLtsPatOpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 13), )
if mibBuilder.loadTexts: mscFrNniLtsPatOpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatOpStateTable.setDescription('This group contains the attributes containing the operational statistics of the pattern.')
mscFrNniLtsPatOpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniLtsPatIndex"))
if mibBuilder.loadTexts: mscFrNniLtsPatOpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatOpStateEntry.setDescription('An entry in the mscFrNniLtsPatOpStateTable.')
mscFrNniLtsPatLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 13, 1, 200), FixedPoint3().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniLtsPatLoad.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatLoad.setDescription('This attribute indicates the load due to this particular pattern. The loads associated with all of the provisioned patterns are summed to arrive at the FrLts load.')
mscFrNniLtsPatStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 9, 2, 13, 1, 201), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniLtsPatStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniLtsPatStatus.setDescription('This attributes specifies the administrative state of the pattern. A disabled pattern will not be generated, although it can still be triggered.')
mscFrNniCa = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101))
mscFrNniCaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 1), )
if mibBuilder.loadTexts: mscFrNniCaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniCa components.')
mscFrNniCaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"))
if mibBuilder.loadTexts: mscFrNniCaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniCa component.')
mscFrNniCaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniCa components. These components cannot be added nor deleted.')
mscFrNniCaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniCaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaStorageType.setDescription('This variable represents the storage type value for the mscFrNniCa tables.')
mscFrNniCaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscFrNniCaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIndex.setDescription('This variable represents the index for the mscFrNniCa tables.')
mscFrNniCaProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 10), )
if mibBuilder.loadTexts: mscFrNniCaProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaProvTable.setDescription('This attribute group contains the common provisionable attributes of the Ca component.')
mscFrNniCaProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"))
if mibBuilder.loadTexts: mscFrNniCaProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaProvEntry.setDescription('An entry in the mscFrNniCaProvTable.')
mscFrNniCaOverrideLinkRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 429496729))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaOverrideLinkRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaOverrideLinkRate.setDescription('This attribute allows the link rate to be overridden for this interface. This allows the user to specify a value other than the actual physical link rate computed when a Framer component is provisioned. When a VFramer component is provisioned, this attribute overrides a link rate set to the maximum value supported by CAC . This attribute serves to provide the user control on the amount of bandwidth available for performing CAC.')
mscFrNniCaMaximumBandwidthPerCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000)).clone(520000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaMaximumBandwidthPerCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaMaximumBandwidthPerCall.setDescription('This attribute specifies the maximum bandwidth that can be allocated per connection.')
mscFrNniCaIngressCacTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 11), )
if mibBuilder.loadTexts: mscFrNniCaIngressCacTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngressCacTable.setDescription('This attribute group contains the common provisionable attributes for ingress call admission control.')
mscFrNniCaIngressCacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"))
if mibBuilder.loadTexts: mscFrNniCaIngressCacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngressCacEntry.setDescription('An entry in the mscFrNniCaIngressCacTable.')
mscFrNniCaIngressApplyToCos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("cirOnly", 1), ("cirAndEir", 2))).clone('cirOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaIngressApplyToCos.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngressApplyToCos.setDescription("This attribute specifies which Classes of Service (CoS) have ingress Call Admission Control (CAC) applied to them. Ingress CAC applies only to swithced connections (SVCs and S-SPVCs). none - Ingress CAC is turned off for all classes of service. cirOnly - Ingress CAC is applied only to the CIR portion of a connection's bandwidth requirements for CIR>0 classes of service. cirAndEir - Ingress CAC is applied to both CIR and EIR portions of a connections bandwidth requirements for all classes of service.")
mscFrNniCaIngressMaximumEirOnlyCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 992)).clone(992)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaIngressMaximumEirOnlyCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngressMaximumEirOnlyCalls.setDescription('This attribute specifies the maximum number of connections in the ingress direction with EIR only traffic that can be up at a given time.')
mscFrNniCaEgressCacTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 12), )
if mibBuilder.loadTexts: mscFrNniCaEgressCacTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgressCacTable.setDescription('This attribute group contains the common provisionable attributes for egress call admission control.')
mscFrNniCaEgressCacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"))
if mibBuilder.loadTexts: mscFrNniCaEgressCacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgressCacEntry.setDescription('An entry in the mscFrNniCaEgressCacTable.')
mscFrNniCaEgressApplyToCos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("cirOnly", 1), ("cirAndEir", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaEgressApplyToCos.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgressApplyToCos.setDescription("This attribute specifies which Classes of Service (CoS) have egress Call Admission Control (CAC) applied to them. Egress CAC applies only to swithced connections (SVCs and S-SPVCs). none - Egress CAC is turned off for all classes of service. cirOnly - Egress CAC is applied only to the CIR portion of a connection's bandwidth requirements for CIR>0 classes of service. cirAndEir - Egress CAC is applied to both CIR and EIR portions of a connections bandwidth requirements for all classes of service.")
mscFrNniCaEgressMaximumEirOnlyCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 992)).clone(992)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaEgressMaximumEirOnlyCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgressMaximumEirOnlyCalls.setDescription('This attribute specifies the maximum number of connections in the egress direction with EIR only traffic that can be up at a given time.')
mscFrNniCaOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 13), )
if mibBuilder.loadTexts: mscFrNniCaOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaOpTable.setDescription('This attribute group contains the operational status of the Ca component.')
mscFrNniCaOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"))
if mibBuilder.loadTexts: mscFrNniCaOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaOpEntry.setDescription('An entry in the mscFrNniCaOpTable.')
mscFrNniCaLinkRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaLinkRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaLinkRate.setDescription('This attribute indicates the link rate used by both ingress and egress CAC to calculate the effective bandwidth pool sizes. If the provisionable attribute overrideLinkRate under this component is 0, then the link rate reported is the actual link rate of the port or channel. Otherwise, the link rate reported is the overrideLinkRate under this component.')
mscFrNniCaNumberRejectedEgressCirPermConn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 13, 1, 681), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 992))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaNumberRejectedEgressCirPermConn.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaNumberRejectedEgressCirPermConn.setDescription('This attribute indicates the number of permanent connections (that is, PVC and P-SPVC) that are rejected by egress CAC. A connection is rejected by egress CAC if it requests more egress CIR bandwidth than is available, and the egressApplyToCos attribute is set to either cirOnly or cirAndEir.')
mscFrNniCaNumberRejectedEgressEirPermConn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 13, 1, 682), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 992))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaNumberRejectedEgressEirPermConn.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaNumberRejectedEgressEirPermConn.setDescription('This attribute indicates the number of permanent connections (that is, PVC and P-SPVC) that are rejected by egress CAC. A connection is rejected by egress CAC if it requests more egress EIR bandwidth than is available, and the egressApplyToCos attribute is set to cirAndEir.')
mscFrNniCaIngCirBPTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 666), )
if mibBuilder.loadTexts: mscFrNniCaIngCirBPTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirBPTable.setDescription('Port capacity is partitioned into 16 pools (pool 0 through pool 15) for the ingress CIR traffic. This attribute specifies the percentage of port capacity that is allowed for each pool. The percentage for each pool ranges from 0% to 1000% of the link rate. It allows for under or over subscription of the port. Under subscription occurs when the sum of the percentages assigned to the 16 pools is less than 100%. Over subscription occurs when the sum of the percentages for the 16 pools exceeds 100%. The default is full sharing of port capacity with three pre-set partitions.')
mscFrNniCaIngCirBPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 666, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIngCirBPIndex"))
if mibBuilder.loadTexts: mscFrNniCaIngCirBPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirBPEntry.setDescription('An entry in the mscFrNniCaIngCirBPTable.')
mscFrNniCaIngCirBPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 666, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaIngCirBPIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirBPIndex.setDescription('This variable represents the mscFrNniCaIngCirBPTable specific index for the mscFrNniCaIngCirBPTable.')
mscFrNniCaIngCirBPValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 666, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaIngCirBPValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirBPValue.setDescription('This variable represents an individual value for the mscFrNniCaIngCirBPTable.')
mscFrNniCaEgCirBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 667), )
if mibBuilder.loadTexts: mscFrNniCaEgCirBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirBpTable.setDescription('Port capacity is partitioned into 16 pools (pool 0 through pool 15) for the egress CIR traffic. This attribute specifies the percentage of port capacity that is allowed for each pool. The percentage for each pool ranges from 0% to 1000% of the link rate. It allows for under or over subscription of the port. Under subscription occurs when the sum of the percentages assigned to the 16 pools is less than 100%. Over subscription occurs when the sum of the percentages for the 16 pools exceeds 100%. The default is full sharing of port capacity with three pre-set partitions.')
mscFrNniCaEgCirBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 667, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaEgCirBpIndex"))
if mibBuilder.loadTexts: mscFrNniCaEgCirBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirBpEntry.setDescription('An entry in the mscFrNniCaEgCirBpTable.')
mscFrNniCaEgCirBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 667, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaEgCirBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirBpIndex.setDescription('This variable represents the mscFrNniCaEgCirBpTable specific index for the mscFrNniCaEgCirBpTable.')
mscFrNniCaEgCirBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 667, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaEgCirBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirBpValue.setDescription('This variable represents an individual value for the mscFrNniCaEgCirBpTable.')
mscFrNniCaIngCirPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 668), )
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAdmitBwTable.setDescription('This attribute indicates the total admitted CIR bandwidth from each CIR bandwidth pool in the ingress direction. Each value is the sum of the equivalent bit rates of the admitted connections.')
mscFrNniCaIngCirPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 668, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIngCirPoolAdmitBwIndex"))
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAdmitBwEntry.setDescription('An entry in the mscFrNniCaIngCirPoolAdmitBwTable.')
mscFrNniCaIngCirPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 668, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAdmitBwIndex.setDescription('This variable represents the mscFrNniCaIngCirPoolAdmitBwTable specific index for the mscFrNniCaIngCirPoolAdmitBwTable.')
mscFrNniCaIngCirPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 668, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAdmitBwValue.setDescription('This variable represents an individual value for the mscFrNniCaIngCirPoolAdmitBwTable.')
mscFrNniCaIngCirPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 669), )
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAvailBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAvailBwTable.setDescription('This attribute indicates the remaining available CIR bandwidth in each ingress CIR bandwidth pool.')
mscFrNniCaIngCirPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 669, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIngCirPoolAvailBwIndex"))
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAvailBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAvailBwEntry.setDescription('An entry in the mscFrNniCaIngCirPoolAvailBwTable.')
mscFrNniCaIngCirPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 669, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAvailBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAvailBwIndex.setDescription('This variable represents the mscFrNniCaIngCirPoolAvailBwTable specific index for the mscFrNniCaIngCirPoolAvailBwTable.')
mscFrNniCaIngCirPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 669, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAvailBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngCirPoolAvailBwValue.setDescription('This variable represents an individual value for the mscFrNniCaIngCirPoolAvailBwTable.')
mscFrNniCaEgCirPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 670), )
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAdmitBwTable.setDescription('This attribute indicates the total admitted CIR bandwidth from each CIR bandwidth pool in the egress direction. Each value is the sum of the equivalent bit rates of the admitted connections.')
mscFrNniCaEgCirPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 670, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaEgCirPoolAdmitBwIndex"))
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAdmitBwEntry.setDescription('An entry in the mscFrNniCaEgCirPoolAdmitBwTable.')
mscFrNniCaEgCirPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 670, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAdmitBwIndex.setDescription('This variable represents the mscFrNniCaEgCirPoolAdmitBwTable specific index for the mscFrNniCaEgCirPoolAdmitBwTable.')
mscFrNniCaEgCirPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 670, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAdmitBwValue.setDescription('This variable represents an individual value for the mscFrNniCaEgCirPoolAdmitBwTable.')
mscFrNniCaEgCirPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 671), )
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAvailBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAvailBwTable.setDescription('This attribute indicates the remaining available CIR bandwidth in each egress CIR bandwidth pool.')
mscFrNniCaEgCirPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 671, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaEgCirPoolAvailBwIndex"))
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAvailBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAvailBwEntry.setDescription('An entry in the mscFrNniCaEgCirPoolAvailBwTable.')
mscFrNniCaEgCirPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 671, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAvailBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAvailBwIndex.setDescription('This variable represents the mscFrNniCaEgCirPoolAvailBwTable specific index for the mscFrNniCaEgCirPoolAvailBwTable.')
mscFrNniCaEgCirPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 671, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAvailBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgCirPoolAvailBwValue.setDescription('This variable represents an individual value for the mscFrNniCaEgCirPoolAvailBwTable.')
mscFrNniCaIngEirBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 673), )
if mibBuilder.loadTexts: mscFrNniCaIngEirBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirBpTable.setDescription('Port capacity is partitioned into 16 pools (pool 0 through pool 15) for the ingress EIR traffic. This attribute specifies the percentage of port capacity that is allowed for each pool. The percentage for each pool ranges from 0% to 1000% of the link rate. It allows for under or over subscription of the port. Under subscription occurs when the sum of the percentages assigned to the 16 pools is less than 100%. Over subscription occurs when the sum of the percentages for the 16 pools exceeds 100%. The default is full sharing of port capacity with three pre-set partitions.')
mscFrNniCaIngEirBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 673, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIngEirBpIndex"))
if mibBuilder.loadTexts: mscFrNniCaIngEirBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirBpEntry.setDescription('An entry in the mscFrNniCaIngEirBpTable.')
mscFrNniCaIngEirBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 673, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaIngEirBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirBpIndex.setDescription('This variable represents the mscFrNniCaIngEirBpTable specific index for the mscFrNniCaIngEirBpTable.')
mscFrNniCaIngEirBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 673, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaIngEirBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirBpValue.setDescription('This variable represents an individual value for the mscFrNniCaIngEirBpTable.')
mscFrNniCaEgEirBpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 674), )
if mibBuilder.loadTexts: mscFrNniCaEgEirBpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirBpTable.setDescription('Port capacity is partitioned into 16 pools (pool 0 through pool 15) for the egress EIR traffic. This attribute specifies the percentage of port capacity that is allowed for each pool. The percentage for each pool ranges from 0% to 1000% of the link rate. It allows for under or over subscription of the port. Under subscription occurs when the sum of the percentages assigned to the 16 pools is less than 100%. Over subscription occurs when the sum of the percentages for the 16 pools exceeds 100%. The default is full sharing of port capacity with three pre-set partitions.')
mscFrNniCaEgEirBpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 674, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaEgEirBpIndex"))
if mibBuilder.loadTexts: mscFrNniCaEgEirBpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirBpEntry.setDescription('An entry in the mscFrNniCaEgEirBpTable.')
mscFrNniCaEgEirBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 674, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaEgEirBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirBpIndex.setDescription('This variable represents the mscFrNniCaEgEirBpTable specific index for the mscFrNniCaEgEirBpTable.')
mscFrNniCaEgEirBpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 674, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaEgEirBpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirBpValue.setDescription('This variable represents an individual value for the mscFrNniCaEgEirBpTable.')
mscFrNniCaIngEirPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 675), )
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAdmitBwTable.setDescription('This attribute indicates the total admitted EIR bandwidth from each EIR bandwidth pool in the ingress direction. Each value is the sum of the equivalent bit rates of the admitted connections. If the ingressApplyToCos attribute is set to none, all ingress CIR bandwidth pools are set to 0.')
mscFrNniCaIngEirPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 675, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIngEirPoolAdmitBwIndex"))
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAdmitBwEntry.setDescription('An entry in the mscFrNniCaIngEirPoolAdmitBwTable.')
mscFrNniCaIngEirPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 675, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAdmitBwIndex.setDescription('This variable represents the mscFrNniCaIngEirPoolAdmitBwTable specific index for the mscFrNniCaIngEirPoolAdmitBwTable.')
mscFrNniCaIngEirPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 675, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAdmitBwValue.setDescription('This variable represents an individual value for the mscFrNniCaIngEirPoolAdmitBwTable.')
mscFrNniCaIngEirPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 676), )
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAvailBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAvailBwTable.setDescription('This attribute indicates the remaining available EIR bandwidth in each ingress EIR bandwidth pool. If the ingressApplyToCos attribute is set to either none or cirOnly, all ingress EIR bandwidth pools are set to 0.')
mscFrNniCaIngEirPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 676, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIngEirPoolAvailBwIndex"))
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAvailBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAvailBwEntry.setDescription('An entry in the mscFrNniCaIngEirPoolAvailBwTable.')
mscFrNniCaIngEirPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 676, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAvailBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAvailBwIndex.setDescription('This variable represents the mscFrNniCaIngEirPoolAvailBwTable specific index for the mscFrNniCaIngEirPoolAvailBwTable.')
mscFrNniCaIngEirPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 676, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAvailBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaIngEirPoolAvailBwValue.setDescription('This variable represents an individual value for the mscFrNniCaIngEirPoolAvailBwTable.')
mscFrNniCaEgEirPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 677), )
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAdmitBwTable.setDescription('This attribute indicates the total admitted EIR bandwidth from each EIR bandwidth pool in the egress direction. Each value is the sum of the equivalent bit rates of the admitted connections. If the egressApplyToCos attribute is set to none, all egress CIR bandwidth pools are set to 0.')
mscFrNniCaEgEirPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 677, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaEgEirPoolAdmitBwIndex"))
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAdmitBwEntry.setDescription('An entry in the mscFrNniCaEgEirPoolAdmitBwTable.')
mscFrNniCaEgEirPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 677, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAdmitBwIndex.setDescription('This variable represents the mscFrNniCaEgEirPoolAdmitBwTable specific index for the mscFrNniCaEgEirPoolAdmitBwTable.')
mscFrNniCaEgEirPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 677, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 520000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAdmitBwValue.setDescription('This variable represents an individual value for the mscFrNniCaEgEirPoolAdmitBwTable.')
mscFrNniCaEgEirPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 678), )
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAvailBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAvailBwTable.setDescription('This attribute indicates the remaining available EIR bandwidth in each egress EIR bandwidth pool. If the egressApplyToCos attribute is set to either none or cirOnly, all egress EIR bandwidth pools are set to 0.')
mscFrNniCaEgEirPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 678, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaEgEirPoolAvailBwIndex"))
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAvailBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAvailBwEntry.setDescription('An entry in the mscFrNniCaEgEirPoolAvailBwTable.')
mscFrNniCaEgEirPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 678, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAvailBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAvailBwIndex.setDescription('This variable represents the mscFrNniCaEgEirPoolAvailBwTable specific index for the mscFrNniCaEgEirPoolAvailBwTable.')
mscFrNniCaEgEirPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 678, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 52000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAvailBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaEgEirPoolAvailBwValue.setDescription('This variable represents an individual value for the mscFrNniCaEgEirPoolAvailBwTable.')
mscFrNniCaTpm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2))
mscFrNniCaTpmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 1), )
if mibBuilder.loadTexts: mscFrNniCaTpmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmRowStatusTable.setDescription('This entry controls the addition and deletion of mscFrNniCaTpm components.')
mscFrNniCaTpmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaTpmIndex"))
if mibBuilder.loadTexts: mscFrNniCaTpmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmRowStatusEntry.setDescription('A single entry in the table represents a single mscFrNniCaTpm component.')
mscFrNniCaTpmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaTpmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscFrNniCaTpm components. These components can be added and deleted.')
mscFrNniCaTpmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaTpmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscFrNniCaTpmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscFrNniCaTpmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmStorageType.setDescription('This variable represents the storage type value for the mscFrNniCaTpm tables.')
mscFrNniCaTpmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscFrNniCaTpmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmIndex.setDescription('This variable represents the index for the mscFrNniCaTpm tables.')
mscFrNniCaTpmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 10), )
if mibBuilder.loadTexts: mscFrNniCaTpmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmProvTable.setDescription('This attribute group contains the provisionable attributes of the Tpm component at this interface.')
mscFrNniCaTpmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaIndex"), (0, "Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", "mscFrNniCaTpmIndex"))
if mibBuilder.loadTexts: mscFrNniCaTpmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmProvEntry.setDescription('An entry in the mscFrNniCaTpmProvTable.')
mscFrNniCaTpmAssignedIngressBandwidthPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16, 16), )).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaTpmAssignedIngressBandwidthPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmAssignedIngressBandwidthPool.setDescription('This attribute specifies the ingress bandwidth pool which is used to support this transfer priority at this interface. When this attribute is set to sameAsModule, the bandwidth pool that is used is obtained from the assignedIngressBandwidthPool attribute under the Mod Frs DprsNet Tpm/n component. VALUES ( 16 = sameAsModule )')
mscFrNniCaTpmAssignedEgressBandwidthPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 70, 101, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16, 16), )).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscFrNniCaTpmAssignedEgressBandwidthPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscFrNniCaTpmAssignedEgressBandwidthPool.setDescription('This attribute specifies the egress bandwidth pool which is used to support this transfer priority at this interface. When this attribute is set to sameAsModule, the bandwidth pool that is used is obtained from the assignedEgressBandwidthPool attribute under the Mod Frs DprsNet Tpm/n component. VALUES ( 16 = sameAsModule )')
frameRelayNniGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23, 1))
frameRelayNniGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23, 1, 1))
frameRelayNniGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23, 1, 1, 3))
frameRelayNniGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23, 1, 1, 3, 2))
frameRelayNniCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23, 3))
frameRelayNniCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23, 3, 1))
frameRelayNniCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23, 3, 1, 3))
frameRelayNniCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 23, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", mscFrNniSig=mscFrNniSig, mscFrNniDnaHgMIndex=mscFrNniDnaHgMIndex, mscFrNniCaIngCirBPTable=mscFrNniCaIngCirBPTable, mscFrNniDlciUsageState=mscFrNniDlciUsageState, mscFrNniFramerLargeFrmErrors=mscFrNniFramerLargeFrmErrors, mscFrNniLtsPatDefaultUseBadLrc=mscFrNniLtsPatDefaultUseBadLrc, mscFrNniDlciVcDuplicatesFromSubnet=mscFrNniDlciVcDuplicatesFromSubnet, mscFrNniDlciDcIndex=mscFrNniDlciDcIndex, mscFrNniDlciRowStatusTable=mscFrNniDlciRowStatusTable, mscFrNniDlciVcSegmentSize=mscFrNniDlciVcSegmentSize, mscFrNniCaIngEirPoolAvailBwEntry=mscFrNniCaIngEirPoolAvailBwEntry, mscFrNniOperStatusEntry=mscFrNniOperStatusEntry, mscFrNniDlciVcPktRetryTimeouts=mscFrNniDlciVcPktRetryTimeouts, mscFrNniCaIngEirBpEntry=mscFrNniCaIngEirBpEntry, mscFrNniDnaIncomingOptionsEntry=mscFrNniDnaIncomingOptionsEntry, mscFrNniFramerNonOctetErrors=mscFrNniFramerNonOctetErrors, mscFrNniDnaRowStatusTable=mscFrNniDnaRowStatusTable, mscFrNniSigIFramesReceived=mscFrNniSigIFramesReceived, mscFrNniCaIngCirPoolAvailBwValue=mscFrNniCaIngCirPoolAvailBwValue, mscFrNniDlciDcDeDiscardPriority=mscFrNniDlciDcDeDiscardPriority, mscFrNniIfIndex=mscFrNniIfIndex, mscFrNniDlciDcStorageType=mscFrNniDlciDcStorageType, mscFrNniSigInCalls=mscFrNniSigInCalls, mscFrNniDlciABitStatusFromIf=mscFrNniDlciABitStatusFromIf, mscFrNni=mscFrNni, mscFrNniDlciRateAdaptationPresent=mscFrNniDlciRateAdaptationPresent, mscFrNniDlciDiscDeCongestedToIfBytes=mscFrNniDlciDiscDeCongestedToIfBytes, mscFrNniDnaAccountClass=mscFrNniDnaAccountClass, mscFrNniDlciCallReferenceNumber=mscFrNniDlciCallReferenceNumber, mscFrNniDlciLbComponentName=mscFrNniDlciLbComponentName, mscFrNniAvailabilityStatus=mscFrNniAvailabilityStatus, mscFrNniFramerRowStatus=mscFrNniFramerRowStatus, mscFrNniLmiIgnoreActiveBit=mscFrNniLmiIgnoreActiveBit, mscFrNniDlciCalldTable=mscFrNniDlciCalldTable, mscFrNniDlciRateAdaptReductPeriod=mscFrNniDlciRateAdaptReductPeriod, mscFrNniCaEgEirPoolAvailBwTable=mscFrNniCaEgEirPoolAvailBwTable, mscFrNniDlciStatsTable=mscFrNniDlciStatsTable, mscFrNniLtsPatOpDataTable=mscFrNniLtsPatOpDataTable, mscFrNniLtsPatDefaultsTable=mscFrNniLtsPatDefaultsTable, mscFrNniDlciSpIndex=mscFrNniDlciSpIndex, mscFrNniDlciSpRateAdaptation=mscFrNniDlciSpRateAdaptation, mscFrNniSigReleaseTimer=mscFrNniSigReleaseTimer, mscFrNniSigStateTable=mscFrNniSigStateTable, mscFrNniSigHighestPermanentDlci=mscFrNniSigHighestPermanentDlci, mscFrNniDlciEirIngressSegFrm=mscFrNniDlciEirIngressSegFrm, mscFrNniDlciTransferPriToNwk=mscFrNniDlciTransferPriToNwk, mscFrNniDlciLbRemoteDeBytes=mscFrNniDlciLbRemoteDeBytes, mscFrNniSigLapfStatusTable=mscFrNniSigLapfStatusTable, mscFrNniLtsPatNumFrames=mscFrNniLtsPatNumFrames, mscFrNniDlciVcPeakRetryQueueSize=mscFrNniDlciVcPeakRetryQueueSize, mscFrNniDlciLbRemoteTotalFrm=mscFrNniDlciLbRemoteTotalFrm, mscFrNniDnaCugDnic=mscFrNniDnaCugDnic, mscFrNniDlciMaximumFrameSize=mscFrNniDlciMaximumFrameSize, mscFrNniDnaCugPreferential=mscFrNniDnaCugPreferential, mscFrNniLtsPatIndex=mscFrNniLtsPatIndex, mscFrNniLmiKeepAliveStatusEnqFromIf=mscFrNniLmiKeepAliveStatusEnqFromIf, mscFrNniFramerUsageState=mscFrNniFramerUsageState, mscFrNniFramerProvTable=mscFrNniFramerProvTable, mscFrNniDlciVcIndex=mscFrNniDlciVcIndex, mscFrNniNumberOfEmissionQs=mscFrNniNumberOfEmissionQs, mscFrNniCaIngEirPoolAdmitBwEntry=mscFrNniCaIngEirPoolAdmitBwEntry, mscFrNniDlciDiscExcessFromIfBytes=mscFrNniDlciDiscExcessFromIfBytes, mscFrNniCaProvEntry=mscFrNniCaProvEntry, mscFrNniSigProvEntry=mscFrNniSigProvEntry, mscFrNniCaEgEirBpIndex=mscFrNniCaEgEirBpIndex, mscFrNniDlciVcFastSelectCall=mscFrNniDlciVcFastSelectCall, mscFrNniSigInCallsRefused=mscFrNniSigInCallsRefused, mscFrNniDlciSp=mscFrNniDlciSp, mscFrNniDnaHgMHgAddrComponentName=mscFrNniDnaHgMHgAddrComponentName, mscFrNniDlciDcDiscardPriority=mscFrNniDlciDcDiscardPriority, mscFrNniCaEgCirBpEntry=mscFrNniCaEgCirBpEntry, mscFrNniDnaOutDefaultPriority=mscFrNniDnaOutDefaultPriority, mscFrNniLtsBytesTx=mscFrNniLtsBytesTx, mscFrNniVFramerRowStatusEntry=mscFrNniVFramerRowStatusEntry, mscFrNniDlciDeFrmToIf=mscFrNniDlciDeFrmToIf, frameRelayNniMIB=frameRelayNniMIB, mscFrNniStandbyStatus=mscFrNniStandbyStatus, mscFrNniLtsLoad=mscFrNniLtsLoad, mscFrNniDlciRateAdaptReduct=mscFrNniDlciRateAdaptReduct, mscFrNniCaEgCirPoolAdmitBwEntry=mscFrNniCaEgCirPoolAdmitBwEntry, mscFrNniCa=mscFrNniCa, mscFrNniOperStatusTable=mscFrNniOperStatusTable, mscFrNniLtsTimeInterval=mscFrNniLtsTimeInterval, mscFrNniFramerStateEntry=mscFrNniFramerStateEntry, mscFrNniDlciEirIngressBytes=mscFrNniDlciEirIngressBytes, mscFrNniLtsPatStatus=mscFrNniLtsPatStatus, mscFrNniSigSvcaccTable=mscFrNniSigSvcaccTable, mscFrNniCustomerIdentifier=mscFrNniCustomerIdentifier, mscFrNniDlciLbRowStatusEntry=mscFrNniDlciLbRowStatusEntry, mscFrNniDnaCallOptionsEntry=mscFrNniDnaCallOptionsEntry, mscFrNniLtsPatLoad=mscFrNniLtsPatLoad, mscFrNniDlciVcCadTable=mscFrNniDlciVcCadTable, mscFrNniDlciVcPreviousDiagnosticCode=mscFrNniDlciVcPreviousDiagnosticCode, mscFrNniCaIngCirPoolAdmitBwValue=mscFrNniCaIngCirPoolAdmitBwValue, mscFrNniDlciCallReference=mscFrNniDlciCallReference, mscFrNniDnaHgMHgAddrRowStatus=mscFrNniDnaHgMHgAddrRowStatus, mscFrNniDlciVcFrdTable=mscFrNniDlciVcFrdTable, mscFrNniLtsPatHeaderLength=mscFrNniLtsPatHeaderLength, mscFrNniControlStatus=mscFrNniControlStatus, mscFrNniDlciEgressSpProvEntry=mscFrNniDlciEgressSpProvEntry, mscFrNniFramerStatsTable=mscFrNniFramerStatsTable, mscFrNniLmiAsyncStatusReport=mscFrNniLmiAsyncStatusReport, mscFrNniDnaAccountCollection=mscFrNniDnaAccountCollection, mscFrNniDlciVcOoSeqByteCntExceeded=mscFrNniDlciVcOoSeqByteCntExceeded, mscFrNniSigSysParmsEntry=mscFrNniSigSysParmsEntry, mscFrNniDlciVcPreviousState=mscFrNniDlciVcPreviousState, mscFrNniDlciSpUpdateBCI=mscFrNniDlciSpUpdateBCI, mscFrNniDlciCommittedBurstSize=mscFrNniDlciCommittedBurstSize, mscFrNniCaIngEirPoolAdmitBwIndex=mscFrNniCaIngEirPoolAdmitBwIndex, mscFrNniProceduralStatus=mscFrNniProceduralStatus, mscFrNniDlciVcSegmentsSent=mscFrNniDlciVcSegmentsSent, mscFrNniCaIngEirBpTable=mscFrNniCaIngEirBpTable, mscFrNniSigLapfStatsEntry=mscFrNniSigLapfStatsEntry, mscFrNniDnaCugIncCalls=mscFrNniDnaCugIncCalls, mscFrNniDlciDcCugIndex=mscFrNniDlciDcCugIndex, mscFrNniDlciEgressSpIndex=mscFrNniDlciEgressSpIndex, mscFrNniDlciBytesFromIf=mscFrNniDlciBytesFromIf, mscFrNniLtsRowStatus=mscFrNniLtsRowStatus, mscFrNniVFramerStateTable=mscFrNniVFramerStateTable, mscFrNniDlciIntEntry=mscFrNniDlciIntEntry, mscFrNniCaComponentName=mscFrNniCaComponentName, mscFrNniDlciCalldEntry=mscFrNniDlciCalldEntry, mscFrNniSigDlciCollisions=mscFrNniSigDlciCollisions, mscFrNniLmiPollingVerifTimeouts=mscFrNniLmiPollingVerifTimeouts, mscFrNniCaEgCirPoolAvailBwValue=mscFrNniCaEgCirPoolAvailBwValue, mscFrNniDlciDcOptionsEntry=mscFrNniDlciDcOptionsEntry, mscFrNniCaEgCirPoolAdmitBwTable=mscFrNniCaEgCirPoolAdmitBwTable, mscFrNniDnaOutgoingOptionsEntry=mscFrNniDnaOutgoingOptionsEntry, mscFrNniDlciTotalEgressBytes=mscFrNniDlciTotalEgressBytes, mscFrNniDlciEgressSpExcessBurstSize=mscFrNniDlciEgressSpExcessBurstSize, mscFrNniVFramerProvTable=mscFrNniVFramerProvTable, mscFrNniDlciSpOpTable=mscFrNniDlciSpOpTable, mscFrNniRowStatusEntry=mscFrNniRowStatusEntry, mscFrNniCaEgEirBpValue=mscFrNniCaEgEirBpValue, mscFrNniDlciVcCallReferenceNumber=mscFrNniDlciVcCallReferenceNumber, mscFrNniDlciVc=mscFrNniDlciVc, mscFrNniFramerStatsEntry=mscFrNniFramerStatsEntry, mscFrNniFramerStorageType=mscFrNniFramerStorageType, mscFrNniLtsPatDataSize=mscFrNniLtsPatDataSize, mscFrNniLmiOpProcedures=mscFrNniLmiOpProcedures, mscFrNniFramerInterfaceName=mscFrNniFramerInterfaceName, mscFrNniDlciTransferPriFromNwk=mscFrNniDlciTransferPriFromNwk, mscFrNniDlciVcStorageType=mscFrNniDlciVcStorageType, mscFrNniDlciControlStatus=mscFrNniDlciControlStatus, mscFrNniVFramerRowStatusTable=mscFrNniVFramerRowStatusTable, mscFrNniFramerRowStatusEntry=mscFrNniFramerRowStatusEntry, mscFrNniSigSetupTimeout=mscFrNniSigSetupTimeout, mscFrNniFramerLinkTable=mscFrNniFramerLinkTable, mscFrNniDlciAdminState=mscFrNniDlciAdminState, mscFrNniVFramerRowStatus=mscFrNniVFramerRowStatus, mscFrNniCaIngEirPoolAvailBwTable=mscFrNniCaIngEirPoolAvailBwTable, mscFrNniDnaCugRowStatus=mscFrNniDnaCugRowStatus, mscFrNniFramerFrmToIf64=mscFrNniFramerFrmToIf64, mscFrNniSigSvcaccEntry=mscFrNniSigSvcaccEntry, mscFrNniDnaCugComponentName=mscFrNniDnaCugComponentName, mscFrNniDlciFecnFrmFromIf=mscFrNniDlciFecnFrmFromIf, frameRelayNniCapabilitiesCA02=frameRelayNniCapabilitiesCA02, mscFrNniFramerOverruns=mscFrNniFramerOverruns, mscFrNniLmiNetworkSideEventHistory=mscFrNniLmiNetworkSideEventHistory, mscFrNniDlciMeasurementInterval=mscFrNniDlciMeasurementInterval, mscFrNniLmiLinkVerificationTimer=mscFrNniLmiLinkVerificationTimer, mscFrNniSigAckTimeout=mscFrNniSigAckTimeout, mscFrNniDlciFrmToIf=mscFrNniDlciFrmToIf, mscFrNniDlciDc=mscFrNniDlciDc, mscFrNniDlciDiscCongestedFromIfBytes=mscFrNniDlciDiscCongestedFromIfBytes, mscFrNniDnaAddressTable=mscFrNniDnaAddressTable, mscFrNniDnaEgressAccounting=mscFrNniDnaEgressAccounting, mscFrNniDnaHgMHgAddrAddrTable=mscFrNniDnaHgMHgAddrAddrTable, mscFrNniFramerLrcErrors=mscFrNniFramerLrcErrors, mscFrNniLmiRowStatusTable=mscFrNniLmiRowStatusTable, mscFrNniDlciSpComponentName=mscFrNniDlciSpComponentName, mscFrNniSigBandwidthNotAvailableEntry=mscFrNniSigBandwidthNotAvailableEntry, mscFrNniCaIngCirBPEntry=mscFrNniCaIngCirBPEntry, mscFrNniLtsGeneratorState=mscFrNniLtsGeneratorState, mscFrNniDlciVcRowStatusEntry=mscFrNniDlciVcRowStatusEntry, mscFrNniSigQualityOfServiceNotAvailable=mscFrNniSigQualityOfServiceNotAvailable, mscFrNniLtsPatSetupEntry=mscFrNniLtsPatSetupEntry, mscFrNniFramerRowStatusTable=mscFrNniFramerRowStatusTable, mscFrNniSigLapfSysEntry=mscFrNniSigLapfSysEntry, mscFrNniDlciSpCommittedBurstSize=mscFrNniDlciSpCommittedBurstSize, mscFrNniDlciVcCombErrorsFromSubnet=mscFrNniDlciVcCombErrorsFromSubnet, mscFrNniSigCurrentQueueSize=mscFrNniSigCurrentQueueSize, mscFrNniDnaHgMAvailabilityDelta=mscFrNniDnaHgMAvailabilityDelta, mscFrNniSigStateChange=mscFrNniSigStateChange, mscFrNniSigReceiveRejectFrame=mscFrNniSigReceiveRejectFrame, mscFrNniLtsPatEaBits=mscFrNniLtsPatEaBits, mscFrNniCaTpmIndex=mscFrNniCaTpmIndex, mscFrNniDlciSpStorageType=mscFrNniDlciSpStorageType, mscFrNniOctetToIfByQueueEntry=mscFrNniOctetToIfByQueueEntry, mscFrNniDlciLbStatsEntry=mscFrNniDlciLbStatsEntry, mscFrNniCaEgCirBpTable=mscFrNniCaEgCirBpTable, mscFrNniDlciVcPeakOoSeqPktCount=mscFrNniDlciVcPeakOoSeqPktCount, mscFrNniLtsPat=mscFrNniLtsPat, mscFrNniDlciLbLocalBecnFrm=mscFrNniDlciLbLocalBecnFrm, mscFrNniLtsPatComponentName=mscFrNniLtsPatComponentName, mscFrNniDnaHgMHgAddrDataNetworkAddress=mscFrNniDnaHgMHgAddrDataNetworkAddress, mscFrNniDlciVcSegmentsRx=mscFrNniDlciVcSegmentsRx, mscFrNniCaEgCirPoolAvailBwTable=mscFrNniCaEgCirPoolAvailBwTable, mscFrNniLmiComponentName=mscFrNniLmiComponentName, mscFrNniFramerAborts=mscFrNniFramerAborts, mscFrNniDlciUnknownStatus=mscFrNniDlciUnknownStatus, mscFrNniCaIngCirPoolAdmitBwIndex=mscFrNniCaIngCirPoolAdmitBwIndex, mscFrNniSigLastStateReceivedStatus=mscFrNniSigLastStateReceivedStatus, mscFrNniDlciFrmFromIf=mscFrNniDlciFrmFromIf, mscFrNniDlciLbRemoteBecnFrm=mscFrNniDlciLbRemoteBecnFrm, mscFrNniStatsTable=mscFrNniStatsTable, mscFrNniDlciDiscCongestedToIfBytes=mscFrNniDlciDiscCongestedToIfBytes, mscFrNniLmiPsiEntry=mscFrNniLmiPsiEntry, mscFrNniLtsPatDefaultNumFrames=mscFrNniLtsPatDefaultNumFrames, mscFrNniDlciSpExcessBurstSize=mscFrNniDlciSpExcessBurstSize, mscFrNniCaEgCirBpIndex=mscFrNniCaEgCirBpIndex, mscFrNniDlciFciFromSubnet=mscFrNniDlciFciFromSubnet, mscFrNniVFramerIndex=mscFrNniVFramerIndex, mscFrNniDlciDiscByteAbit=mscFrNniDlciDiscByteAbit, mscFrNniSigStorageType=mscFrNniSigStorageType, mscFrNniLmiRowStatusEntry=mscFrNniLmiRowStatusEntry, mscFrNniFrmToIfByQueueEntry=mscFrNniFrmToIfByQueueEntry, mscFrNniLmiStateEntry=mscFrNniLmiStateEntry, mscFrNniDlciDcRemoteNpi=mscFrNniDlciDcRemoteNpi, mscFrNniLmiStorageType=mscFrNniLmiStorageType, mscFrNniDlciVcAccountingEnd=mscFrNniDlciVcAccountingEnd, mscFrNniDnaCugCugOptionsTable=mscFrNniDnaCugCugOptionsTable, mscFrNniDnaOutAccess=mscFrNniDnaOutAccess, mscFrNniLmiParmsTable=mscFrNniLmiParmsTable, mscFrNniDlciVcOoSeqPktCntExceeded=mscFrNniDlciVcOoSeqPktCntExceeded, mscFrNniDlciStateTable=mscFrNniDlciStateTable, mscFrNniUnknownStatus=mscFrNniUnknownStatus, mscFrNniVFramerOperationalState=mscFrNniVFramerOperationalState, mscFrNniDlciTotalIngressSegFrm=mscFrNniDlciTotalIngressSegFrm, mscFrNniDlciErrorShortBytesFromIf=mscFrNniDlciErrorShortBytesFromIf, mscFrNniCaIngEirBpValue=mscFrNniCaIngEirBpValue, mscFrNniDlciElapsedDifference=mscFrNniDlciElapsedDifference, mscFrNniVFramerStorageType=mscFrNniVFramerStorageType, mscFrNniSigRateEnforcement=mscFrNniSigRateEnforcement, mscFrNniAlarmStatus=mscFrNniAlarmStatus, mscFrNniDlciComponentName=mscFrNniDlciComponentName, mscFrNniOctetToIfByQueueTable=mscFrNniOctetToIfByQueueTable, mscFrNniDlciEgressSpCommittedBurstSize=mscFrNniDlciEgressSpCommittedBurstSize, mscFrNniLmiPsiTable=mscFrNniLmiPsiTable, mscFrNniDnaDataPath=mscFrNniDnaDataPath, mscFrNniSigOperationalState=mscFrNniSigOperationalState, mscFrNniLtsPatStorageType=mscFrNniLtsPatStorageType, mscFrNniDnaHgMIfTable=mscFrNniDnaHgMIfTable, mscFrNniDlciExcessFrmFromIf=mscFrNniDlciExcessFrmFromIf, mscFrNniDnaHgMHgAddrNumberingPlanIndicator=mscFrNniDnaHgMHgAddrNumberingPlanIndicator, mscFrNniSigRemoteBusy=mscFrNniSigRemoteBusy, mscFrNniDnaCugOutCalls=mscFrNniDnaCugOutCalls, mscFrNniLtsPatHdlcBitsInserted=mscFrNniLtsPatHdlcBitsInserted, mscFrNniLtsPatDlci=mscFrNniLtsPatDlci, mscFrNniFramerCrcErrors=mscFrNniFramerCrcErrors, mscFrNniDlciVcDiagnosticCode=mscFrNniDlciVcDiagnosticCode, mscFrNniDlciVcFrdEntry=mscFrNniDlciVcFrdEntry, mscFrNniLmiNoStatusReportCount=mscFrNniLmiNoStatusReportCount, mscFrNniDnaAddressEntry=mscFrNniDnaAddressEntry)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", mscFrNniDnaHgMHgAddr=mscFrNniDnaHgMHgAddr, frameRelayNniCapabilitiesCA=frameRelayNniCapabilitiesCA, mscFrNniDlciDcNfaRowStatus=mscFrNniDlciDcNfaRowStatus, mscFrNniDlciIntTable=mscFrNniDlciIntTable, mscFrNniSigUsageState=mscFrNniSigUsageState, mscFrNniCaNumberRejectedEgressCirPermConn=mscFrNniCaNumberRejectedEgressCirPermConn, mscFrNniDlciVcPriority=mscFrNniDlciVcPriority, mscFrNniCaIngCirPoolAvailBwEntry=mscFrNniCaIngCirPoolAvailBwEntry, mscFrNniCaNumberRejectedEgressEirPermConn=mscFrNniCaNumberRejectedEgressEirPermConn, mscFrNniDlciSpParmsEntry=mscFrNniDlciSpParmsEntry, mscFrNniLmiStateTable=mscFrNniLmiStateTable, mscFrNniCaIngressMaximumEirOnlyCalls=mscFrNniCaIngressMaximumEirOnlyCalls, mscFrNniLmiProtocolErrors=mscFrNniLmiProtocolErrors, mscFrNniDlciVcSendSequenceNumber=mscFrNniDlciVcSendSequenceNumber, mscFrNniCaIngressCacEntry=mscFrNniCaIngressCacEntry, mscFrNniSigRateAdaptation=mscFrNniSigRateAdaptation, mscFrNniDlciVcCalledDna=mscFrNniDlciVcCalledDna, mscFrNniFramerUtilTable=mscFrNniFramerUtilTable, mscFrNniDlciSpRaSensitivity=mscFrNniDlciSpRaSensitivity, mscFrNniSigStateEntry=mscFrNniSigStateEntry, mscFrNniDlciLbStatsTable=mscFrNniDlciLbStatsTable, mscFrNniDlciVcDmepValue=mscFrNniDlciVcDmepValue, mscFrNniDlciLbLocalTotalFrm=mscFrNniDlciLbLocalTotalFrm, mscFrNniCidDataTable=mscFrNniCidDataTable, mscFrNniLtsPatDefaultDlci=mscFrNniLtsPatDefaultDlci, mscFrNniDlciTotalEgressSegFrm=mscFrNniDlciTotalEgressSegFrm, mscFrNniCaEgCirPoolAdmitBwIndex=mscFrNniCaEgCirPoolAdmitBwIndex, mscFrNniDlciEirPresent=mscFrNniDlciEirPresent, mscFrNniDnaServiceExchange=mscFrNniDnaServiceExchange, mscFrNniLmiNniParmsTable=mscFrNniLmiNniParmsTable, mscFrNniDlciRateEnforcementPresent=mscFrNniDlciRateEnforcementPresent, frameRelayNniGroupCA02A=frameRelayNniGroupCA02A, mscFrNniLmiFullStatusEnqFromIf=mscFrNniLmiFullStatusEnqFromIf, mscFrNniDlciLbLocalTotalBytes=mscFrNniDlciLbLocalTotalBytes, mscFrNniSigLapfStatsTable=mscFrNniSigLapfStatsTable, mscFrNniLmiRowStatus=mscFrNniLmiRowStatus, mscFrNniLtsPatDefaultEABits=mscFrNniLtsPatDefaultEABits, mscFrNniDnaRowStatusEntry=mscFrNniDnaRowStatusEntry, mscFrNniLtsPatOpStateEntry=mscFrNniLtsPatOpStateEntry, mscFrNniStateTable=mscFrNniStateTable, mscFrNniDlciDcRemoteDna=mscFrNniDlciDcRemoteDna, mscFrNniDlciVcFrmCongestedToSubnet=mscFrNniDlciVcFrmCongestedToSubnet, mscFrNniDlciVcSubnetRecoveries=mscFrNniDlciVcSubnetRecoveries, mscFrNniCaIngressCacTable=mscFrNniCaIngressCacTable, mscFrNniCaTpmAssignedIngressBandwidthPool=mscFrNniCaTpmAssignedIngressBandwidthPool, mscFrNniFramerLinkEntry=mscFrNniFramerLinkEntry, mscFrNniCaEgEirPoolAvailBwIndex=mscFrNniCaEgEirPoolAvailBwIndex, mscFrNniDlciSpRateEnforcement=mscFrNniDlciSpRateEnforcement, mscFrNniDlciEgressSpCommittedInformationRate=mscFrNniDlciEgressSpCommittedInformationRate, mscFrNniDlciVcNotDataXferFromSubnet=mscFrNniDlciVcNotDataXferFromSubnet, mscFrNniLtsStateEntry=mscFrNniLtsStateEntry, mscFrNniDlciProceduralStatus=mscFrNniDlciProceduralStatus, mscFrNniLtsSetupTable=mscFrNniLtsSetupTable, mscFrNniSigFrmrReceive=mscFrNniSigFrmrReceive, mscFrNniDlciCirPresent=mscFrNniDlciCirPresent, mscFrNniVFramerFrmToOtherVFramer=mscFrNniVFramerFrmToOtherVFramer, mscFrNniDlciEgressSp=mscFrNniDlciEgressSp, mscFrNniCaTpmRowStatusTable=mscFrNniCaTpmRowStatusTable, mscFrNniDlciSpRowStatusEntry=mscFrNniDlciSpRowStatusEntry, mscFrNniLmiNniParmsEntry=mscFrNniLmiNniParmsEntry, mscFrNniLtsBurstSize=mscFrNniLtsBurstSize, mscFrNniDnaDataNetworkAddress=mscFrNniDnaDataNetworkAddress, mscFrNniDnaCugCugOptionsEntry=mscFrNniDnaCugCugOptionsEntry, mscFrNniDnaStorageType=mscFrNniDnaStorageType, mscFrNniLtsPatOpDataEntry=mscFrNniLtsPatOpDataEntry, mscFrNniDlciVcOutOfRangeFrmFromSubnet=mscFrNniDlciVcOutOfRangeFrmFromSubnet, mscFrNniLmiFullStatusPollingCycles=mscFrNniLmiFullStatusPollingCycles, mscFrNniDlciRateEnforcement=mscFrNniDlciRateEnforcement, mscFrNniDlciTotalIngressBytes=mscFrNniDlciTotalIngressBytes, mscFrNniDlciEgressSpStorageType=mscFrNniDlciEgressSpStorageType, mscFrNniSigCallProceedingTimer=mscFrNniSigCallProceedingTimer, mscFrNniLtsComponentName=mscFrNniLtsComponentName, mscFrNniDnaHgMHgAddrStorageType=mscFrNniDnaHgMHgAddrStorageType, mscFrNniDlciBecnFrmFromIf=mscFrNniDlciBecnFrmFromIf, mscFrNniCaIndex=mscFrNniCaIndex, mscFrNniDlciDiscFrameAbit=mscFrNniDlciDiscFrameAbit, mscFrNniLmiProcedures=mscFrNniLmiProcedures, mscFrNniDlciLbLocalDeFrm=mscFrNniDlciLbLocalDeFrm, mscFrNniDnaOutgoingOptionsTable=mscFrNniDnaOutgoingOptionsTable, mscFrNniDlciVcCadEntry=mscFrNniDlciVcCadEntry, frameRelayNniCapabilitiesCA02A=frameRelayNniCapabilitiesCA02A, mscFrNniCaIngCirBPIndex=mscFrNniCaIngCirBPIndex, mscFrNniFramerFrmToIf=mscFrNniFramerFrmToIf, mscFrNniDnaHgMRowStatusEntry=mscFrNniDnaHgMRowStatusEntry, mscFrNniLtsPatPayloadPattern=mscFrNniLtsPatPayloadPattern, mscFrNniSigRestartReqTimer=mscFrNniSigRestartReqTimer, mscFrNniDlciVcEmissionPriorityFromNetwork=mscFrNniDlciVcEmissionPriorityFromNetwork, mscFrNniSigLastClearCause=mscFrNniSigLastClearCause, mscFrNniDlciEgressSpRowStatusEntry=mscFrNniDlciEgressSpRowStatusEntry, mscFrNniLtsPatDefaultDataSize=mscFrNniLtsPatDefaultDataSize, mscFrNniDlciCallType=mscFrNniDlciCallType, mscFrNniCaEgressCacEntry=mscFrNniCaEgressCacEntry, mscFrNniDnaHgMRowStatusTable=mscFrNniDnaHgMRowStatusTable, mscFrNniSigCurrentState=mscFrNniSigCurrentState, mscFrNniSigIFramesTxDiscarded=mscFrNniSigIFramesTxDiscarded, mscFrNniCaEgEirPoolAdmitBwIndex=mscFrNniCaEgEirPoolAdmitBwIndex, mscFrNniSigMaximumFrameSize=mscFrNniSigMaximumFrameSize, mscFrNniSigLastStateInStatusMsgReceived=mscFrNniSigLastStateInStatusMsgReceived, mscFrNniDnaIncAccess=mscFrNniDnaIncAccess, mscFrNniSigCodesTable=mscFrNniSigCodesTable, mscFrNniDlciCirPresentObs=mscFrNniDlciCirPresentObs, mscFrNniDlciSpMaximumFrameSize=mscFrNniDlciSpMaximumFrameSize, mscFrNniLmiEventCount=mscFrNniLmiEventCount, mscFrNniIfEntryTable=mscFrNniIfEntryTable, mscFrNniDnaHgMComponentName=mscFrNniDnaHgMComponentName, mscFrNniDlciDiscardedBytes=mscFrNniDlciDiscardedBytes, mscFrNniSigRowStatus=mscFrNniSigRowStatus, mscFrNniFramerUnderruns=mscFrNniFramerUnderruns, mscFrNniDnaCugInterlockCode=mscFrNniDnaCugInterlockCode, mscFrNniDlciSpAccounting=mscFrNniDlciSpAccounting, mscFrNniCaEgEirBpTable=mscFrNniCaEgEirBpTable, mscFrNniFramerNormPrioLinkUtilFromIf=mscFrNniFramerNormPrioLinkUtilFromIf, mscFrNniDlciDiscCongestedFromIf=mscFrNniDlciDiscCongestedFromIf, mscFrNniDlciBciToSubnet=mscFrNniDlciBciToSubnet, mscFrNniDlciDeBytesToIf=mscFrNniDlciDeBytesToIf, mscFrNniDnaCugIndex=mscFrNniDnaCugIndex, mscFrNniDnaCugType=mscFrNniDnaCugType, mscFrNniSigLastCauseInStatusMsgReceived=mscFrNniSigLastCauseInStatusMsgReceived, mscFrNniSigRowStatusTable=mscFrNniSigRowStatusTable, mscFrNniLtsPatUseBadLrc=mscFrNniLtsPatUseBadLrc, mscFrNniLmiUsageState=mscFrNniLmiUsageState, mscFrNniDlciEirEgressSegFrm=mscFrNniDlciEirEgressSegFrm, mscFrNniDlciDcRemoteDlci=mscFrNniDlciDcRemoteDlci, mscFrNniDlciVcCallReferenceNumberDecimal=mscFrNniDlciVcCallReferenceNumberDecimal, mscFrNniSigRaSensitivity=mscFrNniSigRaSensitivity, mscFrNniDlciExcessBytesFromIf=mscFrNniDlciExcessBytesFromIf, mscFrNniSigRestartRcvTimer=mscFrNniSigRestartRcvTimer, mscFrNniSigOutCallsFailed=mscFrNniSigOutCallsFailed, mscFrNniCaEgCirBpValue=mscFrNniCaEgCirBpValue, mscFrNniDlciTransferPriorityToNetwork=mscFrNniDlciTransferPriorityToNetwork, mscFrNniFramerNormPrioLinkUtilToIf=mscFrNniFramerNormPrioLinkUtilToIf, mscFrNniLmi=mscFrNniLmi, mscFrNniIndex=mscFrNniIndex, mscFrNniComponentName=mscFrNniComponentName, mscFrNniDlciTransferPriorityFromNetwork=mscFrNniDlciTransferPriorityFromNetwork, mscFrNniSigOutCalls=mscFrNniSigOutCalls, mscFrNniLtsLastActiveInterval=mscFrNniLtsLastActiveInterval, mscFrNniLmiFullStatusToIf=mscFrNniLmiFullStatusToIf, mscFrNniDlciVcNotDataXferToSubnet=mscFrNniDlciVcNotDataXferToSubnet, mscFrNniDlciVcElapsedTimeTillNow=mscFrNniDlciVcElapsedTimeTillNow, mscFrNniDlciEgressSpProvTable=mscFrNniDlciEgressSpProvTable, mscFrNniSigIFramesRcvdDiscarded=mscFrNniSigIFramesRcvdDiscarded, mscFrNniCaOpEntry=mscFrNniCaOpEntry, mscFrNniDlciSpParmsTable=mscFrNniDlciSpParmsTable, mscFrNniVFramerOctetFromOtherVFramer=mscFrNniVFramerOctetFromOtherVFramer, mscFrNniLtsDuration=mscFrNniLtsDuration, mscFrNniVFramerProvEntry=mscFrNniVFramerProvEntry, mscFrNniCaEgCirPoolAvailBwEntry=mscFrNniCaEgCirPoolAvailBwEntry, mscFrNniIfEntryEntry=mscFrNniIfEntryEntry, mscFrNniSigLastDiagnosticCode=mscFrNniSigLastDiagnosticCode, mscFrNniSigStatsEntry=mscFrNniSigStatsEntry, mscFrNniDlciLbStorageType=mscFrNniDlciLbStorageType, mscFrNniDlciVcCannotForwardToSubnet=mscFrNniDlciVcCannotForwardToSubnet, mscFrNniLtsPatDefaultHeaderLength=mscFrNniLtsPatDefaultHeaderLength, mscFrNniDlciVcRcosToNetwork=mscFrNniDlciVcRcosToNetwork, mscFrNniDlciLbRowStatusTable=mscFrNniDlciLbRowStatusTable, mscFrNniLtsStorageType=mscFrNniLtsStorageType, mscFrNniStatsEntry=mscFrNniStatsEntry, mscFrNniUnknownDlciFramesFromIf=mscFrNniUnknownDlciFramesFromIf, mscFrNniDnaIndex=mscFrNniDnaIndex, mscFrNniDlciRowStatusEntry=mscFrNniDlciRowStatusEntry, mscFrNniDlciEgressSpRowStatus=mscFrNniDlciEgressSpRowStatus, mscFrNniDlciErrorLongBytesFromIf=mscFrNniDlciErrorLongBytesFromIf, mscFrNniDlci=mscFrNniDlci, mscFrNniDlciSpRowStatus=mscFrNniDlciSpRowStatus, mscFrNniDlciLb=mscFrNniDlciLb, mscFrNniDlciVcRowStatus=mscFrNniDlciVcRowStatus, mscFrNniCaTpmStorageType=mscFrNniCaTpmStorageType, mscFrNniLtsPatDefaultHeaderBits=mscFrNniLtsPatDefaultHeaderBits, mscFrNniDlciVcIntdTable=mscFrNniDlciVcIntdTable, mscFrNniStorageType=mscFrNniStorageType, mscFrNniFramerProvEntry=mscFrNniFramerProvEntry, mscFrNniSigDefaultAccounting=mscFrNniSigDefaultAccounting, mscFrNniVFramerAdminState=mscFrNniVFramerAdminState, mscFrNniDlciVcDmepEntry=mscFrNniDlciVcDmepEntry, mscFrNniDlciVcPeakOoSeqByteCount=mscFrNniDlciVcPeakOoSeqByteCount, mscFrNniFrmToIfByQueueValue=mscFrNniFrmToIfByQueueValue, mscFrNniCaEgressMaximumEirOnlyCalls=mscFrNniCaEgressMaximumEirOnlyCalls, mscFrNniSigLastClearRemoteDataNetworkAddress=mscFrNniSigLastClearRemoteDataNetworkAddress, mscFrNniCaIngEirPoolAvailBwValue=mscFrNniCaIngEirPoolAvailBwValue, mscFrNniCaIngEirPoolAdmitBwValue=mscFrNniCaIngEirPoolAdmitBwValue, mscFrNniDnaHgMRowStatus=mscFrNniDnaHgMRowStatus, mscFrNniDlciDiscCongestedToIf=mscFrNniDlciDiscCongestedToIf, mscFrNniLtsPatFramePattern=mscFrNniLtsPatFramePattern, mscFrNniDlciVcEmissionPriorityToNetwork=mscFrNniDlciVcEmissionPriorityToNetwork, mscFrNniDnaComponentName=mscFrNniDnaComponentName, mscFrNniSigHighestPvcDlci=mscFrNniSigHighestPvcDlci, mscFrNniDlciVcPeakOoSeqFrmForwarded=mscFrNniDlciVcPeakOoSeqFrmForwarded, mscFrNniCaProvTable=mscFrNniCaProvTable, mscFrNniCaOverrideLinkRate=mscFrNniCaOverrideLinkRate, mscFrNniSigComponentName=mscFrNniSigComponentName, mscFrNniVFramer=mscFrNniVFramer, mscFrNniCaEgEirPoolAvailBwValue=mscFrNniCaEgEirPoolAvailBwValue, mscFrNniFramerDataInversion=mscFrNniFramerDataInversion, mscFrNniFrmToIfByQueueTable=mscFrNniFrmToIfByQueueTable, mscFrNniLtsPatRowStatus=mscFrNniLtsPatRowStatus, mscFrNniRowStatusTable=mscFrNniRowStatusTable, mscFrNniDlciExcessBurstSize=mscFrNniDlciExcessBurstSize, mscFrNniIfAdminStatus=mscFrNniIfAdminStatus, mscFrNniDnaHgMOpEntry=mscFrNniDnaHgMOpEntry, mscFrNniDlciLbRowStatus=mscFrNniDlciLbRowStatus, mscFrNniLtsResultsTable=mscFrNniLtsResultsTable, mscFrNniLtsPatRfc1490Header=mscFrNniLtsPatRfc1490Header, mscFrNniDlciDcCugType=mscFrNniDlciDcCugType, mscFrNniSigBandwidthNotAvailableIndex=mscFrNniSigBandwidthNotAvailableIndex, mscFrNniUsageState=mscFrNniUsageState, mscFrNniDlciAvailabilityStatus=mscFrNniDlciAvailabilityStatus, mscFrNniLmiStatusSequenceErrors=mscFrNniLmiStatusSequenceErrors, mscFrNniEmissionPriorityQsEntry=mscFrNniEmissionPriorityQsEntry, mscFrNniDlciDiscExcessFromIf=mscFrNniDlciDiscExcessFromIf, mscFrNniSigSysParmsTable=mscFrNniSigSysParmsTable, mscFrNniLastUnknownDlci=mscFrNniLastUnknownDlci, mscFrNniFrmToIfByQueueIndex=mscFrNniFrmToIfByQueueIndex, mscFrNniDlciDcRowStatus=mscFrNniDlciDcRowStatus, mscFrNniFramerFrameCrcType=mscFrNniFramerFrameCrcType, mscFrNniCaEgressApplyToCos=mscFrNniCaEgressApplyToCos, mscFrNniDlciLbRemoteDeFrm=mscFrNniDlciLbRemoteDeFrm, mscFrNniLtsPatDefaultPayloadPattern=mscFrNniLtsPatDefaultPayloadPattern, mscFrNniDnaOutDefaultPathSensitivity=mscFrNniDnaOutDefaultPathSensitivity, mscFrNniDlciDcOptionsTable=mscFrNniDlciDcOptionsTable, mscFrNniLtsElapsedGenerationTime=mscFrNniLtsElapsedGenerationTime, mscFrNniVFramerUsageState=mscFrNniVFramerUsageState, mscFrNniCaEgEirBpEntry=mscFrNniCaEgEirBpEntry, mscFrNniDlciSpRowStatusTable=mscFrNniDlciSpRowStatusTable, mscFrNniLmiStatsTable=mscFrNniLmiStatsTable, mscFrNniDlciDeBytesFromIf=mscFrNniDlciDeBytesFromIf, mscFrNniVFramerStatsTable=mscFrNniVFramerStatsTable, mscFrNniLtsResultsEntry=mscFrNniLtsResultsEntry, mscFrNniCaEgEirPoolAvailBwEntry=mscFrNniCaEgEirPoolAvailBwEntry, mscFrNniSigNetworkType=mscFrNniSigNetworkType, mscFrNniDlciDcRowStatusTable=mscFrNniDlciDcRowStatusTable, mscFrNniSigDlciAllocation=mscFrNniSigDlciAllocation, mscFrNniDlciFecnFrmToIf=mscFrNniDlciFecnFrmToIf, mscFrNniLtsPatDefaultsEntry=mscFrNniLtsPatDefaultsEntry, mscFrNniDlciErrorShortFrmFromIf=mscFrNniDlciErrorShortFrmFromIf, mscFrNniLmiSequenceErrors=mscFrNniLmiSequenceErrors, mscFrNniDlciVcRcosFromNetwork=mscFrNniDlciVcRcosFromNetwork, mscFrNniDlciVcDmepTable=mscFrNniDlciVcDmepTable, mscFrNniDlciDiscardedSegFrm=mscFrNniDlciDiscardedSegFrm, mscFrNniCaEgEirPoolAdmitBwTable=mscFrNniCaEgEirPoolAdmitBwTable, mscFrNniCaOpTable=mscFrNniCaOpTable, mscFrNniDnaHgMMaximumAvailableAggregateCir64=mscFrNniDnaHgMMaximumAvailableAggregateCir64, mscFrNniDnaCugRowStatusTable=mscFrNniDnaCugRowStatusTable, mscFrNniSigRowStatusEntry=mscFrNniSigRowStatusEntry, mscFrNniDlciVcAccountingEnabled=mscFrNniDlciVcAccountingEnabled, mscFrNniSigRetransmitLimit=mscFrNniSigRetransmitLimit, mscFrNniDlciDcMapIpCosToFrQos=mscFrNniDlciDcMapIpCosToFrQos, mscFrNniLtsSetupEntry=mscFrNniLtsSetupEntry, mscFrNniDlciDcComponentName=mscFrNniDlciDcComponentName, mscFrNniCaLinkRate=mscFrNniCaLinkRate, mscFrNniSigStatsTable=mscFrNniSigStatsTable, mscFrNniDlciSpMeasurementInterval=mscFrNniDlciSpMeasurementInterval, mscFrNniFramerFrmFromIf=mscFrNniFramerFrmFromIf, mscFrNniSigIndex=mscFrNniSigIndex)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-FrameRelayNniMIB", mscFrNniDlciABitReasonToIf=mscFrNniDlciABitReasonToIf, mscFrNniDlciCallRefNumber=mscFrNniDlciCallRefNumber, mscFrNniLmiProtocolStatus=mscFrNniLmiProtocolStatus, mscFrNniDlciCommittedInformationRate=mscFrNniDlciCommittedInformationRate, mscFrNniLtsAlgorithm=mscFrNniLtsAlgorithm, mscFrNniLmiCheckPointTimer=mscFrNniLmiCheckPointTimer, mscFrNniLtsPatSetupTable=mscFrNniLtsPatSetupTable, mscFrNniSigBandwidthNotAvailableValue=mscFrNniSigBandwidthNotAvailableValue, mscFrNniDlciABitStatusToIf=mscFrNniDlciABitStatusToIf, mscFrNniDnaHgMAvailableAggregateCir64=mscFrNniDnaHgMAvailableAggregateCir64, mscFrNniDnaOutDefaultPathReliability=mscFrNniDnaOutDefaultPathReliability, mscFrNniVFramerComponentName=mscFrNniVFramerComponentName, mscFrNniDlciIndex=mscFrNniDlciIndex, mscFrNniDlciLbRemoteFecnFrm=mscFrNniDlciLbRemoteFecnFrm, mscFrNniLmiKeepAliveStatusToIf=mscFrNniLmiKeepAliveStatusToIf, mscFrNniCaMaximumBandwidthPerCall=mscFrNniCaMaximumBandwidthPerCall, mscFrNniCaTpmComponentName=mscFrNniCaTpmComponentName, mscFrNniCaTpmRowStatusEntry=mscFrNniCaTpmRowStatusEntry, mscFrNniDlciABitReasonFromIf=mscFrNniDlciABitReasonFromIf, mscFrNniDnaHgMAvailabilityUpdateThreshold=mscFrNniDnaHgMAvailabilityUpdateThreshold, mscFrNniDlciSpOpEntry=mscFrNniDlciSpOpEntry, mscFrNniCaRowStatusEntry=mscFrNniCaRowStatusEntry, mscFrNniCaIngressApplyToCos=mscFrNniCaIngressApplyToCos, mscFrNniDlciBytesToIf=mscFrNniDlciBytesToIf, mscFrNniSigWindowSize=mscFrNniSigWindowSize, mscFrNniDnaHgMHgAddrAddrEntry=mscFrNniDnaHgMHgAddrAddrEntry, mscFrNniDnaHgMMaximumAvailableAggregateCir=mscFrNniDnaHgMMaximumAvailableAggregateCir, mscFrNniDnaCugRowStatusEntry=mscFrNniDnaCugRowStatusEntry, mscFrNniDnaHgMAvailableAggregateCir=mscFrNniDnaHgMAvailableAggregateCir, mscFrNniSigIdleProbeTimer=mscFrNniSigIdleProbeTimer, mscFrNniDlciDcNfaTable=mscFrNniDlciDcNfaTable, mscFrNniLmiIndex=mscFrNniLmiIndex, mscFrNniCaEgCirPoolAvailBwIndex=mscFrNniCaEgCirPoolAvailBwIndex, mscFrNniLmiErrorEventThreshold=mscFrNniLmiErrorEventThreshold, mscFrNniDlciLbRemoteTotalBytes=mscFrNniDlciLbRemoteTotalBytes, mscFrNniLtsFrameRateTx=mscFrNniLtsFrameRateTx, mscFrNniLtsPatHeaderBits=mscFrNniLtsPatHeaderBits, mscFrNniOperationalState=mscFrNniOperationalState, mscFrNniLts=mscFrNniLts, mscFrNniFramerFrmFromIf64=mscFrNniFramerFrmFromIf64, mscFrNniDlciLbLocalDeBytes=mscFrNniDlciLbLocalDeBytes, mscFrNniFramerOctetFromIf=mscFrNniFramerOctetFromIf, mscFrNniLtsCycleIncomplete=mscFrNniLtsCycleIncomplete, mscFrNniDlciBciFromSubnet=mscFrNniDlciBciFromSubnet, mscFrNniCaEgEirPoolAdmitBwEntry=mscFrNniCaEgEirPoolAdmitBwEntry, mscFrNniCidDataEntry=mscFrNniCidDataEntry, mscFrNniDlciAlarmStatus=mscFrNniDlciAlarmStatus, mscFrNniSigLastStateChangeReason=mscFrNniSigLastStateChangeReason, mscFrNniDlciDcType=mscFrNniDlciDcType, mscFrNniSigUpdateBCI=mscFrNniSigUpdateBCI, mscFrNniDlciVcComponentName=mscFrNniDlciVcComponentName, mscFrNniLtsRowStatusTable=mscFrNniLtsRowStatusTable, mscFrNniDlciDcDataPath=mscFrNniDlciDcDataPath, mscFrNniLmiUnexpectedIes=mscFrNniLmiUnexpectedIes, mscFrNniLtsPatDefaultRfc1490Header=mscFrNniLtsPatDefaultRfc1490Header, mscFrNniLmiStatsEntry=mscFrNniLmiStatsEntry, mscFrNniSigStatusEnqTimer=mscFrNniSigStatusEnqTimer, mscFrNniCaTpmRowStatus=mscFrNniCaTpmRowStatus, mscFrNniDlciStandbyStatus=mscFrNniDlciStandbyStatus, mscFrNniSigCodesEntry=mscFrNniSigCodesEntry, mscFrNniCaTpm=mscFrNniCaTpm, mscFrNniDlciBecnFrmToIf=mscFrNniDlciBecnFrmToIf, mscFrNniDlciEgressSpMeasurementInterval=mscFrNniDlciEgressSpMeasurementInterval, mscFrNniLtsPatRowStatusTable=mscFrNniLtsPatRowStatusTable, mscFrNniDnaIncomingOptionsTable=mscFrNniDnaIncomingOptionsTable, mscFrNniFramerFrmModeErrors=mscFrNniFramerFrmModeErrors, mscFrNniSigLastDlciReceivedStatus=mscFrNniSigLastDlciReceivedStatus, mscFrNniDna=mscFrNniDna, mscFrNniDnaHgMIfEntry=mscFrNniDnaHgMIfEntry, mscFrNniFramerUtilEntry=mscFrNniFramerUtilEntry, mscFrNniDlciStartTime=mscFrNniDlciStartTime, mscFrNniDlciDiscDeCongestedFromIf=mscFrNniDlciDiscDeCongestedFromIf, mscFrNniDlciEmissionPriorityToIf=mscFrNniDlciEmissionPriorityToIf, mscFrNniCaTpmProvTable=mscFrNniCaTpmProvTable, mscFrNniLmiAdminState=mscFrNniLmiAdminState, mscFrNniCaTpmProvEntry=mscFrNniCaTpmProvEntry, mscFrNniSnmpOperStatus=mscFrNniSnmpOperStatus, frameRelayNniGroup=frameRelayNniGroup, mscFrNniAdminState=mscFrNniAdminState, mscFrNniCaEgEirPoolAdmitBwValue=mscFrNniCaEgEirPoolAdmitBwValue, mscFrNniCaIngCirBPValue=mscFrNniCaIngCirBPValue, mscFrNniLmiUserSideEventHistory=mscFrNniLmiUserSideEventHistory, mscFrNniDlciDiscDeCongestedFromIfBytes=mscFrNniDlciDiscDeCongestedFromIfBytes, mscFrNniDlciLocalRateAdaptOccurred=mscFrNniDlciLocalRateAdaptOccurred, mscFrNniSigAckDelayTimer=mscFrNniSigAckDelayTimer, mscFrNniDlciDiscDeCongestedToIf=mscFrNniDlciDiscDeCongestedToIf, mscFrNniDlciEirEgressBytes=mscFrNniDlciEirEgressBytes, mscFrNniDlciRowStatus=mscFrNniDlciRowStatus, mscFrNniVFramerStatsEntry=mscFrNniVFramerStatsEntry, mscFrNniDlciVcCallingDna=mscFrNniDlciVcCallingDna, mscFrNniDlciDcRowStatusEntry=mscFrNniDlciDcRowStatusEntry, mscFrNniDlciDcTransferPriority=mscFrNniDlciDcTransferPriority, mscFrNniSigCallSetupTimer=mscFrNniSigCallSetupTimer, mscFrNniDlciVcCallingLcn=mscFrNniDlciVcCallingLcn, mscFrNniSigBandwidthNotAvailableTable=mscFrNniSigBandwidthNotAvailableTable, mscFrNniOctetToIfByQueueValue=mscFrNniOctetToIfByQueueValue, mscFrNniDnaNumberingPlanIndicator=mscFrNniDnaNumberingPlanIndicator, mscFrNniDnaCug=mscFrNniDnaCug, mscFrNniLtsIndex=mscFrNniLtsIndex, mscFrNniSigDefaultExcessBurstSize=mscFrNniSigDefaultExcessBurstSize, mscFrNniDlciRateAdaptation=mscFrNniDlciRateAdaptation, mscFrNniVFramerOtherVirtualFramer=mscFrNniVFramerOtherVirtualFramer, mscFrNniEmissionPriorityQsTable=mscFrNniEmissionPriorityQsTable, mscFrNniLtsRowStatusEntry=mscFrNniLtsRowStatusEntry, mscFrNniLtsStateTable=mscFrNniLtsStateTable, mscFrNniCaIngEirPoolAvailBwIndex=mscFrNniCaIngEirPoolAvailBwIndex, mscFrNniDnaCugStorageType=mscFrNniDnaCugStorageType, mscFrNniDnaHgMHgAddrRowStatusEntry=mscFrNniDnaHgMHgAddrRowStatusEntry, mscFrNniDlciEgressSpRowStatusTable=mscFrNniDlciEgressSpRowStatusTable, mscFrNniDnaHgMAvailableDlcis=mscFrNniDnaHgMAvailableDlcis, mscFrNniFramer=mscFrNniFramer, mscFrNniLtsFramesTx=mscFrNniLtsFramesTx, mscFrNniSigIFramesTransmitted=mscFrNniSigIFramesTransmitted, mscFrNniDlciBecnFrmSetByService=mscFrNniDlciBecnFrmSetByService, mscFrNniDlciLoopbackState=mscFrNniDlciLoopbackState, mscFrNniCaEgressCacTable=mscFrNniCaEgressCacTable, mscFrNniFramerStateTable=mscFrNniFramerStateTable, mscFrNniDlciAbitTable=mscFrNniDlciAbitTable, mscFrNniDnaHgM=mscFrNniDnaHgM, mscFrNniDnaCallOptionsTable=mscFrNniDnaCallOptionsTable, mscFrNniCaIngEirPoolAdmitBwTable=mscFrNniCaIngEirPoolAdmitBwTable, mscFrNniCaTpmAssignedEgressBandwidthPool=mscFrNniCaTpmAssignedEgressBandwidthPool, mscFrNniLmiOperationalState=mscFrNniLmiOperationalState, mscFrNniSigCurrentNumberOfSvcCalls=mscFrNniSigCurrentNumberOfSvcCalls, mscFrNniFramerOperationalState=mscFrNniFramerOperationalState, mscFrNniDlciVcCalledLcn=mscFrNniDlciVcCalledLcn, mscFrNniDlciVcMaxSubnetPktSize=mscFrNniDlciVcMaxSubnetPktSize, mscFrNniCaRowStatus=mscFrNniCaRowStatus, frameRelayNniGroupCA=frameRelayNniGroupCA, mscFrNniDlciStorageType=mscFrNniDlciStorageType, mscFrNniDlciVcCallingNpi=mscFrNniDlciVcCallingNpi, mscFrNniSigDefaultMaximumFrameSize=mscFrNniSigDefaultMaximumFrameSize, mscFrNniSigAdminState=mscFrNniSigAdminState, mscFrNniSigAckTimer=mscFrNniSigAckTimer, mscFrNniVFramerLogicalProcessor=mscFrNniVFramerLogicalProcessor, mscFrNniSigProtocolErrors=mscFrNniSigProtocolErrors, mscFrNniSigProvTable=mscFrNniSigProvTable, mscFrNniCaIngCirPoolAvailBwIndex=mscFrNniCaIngCirPoolAvailBwIndex, mscFrNniFramerAdminState=mscFrNniFramerAdminState, mscFrNniDnaHgMOpTable=mscFrNniDnaHgMOpTable, mscFrNniVFramerStateEntry=mscFrNniVFramerStateEntry, mscFrNniFramerFlagsBetweenFrames=mscFrNniFramerFlagsBetweenFrames, mscFrNniSigServParmsEntry=mscFrNniSigServParmsEntry, mscFrNniFramerOctetFromIf64=mscFrNniFramerOctetFromIf64, mscFrNniCaRowStatusTable=mscFrNniCaRowStatusTable, mscFrNniVFramerFrmFromOtherVFramer=mscFrNniVFramerFrmFromOtherVFramer, mscFrNniLtsPatOpStateTable=mscFrNniLtsPatOpStateTable, mscFrNniDlciOperationalState=mscFrNniDlciOperationalState, mscFrNniDlciLbIndex=mscFrNniDlciLbIndex, mscFrNniDlciStateEntry=mscFrNniDlciStateEntry, mscFrNniDnaHgMHgAddrIndex=mscFrNniDnaHgMHgAddrIndex, mscFrNniDlciLbLocalFecnFrm=mscFrNniDlciLbLocalFecnFrm, mscFrNniCaStorageType=mscFrNniCaStorageType, mscFrNniStateEntry=mscFrNniStateEntry, mscFrNniDlciVcDataPath=mscFrNniDlciVcDataPath, mscFrNniLtsBitRateTx=mscFrNniLtsBitRateTx, mscFrNniDnaDefaultTransferPriority=mscFrNniDnaDefaultTransferPriority, mscFrNniDlciAccounting=mscFrNniDlciAccounting, mscFrNniDlciVcPathReliability=mscFrNniDlciVcPathReliability, mscFrNniCaEgCirPoolAdmitBwValue=mscFrNniCaEgCirPoolAdmitBwValue, mscFrNniFramerComponentName=mscFrNniFramerComponentName, mscFrNniOctetToIfByQueueIndex=mscFrNniOctetToIfByQueueIndex, mscFrNniDlciVcFrmLossTimeouts=mscFrNniDlciVcFrmLossTimeouts, mscFrNniCaIngCirPoolAdmitBwTable=mscFrNniCaIngCirPoolAdmitBwTable, mscFrNniRowStatus=mscFrNniRowStatus, mscFrNniDnaHgMHgAddrRowStatusTable=mscFrNniDnaHgMHgAddrRowStatusTable, mscFrNniFramerIndex=mscFrNniFramerIndex, mscFrNniSigDefaultCommittedInformationRate=mscFrNniSigDefaultCommittedInformationRate, mscFrNniDlciDcNfaIndex=mscFrNniDlciDcNfaIndex, mscFrNniDlciEgressSpComponentName=mscFrNniDlciEgressSpComponentName, mscFrNniLtsPatRowStatusEntry=mscFrNniLtsPatRowStatusEntry, mscFrNniCaIngCirPoolAdmitBwEntry=mscFrNniCaIngCirPoolAdmitBwEntry, mscFrNniDlciDeFrmFromIf=mscFrNniDlciDeFrmFromIf, mscFrNniDnaRowStatus=mscFrNniDnaRowStatus, mscFrNniLmiParmsEntry=mscFrNniLmiParmsEntry, mscFrNniDlciDcNfaEntry=mscFrNniDlciDcNfaEntry, mscFrNniDlciEirPresentObs=mscFrNniDlciEirPresentObs, mscFrNniDlciErrorLongFrmFromIf=mscFrNniDlciErrorLongFrmFromIf, mscFrNniDlciDcNfaValue=mscFrNniDlciDcNfaValue, mscFrNniDnaTransferPriorityOverRide=mscFrNniDnaTransferPriorityOverRide, mscFrNniSigLapfSysTable=mscFrNniSigLapfSysTable, mscFrNniDlciVcCalledNpi=mscFrNniDlciVcCalledNpi, frameRelayNniGroupCA02=frameRelayNniGroupCA02, mscFrNniDlciCallState=mscFrNniDlciCallState, mscFrNniDlciVcRowStatusTable=mscFrNniDlciVcRowStatusTable, mscFrNniLmiUnexpectedReports=mscFrNniLmiUnexpectedReports, mscFrNniDnaOutPathSensitivityOverRide=mscFrNniDnaOutPathSensitivityOverRide, mscFrNniDlciVcIntdEntry=mscFrNniDlciVcIntdEntry, mscFrNniSigLapfStatusEntry=mscFrNniSigLapfStatusEntry, mscFrNniDlciVcType=mscFrNniDlciVcType, mscFrNniCaIngCirPoolAvailBwTable=mscFrNniCaIngCirPoolAvailBwTable, mscFrNniDnaHgMStorageType=mscFrNniDnaHgMStorageType, mscFrNniDlciVcStartTime=mscFrNniDlciVcStartTime, mscFrNniSigServParmsTable=mscFrNniSigServParmsTable, frameRelayNniCapabilities=frameRelayNniCapabilities, mscFrNniSigDefaultCommittedBurstSize=mscFrNniSigDefaultCommittedBurstSize, mscFrNniCaIngEirBpIndex=mscFrNniCaIngEirBpIndex, mscFrNniDlciAbitEntry=mscFrNniDlciAbitEntry, mscFrNniInvalidHeaderFramesFromIf=mscFrNniInvalidHeaderFramesFromIf, mscFrNniDlciStatsEntry=mscFrNniDlciStatsEntry, mscFrNniDlciVcState=mscFrNniDlciVcState, mscFrNniDlciSpCommittedInformationRate=mscFrNniDlciSpCommittedInformationRate)

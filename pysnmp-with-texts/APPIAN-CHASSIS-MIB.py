#
# PySNMP MIB module APPIAN-CHASSIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APPIAN-CHASSIS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:23:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
AcRingId, acOsap, AcNodeArchitecture, AcNodeId, AcOpStatus, AcAdminStatus, AcMibVersion = mibBuilder.importSymbols("APPIAN-SMI-MIB", "AcRingId", "acOsap", "AcNodeArchitecture", "AcNodeId", "AcOpStatus", "AcAdminStatus", "AcMibVersion")
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, ObjectIdentity, Unsigned32, ModuleIdentity, MibIdentifier, Counter32, Bits, iso, NotificationType, Counter64, IpAddress, Integer32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ObjectIdentity", "Unsigned32", "ModuleIdentity", "MibIdentifier", "Counter32", "Bits", "iso", "NotificationType", "Counter64", "IpAddress", "Integer32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DateAndTime, TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TruthValue", "DisplayString", "TextualConvention")
acChassis = ModuleIdentity((1, 3, 6, 1, 4, 1, 2785, 2, 1))
acChassis.setRevisions(('1900-04-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: acChassis.setRevisionsDescriptions(('Engineering draft version, not for release.',))
if mibBuilder.loadTexts: acChassis.setLastUpdated('0004200000Z')
if mibBuilder.loadTexts: acChassis.setOrganization('Appian Communications, Inc.')
if mibBuilder.loadTexts: acChassis.setContactInfo('Douglas Theriault')
if mibBuilder.loadTexts: acChassis.setDescription('Appian OSAP Chassis MIB which defines the current hardware configuration and state information.')
class AcFanStatus(TextualConvention, Integer32):
    description = 'The FAN status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 0), ("fast", 1), ("medium", 2), ("slow", 3), ("failed", 4))

acGlobals = MibIdentifier((1, 3, 6, 1, 4, 1, 2785, 2, 1, 1))
acNodeId = MibScalar((1, 3, 6, 1, 4, 1, 2785, 2, 1, 1, 1), AcNodeId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acNodeId.setStatus('current')
if mibBuilder.loadTexts: acNodeId.setDescription('A unique node identifier assigned by the EMS to uniquely identify a node within an Appian ring. This must be set before setting other MIB objects that used NodeId as part of the index.')
acChassisTable = MibTable((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2), )
if mibBuilder.loadTexts: acChassisTable.setStatus('current')
if mibBuilder.loadTexts: acChassisTable.setDescription("A table of configuration and statistics parameters for an Appian Communications chassis's within an Appian ring.")
acChassisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1), ).setIndexNames((0, "APPIAN-CHASSIS-MIB", "acChassisNodeId"))
if mibBuilder.loadTexts: acChassisEntry.setStatus('current')
if mibBuilder.loadTexts: acChassisEntry.setDescription("A single node's chassis parameters. The index to this record is AcNodeId which is a unique identifier assigned by the EMS system.")
acChassisNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 1), AcNodeId()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: acChassisNodeId.setStatus('current')
if mibBuilder.loadTexts: acChassisNodeId.setDescription('A unique node identifier assigned by the EMS to uniquely identify a node within an Appian ring.')
acChassisAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 2), AcAdminStatus().clone('activate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisAdminStatus.setStatus('current')
if mibBuilder.loadTexts: acChassisAdminStatus.setDescription('This field is used by the administrator to ensure only one client can configure the chassis record at a time. The field is set to locked when a client is performing administrative operations and available when it is free.')
acChassisOpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 3), AcOpStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisOpStatus.setStatus('current')
if mibBuilder.loadTexts: acChassisOpStatus.setDescription('The state field is used to identify the current operational state of the chassis.')
acChassisCfgType = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("osap-1600", 1), ("osap-4800", 2), ("osap-10G", 3))).clone('unknown')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisCfgType.setStatus('current')
if mibBuilder.loadTexts: acChassisCfgType.setDescription('This field describes the type of physical chassis as defined by the AppianVista EMS. The model number is a simple enumeration type for an Appian Communications chassis.')
acChassisModelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("osap-1600", 1), ("osap-4800", 2), ("osap-10G", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisModelNumber.setStatus('current')
if mibBuilder.loadTexts: acChassisModelNumber.setDescription('This field defines the type of physical chassis. The model number is a simple enumeration type for an Appian Communications chassis.')
acChassisSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisSerialNumber.setStatus('current')
if mibBuilder.loadTexts: acChassisSerialNumber.setDescription('Display string containing the serial number which is read from the chassis backplane prom.')
acChassisProductionDate = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisProductionDate.setStatus('current')
if mibBuilder.loadTexts: acChassisProductionDate.setDescription('The date code when this chassis was manufactured. This field is read-only and set by manufacturing in the I2C prom. The format used is YYWW; with YY = year and WW = week.')
acChassisRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisRevision.setStatus('current')
if mibBuilder.loadTexts: acChassisRevision.setDescription('The revision of the chassis expressed as an integer monotonically increasing from 0 to 255.')
acChassisTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("normal", 1), ("tooCold", 2), ("tooHot", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisTemperature.setStatus('current')
if mibBuilder.loadTexts: acChassisTemperature.setDescription('The current temperature state for the chassis as reported by the fan and temperature controller card. If the temperature is too hot, it is possible that the input filter is blocked, which is reported in the acChassisFanStatus attribute.')
acChassisFanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 10), AcFanStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisFanSpeed.setStatus('current')
if mibBuilder.loadTexts: acChassisFanSpeed.setDescription('The desired fan speed.')
acChassisFan1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 11), AcFanStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisFan1Status.setStatus('current')
if mibBuilder.loadTexts: acChassisFan1Status.setDescription('FAN 1 status.')
acChassisFan2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 12), AcFanStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisFan2Status.setStatus('current')
if mibBuilder.loadTexts: acChassisFan2Status.setDescription('FAN 2 status.')
acChassisFan3Status = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 13), AcFanStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisFan3Status.setStatus('current')
if mibBuilder.loadTexts: acChassisFan3Status.setDescription('FAN 3 status.')
acChassisFan4Status = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 14), AcFanStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisFan4Status.setStatus('current')
if mibBuilder.loadTexts: acChassisFan4Status.setDescription('FAN 4 status.')
acChassisFan5Status = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 15), AcFanStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisFan5Status.setStatus('current')
if mibBuilder.loadTexts: acChassisFan5Status.setDescription('FAN 5 status.')
acChassisFan6Status = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 16), AcFanStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisFan6Status.setStatus('current')
if mibBuilder.loadTexts: acChassisFan6Status.setDescription('FAN 6 status.')
acChassisPowerAStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 17), AcOpStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisPowerAStatus.setStatus('current')
if mibBuilder.loadTexts: acChassisPowerAStatus.setDescription('The current state of the power supply subsystem.')
acChassisPowerBStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 18), AcOpStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisPowerBStatus.setStatus('current')
if mibBuilder.loadTexts: acChassisPowerBStatus.setDescription('The current state of the power supply subsystem.')
acChassisContact = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisContact.setStatus('current')
if mibBuilder.loadTexts: acChassisContact.setDescription('The identification and contact information of the person responsible for this managed node. This field is mapped to the MIB-II sysContact field.')
acChassisName = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisName.setStatus('current')
if mibBuilder.loadTexts: acChassisName.setDescription('An administratively assigned name for this managed node. This field is mapped to MIB-II sysName field.')
acChassisLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisLocation.setStatus('current')
if mibBuilder.loadTexts: acChassisLocation.setDescription('The physical location of this node. The field is mapped to the MIB-II sysLocation field.')
acChassisDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisDescription.setStatus('current')
if mibBuilder.loadTexts: acChassisDescription.setDescription('A description of the node indicating the type of Appian Communications equipment. This field is mapped to the MIB-II sysDescr attribute.')
acChassisMaxSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisMaxSlots.setStatus('current')
if mibBuilder.loadTexts: acChassisMaxSlots.setDescription('The maximum number of slots within this chassis.')
acChassisSysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisSysUpTime.setStatus('current')
if mibBuilder.loadTexts: acChassisSysUpTime.setDescription('The time in hundredths of a second since the network management portion of the system was last reinitialized. The acChassisSysUpTime field is mapped to the MIB-II sysUptime field. Note: The value of acChassisSysUpTime will not be reset when an Active to Standby failover occurs on the Switch Control Processor(s). The acChassisSysUpTime value will only be reset when the whole system has been reset.')
acChassisCurrentTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 25), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisCurrentTime.setStatus('current')
if mibBuilder.loadTexts: acChassisCurrentTime.setDescription('A string containing the current time and date as read from the active Switch Control Processor (SCP) NovRam. The format is defined by DateAndTime syntax.')
acChassisMaxSerialPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisMaxSerialPorts.setStatus('current')
if mibBuilder.loadTexts: acChassisMaxSerialPorts.setDescription('Identifies the total number of serial interface ports on the OSAP chassis.')
acChassisRingId = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 27), AcRingId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisRingId.setStatus('current')
if mibBuilder.loadTexts: acChassisRingId.setDescription('A unique Ring Identification number which is assigned by the EMS system to uniquely identify the Appian Ring supported by this node.')
acChassisRingName = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 28), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisRingName.setStatus('current')
if mibBuilder.loadTexts: acChassisRingName.setDescription('A user defined string assigned to the Ring Id which uniquely identifies the Appian Ring supported by this node.')
acChassisMibVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 29), AcMibVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisMibVersion.setStatus('current')
if mibBuilder.loadTexts: acChassisMibVersion.setDescription('A ASCII string which identifies the Appian MIB version which is currently supported by the active switch control processor.')
acChassisNodeArchitecture = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 30), AcNodeArchitecture()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisNodeArchitecture.setStatus('current')
if mibBuilder.loadTexts: acChassisNodeArchitecture.setDescription('Node architecture.')
acChassisNodePoll = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 31), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisNodePoll.setStatus('current')
if mibBuilder.loadTexts: acChassisNodePoll.setDescription('This object returns a concise summary of the system state. It contains information on the system operational status, mib revision, fan status, power supply status, and other status information. The value is in compacted binary format: Element Size Value Description ----------------------------------------------------------------------- poll version 1 0x01 Node poll version operational status 1 acChassisOpStatus overall system status mib version 4 software version 4 chassis temperature 1 actual temperature? maybe it should be in module? fan status, each fan status is encoded as: 0xA1 - FAN status IE 0x01 - FAN #1 0x01 - operational power supply status, with each power supply status encoded as: 0xA2 - power status IE 0x02 - power supply #2 0x01 - operational ')
acChassisModulePoll = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 32), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisModulePoll.setStatus('current')
if mibBuilder.loadTexts: acChassisModulePoll.setDescription("This object returns a concise summary of the module cards in the system. For each module card present, it includes card slot, card configured type and actual type, card operational status, redundancy status, and possibly LED information. slot - 1 byte representing the physical slot number. number - 1 byte representing the module number. configured type - 1 byte value from AcModuleType. actual type - 1 byte value from AcModuleType. operStatus - 1 byte representing an AcOpStatus. redundancy - 1 byte to indicate it's active or standby number of LEDs - 1 byte, indicates how many LED status follows LED states - 1 byte for each LED to represent: green, red, yellow, off. with high bit on as ing. ")
acChassisPortPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 33), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acChassisPortPoll.setStatus('current')
if mibBuilder.loadTexts: acChassisPortPoll.setDescription('This object returns a concise summary of the module cards in the system. For each module card present, it includes card slot, card configured type and actual type, card operational status, redundancy status, possibly LED information, and port information. slot - 1 byte representing the physical slot number. configured type - 1 byte value from AcModuleType. actual type - 1 byte value from AcModuleType. operStatus - 1 byte representing an AcOpStatus. media slot - 1 byte, valid only number of LEDs - 1 byte, indicates how many LED status follows LED states - 1 byte for each LED to represent: green, red, yellow, off. with high bit on as ing. number of ports - 1 byte, indicates how many physical ports on the card port info - for each port, it includes operStatus and service status. Take a system with the following configuration as an example: slot 1 - a single port OC3 slot 2 - a single port OC3 slot 3 - a switching control card slot 5 - an ethernet media card slot 6 - an ethernet media card, currently backing up slot 5 slot 11 - an 8-port ethernet PHY card driven by slot 5 slot 12 - an 8-port ethernet PHY card driven by slot 5. The poll would resemble this: 0x01 - the first poll version 0xA3 - this indicates a card information element 0x01 - card slot 1 0x13 - configured card type: oc3-sr-1 0x13 - actual card type: oc3-sr-1 0x01 - card operational status: operational ox00 - media slot, not applicable 0x00 - # of LEDs, 0 means no LED information included 0x01 - # of ports 0x01 - port status: up 0x00 - no services on this port 0xA3 - this indicates a card information element 0x02 - card slot 2 0x13 - configured card type: oc3-sr-1 0x13 - actual card type: oc3-sr-1 0x01 - card operational status: operational ox00 - media slot, not applicable 0x00 - # of LEDs, 0 means no LED information included 0x01 - # of ports 0x01 - port status: up 0x00 - no services on this port 0xA3 - this indicates a card information element 0x03 - card slot 3 0x03 - configured card type: sw-1 0x03 - actual card type: sw-1 0x01 - card operational status: operational ox00 - media slot, not applicable 0x00 - # of LEDs, 0 means no LED information included 0x00 - # of ports 0xA3 - this indicates a card information element 0x05 - card slot 5 0x04 - configured card type: 16-port fast ethernet 0x04 - actual card type: 16-port fast ethernet 0x01 - card operational status: operational ox00 - media slot, not applicable 0x00 - # of LEDs, 0 means no LED information included 0x00 - # of ports - defer port status to PHY cards? 0xA3 - this indicates a card information element 0x0B - card slot 11 0x05 - configured card type: fe8-tx-io (8-port phy card) 0x05 - actual card type: fe8-tx-io (8-port phy card) 0x01 - card operational status: operational ox05 - media slot: currently driven by media card in slot 5 0x00 - # of LEDs, 0 means no LED information included 0x08 - info for 8 ports follows 0x01 0x?? - port 1, up and service status? 0x02 0x?? - port 2, down and service status? ... 1 byte can be used to represent 4 service status, with 2 bits each? 0xA3 - this indicates a card information element 0x0C - card slot 11 0x05 - configured card type: fe8-tx-io (8-port phy card) 0x05 - actual card type: fe8-tx-io (8-port phy card) 0x01 - card operational status: operational ox05 - media slot: currently driven by media card in slot 5 0x00 - # of LEDs, 0 means no LED information included 0x08 - info for 8 ports follows 0x01 0x?? - port 1, up and service status? 0x02 0x?? - port 2, down and service status? ... 1 byte can be used to represent 4 service status, with 2 bits each? ')
acChassisReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 34), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisReset.setStatus('current')
if mibBuilder.loadTexts: acChassisReset.setDescription('Setting this object to true causes the entire system to reset.')
acChassisTdmAccessRedundancyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n-to-one", 0), ("one-to-one", 1))).clone('n-to-one')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acChassisTdmAccessRedundancyMode.setStatus('current')
if mibBuilder.loadTexts: acChassisTdmAccessRedundancyMode.setDescription('This value describes how backup TDM Access cards are used to provide redundancy for active TDM Access cards in the system. n-to-one: One backup card will provide redundancy for all other similar type TDM Access cards. one-to-one: Each backup card will be assigned to provide redundancy for at most one TDM Access card.')
acChassisTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2785, 2, 1, 0))
acChassisCfgMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 2785, 2, 1, 0, 1)).setObjects(("APPIAN-CHASSIS-MIB", "acChassisCurrentTime"), ("APPIAN-CHASSIS-MIB", "acChassisRingId"), ("APPIAN-CHASSIS-MIB", "acChassisNodeId"), ("APPIAN-CHASSIS-MIB", "acChassisModelNumber"), ("APPIAN-CHASSIS-MIB", "acChassisCfgType"))
if mibBuilder.loadTexts: acChassisCfgMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: acChassisCfgMismatchTrap.setDescription('The user configured chassis model does not match the actual chassis model generated by this trap.')
acChassisTemperatureTrap = NotificationType((1, 3, 6, 1, 4, 1, 2785, 2, 1, 0, 2)).setObjects(("APPIAN-CHASSIS-MIB", "acChassisCurrentTime"), ("APPIAN-CHASSIS-MIB", "acChassisRingId"), ("APPIAN-CHASSIS-MIB", "acChassisNodeId"), ("APPIAN-CHASSIS-MIB", "acChassisTemperature"))
if mibBuilder.loadTexts: acChassisTemperatureTrap.setStatus('current')
if mibBuilder.loadTexts: acChassisTemperatureTrap.setDescription('The temperature for this chassis has exceeded or fallen below the normal operational range.')
acChassisFanFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 2785, 2, 1, 0, 3)).setObjects(("APPIAN-CHASSIS-MIB", "acChassisCurrentTime"), ("APPIAN-CHASSIS-MIB", "acChassisRingId"), ("APPIAN-CHASSIS-MIB", "acChassisNodeId"), ("APPIAN-CHASSIS-MIB", "acChassisFan1Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan2Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan3Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan4Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan5Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan6Status"))
if mibBuilder.loadTexts: acChassisFanFailureTrap.setStatus('current')
if mibBuilder.loadTexts: acChassisFanFailureTrap.setDescription('The fan shelf subsystem is reporting a failure of one or more fans.')
acChassisTemperatureClearTrap = NotificationType((1, 3, 6, 1, 4, 1, 2785, 2, 1, 0, 4)).setObjects(("APPIAN-CHASSIS-MIB", "acChassisCurrentTime"), ("APPIAN-CHASSIS-MIB", "acChassisRingId"), ("APPIAN-CHASSIS-MIB", "acChassisNodeId"), ("APPIAN-CHASSIS-MIB", "acChassisTemperature"))
if mibBuilder.loadTexts: acChassisTemperatureClearTrap.setStatus('current')
if mibBuilder.loadTexts: acChassisTemperatureClearTrap.setDescription('The temperature for this chassis has returned back to the normal operational range.')
acChassisFanFailureClearTrap = NotificationType((1, 3, 6, 1, 4, 1, 2785, 2, 1, 0, 5)).setObjects(("APPIAN-CHASSIS-MIB", "acChassisCurrentTime"), ("APPIAN-CHASSIS-MIB", "acChassisRingId"), ("APPIAN-CHASSIS-MIB", "acChassisNodeId"), ("APPIAN-CHASSIS-MIB", "acChassisFan1Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan2Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan3Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan4Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan5Status"), ("APPIAN-CHASSIS-MIB", "acChassisFan6Status"))
if mibBuilder.loadTexts: acChassisFanFailureClearTrap.setStatus('current')
if mibBuilder.loadTexts: acChassisFanFailureClearTrap.setDescription('The fan shelf subsystem that reported a failure of one or more fans has returned back to normal.')
acMgmtAccessTable = MibTable((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3), )
if mibBuilder.loadTexts: acMgmtAccessTable.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessTable.setDescription('This table contains the configuration parameters which define the method used for management of the OSAP via a remote EMS such as the AppianVista platform. The table contains the IP Address, gateway and subnet for in-band and OOB access to the OSAP.')
acMgmtAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1), ).setIndexNames((0, "APPIAN-CHASSIS-MIB", "acMgmtAccessNodeId"), (0, "APPIAN-CHASSIS-MIB", "acMgmtAccessIndex"))
if mibBuilder.loadTexts: acMgmtAccessEntry.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessEntry.setDescription('A configuration record defining a single nodes in-band and oob access methods and interfaces. This entry must be created by the EMS or CLI and is not by default automatically instantiated.')
acMgmtAccessNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 1), AcNodeId()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: acMgmtAccessNodeId.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessNodeId.setDescription('A unique node identifier assigned by the EMS to uniquely identify a node within an Appian ring.')
acMgmtAccessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 2), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: acMgmtAccessIndex.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessIndex.setDescription('Unique identifier of management access interface in this node.')
acMgmtAccessInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 0), ("ethernet", 1), ("appian-dcc", 2), ("oob-ppp", 3), ("frame-relay", 4), ("ppp", 5), ("sonet-1-dbg", 6), ("sonet-2-dbg", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: acMgmtAccessInterfaceType.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessInterfaceType.setDescription('This attribute defines what type of management access port is being configured. The Ethernet(1) interface refers to the OOB Ethernet port on the switch controller and is used for both master and slave switch controllers, only one of which is active at a time. Frame-Relay(4) and PPP(5) refer to In-Band access interface. Appian-DCC(2) is used as an extended LAN and needs to be configured for each node within an Appian SONET Ring.')
acMgmtAccessAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 4), AcAdminStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: acMgmtAccessAdminStatus.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessAdminStatus.setDescription('This field is used by the administrator to ensure only one client can perform configuration operations on the chassis record at a time. The field is set to locked when a client is performing administrative operations and available when it is free. The field is also used to enable or disable a specific management access port. Setting the value to inactivate(1) will cause the interface to be disabled. Setting the state to activate(2) will enable the management interface.')
acMgmtAccessOpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 5), AcOpStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acMgmtAccessOpStatus.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessOpStatus.setDescription('This attribute is used to determine the current state of the management access agent. Refer to the appian-smi.mib for defintion details of the AcOpStatus attribute.')
acMgmtAccessIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 6), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: acMgmtAccessIpAddress.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessIpAddress.setDescription('The IP Address in dotted notation which is used by the AppianVista EMS system or for telnet, tftp, rlogin or ftp access to the network element. This IP address may be bound to a frame-relay trunk/dlci or could be bound to a TLS trunk running PPP.')
acMgmtAccessIpSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 7), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: acMgmtAccessIpSubnet.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessIpSubnet.setDescription('The IP Subnet address in dotted notation used for the primary in-band access interface. If no value is entered, the management agent will assume the natural mask.')
acMgmtAccessTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: acMgmtAccessTrunk.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessTrunk.setDescription('If the access type is either frame relay or PPP, this object has the trunk number of the trunk being used for inband management. If the access type is not frame relay nor PPP, this object has value of 0 and is not applicable.')
acMgmtAccessFrDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 2785, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1022))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: acMgmtAccessFrDlci.setStatus('current')
if mibBuilder.loadTexts: acMgmtAccessFrDlci.setDescription('The Frame-Relay DLCI number used for in-band management access to the network element when the access interface uses a frame-relay trunk.')
mibBuilder.exportSymbols("APPIAN-CHASSIS-MIB", acChassisMaxSerialPorts=acChassisMaxSerialPorts, acChassisFan2Status=acChassisFan2Status, acChassisFan5Status=acChassisFan5Status, acChassisTraps=acChassisTraps, acChassisTemperatureClearTrap=acChassisTemperatureClearTrap, acChassisFanFailureClearTrap=acChassisFanFailureClearTrap, acMgmtAccessIndex=acMgmtAccessIndex, acChassisPowerBStatus=acChassisPowerBStatus, acChassisAdminStatus=acChassisAdminStatus, acMgmtAccessIpSubnet=acMgmtAccessIpSubnet, acChassisNodeId=acChassisNodeId, acChassisSerialNumber=acChassisSerialNumber, acChassisFan1Status=acChassisFan1Status, acMgmtAccessIpAddress=acMgmtAccessIpAddress, acChassisMibVersion=acChassisMibVersion, acChassisRevision=acChassisRevision, acChassisFanSpeed=acChassisFanSpeed, acChassisFan4Status=acChassisFan4Status, acChassisEntry=acChassisEntry, acChassisFan6Status=acChassisFan6Status, acMgmtAccessOpStatus=acMgmtAccessOpStatus, acChassisPowerAStatus=acChassisPowerAStatus, acChassisCurrentTime=acChassisCurrentTime, acGlobals=acGlobals, acChassisOpStatus=acChassisOpStatus, acChassisNodePoll=acChassisNodePoll, acMgmtAccessTrunk=acMgmtAccessTrunk, acChassisProductionDate=acChassisProductionDate, acChassis=acChassis, acChassisTable=acChassisTable, acMgmtAccessNodeId=acMgmtAccessNodeId, acMgmtAccessAdminStatus=acMgmtAccessAdminStatus, acChassisTemperatureTrap=acChassisTemperatureTrap, acChassisContact=acChassisContact, acChassisPortPoll=acChassisPortPoll, acChassisModelNumber=acChassisModelNumber, acChassisNodeArchitecture=acChassisNodeArchitecture, acChassisTdmAccessRedundancyMode=acChassisTdmAccessRedundancyMode, acMgmtAccessTable=acMgmtAccessTable, acChassisRingName=acChassisRingName, acMgmtAccessInterfaceType=acMgmtAccessInterfaceType, acChassisTemperature=acChassisTemperature, acChassisFan3Status=acChassisFan3Status, acChassisSysUpTime=acChassisSysUpTime, acChassisRingId=acChassisRingId, acChassisName=acChassisName, acChassisMaxSlots=acChassisMaxSlots, acChassisReset=acChassisReset, acChassisFanFailureTrap=acChassisFanFailureTrap, acChassisModulePoll=acChassisModulePoll, acChassisLocation=acChassisLocation, acMgmtAccessEntry=acMgmtAccessEntry, PYSNMP_MODULE_ID=acChassis, acMgmtAccessFrDlci=acMgmtAccessFrDlci, acNodeId=acNodeId, acChassisCfgType=acChassisCfgType, AcFanStatus=AcFanStatus, acChassisCfgMismatchTrap=acChassisCfgMismatchTrap, acChassisDescription=acChassisDescription)

#
# PySNMP MIB module BIANCA-BRICK-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BRICK-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:38:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysDescr, sysName = mibBuilder.importSymbols("SNMPv2-MIB", "sysDescr", "sysName")
Bits, ObjectIdentity, NotificationType, IpAddress, Integer32, MibIdentifier, TimeTicks, Unsigned32, Counter64, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter32, NotificationType, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "ObjectIdentity", "NotificationType", "IpAddress", "Integer32", "MibIdentifier", "TimeTicks", "Unsigned32", "Counter64", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter32", "NotificationType", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
admin = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 1))
class DisplayString(OctetString):
    pass

class PhysAddress(OctetString):
    pass

class Date(Integer32):
    pass

class HexValue(Integer32):
    pass

biboAdmTrapCommunity = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTrapCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTrapCommunity.setDescription('Community name for sending traps.')
biboAdmSnmpVersion = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("version1", 1), ("version1-compat", 2), ("version1p1", 3), ("version1p1-compat", 4), ("version1p1-auto", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmSnmpVersion.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSnmpVersion.setDescription('SNMP Version. version1 : SNMP version V1 version1_compat : SNMP version V1 compatibility mode without the appending private OID part (.i). This is for some SNMP managers that cannot handle this extension. In this mode rows with identical index variable content cannot be read correctly. p1 (patch1) : getnext returns the lexicographical next OID (ever!) version1p1_auto : use version1p1_compat if possible use version1p1 if nessesary Usually the OIDs have the format: .1.3.6.x.x .y.y .i .1.3.6.x.x: is the constant part of the OID of the variable specified in MIB-source .y.y : is the specific part of the OID to identify exactly a row. It is the content of all index variables. .i : is a consecutively incremented index number, to distinguish rows with identical index variables ')
biboAdmSnmpPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmSnmpPort.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSnmpPort.setDescription('SNMP listen port.')
biboAdmSnmpTrapPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmSnmpTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSnmpTrapPort.setDescription('SNMP trap port.')
biboAdmIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmIpAddr.setDescription("Local IP address. If this object is set, it's value will be used as the source address for all IP packets that are sent. Otherwise, the IP address used will be retrieved from the ipRouteTable, for the interface the IP packet is to be transmitted over.")
biboAdmTrapBrdCast = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTrapBrdCast.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTrapBrdCast.setDescription('Enable/disable trap broadcasting.')
biboAdmTrapHostTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 10), )
if mibBuilder.loadTexts: biboAdmTrapHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTrapHostTable.setDescription("The biboAdmTrapHostTable defines where traps are sent (i.e., which hosts). If the table is empty traps are broadcasted. Creating entries: Entries are added by assigning an IP address value to the biboAdmTrapHostAddr field. Deleting entries: Entries can be removed by assigning ing the respective biboAdmTrapHostStatus field to 'delete'.")
biboAdmTrapHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 10, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboAdmTrapHostAddr"))
if mibBuilder.loadTexts: biboAdmTrapHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTrapHostEntry.setDescription('')
biboAdmTrapHostAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTrapHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTrapHostAddr.setDescription('Ip-Address where traps are sent.')
biboAdmTrapHostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTrapHostStatus.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTrapHostStatus.setDescription('Status is always valid, and set to delete only to discard the whole entry.')
biboAdmSyslogMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmSyslogMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSyslogMaxEntries.setDescription('Maximum Number of syslog messages stored in memory.')
biboAdmSyslogTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 12), )
if mibBuilder.loadTexts: biboAdmSyslogTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSyslogTable.setDescription('The biboAdmSyslogTable keeps track of syslog messages received. The size of the table (number of entries), is limited by the value of biboAdmSyslogMaxEntries. The columns specify attributes for each message generated. As this information only reports events on the system, all fields are read-only. Creating entries: Entries can only be created by the system and are made each time a syslog message is generated. Deleting entries: Entries are removed by the system once the size limit (biboAdmSyslogMaxEntries) is reached.')
biboAdmSyslogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 12, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboAdmSyslogTimeStamp"), (0, "BIANCA-BRICK-MIB", "biboAdmSyslogLevel"))
if mibBuilder.loadTexts: biboAdmSyslogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSyslogEntry.setDescription('')
biboAdmSyslogTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 12, 1, 1), Date()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmSyslogTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSyslogTimeStamp.setDescription('Time message was generated.')
biboAdmSyslogLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg", 1), ("alert", 2), ("crit", 3), ("err", 4), ("warning", 5), ("notice", 6), ("info", 7), ("debug", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmSyslogLevel.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSyslogLevel.setDescription('Level of syslog message.')
biboAdmSyslogMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 12, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmSyslogMessage.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSyslogMessage.setDescription('The text of the syslog message.')
biboAdmSyslogSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("acct", 1), ("isdn", 2), ("inet", 3), ("x25", 4), ("ipx", 5), ("capi", 6), ("ppp", 7), ("bridge", 8), ("config", 9), ("snmp", 10), ("x21", 11), ("token", 12), ("ether", 13), ("radius", 14), ("tapi", 15), ("ospf", 16), ("fr", 17), ("modem", 18), ("rip", 19), ("atm", 20), ("pabx", 21), ("ipsec", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmSyslogSubject.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSyslogSubject.setDescription('Subject of the syslog message.')
biboAdmLogHostTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 13), )
if mibBuilder.loadTexts: biboAdmLogHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLogHostTable.setDescription("The biboAdmLogHostTable lists hosts which are to receive syslog messages. This table also defines which types and levels of messages to send. Creating entries: Entries are created by setting a IP address to biboAdmLogHostAddr. Deleting entries: Entries are removed by setting the appropriate biboAdmLogHostLevel field to 'delete'.")
biboAdmLogHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 13, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboAdmLogHostAddr"))
if mibBuilder.loadTexts: biboAdmLogHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLogHostEntry.setDescription('')
biboAdmLogHostAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 13, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmLogHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLogHostAddr.setDescription('Ip-Address where syslog messages are sent. If the facility is set to memory or console, this field is not used.')
biboAdmLogHostLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("emerg", 1), ("alert", 2), ("crit", 3), ("err", 4), ("warning", 5), ("notice", 6), ("info", 7), ("debug", 8), ("delete", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmLogHostLevel.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLogHostLevel.setDescription('Priorities lower or equal this level are sent to loghost. The delete priority is used to discard the whole entry.')
biboAdmLogHostFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("local0", 1), ("local1", 2), ("local2", 3), ("local3", 4), ("local4", 5), ("local5", 6), ("local6", 7), ("local7", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmLogHostFacility.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLogHostFacility.setDescription('The facility used for the syslog messages being generated.')
biboAdmLogHostType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("system", 1), ("acct", 2), ("all", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmLogHostType.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLogHostType.setDescription('The subject of the messages that are to be generated. system means all subjects except accounting, all means all subjects.')
biboAdmLogHostTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("time", 2), ("all", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmLogHostTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLogHostTimestamp.setDescription('This object describes the format of the timestamp. none(1) = no timestamp, time(2) = only time is printed, all(3) = date and time is printed.')
biboAdmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 14), )
if mibBuilder.loadTexts: biboAdmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigTable.setDescription('The biboAdmConfigTable is used for assigning parameters for managing configuration files. Creating entries: Entries are added to this table by assigning a value to the biboAdmConfigCmd object. (i.e., The intermediate result of executing, cmd=save, creates an entry to this table.). Deleting entries: Entries can only be removed by the system and is done only after the requested action has been performed (i.e. Once the cmd=save action is complete.).')
biboAdmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 14, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboAdmConfigCmd"))
if mibBuilder.loadTexts: biboAdmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigEntry.setDescription('')
biboAdmConfigDirTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 15), )
if mibBuilder.loadTexts: biboAdmConfigDirTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigDirTable.setDescription('Configuration directory table. This table contains all available configuration files in flash memory.')
biboAdmConfigDirEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 15, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboAdmConfigDirName"))
if mibBuilder.loadTexts: biboAdmConfigDirEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigDirEntry.setDescription('')
biboAdmConfigCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("save", 1), ("load", 2), ("put", 3), ("get", 4), ("state", 5), ("delete", 6), ("move", 7), ("copy", 8), ("reboot", 9), ("reorg", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmConfigCmd.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigCmd.setDescription('Command for configuration handling. Possible values are : save(1) = save configuration (to FLASH) load(2) = load configuration (from FLASH) put(3) = write configuration (via TFTP) get(4) = read configuration (via TFTP) state(5) = write complete configuration (via TFTP) delete(6) = delete configuration (within FLASH) move(7) = move configuration (within FLASH) copy(8) = copy configuration (within FLASH) reboot(9) = reboot the system reorg(10) = reorganizes the flash')
biboAdmConfigObject = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 14, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmConfigObject.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigObject.setDescription('Table object id (OID) to save/load. If this field is set, only this table is saved/loaded. Otherwise all tables are saved/loaded.')
biboAdmConfigPath = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 14, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmConfigPath.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigPath.setDescription('NAme of the configuration file in flash memory to save/load.')
biboAdmConfigPathNew = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 14, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmConfigPathNew.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigPathNew.setDescription('New name of configuration file in flash memory to move/copy')
biboAdmConfigHost = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 14, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmConfigHost.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigHost.setDescription("TFTP host's IP address to send/receive the file to/from. The configuration is transfered directly from flash memory (biboAdmConfigPath) to TFTP-file (biboAdmConfigFile).")
biboAdmConfigState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("todo", 1), ("running", 2), ("done", 3), ("error", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmConfigState.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigState.setDescription('The state of this command (i.e., biboAdmConfigCmd). todo(1) = The command has not started; running(2) = The command is executing; done(3) = The command successfully completed; error(4) = The command failed (see the biboAdmSyslogTable).')
biboAdmConfigFile = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 14, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmConfigFile.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigFile.setDescription('TFTP filename to read/write from/to the specified host. The configuration file received is stored in flash memory specified by biboAdmConfigPath. The actual configuration is not changed.')
biboAdmConfigDirName = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 15, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmConfigDirName.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigDirName.setDescription('Name of the configuration file in flash memory.')
biboAdmConfigDirCount = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmConfigDirCount.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigDirCount.setDescription('Number of tables saved in the file.')
biboAdmConfigDirContent = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 15, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmConfigDirContent.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConfigDirContent.setDescription("Description of directory's contents (e.g., <all> or a series of table numbers).")
biboAdmBoardTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 17), )
if mibBuilder.loadTexts: biboAdmBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmBoardTable.setDescription('The biboAdmBoardTable lists information about the installed communications modules. This table is updated after every system boot up. Creating entries: Entries are created by the system upon detecting the installed hardware. Deleting entries: Entries are removed by the system as a result of removed hardware.')
biboAdmBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboABrdSlot"), (0, "BIANCA-BRICK-MIB", "biboABrdUnit"))
if mibBuilder.loadTexts: biboAdmBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmBoardEntry.setDescription('')
biboABrdSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboABrdSlot.setStatus('mandatory')
if mibBuilder.loadTexts: biboABrdSlot.setDescription('The slot, or location of this module.')
biboABrdType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboABrdType.setStatus('mandatory')
if mibBuilder.loadTexts: biboABrdType.setDescription('The name of this module.')
biboABrdHWRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboABrdHWRelease.setStatus('mandatory')
if mibBuilder.loadTexts: biboABrdHWRelease.setDescription('The hardware release of this module.')
biboABrdFWRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboABrdFWRelease.setStatus('mandatory')
if mibBuilder.loadTexts: biboABrdFWRelease.setDescription('The firmware release of this module.')
biboABrdPartNo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboABrdPartNo.setStatus('mandatory')
if mibBuilder.loadTexts: biboABrdPartNo.setDescription('The part number of this module.')
biboABrdConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("auto", 1), ("rj45", 2), ("bnc", 3), ("subd15", 4), ("rj45-10mbit-hdup", 5), ("rj45-10mbit-fdup", 6), ("rj45-100mbit-hdup", 7), ("rj45-100mbit-fdup", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboABrdConnector.setStatus('mandatory')
if mibBuilder.loadTexts: biboABrdConnector.setDescription("The type of connector used for this module. For modules with more than one connector this value can be changed/switched by setting this object. For example, the CM-BNCTP module supports both twisted pair (RJ45) and 10Base2 (BNC) connectors. If this object is set to 'AUTO' then the BRICK will automatically detect which connector type is being used.")
biboABrdUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboABrdUnit.setStatus('mandatory')
if mibBuilder.loadTexts: biboABrdUnit.setDescription('The logical unit number of this interface.')
biboABrdSerialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 17, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboABrdSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: biboABrdSerialNo.setDescription('The serial number of this module.')
biboAdmUsrTrapTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 18), )
if mibBuilder.loadTexts: biboAdmUsrTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmUsrTrapTable.setDescription("The biboAdmUsrTrapTable lists user-defined objects that are used to create traps. These traps are sent locally, but can also be sent to remote hosts using the biboAdmTrapHostTable. Creating entries: Entries are created by assigning the biboATrpObj object a valid object identifier. Deleting entries: Entries are removed by setting the entry's biboATrpStatus object to 'delete'.")
biboAdmUsrTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 18, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboATrpObj"))
if mibBuilder.loadTexts: biboAdmUsrTrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmUsrTrapEntry.setDescription('')
biboATrpObj = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 18, 1, 1), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboATrpObj.setStatus('mandatory')
if mibBuilder.loadTexts: biboATrpObj.setDescription("The object identifier of an object to use. Each time this object's value changes, a trap is created and sent. Either a single leaf (single variable) or a table (of objects) can be specified.")
biboATrpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboATrpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: biboATrpStatus.setDescription("The status of this entry. Upon creation of a new entry, this object's value is set to 'valid'.")
biboAdmDomainName = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 19), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmDomainName.setDescription('Domain name.')
biboAdmNameServer = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmNameServer.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmNameServer.setDescription('IP address of name server.')
biboAdmNameServ2 = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmNameServ2.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmNameServ2.setDescription('IP address of second name server.')
biboAdmBridgeEnable = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmBridgeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmBridgeEnable.setDescription('Sets bridging to enable / disable status.')
biboAdmCapiTcpPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmCapiTcpPort.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmCapiTcpPort.setDescription('TCP port for remote CAPI demon.')
biboAdmTraceTcpPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTraceTcpPort.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTraceTcpPort.setDescription('TCP port for trace demon.')
biboAdmRipUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmRipUdpPort.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmRipUdpPort.setDescription('UDP port for RIP. Setting this object to zero disables RIP.')
biboAdmSWVersion = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmSWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSWVersion.setDescription('This is the software release version')
biboAdmTimeServer = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 27), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTimeServer.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTimeServer.setDescription('The IP address of the time server.')
biboAdmTimeOffset = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTimeOffset.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTimeOffset.setDescription('This is the time offset from GMT in seconds. If the set value is in the range from -24 to 24, it means hours, and is automatically converted to seconds.')
biboAdmConsoleSyslog = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmConsoleSyslog.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmConsoleSyslog.setDescription('Specifies whether to direct syslog messages to the console.')
biboAdmSyslogTableLevel = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emerg", 1), ("alert", 2), ("crit", 3), ("err", 4), ("warning", 5), ("notice", 6), ("info", 7), ("debug", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmSyslogTableLevel.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSyslogTableLevel.setDescription('Specifies which message levels to post to the biboAdmSyslogTable and the console, if applicable.')
biboAdmSystemId = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 31), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmSystemId.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSystemId.setDescription('This object contains the system Identification String.')
biboAdmLicInfoTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 32), )
if mibBuilder.loadTexts: biboAdmLicInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoTable.setDescription('This table contains an entry for each feature, that can be activated by a license. The licenses have to be entered in the biboAdmLicenseTable. This tabl indicates the current state of the different licenses.')
biboAdmLicInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboAdmLicInfoType"), (0, "BIANCA-BRICK-MIB", "biboAdmLicInfoStatus"))
if mibBuilder.loadTexts: biboAdmLicInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoEntry.setDescription('')
biboAdmLicInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 33, 128, 129, 130, 131, 132))).clone(namedValues=NamedValues(("ip", 1), ("capi", 2), ("bridge", 3), ("x25", 4), ("ipx", 5), ("stac", 6), ("frame-relay", 7), ("tapi", 8), ("ospf", 9), ("extended-lan", 10), ("tunneling", 11), ("taf", 12), ("extended-wan", 13), ("leased-line", 14), ("ipsec", 33), ("ethernet", 128), ("bri", 129), ("g703", 130), ("pri", 131), ("modem", 132)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmLicInfoType.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoType.setDescription('The licenseable feature.')
biboAdmLicInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("builtin", 1), ("valid-license", 2), ("invalid-license", 3), ("no-license", 4), ("erase-internal", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmLicInfoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoStatus.setDescription('The current state of the license.')
biboAdmLicInfoId = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmLicInfoId.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoId.setDescription('The complete serial id string of the special license.')
biboAdmLicInfoSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmLicInfoSlot.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoSlot.setDescription('In case of a hardware license corresponding to a dedicated module serial number, it is the slot number of the module.')
biboAdmLicInfoMaxLic = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmLicInfoMaxLic.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoMaxLic.setDescription('The max number of allowed chunks.')
biboAdmLicInfoInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmLicInfoInUse.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoInUse.setDescription('The current number of chunks in use.')
biboAdmLicInfoHwSerial = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmLicInfoHwSerial.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoHwSerial.setDescription('The complete serial id string of the special license.')
biboAdmLicInfoUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 32, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboAdmLicInfoUnit.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLicInfoUnit.setDescription('In case of a hardware license corresponding to a dedicated module serial number, it is the unit number of the module.')
biboAdmBootpRelayServer = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 33), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmBootpRelayServer.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmBootpRelayServer.setDescription('This object contains the destination IP address to which BOOTP/DHCP request are forwarded by the BIANCA/BRICK BOOTP relay agent. If this entry is empty no BOOTP forwarding is done.')
biboAdmRadiusServer = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 34), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmRadiusServer.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmRadiusServer.setDescription('This object contains the IP address of the RADIUS server (remote dial in user service). If set to 0.0.0.0 RADIUS services are generally disabled (default). The corresponding Radius password is configured in the biboAdmRadiusSecret variable.')
biboAdmLocalPPPIdent = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 35), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmLocalPPPIdent.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmLocalPPPIdent.setDescription('This is the local ID string used for PPP authentication (PAP/CHAP). In pre4.3 versions the sysName has been used as the local ID string. This is, for increased ease and transparency of system configuration, no longer true.')
biboAdmHttpTcpPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmHttpTcpPort.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmHttpTcpPort.setDescription('TCP port for the HTTP server. Default port is 80, 0 disables the HTTP server.')
biboAdmTapiTcpPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTapiTcpPort.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTapiTcpPort.setDescription('TCP port for remote TAPI demon.')
biboAdmTimeProtocol = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("time-udp", 2), ("time-tcp", 3), ("time-sntp", 4), ("isdn", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTimeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTimeProtocol.setDescription('This field specifies from which source the bricks internal clock is synchronised: none(1) = no time synchronisation time-udp(2) = UDP/TIME (RFC 868), from biboAdmTimeServer time-tcp(3) = TCP/TIME (RFC 868), from biboAdmTimeServer time-sntp(4) = SNTP (RFC 1769), from biboAdmTimeServer isdn(5) = examines ISDN time, from controller stack 0')
biboAdmTimeUpdate = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 39), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmTimeUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmTimeUpdate.setDescription('This is the intervall for timeserver requests (in seconds). If the set value is in the range from -24 to 24, it means hours, and is automatically converted to seconds. If the time comes from ISDN, the time is updated with the next call after this intervall.')
biboAdmWINS1 = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 40), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmWINS1.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmWINS1.setDescription('The IP address of the WINS server (NetBIOS Name Server).')
biboAdmWINS2 = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 41), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmWINS2.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmWINS2.setDescription('The IP address of the alternate WINS server.')
admin_2 = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 22)).setLabel("admin-2")
biboAdmCardTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 1, 42), )
if mibBuilder.loadTexts: biboAdmCardTable.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmCardTable.setDescription('The biboAdmCardTable lists installed cards.')
biboAdmCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1), ).setIndexNames((0, "BIANCA-BRICK-MIB", "biboACrdSlot"))
if mibBuilder.loadTexts: biboAdmCardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmCardEntry.setDescription('')
biboACrdSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboACrdSlot.setStatus('mandatory')
if mibBuilder.loadTexts: biboACrdSlot.setDescription('The slot, or location of this card.')
biboACrdType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboACrdType.setStatus('mandatory')
if mibBuilder.loadTexts: biboACrdType.setDescription('The name of this card.')
biboACrdState = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("down", 1), ("running", 2), ("fail", 3), ("stopped", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboACrdState.setStatus('mandatory')
if mibBuilder.loadTexts: biboACrdState.setDescription('State of the card.')
biboACrdCpldVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboACrdCpldVersion.setStatus('mandatory')
if mibBuilder.loadTexts: biboACrdCpldVersion.setDescription('Version of onboard CPLD.')
biboACrdFpgaVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboACrdFpgaVersion.setStatus('mandatory')
if mibBuilder.loadTexts: biboACrdFpgaVersion.setDescription('Version of loaded FPGA firmware.')
biboACrdTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboACrdTemp.setStatus('mandatory')
if mibBuilder.loadTexts: biboACrdTemp.setDescription('This variable shows the actual card temperature in the unit Celsius.')
biboACrdTempAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboACrdTempAlarmThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: biboACrdTempAlarmThreshold.setDescription('Card temperature threshold.')
biboACrdTempAlarmTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 1, 42, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("critical", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: biboACrdTempAlarmTrap.setStatus('mandatory')
if mibBuilder.loadTexts: biboACrdTempAlarmTrap.setDescription('If the card temperature raises above the threshold, a trap is generated every 60 seconds.')
biboAdmTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 1, 43))
biboAdmTrapACrdTempCritical = NotificationType((1, 3, 6, 1, 4, 1, 272, 4, 1, 43) + (0,1)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("BIANCA-BRICK-MIB", "biboACrdSlot"), ("BIANCA-BRICK-MIB", "biboACrdType"), ("BIANCA-BRICK-MIB", "biboACrdState"), ("BIANCA-BRICK-MIB", "biboACrdTemp"), ("BIANCA-BRICK-MIB", "biboACrdTempAlarmThreshold"))
if mibBuilder.loadTexts: biboAdmTrapACrdTempCritical.setDescription('This trap signifies that the Card temperature raises above the critical alarm-threshold')
biboAdmTrapACrdTempOk = NotificationType((1, 3, 6, 1, 4, 1, 272, 4, 1, 43) + (0,2)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("BIANCA-BRICK-MIB", "biboACrdSlot"), ("BIANCA-BRICK-MIB", "biboACrdType"), ("BIANCA-BRICK-MIB", "biboACrdState"), ("BIANCA-BRICK-MIB", "biboACrdTemp"), ("BIANCA-BRICK-MIB", "biboACrdTempAlarmThreshold"))
if mibBuilder.loadTexts: biboAdmTrapACrdTempOk.setDescription('A normal Card temperature has been restored.')
biboAdmTrapACrdDown = NotificationType((1, 3, 6, 1, 4, 1, 272, 4, 1, 43) + (0,3)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("BIANCA-BRICK-MIB", "biboACrdSlot"), ("BIANCA-BRICK-MIB", "biboACrdType"), ("BIANCA-BRICK-MIB", "biboACrdState"), ("BIANCA-BRICK-MIB", "biboACrdTemp"))
if mibBuilder.loadTexts: biboAdmTrapACrdDown.setDescription('This trap signifies that the specified Card is down')
biboAdmTrapACrdRunning = NotificationType((1, 3, 6, 1, 4, 1, 272, 4, 1, 43) + (0,4)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("BIANCA-BRICK-MIB", "biboACrdSlot"), ("BIANCA-BRICK-MIB", "biboACrdType"), ("BIANCA-BRICK-MIB", "biboACrdState"), ("BIANCA-BRICK-MIB", "biboACrdTemp"))
if mibBuilder.loadTexts: biboAdmTrapACrdRunning.setDescription('This trap signifies that the specified Card is up/running')
biboAdmTrapACrdFailed = NotificationType((1, 3, 6, 1, 4, 1, 272, 4, 1, 43) + (0,5)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("BIANCA-BRICK-MIB", "biboACrdSlot"), ("BIANCA-BRICK-MIB", "biboACrdType"), ("BIANCA-BRICK-MIB", "biboACrdState"), ("BIANCA-BRICK-MIB", "biboACrdTemp"))
if mibBuilder.loadTexts: biboAdmTrapACrdFailed.setDescription('This trap signifies that the specified Card has failed')
biboAdmTrapACrdStopped = NotificationType((1, 3, 6, 1, 4, 1, 272, 4, 1, 43) + (0,6)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("BIANCA-BRICK-MIB", "biboACrdSlot"), ("BIANCA-BRICK-MIB", "biboACrdType"), ("BIANCA-BRICK-MIB", "biboACrdState"), ("BIANCA-BRICK-MIB", "biboACrdTemp"))
if mibBuilder.loadTexts: biboAdmTrapACrdStopped.setDescription('This trap signifies that the specified Card is stopped')
biboAdmSnmpLinkTrapEvent = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("any", 2), ("up", 3), ("down", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboAdmSnmpLinkTrapEvent.setStatus('mandatory')
if mibBuilder.loadTexts: biboAdmSnmpLinkTrapEvent.setDescription('Defines the ifOperStatus transition(s) of an ifTable object that generates a SNMP linkUp/linkDown trap: none : disable linkUp/linkDown trap generation. any : enable bintec like trap generation. - entering the up state generates a up trap - any other state change generates a down trap up : enable rfc1157 like trap generation. - entering the up state generates a up trap - leaving the up state generates a down trap down : enable rfc2233 like trap generation. - leaving the down state generates a up trap - entering the down state generates a down trap Seven parameters are sent in each linkUp/linkDown trap pdu: 1. ifEntry.ifIndex (mandatory for linkUp/Down traps) 2. ifEntry.ifDescr 3. ifEntry.ifType 4. ifEntry.ifAdminStatus 5. ifEntry.ifOperStatus 6. system.Description 7. system.Name')
extadmin = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 22, 1))
biboExtAdmMonAddress = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 22, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboExtAdmMonAddress.setStatus('mandatory')
if mibBuilder.loadTexts: biboExtAdmMonAddress.setDescription('The IP address of the host machine running the Activity Monitor program. This program displays the information about the current state of all interfaces. Periodically UDP packets are send to this IP address, to refresh the data automatically on the target host. The value 255.255.255.255 represents the broadcast address of the first LAN interface (e.g. 10.255.255.255), so more than one Activity Monitor on different hosts can receive the data.')
biboExtAdmMonPort = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 22, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboExtAdmMonPort.setStatus('mandatory')
if mibBuilder.loadTexts: biboExtAdmMonPort.setDescription('UDP port for the Activity Monitor protocol.')
biboExtAdmMonType = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 22, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("physical", 2), ("physical-virt", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboExtAdmMonType.setStatus('mandatory')
if mibBuilder.loadTexts: biboExtAdmMonType.setDescription('This parameter configures the content of the Activity Monitor packets, or disables it: off : Activity Monitor disabled physical : send only physical interfaces information physical-virt: send physical and virtual interface information.')
biboExtAdmMonUpdate = MibScalar((1, 3, 6, 1, 4, 1, 272, 4, 22, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: biboExtAdmMonUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: biboExtAdmMonUpdate.setDescription('This is the time interval for the Activity Monitor for sending packets (in seconds) to the specified IP address. The value of 0 disables sending Activity Monitor packets.')
mibBuilder.exportSymbols("BIANCA-BRICK-MIB", biboAdmConfigFile=biboAdmConfigFile, biboAdmConfigState=biboAdmConfigState, biboACrdTempAlarmTrap=biboACrdTempAlarmTrap, biboExtAdmMonAddress=biboExtAdmMonAddress, internet=internet, biboAdmBridgeEnable=biboAdmBridgeEnable, admin_2=admin_2, biboAdmTimeOffset=biboAdmTimeOffset, biboACrdTemp=biboACrdTemp, biboATrpObj=biboATrpObj, biboAdmLicInfoInUse=biboAdmLicInfoInUse, PhysAddress=PhysAddress, biboAdmLicInfoId=biboAdmLicInfoId, biboAdmSyslogTable=biboAdmSyslogTable, biboAdmRipUdpPort=biboAdmRipUdpPort, biboAdmLicInfoHwSerial=biboAdmLicInfoHwSerial, biboAdmConfigTable=biboAdmConfigTable, biboACrdState=biboACrdState, biboAdmTrapACrdTempOk=biboAdmTrapACrdTempOk, biboAdmSyslogTableLevel=biboAdmSyslogTableLevel, biboAdmCardEntry=biboAdmCardEntry, biboAdmTrapACrdFailed=biboAdmTrapACrdFailed, biboABrdConnector=biboABrdConnector, biboAdmTimeUpdate=biboAdmTimeUpdate, biboAdmLicInfoStatus=biboAdmLicInfoStatus, biboAdmTrapHostStatus=biboAdmTrapHostStatus, biboABrdType=biboABrdType, biboAdmTapiTcpPort=biboAdmTapiTcpPort, biboAdmLocalPPPIdent=biboAdmLocalPPPIdent, biboAdmConfigCmd=biboAdmConfigCmd, admin=admin, biboACrdCpldVersion=biboACrdCpldVersion, biboAdmLicInfoEntry=biboAdmLicInfoEntry, biboAdmBootpRelayServer=biboAdmBootpRelayServer, biboAdmSyslogMaxEntries=biboAdmSyslogMaxEntries, biboAdmCapiTcpPort=biboAdmCapiTcpPort, biboAdmTimeServer=biboAdmTimeServer, bintec=bintec, DisplayString=DisplayString, biboAdmWINS1=biboAdmWINS1, biboAdmConfigPath=biboAdmConfigPath, biboAdmLogHostAddr=biboAdmLogHostAddr, bibo=bibo, biboAdmDomainName=biboAdmDomainName, biboAdmTrapBrdCast=biboAdmTrapBrdCast, HexValue=HexValue, biboAdmConfigHost=biboAdmConfigHost, biboAdmConsoleSyslog=biboAdmConsoleSyslog, biboAdmTrapHostTable=biboAdmTrapHostTable, biboAdmTrapHostAddr=biboAdmTrapHostAddr, biboAdmLicInfoSlot=biboAdmLicInfoSlot, biboACrdType=biboACrdType, biboAdmRadiusServer=biboAdmRadiusServer, biboACrdFpgaVersion=biboACrdFpgaVersion, biboAdmSWVersion=biboAdmSWVersion, biboAdmLicInfoMaxLic=biboAdmLicInfoMaxLic, biboAdmTrapACrdDown=biboAdmTrapACrdDown, biboAdmConfigDirContent=biboAdmConfigDirContent, biboAdmHttpTcpPort=biboAdmHttpTcpPort, biboAdmBoardTable=biboAdmBoardTable, biboExtAdmMonType=biboExtAdmMonType, biboAdmLogHostFacility=biboAdmLogHostFacility, biboAdmLogHostLevel=biboAdmLogHostLevel, extadmin=extadmin, biboAdmSyslogEntry=biboAdmSyslogEntry, biboAdmTrapACrdRunning=biboAdmTrapACrdRunning, biboAdmLogHostType=biboAdmLogHostType, biboAdmCardTable=biboAdmCardTable, biboABrdFWRelease=biboABrdFWRelease, biboAdmLogHostEntry=biboAdmLogHostEntry, biboAdmConfigObject=biboAdmConfigObject, biboAdmUsrTrapEntry=biboAdmUsrTrapEntry, biboABrdSlot=biboABrdSlot, biboAdmConfigDirCount=biboAdmConfigDirCount, biboABrdSerialNo=biboABrdSerialNo, biboAdmSnmpVersion=biboAdmSnmpVersion, biboAdmSyslogTimeStamp=biboAdmSyslogTimeStamp, biboAdmSyslogSubject=biboAdmSyslogSubject, biboAdmNameServer=biboAdmNameServer, private=private, Date=Date, biboATrpStatus=biboATrpStatus, biboACrdTempAlarmThreshold=biboACrdTempAlarmThreshold, biboAdmTraps=biboAdmTraps, biboABrdHWRelease=biboABrdHWRelease, biboACrdSlot=biboACrdSlot, biboAdmSystemId=biboAdmSystemId, biboAdmConfigDirTable=biboAdmConfigDirTable, biboAdmSnmpPort=biboAdmSnmpPort, biboAdmLicInfoUnit=biboAdmLicInfoUnit, biboExtAdmMonPort=biboExtAdmMonPort, biboAdmConfigPathNew=biboAdmConfigPathNew, biboAdmLicInfoTable=biboAdmLicInfoTable, biboAdmIpAddr=biboAdmIpAddr, biboAdmTrapCommunity=biboAdmTrapCommunity, biboAdmBoardEntry=biboAdmBoardEntry, biboAdmLicInfoType=biboAdmLicInfoType, enterprises=enterprises, biboAdmNameServ2=biboAdmNameServ2, biboAdmWINS2=biboAdmWINS2, biboAdmSyslogMessage=biboAdmSyslogMessage, biboAdmTraceTcpPort=biboAdmTraceTcpPort, biboAdmTimeProtocol=biboAdmTimeProtocol, biboAdmSnmpLinkTrapEvent=biboAdmSnmpLinkTrapEvent, biboAdmSyslogLevel=biboAdmSyslogLevel, org=org, biboAdmLogHostTable=biboAdmLogHostTable, biboAdmLogHostTimestamp=biboAdmLogHostTimestamp, biboAdmUsrTrapTable=biboAdmUsrTrapTable, biboAdmSnmpTrapPort=biboAdmSnmpTrapPort, biboABrdPartNo=biboABrdPartNo, dod=dod, biboAdmTrapHostEntry=biboAdmTrapHostEntry, biboAdmConfigDirEntry=biboAdmConfigDirEntry, biboABrdUnit=biboABrdUnit, biboAdmConfigDirName=biboAdmConfigDirName, biboAdmTrapACrdStopped=biboAdmTrapACrdStopped, biboAdmConfigEntry=biboAdmConfigEntry, biboExtAdmMonUpdate=biboExtAdmMonUpdate, biboAdmTrapACrdTempCritical=biboAdmTrapACrdTempCritical)

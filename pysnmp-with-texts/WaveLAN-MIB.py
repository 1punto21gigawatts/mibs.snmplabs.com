#
# PySNMP MIB module WaveLAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/WaveLAN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:38:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, Counter64, ObjectIdentity, IpAddress, MibIdentifier, Unsigned32, enterprises, Counter32, NotificationType, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Bits, Gauge32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Counter64", "ObjectIdentity", "IpAddress", "MibIdentifier", "Unsigned32", "enterprises", "Counter32", "NotificationType", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Bits", "Gauge32", "TimeTicks")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
att_2 = MibIdentifier((1, 3, 6, 1, 4, 1, 74)).setLabel("att-2")
att_mgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2)).setLabel("att-mgmt")
wavelan = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 21))
wavelanInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 74, 2, 21, 1))
wliNicTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 1), )
if mibBuilder.loadTexts: wliNicTable.setStatus('mandatory')
if mibBuilder.loadTexts: wliNicTable.setDescription('Network Interface Card information for a collection of WaveLAN interfaces attached to a particular system.')
wliNicEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 1, 1), ).setIndexNames((0, "WaveLAN-MIB", "wliNicIndex"))
if mibBuilder.loadTexts: wliNicEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wliNicEntry.setDescription('Network Interface Card information for a particular WaveLAN interface.')
wliNicIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliNicIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wliNicIndex.setDescription('An index value that uniquely identifies a WaveLAN network interface this NIC information applies to. The interface associated with a particular value of this index is the same interface as identified by the same value of ifIndex.')
wliNicBusType = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("xtBus", 1), ("isaBus", 2), ("mcBus", 3), ("pcmcia2Bus", 4), ("wavepointBus", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliNicBusType.setStatus('mandatory')
if mibBuilder.loadTexts: wliNicBusType.setDescription('The bus-type supported by this NIC.')
wliNicSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliNicSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wliNicSlot.setDescription("The I/O Base Address (ISA/AT) or Slot Number (MC) or Socket Number (PCMCIA) used by this NIC. For ISA/AT (and alike) Base Addresses, the following values are used: 1='0300'H, 2='0390'H, 3='03C0'H, 4='03E0'H")
wliNicIrq = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliNicIrq.setStatus('mandatory')
if mibBuilder.loadTexts: wliNicIrq.setDescription('The Interrupt Request Number (IRQ) used by this NIC.')
wliNicError = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliNicError.setStatus('mandatory')
if mibBuilder.loadTexts: wliNicError.setDescription('A counter for miscellaneous board errors. It indicates (intermittent) NIC hardware problems.')
wliNicOutOfRxResource = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliNicOutOfRxResource.setStatus('mandatory')
if mibBuilder.loadTexts: wliNicOutOfRxResource.setDescription('A counter for the number of times the NIC is out of resources for the receiver, causing the receiver to be switched off temporarily.')
wliPhyTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2), )
if mibBuilder.loadTexts: wliPhyTable.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyTable.setDescription('PHY status information and control variables for a collection of WaveLAN interfaces attached to a particular system.')
wliPhyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1), ).setIndexNames((0, "WaveLAN-MIB", "wliPhyIndex"))
if mibBuilder.loadTexts: wliPhyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyEntry.setDescription('PHY status information and control variables for a particular WaveLAN interface.')
wliPhyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyIndex.setDescription('An index value that uniquely identifies a WaveLAN network interface this PHY information applies to. The interface associated with a particular value of this index is the same interface as identified by the same value of ifIndex.')
wliPhyDsp = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("icarus", 1), ("daedalus", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyDsp.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyDsp.setDescription('The Digital Signal Processor on the board.')
wliPhyFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("f915Mhz", 1), ("f2425Mhz", 2), ("f2460Mhz", 3), ("f2484Mhz", 4), ("f2430Mhz", 5), ("f2412Mhz", 6), ("f2422Mhz", 7), ("f2432Mhz", 8), ("f2442Mhz", 9), ("f2452Mhz", 10), ("f2462Mhz", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyFrequency.setDescription('The mid-point of the frequency band this WaveLAN NIC operates in.')
wliPhyNwid = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wliPhyNwid.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyNwid.setDescription('The WaveLAN Network ID (NWID) this RF-modem is currently configured for.')
wliPhyRfSilenceLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 36))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyRfSilenceLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyRfSilenceLevel.setDescription('The RF Silence Level as currently read from the RF modem.')
wliPhyOwnNwid = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyOwnNwid.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyOwnNwid.setDescription('Own NWID counter; the number of frames received with the configured NWID.')
wliPhyOtherNwid = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyOtherNwid.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyOtherNwid.setDescription('Other NWID counter; the number of frames received with different NWID than configured.')
wliPhyLowSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyLowSnr.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyLowSnr.setDescription('The number of times the Signal to Noise Ratio (sample) of a frame reception was low.')
wliPhyGoodSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyGoodSnr.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyGoodSnr.setDescription('The number of times the Signal to Noise Ratio (sample) of a frame reception was good.')
wliPhyExcellentSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliPhyExcellentSnr.setStatus('mandatory')
if mibBuilder.loadTexts: wliPhyExcellentSnr.setDescription('The number of times the Signal to Noise Ratio (sample) of a frame reception was excellent.')
wliMacTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3), )
if mibBuilder.loadTexts: wliMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacTable.setDescription('MAC status information and control variables for a collection of WaveLAN interfaces attached to a particular system.')
wliMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1), ).setIndexNames((0, "WaveLAN-MIB", "wliMacIndex"))
if mibBuilder.loadTexts: wliMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacEntry.setDescription('MAC status information and control variables for a particular WaveLAN interface.')
wliMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacIndex.setDescription('An index value that uniquely identifies a WaveLAN network interface this MAC information applies to. The interface associated with a particular value of this index is the same interface as identified by the same value of ifIndex.')
wliMacAddressSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("universal", 1), ("local", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMacAddressSelect.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacAddressSelect.setDescription('MAC Address type select.')
wliMacCaDefers = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMacCaDefers.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacCaDefers.setDescription('CSMA/CA Defer counter.')
wliMacDeferredTransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMacDeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacDeferredTransmissions.setDescription('A counter for the number of frames for which the transmission attempt is delayed because the medium is busy. (same as dot3StatsDeferredTransmissions)')
wliMacFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMacFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacFCSErrors.setDescription('A counter for the number of frames received that do not pass the FCS check and/or that are not an integral number of octets in length. WaveLAN hardware does not distinguish between FCS errors and Alignment errors. (same as dot3StatsFCSErrors + dot3StatsAlignmentErrors)')
wliMacFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMacFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacFrameTooLongs.setDescription('A counter for the number of frames received that exceed the maximum permitted frame size for the medium (1518 bytes). (same as dot3StatsFrameTooLongs)')
wliMacFrameTooShorts = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMacFrameTooShorts.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacFrameTooShorts.setDescription('A counter for the number of frames received that are shorter than the minimum permitted frame size for the medium (64 bytes)')
wliMacDeferLimits = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMacDeferLimits.setStatus('mandatory')
if mibBuilder.loadTexts: wliMacDeferLimits.setDescription('The number of times a frame is not transmitted because the CSMA/CA defer limit is reached ')
wliDriverTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 4), )
if mibBuilder.loadTexts: wliDriverTable.setStatus('mandatory')
if mibBuilder.loadTexts: wliDriverTable.setDescription('Driver information for a collection of WaveLAN interfaces attached to a particular system.')
wliDriverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 4, 1), ).setIndexNames((0, "WaveLAN-MIB", "wliDriverIndex"))
if mibBuilder.loadTexts: wliDriverEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wliDriverEntry.setDescription('Driver information for a particular WaveLAN interface.')
wliDriverIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliDriverIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wliDriverIndex.setDescription('An index value that uniquely identifies a WaveLAN network interface this driver information applies to. The interface associated with a particular value of this index is the same interface as identified by the same value of ifIndex.')
wliDriverName = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliDriverName.setStatus('mandatory')
if mibBuilder.loadTexts: wliDriverName.setDescription('The name of the software driver for this WaveLAN network interface.')
wliDriverVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliDriverVersion.setStatus('mandatory')
if mibBuilder.loadTexts: wliDriverVersion.setDescription("The version number of the software driver. A text string as 'mm.nn.pp', where mm = major release number nn = point release number pp = optional patch number")
wliEncTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 5), )
if mibBuilder.loadTexts: wliEncTable.setStatus('mandatory')
if mibBuilder.loadTexts: wliEncTable.setDescription('Encryption status information and control variables for a collection of WaveLAN interfaces attached to a particular system.')
wliEncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 5, 1), ).setIndexNames((0, "WaveLAN-MIB", "wliEncIndex"))
if mibBuilder.loadTexts: wliEncEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wliEncEntry.setDescription('Encryption status information and control variables for a particular WaveLAN interface.')
wliEncIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliEncIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wliEncIndex.setDescription('An index value that uniquely identifies a WaveLAN network interface this encryption information applies to. The interface associated with a particular value of this index is the same interface as identified by the same value of ifIndex.')
wliEncInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("des", 2), ("aes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliEncInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: wliEncInstalled.setDescription('Which encryption option is installed.')
wliEncSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliEncSelect.setStatus('mandatory')
if mibBuilder.loadTexts: wliEncSelect.setDescription('Whether encryption is enabled or disabled.')
wliEncKey = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("writeonly")
if mibBuilder.loadTexts: wliEncKey.setStatus('mandatory')
if mibBuilder.loadTexts: wliEncKey.setDescription('The encryption key.')
wliMcastDelayTable = MibTable((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 6), )
if mibBuilder.loadTexts: wliMcastDelayTable.setStatus('mandatory')
if mibBuilder.loadTexts: wliMcastDelayTable.setDescription('Information about the Multicast Delay feature for a collection of WaveLAN interfaces attached to a particular system.')
wliMcastDelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 6, 1), ).setIndexNames((0, "WaveLAN-MIB", "wliMcastDelayIndex"))
if mibBuilder.loadTexts: wliMcastDelayEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wliMcastDelayEntry.setDescription('Information about the Multicast Delay feature for a particular WaveLAN interface.')
wliMcastDelayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wliMcastDelayIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wliMcastDelayIndex.setDescription('An index value that uniquely identifies a WaveLAN network interface this Multicast Delay information applies to. The interface associated with a particular value of this index is the same interface as identified by the same value of wliIndex (and ifIndex).')
wliMcastNumberOfAps = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wliMcastNumberOfAps.setStatus('mandatory')
if mibBuilder.loadTexts: wliMcastNumberOfAps.setDescription('The total number of Access Points in the coverage area. Together with wliMcastApSequenceNumber this is used to determine the delays before and after the transmission of each multicast frame. This results in a transmission slot per Access Point per multicast frame. 0 means: no multicast delay specified (use default mechanism).')
wliMcastApSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wliMcastApSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wliMcastApSequenceNumber.setDescription('The sequence number of this Access Point in the coverage area. Together with wliMcastNumberOfAps this is used to determine the delays before and after the transmission of each multicast frame. This results in a transmission slot per Access Point per multicast frame.')
wliMcastRepeatCount = MibTableColumn((1, 3, 6, 1, 4, 1, 74, 2, 21, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wliMcastRepeatCount.setStatus('mandatory')
if mibBuilder.loadTexts: wliMcastRepeatCount.setDescription('The number of times a multicast frame transmission is to be repeated.')
mibBuilder.exportSymbols("WaveLAN-MIB", wliPhyOwnNwid=wliPhyOwnNwid, wliDriverTable=wliDriverTable, wliDriverIndex=wliDriverIndex, wliPhyGoodSnr=wliPhyGoodSnr, wliNicEntry=wliNicEntry, wliMacDeferLimits=wliMacDeferLimits, wliPhyFrequency=wliPhyFrequency, wliNicIndex=wliNicIndex, att_2=att_2, wavelan=wavelan, wliMcastDelayTable=wliMcastDelayTable, wliNicIrq=wliNicIrq, wliMcastDelayIndex=wliMcastDelayIndex, wliNicBusType=wliNicBusType, wliMacAddressSelect=wliMacAddressSelect, wliMacTable=wliMacTable, wliMacFrameTooLongs=wliMacFrameTooLongs, wliEncTable=wliEncTable, wliPhyOtherNwid=wliPhyOtherNwid, wliMacFrameTooShorts=wliMacFrameTooShorts, wliPhyRfSilenceLevel=wliPhyRfSilenceLevel, wliMacDeferredTransmissions=wliMacDeferredTransmissions, wliEncIndex=wliEncIndex, wliEncKey=wliEncKey, wliMcastNumberOfAps=wliMcastNumberOfAps, wliMcastDelayEntry=wliMcastDelayEntry, wliDriverEntry=wliDriverEntry, wliPhyExcellentSnr=wliPhyExcellentSnr, wliPhyDsp=wliPhyDsp, wliPhyIndex=wliPhyIndex, wliNicSlot=wliNicSlot, wliPhyTable=wliPhyTable, wliMcastApSequenceNumber=wliMcastApSequenceNumber, wliDriverName=wliDriverName, wliMacEntry=wliMacEntry, wliMacCaDefers=wliMacCaDefers, wliMacIndex=wliMacIndex, wliMcastRepeatCount=wliMcastRepeatCount, wliPhyLowSnr=wliPhyLowSnr, wliEncSelect=wliEncSelect, att_mgmt=att_mgmt, wavelanInterface=wavelanInterface, wliNicOutOfRxResource=wliNicOutOfRxResource, wliPhyNwid=wliPhyNwid, wliEncInstalled=wliEncInstalled, wliMacFCSErrors=wliMacFCSErrors, wliNicError=wliNicError, wliEncEntry=wliEncEntry, wliDriverVersion=wliDriverVersion, wliNicTable=wliNicTable, wliPhyEntry=wliPhyEntry)

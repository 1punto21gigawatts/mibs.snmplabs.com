#
# PySNMP MIB module Nortel-Magellan-Passport-AtmBaseMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-AtmBaseMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:16 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
lp, lpEng, lpEngIndex, lpIndex = mibBuilder.importSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", "lp", "lpEng", "lpEngIndex", "lpIndex")
Integer32, DisplayString, RowStatus, Gauge32, StorageType, Unsigned32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "Integer32", "DisplayString", "RowStatus", "Gauge32", "StorageType", "Unsigned32")
NonReplicated, FixedPoint1 = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "NonReplicated", "FixedPoint1")
passportMIBs, = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter64, ModuleIdentity, TimeTicks, iso, MibIdentifier, ObjectIdentity, NotificationType, Gauge32, Counter32, Bits, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter64", "ModuleIdentity", "TimeTicks", "iso", "MibIdentifier", "ObjectIdentity", "NotificationType", "Gauge32", "Counter32", "Bits", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
atmBaseMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63))
lpArc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19))
lpArcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 1), )
if mibBuilder.loadTexts: lpArcRowStatusTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcRowStatusTable.setDescription('This entry controls the addition and deletion of lpArc components.')
lpArcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpArcIndex"))
if mibBuilder.loadTexts: lpArcRowStatusEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcRowStatusEntry.setDescription('A single entry in the table represents a single lpArc component.')
lpArcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpArc components. These components can be added and deleted.')
lpArcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpArcComponentName.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpArcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpArcStorageType.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcStorageType.setDescription('This variable represents the storage type value for the lpArc tables.')
lpArcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpArcIndex.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcIndex.setDescription('This variable represents the index for the lpArc tables.')
lpArcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100), )
if mibBuilder.loadTexts: lpArcProvTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcProvTable.setDescription('This group specifies the configuration of processor-wide ATM- specific resources on a Logical Processor running ATM services. Note that altering any of these parameters results in a card reset.')
lpArcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpArcIndex"))
if mibBuilder.loadTexts: lpArcProvEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcProvEntry.setDescription('An entry in the lpArcProvTable.')
lpArcTotalConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752)).clone(3072)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcTotalConnectionPoolCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcTotalConnectionPoolCapacity.setDescription('This attribute is migrated to the Lp/n Eng Arc Ov attribute of the same name. This attribute specifies the maximum number of connections (both VCC and VPC) that can be enabled on the LogicalProcessor. If the LogicalProcessor is associated with a card of a cardType other than one of the following: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm; the value of the attribute restricts the sum of the (maxVccs + maxVpcs) across all AtmIfs bound to this LogicalProcessor. If the LogicalProcessor is associated with a card of one of the following cardTypes: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm; the number of available connections are distributed equally across the ports on the FP. The number of connections associated to a particular port will limit the size of the Vcc space defined by the ConnMap of the AtmIf linked to the port. Furthermore, the value of this attribute is restricted based on the number of ports on the card. For one port cards, the minimum is 512, the maximum is 4096 and the value must be divisible by 256. For two port cards, the minimum is 1024, the maximum is 8192 and the value must be divisible by 512. For three port cards, the minimum is 1536, the maximum is 7680 and the value must be divisible by 768. Increasing the value of this attribute reduces the CQM memory available for cell and frame free list. This attribute must be set to 0 if the connectionPoolCapacity attribute is set to non-zero values.')
lpArcMulticastBranchesCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcMulticastBranchesCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcMulticastBranchesCapacity.setDescription('This attribute is migrated to the Lp/n Eng Arc Ov attribute of the same name. This attribute specifies the number of multicast branches that can be enabled on the Logical Processor. A multicast branch is used for cell replication on a Vcc connection whose Vcc distributionType is pointToMultipoint. A branch represent one ATM destination for the replicated cells Increasing the value of this attribute reduces the CQM memory available for the cell and frame free lists.')
lpArcTxFrameMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcTxFrameMemoryAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcTxFrameMemoryAllocation.setDescription('This attribute is migrated to the Lp/n Eng Arc Ov attribute txCellMemoryAllocation. It is converted from frame percentage to cell percentage by subtracting this value from 100. This attribute specifies the percentage of the transmit CQM memory which should be allocated to the transmit frame free list on the ATM-FP. The remaining transmit CQM memory is allocated to the transmit cell free list. Frame memory is used for trunks, ATM VCC testing and for inter-card communication. There is an absolute minimum quantity of frame buffers which is required by ATM software on the FP. If the value of this attribute is smaller than the absolute minimum, the ATM software will allocate the minimum required, rather than the actual number requested. The actual percentage of the transmit CQM memory allocated to the transmit frame free list is indicated by the Aru txFrameMemoryAllocation attribute. A difference between the provisioned and the operational values may exist due to the requirement for a minimum number of frame buffers or rounding during computation within the FP.')
lpArcRxFrameMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcRxFrameMemoryAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcRxFrameMemoryAllocation.setDescription('This attribute is migrated to the Lp/n Eng Arc Ov attribute rxCellMemoryAllocation. It is converted from frame percentage to cell percentage by subtracting this value from 100. This attribute specifies the percentage of the receive CQM memory which should be allocated to the receive frame free list on the ATM- FP. The remaining receive CQM memory is allocated to the receive cell free list. Frame memory is used for trunks, ATM VCC testing and for inter-card communication. There is an absolute minimum quantity of frame buffers which is required by ATM software on the FP. If the value of this attribute is smaller than the absolute minimum, the ATM software will allocate the minimum required, rather than the actual number requested. The actual percentage of the receive CQM memory allocated to the receive frame free list is indicated by the Aru rxFrameMemoryAllocation attribute. A difference between the provisioned and the operational values may exist due to the requirement for a minimum number of frame buffers or rounding during computation within the FP')
lpArcPerVcQueueInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcPerVcQueueInterfaces.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcPerVcQueueInterfaces.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute of the same name. This attribute specifies the number of independent ports or IMA components which support shaping and per-VC queueing on the LogicalProcessor. When this attribute is not zero, at most 4 independent ports or 4 Ima virtual links are supported, regardless of whether or not traffic shaping is enabled on the associated AtmIf components. In this case only independent port instances 0-3 or Ima instances 0-3 can be supported on an associated AtmIf component. For 2 ports cards, the valid values for this attribute are 0, 1, or 2. For 3 ports cards, the valid values for this attribute are 0, 1, or 3. For 8 ports cards, the valid values for this attribute are 0, 1, 2, or 4.')
lpArcShapingStackAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="80")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcShapingStackAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcShapingStackAllocation.setDescription('This attribute is migrated to the perVcQueueInterfaces attribute of the Lp/n Eng Arc Cqc Ov. Value ~0,~1,~2 is migrated to the value 0; value 0,~1,~2 is migrated to value 1; value 0,1,~2 is migrated to the value 2 and value 0,1,2 is migrated to the value 3 (for cardTypes 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm) or to the value 4 (for other cardTypes). This attribute specifies the allocation of shaping stack resources among the ports on this FP. Shaping stacks can currently be allocated on port 0, ports 0 and 1, or ports 0, 1 and 2. Allocating shaping stacks on a port allows the use of traffic shaping and per- VC queueing on that port. Description of bits: n0(0) n1(1) n2(2)')
lpArcShapingScalingFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 40), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(10, 10), ValueRangeConstraint(14, 14), ValueRangeConstraint(20, 20), ValueRangeConstraint(28, 28), ValueRangeConstraint(40, 40), ValueRangeConstraint(56, 56), )).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcShapingScalingFactor.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcShapingScalingFactor.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute of the same name. This attribute specifies the scaling factor which is to be applied to all shaping rates for this ATM-FP. The scaling factor is a multiplicative factor which is applied to the chosen shaping rate to produce an actual shaping rate. For example, if a shaping rate of 25 Mbps is used with a scaling factor of 2, the actual shaping rate is 12.5 Mbps.')
lpArcCdvAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcCdvAttenuation.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcCdvAttenuation.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute cdvReduction. This attribute enables the attenuation of the maximum Cell Delay Variation (CDV) of shaped transmit traffic. When the value of this attribute is set to off, the CDV value can be determined by the following equation: CDV <= 2/ASR + 1/LS where ASR is the Actual Shaping Rate of the connection and LS is the Link Speed of the interface. When the value of this attribute is set to on, the CDV relationship changes to the following equation: CDV <= 1/ASR + 1/LS As can be noted from the equations above, setting this attribute to on can reduce the CDV significantly. CDV attenuation may be used to conform to policers which have strict Cell Delay Variance Tolerance (CDVT). However using this function reduces the transmit bandwidth utilization of the following cards: 3pDS3Atm, 3pOC3Atm.')
lpArcPortAggregation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcPortAggregation.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcPortAggregation.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute portCongestionPolicy. This attribute specifies whether port aggregation is turned on or off for this ATM-FP. It applies only to transmit traffic served on the common queues and does not apply to perVc queues. When port aggregation is on, the enqueue decision of cells or frames to a common queue is based upon the congestion state of the entire port to which the queue belongs. A port is defined to be as congested as the most congested queue amongst all its queues: the low, medium and high emission priority queues. Thus, for example, if the low priority queue is congested, the high priority queue will also experience discards even though the high priority queue may itself not be congested. Setting port aggregation on assures that the low priority queues are also serviced in the event of congestion. When the value of this attribute is set to off, the enqueue decision of cells or frames to a common queue is based solely upon the congestion state of that queue, not the port. This setting assures that the absolute priority of the traffic is taken into account, regardless of whether or not the lower priority queues are being served.')
lpArcSubConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 43), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8192)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcSubConnectionPoolCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcSubConnectionPoolCapacity.setDescription('This attribute is migrated to the Lp/n Eng Fcrc Ov attribute of the same name. This attribute specifies the maximum number of sub-connections for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay, and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. Due to limited resources, not all of the provisioned number of sub- connections may be allocated. The actual number of sub- connections allocated is indicated by the sum of Aru subConnectionPoolAvailable and Aru SubConnectionPoolUsage attributes. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/x Dlci/y Siwf McsMgr Frf5EpG/x Frf5Ep/y Lmi McsMgr Frf5EpG/x Frf5Ep/y Dlci/z When the sub-connection pool is exhausted, no more connections will be accepted from the services which utilize this pool.')
lpArcLnnConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 100, 1, 44), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 512)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcLnnConnectionPoolCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcLnnConnectionPoolCapacity.setDescription('This attribute is migrated to the Lp/n Eng Fcrc Ov attribute of the same name. This attribute specifies the maximum number of resource records for the connections which utilize Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. A LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is allocated at the intermediate nodes to sustain these connectionless services. Due to limited resources, not all of the provisioned number of LNN connection resource records may be allocated. The actual number of resource records allocated is indicated by the sum of Aru lnnConnectionPoolAvailable and Aru lnnConnectionPoolUsage attributes. If the McsMgr DprsMcsEpG/x Ep/y EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/x Ep/y component uses one resource record from this pool.')
lpArcConnCapTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 291), )
if mibBuilder.loadTexts: lpArcConnCapTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcConnCapTable.setDescription('This attribute is migrated to the Lp/n Eng Arc Cqc Ov attribute of the same name. This attribute is provided for backward compatibility and can only be used if the LogicalProcessor is associated to a card of one of the following cardType: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm. This attribute can be used when the desired distribution of connections across ports cannot be achieved using the totalConnectionPoolCapacity attribute. This attribute defines the maximum number of connections (both VCC and VPC) that are available on each port. The entries are indexed by port number. This number limits the range of the ConnMap entries. Note that the value of this attribute must be evenly divisible by 256, and that port 2 supports at most 2560 connections, not the full 4096.')
lpArcConnCapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 291, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpArcConnCapIndex"))
if mibBuilder.loadTexts: lpArcConnCapEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcConnCapEntry.setDescription('An entry in the lpArcConnCapTable.')
lpArcConnCapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 291, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: lpArcConnCapIndex.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcConnCapIndex.setDescription('This variable represents the lpArcConnCapTable specific index for the lpArcConnCapTable.')
lpArcConnCapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 19, 291, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 4096), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpArcConnCapValue.setStatus('obsolete')
if mibBuilder.loadTexts: lpArcConnCapValue.setDescription('This variable represents an individual value for the lpArcConnCapTable.')
lpAru = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20))
lpAruRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 1), )
if mibBuilder.loadTexts: lpAruRowStatusTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRowStatusTable.setDescription('This entry controls the addition and deletion of lpAru components.')
lpAruRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruIndex"))
if mibBuilder.loadTexts: lpAruRowStatusEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRowStatusEntry.setDescription('A single entry in the table represents a single lpAru component.')
lpAruRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpAru components. These components cannot be added nor deleted.')
lpAruComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruComponentName.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpAruStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruStorageType.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruStorageType.setDescription('This variable represents the storage type value for the lpAru tables.')
lpAruIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpAruIndex.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruIndex.setDescription('This variable represents the index for the lpAru tables.')
lpAruOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100), )
if mibBuilder.loadTexts: lpAruOperTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruOperTable.setDescription('This group describes the usage of ATM-specific resources on a Logical Processor running ATM services.')
lpAruOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruIndex"))
if mibBuilder.loadTexts: lpAruOperEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruOperEntry.setDescription('An entry in the lpAruOperTable.')
lpAruTotalConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTotalConnectionPoolUsage.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTotalConnectionPoolUsage.setDescription('If the LogicalProcessor is associated with a card of a cardType other than 4pE1Aal1 or 4pDS1Aal1, this attribute indicates the total number of enabled VCCs and VPCs in AtmIfs associated with this LogicalProcessor. An example of a VCC not in the enabled state is a VCC with a Test subcomponent. This attribute is equal to the sum of the AtmIf Ca connectionPoolUsage attributes of AtmIfs associated with this LogicalProcessor. If the LogicalProcessor is associated with a card of cardType 4pE1Aal1 or 4pDS1Aal1, this attribute indicates the total number of Ces components associated with this LogicalProcessor.')
lpAruMulticastBranchesUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruMulticastBranchesUsage.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruMulticastBranchesUsage.setDescription('This attribute indicates the total number of multicast branches that are active on the Logical Processor.')
lpAruTxCellBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxCellBlockCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxCellBlockCapacity.setDescription('This attribute indicates the amount of memory reserved for storing ATM cells to be transmitted by the Lp.')
lpAruTxCellBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 20), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxCellBlockUsage.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxCellBlockUsage.setDescription('This attribute indicates the amount of memory currently being used to store ATM cells to be transmitted by the Lp.')
lpAruTxCellFreeListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxCellFreeListSize.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxCellFreeListSize.setDescription('This attribute indicates the current size of the transmit cell free list. The transmit cell free list is the memory available for storing ATM cells to be transmitted by the Lp.')
lpAruTxCellFreeListCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxCellFreeListCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxCellFreeListCongestionState.setDescription('This attribute indicates the congestion state of the transmit cell free list on this ATM-FP. The congestion state of a free list is indicated by a numeric value ranging from 0 to 3. When a free list is in a congested state x, only traffic with discard priority (DP) 0 to x will be stored. Traffic with DP > x will be discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 will be stored.')
lpAruTxFrameMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxFrameMemoryAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFrameMemoryAllocation.setDescription('This attribute defines the percentage of the transmit CQM memory which is allocated to the transmit frame free list on the ATM-FP. The remaining transmit CQM memory is allocated to the transmit cell free list. Frame memory is used for trunks, ATM Vcc testing and for inter-card communication.')
lpAruTxFrameBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxFrameBlockCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFrameBlockCapacity.setDescription('This attribute indicates the amount of memory reserved for storing frames to be transmitted by the Lp.')
lpAruTxFrameBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 50), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxFrameBlockUsage.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFrameBlockUsage.setDescription('This attribute indicates the amount of memory currently being used to store frames to be transmitted by the Lp.')
lpAruTxFrameFreeListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 53), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxFrameFreeListSize.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFrameFreeListSize.setDescription('This attribute indicates the current size of the transmit frame free list. The transmit frame free list is the memory (in ATM cells) available for storing frames to be transmitted by the Lp.')
lpAruTxFrameFreeListCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxFrameFreeListCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFrameFreeListCongestionState.setDescription('This attribute indicates the congestion state of the transmit frame free list on this ATM-FP. The congestion state of a free list is indicated by a numeric value ranging from 0 to 3. When a free list is in a congested state x, only traffic with discard priority (DP) 0 to x will be stored. Traffic with DP > x will be discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 will be stored.')
lpAruRxCellBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 60), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxCellBlockCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxCellBlockCapacity.setDescription('This attribute indicates the amount of memory reserved for storing ATM cells received by the Lp.')
lpAruRxCellBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 70), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxCellBlockUsage.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxCellBlockUsage.setDescription('This attribute indicates the amount of memory currently being used to store ATM cells received by the Lp.')
lpAruRxCellFreeListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 73), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxCellFreeListSize.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxCellFreeListSize.setDescription('This attribute indicates the current size of the receive cell free list. The receive cell free list is the memory available for storing ATM cells received by the Lp.')
lpAruRxCellFreeListCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 76), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxCellFreeListCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxCellFreeListCongestionState.setDescription('This attribute indicates the congestion state of the receive cell free list on this ATM-FP. The congestion state of a free list is indicated by a numeric value ranging from 0 to 3. When a free list is in a congested state x, only traffic with discard priority (DP) 0 to x will be stored. Traffic with DP > x will be discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 will be stored.')
lpAruRxFrameMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 80), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxFrameMemoryAllocation.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFrameMemoryAllocation.setDescription('This attribute indicates the percentage of the receive CQM memory which is allocated to the receive frame free list on the ATM-FP. The remaining receive CQM memory is allocated to the receive cell free list. Frame memory is used for trunks, ATM Vcc testing and for inter-card communication.')
lpAruRxFrameBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 90), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxFrameBlockCapacity.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFrameBlockCapacity.setDescription('This attribute indicates the amount of memory reserved for storing frames received by the Lp.')
lpAruRxFrameBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 100), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxFrameBlockUsage.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFrameBlockUsage.setDescription('This attribute indicates the amount of memory currently being used to store frames received by the Lp.')
lpAruRxFrameFreeListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 103), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxFrameFreeListSize.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFrameFreeListSize.setDescription('This attribute indicates the current size of the receive frame free list. The receive frame free list is the memory (in ATM cells) available for storing frames received by the Lp.')
lpAruRxFrameFreeListCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 106), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxFrameFreeListCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFrameFreeListCongestionState.setDescription('This attribute indicates the congestion state of the receive frame free list on this ATM-FP. The congestion state of a free list is indicated by a numeric value ranging from 0 to 3. When a free list is in a congested state x, only traffic with discard priority (DP) 0 to x will be stored. Traffic with DP > x will be discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is stored. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 will be stored.')
lpAruSubConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 107), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruSubConnectionPoolAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruSubConnectionPoolAvailable.setDescription('This attribute indicates the number of sub-connections available for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay, and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/x Dlci/y Siwf McsMgr Frf5EpG/x Frf5Ep/y Lmi McsMgr Frf5EpG/x Frf5Ep/y Dlci/z Note when the value of this attribute reaches zero, no more connections will be accepted for any of the services which utilize this pool. To increase the size of this pool, use the Arc subConnectionPoolCapacity attribute.')
lpAruSubConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 108), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruSubConnectionPoolUsage.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruSubConnectionPoolUsage.setDescription('This attribute indicates the number of sub-connections being utilized for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay, and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/x Dlci/y Siwf McsMgr Frf5EpG/x Frf5Ep/y Lmi McsMgr Frf5EpG/x Frf5Ep/y Dlci/z')
lpAruLnnConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 109), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruLnnConnectionPoolAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruLnnConnectionPoolAvailable.setDescription('This attribute indicates the number of resource records available for the connections which utilize Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. A LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is allocated at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/x Ep/y EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/x Ep/y component uses one resource record from this pool. Note, when the value of this attribute reaches zero, no more connections will be accepted for any of the services which utilize this pool. To increase the size of this pool, use the Arc lnnConnectionPoolCapacity attribute.')
lpAruLnnConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 100, 1, 110), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruLnnConnectionPoolUsage.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruLnnConnectionPoolUsage.setDescription('This attribute indicates the number of resource records being utilized for the connections which use Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. A LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is applied at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/x Ep/y EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/x Ep/y component uses one resource record from this pool.')
lpAruConnUsageTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 292), )
if mibBuilder.loadTexts: lpAruConnUsageTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruConnUsageTable.setDescription('This attribute has been replaced by the set of AtmIf CA connectionPoolUsage attributes for AtmIf associated to independent links or IMA groups on this LogicalProcessor. The change better encapsulates the information associated with the AtmIf. This attribute indicates the number of connection identifiers (both VCC and VPC) that are in use on each port. The entries are indexed by port number.')
lpAruConnUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 292, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruConnUsageIndex"))
if mibBuilder.loadTexts: lpAruConnUsageEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruConnUsageEntry.setDescription('An entry in the lpAruConnUsageTable.')
lpAruConnUsageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 292, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: lpAruConnUsageIndex.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruConnUsageIndex.setDescription('This variable represents the lpAruConnUsageTable specific index for the lpAruConnUsageTable.')
lpAruConnUsageValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 292, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruConnUsageValue.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruConnUsageValue.setDescription('This variable represents an individual value for the lpAruConnUsageTable.')
lpAruTxCflThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 353), )
if mibBuilder.loadTexts: lpAruTxCflThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxCflThreshTable.setDescription('This attribute indicates the maximum value of the txCellFreeListSize and the discard thresholds of the transmit cell free list. The transmit cell free list is the memory used for storing ATM cells to be transmitted by the Lp. The first value indicates the maximum size of the transmit cell free list. This is derived based upon the connectionPoolCapacity and the txFrameMemoryAllocation under the ARC component. When the txCellFreeListSize decreases to the second value, the txCellFreeListCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the maximum transmit cell free list size. When the txCellFreeListSize decreases to the third value, the txCellFreeListCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) = 2 is discarded. This threshold is set approximately at 20 percent of the first value, the maximum transmit cell free list size. When the txCellFreeListSize decreases to the fourth value, the txCellFreeListCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 10 percent of the first value, the maximum transmit cell free list size.')
lpAruTxCflThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 353, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruTxCflThreshIndex"))
if mibBuilder.loadTexts: lpAruTxCflThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxCflThreshEntry.setDescription('An entry in the lpAruTxCflThreshTable.')
lpAruTxCflThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 353, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpAruTxCflThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxCflThreshIndex.setDescription('This variable represents the lpAruTxCflThreshTable specific index for the lpAruTxCflThreshTable.')
lpAruTxCflThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 353, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxCflThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxCflThreshValue.setDescription('This variable represents an individual value for the lpAruTxCflThreshTable.')
lpAruTxFflThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 354), )
if mibBuilder.loadTexts: lpAruTxFflThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFflThreshTable.setDescription('This attribute indicates the maximum txFrameFreeListSize and the discard thresholds of the transmit frame free list. The transmit frame free list is the memory (in units of ATM cells) used for storing frames to be transmitted by the Lp. The first parameter indicates the total size of the transmit frame free list. This is derived based upon the connectionPoolCapacity and the txFrameMemoryAllocation under the ARC component. When the txFrameFreeListSize decreases to the second value, the txFrameFreeListCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the maximum transmit frame free list size. When the txFrameFreeListSize decreases to the third value, the txFrameFreeListCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) = 2 is discarded. This threshold is set approximately at 20 percent of the first value, the maximum transmit frame free list size. When the txFameFreeListSize decreases to the fourth value, the txFameFreeListCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 10 percent of the first value, the maximum transmit frame free list size.')
lpAruTxFflThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 354, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruTxFflThreshIndex"))
if mibBuilder.loadTexts: lpAruTxFflThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFflThreshEntry.setDescription('An entry in the lpAruTxFflThreshTable.')
lpAruTxFflThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 354, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpAruTxFflThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFflThreshIndex.setDescription('This variable represents the lpAruTxFflThreshTable specific index for the lpAruTxFflThreshTable.')
lpAruTxFflThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 354, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruTxFflThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruTxFflThreshValue.setDescription('This variable represents an individual value for the lpAruTxFflThreshTable.')
lpAruRxCflThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 355), )
if mibBuilder.loadTexts: lpAruRxCflThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxCflThreshTable.setDescription('This attribute indicates the maximum value of the rxCellFreeListSize and the discard thresholds of the receive cell free list. The receive cell free list is the memory used for storing ATM cells to be received by the Lp. The first value indicates the maximum size of the receive cell free list. This is derived based upon the connectionPoolCapacity and the rxFrameMemoryAllocation under the ARC component. When the rxCellFreeListSize decreases to the second value, the rxCellFreeListCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the maximum receive cell free list size. When the rxCellFreeListSize decreases to the third value, the rxCellFreeListCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) = 2 is discarded. This threshold is set approximately at 20 percent of the first value, the maximum receive cell free list size. When the rxCellFreeListSize decreases to the fourth value, the rxCellFreeListCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 10 percent of the first value, the maximum receive cell free list size.')
lpAruRxCflThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 355, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruRxCflThreshIndex"))
if mibBuilder.loadTexts: lpAruRxCflThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxCflThreshEntry.setDescription('An entry in the lpAruRxCflThreshTable.')
lpAruRxCflThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 355, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpAruRxCflThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxCflThreshIndex.setDescription('This variable represents the lpAruRxCflThreshTable specific index for the lpAruRxCflThreshTable.')
lpAruRxCflThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 355, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxCflThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxCflThreshValue.setDescription('This variable represents an individual value for the lpAruRxCflThreshTable.')
lpAruRxFflThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 356), )
if mibBuilder.loadTexts: lpAruRxFflThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFflThreshTable.setDescription('This attribute indicates the maximum rxFrameFreeListSize and the discard thresholds of the transmit frame free list. The receive frame free list is the memory (in units of ATM cells) used for storing frames to be received by the Lp. The first parameter indicates the total size of the receive frame free list. This is derived based upon the connectionPoolCapacity and the rxFrameMemoryAllocation under the ARC component. When the rxFrameFreeListSize decreases to the second value, the rxFrameFreeListCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) = 3 is discarded. This threshold is set approximately at 25 percent of the first value, the maximum receive frame free list size. When the rxFrameFreeListSize decreases to the third value, the rxFrameFreeListCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) = 2 is discarded. This threshold is set approximately at 20 percent of the first value, the maximum receive frame free list size. When the rxFameFreeListSize decreases to the fourth value, the rxFameFreeListCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 10 percent of the first value, the maximum receive frame free list size.')
lpAruRxFflThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 356, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpAruRxFflThreshIndex"))
if mibBuilder.loadTexts: lpAruRxFflThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFflThreshEntry.setDescription('An entry in the lpAruRxFflThreshTable.')
lpAruRxFflThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 356, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpAruRxFflThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFflThreshIndex.setDescription('This variable represents the lpAruRxFflThreshTable specific index for the lpAruRxFflThreshTable.')
lpAruRxFflThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 20, 356, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAruRxFflThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: lpAruRxFflThreshValue.setDescription('This variable represents an individual value for the lpAruRxFflThreshTable.')
lpEngArc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5))
lpEngArcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 1), )
if mibBuilder.loadTexts: lpEngArcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngArc components.')
lpEngArcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"))
if mibBuilder.loadTexts: lpEngArcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRowStatusEntry.setDescription('A single entry in the table represents a single lpEngArc component.')
lpEngArcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngArc components. These components can be added and deleted.')
lpEngArcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngArcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcStorageType.setDescription('This variable represents the storage type value for the lpEngArc tables.')
lpEngArcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngArcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcIndex.setDescription('This variable represents the index for the lpEngArc tables.')
lpEngArcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10), )
if mibBuilder.loadTexts: lpEngArcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOperTable.setDescription('This group describes the usage of ATM-specific resources on a Logical Processor running ATM services. The attributes listed represent Queue Controller resource usage for all ATM Cards (CQC for CQC based cards or PQC for SGAF cards).')
lpEngArcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"))
if mibBuilder.loadTexts: lpEngArcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOperEntry.setDescription('An entry in the lpEngArcOperTable.')
lpEngArcTotalConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTotalConnectionPoolAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTotalConnectionPoolAvailable.setDescription('This attribute indicates the number of connection resources available (VCC, VPC, and VPT) that can be used on this FP. A standard Vpt uses 3 connection resources and a basic Vpt uses 2.')
lpEngArcTotalConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTotalConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTotalConnectionPoolUsage.setDescription('This attribute indicates the number of connection resources (VCC, VPC, and VPT) in use on this FP. A standard Vpt uses 3 connection resources and a basic Vpt uses 2.')
lpEngArcMulticastBranchesAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcMulticastBranchesAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcMulticastBranchesAvailable.setDescription('This attribute indicates the total number of multicast branches that are available on this FP.')
lpEngArcMulticastBranchesUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcMulticastBranchesUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcMulticastBranchesUsage.setDescription('This attribute indicates the total number of multicast branches that are active on this FP.')
lpEngArcTxCellMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTxCellMemoryAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTxCellMemoryAllocation.setDescription('This attribute indicates the fraction of the transmit memory which is allocated for the transmission of cells on the FP. Cell memory is used for Atm Bearer Services, ATM SVCs and ATM PVCs. The remaining transmit memory is allocated for the transmission of frames. Frame memory is used for trunks, ATM VCC testing and for inter-card communication.')
lpEngArcTxCellMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTxCellMemoryAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngArcTxCellMemoryAvailable.setDescription('This attribute indicates the current availability of the transmit cell memory. The transmit cell memory is the memory available for storing ATM cells to be transmitted by this FP.')
lpEngArcTxCellMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTxCellMemoryMinAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngArcTxCellMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the transmit cell memory. The transmit cell memory is the memory available for storing ATM cells to be transmitted by this FP. This value is reset to the current availability every 15 minutes and when the card is reset.')
lpEngArcTxCellMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTxCellMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTxCellMemoryCongestionState.setDescription("This attribute indicates the congestion state of the transmit cell memory for this FP. This attribute indicates which txCellMemoryThresholds corresponds to the current value of txCellMemoryUsage. The congestion state is used to determine if cells of a particular discard priority (DP) are discarded before being queued for transmit. The congestion state of transmit cell memory is indicated by a numeric value ranging from 3 to 0. When transmit cell memory is in congestion state 'x', traffic with DP > 'x' is discarded before transmit. Traffic with DP < 'x' may be queued for transmit, depending on the congestion level of the connection transmit queue. Traffic with DP = 'x' may be either queued or discarded depending on how close the value of txCellMemoryUsage is to the next threshold as displayed in txCellMemoryThresholds. For example, CLP1 traffic is queued until the value indicated by txCellMemoryUsage equals the value indicated in txCellMemoryThresholds 3. At that point, CLP1 traffic is discarded.")
lpEngArcRxCellMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcRxCellMemoryAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRxCellMemoryAllocation.setDescription('This attribute indicates the fraction of the receive memory which is allocated for the reception of cells on the FP. Cell memory is used for Atm Bearer Services, ATM SVCS and ATM PVCS. The remaining receive memory is allocated to the reception of frame. Frame memory is used for trunks, ATM VCC testing and for inter-card communication.')
lpEngArcRxCellMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcRxCellMemoryAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngArcRxCellMemoryAvailable.setDescription('This attribute indicates the current availability of the receive cell memory. The receive cell memory is the memory available for storing ATM cells to be transmitted by this FP.')
lpEngArcRxCellMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcRxCellMemoryMinAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngArcRxCellMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the receive cell memory. The receive cell memory is the memory available for storing ATM cells to be transmitted by this FP. This value is reset to the current availability every 15 minutes and when the card is reset.')
lpEngArcRxCellMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcRxCellMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRxCellMemoryCongestionState.setDescription("This attribute indicates the congestion state of the receive cell memory on this FP. This attribute indicates which rxCellMemoryThresholds corresponds to the current value of rxCellMemoryUsage. The congestion state is used to determine if cells of a particular discard priority (DP) are discarded before being queued for processing on this FP. The congestion state of receive cell memory is indicated by a numeric value ranging from 3 to 0. When receive cell memory is in congestion state 'x', traffic with DP > 'x' is discarded before processing. Traffic with DP < 'x' may be queued for processing, depending on the congestion level of the processor or bus queue. Traffic with DP = 'x' may be either queued or discarded depending on how close the value of rxCellMemoryUsage is to the next threshold as displayed in rxCellMemoryThresholds. For example, CLP1 traffic is queued until the value indicated by rxCellMemoryUsage equals the value indicated in rxCellMemoryThresholds 3. At that point, CLP1 traffic is discarded.")
lpEngArcTxCellMemoryMaxUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTxCellMemoryMaxUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTxCellMemoryMaxUsage.setDescription('This attribute indicates the maximum number which has recently occurred for the txCellMemoryUsage attribute. On CQC-based ATM FPs, this number indicates the maximum usage of transmit cells for all ports on this FP. On ATM IP FPs, this number indicates the maximum usage of transmit cells in the Passport Queue Controller (PQC) ASIC. Queuing of ATM cells for transmit normally occurs in the ATM Queue Manager (AQM) ASIC, which is indicated in the Lp Eng Arc Aqm/x txCellMemoryUsage attribute. Transmit cells should only be queued in the PQC under circumstances of extreme transient congestion. This value is reset to the current usage every 15 minutes and when the card is reset.')
lpEngArcTxCellMemoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 14), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTxCellMemoryUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTxCellMemoryUsage.setDescription('This attribute indicates the current number of transmit cells which are in use for this FP. On CQC-based ATM FPs, this number indicates the total transmit cells which are in use for all ports on this FP. On ATM IP FPs, this number indicates the number of transmit cells which are in use in the Passport Queue Controller (PQC) ASIC. Queuing of ATM cells for transmit normally occurs in the ATM Queue Manager (AQM) ASIC, which is indicated in the Lp Eng Arc Aqm/x txCellMemoryUsage attribute. Transmit cells should only be queued in the PQC under circumstances of extreme transient congestion.')
lpEngArcRxCellMemoryMaxUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 15), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcRxCellMemoryMaxUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRxCellMemoryMaxUsage.setDescription('This attribute indicates the maximum usage of receive cells for all ports on this FP. Receive cell memory is used for storing ATM cells received by this FP which are currently queued either for handling by the processor on this FP or queued for transmitting over the backplane to other FPs. This value is reset to the current usage every 15 minutes and when the card is reset.')
lpEngArcRxCellMemoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 10, 1, 16), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcRxCellMemoryUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRxCellMemoryUsage.setDescription('This attribute indicates the current number of receive cells which are in use for all ports on this FP. Receive cell memory is used for storing ATM cells received by this FP which are currently queued either for handling by the processor on this FP or queued for transmitting over the backplane to other FPs on this switch.')
lpEngArcTxCellThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 440), )
if mibBuilder.loadTexts: lpEngArcTxCellThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTxCellThreshTable.setDescription('This attribute is a vector which indicates the size and three discard thresholds for transmit cell memory for this FP. The transmit cell memory is used for storing ATM cells to be transmitted by this FP. The first value indicates the transmit cell memory size. This is derived based on the total transmit memory capacity of this FP, and the value of the connectionPoolCapacity and the txCellMemoryAllocation attributes. The current value of txCellMemoryUsage together with the vector of values in txCellMemoryThresholds determines the txCellMemoryCongestionState. The congestion state determines whether cells of a given discard priority (DP) are discarded or queued for transmit. When the txCellMemoryUsage attribute is between threshold 0 and threshold 1, the txCellMemoryCongestionState indicates the value 0. In congestion state 0, traffic with DP > 0 is discarded. Threshold 1 is set approximately at 90 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is between threshold 1 and threshold 2, the txCellMemoryCongestionState indicates the value 1. In congestion state 1, traffic with DP > 1 is discarded. Threshold 2 is set approximately at 85 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is between threshold 2 and threshold 3, the txCellMemoryCongestionState indicates the value 2. In congestion state 2, traffic with DP > 2 is discarded. Threshold 3 is set approximately at 75 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is below threshold 3, the txCellMemoryCongestionState indicates the value 3. In congestion state 3, traffic with DP=3 is queued.')
lpEngArcTxCellThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 440, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcTxCellThreshIndex"))
if mibBuilder.loadTexts: lpEngArcTxCellThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTxCellThreshEntry.setDescription('An entry in the lpEngArcTxCellThreshTable.')
lpEngArcTxCellThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 440, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpEngArcTxCellThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTxCellThreshIndex.setDescription('This variable represents the lpEngArcTxCellThreshTable specific index for the lpEngArcTxCellThreshTable.')
lpEngArcTxCellThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 440, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcTxCellThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcTxCellThreshValue.setDescription('This variable represents an individual value for the lpEngArcTxCellThreshTable.')
lpEngArcRxCellThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 444), )
if mibBuilder.loadTexts: lpEngArcRxCellThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRxCellThreshTable.setDescription('This attribute is a vector which indicates the size and three discard thresholds for receive cell memory for this FP. Receive cell memory is used for storing ATM cells received by this FP which are queued either for handling by the processor on this FP or queued for transmitting over the backplane to other FPs on this switch. The first value indicates the receive cell memory size. This is derived based on the total receive memory capacity of this FP, and the value of the connectionPoolCapacity and the rxCellMemoryAllocation attributes. The current value of rxCellMemoryUsage together with the vector of values in rxCellMemoryThresholds determines the rxCellMemoryCongestionState. The congestion state determines whether cells of a given discard priority (DP) are discarded or queued. When the rxCellMemoryUsage attribute is between threshold 0 and threshold 1, the rxCellMemoryCongestionState indicates the value 0. In congestion state 0, traffic with DP > 0 is discarded. Threshold 1 is set approximately at 90 percent of threshold 0, the total receive cell memory size. When the rxCellMemoryUsage attribute is between threshold 1 and threshold 2, the rxCellMemoryCongestionState indicates the value 1. In congestion state 1, traffic with DP > 1 is discarded. Threshold 2 is set approximately at 85 percent of threshold 0, the total receive cell memory size. When the rxCellMemoryUsage attribute is between threshold 2 and threshold 3, the rxCellMemoryCongestionState indicates the value 2. In congestion state 2, traffic with DP > 2 is discarded. Threshold 3 is set approximately at 75 percent of threshold 0, the total receive cell memory size. When the rxCellMemoryUsage attribute is below threshold 3, the rxCellMemoryCongestionState indicates the value 3. In congestion state 3, traffic with DP=3 is queued.')
lpEngArcRxCellThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 444, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcRxCellThreshIndex"))
if mibBuilder.loadTexts: lpEngArcRxCellThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRxCellThreshEntry.setDescription('An entry in the lpEngArcRxCellThreshTable.')
lpEngArcRxCellThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 444, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpEngArcRxCellThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRxCellThreshIndex.setDescription('This variable represents the lpEngArcRxCellThreshTable specific index for the lpEngArcRxCellThreshTable.')
lpEngArcRxCellThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 444, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcRxCellThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcRxCellThreshValue.setDescription('This variable represents an individual value for the lpEngArcRxCellThreshTable.')
lpEngArcOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2))
lpEngArcOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 1), )
if mibBuilder.loadTexts: lpEngArcOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngArcOv components.')
lpEngArcOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcOvIndex"))
if mibBuilder.loadTexts: lpEngArcOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvRowStatusEntry.setDescription('A single entry in the table represents a single lpEngArcOv component.')
lpEngArcOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngArcOv components. These components can be added and deleted.')
lpEngArcOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngArcOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvStorageType.setDescription('This variable represents the storage type value for the lpEngArcOv tables.')
lpEngArcOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngArcOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvIndex.setDescription('This variable represents the index for the lpEngArcOv tables.')
lpEngArcOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 10), )
if mibBuilder.loadTexts: lpEngArcOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvProvTable.setDescription('This group specifies the configuration of processor-wide ATM- specific resources on a Logical Processor running ATM services on ATM cards. Note that altering any of these parameters will result in a card reboot.')
lpEngArcOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcOvIndex"))
if mibBuilder.loadTexts: lpEngArcOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvProvEntry.setDescription('An entry in the lpEngArcOvProvTable.')
lpEngArcOvTotalConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768)).clone(3072)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcOvTotalConnectionPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvTotalConnectionPoolCapacity.setDescription('This attribute specifies the maximum number of connections (VCC, VPC, and VPT) that can be enabled on this FP. A standard Vpt uses 3 connections and a basic Vpt uses 2. If the LogicalProcessor is associated with a card of a cardType other than one of the following: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm; the value of the attribute restricts the sum of the (maxVccs + maxVpcs + (maxVpts * 3)) across all AtmIfs bound to this LogicalProcessor. If the LogicalProcessor is associated with a card of one of the following cardTypes: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm; the number of available connections are distributed equally across the ports on the FP. The number of connections associated to a particular port limits the size of the Vcc space which can be defined by the ConnMap of the AtmIf linked to the port. If the ConnMap component does not exist, its default settings are used for this check. Furthermore, the value of this attribute is restricted based on the number of ports on the card. For one port cards, the minimum is 512, the maximum is 4096 and the value must be divisible by 256. For two port cards, the minimum is 1024, the maximum is 8192 and the value must be divisible by 512. For three port cards, the minimum is 1536, the maximum is 7680 and the value must be divisible by 768. If the LogicalProcessor is associated with a card of one of the following cardTypes: 8pE1Atm, 8pDS1Atm, the maximum value for this attribute is 10752. For SGAF cards, the Connmap attributes are set to their default values. Increasing the value of this attribute reduces the memory available for cell and frame memory. This attribute must be set to 0 if the connectionPoolCapacity attribute of the Arc Ov component is set to non-zero values.')
lpEngArcOvMulticastBranchesCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcOvMulticastBranchesCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvMulticastBranchesCapacity.setDescription('This attribute specifies the number of multicast branches that can be enabled on this FP. A multicast branch is used for cell replication on a VCC connection whose Vcc distributionType is pointToMultipoint. A branch represents one ATM destination for the replicated cells. Increasing the value of this attribute reduces the memory available for the cell and frame storage. For CQC based ATM FPs, the maximum value for this attribute is 10752.')
lpEngArcOvTxCellMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcOvTxCellMemoryAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvTxCellMemoryAllocation.setDescription('This attribute specifies the fraction of the transmit memory which should be allocated to the transmission of cells on an FP. The remaining memory is allocated for the transmission of frames. Frame memory is used for trunks, ATM VCC testing and for inter- card communication. Cell memory is used for Atm Bearer Service, ATM SVCs and ATM PVCs. There is an absolute minimum quantity of frame buffers which is required by ATM software on the FP. If the value of this attribute is smaller than the absolute minimum, the ATM software allocates the minimum required, rather than the actual number requested. The actual percentage of the transmit memory allocated to the transmit cell memory is indicated by the Arc txCellMemoryAllocation attribute. A difference between the provisioned and the operational values may exist due to the requirement for a minimum number of frame buffers or rounding during computation within the FP.')
lpEngArcOvRxCellMemoryAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcOvRxCellMemoryAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcOvRxCellMemoryAllocation.setDescription('This attribute specifies the fraction of the receive memory which should be allocated to the reception of cells on an FP. The remaining receive memory is allocated for the reception of frames. Frame memory is used for trunks, ATM VCC testing and for inter- card communication. Cell memory is used for Atm Bearer Service, ATM SVCs and ATM PVCs. There is an absolute minimum quantity of frame buffers which is required by ATM software on the FP. If the value of this attribute is smaller than the absolute minimum, the ATM software allocates the minimum required, rather than the actual number requested. The actual percentage of the receive memory allocated to the receive cell memory is indicated by the Arc rxCellMemoryAllocation attribute. A difference between the provisioned and the operational values may exist due to the requirement for a minimum number of frame buffers or rounding during computation within the FP.')
lpEngArcCqc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3))
lpEngArcCqcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 1), )
if mibBuilder.loadTexts: lpEngArcCqcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngArcCqc components.')
lpEngArcCqcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcIndex"))
if mibBuilder.loadTexts: lpEngArcCqcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcRowStatusEntry.setDescription('A single entry in the table represents a single lpEngArcCqc component.')
lpEngArcCqcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcCqcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngArcCqc components. These components can be added and deleted.')
lpEngArcCqcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcCqcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngArcCqcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcCqcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcStorageType.setDescription('This variable represents the storage type value for the lpEngArcCqc tables.')
lpEngArcCqcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngArcCqcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcIndex.setDescription('This variable represents the index for the lpEngArcCqc tables.')
lpEngArcCqcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 10), )
if mibBuilder.loadTexts: lpEngArcCqcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOperTable.setDescription('This group describes the usage of ATM-specific resources on a Logical Processor running ATM services on a CQC based card.')
lpEngArcCqcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcIndex"))
if mibBuilder.loadTexts: lpEngArcCqcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOperEntry.setDescription('An entry in the lpEngArcCqcOperTable.')
lpEngArcCqcCdvReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("cardDependent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcCqcCdvReduction.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcCdvReduction.setDescription('This attribute indicates if the reduction of the maximum Cell Delay Variation (CDV) of shaped transmit traffic is applicable. When the value of this attribute is disabled, the CDV value can be determined by the following equation: CDV <= 2/ASR + 1/LS where ASR is the Actual Shaping Rate of the connection and LS is the Link Speed of the interface. When the value of this attribute is enabled, the CDV relationship changes to the following equation: CDV <= 1/ASR + 1/LS')
lpEngArcCqcOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2))
lpEngArcCqcOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 1), )
if mibBuilder.loadTexts: lpEngArcCqcOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngArcCqcOv components.')
lpEngArcCqcOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcOvIndex"))
if mibBuilder.loadTexts: lpEngArcCqcOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvRowStatusEntry.setDescription('A single entry in the table represents a single lpEngArcCqcOv component.')
lpEngArcCqcOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcCqcOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngArcCqcOv components. These components cannot be added nor deleted.')
lpEngArcCqcOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcCqcOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngArcCqcOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcCqcOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvStorageType.setDescription('This variable represents the storage type value for the lpEngArcCqcOv tables.')
lpEngArcCqcOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngArcCqcOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvIndex.setDescription('This variable represents the index for the lpEngArcCqcOv tables.')
lpEngArcCqcOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 10), )
if mibBuilder.loadTexts: lpEngArcCqcOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvProvTable.setDescription('This group specifies the configuration of processor-wide ATM- specific resources on a Logical Processor running ATM services. Note that altering any of these parameters will result in a card reboot.')
lpEngArcCqcOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcOvIndex"))
if mibBuilder.loadTexts: lpEngArcCqcOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvProvEntry.setDescription('An entry in the lpEngArcCqcOvProvTable.')
lpEngArcCqcOvPerVcQueueInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcCqcOvPerVcQueueInterfaces.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvPerVcQueueInterfaces.setDescription('This attribute specifies the number of independent ports or IMA components which support shaping and per-VC queueing on this FP. When this attribute is not zero, at most 4 independent ports or 4 Ima virtual links are supported, regardless of whether or not traffic shaping is enabled on the associated AtmIf components. In this case only independent port instances 0-3 or Ima instances 0-3 can be supported on an associated AtmIf component. For 2 ports cards, the valid values for this attribute are 0, 1, or 2. For 3 ports cards, the valid values for this attribute are 0, 1, 2 or 3. For 8 ports cards, the valid values for this attribute are 0, 1, 2, or 4.')
lpEngArcCqcOvShapingScalingFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 10, 1, 2), FixedPoint1().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(10, 10), ValueRangeConstraint(14, 14), ValueRangeConstraint(20, 20), ValueRangeConstraint(28, 28), ValueRangeConstraint(40, 40), ValueRangeConstraint(56, 56), )).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcCqcOvShapingScalingFactor.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvShapingScalingFactor.setDescription('This attribute specifies the scaling factor which is to be applied to all shaping rates for this FP. The scaling factor is an inverse factor which is applied to the chosen shaping rate to produce an actual shaping rate. For example, if a shaping rate of 25 Mbit/s is used with a scaling factor of 2, the actual shaping rate is 12.5 Mbit/s.')
lpEngArcCqcOvCdvReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("cardDependent", 2))).clone('cardDependent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcCqcOvCdvReduction.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvCdvReduction.setDescription('This attribute specifies the reduction of the maximum Cell Delay Variation (CDV) of shaped transmit traffic. When the value of this attribute is set to disabled, the CDV value can be determined by the following equation: CDV <= 2/ASR + 1/LS where ASR is the Actual Shaping Rate of the connection and LS is the Link Speed of the interface. When the value of this attribute is set to enabled, the CDV relationship changes to the following equation: CDV <= 1/ASR + 1/LS As can be noted from the equations above, setting this attribute to enabled can reduce the CDV significantly. CDV reduction may be used to conform to policers which have strict Cell Delay Variance Tolerance (CDVT). However using this function reduces the transmit bandwidth utilization of the following cards: 3pDS3Atm, 3pOC3Atm, 2pJ6MAtm. When the value is cardDependent, CDV reduction is disabled for cardtypes 3pDS3Atm, 3pOC3Atm, 2pJ6MAtm, 4pDS1Aal1, 4pE1Aal1 and enabled for all other cards.')
lpEngArcCqcOvPortCongestionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aggregate", 0), ("individualQueue", 1))).clone('aggregate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcCqcOvPortCongestionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvPortCongestionPolicy.setDescription('This attribute specifies the congestion behavior of all ports on this FP. It applies only to transmit traffic served on the common queues and does not apply to per-VC queues. When the value is aggregate, the enqueue decision of cells or frames to a common queue is based upon the congestion state of the entire port to which the queue belongs. A port is defined to be as congested as the most congested queue amongst all its common queues: the low, medium and high emission priority queues. Thus, for example, if the low priority queue is congested, the high priority queue also experiences discards even though the high priority queue may itself not be congested. Setting this attribute to aggregate assures that the low priority queues are also serviced in the event of congestion. When the value of this attribute is set to individualQueue, the enqueue decision of cells or frames to a common queue is based solely upon the congestion state of that queue, not the port. This setting assures that the absolute priority of the traffic is taken into account, regardless of whether the lower priority queues are being served.')
lpEngArcCqcOvConnCapTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 450), )
if mibBuilder.loadTexts: lpEngArcCqcOvConnCapTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvConnCapTable.setDescription('This attribute is provided for backward compatibility and can only be used if the LogicalProcessor is associated with a card of one of the following cardType: 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm. This attribute can be used when the desired distribution of connections across ports cannot be achieved using the totalConnectionPoolCapacity attribute. This attribute defines the maximum number of connections (VCC, VPC, and VPT) that are available on each port. A basic Vpt uses 2 connections. The entries are indexed by port number. This number limits the range of the ConnMap entries. If the Connmap component does not exist, its default settings are used for this check. Note that the value of this attribute must be evenly divisible by 256, and that port 2 supports at most 2560 connections, not the full 4096. The connection pool for each port must be set to 0 if the totalConnectionPoolCapacity attribute is set to a non-zero value.')
lpEngArcCqcOvConnCapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 450, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcOvIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcCqcOvConnCapIndex"))
if mibBuilder.loadTexts: lpEngArcCqcOvConnCapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvConnCapEntry.setDescription('An entry in the lpEngArcCqcOvConnCapTable.')
lpEngArcCqcOvConnCapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 450, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: lpEngArcCqcOvConnCapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvConnCapIndex.setDescription('This variable represents the lpEngArcCqcOvConnCapTable specific index for the lpEngArcCqcOvConnCapTable.')
lpEngArcCqcOvConnCapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 3, 2, 450, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(512, 4096), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcCqcOvConnCapValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcCqcOvConnCapValue.setDescription('This variable represents an individual value for the lpEngArcCqcOvConnCapTable.')
lpEngArcAqm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4))
lpEngArcAqmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 1), )
if mibBuilder.loadTexts: lpEngArcAqmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngArcAqm components.')
lpEngArcAqmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcAqmIndex"))
if mibBuilder.loadTexts: lpEngArcAqmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmRowStatusEntry.setDescription('A single entry in the table represents a single lpEngArcAqm component.')
lpEngArcAqmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcAqmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngArcAqm components. These components can be added and deleted.')
lpEngArcAqmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngArcAqmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmStorageType.setDescription('This variable represents the storage type value for the lpEngArcAqm tables.')
lpEngArcAqmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: lpEngArcAqmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmIndex.setDescription('This variable represents the index for the lpEngArcAqm tables.')
lpEngArcAqmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10), )
if mibBuilder.loadTexts: lpEngArcAqmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOperTable.setDescription('This group describes the usage of ATM-specific resources for a specific AQM on a Logical Processor running ATM services.')
lpEngArcAqmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcAqmIndex"))
if mibBuilder.loadTexts: lpEngArcAqmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOperEntry.setDescription('An entry in the lpEngArcAqmOperTable.')
lpEngArcAqmConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmConnectionPoolAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmConnectionPoolAvailable.setDescription('This attribute indicates the number of connection resources available (VCC, VPC, and VPT) that can be configured on the AQM instance of the LogicalProcessor. A standard Vpt uses 3 connection resources and a basic Vpt uses 2.')
lpEngArcAqmConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmConnectionPoolUsage.setDescription('This attribute indicates the total number of connections for configured VCCs, VPCs, and VPTs in AtmIfs associated with the AQM instance of the LogicalProcessor. A standard Vpt uses 3 connection resources and a basic Vpt uses 2.')
lpEngArcAqmTxCellMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryAvailable.setDescription('This attribute indicates the current availability of the transmit cell memory. The transmit cell memory is the memory available for storing ATM cells to be transmitted by the Lp.')
lpEngArcAqmTxCellMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryMinAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the transmit cell memory. The transmit cell memory is the memory available for storing ATM cells to be transmitted by the Lp. This attribute is reset to the current availability every 15 minutes and when the card is reset.')
lpEngArcAqmTxCellMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryCongestionState.setDescription("This attribute indicates the congestion state of the transmit cell memory for the ATM Queue Manager (AQM) ASIC on this FP. This attribute indicates which txCellMemoryThresholds corresponds to the current value of txCellMemoryUsage. The congestion state is used to determine if cells of a particular discard priority (DP) are discarded before being queued for transmit. The congestion state of transmit cell memory is indicated by a numeric value ranging from 3 to 0. When transmit cell memory is in congestion state 'x', traffic with DP > 'x' is discarded before transmit. Traffic with DP < 'x' may be queued for transmit, depending on the congestion level of the connection transmit queue. Traffic with DP = 'x' may be either queued or discarded depending on how close the value of txCellMemoryUsage is to the next threshold as displayed in txCellMemoryThresholds. For example, CLP1 traffic is queued until the value indicated by txCellMemoryUsage equals the value indicated in txCellMemoryThresholds 3. At that point, CLP1 traffic is discarded.")
lpEngArcAqmTxCellMemoryMaxUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryMaxUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryMaxUsage.setDescription('This attribute indicates the maximum number which has recently occurred for the txCellMemoryUsage attribute. Transmit cell memory is used for storing ATM cells to be transmitted by connections for the ATM Queue Manager (AQM) ASIC on this FP. It includes all cells in all connections at all service categories. This attribute is reset to the current usage every 15 minutes and when the card is reset.')
lpEngArcAqmTxCellMemoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmTxCellMemoryUsage.setDescription('This attribute indicates the current number of transmit cells which are in use on this FP. Transmit cell memory is used for storing ATM cells to be transmitted by connections for the ATM Queue Manager (AQM) ASIC on this FP. It includes all cells in all connections at all service categories.')
lpEngArcAqmMaxVirtualLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(6, 6), ValueRangeConstraint(14, 14), ValueRangeConstraint(29, 29), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmMaxVirtualLinks.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmMaxVirtualLinks.setDescription("This attribute indicates the maximum number of virtual links (VLs) that can exist on this AQM. Normally a virtual link contains all VCCs and VPCs provisioned for a port (OC-3, DS3, E3, etc), making a virtual link equivalent to a port. However, if an AtmIf linked to a port has provisioned virtual path terminations (VPTs) with a vptType of virtualLink, then there is one virtual link per VL VPT, and one virtual link for all remaining VCCs and VPCs not part of a VL VPT. Unless this attribute is overridden in the optional Override subcomponent, its value will be sameNumberAsPorts, indicating that there is one virtual link per port using the AQM. The value of maxVirtualLinks may restrict the maximum bandwidth allowed per virtual link. If the value of this attribute is sameNumberAsPorts there is no restriction on a virtual link's bandwidth; it may be any cell rate up to the port's link rate. If maxVirtualLinks is set to some other value, then all virtual links on the AQM are subject to a maximum cell rate, listed in the table below, which may be less than the port cell rate. maxVirtualLinks : cell rate 6: 163840 cell/s 14 : 81920 cell/s 29: 40960 cell/s On 2pOC3MmAtm2 and 2pOC3SmAtm2 cards, there is one AQM per port. Since one link is required for connections not part of a VL VPT, if maxVirtualLinks is 6 (for example), then up to fiveVL VPTs may be provisioned on the port. Continuing this example, each VPT's provisioned bandwidth can be no larger than 163840 cells/s (46% of the total OC-3 rate) and the total bandwidth available to independent VCCs and non VL VPTs will be no greater than 163840 cell/s. On 3pDS3Atm2 and 3pE3Atm2 cards, there is one AQM for the card. Since three links are required for connections not part of a VL VPT (one per port), if maxVirtualLinks is 6 (for example), then up to threeVL VPTs may be provisioned on the card. In this case, since the maximum cell rate per virtual link is 163840 cell/s, which is greater than the port cell rate for both DS3 and E3, there is no restriction on the bandwidth assigned to VL VPTs or available to independent VCC and non VL VPT connections. VALUES ( 0 = sameNumberAsPorts )")
lpEngArcAqmVirtualLinkUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmVirtualLinkUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmVirtualLinkUsage.setDescription('This attribute indicates the number of virtual links in use on this AQM. Its maximum value is the value of operational attribute maxVirtualLinks. Since each port uses one virtual link, if maxVirtualLinks has value sameNumberAsPorts then virtualLinkUsage will be 1 for 2pOC3MmAtm2 and 2pOC3SmAtm2 cards, and 3 for 3pDS3Atm2 and 3pE3Atm2 cards.')
lpEngArcAqmVirtualLinkGranularity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 10, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmVirtualLinkGranularity.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmVirtualLinkGranularity.setDescription("This attribute indicates the granularity on which virtual link bandwidths are allocated. It is affected by the Override subcomponent's provisionable virtualLinkGranularity attribute, and will vary between 562 cell/s (minimum granularity for an E3 G.751 PLCP link) and 353207 cell/s (maximum granularity for an OC-3 link).")
lpEngArcAqmTxCellThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 448), )
if mibBuilder.loadTexts: lpEngArcAqmTxCellThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmTxCellThreshTable.setDescription('This attribute is a vector which indicates the size and three discard thresholds for transmit cell memory for the ATM Queue Manager (AQM) ASIC on this FP. Transmit cell memory is used for storing ATM cells to be transmitted by connections. It includes all cells in all connections at all service categories. The first value indicates the transmit cell memory size. It is the amount of transmit memory which is available for cell queueing, after the amount of memory specified by connectionPoolCapacity. The current value of txCellMemoryUsage together with the vector of values in txCellMemoryThresholds determines the txCellMemoryCongestionState. The congestion state determines whether cells of a given discard priority (DP) are discarded or queued for transmit. When the txCellMemoryUsage attribute is between threshold 0 and threshold 1, the txCellMemoryCongestionState indicates the value 0. In congestion state 0, traffic with DP > 0 is discarded. Threshold 1 is set approximately at 90 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is between threshold 1 and threshold 2, the txCellMemoryCongestionState indicates the value 1. In congestion state 1, traffic with DP > 1 is discarded. Threshold 2 is set approximately at 85 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is between threshold 2 and threshold 3, the txCellMemoryCongestionState indicates the value 2. In congestion state 2, traffic with DP > 2 is discarded. Threshold 3 is set approximately at 75 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is below threshold 3, the txCellMemoryCongestionState indicates the value 3. In congestion state 3, traffic with DP=3 is queued.')
lpEngArcAqmTxCellThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 448, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcAqmIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcAqmTxCellThreshIndex"))
if mibBuilder.loadTexts: lpEngArcAqmTxCellThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmTxCellThreshEntry.setDescription('An entry in the lpEngArcAqmTxCellThreshTable.')
lpEngArcAqmTxCellThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 448, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpEngArcAqmTxCellThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmTxCellThreshIndex.setDescription('This variable represents the lpEngArcAqmTxCellThreshTable specific index for the lpEngArcAqmTxCellThreshTable.')
lpEngArcAqmTxCellThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 448, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmTxCellThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmTxCellThreshValue.setDescription('This variable represents an individual value for the lpEngArcAqmTxCellThreshTable.')
lpEngArcAqmOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2))
lpEngArcAqmOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 1), )
if mibBuilder.loadTexts: lpEngArcAqmOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngArcAqmOv components.')
lpEngArcAqmOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcAqmIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcAqmOvIndex"))
if mibBuilder.loadTexts: lpEngArcAqmOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvRowStatusEntry.setDescription('A single entry in the table represents a single lpEngArcAqmOv component.')
lpEngArcAqmOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngArcAqmOv components. These components cannot be added nor deleted.')
lpEngArcAqmOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngArcAqmOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngArcAqmOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvStorageType.setDescription('This variable represents the storage type value for the lpEngArcAqmOv tables.')
lpEngArcAqmOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngArcAqmOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvIndex.setDescription('This variable represents the index for the lpEngArcAqmOv tables.')
lpEngArcAqmOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 10), )
if mibBuilder.loadTexts: lpEngArcAqmOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvProvTable.setDescription('This group specifies the configuration of processor-wide ATM- specific resources on a Logical Processor running ATM services on CQC based cards. Note that altering any of these parameters will result in a card reboot.')
lpEngArcAqmOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcAqmIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngArcAqmOvIndex"))
if mibBuilder.loadTexts: lpEngArcAqmOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvProvEntry.setDescription('An entry in the lpEngArcAqmOvProvTable.')
lpEngArcAqmOvConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcAqmOvConnectionPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvConnectionPoolCapacity.setDescription('This attribute specifies the maximum number of connections (VCC, VPC, and VPT) that can be configured on the AQM instance of the LogicalProcessor. The value of this attribute should be less than or equal to totalConnectionPoolCapacity of the Arc component. Note that 3 connections are used for each standard Vpt and 2 for each basic Vpt. The default value derivedFromArc is obtained using the following equation: totalConnectionPoolCapacity / number of AQM component on FP. VALUES ( 0 = derivedFromArc )')
lpEngArcAqmOvHighPriorityEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 1024)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcAqmOvHighPriorityEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvHighPriorityEpdOffset.setDescription('This attribute specifies the high priority Early Packet Discard (EPD) offset for connection queues. On ATM IP FPs a given connection queue is associated with one of eight emission priorities (EP). These include six unshaped EPs, one exclusive VBR shaper EP and one ABR/VBR shaper EP. This attribute specifies the EPD offset for the exclusive VBR shaper EP and the first four (higher priority) unshaped EPs. This offset is used to derive a connection EPD threshold for a given Congestion Control (CC) level by subtracting the offset from the All Packet Discard (APD) threshold at the same CC level. The APD thresholds are themselves derived from the transmit queue limit. The EPD threshold only applies to a connection if the txPacketWiseDiscard feature is requested. The txPacketWiseDiscard feature can be enabled only if the transmit queue limit is at least 5.71 times the EPD offset. This ensures that the derived EPD threshold will never be less than 17.5 % of the transmit queue limit. If this condition is not satisfied, txPacketWiseDiscard for the connection will be automatically disabled. Due to the above constraint, if the operator wishes to decrease the transmit queue limit and still have txPacketWiseDiscard enabled on the connection then this offset must be set to a lower value that meets the above requirement. Due to hardware granularity the actual value of the EPD offset may not match exactly the value provisioned. The actual value is displayed under the ATM Connection Administrator service category subcomponents on ATM IP FPs. This attribute does not apply to CQC FPs.')
lpEngArcAqmOvLowPriorityEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 1024)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcAqmOvLowPriorityEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvLowPriorityEpdOffset.setDescription('This attribute specifies the low priority Early Packet Discard (EPD) offset for connection queues. On ATM IP FPs a given connection queue is associated with one of eight emission priorities (EP). These include six unshaped EPs, one exclusive VBR shaper EP and one ABR/VBR shaper EP. This attribute specifies the EPD offset for the exclusive ABR/VBR shaper EP and the last two (lower priority) unshaped EPs. This offset is used to derive a connection EPD threshold for a given Congestion Control (CC) level by subtracting the offset from the All Packet Discard (APD) threshold at the same CC level. The APD thresholds are themselves derived from the transmit queue limit. The EPD threshold only applies to a connection if the txPacketWiseDiscard feature is requested. The txPacketWiseDiscard feature can be enabled only if the transmit queue limit is at least 5.71 times the EPD offset. This ensures that the derived EPD threshold will never be less than 17.5 % of the transmit queue limit. If this condition is not satisfied, txPacketWiseDiscard for the connection will be automatically disabled. Due to the above constraint, if the operator wishes to decrease the transmit queue limit and still have txPacketWiseDiscard enabled on the connection then this offset must be set to a lower value that meets the above requirement. Due to hardware granularity the actual value of the EPD offset may not match exactly the value provisioned. The actual value is displayed under the ATM Connection Administrator service category subcomponents on ATM IP FPs. This attribute does not apply to CQC FPs.')
lpEngArcAqmOvPortCongestionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aggregate", 0), ("individualQueue", 1))).clone('individualQueue')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcAqmOvPortCongestionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvPortCongestionPolicy.setDescription('This attribute specifies the congestion behavior of all ports on this FP. It applies only to transmit traffic and does not apply to the CBR service category. When the value is aggregate, the enqueue decision of cells or frames to a queue is based upon the congestion state of the entire port to which the queue belongs. A port is defined to be as congested as the most congested queue amongst all its queues. Thus, for example, if a nrtVBR queue is congested, the rtVBR queue also experiences discards even though the rtVBR queue may itself not be congested. Setting this attribute to aggregate assures that the low priority queues are also serviced in the event of congestion. If this attribute is set to aggregate then rtVBR must not be configured to do common queueing and its emissionPriority should be set to a number numerically smaller than or equal to 3. Another impact of setting this attribute to aggregate is that the per connection queue limits for nrtVBR and UBR connections will be increased to the link pool size and their discard thresholds will be modified to be aligned with the free list discard thresholds. When the value of this attribute is set to individualQueue, the enqueue decision of cells or frames to a queue is based solely upon the congestion state of that queue, not the port. This setting assures that the absolute priority of the traffic is taken into account, regardless of whether the lower priority queues are being served. On 3pOC3SmAtm2 and 3pOC3MmAtm2 cards, if more than one override component exists, they must have the same setting for this attribute. Otherwise, setting the attribute under one override component applies to the entire card.')
lpEngArcAqmOvMaxVirtualLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(6, 6), ValueRangeConstraint(14, 14), ValueRangeConstraint(29, 29), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcAqmOvMaxVirtualLinks.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvMaxVirtualLinks.setDescription('This attribute specifies the maximum number of virtual links that can use this AQM. Refer to the description of the operational attribute maxVirtualLinks under component Lp/n Eng Arc Aqm/n for a complete description of the effects of setting this attribute. On all card types except 3pE3Atm2, this attribute may be set to any of the valid values. On 3pE3Atm2 cards this attribute may only be set to sameNumberAsPorts, 14, or 29, since, due to hardware considerations, there is no advantage to setting the value to 6, and there are advantages to not doing so. VALUES ( 0 = sameNumberAsPorts )')
lpEngArcAqmOvVirtualLinkGranularity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 5, 4, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("minimum", 0), ("ds1", 1), ("e1", 2), ("jt2", 3))).clone('minimum')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngArcAqmOvVirtualLinkGranularity.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngArcAqmOvVirtualLinkGranularity.setDescription('This attribute specifies the granularity on which virtual link bandwidths are allocated. A value of minimum indicates the granularity is as small as possible for the specific card on which the Aqm component resides. A value of DS1, E1, or JT2 indicates that the VL bandwidths should be allocated in multiples of the DS1, E1, or JT2 cell rates (nominally 3622 cell/s, 4528 cell/s, and 14490 cell/ s respectively).')
lpEngFcrc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6))
lpEngFcrcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 1), )
if mibBuilder.loadTexts: lpEngFcrcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngFcrc components.')
lpEngFcrcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"))
if mibBuilder.loadTexts: lpEngFcrcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRowStatusEntry.setDescription('A single entry in the table represents a single lpEngFcrc component.')
lpEngFcrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngFcrcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngFcrc components. These components can be added and deleted.')
lpEngFcrcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngFcrcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcStorageType.setDescription('This variable represents the storage type value for the lpEngFcrc tables.')
lpEngFcrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngFcrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcIndex.setDescription('This variable represents the index for the lpEngFcrc tables.')
lpEngFcrcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10), )
if mibBuilder.loadTexts: lpEngFcrcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOperTable.setDescription('This group indicates the configuration of processor-wide frame specific resources on a LogicalProcessor.')
lpEngFcrcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"))
if mibBuilder.loadTexts: lpEngFcrcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOperEntry.setDescription('An entry in the lpEngFcrcOperTable.')
lpEngFcrcSubConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 49152))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcSubConnectionPoolAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcSubConnectionPoolAvailable.setDescription('This attribute indicates the number of sub-connections available for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/n Dlci/n Siwf McsMgr Frf5EpG/n Frf5Ep/n Lmi McsMgr Frf5EpG/n Frf5Ep/n Dlci/n Note: When the value of this attribute reaches zero, no more connections are accepted for any of the services which utilize this pool. To increase the size of this pool, use the Lp Eng Fcrc Ov subConnectionPoolCapacity attribute.')
lpEngFcrcSubConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 49152))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcSubConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcSubConnectionPoolUsage.setDescription('This attribute indicates the number of sub-connections being utilized by the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/n Dlci/n Siwf McsMgr Frf5EpG/n Frf5Ep/n Lmi McsMgr Frf5EpG/n Frf5Ep/n Dlci/n')
lpEngFcrcLnnConnectionPoolAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcLnnConnectionPoolAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcLnnConnectionPoolAvailable.setDescription('This attribute indicates the number of resource records available for the connections which utilize Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of Passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. An LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is allocated at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/n Ep/n EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/n Ep/n component uses one resource record from this pool, otherwise it does not use this pool. When the value of this attribute reaches zero, no more connections are accepted for any of the services which utilize this pool. To increase the size of this pool, use the Fcrc Ov lnnConnectionPoolCapacity attribute.')
lpEngFcrcLnnConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2048))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcLnnConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcLnnConnectionPoolUsage.setDescription('This attribute indicates the number of resource records being utilized for the connections which use Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of Passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. An LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is applied at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/n Ep/n EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/n Ep/n component uses one resource record from this pool, otherwise it does not use this pool.')
lpEngFcrcTxFrameMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryAvailable.setDescription('This attribute indicates the current availability of the transmit frame memory (in units of frames). The transmit frame memory is the memory available for storing frames to be transmitted by this FP.')
lpEngFcrcTxFrameMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryMinAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the transmit PQC/ CQC frame memory (in units of frames). The transmit frame memory is the memory available for storing frames to be transmitted by this FP. This value is reset every 15 minutes and when the card is reset.')
lpEngFcrcTxFrameMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryCongestionState.setDescription("This attribute indicates the congestion state of the transmit frame memory for this FP. This attribute indicates which txFrameMemoryThresholds corresponds to the current value of txFrameMemoryUsage. The congestion state is used to determine if frames of a particular discard priority (DP) are discarded before being queued for transmit. The congestion state of transmit frame memory is indicated by a numeric value ranging from 3 to 0. When transmit frame memory is in congestion state 'x', traffic with DP > 'x' is discarded before transmit. Traffic with DP < 'x' may be queued for transmit, depending on the congestion level of the transmit queue. Traffic with DP = 'x' may be either queued or discarded depending on how close the value of txFrameMemoryUsage is to the next threshold as displayed in txFrameMemoryThresholds. For example, DP=3 traffic is queued until the value indicated by txFrameMemoryUsage equals the value indicated in txFrameMemoryThresholds 3. At that point, DP=3 traffic is discarded.")
lpEngFcrcRxFrameMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryAvailable.setDescription('This attribute indicates the current availability of the receive frame memory (in units of frames). The receive frame memory is the memory available for storing frames received by this FP.')
lpEngFcrcRxFrameMemoryMinAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryMinAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryMinAvailable.setDescription('This attribute indicates the lowest availability of the receive frame memory (in units of frames). The receive frame memory is the memory available for storing frames received by this FP. This value is reset every 15 minutes and when the card is reset.')
lpEngFcrcRxFrameMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryCongestionState.setDescription("This attribute indicates the congestion state of the receive frame memory for this FP. This attribute indicates which rxFrameMemoryThresholds corresponds to the current value of rxFrameMemoryUsage. The congestion state is used to determine if frames of a particular discard priority (DP) are discarded before being queued for processing on this FP. The congestion state of receive frame memory is indicated by a numeric value ranging from 3 to 0. When receive frame memory is in congestion state 'x', traffic with DP > 'x' is discarded before processing. Traffic with DP < 'x' may be queued for processing, depending on the congestion level of the processor or bus queue. Traffic with DP = 'x' may be either queued or discarded depending on how close the value of rxFrameMemoryUsage is to the next threshold as displayed in rxFrameMemoryThresholds. For example, DP=3 traffic is queued until the value indicated by rxFrameMemoryUsage equals the value indicated in rxFrameMemoryThresholds 3. At that point, DP=3 traffic is discarded.")
lpEngFcrcTxFrameMemoryMaxUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryMaxUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryMaxUsage.setDescription('This attribute indicates the maximum number which has recently occurred for the txFrameMemoryUsage attribute. On CQC-based ATM FPs, this number indicates the maximum usage of transmit frames for all ports on this FP. On ATM IP FPs, this number indicates the maximum usage of transmit frames in the Passport Queue Controller (PQC) ASIC. Queuing of frames for transmit only occurs in the PQC. This value is reset to the current usage every 15 minutes and when the card is reset.')
lpEngFcrcTxFrameMemoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcTxFrameMemoryUsage.setDescription('This attribute indicates the current number of transmit frames which are in use for this FP. On CQC-based ATM FPs, this number indicates the total transmit frames which are in use for all ports on this FP. On ATM IP FPs, this number indicates the number of transmit frames which are in use in the Passport Queue Controller (PQC) ASIC. Queuing of frames for transmit only occurs in the PQC.')
lpEngFcrcRxFrameMemoryMaxUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryMaxUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryMaxUsage.setDescription('This attribute indicates the maximum number which has recently occurred for the rxFrameMemorySize attribute. On CQC-based ATM FPs, this number indicates the maximum usage of receive frames for all ports on this FP. On ATM IP FPs, this number indicates the maximum usage of received frames in the Passport Queue Controller (PQC) ASIC. Queuing of received frames only occurs in the PQC. This value is reset to the current usage every 15 minutes and when the card is reset.')
lpEngFcrcRxFrameMemoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 10, 1, 14), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRxFrameMemoryUsage.setDescription('This attribute indicates the current number of receive frames which are in use for this FP. On CQC-based ATM FPs, this number indicates the total receive frames which are in use for all ports on this FP. On ATM IP FPs, this number indicates the number of receive frames which are in use in the Passport Queue Controller (PQC) ASIC. Queuing of received frames only occurs in the PQC.')
lpEngFcrcTxFrThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 442), )
if mibBuilder.loadTexts: lpEngFcrcTxFrThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcTxFrThreshTable.setDescription('This attribute is a vector which indicates the size and three discard thresholds for transmit frame memory for this FP. The transmit frame memory is used for storing frames to be transmitted by this FP. The first value indicates the transmit frame memory size. This is derived based on the total transmit memory capacity of this FP, and the number of connections specified. The current value of txFrameMemoryUsage together with the vector of values in txFrameMemoryThresholds determines the txFrameMemoryCongestionState. The congestion state determines whether frames of a given discard priority (DP) are discarded or queued for transmit. When the txFrameMemoryUsage attribute is between threshold 0 and threshold 1, the txFrameMemoryCongestionState indicates the value 0. In congestion state 0, traffic with DP > 0 is discarded. Threshold 1 is set approximately at 90 percent of threshold 0, the total transmit frame memory size. When the txFrameMemoryUsage attribute is between threshold 1 and threshold 2, the txFrameMemoryCongestionState indicates the value 1. In congestion state 1, traffic with DP > 1 is discarded. Threshold 2 is set approximately at 85 percent of threshold 0, the total transmit frame memory size. When the txFrameMemoryUsage attribute is between threshold 2 and threshold 3, the txFrameMemoryCongestionState indicates the value 2. In congestion state 2, traffic with DP > 2 is discarded. Threshold 3 is set approximately at 75 percent of threshold 0, the total transmit frame memory size. When the txFrameMemoryUsage attribute is below threshold 3, the txFrameMemoryCongestionState indicates the value 3. In congestion state 3, traffic with DP=3 is queued.')
lpEngFcrcTxFrThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 442, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcTxFrThreshIndex"))
if mibBuilder.loadTexts: lpEngFcrcTxFrThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcTxFrThreshEntry.setDescription('An entry in the lpEngFcrcTxFrThreshTable.')
lpEngFcrcTxFrThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 442, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpEngFcrcTxFrThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcTxFrThreshIndex.setDescription('This variable represents the lpEngFcrcTxFrThreshTable specific index for the lpEngFcrcTxFrThreshTable.')
lpEngFcrcTxFrThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 442, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcTxFrThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcTxFrThreshValue.setDescription('This variable represents an individual value for the lpEngFcrcTxFrThreshTable.')
lpEngFcrcRxFrThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 446), )
if mibBuilder.loadTexts: lpEngFcrcRxFrThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRxFrThreshTable.setDescription('This attribute is a vector which indicates the size and three discard thresholds for receive frame memory for this FP. The receive frame memory is used for storing frames received by this FP. The first value indicates the total receive frame memory size. This is derived based on the total receive memory capacity of this FP, and the number of connections specified. The current value of rxFrameMemoryUsage together with the vector of values in rxFrameMemoryThresholds determines the rxFrameMemoryCongestionState. The congestion state determines whether frames of a given discard priority (DP) are discarded or queued for processing. When the rxFrameMemoryUsage attribute is between threshold 0 and threshold 1, the rxFrameMemoryCongestionState indicates the value 0. In congestion state 0, traffic with DP > 0 is discarded. Threshold 1 is set approximately at 90 percent of threshold 0, the total receive frame memory size. When the rxFrameMemoryUsage attribute is between threshold 1 and threshold 2, the rxFrameMemoryCongestionState indicates the value 1. In congestion state 1, traffic with DP > 1 is discarded. Threshold 2 is set approximately at 85 percent of threshold 0, the total receive frame memory size. When the rxFrameMemoryUsage attribute is between threshold 2 and threshold 3, the rxFrameMemoryCongestionState indicates the value 2. In congestion state 2, traffic with DP > 2 is discarded. Threshold 3 is set approximately at 75 percent of threshold 0, the total receive frame memory size. When the rxFrameMemoryUsage attribute is below threshold 3, the rxFrameMemoryCongestionState indicates the value 3. In congestion state 3, traffic with DP=3 is queued.')
lpEngFcrcRxFrThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 446, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcRxFrThreshIndex"))
if mibBuilder.loadTexts: lpEngFcrcRxFrThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRxFrThreshEntry.setDescription('An entry in the lpEngFcrcRxFrThreshTable.')
lpEngFcrcRxFrThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 446, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: lpEngFcrcRxFrThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRxFrThreshIndex.setDescription('This variable represents the lpEngFcrcRxFrThreshTable specific index for the lpEngFcrcRxFrThreshTable.')
lpEngFcrcRxFrThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 446, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcRxFrThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcRxFrThreshValue.setDescription('This variable represents an individual value for the lpEngFcrcRxFrThreshTable.')
lpEngFcrcOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2))
lpEngFcrcOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 1), )
if mibBuilder.loadTexts: lpEngFcrcOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngFcrcOv components.')
lpEngFcrcOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcOvIndex"))
if mibBuilder.loadTexts: lpEngFcrcOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvRowStatusEntry.setDescription('A single entry in the table represents a single lpEngFcrcOv component.')
lpEngFcrcOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngFcrcOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngFcrcOv components. These components can be added and deleted.')
lpEngFcrcOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngFcrcOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvStorageType.setDescription('This variable represents the storage type value for the lpEngFcrcOv tables.')
lpEngFcrcOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngFcrcOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvIndex.setDescription('This variable represents the index for the lpEngFcrcOv tables.')
lpEngFcrcOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 10), )
if mibBuilder.loadTexts: lpEngFcrcOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvProvTable.setDescription('This group contains frame services provisionable engineering parameters for this LogicalProcessor. Note that altering any of these parameters will result in a card reset.')
lpEngFcrcOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcOvIndex"))
if mibBuilder.loadTexts: lpEngFcrcOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvProvEntry.setDescription('An entry in the lpEngFcrcOvProvTable.')
lpEngFcrcOvSubConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 49152), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngFcrcOvSubConnectionPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvSubConnectionPoolCapacity.setDescription('This attribute indicates the maximum number of sub-connections for the LogicalProcessor. A sub-connection is used for interworking the ATM services with the frame oriented services such as Frame Relay and Path Oriented Routing System (PORS). When a frame is received at a sub- connection, the frame header is modified to be compatible with the service it is to be forwarded to. Due to limited resources, not all of the sub-connections requested by this attribute may be allocated. The desired number of sub- connections allocated is indicated by the sum of fcrc subConnectionPoolAvailable and fcrc subConnectionPoolUsage attributes. This pool is used for connection oriented services only. Each of the following components uses one sub-connection from this pool: FrAtm/n Dlci/n Siwf McsMgr Frf5EpG/n Frf5Ep/n Lmi McsMgr Frf5EpG/n Frf5Ep/n Dlci/n When the sub-connection pool is exhausted, no more connections are accepted from the services which utilize this pool. Note: Ip Routing entries also compete for this memory. The maximum size of this pool is 8192 for CQC based cards. The default cardDependent has the effect of setting subConnectionPoolCapacity to 1024 for both CQC cards and SGAF cards. VALUES ( 65535 = cardDependent )')
lpEngFcrcOvLnnConnectionPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2048), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngFcrcOvLnnConnectionPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcOvLnnConnectionPoolCapacity.setDescription('This attribute indicates the maximum number of resource records for the connections which utilize Logical Network Number (LNN) on the LogicalProcessor. A logical network is a subset of passport modules together with a subset of trunks that interconnect those modules. It carries the traffic for a defined set of network protocols. An LNN is used to identify a logical network. The connectionless services which utilize the logical networks require some processing at the intermediate nodes. This pool is allocated at the intermediate nodes to sustain these connectionless services. If the McsMgr DprsMcsEpG/n Ep/n EpD transportConnectionPreference attribute is set to atmOnly, each instance of the McsMgr DprsMcsEpG/n Ep/n component uses one resource record from this pool, otherwise it does not use this pool. Note: Frame and Cell queues also compete for this memory. Each DPRS instance requires two resource records and each VNS instance requires one resource records from this pool. (A VNS instance is an lnn combined with a trunk). The maximum size of this pool is 256 for CQC based cards. The default cardDependent has the effect of setting lnnConnectionPoolCapacity to 128 for CQC cards and 256 for SGAF cards. VALUES ( 0 = cardDependent )')
lpEngFcrcPqc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3))
lpEngFcrcPqcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 1), )
if mibBuilder.loadTexts: lpEngFcrcPqcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngFcrcPqc components.')
lpEngFcrcPqcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcPqcIndex"))
if mibBuilder.loadTexts: lpEngFcrcPqcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcRowStatusEntry.setDescription('A single entry in the table represents a single lpEngFcrcPqc component.')
lpEngFcrcPqcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngFcrcPqcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngFcrcPqc components. These components can be added and deleted.')
lpEngFcrcPqcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcPqcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngFcrcPqcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcPqcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcStorageType.setDescription('This variable represents the storage type value for the lpEngFcrcPqc tables.')
lpEngFcrcPqcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngFcrcPqcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcIndex.setDescription('This variable represents the index for the lpEngFcrcPqc tables.')
lpEngFcrcPqcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 10), )
if mibBuilder.loadTexts: lpEngFcrcPqcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOperTable.setDescription('This group describes the usage of resources specific to frame services on a PQC based FP.')
lpEngFcrcPqcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcPqcIndex"))
if mibBuilder.loadTexts: lpEngFcrcPqcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOperEntry.setDescription('An entry in the lpEngFcrcPqcOperTable.')
lpEngFcrcPqcIpRoutesPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 10, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcPqcIpRoutesPoolSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcIpRoutesPoolSize.setDescription('This attribute indicates the number of IP routing entries permitted on the Logical Processor. If there are enough resources on the card, this value is equal to the provisioned attribute (in Fcrc Pqc Ov) ipRoutesPoolCapacity.')
lpEngFcrcPqcIpRoutesPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcPqcIpRoutesPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcIpRoutesPoolUsage.setDescription('This attribute represents the current number of IP routing entries that are in use.')
lpEngFcrcPqcIpRoutesPoolAvailableEst = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 10, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcPqcIpRoutesPoolAvailableEst.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcIpRoutesPoolAvailableEst.setDescription('Each IP routing resource can hold between one and three IP routing entries. Therefore, it is not possible to know exactly how many more IP routing entries can be added to the IP routing table. This attribute specifies the estimated number of IP routing entries that are available on the Logical Processor. It is an approximation based on the current average number of IP routing entries per IP routing resource.')
lpEngFcrcPqcOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2))
lpEngFcrcPqcOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 1), )
if mibBuilder.loadTexts: lpEngFcrcPqcOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngFcrcPqcOv components.')
lpEngFcrcPqcOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcPqcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcPqcOvIndex"))
if mibBuilder.loadTexts: lpEngFcrcPqcOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvRowStatusEntry.setDescription('A single entry in the table represents a single lpEngFcrcPqcOv component.')
lpEngFcrcPqcOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcPqcOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngFcrcPqcOv components. These components cannot be added nor deleted.')
lpEngFcrcPqcOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcPqcOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngFcrcPqcOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngFcrcPqcOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvStorageType.setDescription('This variable represents the storage type value for the lpEngFcrcPqcOv tables.')
lpEngFcrcPqcOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngFcrcPqcOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvIndex.setDescription('This variable represents the index for the lpEngFcrcPqcOv tables.')
lpEngFcrcPqcOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 10), )
if mibBuilder.loadTexts: lpEngFcrcPqcOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvProvTable.setDescription('This group is used for fine tuning resource configuration of frame services on a PQC based Logical Processor.')
lpEngFcrcPqcOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcPqcIndex"), (0, "Nortel-Magellan-Passport-AtmBaseMIB", "lpEngFcrcPqcOvIndex"))
if mibBuilder.loadTexts: lpEngFcrcPqcOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvProvEntry.setDescription('An entry in the lpEngFcrcPqcOvProvTable.')
lpEngFcrcPqcOvIpRoutesPoolCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 6, 3, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000)).clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngFcrcPqcOvIpRoutesPoolCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngFcrcPqcOvIpRoutesPoolCapacity.setDescription('This attribute indicates the number of desired IP routing entries for the Logical Processor. It is used to determine the number of IP routing resources to be allocated on the card. Each IP routing resource can hold between one and three IP routing entries. To calculate the number of IP routing resources required, an average of 2 IP routing entries per IP routing resource is used. If there are not enough resources on the card, a smaller pool is allocated. Operational attribute (in Fcrc Pqc) ipRoutesPoolSize indicates the actual size of the pool.')
atmBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63, 1))
atmBaseGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63, 1, 5))
atmBaseGroupBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63, 1, 5, 1))
atmBaseGroupBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63, 1, 5, 1, 2))
atmBaseCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63, 3))
atmBaseCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63, 3, 5))
atmBaseCapabilitiesBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63, 3, 5, 1))
atmBaseCapabilitiesBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 63, 3, 5, 1, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmBaseMIB", lpAruTxFflThreshIndex=lpAruTxFflThreshIndex, lpEngArcAqmOvConnectionPoolCapacity=lpEngArcAqmOvConnectionPoolCapacity, lpEngArcCqcStorageType=lpEngArcCqcStorageType, lpEngArcCqcOvRowStatus=lpEngArcCqcOvRowStatus, lpEngArcAqmTxCellThreshValue=lpEngArcAqmTxCellThreshValue, lpEngFcrcTxFrameMemoryCongestionState=lpEngFcrcTxFrameMemoryCongestionState, lpEngArcTxCellThreshIndex=lpEngArcTxCellThreshIndex, lpEngArcCqcRowStatus=lpEngArcCqcRowStatus, lpEngArcOv=lpEngArcOv, lpArcTxFrameMemoryAllocation=lpArcTxFrameMemoryAllocation, lpEngArcIndex=lpEngArcIndex, lpEngArcOvTotalConnectionPoolCapacity=lpEngArcOvTotalConnectionPoolCapacity, lpEngFcrcRowStatus=lpEngFcrcRowStatus, lpEngFcrcPqcOvRowStatus=lpEngFcrcPqcOvRowStatus, lpEngArcCqcOvCdvReduction=lpEngArcCqcOvCdvReduction, lpEngFcrcPqcOvRowStatusEntry=lpEngFcrcPqcOvRowStatusEntry, lpEngArcAqmTxCellMemoryUsage=lpEngArcAqmTxCellMemoryUsage, atmBaseCapabilitiesBE00=atmBaseCapabilitiesBE00, lpArcConnCapValue=lpArcConnCapValue, lpEngArcAqmRowStatus=lpEngArcAqmRowStatus, lpEngArcRxCellThreshEntry=lpEngArcRxCellThreshEntry, lpEngFcrcOvIndex=lpEngFcrcOvIndex, lpEngFcrcRxFrThreshIndex=lpEngFcrcRxFrThreshIndex, lpEngArcTotalConnectionPoolAvailable=lpEngArcTotalConnectionPoolAvailable, lpArcPerVcQueueInterfaces=lpArcPerVcQueueInterfaces, lpEngFcrcStorageType=lpEngFcrcStorageType, lpEngFcrcTxFrameMemoryMinAvailable=lpEngFcrcTxFrameMemoryMinAvailable, lpEngArcAqmOvHighPriorityEpdOffset=lpEngArcAqmOvHighPriorityEpdOffset, lpEngArcCqcOvStorageType=lpEngArcCqcOvStorageType, lpEngArcCqcRowStatusTable=lpEngArcCqcRowStatusTable, lpEngFcrcRxFrThreshTable=lpEngFcrcRxFrThreshTable, lpAruLnnConnectionPoolAvailable=lpAruLnnConnectionPoolAvailable, lpEngArcRxCellMemoryUsage=lpEngArcRxCellMemoryUsage, lpEngArcOvComponentName=lpEngArcOvComponentName, lpEngArcAqmTxCellThreshTable=lpEngArcAqmTxCellThreshTable, lpEngArcRxCellThreshTable=lpEngArcRxCellThreshTable, lpAruRxFflThreshValue=lpAruRxFflThreshValue, lpEngFcrcOvComponentName=lpEngFcrcOvComponentName, lpEngArcAqmOvProvEntry=lpEngArcAqmOvProvEntry, lpArcMulticastBranchesCapacity=lpArcMulticastBranchesCapacity, lpAruOperTable=lpAruOperTable, lpAruRowStatus=lpAruRowStatus, lpEngArcAqmConnectionPoolUsage=lpEngArcAqmConnectionPoolUsage, lpEngArcAqmOperTable=lpEngArcAqmOperTable, lpArcConnCapEntry=lpArcConnCapEntry, lpEngArcAqmTxCellThreshIndex=lpEngArcAqmTxCellThreshIndex, lpEngFcrcIndex=lpEngFcrcIndex, lpAruRowStatusTable=lpAruRowStatusTable, lpEngArcCqcComponentName=lpEngArcCqcComponentName, lpEngArcStorageType=lpEngArcStorageType, lpEngFcrc=lpEngFcrc, lpEngArcOvTxCellMemoryAllocation=lpEngArcOvTxCellMemoryAllocation, lpEngArcRowStatusTable=lpEngArcRowStatusTable, lpAruTxFflThreshEntry=lpAruTxFflThreshEntry, lpEngArcAqmOvStorageType=lpEngArcAqmOvStorageType, lpEngFcrcTxFrameMemoryUsage=lpEngFcrcTxFrameMemoryUsage, lpEngFcrcPqcOvRowStatusTable=lpEngFcrcPqcOvRowStatusTable, lpEngArcAqmTxCellMemoryCongestionState=lpEngArcAqmTxCellMemoryCongestionState, lpEngFcrcOv=lpEngFcrcOv, lpAruTxCellBlockCapacity=lpAruTxCellBlockCapacity, lpEngFcrcPqcOvProvEntry=lpEngFcrcPqcOvProvEntry, lpEngFcrcPqc=lpEngFcrcPqc, atmBaseGroup=atmBaseGroup, lpAruTxCellBlockUsage=lpAruTxCellBlockUsage, lpEngFcrcPqcOvProvTable=lpEngFcrcPqcOvProvTable, lpAruComponentName=lpAruComponentName, lpAruRxCellBlockUsage=lpAruRxCellBlockUsage, lpEngArcAqmStorageType=lpEngArcAqmStorageType, lpEngArcOvRowStatusEntry=lpEngArcOvRowStatusEntry, lpAruStorageType=lpAruStorageType, lpArcConnCapIndex=lpArcConnCapIndex, lpArcRowStatusEntry=lpArcRowStatusEntry, lpEngArcCqcOperTable=lpEngArcCqcOperTable, lpEngArcCqcOv=lpEngArcCqcOv, lpEngArcAqmMaxVirtualLinks=lpEngArcAqmMaxVirtualLinks, lpEngFcrcPqcIpRoutesPoolUsage=lpEngFcrcPqcIpRoutesPoolUsage, lpEngArcMulticastBranchesAvailable=lpEngArcMulticastBranchesAvailable, lpEngArcAqmTxCellMemoryAvailable=lpEngArcAqmTxCellMemoryAvailable, lpEngFcrcRxFrThreshValue=lpEngFcrcRxFrThreshValue, lpEngFcrcOvProvTable=lpEngFcrcOvProvTable, lpEngFcrcTxFrThreshEntry=lpEngFcrcTxFrThreshEntry, lpEngFcrcTxFrThreshTable=lpEngFcrcTxFrThreshTable, lpArcSubConnectionPoolCapacity=lpArcSubConnectionPoolCapacity, lpEngArcCqcOvComponentName=lpEngArcCqcOvComponentName, lpEngArcRxCellMemoryAllocation=lpEngArcRxCellMemoryAllocation, lpEngFcrcRxFrameMemoryMaxUsage=lpEngFcrcRxFrameMemoryMaxUsage, lpArcLnnConnectionPoolCapacity=lpArcLnnConnectionPoolCapacity, lpAruRxFrameBlockUsage=lpAruRxFrameBlockUsage, lpAruRxFflThreshEntry=lpAruRxFflThreshEntry, lpEngArcOvStorageType=lpEngArcOvStorageType, lpAruRxCellBlockCapacity=lpAruRxCellBlockCapacity, lpArc=lpArc, lpAruConnUsageIndex=lpAruConnUsageIndex, lpAruRxCflThreshTable=lpAruRxCflThreshTable, lpArcRowStatus=lpArcRowStatus, lpAruTxFflThreshValue=lpAruTxFflThreshValue, lpEngArcAqmOvRowStatusTable=lpEngArcAqmOvRowStatusTable, lpEngArcMulticastBranchesUsage=lpEngArcMulticastBranchesUsage, lpEngArcAqmOvComponentName=lpEngArcAqmOvComponentName, lpEngFcrcTxFrameMemoryAvailable=lpEngFcrcTxFrameMemoryAvailable, lpEngFcrcRowStatusEntry=lpEngFcrcRowStatusEntry, lpEngArcCqcIndex=lpEngArcCqcIndex, lpAruMulticastBranchesUsage=lpAruMulticastBranchesUsage, lpEngArc=lpEngArc, lpAruOperEntry=lpAruOperEntry, lpEngArcTxCellMemoryAvailable=lpEngArcTxCellMemoryAvailable, lpAruTxCflThreshIndex=lpAruTxCflThreshIndex, lpEngArcComponentName=lpEngArcComponentName, lpEngArcCqcOvIndex=lpEngArcCqcOvIndex, lpAruRxFflThreshIndex=lpAruRxFflThreshIndex, lpEngFcrcRxFrameMemoryAvailable=lpEngFcrcRxFrameMemoryAvailable, lpEngFcrcPqcOperTable=lpEngFcrcPqcOperTable, lpAruRxCflThreshValue=lpAruRxCflThreshValue, lpAruConnUsageTable=lpAruConnUsageTable, lpEngArcRxCellMemoryAvailable=lpEngArcRxCellMemoryAvailable, lpEngArcOvIndex=lpEngArcOvIndex, atmBaseCapabilitiesBE00A=atmBaseCapabilitiesBE00A, lpEngFcrcPqcOvIndex=lpEngFcrcPqcOvIndex, atmBaseCapabilities=atmBaseCapabilities, lpAruTxCellFreeListCongestionState=lpAruTxCellFreeListCongestionState, lpEngArcAqm=lpEngArcAqm, lpEngFcrcPqcIpRoutesPoolSize=lpEngFcrcPqcIpRoutesPoolSize, lpEngFcrcPqcRowStatus=lpEngFcrcPqcRowStatus, lpEngArcTxCellMemoryMaxUsage=lpEngArcTxCellMemoryMaxUsage, lpEngFcrcOvProvEntry=lpEngFcrcOvProvEntry, lpEngArcAqmVirtualLinkUsage=lpEngArcAqmVirtualLinkUsage, lpEngArcTotalConnectionPoolUsage=lpEngArcTotalConnectionPoolUsage, lpAruTxFflThreshTable=lpAruTxFflThreshTable, lpEngArcRxCellMemoryCongestionState=lpEngArcRxCellMemoryCongestionState, lpEngArcAqmOperEntry=lpEngArcAqmOperEntry, lpAruSubConnectionPoolAvailable=lpAruSubConnectionPoolAvailable, atmBaseGroupBE=atmBaseGroupBE, lpEngFcrcOvRowStatus=lpEngFcrcOvRowStatus, lpEngArcCqcRowStatusEntry=lpEngArcCqcRowStatusEntry, lpEngArcTxCellMemoryAllocation=lpEngArcTxCellMemoryAllocation, lpEngFcrcPqcOv=lpEngFcrcPqcOv, lpAruTxFrameFreeListCongestionState=lpAruTxFrameFreeListCongestionState, lpArcComponentName=lpArcComponentName, lpAruTxFrameBlockCapacity=lpAruTxFrameBlockCapacity, lpEngArcCqcOvProvTable=lpEngArcCqcOvProvTable, lpAru=lpAru, lpEngArcAqmOvProvTable=lpEngArcAqmOvProvTable, lpEngArcCqcOvPerVcQueueInterfaces=lpEngArcCqcOvPerVcQueueInterfaces, lpEngArcOvRxCellMemoryAllocation=lpEngArcOvRxCellMemoryAllocation, lpEngArcCqcOvPortCongestionPolicy=lpEngArcCqcOvPortCongestionPolicy, lpEngArcAqmOvMaxVirtualLinks=lpEngArcAqmOvMaxVirtualLinks, lpEngFcrcPqcOvComponentName=lpEngFcrcPqcOvComponentName, lpEngArcCqcOvRowStatusEntry=lpEngArcCqcOvRowStatusEntry, lpEngFcrcOvRowStatusEntry=lpEngFcrcOvRowStatusEntry, lpEngFcrcPqcRowStatusEntry=lpEngFcrcPqcRowStatusEntry, lpEngArcTxCellMemoryMinAvailable=lpEngArcTxCellMemoryMinAvailable, lpEngFcrcPqcIndex=lpEngFcrcPqcIndex, lpEngArcOvProvEntry=lpEngArcOvProvEntry, lpEngArcTxCellThreshValue=lpEngArcTxCellThreshValue, lpAruLnnConnectionPoolUsage=lpAruLnnConnectionPoolUsage, lpArcCdvAttenuation=lpArcCdvAttenuation, lpEngFcrcTxFrameMemoryMaxUsage=lpEngFcrcTxFrameMemoryMaxUsage, lpEngArcTxCellMemoryCongestionState=lpEngArcTxCellMemoryCongestionState, lpAruTxFrameMemoryAllocation=lpAruTxFrameMemoryAllocation, lpEngFcrcPqcStorageType=lpEngFcrcPqcStorageType, lpEngFcrcPqcOvIpRoutesPoolCapacity=lpEngFcrcPqcOvIpRoutesPoolCapacity, lpAruRxCellFreeListSize=lpAruRxCellFreeListSize, lpEngArcAqmTxCellThreshEntry=lpEngArcAqmTxCellThreshEntry, lpAruRxFrameBlockCapacity=lpAruRxFrameBlockCapacity, lpAruRxFflThreshTable=lpAruRxFflThreshTable, lpEngArcOvMulticastBranchesCapacity=lpEngArcOvMulticastBranchesCapacity, lpEngArcAqmVirtualLinkGranularity=lpEngArcAqmVirtualLinkGranularity, lpEngArcAqmOvVirtualLinkGranularity=lpEngArcAqmOvVirtualLinkGranularity, atmBaseCapabilitiesBE=atmBaseCapabilitiesBE, lpEngArcAqmConnectionPoolAvailable=lpEngArcAqmConnectionPoolAvailable, lpAruRxCflThreshEntry=lpAruRxCflThreshEntry, lpEngArcTxCellThreshEntry=lpEngArcTxCellThreshEntry, lpEngArcCqcOvConnCapTable=lpEngArcCqcOvConnCapTable, lpEngFcrcPqcComponentName=lpEngFcrcPqcComponentName, lpEngArcAqmRowStatusTable=lpEngArcAqmRowStatusTable, lpEngArcTxCellMemoryUsage=lpEngArcTxCellMemoryUsage, lpAruRxFrameFreeListCongestionState=lpAruRxFrameFreeListCongestionState, lpAruConnUsageEntry=lpAruConnUsageEntry, lpEngArcRxCellMemoryMinAvailable=lpEngArcRxCellMemoryMinAvailable, lpEngFcrcRxFrameMemoryMinAvailable=lpEngFcrcRxFrameMemoryMinAvailable, lpAruTxCellFreeListSize=lpAruTxCellFreeListSize, lpEngFcrcTxFrThreshIndex=lpEngFcrcTxFrThreshIndex, lpAruRowStatusEntry=lpAruRowStatusEntry, atmBaseGroupBE00=atmBaseGroupBE00, lpEngArcOvProvTable=lpEngArcOvProvTable, lpAruTxCflThreshValue=lpAruTxCflThreshValue, lpEngArcCqcOvConnCapEntry=lpEngArcCqcOvConnCapEntry, lpEngFcrcLnnConnectionPoolAvailable=lpEngFcrcLnnConnectionPoolAvailable, lpEngArcCqcOvProvEntry=lpEngArcCqcOvProvEntry, lpEngArcOvRowStatusTable=lpEngArcOvRowStatusTable, lpArcConnCapTable=lpArcConnCapTable, lpEngFcrcOperEntry=lpEngFcrcOperEntry, lpArcRxFrameMemoryAllocation=lpArcRxFrameMemoryAllocation, lpArcTotalConnectionPoolCapacity=lpArcTotalConnectionPoolCapacity, lpEngArcCqc=lpEngArcCqc, lpEngArcAqmComponentName=lpEngArcAqmComponentName, lpAruRxCellFreeListCongestionState=lpAruRxCellFreeListCongestionState, lpEngFcrcRxFrThreshEntry=lpEngFcrcRxFrThreshEntry, lpAruConnUsageValue=lpAruConnUsageValue, lpEngArcOperEntry=lpEngArcOperEntry, lpAruTxCflThreshTable=lpAruTxCflThreshTable, lpAruRxFrameMemoryAllocation=lpAruRxFrameMemoryAllocation, lpEngArcOperTable=lpEngArcOperTable, lpEngArcAqmIndex=lpEngArcAqmIndex, lpArcShapingStackAllocation=lpArcShapingStackAllocation, lpArcPortAggregation=lpArcPortAggregation, lpAruIndex=lpAruIndex, lpEngArcAqmRowStatusEntry=lpEngArcAqmRowStatusEntry, lpEngArcAqmTxCellMemoryMaxUsage=lpEngArcAqmTxCellMemoryMaxUsage, lpEngArcAqmOv=lpEngArcAqmOv, lpArcStorageType=lpArcStorageType, lpAruRxFrameFreeListSize=lpAruRxFrameFreeListSize, lpAruSubConnectionPoolUsage=lpAruSubConnectionPoolUsage, lpEngArcOvRowStatus=lpEngArcOvRowStatus, lpEngArcAqmOvLowPriorityEpdOffset=lpEngArcAqmOvLowPriorityEpdOffset, lpEngArcCqcOvConnCapIndex=lpEngArcCqcOvConnCapIndex, lpEngFcrcOperTable=lpEngFcrcOperTable, lpEngFcrcLnnConnectionPoolUsage=lpEngFcrcLnnConnectionPoolUsage, lpEngFcrcPqcOperEntry=lpEngFcrcPqcOperEntry, lpEngFcrcPqcRowStatusTable=lpEngFcrcPqcRowStatusTable, lpEngFcrcPqcIpRoutesPoolAvailableEst=lpEngFcrcPqcIpRoutesPoolAvailableEst, lpEngFcrcPqcOvStorageType=lpEngFcrcPqcOvStorageType, lpEngArcCqcOvRowStatusTable=lpEngArcCqcOvRowStatusTable, atmBaseMIB=atmBaseMIB, lpEngFcrcOvRowStatusTable=lpEngFcrcOvRowStatusTable, lpEngArcRxCellThreshValue=lpEngArcRxCellThreshValue, lpEngFcrcOvStorageType=lpEngFcrcOvStorageType, lpEngFcrcRxFrameMemoryUsage=lpEngFcrcRxFrameMemoryUsage, lpEngArcAqmOvRowStatus=lpEngArcAqmOvRowStatus, lpEngArcCqcOperEntry=lpEngArcCqcOperEntry, atmBaseGroupBE00A=atmBaseGroupBE00A, lpAruTxFrameBlockUsage=lpAruTxFrameBlockUsage, lpArcProvEntry=lpArcProvEntry, lpEngArcAqmTxCellMemoryMinAvailable=lpEngArcAqmTxCellMemoryMinAvailable, lpEngArcRowStatus=lpEngArcRowStatus, lpEngFcrcSubConnectionPoolUsage=lpEngFcrcSubConnectionPoolUsage, lpAruTotalConnectionPoolUsage=lpAruTotalConnectionPoolUsage, lpEngFcrcOvSubConnectionPoolCapacity=lpEngFcrcOvSubConnectionPoolCapacity, lpEngArcAqmOvRowStatusEntry=lpEngArcAqmOvRowStatusEntry, lpEngArcCqcCdvReduction=lpEngArcCqcCdvReduction, lpAruTxFrameFreeListSize=lpAruTxFrameFreeListSize, lpEngArcAqmOvIndex=lpEngArcAqmOvIndex, lpEngFcrcRxFrameMemoryCongestionState=lpEngFcrcRxFrameMemoryCongestionState, lpEngFcrcComponentName=lpEngFcrcComponentName, lpArcShapingScalingFactor=lpArcShapingScalingFactor, lpArcRowStatusTable=lpArcRowStatusTable, lpEngFcrcOvLnnConnectionPoolCapacity=lpEngFcrcOvLnnConnectionPoolCapacity, lpEngArcAqmOvPortCongestionPolicy=lpEngArcAqmOvPortCongestionPolicy, lpEngArcTxCellThreshTable=lpEngArcTxCellThreshTable, lpArcIndex=lpArcIndex, lpEngArcRxCellMemoryMaxUsage=lpEngArcRxCellMemoryMaxUsage, lpEngFcrcSubConnectionPoolAvailable=lpEngFcrcSubConnectionPoolAvailable, lpArcProvTable=lpArcProvTable, lpEngFcrcRowStatusTable=lpEngFcrcRowStatusTable)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmBaseMIB", lpAruTxCflThreshEntry=lpAruTxCflThreshEntry, lpEngFcrcTxFrThreshValue=lpEngFcrcTxFrThreshValue, lpAruRxCflThreshIndex=lpAruRxCflThreshIndex, lpEngArcRowStatusEntry=lpEngArcRowStatusEntry, lpEngArcCqcOvConnCapValue=lpEngArcCqcOvConnCapValue, lpEngArcCqcOvShapingScalingFactor=lpEngArcCqcOvShapingScalingFactor, lpEngArcRxCellThreshIndex=lpEngArcRxCellThreshIndex)

#
# PySNMP MIB module OLD-CISCO-IP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/OLD-CISCO-IP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:32:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
local, = mibBuilder.importSymbols("CISCO-SMI", "local")
ipAdEntAddr, = mibBuilder.importSymbols("IP-MIB", "ipAdEntAddr")
ipRouteDest, = mibBuilder.importSymbols("RFC1213-MIB", "ipRouteDest")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, ObjectIdentity, Counter64, TimeTicks, ModuleIdentity, Integer32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, NotificationType, Unsigned32, MibIdentifier, Counter32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "ObjectIdentity", "Counter64", "TimeTicks", "ModuleIdentity", "Integer32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "NotificationType", "Unsigned32", "MibIdentifier", "Counter32", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
lip = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 2, 4))
lipAddrTable = MibTable((1, 3, 6, 1, 4, 1, 9, 2, 4, 1), )
if mibBuilder.loadTexts: lipAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: lipAddrTable.setDescription('A list of IP address entries.')
lipAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 2, 4, 1, 1), ).setIndexNames((0, "IP-MIB", "ipAdEntAddr"))
if mibBuilder.loadTexts: lipAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lipAddrEntry.setDescription('A collection of additional objects in the cisco IP implementation.')
locIPHow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locIPHow.setStatus('mandatory')
if mibBuilder.loadTexts: locIPHow.setDescription('Method of how this interface obtained its IP address.')
locIPWho = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locIPWho.setStatus('mandatory')
if mibBuilder.loadTexts: locIPWho.setDescription('IP address of who supplied this interface its IP address.')
locIPHelper = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locIPHelper.setStatus('mandatory')
if mibBuilder.loadTexts: locIPHelper.setDescription('IP helper address for broadcast forwarding support.')
locIPSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locIPSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: locIPSecurity.setDescription('IP security level. See RFC 1038.')
locIPRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locIPRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: locIPRedirects.setDescription('Boolean whether ICMP redirects will be sent or not.')
locIPUnreach = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locIPUnreach.setStatus('mandatory')
if mibBuilder.loadTexts: locIPUnreach.setDescription('Boolean whether ICMP unreachables will be sent or not.')
lipRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 2, 4, 2), )
if mibBuilder.loadTexts: lipRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: lipRouteTable.setDescription('A list of IP routing entries.')
lipRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 2, 4, 2, 1), ).setIndexNames((0, "RFC1213-MIB", "ipRouteDest"))
if mibBuilder.loadTexts: lipRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lipRouteEntry.setDescription('A collection of additional objects in the cisco IP routing implementation.')
locRtMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locRtMask.setStatus('mandatory')
if mibBuilder.loadTexts: locRtMask.setDescription('Routing table network mask.')
locRtCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locRtCount.setStatus('mandatory')
if mibBuilder.loadTexts: locRtCount.setDescription('Number of parallel routes within routing table.')
locRtUses = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: locRtUses.setStatus('mandatory')
if mibBuilder.loadTexts: locRtUses.setDescription('Number of times this route was used in a forward operation.')
actThresh = MibScalar((1, 3, 6, 1, 4, 1, 9, 2, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actThresh.setStatus('mandatory')
if mibBuilder.loadTexts: actThresh.setDescription('Threshold of IP accounting records in use before IP traffic will be unaccounted.')
actLostPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 2, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actLostPkts.setStatus('mandatory')
if mibBuilder.loadTexts: actLostPkts.setDescription('Lost IP packets due to memory limitations.')
actLostByts = MibScalar((1, 3, 6, 1, 4, 1, 9, 2, 4, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actLostByts.setStatus('mandatory')
if mibBuilder.loadTexts: actLostByts.setDescription('Total bytes of lost IP packets.')
lipAccountingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 2, 4, 7), )
if mibBuilder.loadTexts: lipAccountingTable.setStatus('mandatory')
if mibBuilder.loadTexts: lipAccountingTable.setDescription('A list of IP accounting entries.')
lipAccountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 2, 4, 7, 1), ).setIndexNames((0, "OLD-CISCO-IP-MIB", "actSrc"), (0, "OLD-CISCO-IP-MIB", "actDst"))
if mibBuilder.loadTexts: lipAccountEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lipAccountEntry.setDescription('A collection of objects necessary for IP accounting.')
actSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 7, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actSrc.setStatus('mandatory')
if mibBuilder.loadTexts: actSrc.setDescription('IP Source address for host traffic matrix.')
actDst = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 7, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actDst.setStatus('mandatory')
if mibBuilder.loadTexts: actDst.setDescription('IP Destination address for host traffic matrix.')
actPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actPkts.setStatus('mandatory')
if mibBuilder.loadTexts: actPkts.setDescription('Number of IP packets sent from source to destination.')
actByts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actByts.setStatus('mandatory')
if mibBuilder.loadTexts: actByts.setDescription('Total number of bytes in IP packets from source to destination.')
actViolation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actViolation.setStatus('mandatory')
if mibBuilder.loadTexts: actViolation.setDescription('Access list number violated by packets from this source to this destination. A zero value indicates that no access list was violated.')
actAge = MibScalar((1, 3, 6, 1, 4, 1, 9, 2, 4, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actAge.setStatus('mandatory')
if mibBuilder.loadTexts: actAge.setDescription('The age of the data in the current data matrix.')
lipCkAccountingTable = MibTable((1, 3, 6, 1, 4, 1, 9, 2, 4, 9), )
if mibBuilder.loadTexts: lipCkAccountingTable.setStatus('mandatory')
if mibBuilder.loadTexts: lipCkAccountingTable.setDescription('A list of IP checkpoint accounting entries.')
lipCkAccountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 2, 4, 9, 1), ).setIndexNames((0, "OLD-CISCO-IP-MIB", "ckactSrc"), (0, "OLD-CISCO-IP-MIB", "ckactDst"))
if mibBuilder.loadTexts: lipCkAccountEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lipCkAccountEntry.setDescription('A collection of objects necessary for IP checkpoint accounting.')
ckactSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 9, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ckactSrc.setStatus('mandatory')
if mibBuilder.loadTexts: ckactSrc.setDescription('IP Source address for host in checkpoint traffic matrix.')
ckactDst = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ckactDst.setStatus('mandatory')
if mibBuilder.loadTexts: ckactDst.setDescription('IP Destination address for host in checkpoint traffic matrix.')
ckactPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ckactPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ckactPkts.setDescription('Number of IP packets sent from source to destination in checkpoint matrix.')
ckactByts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ckactByts.setStatus('mandatory')
if mibBuilder.loadTexts: ckactByts.setDescription('Total number of bytes in IP packets from source to destination in checkpoint matrix. A zero value indicates that no access list was violated.')
ckactViolation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 2, 4, 9, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ckactViolation.setStatus('mandatory')
if mibBuilder.loadTexts: ckactViolation.setDescription('Access list number violated by packets from source to destination in checkpoint matrix.')
ckactAge = MibScalar((1, 3, 6, 1, 4, 1, 9, 2, 4, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ckactAge.setStatus('mandatory')
if mibBuilder.loadTexts: ckactAge.setDescription('Age of data in the checkpoint matrix.')
actCheckPoint = MibScalar((1, 3, 6, 1, 4, 1, 9, 2, 4, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: actCheckPoint.setStatus('mandatory')
if mibBuilder.loadTexts: actCheckPoint.setDescription('Check points the accounting database. This mib variable must be read and then set with the same value for the check point to succeed. The value read and then set will be incremented after a successful set request')
ipNoaccess = MibScalar((1, 3, 6, 1, 4, 1, 9, 2, 4, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNoaccess.setStatus('mandatory')
if mibBuilder.loadTexts: ipNoaccess.setDescription('Total number of packets dropped due to access control failure.')
mibBuilder.exportSymbols("OLD-CISCO-IP-MIB", actAge=actAge, ipNoaccess=ipNoaccess, actByts=actByts, ckactByts=ckactByts, locIPRedirects=locIPRedirects, actViolation=actViolation, locIPSecurity=locIPSecurity, locIPHelper=locIPHelper, locIPUnreach=locIPUnreach, lipRouteEntry=lipRouteEntry, actCheckPoint=actCheckPoint, lipAddrTable=lipAddrTable, lip=lip, ckactViolation=ckactViolation, lipRouteTable=lipRouteTable, lipAccountEntry=lipAccountEntry, actPkts=actPkts, lipAccountingTable=lipAccountingTable, actDst=actDst, locRtMask=locRtMask, lipCkAccountingTable=lipCkAccountingTable, actLostByts=actLostByts, ckactDst=ckactDst, ckactPkts=ckactPkts, locIPHow=locIPHow, actThresh=actThresh, locRtUses=locRtUses, ckactAge=ckactAge, ckactSrc=ckactSrc, locRtCount=locRtCount, lipCkAccountEntry=lipCkAccountEntry, actSrc=actSrc, actLostPkts=actLostPkts, lipAddrEntry=lipAddrEntry, locIPWho=locIPWho)

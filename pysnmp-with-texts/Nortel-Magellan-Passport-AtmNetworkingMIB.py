#
# PySNMP MIB module Nortel-Magellan-Passport-AtmNetworkingMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-AtmNetworkingMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
atmIfVpcIndex, atmIfVptVcc, atmIfVcc, atmIfVpc, atmIfVptIndex, atmIfIndex, atmIfVccIndex, atmIfVptVccIndex = mibBuilder.importSymbols("Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex", "atmIfVptVcc", "atmIfVcc", "atmIfVpc", "atmIfVptIndex", "atmIfIndex", "atmIfVccIndex", "atmIfVptVccIndex")
RowStatus, Unsigned32, Gauge32, DisplayString, Integer32, Counter32, StorageType, RowPointer = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "RowStatus", "Unsigned32", "Gauge32", "DisplayString", "Integer32", "Counter32", "StorageType", "RowPointer")
FixedPoint1, IntegerSequence, NonReplicated, AsciiStringIndex, AsciiString, HexString = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "FixedPoint1", "IntegerSequence", "NonReplicated", "AsciiStringIndex", "AsciiString", "HexString")
passportMIBs, components = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs", "components")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, NotificationType, Bits, ObjectIdentity, Unsigned32, TimeTicks, Gauge32, IpAddress, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, ModuleIdentity, iso, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "NotificationType", "Bits", "ObjectIdentity", "Unsigned32", "TimeTicks", "Gauge32", "IpAddress", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "ModuleIdentity", "iso", "Counter64")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
atmNetworkingMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42))
aRtg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95))
aRtgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 1), )
if mibBuilder.loadTexts: aRtgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgRowStatusTable.setDescription('This entry controls the addition and deletion of aRtg components.')
aRtgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"))
if mibBuilder.loadTexts: aRtgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgRowStatusEntry.setDescription('A single entry in the table represents a single aRtg component.')
aRtgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtg components. These components can be added and deleted.')
aRtgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgStorageType.setDescription('This variable represents the storage type value for the aRtg tables.')
aRtgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: aRtgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgIndex.setDescription('This variable represents the index for the aRtg tables.')
aRtgStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 10), )
if mibBuilder.loadTexts: aRtgStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgStatsTable.setDescription('This group contains the statistical operational attributes of an ARtg component.')
aRtgStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"))
if mibBuilder.loadTexts: aRtgStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgStatsEntry.setDescription('An entry in the aRtgStatsTable.')
aRtgRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgRoutingAttempts.setDescription('This attribute counts the total number of calls routed. The counter wraps when it exceeds the maximum value.')
aRtgFailedRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgFailedRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgFailedRoutingAttempts.setDescription('This attribute counts the total number of calls which were not successfully routed.The counter wraps when it exceeds the maximum value.')
aRtgDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2))
aRtgDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 1), )
if mibBuilder.loadTexts: aRtgDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of aRtgDna components.')
aRtgDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgDnaIndex"))
if mibBuilder.loadTexts: aRtgDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaRowStatusEntry.setDescription('A single entry in the table represents a single aRtgDna component.')
aRtgDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgDna components. These components cannot be added nor deleted.')
aRtgDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaStorageType.setDescription('This variable represents the storage type value for the aRtgDna tables.')
aRtgDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 40)))
if mibBuilder.loadTexts: aRtgDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaIndex.setDescription('This variable represents the index for the aRtgDna tables.')
aRtgDnaDestInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2))
aRtgDnaDestInfoRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 1), )
if mibBuilder.loadTexts: aRtgDnaDestInfoRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of aRtgDnaDestInfo components.')
aRtgDnaDestInfoRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgDnaIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgDnaDestInfoIndex"))
if mibBuilder.loadTexts: aRtgDnaDestInfoRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoRowStatusEntry.setDescription('A single entry in the table represents a single aRtgDnaDestInfo component.')
aRtgDnaDestInfoRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaDestInfoRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgDnaDestInfo components. These components cannot be added nor deleted.')
aRtgDnaDestInfoComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaDestInfoComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgDnaDestInfoStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaDestInfoStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoStorageType.setDescription('This variable represents the storage type value for the aRtgDnaDestInfo tables.')
aRtgDnaDestInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50)))
if mibBuilder.loadTexts: aRtgDnaDestInfoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoIndex.setDescription('This variable represents the index for the aRtgDnaDestInfo tables.')
aRtgDnaDestInfoOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 10), )
if mibBuilder.loadTexts: aRtgDnaDestInfoOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes for the DestInfo component.')
aRtgDnaDestInfoOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgDnaIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgDnaDestInfoIndex"))
if mibBuilder.loadTexts: aRtgDnaDestInfoOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoOperEntry.setDescription('An entry in the aRtgDnaDestInfoOperTable.')
aRtgDnaDestInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("primary", 0), ("alternate", 1), ("registered", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaDestInfoType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoType.setDescription('This attribute indicates the type of the address at the destination interface. Provisioned addresses are assigned a type of primary or alternate; ATM routing will try primary routes and then the alternate routes if none of the primary routes succeed. The type registered is used for dynamic addresses registered through ILMI. The type default is used for Soft PVC addresses.')
aRtgDnaDestInfoScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaDestInfoScope.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoScope.setDescription('This attribute indicates the highest level (meaning the lowest level number) in the hierarchy that the address will be advertised to. A value of -1 indicates that the scope is not applicable since this node has not been configured as a PNNI node.')
aRtgDnaDestInfoStdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 10, 1, 3), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaDestInfoStdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoStdComponentName.setDescription('This attribute represents a component name of the interface through which the address can be reached.')
aRtgDnaDestInfoReachability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 2, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgDnaDestInfoReachability.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgDnaDestInfoReachability.setDescription('This attribute indicates whether the address is internal or exterior.')
aRtgPnni = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3))
aRtgPnniRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 1), )
if mibBuilder.loadTexts: aRtgPnniRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRowStatusTable.setDescription('This entry controls the addition and deletion of aRtgPnni components.')
aRtgPnniRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"))
if mibBuilder.loadTexts: aRtgPnniRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnni component.')
aRtgPnniRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnni components. These components can be added and deleted.')
aRtgPnniComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniStorageType.setDescription('This variable represents the storage type value for the aRtgPnni tables.')
aRtgPnniIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: aRtgPnniIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniIndex.setDescription('This variable represents the index for the aRtgPnni tables.')
aRtgPnniProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 10), )
if mibBuilder.loadTexts: aRtgPnniProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniProvTable.setDescription('This group contains the generic provisionable attributes of a Pnni component.')
aRtgPnniProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"))
if mibBuilder.loadTexts: aRtgPnniProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniProvEntry.setDescription('An entry in the aRtgPnniProvTable.')
aRtgPnniNodeAddressPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniNodeAddressPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniNodeAddressPrefix.setDescription("This attribute specifies the ATM address of this node. It allows the default node address to be overridden. If this attribute is set to the null string, then the default node address prefix is assumed, and computed as follows: the value provisioned for the ModuleData component's nodePrefix attribute, followed by a unique MAC address (6 octets).")
aRtgPnniDefaultScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 104))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniDefaultScope.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniDefaultScope.setDescription('This attribute specifies the default PNNI scope for ATM addresses associated with this node. The PNNI scope determines the level to which the address will be advertised within the PNNI routing domain. A provisioned Addr component may override the default scope in a PnniInfo subcomponent. A value of 0 means that all addresses which do not have provisioned scopes will be advertised globally within the PNNI routing domain. The value specified must be numerically smaller than or equal to that of the lowest level at which this node is configured in the PNNI hierarchy.')
aRtgPnniDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)).clone(hexValue="31")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniDomain.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniDomain.setDescription('This attribute specifies the routing domain name. This attribute should be set identically for all nodes in the same routing domain.')
aRtgPnniRestrictTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRestrictTransit.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRestrictTransit.setDescription('This attribute specifies if the node should restrict tandeming of SVCs. If this attribute is set to true, then other lowest level nodes in the PNNI hierarchy will avoid traversing this node during route computation.')
aRtgPnniMaxReroutesOnCrankback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 20)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniMaxReroutesOnCrankback.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniMaxReroutesOnCrankback.setDescription('This attribute specifies the number of alternate routing attempts before a call requiring crank back is rejected.')
aRtgPnniPglParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 11), )
if mibBuilder.loadTexts: aRtgPnniPglParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPglParmsTable.setDescription('This group contains the provisionable attributes for the peer group leader election timer parameters of a Pnni component.')
aRtgPnniPglParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"))
if mibBuilder.loadTexts: aRtgPnniPglParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPglParmsEntry.setDescription('An entry in the aRtgPnniPglParmsTable.')
aRtgPnniPglInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniPglInitTime.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPglInitTime.setDescription('This attribute specifies how long this node will delay advertising its choice of preferred peer group leader after having initialized operation and reached the full peer state with at least one neighbor in the peer group.')
aRtgPnniOverrideDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniOverrideDelay.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniOverrideDelay.setDescription('This attribute specifies how long a node will wait for itself to be declared the preferred peer group leader by unanimous agreement among its peers.')
aRtgPnniReElectionInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniReElectionInterval.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniReElectionInterval.setDescription('This attribute specifies how long this node will wait after losing connectivity to the current peer group leader before re-starting the process of electing a new peer group leader.')
aRtgPnniHlParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 12), )
if mibBuilder.loadTexts: aRtgPnniHlParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniHlParmsTable.setDescription('This group contains the default provisionable Hello protocol parameters.')
aRtgPnniHlParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"))
if mibBuilder.loadTexts: aRtgPnniHlParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniHlParmsEntry.setDescription('An entry in the aRtgPnniHlParmsTable.')
aRtgPnniHelloHoldDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 12, 1, 1), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(1, 655350)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniHelloHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniHelloHoldDown.setDescription('This attribute is used to limit the rate at which this node sends out Hello packets. Specifically, it specifies the default minimum amount of time between successive Hellos used by routing control channels on this node.')
aRtgPnniHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniHelloInterval.setDescription('This attribute specifies the default duration of the Hello Timer in seconds for routing control channels on this node. Every helloInterval seconds, this node will send out a Hello packet to the neighbor node, subject to the helloHoldDown timer having expired at least once since the last Hello packet was sent.')
aRtgPnniHelloInactivityFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniHelloInactivityFactor.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniHelloInactivityFactor.setDescription('This attribute specifies the default number of Hello intervals allowed to pass without receiving a Hello from the neighbor node, before an attempt is made to re-stage, for routing control channels on this node. The hello inactivity timer is enabled in the oneWayInside, twoWayInside, oneWayOutside, twoWayOutside and commonOutside (see the helloState attribute on the Rcc component for a description of these states). Note that the value for the Hello interval used in the calculation is the one specified in the Hello packet from the neighbor node.')
aRtgPnniPtseParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 13), )
if mibBuilder.loadTexts: aRtgPnniPtseParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPtseParmsTable.setDescription('This group contains the provisionable attributes for the PTSE timer values of a Pnni component.')
aRtgPnniPtseParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"))
if mibBuilder.loadTexts: aRtgPnniPtseParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPtseParmsEntry.setDescription('An entry in the aRtgPnniPtseParmsTable.')
aRtgPnniPtseHoldDown = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 13, 1, 1), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(1, 655350)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniPtseHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPtseHoldDown.setDescription('This attribute is used to limit the rate at which this node sends out PTSE packets. Specifically, it specifies the minimum amount of time in seconds that this node must wait between sending successive PTSE packets.')
aRtgPnniPtseRefreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 65535)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniPtseRefreshInterval.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPtseRefreshInterval.setDescription('This attribute specifies the duration of the PTSE Timer. Every ptseRefreshInterval seconds, this node will send out a self- originated PTSE packet to the neighbor node, subject to the ptseHoldDown timer having expired at least once since the last PTSE packet was sent.')
aRtgPnniPtseLifetimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(101, 1000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniPtseLifetimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPtseLifetimeFactor.setDescription('This attribute specifies the lifetime multiplier. The result of multiplying the ptseRefreshInterval by this value is used as the initial lifetime that this node places into PTSEs.')
aRtgPnniRequestRxmtInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRequestRxmtInterval.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRequestRxmtInterval.setDescription('This attribute specifies the period between retransmissions of unacknowledged Database Summary packets, PTSE Request packets and PTSPs.')
aRtgPnniPeerDelayedAckInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 13, 1, 5), FixedPoint1().subtype(subtypeSpec=ValueRangeConstraint(1, 655350)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniPeerDelayedAckInterval.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPeerDelayedAckInterval.setDescription('This attribute specifies the minimum amount of time between transmissions of delayed PTSE acknowledgment packets.')
aRtgPnniThreshParmsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 14), )
if mibBuilder.loadTexts: aRtgPnniThreshParmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniThreshParmsTable.setDescription('This group contains the provisionable attributes for the change thresholds of a ARtg Pnni component.')
aRtgPnniThreshParmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"))
if mibBuilder.loadTexts: aRtgPnniThreshParmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniThreshParmsEntry.setDescription('An entry in the aRtgPnniThreshParmsTable.')
aRtgPnniAvcrMt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniAvcrMt.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniAvcrMt.setDescription('This attribute when multiplied by the Maximum Cell Rate specifies the minimum threshold used in the algorithms that determine significant change for average cell rate parameters.')
aRtgPnniAvcrPm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 14, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniAvcrPm.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniAvcrPm.setDescription('This attribute when multiplied by the current Available Cell Rate specifies the threshold used in the algorithms that determine significant change for AvCR parameters. If the resulting threshold is lower than minimum threshold, minimum threshold will be used. Increasing the value of the attribute increases the range of insignificance and reduces the amount of PTSP flooding due to changes in resource availability.')
aRtgPnniOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 15), )
if mibBuilder.loadTexts: aRtgPnniOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniOperTable.setDescription('This group contains the generic operational attributes of an ARtg Pnni component.')
aRtgPnniOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"))
if mibBuilder.loadTexts: aRtgPnniOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniOperEntry.setDescription('An entry in the aRtgPnniOperTable.')
aRtgPnniTopologyMemoryExhaustion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopologyMemoryExhaustion.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopologyMemoryExhaustion.setDescription('This attribute indicates if the topology database is overloaded. A node goes into a database overload state when it fails to store the complete topology database due to insufficient memory in the node. A node in this state performs resynchronization periodically by restarting all its Neighbor Peer Finite State Machines. The node will stay in this state until it synchronizes with all of its neighbors without any overload problems. When this attribute is set an alarm will be issued.')
aRtgPnniStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 16), )
if mibBuilder.loadTexts: aRtgPnniStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniStatsTable.setDescription('This group contains the statistical operational attributes of a ARtg Pnni component.')
aRtgPnniStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"))
if mibBuilder.loadTexts: aRtgPnniStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniStatsEntry.setDescription('An entry in the aRtgPnniStatsTable.')
aRtgPnniRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRoutingAttempts.setDescription('This attribute counts successful PNNI routing attempts. The counter wraps when it exceeds the maximum value.')
aRtgPnniFailedRoutingAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniFailedRoutingAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniFailedRoutingAttempts.setDescription('This attribute counts failed PNNI routing attempts. The counter wraps when it exceeds the maximum value.')
aRtgPnniCallsRerouted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCallsRerouted.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCallsRerouted.setDescription('This attribute counts successful PNNI alternate routing attempts. The counter wraps when it exceeds the maximum value.')
aRtgPnniOptMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 386), )
if mibBuilder.loadTexts: aRtgPnniOptMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniOptMetricTable.setDescription('This attribute is a vector that specifies the optimization metric for each ATM service category. The optimization metric is used during Generic Connection Admission Control (GCAC) route computation. Setting the value to cdv for a particular service category will cause GCAC to optimize for cell delay variation on call setups requiring that service category. Setting the value to maxCtd for a particular service category will cause GCAC to optimize for maximum cell transfer delay on call setups requiring that service category. Setting the value to aw for a particular service category will cause GCAC to optimize for administrative weight on call setups requiring that service category.')
aRtgPnniOptMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 386, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniOptMetricIndex"))
if mibBuilder.loadTexts: aRtgPnniOptMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniOptMetricEntry.setDescription('An entry in the aRtgPnniOptMetricTable.')
aRtgPnniOptMetricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 386, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cbr", 1), ("rtVbr", 2), ("nrtVbr", 3), ("ubr", 4))))
if mibBuilder.loadTexts: aRtgPnniOptMetricIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniOptMetricIndex.setDescription('This variable represents the aRtgPnniOptMetricTable specific index for the aRtgPnniOptMetricTable.')
aRtgPnniOptMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 386, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("maxCtd", 1), ("aw", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniOptMetricValue.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniOptMetricValue.setDescription('This variable represents an individual value for the aRtgPnniOptMetricTable.')
aRtgPnniRf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2))
aRtgPnniRfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 1), )
if mibBuilder.loadTexts: aRtgPnniRfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfRowStatusTable.setDescription('This entry controls the addition and deletion of aRtgPnniRf components.')
aRtgPnniRfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfIndex"))
if mibBuilder.loadTexts: aRtgPnniRfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniRf component.')
aRtgPnniRfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniRfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniRf components. These components cannot be added nor deleted.')
aRtgPnniRfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniRfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniRfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniRfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfStorageType.setDescription('This variable represents the storage type value for the aRtgPnniRf tables.')
aRtgPnniRfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: aRtgPnniRfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfIndex.setDescription('This variable represents the index for the aRtgPnniRf tables.')
aRtgPnniRfCriteriaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10), )
if mibBuilder.loadTexts: aRtgPnniRfCriteriaTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfCriteriaTable.setDescription('This group contains the attributes specifying the routing criteria for the route computation.')
aRtgPnniRfCriteriaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfIndex"))
if mibBuilder.loadTexts: aRtgPnniRfCriteriaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfCriteriaEntry.setDescription('An entry in the aRtgPnniRfCriteriaTable.')
aRtgPnniRfDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfDestinationAddress.setDescription('This attribute specifies the destination NSAP address to be used for the computation. If this attribute specifies an invalid address then no routes will be found.')
aRtgPnniRfMaxRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfMaxRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfMaxRoutes.setDescription('This attribute specifies a ceiling on the number of routes to be computed.')
aRtgPnniRfTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
aRtgPnniRfRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
aRtgPnniRfAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC IE parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by CellTransfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. VBR real time service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. VBR non-real time service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
aRtgPnniRfFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. Class 1 supports a QOS that will meet Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that will meet Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that will meet Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that will meet Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
aRtgPnniRfBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. Class 1 supports a QOS that will meet Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that will meet Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that will meet Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that will meet Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
aRtgPnniRfBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfBearerClassBbc.setDescription('This attribute specifies the bearer capability. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol.')
aRtgPnniRfTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability : TrafficType, Timing> 0 : NoIndication, NoIndication 1 : NoIndication, yes 2 : NoIndication, no 5 : CBR, yes 8 : VBR, NoIndication 9 : VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; this is also the case for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
aRtgPnniRfClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC IE. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
aRtgPnniRfBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor IE. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. DESCRIPTION')
aRtgPnniRfOptimizationMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("maxCtd", 1), ("aw", 2))).clone('aw')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfOptimizationMetric.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfOptimizationMetric.setDescription('This attribute specifies the optimization metric to be used in the route computation; one of cell delay variation (cdv), maximum cell transfer delay (maxCtd), or administrative weight (aw).')
aRtgPnniRfRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 388), )
if mibBuilder.loadTexts: aRtgPnniRfRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute will be taken from the txTrafficDescParm.')
aRtgPnniRfRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 388, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfRxTdpIndex"))
if mibBuilder.loadTexts: aRtgPnniRfRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfRxTdpEntry.setDescription('An entry in the aRtgPnniRfRxTdpTable.')
aRtgPnniRfRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 388, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: aRtgPnniRfRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfRxTdpIndex.setDescription('This variable represents the aRtgPnniRfRxTdpTable specific index for the aRtgPnniRfRxTdpTable.')
aRtgPnniRfRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 388, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfRxTdpValue.setDescription('This variable represents an individual value for the aRtgPnniRfRxTdpTable.')
aRtgPnniRfTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 389), )
if mibBuilder.loadTexts: aRtgPnniRfTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic will be shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic will be shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic will be shaped at the next rate above the PCR.')
aRtgPnniRfTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 389, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfTxTdpIndex"))
if mibBuilder.loadTexts: aRtgPnniRfTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfTxTdpEntry.setDescription('An entry in the aRtgPnniRfTxTdpTable.')
aRtgPnniRfTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 389, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: aRtgPnniRfTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfTxTdpIndex.setDescription('This variable represents the aRtgPnniRfTxTdpTable specific index for the aRtgPnniRfTxTdpTable.')
aRtgPnniRfTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 389, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfTxTdpValue.setDescription('This variable represents an individual value for the aRtgPnniRfTxTdpTable.')
aRtgPnniRfFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 390), )
if mibBuilder.loadTexts: aRtgPnniRfFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
aRtgPnniRfFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 390, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfFqpIndex"))
if mibBuilder.loadTexts: aRtgPnniRfFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfFqpEntry.setDescription('An entry in the aRtgPnniRfFqpTable.')
aRtgPnniRfFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 390, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: aRtgPnniRfFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfFqpIndex.setDescription('This variable represents the aRtgPnniRfFqpTable specific index for the aRtgPnniRfFqpTable.')
aRtgPnniRfFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 390, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfFqpValue.setDescription('This variable represents an individual value for the aRtgPnniRfFqpTable.')
aRtgPnniRfBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 393), )
if mibBuilder.loadTexts: aRtgPnniRfBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfBqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
aRtgPnniRfBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 393, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniRfBqpIndex"))
if mibBuilder.loadTexts: aRtgPnniRfBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfBqpEntry.setDescription('An entry in the aRtgPnniRfBqpTable.')
aRtgPnniRfBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 393, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: aRtgPnniRfBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfBqpIndex.setDescription('This variable represents the aRtgPnniRfBqpTable specific index for the aRtgPnniRfBqpTable.')
aRtgPnniRfBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 2, 393, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniRfBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniRfBqpValue.setDescription('This variable represents an individual value for the aRtgPnniRfBqpTable.')
aRtgPnniCfgNode = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3))
aRtgPnniCfgNodeRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 1), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeRowStatusTable.setDescription('This entry controls the addition and deletion of aRtgPnniCfgNode components.')
aRtgPnniCfgNodeRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniCfgNode component.')
aRtgPnniCfgNodeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniCfgNodeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniCfgNode components. These components can be added and deleted.')
aRtgPnniCfgNodeComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniCfgNodeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeStorageType.setDescription('This variable represents the storage type value for the aRtgPnniCfgNode tables.')
aRtgPnniCfgNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 104)))
if mibBuilder.loadTexts: aRtgPnniCfgNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeIndex.setDescription('This variable represents the index for the aRtgPnniCfgNode tables.')
aRtgPnniCfgNodeProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 10), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeProvTable.setDescription('This group contains the provisionable attributes of a ConfiguredNode component.')
aRtgPnniCfgNodeProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeProvEntry.setDescription('An entry in the aRtgPnniCfgNodeProvTable.')
aRtgPnniCfgNodeNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 10, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNodeId.setDescription('This attribute specifies the node id of the configured node. If this attribute is set to null, then the node id is computed as follows: If this is the lowest configured node, then the node id is computed as the level (one octet), followed by the integer value 160 (one octet), followed by the node address (20 octets). If this is not the lowest configured node, then the node id is computed as the level (one octet), followed by the 14 octet peer group id of the child peer group which the LGN represents, followed by the ESI specified in the node address (6 octets), followed by the integer value 0 (one octet).')
aRtgPnniCfgNodePeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniCfgNodePeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodePeerGroupId.setDescription("This attribute allows the peer group id of the Logical Group Node (LGN) to be set. The peer group id is specified by 28 hex digits where the first octet represents the level of the node and the remaining 13 octets form the End System Address. If this attribute is set to the null string then the peer group id is computed as follows: The peer group id for a lowest level node is computed to be the node's level (one octet), followed by the first <level> bits of the node's address, followed by zero or more padding 0 bits. The peer group id for an LGN is computed to be the LGN's level (one octet), followed by the first <level> bits of the id of the peer group which this LGN represents.")
aRtgPnniCfgNodeOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeOperTable.setDescription('This group contains the generic operational attributes of a ConfiguredNode component.')
aRtgPnniCfgNodeOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeOperEntry.setDescription('An entry in the aRtgPnniCfgNodeOperTable.')
aRtgPnniCfgNodeNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNodeAddress.setDescription('This attribute indicates the address of the node at this level. At the lowest level, the nodeAddress is determined by the value of the nodeAddressPrefix attribute for the ARtg Pnni component followed by the level of this CfgNode. For LGNs, the nodeAddress is the same as the nodeAddress of the node at the lowest level, with the selector field set to the level of the peer group containing the LGN.')
aRtgPnniCfgNodeOpNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeOpNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeOpNodeId.setDescription('This attribute indicates the node id of the node at this level. The default node id is computed as follows: If this is the lowest level node, then the default node id is computed as the level (one octet), followed by the integer value 160 (one octet), followed by the node address (20 octets). If this is not the lowest level node, then the default node id is computed as the level (one octet), followed by the 14 octet peer group id of the child peer group which the LGN represents, followed by the ESI specified in the node address (6 octets), followed by the integer value 0 (one octet).')
aRtgPnniCfgNodeOpPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeOpPeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeOpPeerGroupId.setDescription('This attribute indicates the peer group id of the node at this level. The value is determined by the provisioned peerGroupId attribute.')
aRtgPnniCfgNodeNumNeighbors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNumNeighbors.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNumNeighbors.setDescription('This attribute indicates the number of PNNI nodes which are neighbors of this node at this level.')
aRtgPnniCfgNodeNumRccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNumRccs.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNumRccs.setDescription("This attribute indicates the number of Routing Control Channels to this node's neighbors at this level.")
aRtgPnniCfgNodeCurrentLeadershipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 205))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeCurrentLeadershipPriority.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeCurrentLeadershipPriority.setDescription('This attribute indicates the leadership priority of the node that this node believes should be the peer group leader at this point in time.')
aRtgPnniCfgNodePglElectionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("starting", 0), ("awaiting", 1), ("awaitingFull", 2), ("initialDelay", 3), ("calculating", 4), ("operNotPgl", 5), ("operPgl", 6), ("awaitUnanimity", 7), ("hungElection", 8), ("awaitReElection", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodePglElectionState.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodePglElectionState.setDescription('This attribute indicates the current state of the peer group leader election process. The following are the possible values for this attribute: starting: the initial state of the state machine. awaiting: the node has started the Hello Finite State Machine on at least one link, and no peer has been found yet. awaitingFull: no database synchronization process has been completed yet but at least one neighboring peer has been found. initialDelay: Database synchronization has been completed with at least one neighboring peer. The node must wait pglInitTime second before it can select and advertise its preferred Peer Group Leader (PGL). calculating: the node is in the process of calculating what its new choice for preferred PGL will be. operNotPgl: a non PGL node is in the process of determining which node has the highest priority to be PGL by examining PTSEs sent by other nodes. operPgl: a PGL node is in the process of determining if another node has a higher priority than itself by examining PTSEs sent by other nodes. awaitUnanimity: the node has chosen itself as PGL. If the node has been elected unanimously, it generates a Unanimity event. It waits for unanimity or expiration of the overrideDelay timer before declaring itself peer group leader. hungElection: the node has chosen itself as PGL with less than 2/3 of the other nodes advertising it as their preferred PGL. In this case either this node should change its choice of preferred PGL, or the other nodes are going to accept it as PGL. awaitReElection: the node has lost connectivity to the current PGL. The connectivity must be reestablished before the reElectionInterval timer fires, otherwise the election is redone.')
aRtgPnniCfgNodeSAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2))
aRtgPnniCfgNodeSAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 1), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrRowStatusTable.setDescription('This entry controls the addition and deletion of aRtgPnniCfgNodeSAddr components.')
aRtgPnniCfgNodeSAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrAddressIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrPrefixLengthIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrReachabilityIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniCfgNodeSAddr component.')
aRtgPnniCfgNodeSAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniCfgNodeSAddr components. These components can be added and deleted.')
aRtgPnniCfgNodeSAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniCfgNodeSAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrStorageType.setDescription('This variable represents the storage type value for the aRtgPnniCfgNodeSAddr tables.')
aRtgPnniCfgNodeSAddrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 1, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(19, 19)).setFixedLength(19))
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrAddressIndex.setDescription('This variable represents an index for the aRtgPnniCfgNodeSAddr tables.')
aRtgPnniCfgNodeSAddrPrefixLengthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 152)))
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrPrefixLengthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrPrefixLengthIndex.setDescription('This variable represents an index for the aRtgPnniCfgNodeSAddr tables.')
aRtgPnniCfgNodeSAddrReachabilityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1))))
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrReachabilityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrReachabilityIndex.setDescription('This variable represents an index for the aRtgPnniCfgNodeSAddr tables.')
aRtgPnniCfgNodeSAddrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 10), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrProvTable.setDescription('This group contains the provisionable attributes of a SummaryAddress component. A summary address is an abbreviation of a set of addresses, represented by an address prefix that all of the summarized addresses have in common. A suppressed summary address is used to suppress the advertisement of addresses which match this prefix, regardless of scope.')
aRtgPnniCfgNodeSAddrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrAddressIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrPrefixLengthIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrReachabilityIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrProvEntry.setDescription('An entry in the aRtgPnniCfgNodeSAddrProvTable.')
aRtgPnniCfgNodeSAddrSuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrSuppress.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrSuppress.setDescription('This attribute specifies whether or not the address should be suppressed. If this attribute is set to true, then all addresses matching that prefix will not be advertised above this level.')
aRtgPnniCfgNodeSAddrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 11), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrOperTable.setDescription('This group contains the operational attributes of a SummaryAddress component.')
aRtgPnniCfgNodeSAddrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrAddressIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrPrefixLengthIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeSAddrReachabilityIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrOperEntry.setDescription('An entry in the aRtgPnniCfgNodeSAddrOperTable.')
aRtgPnniCfgNodeSAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("advertising", 0), ("suppressing", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrState.setDescription('This attribute indicates the state of the address: one of advertising, suppressing or inactive. inactive: the summary address has been configured but is not suppressing or summarizing any ATM addresses. suppressing: the summary address has suppressed at least one ATM address on the node. advertising: the summary address is summarizing at least one ATM address on the node.')
aRtgPnniCfgNodeSAddrScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrScope.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeSAddrScope.setDescription('This attribute indicates the scope of the summary address. The scope corresponds to the scope of the underlying summarized address with the highest advertised scope. A value of -1 means the scope is unknown.')
aRtgPnniCfgNodeNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3))
aRtgPnniCfgNodeNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 1), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of aRtgPnniCfgNodeNbr components.')
aRtgPnniCfgNodeNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeNbrIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniCfgNodeNbr component.')
aRtgPnniCfgNodeNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniCfgNodeNbr components. These components cannot be added nor deleted.')
aRtgPnniCfgNodeNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniCfgNodeNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrStorageType.setDescription('This variable represents the storage type value for the aRtgPnniCfgNodeNbr tables.')
aRtgPnniCfgNodeNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 1, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22))
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrIndex.setDescription('This variable represents the index for the aRtgPnniCfgNodeNbr tables.')
aRtgPnniCfgNodeNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 10), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of a Neighbor component.')
aRtgPnniCfgNodeNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeNbrIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrOperEntry.setDescription('An entry in the aRtgPnniCfgNodeNbrOperTable.')
aRtgPnniCfgNodeNbrPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("npDown", 0), ("negotiating", 1), ("exchanging", 2), ("loading", 3), ("full", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPeerState.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPeerState.setDescription('This attribute indicates the state of the routing database exchange with the peer node. npDown: there are no active links (i.e. in the twoWayInside Hello state) to the neighboring peer. negotiating: the first step in creating an adjacency between the two neighboring peers; this step determines which node is the master, and what the initial DS sequence number will be. exchanging: the node describes its topology database by sending Database Summary packets to the neighboring peer. loading: a full sequence of Database Summary packets has been exchanged with the neighboring peer, and the required PTSEs are requested and at least one has not yet been received. full: All PTSEs known to be available have been received from the neighboring peer. At this point the all ports leading to the neighbor node will be flooded in PTSEs within the peer group.')
aRtgPnniCfgNodeNbrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the statistical operational attributes of a Neighbor component.')
aRtgPnniCfgNodeNbrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeNbrIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrStatsEntry.setDescription('An entry in the aRtgPnniCfgNodeNbrStatsTable.')
aRtgPnniCfgNodeNbrPtspRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtspRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtspRx.setDescription('This attribute counts the PNNI Topology State Packets received from the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrPtspTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtspTx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtspTx.setDescription('This attribute counts the total number of PTSPs send to the neighbor node.The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrPtseRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseRx.setDescription('This attribute counts the total number of PTSEs received from the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrPtseTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseTx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseTx.setDescription('This attribute counts the total number of PTSEs sent to the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrPtseReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseReqRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseReqRx.setDescription('This attribute counts the total number of PTSE requests received from the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrPtseReqTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseReqTx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseReqTx.setDescription('This attribute counts the total number of PTSE requests sent to the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrPtseAcksRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseAcksRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseAcksRx.setDescription('This attribute counts the total number of PTSE acknowledgments received from the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrPtseAcksTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseAcksTx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrPtseAcksTx.setDescription('This attribute counts the total number of PTSE acknowledgments sent to the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrDbSummariesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrDbSummariesRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrDbSummariesRx.setDescription('This attribute counts the number of database summary packets received from the neighbor. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrDbSummariesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrDbSummariesTx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrDbSummariesTx.setDescription('This attribute counts the number of database summary packets transmitted to the neighbor. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrBadPtspRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadPtspRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadPtspRx.setDescription('This attribute counts the total number of invalid PTSP packets received from the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrBadPtseRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadPtseRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadPtseRx.setDescription('This attribute counts the total number of invalid PTSE packets received to the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrBadPtseReqRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadPtseReqRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadPtseReqRx.setDescription('This attribute counts the total number of invalid PTSE requests received from the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrBadPtseAckRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadPtseAckRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadPtseAckRx.setDescription('This attribute counts the total number of invalid PTSE acknowledgments received from the neighbor node. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrBadDbSummariesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 11, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadDbSummariesRx.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrBadDbSummariesRx.setDescription('This attribute counts the total number of invalid database summary packets received from the neighbor. The counter wraps when it exceeds the maximum value.')
aRtgPnniCfgNodeNbrRccListTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 385), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRccListTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRccListTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates the component names of all Routing Control Channels to the neighbor PNNI node.')
aRtgPnniCfgNodeNbrRccListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 385, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeNbrIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeNbrRccListValue"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRccListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRccListEntry.setDescription('An entry in the aRtgPnniCfgNodeNbrRccListTable.')
aRtgPnniCfgNodeNbrRccListValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 3, 385, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRccListValue.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeNbrRccListValue.setDescription('This variable represents both the value and the index for the aRtgPnniCfgNodeNbrRccListTable.')
aRtgPnniCfgNodeDefSAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4))
aRtgPnniCfgNodeDefSAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 1), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrRowStatusTable.setDescription('This entry controls the addition and deletion of aRtgPnniCfgNodeDefSAddr components.')
aRtgPnniCfgNodeDefSAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeDefSAddrIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniCfgNodeDefSAddr component.')
aRtgPnniCfgNodeDefSAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniCfgNodeDefSAddr components. These components cannot be added nor deleted.')
aRtgPnniCfgNodeDefSAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniCfgNodeDefSAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrStorageType.setDescription('This variable represents the storage type value for the aRtgPnniCfgNodeDefSAddr tables.')
aRtgPnniCfgNodeDefSAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrIndex.setDescription('This variable represents the index for the aRtgPnniCfgNodeDefSAddr tables.')
aRtgPnniCfgNodeDefSAddrDefAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 10), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrDefAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrDefAddrTable.setDescription('This group contains the operational attributes of a DefSummaryAddress component.')
aRtgPnniCfgNodeDefSAddrDefAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeDefSAddrIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrDefAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrDefAddrEntry.setDescription('An entry in the aRtgPnniCfgNodeDefSAddrDefAddrTable.')
aRtgPnniCfgNodeDefSAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrAddress.setDescription('This attribute indicates the default summary address of the node at this level.')
aRtgPnniCfgNodeDefSAddrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 11), )
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrOperTable.setDescription('This group contains the operational attributes of a SummaryAddress component.')
aRtgPnniCfgNodeDefSAddrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniCfgNodeDefSAddrIndex"))
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrOperEntry.setDescription('An entry in the aRtgPnniCfgNodeDefSAddrOperTable.')
aRtgPnniCfgNodeDefSAddrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("advertising", 0), ("suppressing", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrState.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrState.setDescription('This attribute indicates the state of the address: one of advertising, suppressing or inactive. inactive: the summary address has been configured but is not suppressing or summarizing any ATM addresses. suppressing: the summary address has suppressed at least one ATM address on the node. advertising: the summary address is summarizing at least one ATM address on the node.')
aRtgPnniCfgNodeDefSAddrScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 3, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrScope.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniCfgNodeDefSAddrScope.setDescription('This attribute indicates the scope of the summary address. The scope corresponds to the scope of the underlying summarized address with the highest advertised scope. A value of -1 means the scope is unknown.')
aRtgPnniTop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4))
aRtgPnniTopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 1), )
if mibBuilder.loadTexts: aRtgPnniTopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of aRtgPnniTop components.')
aRtgPnniTopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopIndex"))
if mibBuilder.loadTexts: aRtgPnniTopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniTop component.')
aRtgPnniTopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniTop components. These components cannot be added nor deleted.')
aRtgPnniTopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniTopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopStorageType.setDescription('This variable represents the storage type value for the aRtgPnniTop tables.')
aRtgPnniTopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 104)))
if mibBuilder.loadTexts: aRtgPnniTopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopIndex.setDescription('This variable represents the index for the aRtgPnniTop tables.')
aRtgPnniTopOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 10), )
if mibBuilder.loadTexts: aRtgPnniTopOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of a Topology component.')
aRtgPnniTopOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopIndex"))
if mibBuilder.loadTexts: aRtgPnniTopOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopOperEntry.setDescription('An entry in the aRtgPnniTopOperTable.')
aRtgPnniTopPtsesInDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 10, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopPtsesInDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopPtsesInDatabase.setDescription("This attribute indicates the number of PTSEs in storage in this node's topology database for this level.")
aRtgPnniTopPglNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 10, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopPglNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopPglNodeId.setDescription('This attribute indicates the node id of the peer group leader. If this attribute is empty, it indicates the Peer Group Level node id is unknown.')
aRtgPnniTopActiveParentNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopActiveParentNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopActiveParentNodeId.setDescription('This attribute indicates the node identifier being used by the LGN representing this peer group at the next higher level peer group.')
aRtgPnniTopPreferredPglNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopPreferredPglNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopPreferredPglNodeId.setDescription('This attribute represents the node in database with the highest Peer Group Level (PGL) priority. If this attribute is empty, it indicates the preferred PGL node id is unknown.')
aRtgPnniTopNode = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2))
aRtgPnniTopNodeRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 1), )
if mibBuilder.loadTexts: aRtgPnniTopNodeRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of aRtgPnniTopNode components.')
aRtgPnniTopNodeRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeIndex"))
if mibBuilder.loadTexts: aRtgPnniTopNodeRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniTopNode component.')
aRtgPnniTopNodeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniTopNode components. These components cannot be added nor deleted.')
aRtgPnniTopNodeComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniTopNodeStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeStorageType.setDescription('This variable represents the storage type value for the aRtgPnniTopNode tables.')
aRtgPnniTopNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 1, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22))
if mibBuilder.loadTexts: aRtgPnniTopNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeIndex.setDescription('This variable represents the index for the aRtgPnniTopNode tables.')
aRtgPnniTopNodeAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2))
aRtgPnniTopNodeAddrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 1), )
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of aRtgPnniTopNodeAddr components.')
aRtgPnniTopNodeAddrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeAddrAddressIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeAddrPrefixLengthIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeAddrReachabilityIndex"))
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniTopNodeAddr component.')
aRtgPnniTopNodeAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniTopNodeAddr components. These components cannot be added nor deleted.')
aRtgPnniTopNodeAddrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniTopNodeAddrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrStorageType.setDescription('This variable represents the storage type value for the aRtgPnniTopNodeAddr tables.')
aRtgPnniTopNodeAddrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 1, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(19, 19)).setFixedLength(19))
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrAddressIndex.setDescription('This variable represents an index for the aRtgPnniTopNodeAddr tables.')
aRtgPnniTopNodeAddrPrefixLengthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 152)))
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrPrefixLengthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrPrefixLengthIndex.setDescription('This variable represents an index for the aRtgPnniTopNodeAddr tables.')
aRtgPnniTopNodeAddrReachabilityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("internal", 0), ("exterior", 1))))
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrReachabilityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrReachabilityIndex.setDescription('This variable represents an index for the aRtgPnniTopNodeAddr tables.')
aRtgPnniTopNodeAddrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 10), )
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute group contains the operational attributes for the Address component.')
aRtgPnniTopNodeAddrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeAddrAddressIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeAddrPrefixLengthIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeAddrReachabilityIndex"))
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrOperEntry.setDescription('An entry in the aRtgPnniTopNodeAddrOperTable.')
aRtgPnniTopNodeAddrScope = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 104))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrScope.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeAddrScope.setDescription('This attribute specifies the scope of the ATM address, which is the highest level to which this address will be advertised in the PNNI hierarchy.')
aRtgPnniTopNodeLink = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3))
aRtgPnniTopNodeLinkRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 1), )
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of aRtgPnniTopNodeLink components.')
aRtgPnniTopNodeLinkRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeLinkIndex"))
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniTopNodeLink component.')
aRtgPnniTopNodeLinkRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniTopNodeLink components. These components cannot be added nor deleted.')
aRtgPnniTopNodeLinkComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniTopNodeLinkStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkStorageType.setDescription('This variable represents the storage type value for the aRtgPnniTopNodeLink tables.')
aRtgPnniTopNodeLinkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435455)))
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkIndex.setDescription('This variable represents the index for the aRtgPnniTopNodeLink tables.')
aRtgPnniTopNodeLinkOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 10), )
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of a Link component.')
aRtgPnniTopNodeLinkOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniTopNodeLinkIndex"))
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkOperEntry.setDescription('An entry in the aRtgPnniTopNodeLinkOperTable.')
aRtgPnniTopNodeLinkRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(22, 22)).setFixedLength(22)).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRemoteNodeId.setDescription('This attribute indicates the id of the node at the far end of this link.')
aRtgPnniTopNodeLinkRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 4, 2, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRemotePortId.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniTopNodeLinkRemotePortId.setDescription("This attribute indicates the node's port id at the far end of this link.")
aRtgPnniPort = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5))
aRtgPnniPortRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 1), )
if mibBuilder.loadTexts: aRtgPnniPortRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of aRtgPnniPort components.')
aRtgPnniPortRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniPortIndex"))
if mibBuilder.loadTexts: aRtgPnniPortRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortRowStatusEntry.setDescription('A single entry in the table represents a single aRtgPnniPort component.')
aRtgPnniPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortRowStatus.setDescription('This variable is used as the basis for SNMP naming of aRtgPnniPort components. These components cannot be added nor deleted.')
aRtgPnniPortComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniPortComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
aRtgPnniPortStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniPortStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortStorageType.setDescription('This variable represents the storage type value for the aRtgPnniPort tables.')
aRtgPnniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435455)))
if mibBuilder.loadTexts: aRtgPnniPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortIndex.setDescription('This variable represents the index for the aRtgPnniPort tables.')
aRtgPnniPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 10), )
if mibBuilder.loadTexts: aRtgPnniPortOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of a Port component.')
aRtgPnniPortOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "aRtgPnniPortIndex"))
if mibBuilder.loadTexts: aRtgPnniPortOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortOperEntry.setDescription('An entry in the aRtgPnniPortOperTable.')
aRtgPnniPortStdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 95, 3, 5, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aRtgPnniPortStdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: aRtgPnniPortStdComponentName.setDescription('This attribute indicates the component name of the port.')
atmCR = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113))
atmCRRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 1), )
if mibBuilder.loadTexts: atmCRRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRRowStatusTable.setDescription('This entry controls the addition and deletion of atmCR components.')
atmCRRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmCRIndex"))
if mibBuilder.loadTexts: atmCRRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRRowStatusEntry.setDescription('A single entry in the table represents a single atmCR component.')
atmCRRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmCRRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmCR components. These components can be added and deleted.')
atmCRComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCRComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmCRStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCRStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRStorageType.setDescription('This variable represents the storage type value for the atmCR tables.')
atmCRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmCRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRIndex.setDescription('This variable represents the index for the atmCR tables.')
atmCRProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 10), )
if mibBuilder.loadTexts: atmCRProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRProvTable.setDescription('This group represents the provisioned attributes for the AtmCallRouter component.')
atmCRProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmCRIndex"))
if mibBuilder.loadTexts: atmCRProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRProvEntry.setDescription('An entry in the atmCRProvTable.')
atmCRNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(26, 26)).setFixedLength(26)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmCRNodeAddress.setStatus('obsolete')
if mibBuilder.loadTexts: atmCRNodeAddress.setDescription('This attribute specifies the NSAP address prefix used for ILMI purposes.')
atmCRStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 11), )
if mibBuilder.loadTexts: atmCRStatsTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmCRStatsTable.setDescription('This group represents the operational attributes for the AtmCallRouter component.')
atmCRStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmCRIndex"))
if mibBuilder.loadTexts: atmCRStatsEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmCRStatsEntry.setDescription('An entry in the atmCRStatsTable.')
atmCRCallsRouted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCRCallsRouted.setStatus('obsolete')
if mibBuilder.loadTexts: atmCRCallsRouted.setDescription('This attribute counts the total number of calls routed.')
atmCRCallsFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCRCallsFailed.setStatus('obsolete')
if mibBuilder.loadTexts: atmCRCallsFailed.setDescription('This attribute specifies the number of calls that failed to route.')
atmCRDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2))
atmCRDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 1), )
if mibBuilder.loadTexts: atmCRDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRDnaRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of atmCRDna components.')
atmCRDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmCRIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmCRDnaIndex"))
if mibBuilder.loadTexts: atmCRDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRDnaRowStatusEntry.setDescription('A single entry in the table represents a single atmCRDna component.')
atmCRDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCRDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmCRDna components. These components cannot be added nor deleted.')
atmCRDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCRDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmCRDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCRDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRDnaStorageType.setDescription('This variable represents the storage type value for the atmCRDna tables.')
atmCRDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 40)))
if mibBuilder.loadTexts: atmCRDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmCRDnaIndex.setDescription('This variable represents the index for the atmCRDna tables.')
atmCRDnaDestinationNameTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 289), )
if mibBuilder.loadTexts: atmCRDnaDestinationNameTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmCRDnaDestinationNameTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This attribute indicates which components have this address provisioned or dynamically registered via ILMI.')
atmCRDnaDestinationNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 289, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmCRIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmCRDnaIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmCRDnaDestinationNameValue"))
if mibBuilder.loadTexts: atmCRDnaDestinationNameEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmCRDnaDestinationNameEntry.setDescription('An entry in the atmCRDnaDestinationNameTable.')
atmCRDnaDestinationNameValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 113, 2, 289, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCRDnaDestinationNameValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmCRDnaDestinationNameValue.setDescription('This variable represents both the value and the index for the atmCRDnaDestinationNameTable.')
atmIfVpcSrc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6))
atmIfVpcSrcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 1), )
if mibBuilder.loadTexts: atmIfVpcSrcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcSrc components.')
atmIfVpcSrcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcSrcIndex"))
if mibBuilder.loadTexts: atmIfVpcSrcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcSrc component.')
atmIfVpcSrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcSrcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcSrc components. These components can be added and deleted.')
atmIfVpcSrcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcSrcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcSrcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcSrcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcStorageType.setDescription('This variable represents the storage type value for the atmIfVpcSrc tables.')
atmIfVpcSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcIndex.setDescription('This variable represents the index for the atmIfVpcSrc tables.')
atmIfVpcSrcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 10), )
if mibBuilder.loadTexts: atmIfVpcSrcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcProvTable.setDescription('This attribute group contains the provisionable attributes of the AtmIf/n Vpc/vpi SrcPvp component.')
atmIfVpcSrcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcSrcIndex"))
if mibBuilder.loadTexts: atmIfVpcSrcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcProvEntry.setDescription('An entry in the atmIfVpcSrcProvTable.')
atmIfVpcSrcCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcSrcCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcCallingAddress.setDescription('This attribute specifies the calling address of the soft PVP. If it is a null string, then the calling address is the address of the current interface (that is, where the soft PVC originates).')
atmIfVpcSrcCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 10, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcSrcCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcCalledAddress.setDescription('This attribute specifies the called (remote) address of the soft PVP.')
atmIfVpcSrcCalledVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcSrcCalledVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcCalledVpi.setDescription('This attribute specifies the called VPI of the soft PVP.')
atmIfVpcSrcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 11), )
if mibBuilder.loadTexts: atmIfVpcSrcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcOperTable.setDescription('This attribute group contains the operational attributes associated with the SrcPvp or SrcPvc component.')
atmIfVpcSrcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcSrcIndex"))
if mibBuilder.loadTexts: atmIfVpcSrcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcOperEntry.setDescription('An entry in the atmIfVpcSrcOperTable.')
atmIfVpcSrcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcSrcState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcState.setDescription('This attribute indicates the state of the soft PVP or soft PVC.')
atmIfVpcSrcRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcSrcRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcRetryCount.setDescription('This attribute indicates the number of failed attempts to set up the soft PVP or soft PVC since the last time the connection failed.')
atmIfVpcSrcLastFailureCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcSrcLastFailureCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcLastFailureCauseCode.setDescription('This attribute contains the cause code in the last transmitted signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages. The default value for this attribute is set to 0.')
atmIfVpcSrcLastFailureDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 6, 11, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcSrcLastFailureDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSrcLastFailureDiagCode.setDescription('This attribute contains the diagnostic code in the last transmitted signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to NULL.')
atmIfVpcRp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7))
atmIfVpcRpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 1), )
if mibBuilder.loadTexts: atmIfVpcRpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcRp components.')
atmIfVpcRpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcRpIndex"))
if mibBuilder.loadTexts: atmIfVpcRpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcRp component.')
atmIfVpcRpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcRp components. These components cannot be added nor deleted.')
atmIfVpcRpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcRpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpStorageType.setDescription('This variable represents the storage type value for the atmIfVpcRp tables.')
atmIfVpcRpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcRpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpIndex.setDescription('This variable represents the index for the atmIfVpcRp tables.')
atmIfVpcRpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 10), )
if mibBuilder.loadTexts: atmIfVpcRpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpOperTable.setDescription('This attribute group contains the operational attributes for the AtmRelayPoint component.')
atmIfVpcRpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcRpIndex"))
if mibBuilder.loadTexts: atmIfVpcRpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpOperEntry.setDescription('An entry in the atmIfVpcRpOperTable.')
atmIfVpcRpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRpNextHop.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRpNextHop.setDescription('This attribute indicates the component name of the Rp component with which this Rp component is associated.')
atmIfVpcRpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 430), )
if mibBuilder.loadTexts: atmIfVpcRpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpNextHopsTable.setDescription('This attribute indicates the component name(s) of the Rp component(s) with which this Rp component is associated. This attribute can have more than one component name only when the Vcc distributionType is pointToMultipoint and the callDirection is fromLink.')
atmIfVpcRpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 430, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcRpIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcRpNextHopsValue"))
if mibBuilder.loadTexts: atmIfVpcRpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpNextHopsEntry.setDescription('An entry in the atmIfVpcRpNextHopsTable.')
atmIfVpcRpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 7, 430, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRpNextHopsValue.setDescription('This variable represents both the value and the index for the atmIfVpcRpNextHopsTable.')
atmIfVpcDst = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8))
atmIfVpcDstRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 1), )
if mibBuilder.loadTexts: atmIfVpcDstRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcDst components.')
atmIfVpcDstRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcDstIndex"))
if mibBuilder.loadTexts: atmIfVpcDstRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcDst component.')
atmIfVpcDstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcDstRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcDst components. These components cannot be added nor deleted.')
atmIfVpcDstComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcDstComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcDstStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcDstStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstStorageType.setDescription('This variable represents the storage type value for the atmIfVpcDst tables.')
atmIfVpcDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstIndex.setDescription('This variable represents the index for the atmIfVpcDst tables.')
atmIfVpcDstOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 10), )
if mibBuilder.loadTexts: atmIfVpcDstOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstOperTable.setDescription('This attribute group contains the operational attributes for the AtmIf/n Vpc/vpi DstPvp component.')
atmIfVpcDstOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVpcDstIndex"))
if mibBuilder.loadTexts: atmIfVpcDstOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstOperEntry.setDescription('An entry in the atmIfVpcDstOperTable.')
atmIfVpcDstCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcDstCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstCalledAddress.setDescription('This attribute indicates the called address of the soft PVP.')
atmIfVpcDstCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcDstCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstCallingAddress.setDescription('This attribute indicates the calling (remote) address of the soft PVP. If the address in not known, then the value of this address is Unknown.')
atmIfVpcDstCallingVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 8, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcDstCallingVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcDstCallingVpi.setDescription('This attribute represents the calling (remote) VPI of the soft PVP. If the VPI value is not known, the attribute value is set to Unknown.')
atmIfVccSrc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8))
atmIfVccSrcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 1), )
if mibBuilder.loadTexts: atmIfVccSrcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccSrc components.')
atmIfVccSrcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccSrcIndex"))
if mibBuilder.loadTexts: atmIfVccSrcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccSrc component.')
atmIfVccSrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccSrcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccSrc components. These components can be added and deleted.')
atmIfVccSrcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccSrcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccSrcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccSrcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcStorageType.setDescription('This variable represents the storage type value for the atmIfVccSrc tables.')
atmIfVccSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcIndex.setDescription('This variable represents the index for the atmIfVccSrc tables.')
atmIfVccSrcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 10), )
if mibBuilder.loadTexts: atmIfVccSrcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcProvTable.setDescription('This attribute group contains the provisionable attributes of the SourcePvc component.')
atmIfVccSrcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccSrcIndex"))
if mibBuilder.loadTexts: atmIfVccSrcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcProvEntry.setDescription('An entry in the atmIfVccSrcProvTable.')
atmIfVccSrcRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccSrcRemoteAddress.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccSrcRemoteAddress.setDescription('This attribute represents the remote address of the soft PVC.')
atmIfVccSrcRemoteVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 10, 1, 2), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccSrcRemoteVpiVci.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccSrcRemoteVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC.')
atmIfVccSrcCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccSrcCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcCallingAddress.setDescription('This attribute represents the calling address of the soft PVC. If it is a null string, then the calling address is the address of the current interface (that is, where the soft PVC originates).')
atmIfVccSrcCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccSrcCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcCalledAddress.setDescription('This attribute represents the called (remote) address of the soft PVC.')
atmIfVccSrcCalledVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 10, 1, 5), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccSrcCalledVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcCalledVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC.')
atmIfVccSrcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 11), )
if mibBuilder.loadTexts: atmIfVccSrcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcOperTable.setDescription('This attribute group contains the operational attributes associated with the SrcPvp or SrcPvc component.')
atmIfVccSrcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccSrcIndex"))
if mibBuilder.loadTexts: atmIfVccSrcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcOperEntry.setDescription('An entry in the atmIfVccSrcOperTable.')
atmIfVccSrcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccSrcState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcState.setDescription('This attribute indicates the state of the soft PVP or soft PVC.')
atmIfVccSrcRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccSrcRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcRetryCount.setDescription('This attribute indicates the number of failed attempts to set up the soft PVP or soft PVC since the last time the connection failed.')
atmIfVccSrcLastFailureCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccSrcLastFailureCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcLastFailureCauseCode.setDescription('This attribute contains the cause code in the last transmitted signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages. The default value for this attribute is set to 0.')
atmIfVccSrcLastFailureDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 8, 11, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccSrcLastFailureDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSrcLastFailureDiagCode.setDescription('This attribute contains the diagnostic code in the last transmitted signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to NULL.')
atmIfVccEp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9))
atmIfVccEpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 1), )
if mibBuilder.loadTexts: atmIfVccEpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccEp components.')
atmIfVccEpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccEpIndex"))
if mibBuilder.loadTexts: atmIfVccEpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccEp component.')
atmIfVccEpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccEpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccEp components. These components cannot be added nor deleted.')
atmIfVccEpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccEpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccEpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccEpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpStorageType.setDescription('This variable represents the storage type value for the atmIfVccEp tables.')
atmIfVccEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpIndex.setDescription('This variable represents the index for the atmIfVccEp tables.')
atmIfVccEpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 10), )
if mibBuilder.loadTexts: atmIfVccEpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpOperTable.setDescription('This attribute group contains the operational attributes for the AtmEndPoint component.')
atmIfVccEpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccEpIndex"))
if mibBuilder.loadTexts: atmIfVccEpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpOperEntry.setDescription('An entry in the atmIfVccEpOperTable.')
atmIfVccEpApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 9, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccEpApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEpApplicationName.setDescription('This attribute indicates the component name associated with the application associated with the switched VCC.')
atmIfVccRp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10))
atmIfVccRpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 1), )
if mibBuilder.loadTexts: atmIfVccRpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccRp components.')
atmIfVccRpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccRpIndex"))
if mibBuilder.loadTexts: atmIfVccRpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccRp component.')
atmIfVccRpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccRp components. These components cannot be added nor deleted.')
atmIfVccRpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccRpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpStorageType.setDescription('This variable represents the storage type value for the atmIfVccRp tables.')
atmIfVccRpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccRpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpIndex.setDescription('This variable represents the index for the atmIfVccRp tables.')
atmIfVccRpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 10), )
if mibBuilder.loadTexts: atmIfVccRpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpOperTable.setDescription('This attribute group contains the operational attributes for the AtmRelayPoint component.')
atmIfVccRpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccRpIndex"))
if mibBuilder.loadTexts: atmIfVccRpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpOperEntry.setDescription('An entry in the atmIfVccRpOperTable.')
atmIfVccRpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRpNextHop.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRpNextHop.setDescription('This attribute indicates the component name of the Rp component with which this Rp component is associated.')
atmIfVccRpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 430), )
if mibBuilder.loadTexts: atmIfVccRpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpNextHopsTable.setDescription('This attribute indicates the component name(s) of the Rp component(s) with which this Rp component is associated. This attribute can have more than one component name only when the Vcc distributionType is pointToMultipoint and the callDirection is fromLink.')
atmIfVccRpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 430, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccRpIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccRpNextHopsValue"))
if mibBuilder.loadTexts: atmIfVccRpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpNextHopsEntry.setDescription('An entry in the atmIfVccRpNextHopsTable.')
atmIfVccRpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 10, 430, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRpNextHopsValue.setDescription('This variable represents both the value and the index for the atmIfVccRpNextHopsTable.')
atmIfVccDst = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11))
atmIfVccDstRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 1), )
if mibBuilder.loadTexts: atmIfVccDstRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccDst components.')
atmIfVccDstRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccDstIndex"))
if mibBuilder.loadTexts: atmIfVccDstRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccDst component.')
atmIfVccDstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccDstRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccDst components. These components cannot be added nor deleted.')
atmIfVccDstComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccDstComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccDstStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccDstStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstStorageType.setDescription('This variable represents the storage type value for the atmIfVccDst tables.')
atmIfVccDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstIndex.setDescription('This variable represents the index for the atmIfVccDst tables.')
atmIfVccDstOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 10), )
if mibBuilder.loadTexts: atmIfVccDstOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstOperTable.setDescription('This attribute group contains the operational attributes for the DestinationPvc component.')
atmIfVccDstOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVccDstIndex"))
if mibBuilder.loadTexts: atmIfVccDstOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstOperEntry.setDescription('An entry in the atmIfVccDstOperTable.')
atmIfVccDstCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccDstCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstCalledAddress.setDescription('This attribute represents the called address of the soft PVC.')
atmIfVccDstCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 10, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccDstCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstCallingAddress.setDescription('This attribute represents the remote address of the soft PVC. If the address in not known, then the value of this address is Unknown.')
atmIfVccDstCallingVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 11, 10, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccDstCallingVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDstCallingVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC. If the VPI and VCI values are not known, this attribute is set to Unknown.')
atmIfVptVccSrc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8))
atmIfVptVccSrcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 1), )
if mibBuilder.loadTexts: atmIfVptVccSrcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccSrc components.')
atmIfVptVccSrcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccSrcIndex"))
if mibBuilder.loadTexts: atmIfVptVccSrcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccSrc component.')
atmIfVptVccSrcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccSrcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccSrc components. These components can be added and deleted.')
atmIfVptVccSrcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccSrcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccSrcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccSrcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccSrc tables.')
atmIfVptVccSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcIndex.setDescription('This variable represents the index for the atmIfVptVccSrc tables.')
atmIfVptVccSrcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 10), )
if mibBuilder.loadTexts: atmIfVptVccSrcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcProvTable.setDescription('This attribute group contains the provisionable attributes of the SourcePvc component.')
atmIfVptVccSrcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccSrcIndex"))
if mibBuilder.loadTexts: atmIfVptVccSrcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcProvEntry.setDescription('An entry in the atmIfVptVccSrcProvTable.')
atmIfVptVccSrcRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 10, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccSrcRemoteAddress.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccSrcRemoteAddress.setDescription('This attribute represents the remote address of the soft PVC.')
atmIfVptVccSrcRemoteVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 10, 1, 2), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccSrcRemoteVpiVci.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccSrcRemoteVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC.')
atmIfVptVccSrcCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 20)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccSrcCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcCallingAddress.setDescription('This attribute represents the calling address of the soft PVC. If it is a null string, then the calling address is the address of the current interface (that is, where the soft PVC originates).')
atmIfVptVccSrcCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccSrcCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcCalledAddress.setDescription('This attribute represents the called (remote) address of the soft PVC.')
atmIfVptVccSrcCalledVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 10, 1, 5), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccSrcCalledVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcCalledVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC.')
atmIfVptVccSrcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 11), )
if mibBuilder.loadTexts: atmIfVptVccSrcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcOperTable.setDescription('This attribute group contains the operational attributes associated with the SrcPvp or SrcPvc component.')
atmIfVptVccSrcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccSrcIndex"))
if mibBuilder.loadTexts: atmIfVptVccSrcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcOperEntry.setDescription('An entry in the atmIfVptVccSrcOperTable.')
atmIfVptVccSrcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("active", 0), ("inactive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccSrcState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcState.setDescription('This attribute indicates the state of the soft PVP or soft PVC.')
atmIfVptVccSrcRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccSrcRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcRetryCount.setDescription('This attribute indicates the number of failed attempts to set up the soft PVP or soft PVC since the last time the connection failed.')
atmIfVptVccSrcLastFailureCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccSrcLastFailureCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcLastFailureCauseCode.setDescription('This attribute contains the cause code in the last transmitted signalling message that contains the CAUSE information element. The cause code is used to describe the reason for generating certain signalling messages. The default value for this attribute is set to 0.')
atmIfVptVccSrcLastFailureDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 8, 11, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccSrcLastFailureDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSrcLastFailureDiagCode.setDescription('This attribute contains the diagnostic code in the last transmitted signalling message. The diagnostic code is contained in the CAUSE information element and identifies an information element type or timer type. The diagnostic code is present only if a procedural error is detected by the signalling protocol. A diagnostic code is always accompanied by the cause code. If there is no failure, this attribute is set to NULL.')
atmIfVptVccEp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9))
atmIfVptVccEpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 1), )
if mibBuilder.loadTexts: atmIfVptVccEpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccEp components.')
atmIfVptVccEpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccEpIndex"))
if mibBuilder.loadTexts: atmIfVptVccEpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccEp component.')
atmIfVptVccEpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccEpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccEp components. These components cannot be added nor deleted.')
atmIfVptVccEpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccEpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccEpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccEpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccEp tables.')
atmIfVptVccEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpIndex.setDescription('This variable represents the index for the atmIfVptVccEp tables.')
atmIfVptVccEpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 10), )
if mibBuilder.loadTexts: atmIfVptVccEpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpOperTable.setDescription('This attribute group contains the operational attributes for the AtmEndPoint component.')
atmIfVptVccEpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccEpIndex"))
if mibBuilder.loadTexts: atmIfVptVccEpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpOperEntry.setDescription('An entry in the atmIfVptVccEpOperTable.')
atmIfVptVccEpApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 9, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccEpApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEpApplicationName.setDescription('This attribute indicates the component name associated with the application associated with the switched VCC.')
atmIfVptVccRp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10))
atmIfVptVccRpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 1), )
if mibBuilder.loadTexts: atmIfVptVccRpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccRp components.')
atmIfVptVccRpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccRpIndex"))
if mibBuilder.loadTexts: atmIfVptVccRpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccRp component.')
atmIfVptVccRpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccRp components. These components cannot be added nor deleted.')
atmIfVptVccRpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccRpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccRp tables.')
atmIfVptVccRpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccRpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpIndex.setDescription('This variable represents the index for the atmIfVptVccRp tables.')
atmIfVptVccRpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 10), )
if mibBuilder.loadTexts: atmIfVptVccRpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpOperTable.setDescription('This attribute group contains the operational attributes for the AtmRelayPoint component.')
atmIfVptVccRpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccRpIndex"))
if mibBuilder.loadTexts: atmIfVptVccRpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpOperEntry.setDescription('An entry in the atmIfVptVccRpOperTable.')
atmIfVptVccRpNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 10, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRpNextHop.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRpNextHop.setDescription('This attribute indicates the component name of the Rp component with which this Rp component is associated.')
atmIfVptVccRpNextHopsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 430), )
if mibBuilder.loadTexts: atmIfVptVccRpNextHopsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpNextHopsTable.setDescription('This attribute indicates the component name(s) of the Rp component(s) with which this Rp component is associated. This attribute can have more than one component name only when the Vcc distributionType is pointToMultipoint and the callDirection is fromLink.')
atmIfVptVccRpNextHopsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 430, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccRpIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccRpNextHopsValue"))
if mibBuilder.loadTexts: atmIfVptVccRpNextHopsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpNextHopsEntry.setDescription('An entry in the atmIfVptVccRpNextHopsTable.')
atmIfVptVccRpNextHopsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 10, 430, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRpNextHopsValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRpNextHopsValue.setDescription('This variable represents both the value and the index for the atmIfVptVccRpNextHopsTable.')
atmIfVptVccDst = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11))
atmIfVptVccDstRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 1), )
if mibBuilder.loadTexts: atmIfVptVccDstRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccDst components.')
atmIfVptVccDstRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccDstIndex"))
if mibBuilder.loadTexts: atmIfVptVccDstRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccDst component.')
atmIfVptVccDstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccDstRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccDst components. These components cannot be added nor deleted.')
atmIfVptVccDstComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccDstComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccDstStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccDstStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccDst tables.')
atmIfVptVccDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstIndex.setDescription('This variable represents the index for the atmIfVptVccDst tables.')
atmIfVptVccDstOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 10), )
if mibBuilder.loadTexts: atmIfVptVccDstOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstOperTable.setDescription('This attribute group contains the operational attributes for the DestinationPvc component.')
atmIfVptVccDstOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmNetworkingMIB", "atmIfVptVccDstIndex"))
if mibBuilder.loadTexts: atmIfVptVccDstOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstOperEntry.setDescription('An entry in the atmIfVptVccDstOperTable.')
atmIfVptVccDstCalledAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 10, 1, 3), HexString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccDstCalledAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstCalledAddress.setDescription('This attribute represents the called address of the soft PVC.')
atmIfVptVccDstCallingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 10, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccDstCallingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstCallingAddress.setDescription('This attribute represents the remote address of the soft PVC. If the address in not known, then the value of this address is Unknown.')
atmIfVptVccDstCallingVpiVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 11, 10, 1, 5), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(7, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccDstCallingVpiVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDstCallingVpiVci.setDescription('This attribute represents the remote VPI and VCI of the soft PVC. If the VPI and VCI values are not known, this attribute is set to Unknown.')
atmNetworkingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42, 1))
atmNetworkingGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42, 1, 5))
atmNetworkingGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42, 1, 5, 2))
atmNetworkingGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42, 1, 5, 2, 2))
atmNetworkingCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42, 3))
atmNetworkingCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42, 3, 5))
atmNetworkingCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42, 3, 5, 2))
atmNetworkingCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 42, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmNetworkingMIB", aRtgPnniRfTxTrafficDescType=aRtgPnniRfTxTrafficDescType, aRtgPnniRfFqpIndex=aRtgPnniRfFqpIndex, aRtgPnniCfgNodeNbrStorageType=aRtgPnniCfgNodeNbrStorageType, atmIfVptVccRpNextHopsEntry=atmIfVptVccRpNextHopsEntry, atmIfVccSrcRowStatusTable=atmIfVccSrcRowStatusTable, aRtgPnniHelloHoldDown=aRtgPnniHelloHoldDown, atmIfVpcSrcRowStatusEntry=atmIfVpcSrcRowStatusEntry, atmIfVccSrcRowStatus=atmIfVccSrcRowStatus, atmIfVccRpRowStatusEntry=atmIfVccRpRowStatusEntry, aRtgPnniPtseParmsTable=aRtgPnniPtseParmsTable, atmIfVptVccEpOperTable=atmIfVptVccEpOperTable, atmIfVptVccRpOperEntry=atmIfVptVccRpOperEntry, atmIfVccEpIndex=atmIfVccEpIndex, aRtgPnniCfgNodeNbrBadPtseRx=aRtgPnniCfgNodeNbrBadPtseRx, atmIfVccEpStorageType=atmIfVccEpStorageType, aRtgPnniCfgNodeStorageType=aRtgPnniCfgNodeStorageType, aRtgPnniRfTxTdpIndex=aRtgPnniRfTxTdpIndex, atmIfVpcSrcIndex=atmIfVpcSrcIndex, atmCRCallsRouted=atmCRCallsRouted, aRtgPnniTopNodeAddrAddressIndex=aRtgPnniTopNodeAddrAddressIndex, aRtgPnniPtseLifetimeFactor=aRtgPnniPtseLifetimeFactor, aRtgPnniCfgNodeNodeAddress=aRtgPnniCfgNodeNodeAddress, aRtgPnniCfgNodeNbrIndex=aRtgPnniCfgNodeNbrIndex, aRtgPnniRfBqpIndex=aRtgPnniRfBqpIndex, aRtgPnniCfgNodeNbrPeerState=aRtgPnniCfgNodeNbrPeerState, aRtgDnaDestInfoType=aRtgDnaDestInfoType, aRtgPnniRfBwdQosClass=aRtgPnniRfBwdQosClass, aRtgPnniTopNodeLink=aRtgPnniTopNodeLink, aRtgPnniReElectionInterval=aRtgPnniReElectionInterval, atmIfVpcRpNextHopsValue=atmIfVpcRpNextHopsValue, aRtgPnniTopNodeRowStatus=aRtgPnniTopNodeRowStatus, aRtgStorageType=aRtgStorageType, aRtgPnniTopNodeLinkRowStatus=aRtgPnniTopNodeLinkRowStatus, aRtgPnniCfgNodeNbrPtspRx=aRtgPnniCfgNodeNbrPtspRx, aRtgPnniCfgNodeNbrStatsTable=aRtgPnniCfgNodeNbrStatsTable, atmIfVpcSrcProvTable=atmIfVpcSrcProvTable, aRtgPnniTopPreferredPglNodeId=aRtgPnniTopPreferredPglNodeId, aRtgPnniTopNodeComponentName=aRtgPnniTopNodeComponentName, atmIfVpcSrcState=atmIfVpcSrcState, aRtgPnniHlParmsEntry=aRtgPnniHlParmsEntry, aRtgPnniCfgNodeNbr=aRtgPnniCfgNodeNbr, aRtgPnniTopNodeRowStatusEntry=aRtgPnniTopNodeRowStatusEntry, aRtgPnniCfgNodeNbrPtspTx=aRtgPnniCfgNodeNbrPtspTx, atmIfVpcSrcRowStatusTable=atmIfVpcSrcRowStatusTable, atmIfVptVccEp=atmIfVptVccEp, aRtgPnniCfgNodeDefSAddrIndex=aRtgPnniCfgNodeDefSAddrIndex, aRtgPnniRfRxTrafficDescType=aRtgPnniRfRxTrafficDescType, atmIfVpcDstRowStatus=atmIfVpcDstRowStatus, aRtgPnniIndex=aRtgPnniIndex, atmIfVptVccRpNextHopsTable=atmIfVptVccRpNextHopsTable, aRtgPnniThreshParmsEntry=aRtgPnniThreshParmsEntry, aRtgPnniCfgNodeDefSAddrAddress=aRtgPnniCfgNodeDefSAddrAddress, aRtgPnniTopNodeAddrRowStatus=aRtgPnniTopNodeAddrRowStatus, atmCRDnaRowStatusTable=atmCRDnaRowStatusTable, aRtgPnniRfTxTdpTable=aRtgPnniRfTxTdpTable, atmIfVccSrcRemoteAddress=atmIfVccSrcRemoteAddress, aRtgPnniCfgNodeNbrDbSummariesTx=aRtgPnniCfgNodeNbrDbSummariesTx, aRtgPnniTopOperTable=aRtgPnniTopOperTable, atmIfVptVccDstStorageType=atmIfVptVccDstStorageType, aRtgPnniHelloInactivityFactor=aRtgPnniHelloInactivityFactor, aRtgPnniRestrictTransit=aRtgPnniRestrictTransit, aRtgPnniCfgNodeRowStatusEntry=aRtgPnniCfgNodeRowStatusEntry, aRtgPnniCfgNodeNbrBadDbSummariesRx=aRtgPnniCfgNodeNbrBadDbSummariesRx, atmCRDnaDestinationNameEntry=atmCRDnaDestinationNameEntry, aRtgPnniRfBqpValue=aRtgPnniRfBqpValue, aRtgPnniTopNodeLinkStorageType=aRtgPnniTopNodeLinkStorageType, atmIfVpcDstCallingVpi=atmIfVpcDstCallingVpi, aRtgPnniCfgNodeNbrRowStatusTable=aRtgPnniCfgNodeNbrRowStatusTable, atmCRDnaRowStatus=atmCRDnaRowStatus, atmIfVptVccEpComponentName=atmIfVptVccEpComponentName, atmIfVptVccSrcStorageType=atmIfVptVccSrcStorageType, aRtgPnniCfgNodeRowStatus=aRtgPnniCfgNodeRowStatus, aRtgPnniCfgNodeNumRccs=aRtgPnniCfgNodeNumRccs, atmIfVpcDstRowStatusEntry=atmIfVpcDstRowStatusEntry, atmIfVccSrcOperEntry=atmIfVccSrcOperEntry, atmIfVccSrcLastFailureCauseCode=atmIfVccSrcLastFailureCauseCode, aRtgPnniPortStdComponentName=aRtgPnniPortStdComponentName, aRtgPnniCfgNodeNbrRowStatus=aRtgPnniCfgNodeNbrRowStatus, aRtgPnniCfgNodeNbrPtseTx=aRtgPnniCfgNodeNbrPtseTx, atmNetworkingGroupBE01A=atmNetworkingGroupBE01A, aRtgPnniProvEntry=aRtgPnniProvEntry, atmIfVptVccSrcRemoteAddress=atmIfVptVccSrcRemoteAddress, atmIfVpcSrcProvEntry=atmIfVpcSrcProvEntry, aRtgPnniPglInitTime=aRtgPnniPglInitTime, aRtgPnniTopOperEntry=aRtgPnniTopOperEntry, atmIfVccDstRowStatusTable=atmIfVccDstRowStatusTable, aRtgPnniTopNodeLinkRowStatusEntry=aRtgPnniTopNodeLinkRowStatusEntry, aRtgPnniTopNodeLinkIndex=aRtgPnniTopNodeLinkIndex, aRtgPnniCfgNodeNbrDbSummariesRx=aRtgPnniCfgNodeNbrDbSummariesRx, aRtgPnniPortComponentName=aRtgPnniPortComponentName, aRtgPnniRfIndex=aRtgPnniRfIndex, aRtgPnniRoutingAttempts=aRtgPnniRoutingAttempts, aRtgPnniOptMetricEntry=aRtgPnniOptMetricEntry, aRtgPnniCfgNodeNbrPtseAcksRx=aRtgPnniCfgNodeNbrPtseAcksRx, aRtgPnniRfClippingBbc=aRtgPnniRfClippingBbc, aRtgPnniTopNodeAddrRowStatusEntry=aRtgPnniTopNodeAddrRowStatusEntry, atmIfVptVccRpOperTable=atmIfVptVccRpOperTable, aRtgDnaDestInfoOperTable=aRtgDnaDestInfoOperTable, aRtgPnniTopNodeIndex=aRtgPnniTopNodeIndex, aRtgPnniCfgNodeDefSAddr=aRtgPnniCfgNodeDefSAddr, aRtgDna=aRtgDna, aRtgPnniCfgNodeIndex=aRtgPnniCfgNodeIndex, aRtgDnaDestInfoIndex=aRtgDnaDestInfoIndex, aRtgPnniCfgNodeSAddrPrefixLengthIndex=aRtgPnniCfgNodeSAddrPrefixLengthIndex, aRtgDnaDestInfoRowStatusTable=aRtgDnaDestInfoRowStatusTable, aRtgPnniTopNodeLinkOperEntry=aRtgPnniTopNodeLinkOperEntry, aRtgPnniCfgNodeSAddrScope=aRtgPnniCfgNodeSAddrScope, aRtgPnniTopNodeLinkOperTable=aRtgPnniTopNodeLinkOperTable, aRtgPnniCfgNodeSAddrOperEntry=aRtgPnniCfgNodeSAddrOperEntry, atmIfVccRpNextHop=atmIfVccRpNextHop, aRtgPnniCfgNodeNbrOperTable=aRtgPnniCfgNodeNbrOperTable, atmIfVccEpComponentName=atmIfVccEpComponentName, aRtgDnaRowStatus=aRtgDnaRowStatus, atmIfVptVccDstOperEntry=atmIfVptVccDstOperEntry, aRtgPnniCfgNodeNbrRccListTable=aRtgPnniCfgNodeNbrRccListTable, atmIfVpcDstOperTable=atmIfVpcDstOperTable, aRtgPnniRfFwdQosClass=aRtgPnniRfFwdQosClass, atmIfVpcSrcLastFailureCauseCode=atmIfVpcSrcLastFailureCauseCode, atmCRDnaDestinationNameValue=atmCRDnaDestinationNameValue, atmIfVpcSrcCallingAddress=atmIfVpcSrcCallingAddress, aRtgPnniPtseParmsEntry=aRtgPnniPtseParmsEntry, aRtgPnniPortRowStatusEntry=aRtgPnniPortRowStatusEntry, aRtgPnniCfgNodeDefSAddrDefAddrTable=aRtgPnniCfgNodeDefSAddrDefAddrTable, atmCRRowStatusTable=atmCRRowStatusTable, aRtgPnniDefaultScope=aRtgPnniDefaultScope, aRtgPnniCfgNodeNbrRccListValue=aRtgPnniCfgNodeNbrRccListValue, atmIfVptVccDstIndex=atmIfVptVccDstIndex, aRtgPnniTopNodeAddrScope=aRtgPnniTopNodeAddrScope, atmIfVccSrcProvEntry=atmIfVccSrcProvEntry, aRtgPnniCfgNodeProvTable=aRtgPnniCfgNodeProvTable, atmIfVccRpRowStatusTable=atmIfVccRpRowStatusTable, aRtgPnniTopPtsesInDatabase=aRtgPnniTopPtsesInDatabase, aRtgPnniTopRowStatusEntry=aRtgPnniTopRowStatusEntry, aRtgPnniPortIndex=aRtgPnniPortIndex, aRtgPnniCfgNodeDefSAddrOperEntry=aRtgPnniCfgNodeDefSAddrOperEntry, atmIfVptVccRpNextHopsValue=atmIfVptVccRpNextHopsValue, aRtgPnniRfDestinationAddress=aRtgPnniRfDestinationAddress, atmIfVpcSrcCalledAddress=atmIfVpcSrcCalledAddress, aRtgPnniCfgNodeOperTable=aRtgPnniCfgNodeOperTable, atmCR=atmCR, atmIfVpcDstCallingAddress=atmIfVpcDstCallingAddress, aRtgPnniRfMaxRoutes=aRtgPnniRfMaxRoutes, atmIfVptVccSrcRetryCount=atmIfVptVccSrcRetryCount, aRtgDnaDestInfoComponentName=aRtgDnaDestInfoComponentName, atmCRRowStatusEntry=atmCRRowStatusEntry, atmIfVpcRpComponentName=atmIfVpcRpComponentName, aRtgDnaDestInfoReachability=aRtgDnaDestInfoReachability, aRtgPnniRfCriteriaTable=aRtgPnniRfCriteriaTable, aRtgPnniCfgNodeNbrStatsEntry=aRtgPnniCfgNodeNbrStatsEntry, aRtgPnniAvcrPm=aRtgPnniAvcrPm, atmCRCallsFailed=atmCRCallsFailed, aRtgPnniHlParmsTable=aRtgPnniHlParmsTable, aRtgPnniTopNodeAddrOperEntry=aRtgPnniTopNodeAddrOperEntry, atmIfVccDstRowStatus=atmIfVccDstRowStatus, aRtgPnniCfgNodeOperEntry=aRtgPnniCfgNodeOperEntry, aRtgPnniTop=aRtgPnniTop, aRtgPnniTopNodeLinkRemotePortId=aRtgPnniTopNodeLinkRemotePortId, atmIfVptVccSrcRowStatus=atmIfVptVccSrcRowStatus, aRtgPnniRfTxTdpValue=aRtgPnniRfTxTdpValue, atmIfVptVccRpComponentName=atmIfVptVccRpComponentName, atmNetworkingGroupBE=atmNetworkingGroupBE, aRtgPnniTopNodeLinkComponentName=aRtgPnniTopNodeLinkComponentName, aRtgPnniTopNodeAddr=aRtgPnniTopNodeAddr, atmIfVptVccSrcCallingAddress=atmIfVptVccSrcCallingAddress, atmIfVpcSrcStorageType=atmIfVpcSrcStorageType, aRtgPnniTopNodeStorageType=aRtgPnniTopNodeStorageType, aRtgPnniCfgNodeNbrComponentName=aRtgPnniCfgNodeNbrComponentName, atmIfVccRpRowStatus=atmIfVccRpRowStatus, aRtgPnniCfgNodeNbrBadPtseAckRx=aRtgPnniCfgNodeNbrBadPtseAckRx, aRtgPnniPortRowStatusTable=aRtgPnniPortRowStatusTable, aRtgDnaRowStatusEntry=aRtgDnaRowStatusEntry, aRtgPnniRowStatusEntry=aRtgPnniRowStatusEntry, aRtgPnniCfgNodeDefSAddrScope=aRtgPnniCfgNodeDefSAddrScope, aRtgPnniTopNodeAddrPrefixLengthIndex=aRtgPnniTopNodeAddrPrefixLengthIndex, atmIfVccRpIndex=atmIfVccRpIndex, atmIfVccSrcLastFailureDiagCode=atmIfVccSrcLastFailureDiagCode, atmIfVptVccRpStorageType=atmIfVptVccRpStorageType, atmIfVccDstCallingVpiVci=atmIfVccDstCallingVpiVci, aRtgPnniThreshParmsTable=aRtgPnniThreshParmsTable, atmIfVccRp=atmIfVccRp, atmCRStatsEntry=atmCRStatsEntry, aRtgPnniTopNodeAddrOperTable=aRtgPnniTopNodeAddrOperTable, atmCRDnaDestinationNameTable=atmCRDnaDestinationNameTable, aRtgPnniRfBestEffort=aRtgPnniRfBestEffort, atmIfVccDstCallingAddress=atmIfVccDstCallingAddress, aRtgPnniTopNodeLinkRemoteNodeId=aRtgPnniTopNodeLinkRemoteNodeId, atmCRProvEntry=atmCRProvEntry, aRtgPnniTopIndex=aRtgPnniTopIndex, atmIfVptVccSrcProvEntry=atmIfVptVccSrcProvEntry, atmIfVccSrcStorageType=atmIfVccSrcStorageType, atmIfVpcRpNextHopsTable=atmIfVpcRpNextHopsTable, atmIfVptVccRpRowStatusEntry=atmIfVptVccRpRowStatusEntry, atmIfVccSrcCalledAddress=atmIfVccSrcCalledAddress, atmCRProvTable=atmCRProvTable, atmIfVptVccDstComponentName=atmIfVptVccDstComponentName, aRtgPnniPtseRefreshInterval=aRtgPnniPtseRefreshInterval, aRtgPnniCfgNodeSAddrOperTable=aRtgPnniCfgNodeSAddrOperTable, atmNetworkingGroupBE01=atmNetworkingGroupBE01, aRtgPnniRfTxTdpEntry=aRtgPnniRfTxTdpEntry, aRtgPnniRfFqpValue=aRtgPnniRfFqpValue, atmIfVccSrcOperTable=atmIfVccSrcOperTable, aRtgPnniCfgNodeNbrOperEntry=aRtgPnniCfgNodeNbrOperEntry, atmIfVccSrcComponentName=atmIfVccSrcComponentName, aRtgPnniTopStorageType=aRtgPnniTopStorageType, atmIfVccEp=atmIfVccEp, aRtgPnniTopNodeAddrReachabilityIndex=aRtgPnniTopNodeAddrReachabilityIndex, atmIfVccRpNextHopsEntry=atmIfVccRpNextHopsEntry, aRtgPnniTopNode=aRtgPnniTopNode, aRtgRowStatusTable=aRtgRowStatusTable, aRtgDnaDestInfoRowStatusEntry=aRtgDnaDestInfoRowStatusEntry, aRtgPnniCfgNodeSAddrAddressIndex=aRtgPnniCfgNodeSAddrAddressIndex, aRtgPnniRf=aRtgPnniRf, atmIfVccSrcProvTable=atmIfVccSrcProvTable, aRtgPnniProvTable=aRtgPnniProvTable, aRtgPnniPort=aRtgPnniPort, aRtgPnniCfgNodeOpPeerGroupId=aRtgPnniCfgNodeOpPeerGroupId, atmIfVptVccSrcProvTable=atmIfVptVccSrcProvTable, aRtgPnni=aRtgPnni, atmCRDnaComponentName=atmCRDnaComponentName, atmCRNodeAddress=atmCRNodeAddress, atmNetworkingGroup=atmNetworkingGroup, atmIfVpcSrcCalledVpi=atmIfVpcSrcCalledVpi, atmIfVccSrcRemoteVpiVci=atmIfVccSrcRemoteVpiVci, aRtgPnniTopNodeRowStatusTable=aRtgPnniTopNodeRowStatusTable, aRtgPnniRfFqpTable=aRtgPnniRfFqpTable, aRtgPnniCfgNodeSAddrRowStatusTable=aRtgPnniCfgNodeSAddrRowStatusTable, aRtgPnniTopNodeLinkRowStatusTable=aRtgPnniTopNodeLinkRowStatusTable, atmIfVpcRpNextHop=atmIfVpcRpNextHop, aRtgPnniCfgNodeNbrBadPtspRx=aRtgPnniCfgNodeNbrBadPtspRx, aRtgPnniCfgNodeOpNodeId=aRtgPnniCfgNodeOpNodeId, atmCRIndex=atmCRIndex, aRtgPnniCfgNodeNbrRowStatusEntry=aRtgPnniCfgNodeNbrRowStatusEntry, atmIfVccDstOperTable=atmIfVccDstOperTable, atmIfVccSrcCalledVpiVci=atmIfVccSrcCalledVpiVci, aRtgPnniRfRxTdpEntry=aRtgPnniRfRxTdpEntry, atmIfVpcDst=atmIfVpcDst, aRtgDnaDestInfoScope=aRtgDnaDestInfoScope, aRtgPnniCfgNodeDefSAddrRowStatus=aRtgPnniCfgNodeDefSAddrRowStatus, aRtgPnniOptMetricValue=aRtgPnniOptMetricValue, atmIfVptVccSrcCalledAddress=atmIfVptVccSrcCalledAddress, aRtgPnniAvcrMt=aRtgPnniAvcrMt, aRtgPnniDomain=aRtgPnniDomain, atmIfVptVccSrc=atmIfVptVccSrc, atmIfVptVccSrcState=atmIfVptVccSrcState, aRtgPnniRequestRxmtInterval=aRtgPnniRequestRxmtInterval, aRtgPnniCfgNodeSAddrReachabilityIndex=aRtgPnniCfgNodeSAddrReachabilityIndex, atmIfVccDstIndex=atmIfVccDstIndex, atmIfVpcRpOperTable=atmIfVpcRpOperTable, atmIfVptVccSrcRemoteVpiVci=atmIfVptVccSrcRemoteVpiVci, aRtgPnniNodeAddressPrefix=aRtgPnniNodeAddressPrefix, atmCRDnaIndex=atmCRDnaIndex, aRtgPnniRfRxTdpTable=aRtgPnniRfRxTdpTable, aRtgPnniCfgNodeNodeId=aRtgPnniCfgNodeNodeId, atmIfVccDstRowStatusEntry=atmIfVccDstRowStatusEntry)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmNetworkingMIB", atmIfVptVccRpRowStatus=atmIfVptVccRpRowStatus, aRtgPnniPglParmsEntry=aRtgPnniPglParmsEntry, aRtgPnniCfgNode=aRtgPnniCfgNode, aRtgPnniCfgNodePglElectionState=aRtgPnniCfgNodePglElectionState, aRtgPnniTopRowStatus=aRtgPnniTopRowStatus, aRtgPnniCfgNodeDefSAddrComponentName=aRtgPnniCfgNodeDefSAddrComponentName, aRtgPnniPtseHoldDown=aRtgPnniPtseHoldDown, atmIfVptVccSrcRowStatusTable=atmIfVptVccSrcRowStatusTable, atmIfVptVccEpRowStatusTable=atmIfVptVccEpRowStatusTable, atmIfVptVccRpNextHop=atmIfVptVccRpNextHop, aRtgPnniTopPglNodeId=aRtgPnniTopPglNodeId, aRtgRoutingAttempts=aRtgRoutingAttempts, atmIfVpcDstComponentName=atmIfVpcDstComponentName, aRtgPnniRfAtmServiceCategory=aRtgPnniRfAtmServiceCategory, aRtgPnniFailedRoutingAttempts=aRtgPnniFailedRoutingAttempts, atmIfVptVccSrcIndex=atmIfVptVccSrcIndex, atmCRStorageType=atmCRStorageType, atmIfVptVccSrcRowStatusEntry=atmIfVptVccSrcRowStatusEntry, aRtgPnniTopRowStatusTable=aRtgPnniTopRowStatusTable, aRtgFailedRoutingAttempts=aRtgFailedRoutingAttempts, atmIfVccSrcRetryCount=atmIfVccSrcRetryCount, aRtgPnniPeerDelayedAckInterval=aRtgPnniPeerDelayedAckInterval, atmIfVptVccEpStorageType=atmIfVptVccEpStorageType, aRtgPnniTopNodeAddrComponentName=aRtgPnniTopNodeAddrComponentName, atmIfVptVccEpRowStatusEntry=atmIfVptVccEpRowStatusEntry, atmNetworkingMIB=atmNetworkingMIB, atmIfVptVccSrcLastFailureCauseCode=atmIfVptVccSrcLastFailureCauseCode, aRtgPnniRfRowStatusTable=aRtgPnniRfRowStatusTable, atmIfVccSrcCallingAddress=atmIfVccSrcCallingAddress, aRtgPnniCfgNodeSAddrSuppress=aRtgPnniCfgNodeSAddrSuppress, atmCRComponentName=atmCRComponentName, atmIfVptVccDstOperTable=atmIfVptVccDstOperTable, aRtgRowStatus=aRtgRowStatus, aRtgPnniCfgNodeNbrPtseReqTx=aRtgPnniCfgNodeNbrPtseReqTx, aRtgDnaDestInfoStorageType=aRtgDnaDestInfoStorageType, aRtgPnniCfgNodeSAddrRowStatus=aRtgPnniCfgNodeSAddrRowStatus, aRtgPnniRfComponentName=aRtgPnniRfComponentName, atmIfVccEpApplicationName=atmIfVccEpApplicationName, aRtgPnniCfgNodeProvEntry=aRtgPnniCfgNodeProvEntry, atmCRDnaStorageType=atmCRDnaStorageType, atmIfVccDstComponentName=atmIfVccDstComponentName, aRtgDnaComponentName=aRtgDnaComponentName, atmIfVccRpOperTable=atmIfVccRpOperTable, aRtgPnniRfRowStatus=aRtgPnniRfRowStatus, aRtgPnniRfCriteriaEntry=aRtgPnniRfCriteriaEntry, aRtgPnniCfgNodeSAddrProvEntry=aRtgPnniCfgNodeSAddrProvEntry, aRtgDnaDestInfoOperEntry=aRtgDnaDestInfoOperEntry, atmCRStatsTable=atmCRStatsTable, aRtgPnniCfgNodeSAddrComponentName=aRtgPnniCfgNodeSAddrComponentName, aRtgPnniPortOperTable=aRtgPnniPortOperTable, atmIfVpcDstOperEntry=atmIfVpcDstOperEntry, atmIfVpcSrcRetryCount=atmIfVpcSrcRetryCount, atmIfVpcRp=atmIfVpcRp, aRtgPnniCfgNodeNbrBadPtseReqRx=aRtgPnniCfgNodeNbrBadPtseReqRx, aRtgPnniCfgNodeSAddrState=aRtgPnniCfgNodeSAddrState, aRtgPnniCfgNodeNumNeighbors=aRtgPnniCfgNodeNumNeighbors, atmIfVpcRpIndex=atmIfVpcRpIndex, atmIfVptVccEpApplicationName=atmIfVptVccEpApplicationName, atmIfVccEpRowStatusEntry=atmIfVccEpRowStatusEntry, aRtgStatsEntry=aRtgStatsEntry, aRtg=aRtg, atmIfVccRpComponentName=atmIfVccRpComponentName, atmIfVpcDstRowStatusTable=atmIfVpcDstRowStatusTable, atmIfVpcSrcOperEntry=atmIfVpcSrcOperEntry, aRtgPnniCfgNodeDefSAddrRowStatusTable=aRtgPnniCfgNodeDefSAddrRowStatusTable, aRtgPnniStatsEntry=aRtgPnniStatsEntry, aRtgDnaIndex=aRtgDnaIndex, aRtgPnniRfFqpEntry=aRtgPnniRfFqpEntry, aRtgPnniCfgNodeDefSAddrState=aRtgPnniCfgNodeDefSAddrState, aRtgPnniHelloInterval=aRtgPnniHelloInterval, aRtgPnniCfgNodeDefSAddrRowStatusEntry=aRtgPnniCfgNodeDefSAddrRowStatusEntry, aRtgStatsTable=aRtgStatsTable, aRtgPnniRowStatus=aRtgPnniRowStatus, aRtgPnniCallsRerouted=aRtgPnniCallsRerouted, atmIfVpcDstCalledAddress=atmIfVpcDstCalledAddress, aRtgPnniRfBqpEntry=aRtgPnniRfBqpEntry, aRtgIndex=aRtgIndex, aRtgPnniCfgNodeDefSAddrDefAddrEntry=aRtgPnniCfgNodeDefSAddrDefAddrEntry, aRtgPnniMaxReroutesOnCrankback=aRtgPnniMaxReroutesOnCrankback, aRtgPnniOperEntry=aRtgPnniOperEntry, aRtgPnniRfStorageType=aRtgPnniRfStorageType, atmIfVptVccSrcOperEntry=atmIfVptVccSrcOperEntry, atmIfVccEpRowStatusTable=atmIfVccEpRowStatusTable, atmIfVpcRpRowStatusTable=atmIfVpcRpRowStatusTable, atmIfVccEpOperTable=atmIfVccEpOperTable, aRtgPnniRfOptimizationMetric=aRtgPnniRfOptimizationMetric, aRtgPnniCfgNodeSAddrRowStatusEntry=aRtgPnniCfgNodeSAddrRowStatusEntry, aRtgPnniOptMetricIndex=aRtgPnniOptMetricIndex, atmIfVptVccEpRowStatus=atmIfVptVccEpRowStatus, aRtgDnaDestInfo=aRtgDnaDestInfo, atmIfVccDst=atmIfVccDst, atmIfVpcSrcComponentName=atmIfVpcSrcComponentName, atmIfVptVccDstCalledAddress=atmIfVptVccDstCalledAddress, atmIfVptVccDstRowStatusTable=atmIfVptVccDstRowStatusTable, aRtgPnniCfgNodeDefSAddrOperTable=aRtgPnniCfgNodeDefSAddrOperTable, aRtgPnniRfRowStatusEntry=aRtgPnniRfRowStatusEntry, aRtgPnniRfRxTdpValue=aRtgPnniRfRxTdpValue, atmIfVpcRpOperEntry=atmIfVpcRpOperEntry, aRtgPnniRfRxTdpIndex=aRtgPnniRfRxTdpIndex, aRtgPnniCfgNodeRowStatusTable=aRtgPnniCfgNodeRowStatusTable, atmIfVptVccDst=atmIfVptVccDst, atmNetworkingCapabilitiesBE01=atmNetworkingCapabilitiesBE01, aRtgDnaRowStatusTable=aRtgDnaRowStatusTable, atmIfVptVccEpOperEntry=atmIfVptVccEpOperEntry, aRtgPnniPglParmsTable=aRtgPnniPglParmsTable, aRtgPnniCfgNodeSAddrStorageType=aRtgPnniCfgNodeSAddrStorageType, aRtgPnniCfgNodeSAddrProvTable=aRtgPnniCfgNodeSAddrProvTable, atmCRRowStatus=atmCRRowStatus, atmIfVpcRpRowStatus=atmIfVpcRpRowStatus, atmNetworkingCapabilitiesBE=atmNetworkingCapabilitiesBE, aRtgPnniCfgNodeComponentName=aRtgPnniCfgNodeComponentName, aRtgPnniPortRowStatus=aRtgPnniPortRowStatus, aRtgPnniCfgNodePeerGroupId=aRtgPnniCfgNodePeerGroupId, aRtgDnaStorageType=aRtgDnaStorageType, aRtgPnniTopNodeAddrRowStatusTable=aRtgPnniTopNodeAddrRowStatusTable, atmIfVpcSrcOperTable=atmIfVpcSrcOperTable, atmIfVccRpNextHopsTable=atmIfVccRpNextHopsTable, atmIfVpcRpRowStatusEntry=atmIfVpcRpRowStatusEntry, atmIfVccRpNextHopsValue=atmIfVccRpNextHopsValue, atmIfVptVccRpIndex=atmIfVptVccRpIndex, atmIfVpcRpStorageType=atmIfVpcRpStorageType, atmIfVccSrcIndex=atmIfVccSrcIndex, atmNetworkingCapabilitiesBE01A=atmNetworkingCapabilitiesBE01A, aRtgPnniCfgNodeDefSAddrStorageType=aRtgPnniCfgNodeDefSAddrStorageType, aRtgPnniRowStatusTable=aRtgPnniRowStatusTable, aRtgPnniCfgNodeNbrPtseAcksTx=aRtgPnniCfgNodeNbrPtseAcksTx, aRtgPnniRfBearerClassBbc=aRtgPnniRfBearerClassBbc, aRtgComponentName=aRtgComponentName, aRtgPnniCfgNodeCurrentLeadershipPriority=aRtgPnniCfgNodeCurrentLeadershipPriority, aRtgPnniCfgNodeSAddr=aRtgPnniCfgNodeSAddr, atmIfVccSrc=atmIfVccSrc, aRtgPnniComponentName=aRtgPnniComponentName, aRtgPnniOverrideDelay=aRtgPnniOverrideDelay, atmIfVccDstStorageType=atmIfVccDstStorageType, aRtgPnniStatsTable=aRtgPnniStatsTable, aRtgPnniRfTransferCapabilityBbc=aRtgPnniRfTransferCapabilityBbc, atmIfVptVccRp=atmIfVptVccRp, aRtgDnaDestInfoStdComponentName=aRtgDnaDestInfoStdComponentName, atmIfVpcSrcRowStatus=atmIfVpcSrcRowStatus, aRtgPnniPortOperEntry=aRtgPnniPortOperEntry, atmIfVccDstOperEntry=atmIfVccDstOperEntry, atmIfVccDstCalledAddress=atmIfVccDstCalledAddress, atmIfVptVccDstRowStatus=atmIfVptVccDstRowStatus, aRtgPnniTopComponentName=aRtgPnniTopComponentName, atmCRDna=atmCRDna, atmCRDnaRowStatusEntry=atmCRDnaRowStatusEntry, atmIfVptVccSrcOperTable=atmIfVptVccSrcOperTable, atmIfVpcRpNextHopsEntry=atmIfVpcRpNextHopsEntry, atmIfVpcDstIndex=atmIfVpcDstIndex, atmIfVccEpRowStatus=atmIfVccEpRowStatus, atmIfVccRpStorageType=atmIfVccRpStorageType, atmIfVptVccSrcLastFailureDiagCode=atmIfVptVccSrcLastFailureDiagCode, atmNetworkingCapabilities=atmNetworkingCapabilities, atmIfVpcDstStorageType=atmIfVpcDstStorageType, atmIfVptVccRpRowStatusTable=atmIfVptVccRpRowStatusTable, atmIfVccSrcState=atmIfVccSrcState, atmIfVptVccSrcCalledVpiVci=atmIfVptVccSrcCalledVpiVci, atmIfVptVccSrcComponentName=atmIfVptVccSrcComponentName, atmIfVptVccEpIndex=atmIfVptVccEpIndex, atmIfVccSrcRowStatusEntry=atmIfVccSrcRowStatusEntry, aRtgPnniTopActiveParentNodeId=aRtgPnniTopActiveParentNodeId, aRtgPnniStorageType=aRtgPnniStorageType, aRtgPnniCfgNodeNbrPtseReqRx=aRtgPnniCfgNodeNbrPtseReqRx, atmIfVptVccDstCallingVpiVci=atmIfVptVccDstCallingVpiVci, aRtgRowStatusEntry=aRtgRowStatusEntry, aRtgPnniOptMetricTable=aRtgPnniOptMetricTable, aRtgPnniCfgNodeNbrRccListEntry=aRtgPnniCfgNodeNbrRccListEntry, atmIfVccEpOperEntry=atmIfVccEpOperEntry, atmIfVpcSrcLastFailureDiagCode=atmIfVpcSrcLastFailureDiagCode, atmIfVptVccDstRowStatusEntry=atmIfVptVccDstRowStatusEntry, aRtgPnniRfBqpTable=aRtgPnniRfBqpTable, aRtgPnniTopologyMemoryExhaustion=aRtgPnniTopologyMemoryExhaustion, aRtgPnniTopNodeAddrStorageType=aRtgPnniTopNodeAddrStorageType, atmIfVpcSrc=atmIfVpcSrc, aRtgPnniCfgNodeNbrPtseRx=aRtgPnniCfgNodeNbrPtseRx, atmIfVptVccDstCallingAddress=atmIfVptVccDstCallingAddress, aRtgPnniOperTable=aRtgPnniOperTable, atmIfVccRpOperEntry=atmIfVccRpOperEntry, aRtgDnaDestInfoRowStatus=aRtgDnaDestInfoRowStatus, aRtgPnniPortStorageType=aRtgPnniPortStorageType)

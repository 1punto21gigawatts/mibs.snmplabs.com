#
# PySNMP MIB module CISCO-CALL-TRACKER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-CALL-TRACKER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:52:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
AbsoluteCounter32, = mibBuilder.importSymbols("DIAL-CONTROL-MIB", "AbsoluteCounter32")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Bits, Unsigned32, MibIdentifier, Counter64, Integer32, TimeTicks, Gauge32, Counter32, NotificationType, ModuleIdentity, iso, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Unsigned32", "MibIdentifier", "Counter64", "Integer32", "TimeTicks", "Gauge32", "Counter32", "NotificationType", "ModuleIdentity", "iso", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity")
DisplayString, TimeStamp, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TimeStamp", "TextualConvention", "TruthValue")
ciscoCallTrackerMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 163))
ciscoCallTrackerMIB.setRevisions(('2005-04-12 00:00', '2004-02-02 00:00', '2000-02-10 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoCallTrackerMIB.setRevisionsDescriptions(('[1] CctCallCategory - added syncData [2] CctCallCategory - added lapb-ta [3] Added new textual convention CctCallSigType [4] Added cctActiveCallSignalingType to cctActiveTable [5] Added cctHistoryCallSignalingType to cctHistoryTable ', 'Included mgcpData in CctCallCategory.', 'Initial version of this MIB.',))
if mibBuilder.loadTexts: ciscoCallTrackerMIB.setLastUpdated('200504120000Z')
if mibBuilder.loadTexts: ciscoCallTrackerMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoCallTrackerMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W. Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-dial@cisco.com')
if mibBuilder.loadTexts: ciscoCallTrackerMIB.setDescription('This MIB module provides information for tracking the progress and status of a data call from the hardware layer through the application or service layer. A data call is a call setup via a signaling protocol (e.g., ISDN D Channel signaling) on the Public Switching Telephony Network to a Network Access Server in order to transfer data, either as a byte stream (e.g., terminal emulation) or in a packet format (e.g., PPP packets) from a data terminal (e.g., Personal Computer) to a data network (e.g., Internet). ')
class CctCallId(TextualConvention, Unsigned32):
    description = 'Represents a Call Identifier. The call identifier is a monotonically assigned, positive integer which uniquely identifies the call within the system. '
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class CctServiceType(TextualConvention, Integer32):
    description = 'Represents possible service types. none - No service associated with call. other - Service active, but none of the following. slip - Serial Line IP ppp - PPP mp - Multilink PPP (RFC 1990) tcpClear - Byte stream over TCP telnet - TELNET exec - terminal server l2f - Virtual Private Data Network service (VPDN) using Layer 2 Forwarding protocol l2tp - Virtual Private Data Network service (VPDN) using Layer 2 Tunneling Protocol '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("none", 1), ("other", 2), ("slip", 3), ("ppp", 4), ("mp", 5), ("tcpClear", 6), ("telnet", 7), ("exec", 8), ("l2f", 9), ("l2tp", 10))

class CctCallCategory(TextualConvention, Integer32):
    description = 'Represents possible call categories or types. none - No call category associated with call other - None of the following modem - Modem call isdn-sync - ISDN sync digital call Now mapped to syncData v110 - V110 Call v120 - V120 Call cas-digital - Channel Associated Signaling (CAS) 56k data call mgcpData - MGCP data call Now mapped to syncData syncData - Sync digital data call for any call control lapb-ta - LAPB or LAPB-TA call '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("none", 1), ("other", 2), ("modem", 3), ("isdnSync", 4), ("v110", 5), ("v120", 6), ("casDigital", 7), ("mgcpData", 8), ("syncData", 9), ("lapb-ta", 10))

class CctCallSigType(TextualConvention, Integer32):
    description = 'Represents supported signaling types for a call. Unknown - Signaling origin of call type unknown. External - Signaling origin of call type by external agent e.g. MGCP, H.248 Q931 - Signaling origin of call type by Q.931/ISDN Autodetect - Signaling of call type by automatic detection '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("external", 2), ("q931", 3), ("autoDetect", 4))

cctMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 1))
cctGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 1))
cctActive = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2))
cctHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3))
cctNotificationConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 4))
cctCallIdPrefix = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctCallIdPrefix.setStatus('current')
if mibBuilder.loadTexts: cctCallIdPrefix.setDescription('This object may be used in conjunction with objects of type CctCallId to provide call references which are unique across system re-initializations. This value is generated at system re-initialization. It is a 32-bit random number, with very low likely-hood of repeating within the lifetime of the system. ')
cctActiveTableNumberEntries = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveTableNumberEntries.setStatus('current')
if mibBuilder.loadTexts: cctActiveTableNumberEntries.setDescription('The number of entries currently in the cctActiveTable. ')
cctActiveTableHighWaterMark = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveTableHighWaterMark.setStatus('current')
if mibBuilder.loadTexts: cctActiveTableHighWaterMark.setDescription('Maximum number of entries present in cctActiveTable since last system re-initialization. This corresponds to the maximum value reported by cctActiveTableNumberEntries. ')
cctActiveTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3), )
if mibBuilder.loadTexts: cctActiveTable.setStatus('current')
if mibBuilder.loadTexts: cctActiveTable.setDescription('This table contains entries for active calls in the system. All such calls either originate or terminate at this system. The table is indexed by call ID assigned to the call. ')
cctActiveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-CALL-TRACKER-MIB", "cctActiveCallId"))
if mibBuilder.loadTexts: cctActiveEntry.setStatus('current')
if mibBuilder.loadTexts: cctActiveEntry.setDescription('The information regarding a single call. Entries are created when a setup request is first received by the system. Entries are removed when a call is terminated or rejected. A corresponding entry is created in the cctHistoryTable. ')
cctActiveCallId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 1), CctCallId())
if mibBuilder.loadTexts: cctActiveCallId.setStatus('current')
if mibBuilder.loadTexts: cctActiveCallId.setDescription('Represents a Call Identifier. The call identifier is a monotonically increasing unsigned integer which uniquely identifies the call within the system. The Call ID is represented as an unsigned 32-bit integer. After 4,294,967,295 calls, the ID will wrap and the 4,294,967,296th call will receive the next smallest available id starting from 1. Zero is not a valid value. ')
cctActiveSetupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveSetupTime.setStatus('current')
if mibBuilder.loadTexts: cctActiveSetupTime.setDescription('Value of sysUpTime when the call is first made known to the system. ')
cctActiveOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("originate", 1), ("answer", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveOrigin.setStatus('current')
if mibBuilder.loadTexts: cctActiveOrigin.setDescription('This object indicates how the call was created. originate(1) - The call was initiated locally with the system sending the setup request. Dialout answer(2) - The call was initiated remotely and the system received the setup request. Dialin ')
cctActiveConnectionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveConnectionTime.setStatus('current')
if mibBuilder.loadTexts: cctActiveConnectionTime.setDescription('Value of sysUpTime when the system connected the call. ')
cctActivePhysicalLayerReadyTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActivePhysicalLayerReadyTime.setStatus('current')
if mibBuilder.loadTexts: cctActivePhysicalLayerReadyTime.setDescription('Value of sysUpTime when the physical layer for the call achieved a steady state and the call is ready for higher protocol layers to begin. In the case of modem calls, the physical layer for the call achieves a steady state when the data rates, modulations, and error correcting protocols have been negotiated between the originating and answering modems. This is primarily intended for calls which connect to a processing resource identified by cctActiveResourceSlot and cctActiveResourcePort. It also applies to digital calls using adaptive rate technologies such as V.110 and V.120. ')
cctActiveServiceUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveServiceUpTime.setStatus('current')
if mibBuilder.loadTexts: cctActiveServiceUpTime.setDescription('Value of sysUpTime when the call service type identified in cctActiveServiceType was established. ')
cctActiveServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 7), CctServiceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveServiceType.setStatus('current')
if mibBuilder.loadTexts: cctActiveServiceType.setDescription('Service associated with the call. This is the highest level of service known to the system for the call. The service represents the encapsulation protocol layer active for the call. In the case of multiple services on a given call, the last service activated will be reported. ')
cctActiveUserValidationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveUserValidationTime.setStatus('current')
if mibBuilder.loadTexts: cctActiveUserValidationTime.setDescription('Value of sysUpTime when the user identification associated with this call was validated. See cctActiveUserId for description of user identification. ')
cctActiveUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveUserId.setStatus('current')
if mibBuilder.loadTexts: cctActiveUserId.setDescription('The User login ID or zero length string if unavailable. ')
cctActiveUserIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveUserIpAddr.setStatus('current')
if mibBuilder.loadTexts: cctActiveUserIpAddr.setDescription('The IP address assigned to the cctActiveUserId for this call or 0.0.0.0 if not applicable or unavailable. ')
cctActiveUserSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveUserSubnetMask.setStatus('current')
if mibBuilder.loadTexts: cctActiveUserSubnetMask.setDescription('The IP subnet mask assigned to the cctActiveUserId for this call or 0.0.0.0 if not applicable or unavailable. ')
cctActiveAccountingSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveAccountingSessionId.setReference('RFC 2139 RADIUS Accounting The TACACS+ Protocol Version 1.78, Internet Draft ')
if mibBuilder.loadTexts: cctActiveAccountingSessionId.setStatus('current')
if mibBuilder.loadTexts: cctActiveAccountingSessionId.setDescription('Accounting session identification assigned to this call by AAA. The session ID is sent by AAA to RADIUS as the Acct-Session-Id attribute or TACACS+ as the task_id. If no accounting session ID is assigned, the value is a null string. ')
cctActiveCallCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 13), CctCallCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveCallCategory.setStatus('current')
if mibBuilder.loadTexts: cctActiveCallCategory.setDescription('The call category or type ')
cctActiveInitialRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 14), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveInitialRxRate.setStatus('current')
if mibBuilder.loadTexts: cctActiveInitialRxRate.setDescription('Initial receive data rate for this call. If call is a synchronous digital call such as ISDN sync, this value is the data rate of the B-channel. If call is asynchronous, even if using a synchronous transmission medium such as ISDN, the value is determined by the resource providing the asynchronous processing. For modem calls, this value corresponds to the value of cmRXRate from CISCO-MODEM-MGMT-MIB, immediately after the modem has completed initial negotiations. This value does not change, even if the data rate varies during the call. This value will be zero until an initial data rate has been determined. ')
cctActiveInitialTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 15), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveInitialTxRate.setStatus('current')
if mibBuilder.loadTexts: cctActiveInitialTxRate.setDescription('Initial transmit data rate for this call. If call is a synchronous digital call such as ISDN sync, this value is the data rate of the B-channel. If call is asynchronous, even if using a synchronous transmission medium such as ISDN, the value is determined by the resource providing the asynchronous processing. For modem calls, this value corresponds to the value of cmTXRate from CISCO-MODEM-MGMT-MIB, immediately after the modem has completed initial negotiations. This value does not change, even if the data rate varies during the call. This value will be zero until an initial data rate has been determined. ')
cctActiveResourceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveResourceSlot.setStatus('current')
if mibBuilder.loadTexts: cctActiveResourceSlot.setDescription('Identification of the processing resource allocated to the call. In the case of a call requiring a modem resource, this is the value of cmSlotIndex from CISCO-MODEM-MGMT-MIB. This value along with cctActiveResourcePort uniquely identifies a resource port. Value is -1 if call does not utilize such a resource. ')
cctActiveResourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveResourcePort.setStatus('current')
if mibBuilder.loadTexts: cctActiveResourcePort.setDescription('Identification of the processing resource allocated to the call. In the case of a call requiring a modem resource, this is the value of cmPortIndex from CISCO-MODEM-MGMT-MIB. This value along with cctActiveResourceSlot uniquely identifies a resource port. Value is -1 if call does not utilize such a resource. ')
cctActiveEntrySlot = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveEntrySlot.setStatus('current')
if mibBuilder.loadTexts: cctActiveEntrySlot.setDescription('The device slot containing the port on which the call exists. ')
cctActiveEntryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveEntryPort.setStatus('current')
if mibBuilder.loadTexts: cctActiveEntryPort.setDescription('The physical port within the device slot on which the call exists. ')
cctActiveEntryDs1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveEntryDs1.setStatus('current')
if mibBuilder.loadTexts: cctActiveEntryDs1.setDescription('The DS1 link containing the call. This may be a DS1 contained within a larger grouping of multiple DS1s within a single physical port. If the physical port is of type DS1, this value is identical to cctActiveEntryPort. If the DS1 is a logical subinterface within the physical port, this value is the number of the DS1 within this slot. Examples: 8 port DS1 card - cctActiveEntryPort and cctActiveEntryDs1 will have identical values. 3 port T3 card - cctActiveEntryPort represents T3 ports. cctActiveEntryEntryDs1 represents logical T1 interfaces. Each T3 contains 28 T1 interfaces. The T1 interfaces are numbered sequentially across the entire T3 card. ')
cctActiveEntryChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveEntryChannel.setStatus('current')
if mibBuilder.loadTexts: cctActiveEntryChannel.setDescription('The channel or timeslot within the cctActiveEntryDs1 allocated to the call. ')
cctActiveCalledPartyId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveCalledPartyId.setStatus('current')
if mibBuilder.loadTexts: cctActiveCalledPartyId.setDescription('The called telephone number for this call. For calls answered by the system, this corresponds to the Dialed Number Identification (DNIS). For calls originated by the system, this is the destination number. If not available this is a zero-length string. ')
cctActiveCallingPartyId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveCallingPartyId.setStatus('current')
if mibBuilder.loadTexts: cctActiveCallingPartyId.setDescription('The calling telephone number for this call. For calls answered by the system, this corresponds to the calling identification (CLID). For calls originated by the system, this is the number associated with the device. For the interworking call, this object contains the translated calling party number if there is a translation rule is associated with dial plan for making this outgoing call. If not available this is a zero-length string. ')
cctActiveMpBundleId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 24), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveMpBundleId.setStatus('current')
if mibBuilder.loadTexts: cctActiveMpBundleId.setDescription("Multilink PPP bundle identification for call if cctActiveServiceType has the value 'mp'. If the value of cctActiveServiceType for this call is not 'mp', then the value of this object is not meaningful. ")
cctActiveChargedUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 25), AbsoluteCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveChargedUnits.setReference('AOC-D defined in ETSI Standard: ETS 300 179 ')
if mibBuilder.loadTexts: cctActiveChargedUnits.setStatus('current')
if mibBuilder.loadTexts: cctActiveChargedUnits.setDescription('The number of charged units for this connection. For incoming calls or if charging information is not supplied by the switch, the value of this object will be zero. ')
cctActiveReceiveBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 26), AbsoluteCounter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveReceiveBytes.setStatus('current')
if mibBuilder.loadTexts: cctActiveReceiveBytes.setDescription("The number of bytes received on the call. All the 'raw' bytes are counted including any protocol headers which may or may not be present depending on the value of cctActiveServiceType. ")
cctActiveTransmitBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 27), AbsoluteCounter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveTransmitBytes.setStatus('current')
if mibBuilder.loadTexts: cctActiveTransmitBytes.setDescription("The number of bytes transmitted on the call. All the 'raw' bytes are counted including any protocol headers which may or may not be present depending on the value of cctActiveServiceType. ")
cctActiveCallSignalingType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 2, 3, 1, 28), CctCallSigType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctActiveCallSignalingType.setStatus('current')
if mibBuilder.loadTexts: cctActiveCallSignalingType.setDescription('Signaling type used to setup the call. ')
cctHistoryTableEntriesLimit = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cctHistoryTableEntriesLimit.setStatus('current')
if mibBuilder.loadTexts: cctHistoryTableEntriesLimit.setDescription('The upper limit on the number of entries that the cctHistoryTable may contain. A value of zero will prevent any history from being retained. This value may not exceed the system specific limit provided in cctHistoryTableMaxEntries. ')
cctHistoryTableMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryTableMaxEntries.setStatus('current')
if mibBuilder.loadTexts: cctHistoryTableMaxEntries.setDescription('The maximum allowed table length supported by this system. The value of cctHistoryTableEntriesLimit may not exceed this value. ')
cctHistoryTableRetainTimer = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cctHistoryTableRetainTimer.setStatus('current')
if mibBuilder.loadTexts: cctHistoryTableRetainTimer.setDescription('The maximum amount of time that an entry will be maintained within the cctHistoryTable before being deleted. A value of zero will prevent any history from being retained. ')
cctHistoryTableNumberEntries = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryTableNumberEntries.setStatus('current')
if mibBuilder.loadTexts: cctHistoryTableNumberEntries.setDescription('Count of the number of entries currently in the cctHistoryTable. ')
cctHistoryTableHighWaterMark = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryTableHighWaterMark.setStatus('current')
if mibBuilder.loadTexts: cctHistoryTableHighWaterMark.setDescription('Maximum number of entries present in cctHistoryTable since last system re-initialization or the value of cctHistoryTableEntriesLimit has been changed. This corresponds to the maximum value reported by cctHistoryTableNumberEntries. Changing the value of cctHistoryTableEntriesLimit resets this value to zero. ')
cctHistoryTableNewestIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryTableNewestIndex.setStatus('current')
if mibBuilder.loadTexts: cctHistoryTableNewestIndex.setDescription('This object provides the index value of the most recent entry currently in the cctHistoryTable. A value of zero indicates there has never been an entry in the table or all entries have expired. ')
cctHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7), )
if mibBuilder.loadTexts: cctHistoryTable.setStatus('current')
if mibBuilder.loadTexts: cctHistoryTable.setDescription('This table provides information on terminated calls. ')
cctHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1), ).setIndexNames((0, "CISCO-CALL-TRACKER-MIB", "cctHistoryIndex"))
if mibBuilder.loadTexts: cctHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: cctHistoryEntry.setDescription('The information regarding a single terminated call. An entry of this table is created when the system initiates, detects, or is notified of a call termination. Resources allocated to the call may still be in use by the call when the entry is created. An entry is deleted when it has existed in this table longer than cctHistoryTableRetainTimer minutes. An entry is also removed if the table is full and a new entry needs to be created to accommodate a terminated call. The oldest entry in the table will be deleted. ')
cctHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cctHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: cctHistoryIndex.setDescription('A monotonically increasing integer for the sole purpose of indexing terminated calls. When it reaches the maximum value the agent wraps the value back to 1 and will flush existing entries.')
cctHistoryCallId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 2), CctCallId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryCallId.setStatus('current')
if mibBuilder.loadTexts: cctHistoryCallId.setDescription('The call identifier for the call. This is the same value assigned to the call in cctActiveCallId when it was in the cctActiveTable. It is possible for two cctHistoryEntry entries to have the same cctHistoryCallId if one very long running call terminates after the cctActiveCallId has wrapped around and is reassigned to a new short lived call. ')
cctHistorySetupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistorySetupTime.setStatus('current')
if mibBuilder.loadTexts: cctHistorySetupTime.setDescription('Value of sysUpTime when the call was first made known to the system. ')
cctHistoryOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("originate", 1), ("answer", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryOrigin.setStatus('current')
if mibBuilder.loadTexts: cctHistoryOrigin.setDescription('This object indicates how the call was created. originate(1) - The call was initiated locally with the system sending the setup request. Dialout answer(2) - The call was initiated remotely and the system received the setup request. Dialin ')
cctHistoryConnectionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryConnectionTime.setStatus('current')
if mibBuilder.loadTexts: cctHistoryConnectionTime.setDescription('Value of sysUpTime when the system connected the call. ')
cctHistoryPhysicalLayerReadyTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryPhysicalLayerReadyTime.setStatus('current')
if mibBuilder.loadTexts: cctHistoryPhysicalLayerReadyTime.setDescription('Value of sysUpTime when the physical layer for the call achieved a steady state and the call is ready for higher protocol layers to begin. In the case of modem calls, the physical layer for the call achieves a steady state when the data rates, modulations, and error correcting protocols have been negotiated between the originating and answering modems. This is primarily intended for calls which connect to a processing resource identified by cctHistoryResourceSlot and cctHistoryResourcePort. It also applies to digital calls using adaptive rate technologies such as V.110 and V.120. ')
cctHistoryServiceUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryServiceUpTime.setStatus('current')
if mibBuilder.loadTexts: cctHistoryServiceUpTime.setDescription('Value of sysUpTime when the call service type identified in cctHistoryServiceType was established. ')
cctHistoryServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 8), CctServiceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryServiceType.setStatus('current')
if mibBuilder.loadTexts: cctHistoryServiceType.setDescription('Service associated with the call. This is the highest level of service known to the system for the call. The service represents the encapsulation protocol layer active for the call. In the case of multiple services on a given call, the last service activated will be reported. ')
cctHistoryUserValidationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryUserValidationTime.setStatus('current')
if mibBuilder.loadTexts: cctHistoryUserValidationTime.setDescription('Value of sysUpTime when the user identification associated with this call was validated. See cctHistoryUserId for description of user identification. ')
cctHistoryUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryUserId.setStatus('current')
if mibBuilder.loadTexts: cctHistoryUserId.setDescription('The User login ID or zero length string if unavailable. If this contains a non-zero length string, and cctHistoryUserValidationTime is zero, then the user failed validation. ')
cctHistoryUserIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryUserIpAddr.setStatus('current')
if mibBuilder.loadTexts: cctHistoryUserIpAddr.setDescription('The IP address assigned to the cctHistoryUserId for this call or 0.0.0.0 if not applicable or unavailable. ')
cctHistoryUserSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryUserSubnetMask.setStatus('current')
if mibBuilder.loadTexts: cctHistoryUserSubnetMask.setDescription('The IP subnet mask assigned to the cctHistoryUserId for this call or 0.0.0.0 if not applicable or unavailable. ')
cctHistoryAccountingSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryAccountingSessionId.setReference('RFC 2139 RADIUS Accounting The TACACS+ Protocol Version 1.78, Internet Draft ')
if mibBuilder.loadTexts: cctHistoryAccountingSessionId.setStatus('current')
if mibBuilder.loadTexts: cctHistoryAccountingSessionId.setDescription('Accounting session identification assigned to this call by AAA. The session ID is sent by AAA to RADIUS as the Acct-Session-Id attribute or TACACS+ as the task_id. If no accounting session ID is assigned, the value is a null string. ')
cctHistoryCallCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 14), CctCallCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryCallCategory.setStatus('current')
if mibBuilder.loadTexts: cctHistoryCallCategory.setDescription('The call category or type ')
cctHistoryInitialRxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 15), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryInitialRxRate.setStatus('current')
if mibBuilder.loadTexts: cctHistoryInitialRxRate.setDescription('Initial receive data rate for this call. If call is a synchronous digital call such as ISDN sync, this value is the data rate of the B-channel. If call is asynchronous, even if using a synchronous transmission medium such as ISDN, the value is determined by the resource providing the asynchronous processing. For modem calls, this value corresponds to the value of cmRXRate from CISCO-MODEM-MGMT-MIB, immediately after the modem has completed initial negotiations. This value does not change, even if the data rate varies during the call. This value will be zero if the call terminated prior to an initial data rate determination. ')
cctHistoryInitialTxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 16), Unsigned32()).setUnits('bits per second').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryInitialTxRate.setStatus('current')
if mibBuilder.loadTexts: cctHistoryInitialTxRate.setDescription('Initial transmit data rate for this call. If call is a synchronous digital call such as ISDN sync, this value is the data rate of the B-channel. If call is asynchronous, even if using a synchronous transmission medium such as ISDN, the value is determined by the resource providing the asynchronous processing. For modem calls, this value corresponds to the value of cmTXRate from CISCO-MODEM-MGMT-MIB, immediately after the modem has completed initial negotiations. This value does not change, even if the data rate varies during the call. This value will be zero if the call terminated prior to an initial data rate determination. ')
cctHistoryResourceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryResourceSlot.setStatus('current')
if mibBuilder.loadTexts: cctHistoryResourceSlot.setDescription('Identification of processing resource allocated to call. In the case of a call requiring a modem resource, this is the value of cmSlotIndex from CISCO-MODEM-MGMT-MIB. This value along with cctHistoryResourcePort uniquely identifies a resource port. Value is -1 if call does not utilize such a resource. ')
cctHistoryResourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryResourcePort.setStatus('current')
if mibBuilder.loadTexts: cctHistoryResourcePort.setDescription('Identification of processing resource allocated to call. In the case of a call requiring a modem resource, this is the value of cmPortIndex from CISCO-MODEM-MGMT-MIB. This value along with cctHistoryResourceSlot uniquely identifies a resource port. Value is -1 if call does not utilize such a resource. ')
cctHistoryEntrySlot = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryEntrySlot.setStatus('current')
if mibBuilder.loadTexts: cctHistoryEntrySlot.setDescription('The device slot containing the port on which the call existed. ')
cctHistoryEntryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryEntryPort.setStatus('current')
if mibBuilder.loadTexts: cctHistoryEntryPort.setDescription('The physical port within the device slot on which the call existed. ')
cctHistoryEntryDs1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryEntryDs1.setStatus('current')
if mibBuilder.loadTexts: cctHistoryEntryDs1.setDescription('The DS1 link containing the call. This may be a DS1 contained within a larger grouping of multiple DS1s within a single physical port. If the physical port is of type DS1, this value is identical to cctActiveEntryPort. If the DS1 is a logical subinterface within the physical port, this value is the number of the DS1 within this slot. Examples: 8 port DS1 card - cctActiveEntryPort and cctActiveEntryDs1 will have identical values. 3 port T3 card - cctActiveEntryPort represents T3 ports. cctActiveEntryEntryDs1 represents logical T1 interfaces. Each T3 contains 28 T1 interfaces. The T1 interfaces are numbered sequentially across the entire T3 card. ')
cctHistoryEntryChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 214783647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryEntryChannel.setStatus('current')
if mibBuilder.loadTexts: cctHistoryEntryChannel.setDescription('The channel or timeslot within the cctHistoryEntryDs1 which was allocated to the call. ')
cctHistoryCalledPartyId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryCalledPartyId.setStatus('current')
if mibBuilder.loadTexts: cctHistoryCalledPartyId.setDescription('The called telephone number for this call. For calls answered by the system, this corresponds to the Dialed Number Identification (DNIS). For calls originated by the system, this is the destination number. If not available the string length is zero. ')
cctHistoryCallingPartyId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryCallingPartyId.setStatus('current')
if mibBuilder.loadTexts: cctHistoryCallingPartyId.setDescription('The calling telephone number for this call. For calls answered by the system, this corresponds to the calling identification (CLID). For calls originated by the system, this is the number associated with the device. For the interworking call, this object contains the translated calling party number if there is a translation rule is associated with dial plan for making this outgoing call. If not available this is a zero-length string. ')
cctHistoryMpBundleId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryMpBundleId.setStatus('current')
if mibBuilder.loadTexts: cctHistoryMpBundleId.setDescription("Multilink PPP bundle identification for call if cctHistoryServiceType has the value 'mp'. If the value of cctHistoryServiceType for this call is not 'mp', then the value of this object is not meaningful. ")
cctHistoryChargedUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryChargedUnits.setReference('AOC-D defined in ETSI Standard: ETS 300 179 ')
if mibBuilder.loadTexts: cctHistoryChargedUnits.setStatus('current')
if mibBuilder.loadTexts: cctHistoryChargedUnits.setDescription('The number of charged units for this connection. For incoming calls or if charging information is not supplied by the switch, the value of this object will be zero. ')
cctHistoryReceiveBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 28), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryReceiveBytes.setStatus('current')
if mibBuilder.loadTexts: cctHistoryReceiveBytes.setDescription("The number of bytes received on the call. All the 'raw' bytes are counted including any protocol headers which may or may not be present depending on the value of cctHistoryServiceType. ")
cctHistoryTransmitBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 29), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryTransmitBytes.setStatus('current')
if mibBuilder.loadTexts: cctHistoryTransmitBytes.setDescription("The number of bytes transmitted on the call. All the 'raw' bytes are counted including any protocol headers which may or may not be present depending on the value of cctHistoryServiceType. ")
cctHistoryDisconnectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 30), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryDisconnectTime.setStatus('current')
if mibBuilder.loadTexts: cctHistoryDisconnectTime.setDescription('Value of sysUpTime when call was disconnected. This is when the system initiates, detects, or is notified of call termination. This is the call duration from initial setup request. ')
cctHistoryDisconnectReasonText = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryDisconnectReasonText.setStatus('current')
if mibBuilder.loadTexts: cctHistoryDisconnectReasonText.setDescription('Text description of the disconnect reason provided. Value is zero-length string if no text is available. ')
cctHistoryCallSignalingType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 3, 7, 1, 32), CctCallSigType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cctHistoryCallSignalingType.setStatus('current')
if mibBuilder.loadTexts: cctHistoryCallSignalingType.setDescription('Signaling type used to setup the call. ')
cctCallSetupTermNotifyEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 163, 1, 4, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cctCallSetupTermNotifyEnable.setStatus('current')
if mibBuilder.loadTexts: cctCallSetupTermNotifyEnable.setDescription("This variable controls generation of cctCallSetupNotification and cctCallTerminateNotification. When this variable is 'true(1)', generation of these notifications is enabled. When this variable is 'false(2)', generation is disabled. The default value is 'false(2)'. ")
cctMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 2))
cctMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 2, 0))
cctCallSetupNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 163, 2, 0, 1)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctActiveSetupTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCalledPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCallingPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCallCategory"))
if mibBuilder.loadTexts: cctCallSetupNotification.setStatus('current')
if mibBuilder.loadTexts: cctCallSetupNotification.setDescription('A Call Tracker Setup notification is generated whenever a new active call entry is created in the cctActiveTable. ')
cctCallTerminateNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 163, 2, 0, 2)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctHistoryCallId"))
if mibBuilder.loadTexts: cctCallTerminateNotification.setStatus('current')
if mibBuilder.loadTexts: cctCallTerminateNotification.setDescription('A Call Tracker Terminate notification is generated whenever a new history call entry is created in the cctHistoryTable. ')
cctMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 3))
cctMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 1))
cctMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 2))
cctMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 1, 1)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctGeneralGroup"), ("CISCO-CALL-TRACKER-MIB", "cctActiveGroup"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryGroup"), ("CISCO-CALL-TRACKER-MIB", "cctNotificationConfigGroup"), ("CISCO-CALL-TRACKER-MIB", "cctNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctMIBCompliance = cctMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: cctMIBCompliance.setDescription('The compliance statement for entities which implement the CISCO CALL TRACKER MIB')
cctMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 1, 2)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctGeneralGroup"), ("CISCO-CALL-TRACKER-MIB", "cctActiveGroupRev1"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryGroupRev1"), ("CISCO-CALL-TRACKER-MIB", "cctNotificationConfigGroup"), ("CISCO-CALL-TRACKER-MIB", "cctNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctMIBComplianceRev1 = cctMIBComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: cctMIBComplianceRev1.setDescription('The compliance statement for entities which implement the CISCO CALL TRACKER MIB')
cctGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 2, 1)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctCallIdPrefix"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctGeneralGroup = cctGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: cctGeneralGroup.setDescription('A collection of objects providing the general information. ')
cctActiveGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 2, 2)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctActiveTableNumberEntries"), ("CISCO-CALL-TRACKER-MIB", "cctActiveTableHighWaterMark"), ("CISCO-CALL-TRACKER-MIB", "cctActiveSetupTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveOrigin"), ("CISCO-CALL-TRACKER-MIB", "cctActiveConnectionTime"), ("CISCO-CALL-TRACKER-MIB", "cctActivePhysicalLayerReadyTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveServiceUpTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveServiceType"), ("CISCO-CALL-TRACKER-MIB", "cctActiveUserValidationTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveUserId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveUserIpAddr"), ("CISCO-CALL-TRACKER-MIB", "cctActiveUserSubnetMask"), ("CISCO-CALL-TRACKER-MIB", "cctActiveAccountingSessionId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCallCategory"), ("CISCO-CALL-TRACKER-MIB", "cctActiveInitialRxRate"), ("CISCO-CALL-TRACKER-MIB", "cctActiveInitialTxRate"), ("CISCO-CALL-TRACKER-MIB", "cctActiveResourceSlot"), ("CISCO-CALL-TRACKER-MIB", "cctActiveResourcePort"), ("CISCO-CALL-TRACKER-MIB", "cctActiveEntrySlot"), ("CISCO-CALL-TRACKER-MIB", "cctActiveEntryPort"), ("CISCO-CALL-TRACKER-MIB", "cctActiveEntryDs1"), ("CISCO-CALL-TRACKER-MIB", "cctActiveEntryChannel"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCalledPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCallingPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveMpBundleId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveChargedUnits"), ("CISCO-CALL-TRACKER-MIB", "cctActiveReceiveBytes"), ("CISCO-CALL-TRACKER-MIB", "cctActiveTransmitBytes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctActiveGroup = cctActiveGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cctActiveGroup.setDescription('A collection of objects providing the active call information. ')
cctHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 2, 3)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctHistoryTableEntriesLimit"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableMaxEntries"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableRetainTimer"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableNumberEntries"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableHighWaterMark"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableNewestIndex"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCallId"), ("CISCO-CALL-TRACKER-MIB", "cctHistorySetupTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryOrigin"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryConnectionTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryPhysicalLayerReadyTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryServiceUpTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryServiceType"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryUserValidationTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryUserId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryUserIpAddr"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryUserSubnetMask"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryAccountingSessionId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCallCategory"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryInitialRxRate"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryInitialTxRate"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryResourceSlot"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryResourcePort"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryEntrySlot"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryEntryPort"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryEntryDs1"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryEntryChannel"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCalledPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCallingPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryMpBundleId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryChargedUnits"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryReceiveBytes"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTransmitBytes"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryDisconnectTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryDisconnectReasonText"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctHistoryGroup = cctHistoryGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cctHistoryGroup.setDescription('A collection of objects providing the historical call information. ')
cctNotificationConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 2, 4)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctCallSetupTermNotifyEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctNotificationConfigGroup = cctNotificationConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cctNotificationConfigGroup.setDescription('A collection of objects providing the notification configuration. ')
cctNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 2, 5)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctCallSetupNotification"), ("CISCO-CALL-TRACKER-MIB", "cctCallTerminateNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctNotificationGroup = cctNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: cctNotificationGroup.setDescription('The collection of notifications used for call status changes. ')
cctActiveGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 2, 6)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctActiveTableNumberEntries"), ("CISCO-CALL-TRACKER-MIB", "cctActiveTableHighWaterMark"), ("CISCO-CALL-TRACKER-MIB", "cctActiveSetupTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveOrigin"), ("CISCO-CALL-TRACKER-MIB", "cctActiveConnectionTime"), ("CISCO-CALL-TRACKER-MIB", "cctActivePhysicalLayerReadyTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveServiceUpTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveServiceType"), ("CISCO-CALL-TRACKER-MIB", "cctActiveUserValidationTime"), ("CISCO-CALL-TRACKER-MIB", "cctActiveUserId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveUserIpAddr"), ("CISCO-CALL-TRACKER-MIB", "cctActiveUserSubnetMask"), ("CISCO-CALL-TRACKER-MIB", "cctActiveAccountingSessionId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCallCategory"), ("CISCO-CALL-TRACKER-MIB", "cctActiveInitialRxRate"), ("CISCO-CALL-TRACKER-MIB", "cctActiveInitialTxRate"), ("CISCO-CALL-TRACKER-MIB", "cctActiveResourceSlot"), ("CISCO-CALL-TRACKER-MIB", "cctActiveResourcePort"), ("CISCO-CALL-TRACKER-MIB", "cctActiveEntrySlot"), ("CISCO-CALL-TRACKER-MIB", "cctActiveEntryPort"), ("CISCO-CALL-TRACKER-MIB", "cctActiveEntryDs1"), ("CISCO-CALL-TRACKER-MIB", "cctActiveEntryChannel"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCalledPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCallingPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveMpBundleId"), ("CISCO-CALL-TRACKER-MIB", "cctActiveChargedUnits"), ("CISCO-CALL-TRACKER-MIB", "cctActiveReceiveBytes"), ("CISCO-CALL-TRACKER-MIB", "cctActiveTransmitBytes"), ("CISCO-CALL-TRACKER-MIB", "cctActiveCallSignalingType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctActiveGroupRev1 = cctActiveGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cctActiveGroupRev1.setDescription('A collection of objects providing the active call information. ')
cctHistoryGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 163, 3, 2, 7)).setObjects(("CISCO-CALL-TRACKER-MIB", "cctHistoryTableEntriesLimit"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableMaxEntries"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableRetainTimer"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableNumberEntries"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableHighWaterMark"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTableNewestIndex"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCallId"), ("CISCO-CALL-TRACKER-MIB", "cctHistorySetupTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryOrigin"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryConnectionTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryPhysicalLayerReadyTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryServiceUpTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryServiceType"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryUserValidationTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryUserId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryUserIpAddr"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryUserSubnetMask"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryAccountingSessionId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCallCategory"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryInitialRxRate"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryInitialTxRate"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryResourceSlot"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryResourcePort"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryEntrySlot"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryEntryPort"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryEntryDs1"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryEntryChannel"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCalledPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCallingPartyId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryMpBundleId"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryChargedUnits"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryReceiveBytes"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryTransmitBytes"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryDisconnectTime"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryDisconnectReasonText"), ("CISCO-CALL-TRACKER-MIB", "cctHistoryCallSignalingType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cctHistoryGroupRev1 = cctHistoryGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cctHistoryGroupRev1.setDescription('A collection of objects providing the historical call information. ')
mibBuilder.exportSymbols("CISCO-CALL-TRACKER-MIB", cctHistoryGroupRev1=cctHistoryGroupRev1, cctHistoryEntryPort=cctHistoryEntryPort, cctHistoryInitialTxRate=cctHistoryInitialTxRate, cctHistoryUserIpAddr=cctHistoryUserIpAddr, cctMIBNotificationPrefix=cctMIBNotificationPrefix, cctActiveResourcePort=cctActiveResourcePort, cctActiveSetupTime=cctActiveSetupTime, cctHistory=cctHistory, cctHistoryCallId=cctHistoryCallId, cctMIBGroups=cctMIBGroups, cctHistoryEntrySlot=cctHistoryEntrySlot, cctHistoryServiceUpTime=cctHistoryServiceUpTime, cctActiveOrigin=cctActiveOrigin, cctHistoryUserValidationTime=cctHistoryUserValidationTime, cctHistoryIndex=cctHistoryIndex, cctHistoryTableHighWaterMark=cctHistoryTableHighWaterMark, cctNotificationConfig=cctNotificationConfig, CctCallSigType=CctCallSigType, cctHistoryTableNumberEntries=cctHistoryTableNumberEntries, cctHistoryCallSignalingType=cctHistoryCallSignalingType, cctMIBNotifications=cctMIBNotifications, cctGeneralGroup=cctGeneralGroup, cctHistoryEntry=cctHistoryEntry, cctActiveTableHighWaterMark=cctActiveTableHighWaterMark, cctActiveCallingPartyId=cctActiveCallingPartyId, cctHistoryEntryChannel=cctHistoryEntryChannel, CctCallCategory=CctCallCategory, cctCallTerminateNotification=cctCallTerminateNotification, cctHistoryCallCategory=cctHistoryCallCategory, cctActiveChargedUnits=cctActiveChargedUnits, cctHistoryCalledPartyId=cctHistoryCalledPartyId, cctActiveEntry=cctActiveEntry, cctActiveServiceType=cctActiveServiceType, cctActiveTableNumberEntries=cctActiveTableNumberEntries, cctActiveTable=cctActiveTable, cctHistoryPhysicalLayerReadyTime=cctHistoryPhysicalLayerReadyTime, cctActiveCallCategory=cctActiveCallCategory, cctHistoryUserId=cctHistoryUserId, cctHistorySetupTime=cctHistorySetupTime, cctActiveGroup=cctActiveGroup, cctHistoryReceiveBytes=cctHistoryReceiveBytes, cctCallSetupNotification=cctCallSetupNotification, cctActiveCallId=cctActiveCallId, cctActiveEntryDs1=cctActiveEntryDs1, cctHistoryTransmitBytes=cctHistoryTransmitBytes, cctActiveGroupRev1=cctActiveGroupRev1, cctActiveServiceUpTime=cctActiveServiceUpTime, cctActiveConnectionTime=cctActiveConnectionTime, cctHistoryAccountingSessionId=cctHistoryAccountingSessionId, ciscoCallTrackerMIB=ciscoCallTrackerMIB, CctServiceType=CctServiceType, cctActiveTransmitBytes=cctActiveTransmitBytes, cctGeneral=cctGeneral, cctHistoryConnectionTime=cctHistoryConnectionTime, CctCallId=CctCallId, cctActivePhysicalLayerReadyTime=cctActivePhysicalLayerReadyTime, cctMIBCompliances=cctMIBCompliances, cctHistoryResourceSlot=cctHistoryResourceSlot, cctActive=cctActive, cctActiveUserId=cctActiveUserId, cctActiveInitialTxRate=cctActiveInitialTxRate, cctActiveResourceSlot=cctActiveResourceSlot, cctMIBCompliance=cctMIBCompliance, cctActiveInitialRxRate=cctActiveInitialRxRate, cctCallSetupTermNotifyEnable=cctCallSetupTermNotifyEnable, cctHistoryDisconnectTime=cctHistoryDisconnectTime, cctMIBConformance=cctMIBConformance, cctHistoryTableRetainTimer=cctHistoryTableRetainTimer, cctActiveUserValidationTime=cctActiveUserValidationTime, cctNotificationConfigGroup=cctNotificationConfigGroup, cctHistoryUserSubnetMask=cctHistoryUserSubnetMask, cctActiveEntrySlot=cctActiveEntrySlot, cctHistoryChargedUnits=cctHistoryChargedUnits, cctMIBObjects=cctMIBObjects, cctActiveCallSignalingType=cctActiveCallSignalingType, cctHistoryInitialRxRate=cctHistoryInitialRxRate, cctHistoryTableMaxEntries=cctHistoryTableMaxEntries, cctHistoryOrigin=cctHistoryOrigin, cctHistoryGroup=cctHistoryGroup, cctActiveCalledPartyId=cctActiveCalledPartyId, cctNotificationGroup=cctNotificationGroup, cctActiveEntryPort=cctActiveEntryPort, cctHistoryTableEntriesLimit=cctHistoryTableEntriesLimit, cctHistoryResourcePort=cctHistoryResourcePort, cctActiveAccountingSessionId=cctActiveAccountingSessionId, cctHistoryEntryDs1=cctHistoryEntryDs1, cctCallIdPrefix=cctCallIdPrefix, cctActiveUserIpAddr=cctActiveUserIpAddr, cctMIBComplianceRev1=cctMIBComplianceRev1, cctHistoryCallingPartyId=cctHistoryCallingPartyId, cctActiveReceiveBytes=cctActiveReceiveBytes, cctHistoryTableNewestIndex=cctHistoryTableNewestIndex, cctActiveUserSubnetMask=cctActiveUserSubnetMask, cctHistoryTable=cctHistoryTable, cctHistoryDisconnectReasonText=cctHistoryDisconnectReasonText, PYSNMP_MODULE_ID=ciscoCallTrackerMIB, cctHistoryServiceType=cctHistoryServiceType, cctHistoryMpBundleId=cctHistoryMpBundleId, cctActiveMpBundleId=cctActiveMpBundleId, cctActiveEntryChannel=cctActiveEntryChannel)
